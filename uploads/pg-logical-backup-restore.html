<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Shen Yu">
  <meta name="dcterms.date" content="2017-01-01">
  <title>Logical Backup and Restore</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="reveal.js/css/reveal.css">
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="reveal.js/css/theme/solarized.css" id="theme">
  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
  <!--[if lt IE 9]>
  <script src="reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section>
  <h1 class="title">Logical Backup and Restore</h1>
  <h2 class="author">Shen Yu</h2>
  <h3 class="date">2017</h3>
</section>

<section><section id="主要内容" class="titleslide slide level1"><h1>主要内容</h1></section><section id="pg_dump" class="slide level2">
<h1>pg_dump</h1>
<ol type="1">
<li>pg_dump 参数解析</li>
<li>pg_dump 基本流程</li>
<li>pg_dump 中的事务</li>
</ol>
</section><section id="pg_restore" class="slide level2">
<h1>pg_restore</h1>
<ol start="4" type="1">
<li>pg_restore 参数解析</li>
<li>pg_restore 基本流程</li>
<li>pg_restore 中的事务</li>
</ol>
</section></section>
<section><section id="什么是逻辑logical备份还原" class="titleslide slide level1"><h1>什么是逻辑(Logical)备份还原</h1></section><section id="逻辑备份" class="slide level2">
<h1>逻辑备份</h1>
<p>逻辑备份是在联机状态下通过读取数据库中用户创建的数据对象信息，通过SQL方式，从数据库中抽取出各个对象的定义和数据信息到备份文件中。</p>
</section><section id="逻辑还原" class="slide level2">
<h1>逻辑还原</h1>
<p>逻辑还原是通过执行备份文件中SQL语句，重建数据库对象。</p>
</section></section>
<section><section id="pg_dump-参数解析" class="titleslide slide level1"><h1>pg_dump 参数解析</h1></section><section id="help" class="slide level2">
<h1>help</h1>
<pre class="shell"><code>$ ./pg_dump --help</code></pre>
<pre><code>pg_dump dumps a database as a text file or to other formats.

Usage:
  pg_dump [OPTION]... [DBNAME]

General options:
  -f, --file=FILENAME          output file or directory name
  -F, --format=c|d|t|p         output file format (custom, directory, tar,
                               plain text (default))
  -j, --jobs=NUM               use this many parallel jobs to dump
  -v, --verbose                verbose mode
  -V, --version                output version information, then exit
  -Z, --compress=0-9           compression level for compressed formats
  --lock-wait-timeout=TIMEOUT  fail after waiting TIMEOUT for a table lock
  -?, --help                   show this help, then exit

Options controlling the output content:
  -a, --data-only              dump only the data, not the schema
  -b, --blobs                  include large objects in dump
  -B, --no-blobs               exclude large objects in dump
  -c, --clean                  clean (drop) database objects before recreating
  -C, --create                 include commands to create database in dump
  -E, --encoding=ENCODING      dump the data in encoding ENCODING
  -n, --schema=SCHEMA          dump the named schema(s) only
  -N, --exclude-schema=SCHEMA  do NOT dump the named schema(s)
  -o, --oids                   include OIDs in dump
  -O, --no-owner               skip restoration of object ownership in
                               plain-text format
  -s, --schema-only            dump only the schema, no data
  -S, --superuser=NAME         superuser user name to use in plain-text format
  -t, --table=TABLE            dump the named table(s) only
  -T, --exclude-table=TABLE    do NOT dump the named table(s)
  -x, --no-privileges          do not dump privileges (grant/revoke)
  --binary-upgrade             for use by upgrade utilities only
  --column-inserts             dump data as INSERT commands with column names
  --disable-dollar-quoting     disable dollar quoting, use SQL standard quoting
  --disable-triggers           disable triggers during data-only restore
  --enable-row-security        enable row security (dump only content user has
                               access to)
  --exclude-table-data=TABLE   do NOT dump data for the named table(s)
  --if-exists                  use IF EXISTS when dropping objects
  --inserts                    dump data as INSERT commands, rather than COPY
  --no-security-labels         do not dump security label assignments
  --no-synchronized-snapshots  do not use synchronized snapshots in parallel jobs
  --no-tablespaces             do not dump tablespace assignments
  --no-unlogged-table-data     do not dump unlogged table data
  --quote-all-identifiers      quote all identifiers, even if not key words
  --section=SECTION            dump named section (pre-data, data, or post-data)
  --serializable-deferrable    wait until the dump can run without anomalies
  --snapshot=SNAPSHOT          use given snapshot for the dump
  --strict-names               require table and/or schema include patterns to
                               match at least one entity each
  --use-set-session-authorization
                               use SET SESSION AUTHORIZATION commands instead of
                               ALTER OWNER commands to set ownership

Connection options:
  -d, --dbname=DBNAME      database to dump
  -h, --host=HOSTNAME      database server host or socket directory
  -p, --port=PORT          database server port number
  -U, --username=NAME      connect as specified database user
  -w, --no-password        never prompt for password
  -W, --password           force password prompt (should happen automatically)
  --role=ROLENAME          do SET ROLE before dump

If no database name is supplied, then the PGDATABASE environment
variable value is used.

Report bugs to &lt;pgsql-bugs@postgresql.org&gt;.

</code></pre>
</section><section id="备份为sql形式" class="slide level2">
<h1>备份为sql形式</h1>
<pre><code>默认是备份为sql的形式，输出为stdout，可以把输出指向另一个postgres实例来实现数据库迁移。这样实现类似远程同步的功能。
                              pg_dump
postgres1  ------------------------------------------&gt; postgres2
$ ./pg_dump -hlocalhost -p5432  postgres</code></pre>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql">$ ./pg_dump -hlocalhost -p5432  postgres
<span class="co">--</span>
<span class="co">-- PostgreSQL database dump</span>
<span class="co">--</span>

<span class="co">-- Dumped from database version 10devel</span>
<span class="co">-- Dumped by pg_dump version 10devel</span>

<span class="kw">SET</span> statement_timeout = <span class="dv">0</span>;
<span class="kw">SET</span> lock_timeout = <span class="dv">0</span>;
<span class="kw">SET</span> idle_in_transaction_session_timeout = <span class="dv">0</span>;
<span class="kw">SET</span> client_encoding = <span class="st">&#39;UTF8&#39;</span>;
<span class="kw">SET</span> standard_conforming_strings = <span class="kw">on</span>;
<span class="kw">SET</span> check_function_bodies = <span class="kw">false</span>;
<span class="kw">SET</span> client_min_messages = warning;
<span class="kw">SET</span> row_security = <span class="kw">off</span>;

<span class="co">--</span>
<span class="co">-- Name: postgres; Type: COMMENT; Schema: -; Owner: yshen</span>
<span class="co">--</span>

<span class="kw">COMMENT</span> <span class="kw">ON</span> <span class="kw">DATABASE</span> postgres <span class="kw">IS</span> <span class="st">&#39;default administrative connection database&#39;</span>;


<span class="co">--</span>
<span class="co">-- Name: plpgsql; Type: EXTENSION; Schema: -; Owner: </span>
<span class="co">--</span>

<span class="kw">CREATE</span> EXTENSION <span class="kw">IF</span> <span class="kw">NOT</span> <span class="kw">EXISTS</span> plpgsql <span class="kw">WITH</span> <span class="kw">SCHEMA</span> pg_catalog;


<span class="co">--</span>
<span class="co">-- Name: EXTENSION plpgsql; Type: COMMENT; Schema: -; Owner: </span>
<span class="co">--</span>

<span class="kw">COMMENT</span> <span class="kw">ON</span> EXTENSION plpgsql <span class="kw">IS</span> <span class="st">&#39;PL/pgSQL procedural language&#39;</span>;


<span class="kw">SET</span> search_path = <span class="kw">public</span>, pg_catalog;

<span class="kw">SET</span> default_tablespace = <span class="st">&#39;&#39;</span>;

<span class="kw">SET</span> default_with_oids = <span class="kw">false</span>;

<span class="co">--</span>
<span class="co">-- Name: tb1; Type: TABLE; Schema: public; Owner: yshen</span>
<span class="co">--</span>

<span class="kw">CREATE</span> <span class="kw">TABLE</span> tb1 (
    a <span class="dt">integer</span>
);


<span class="kw">ALTER</span> <span class="kw">TABLE</span> tb1 OWNER <span class="kw">TO</span> yshen;

<span class="co">--</span>
<span class="co">-- Name: tb2; Type: TABLE; Schema: public; Owner: yshen</span>
<span class="co">--</span>

<span class="kw">CREATE</span> <span class="kw">TABLE</span> tb2 (
    a <span class="dt">integer</span>
);


<span class="kw">ALTER</span> <span class="kw">TABLE</span> tb2 OWNER <span class="kw">TO</span> yshen;

<span class="co">--</span>
<span class="co">-- Data for Name: tb1; Type: TABLE DATA; Schema: public; Owner: yshen</span>
<span class="co">--</span>

<span class="kw">COPY</span> tb1 (a) <span class="kw">FROM</span> stdin;
<span class="dv">1</span>
<span class="dv">2</span>
\.


<span class="co">--</span>
<span class="co">-- Data for Name: tb2; Type: TABLE DATA; Schema: public; Owner: yshen</span>
<span class="co">--</span>

<span class="kw">COPY</span> tb2 (a) <span class="kw">FROM</span> stdin;
<span class="dv">1</span>
<span class="dv">2</span>
\.


<span class="co">--</span>
<span class="co">-- PostgreSQL database dump complete</span>
<span class="co">--</span>
</code></pre></div>
</section><section id="备份为二进制形式" class="slide level2">
<h1>备份为二进制形式</h1>
<pre><code>$ ./pg_dump -Fc -f dump.dmp  postgres</code></pre>
<p>备份为二进制，那么还原的时候就可以很方便的指定还原选项，比如说只还原某个表。 另外也可以把二进制格式用pg_restore导出为sql格式。</p>
<pre><code>              pg_dump                    pg_restore
postgres1--------------------&gt; custom--------------------&gt;postgres2</code></pre>
</section></section>
<section><section id="pg_dump基本流程" class="titleslide slide level1"><h1>pg_dump基本流程</h1></section><section id="基本流程" class="slide level2">
<h1>基本流程</h1>
<ol type="1">
<li>收集备份对象信息（查询系统表）</li>
<li>拓扑排序</li>
<li>输出（拼接定义，生成toc_entry）</li>
</ol>
</section><section id="基本流程-1" class="slide level2">
<h1>基本流程</h1>
<pre><code>根据备份类型（二进制-F c 即custom|文本-F p 即plain text）来初始化ArchiveHandle结果保存在g_fout全局变量里
调用ConnectDatabase连接数据库，把结果保存在g_conn全局变量中
调用setup_connection来设置很多的连接参数，比如编码等等
BEGIN
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE
    获取备份对象的属性 getXXX相关函数
    对表加锁: LOCK TABLE &quot;PUBLIC&quot;.&quot;TB1&quot; IN ACCESS SHARE MODE （备份过程中不能drop）
    依赖关系拓扑排序
    获取对象数据并输出：COPY &quot;PUBLIC&quot;.&quot;TB1&quot; (&quot;VALUE&quot;)  TO stdout;  dumpXXX相关函数
COMIT</code></pre>
</section><section id="pg_dump的log" class="slide level2">
<h1>pg_dump的log</h1>
<pre><code>$ ./pg_dump -hlocalhost -p5432 --verbose  -Fc  -f ./dmp.dmp  postgres</code></pre>
<pre><code>pg_dump: last built-in OID is 16383
pg_dump: reading extensions
pg_dump: identifying extension members
pg_dump: reading schemas
pg_dump: reading user-defined tables
pg_dump: reading user-defined functions
pg_dump: reading user-defined types
pg_dump: reading procedural languages
pg_dump: reading user-defined aggregate functions
pg_dump: reading user-defined operators
pg_dump: reading user-defined access methods
pg_dump: reading user-defined operator classes
pg_dump: reading user-defined operator families
pg_dump: reading user-defined text search parsers
pg_dump: reading user-defined text search templates
pg_dump: reading user-defined text search dictionaries
pg_dump: reading user-defined text search configurations
pg_dump: reading user-defined foreign-data wrappers
pg_dump: reading user-defined foreign servers
pg_dump: reading default privileges
pg_dump: reading user-defined collations
pg_dump: reading user-defined conversions
pg_dump: reading type casts
pg_dump: reading transforms
pg_dump: reading table inheritance information
pg_dump: reading partition information
pg_dump: reading event triggers
pg_dump: finding extension tables
pg_dump: finding inheritance relationships
pg_dump: finding partition relationships
pg_dump: reading column info for interesting tables
pg_dump: finding the columns and types of table &quot;public.tb1&quot;
pg_dump: finding the columns and types of table &quot;public.tb2&quot;
pg_dump: flagging inherited columns in subtables
pg_dump: reading indexes
pg_dump: reading constraints
pg_dump: reading triggers
pg_dump: reading rewrite rules
pg_dump: reading policies
pg_dump: reading row security enabled for table &quot;public.tb1&quot;
pg_dump: reading policies for table &quot;public.tb1&quot;
pg_dump: reading row security enabled for table &quot;public.tb2&quot;
pg_dump: reading policies for table &quot;public.tb2&quot;
pg_dump: reading partition key information for interesting tables
pg_dump: reading large objects
pg_dump: reading dependency data
pg_dump: saving encoding = UTF8
pg_dump: saving standard_conforming_strings = on
pg_dump: saving database definition
pg_dump: dumping contents of table &quot;public.tb1&quot;
pg_dump: dumping contents of table &quot;public.tb2&quot;
</code></pre>
</section><section id="备份过程中数据库端的log" class="slide level2">
<h1>备份过程中数据库端的log</h1>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="co">--进行了一些基本的设置</span>
LOG:  statement: <span class="kw">SELECT</span> pg_catalog.pg_is_in_recovery()
LOG:  statement: <span class="kw">SET</span> DATESTYLE = ISO
LOG:  statement: <span class="kw">SET</span> INTERVALSTYLE = POSTGRES
LOG:  statement: <span class="kw">SET</span> extra_float_digits <span class="kw">TO</span> <span class="dv">3</span>
LOG:  statement: <span class="kw">SET</span> synchronize_seqscans <span class="kw">TO</span> <span class="kw">off</span>
LOG:  statement: <span class="kw">SET</span> statement_timeout = <span class="dv">0</span>
LOG:  statement: <span class="kw">SET</span> lock_timeout = <span class="dv">0</span>
LOG:  statement: <span class="kw">SET</span> idle_in_transaction_session_timeout = <span class="dv">0</span>
LOG:  statement: <span class="kw">SET</span> row_security = <span class="kw">off</span>
<span class="co">--开启一个事物</span>
LOG:  statement: <span class="kw">BEGIN</span>
LOG:  statement: <span class="kw">SET</span> <span class="kw">TRANSACTION</span> <span class="kw">ISOLATION</span> <span class="kw">LEVEL</span> REPEATABLE <span class="kw">READ</span>, <span class="kw">READ</span> <span class="kw">ONLY</span>
LOG:  statement: <span class="kw">SET</span> search_path = pg_catalog
<span class="co">--开始获取备份对象信息，对应的是pg_dump中的getXXX系列函数</span>
LOG:  statement: <span class="kw">SELECT</span> x.tableoid, x.oid, x.extname, n.nspname, x.extrelocatable, x.extversion, x.extconfig, x.extcondition <span class="kw">FROM</span> pg_extension x <span class="kw">JOIN</span> pg_namespace n <span class="kw">ON</span> n.oid = x.extnamespace
LOG:  statement: <span class="kw">SET</span> search_path = pg_catalog
LOG:  statement: <span class="kw">SELECT</span> classid, objid, refobjid <span class="kw">FROM</span> pg_depend <span class="kw">WHERE</span> refclassid = <span class="st">&#39;pg_extension&#39;</span>:<span class="ch">:regclass</span> <span class="kw">AND</span> deptype = <span class="st">&#39;e&#39;</span> <span class="kw">ORDER</span> <span class="kw">BY</span> <span class="dv">3</span>
LOG:  statement: <span class="kw">SET</span> search_path = pg_catalog
LOG:  statement: <span class="kw">SELECT</span> n.tableoid, n.oid, n.nspname, (<span class="kw">SELECT</span> rolname <span class="kw">FROM</span> pg_catalog.pg_roles <span class="kw">WHERE</span> <span class="kw">oid</span> = nspowner) <span class="kw">AS</span> rolname, (<span class="kw">SELECT</span> pg_catalog.array_agg(acl) <span class="kw">FROM</span> (<span class="kw">SELECT</span> pg_catalog.unnest(<span class="kw">coalesce</span>(n.nspacl,pg_catalog.acldefault(<span class="st">&#39;n&#39;</span>,n.nspowner))) <span class="kw">AS</span> acl <span class="kw">EXCEPT</span> <span class="kw">SELECT</span> pg_catalog.unnest(<span class="kw">coalesce</span>(pip.initprivs,pg_catalog.acldefault(<span class="st">&#39;n&#39;</span>,n.nspowner)))) <span class="kw">as</span> foo) <span class="kw">as</span> nspacl, (<span class="kw">SELECT</span> pg_catalog.array_agg(acl) <span class="kw">FROM</span> (<span class="kw">SELECT</span> pg_catalog.unnest(<span class="kw">coalesce</span>(pip.initprivs,pg_catalog.acldefault(<span class="st">&#39;n&#39;</span>,n.nspowner))) <span class="kw">AS</span> acl <span class="kw">EXCEPT</span> <span class="kw">SELECT</span> pg_catalog.unnest(<span class="kw">coalesce</span>(n.nspacl,pg_catalog.acldefault(<span class="st">&#39;n&#39;</span>,n.nspowner)))) <span class="kw">as</span> foo) <span class="kw">as</span> rnspacl, <span class="kw">NULL</span> <span class="kw">as</span> initnspacl, <span class="kw">NULL</span> <span class="kw">as</span> initrnspacl <span class="kw">FROM</span> pg_namespace n <span class="kw">LEFT</span> <span class="kw">JOIN</span> pg_init_privs pip <span class="kw">ON</span> (n.oid = pip.objoid <span class="kw">AND</span> pip.classoid = <span class="st">&#39;pg_namespace&#39;</span>:<span class="ch">:regclass</span> <span class="kw">AND</span> pip.objsubid = <span class="dv">0</span>) 
LOG:  statement: <span class="kw">SET</span> search_path = pg_catalog
LOG:  statement: <span class="kw">SELECT</span> c.tableoid, c.oid, c.relname, (<span class="kw">SELECT</span> pg_catalog.array_agg(acl) <span class="kw">FROM</span> (<span class="kw">SELECT</span> pg_catalog.unnest(<span class="kw">coalesce</span>(c.relacl,pg_catalog.acldefault(<span class="kw">CASE</span> <span class="kw">WHEN</span> c.relkind = <span class="st">&#39;S&#39;</span> <span class="kw">THEN</span> <span class="st">&#39;s&#39;</span> <span class="kw">ELSE</span> <span class="st">&#39;r&#39;</span> END::<span class="ot">&quot;char&quot;</span>,c.relowner))) <span class="kw">AS</span> acl <span class="kw">EXCEPT</span> <span class="kw">SELECT</span> pg_catalog.unnest(<span class="kw">coalesce</span>(pip.initprivs,pg_catalog.acldefault(<span class="kw">CASE</span> <span class="kw">WHEN</span> c.relkind = <span class="st">&#39;S&#39;</span> <span class="kw">THEN</span> <span class="st">&#39;s&#39;</span> <span class="kw">ELSE</span> <span class="st">&#39;r&#39;</span> END::<span class="ot">&quot;char&quot;</span>,c.relowner)))) <span class="kw">as</span> foo) <span class="kw">AS</span> relacl, (<span class="kw">SELECT</span> pg_catalog.array_agg(acl) <span class="kw">FROM</span> (<span class="kw">SELECT</span> pg_catalog.unnest(<span class="kw">coalesce</span>(pip.initprivs,pg_catalog.acldefault(<span class="kw">CASE</span> <span class="kw">WHEN</span> c.relkind = <span class="st">&#39;S&#39;</span> <span class="kw">THEN</span> <span class="st">&#39;s&#39;</span> <span class="kw">ELSE</span> <span class="st">&#39;r&#39;</span> END::<span class="ot">&quot;char&quot;</span>,c.relowner))) <span class="kw">AS</span> acl <span class="kw">EXCEPT</span> <span class="kw">SELECT</span> pg_catalog.unnest(<span class="kw">coalesce</span>(c.relacl,pg_catalog.acldefault(<span class="kw">CASE</span> <span class="kw">WHEN</span> c.relkind = <span class="st">&#39;S&#39;</span> <span class="kw">THEN</span> <span class="st">&#39;s&#39;</span> <span class="kw">ELSE</span> <span class="st">&#39;r&#39;</span> END::<span class="ot">&quot;char&quot;</span>,c.relowner)))) <span class="kw">as</span> foo) <span class="kw">as</span> rrelacl, <span class="kw">NULL</span> <span class="kw">AS</span> initrelacl, <span class="kw">NULL</span> <span class="kw">as</span> initrrelacl, c.relkind, c.relnamespace, (<span class="kw">SELECT</span> rolname <span class="kw">FROM</span> pg_catalog.pg_roles <span class="kw">WHERE</span> <span class="kw">oid</span> = c.relowner) <span class="kw">AS</span> rolname, c.relchecks, c.relhastriggers, c.relhasindex, c.relhasrules, c.relhasoids, c.relrowsecurity, c.relforcerowsecurity, c.relfrozenxid, c.relminmxid, tc.oid <span class="kw">AS</span> toid, tc.relfrozenxid <span class="kw">AS</span> tfrozenxid, tc.relminmxid <span class="kw">AS</span> tminmxid, c.relpersistence, c.relispopulated, c.relreplident, c.relpages, <span class="kw">CASE</span> <span class="kw">WHEN</span> c.reloftype &lt;&gt; <span class="dv">0</span> <span class="kw">THEN</span> c.reloftype:<span class="ch">:pg_catalog</span>.regtype <span class="kw">ELSE</span> <span class="kw">NULL</span> <span class="kw">END</span> <span class="kw">AS</span> reloftype, d.refobjid <span class="kw">AS</span> owning_tab, d.refobjsubid <span class="kw">AS</span> owning_col, (<span class="kw">SELECT</span> spcname <span class="kw">FROM</span> pg_tablespace t <span class="kw">WHERE</span> t.oid = c.reltablespace) <span class="kw">AS</span> reltablespace, array_remove(array_remove(c.reloptions,<span class="st">&#39;check_option=local&#39;</span>),<span class="st">&#39;check_option=cascaded&#39;</span>) <span class="kw">AS</span> reloptions, <span class="kw">CASE</span> <span class="kw">WHEN</span> <span class="st">&#39;check_option=local&#39;</span> = <span class="kw">ANY</span> (c.reloptions) <span class="kw">THEN</span> <span class="st">&#39;LOCAL&#39;</span>:<span class="ch">:text</span> <span class="kw">WHEN</span> <span class="st">&#39;check_option=cascaded&#39;</span> = <span class="kw">ANY</span> (c.reloptions) <span class="kw">THEN</span> <span class="st">&#39;CASCADED&#39;</span>:<span class="ch">:text</span> <span class="kw">ELSE</span> <span class="kw">NULL</span> <span class="kw">END</span> <span class="kw">AS</span> checkoption, tc.reloptions <span class="kw">AS</span> toast_reloptions, <span class="kw">EXISTS</span> (<span class="kw">SELECT</span> <span class="dv">1</span> <span class="kw">FROM</span> pg_attribute <span class="kw">at</span> <span class="kw">LEFT</span> <span class="kw">JOIN</span> pg_init_privs pip <span class="kw">ON</span> (c.oid = pip.objoid <span class="kw">AND</span> pip.classoid = <span class="st">&#39;pg_class&#39;</span>:<span class="ch">:regclass</span> <span class="kw">AND</span> pip.objsubid = at.attnum)<span class="kw">WHERE</span> at.attrelid = c.oid <span class="kw">AND</span> ((<span class="kw">SELECT</span> pg_catalog.array_agg(acl) <span class="kw">FROM</span> (<span class="kw">SELECT</span> pg_catalog.unnest(<span class="kw">coalesce</span>(at.attacl,pg_catalog.acldefault(<span class="st">&#39;c&#39;</span>,c.relowner))) <span class="kw">AS</span> acl <span class="kw">EXCEPT</span> <span class="kw">SELECT</span> pg_catalog.unnest(<span class="kw">coalesce</span>(pip.initprivs,pg_catalog.acldefault(<span class="st">&#39;c&#39;</span>,c.relowner)))) <span class="kw">as</span> foo) <span class="kw">IS</span> <span class="kw">NOT</span> <span class="kw">NULL</span> <span class="kw">OR</span> (<span class="kw">SELECT</span> pg_catalog.array_agg(acl) <span class="kw">FROM</span> (<span class="kw">SELECT</span> pg_catalog.unnest(<span class="kw">coalesce</span>(pip.initprivs,pg_catalog.acldefault(<span class="st">&#39;c&#39;</span>,c.relowner))) <span class="kw">AS</span> acl <span class="kw">EXCEPT</span> <span class="kw">SELECT</span> pg_catalog.unnest(<span class="kw">coalesce</span>(at.attacl,pg_catalog.acldefault(<span class="st">&#39;c&#39;</span>,c.relowner)))) <span class="kw">as</span> foo) <span class="kw">IS</span> <span class="kw">NOT</span> <span class="kw">NULL</span> <span class="kw">OR</span> <span class="kw">NULL</span> <span class="kw">IS</span> <span class="kw">NOT</span> <span class="kw">NULL</span> <span class="kw">OR</span> <span class="kw">NULL</span> <span class="kw">IS</span> <span class="kw">NOT</span> <span class="kw">NULL</span>))<span class="kw">AS</span> changed_acl <span class="kw">FROM</span> pg_class c <span class="kw">LEFT</span> <span class="kw">JOIN</span> pg_depend d <span class="kw">ON</span> (c.relkind = <span class="st">&#39;S&#39;</span> <span class="kw">AND</span> d.classid = c.tableoid <span class="kw">AND</span> d.objid = c.oid <span class="kw">AND</span> d.objsubid = <span class="dv">0</span> <span class="kw">AND</span> d.refclassid = c.tableoid <span class="kw">AND</span> d.deptype = <span class="st">&#39;a&#39;</span>) <span class="kw">LEFT</span> <span class="kw">JOIN</span> pg_class tc <span class="kw">ON</span> (c.reltoastrelid = tc.oid) <span class="kw">LEFT</span> <span class="kw">JOIN</span> pg_init_privs pip <span class="kw">ON</span> (c.oid = pip.objoid <span class="kw">AND</span> pip.classoid = <span class="st">&#39;pg_class&#39;</span>:<span class="ch">:regclass</span> <span class="kw">AND</span> pip.objsubid = <span class="dv">0</span>) <span class="kw">WHERE</span> c.relkind <span class="kw">in</span> (<span class="st">&#39;r&#39;</span>, <span class="st">&#39;S&#39;</span>, <span class="st">&#39;v&#39;</span>, <span class="st">&#39;c&#39;</span>, <span class="st">&#39;m&#39;</span>, <span class="st">&#39;f&#39;</span>, <span class="st">&#39;P&#39;</span>) <span class="kw">ORDER</span> <span class="kw">BY</span> c.oid
<span class="co">--对表加ACESS SHARE锁，防止在备份的时候drop，alter等操作</span>
LOG:  statement: <span class="kw">LOCK</span> <span class="kw">TABLE</span> public.tb1 <span class="kw">IN</span> <span class="kw">ACCESS</span> <span class="kw">SHARE</span> <span class="kw">MODE</span>
LOG:  statement: <span class="kw">LOCK</span> <span class="kw">TABLE</span> public.tb2 <span class="kw">IN</span> <span class="kw">ACCESS</span> <span class="kw">SHARE</span> <span class="kw">MODE</span>
LOG:  statement: <span class="kw">SET</span> search_path = pg_catalog
LOG:  statement: <span class="kw">SELECT</span> p.tableoid, p.oid, p.proname, p.prolang, p.pronargs, p.proargtypes, p.prorettype, (<span class="kw">SELECT</span> pg_catalog.array_agg(acl) <span class="kw">FROM</span> (<span class="kw">SELECT</span> pg_catalog.unnest(<span class="kw">coalesce</span>(p.proacl,pg_catalog.acldefault(<span class="st">&#39;f&#39;</span>,p.proowner))) <span class="kw">AS</span> acl <span class="kw">EXCEPT</span> <span class="kw">SELECT</span> pg_catalog.unnest(<span class="kw">coalesce</span>(pip.initprivs,pg_catalog.acldefault(<span class="st">&#39;f&#39;</span>,p.proowner)))) <span class="kw">as</span> foo) <span class="kw">AS</span> proacl, (<span class="kw">SELECT</span> pg_catalog.array_agg(acl) <span class="kw">FROM</span> (<span class="kw">SELECT</span> pg_catalog.unnest(<span class="kw">coalesce</span>(pip.initprivs,pg_catalog.acldefault(<span class="st">&#39;f&#39;</span>,p.proowner))) <span class="kw">AS</span> acl <span class="kw">EXCEPT</span> <span class="kw">SELECT</span> pg_catalog.unnest(<span class="kw">coalesce</span>(p.proacl,pg_catalog.acldefault(<span class="st">&#39;f&#39;</span>,p.proowner)))) <span class="kw">as</span> foo) <span class="kw">AS</span> rproacl, <span class="kw">NULL</span> <span class="kw">AS</span> initproacl, <span class="kw">NULL</span> <span class="kw">AS</span> initrproacl, p.pronamespace, (<span class="kw">SELECT</span> rolname <span class="kw">FROM</span> pg_catalog.pg_roles <span class="kw">WHERE</span> <span class="kw">oid</span> = p.proowner) <span class="kw">AS</span> rolname <span class="kw">FROM</span> pg_proc p <span class="kw">LEFT</span> <span class="kw">JOIN</span> pg_init_privs pip <span class="kw">ON</span> (p.oid = pip.objoid <span class="kw">AND</span> pip.classoid = <span class="st">&#39;pg_proc&#39;</span>:<span class="ch">:regclass</span> <span class="kw">AND</span> pip.objsubid = <span class="dv">0</span>) <span class="kw">WHERE</span> <span class="kw">NOT</span> proisagg
depend <span class="kw">WHERE</span> classid = <span class="st">&#39;pg_proc&#39;</span>:<span class="ch">:regclass</span> <span class="kw">AND</span> objid = p.oid <span class="kw">AND</span> deptype = <span class="st">&#39;i&#39;</span>)
pg_namespace <span class="kw">WHERE</span> nspname = <span class="st">&#39;pg_catalog&#39;</span>)form D )initprivs)
LOG:  statement: <span class="kw">SET</span> search_path = pg_catalog
LOG:  statement: <span class="kw">SELECT</span> t.tableoid, t.oid, t.typname, t.typnamespace, (<span class="kw">SELECT</span> pg_catalog.array_agg(acl) <span class="kw">FROM</span> (<span class="kw">SELECT</span> pg_catalog.unnest(<span class="kw">coalesce</span>(t.typacl,pg_catalog.acldefault(<span class="st">&#39;T&#39;</span>,t.typowner))) <span class="kw">AS</span> acl <span class="kw">EXCEPT</span> <span class="kw">SELECT</span> pg_catalog.unnest(<span class="kw">coalesce</span>(pip.initprivs,pg_catalog.acldefault(<span class="st">&#39;T&#39;</span>,t.typowner)))) <span class="kw">as</span> foo) <span class="kw">AS</span> typacl, (<span class="kw">SELECT</span> pg_catalog.array_agg(acl) <span class="kw">FROM</span> (<span class="kw">SELECT</span> pg_catalog.unnest(<span class="kw">coalesce</span>(pip.initprivs,pg_catalog.acldefault(<span class="st">&#39;T&#39;</span>,t.typowner))) <span class="kw">AS</span> acl <span class="kw">EXCEPT</span> <span class="kw">SELECT</span> pg_catalog.unnest(<span class="kw">coalesce</span>(t.typacl,pg_catalog.acldefault(<span class="st">&#39;T&#39;</span>,t.typowner)))) <span class="kw">as</span> foo) <span class="kw">AS</span> rtypacl, <span class="kw">NULL</span> <span class="kw">AS</span> inittypacl, <span class="kw">NULL</span> <span class="kw">AS</span> initrtypacl, (<span class="kw">SELECT</span> rolname <span class="kw">FROM</span> pg_catalog.pg_roles <span class="kw">WHERE</span> <span class="kw">oid</span> = t.typowner) <span class="kw">AS</span> rolname, t.typelem, t.typrelid, <span class="kw">CASE</span> <span class="kw">WHEN</span> t.typrelid = <span class="dv">0</span> <span class="kw">THEN</span> <span class="st">&#39; &#39;</span>::<span class="ot">&quot;char&quot;</span> <span class="kw">ELSE</span> (<span class="kw">SELECT</span> relkind <span class="kw">FROM</span> pg_class <span class="kw">WHERE</span> <span class="kw">oid</span> = t.typrelid) <span class="kw">END</span> <span class="kw">AS</span> typrelkind, t.typtype, t.typisdefined, t.typname[<span class="dv">0</span>] = <span class="st">&#39;_&#39;</span> <span class="kw">AND</span> t.typelem != <span class="dv">0</span> <span class="kw">AND</span> (<span class="kw">SELECT</span> typarray <span class="kw">FROM</span> pg_type te <span class="kw">WHERE</span> <span class="kw">oid</span> = t.typelem) = t.oid <span class="kw">AS</span> isarray <span class="kw">FROM</span> pg_type t <span class="kw">LEFT</span> <span class="kw">JOIN</span> pg_init_privs pip <span class="kw">ON</span> (t.oid = pip.objoid <span class="kw">AND</span> pip.classoid = <span class="st">&#39;pg_type&#39;</span>:<span class="ch">:regclass</span> <span class="kw">AND</span> pip.objsubid = <span class="dv">0</span>) 
LOG:  statement: <span class="kw">SET</span> search_path = pg_catalog
LOG:  statement: <span class="kw">SELECT</span> l.tableoid, l.oid, l.lanname, l.lanpltrusted, l.lanplcallfoid, l.laninline, l.lanvalidator, (<span class="kw">SELECT</span> pg_catalog.array_agg(acl) <span class="kw">FROM</span> (<span class="kw">SELECT</span> pg_catalog.unnest(<span class="kw">coalesce</span>(l.lanacl,pg_catalog.acldefault(<span class="st">&#39;l&#39;</span>,l.lanowner))) <span class="kw">AS</span> acl <span class="kw">EXCEPT</span> <span class="kw">SELECT</span> pg_catalog.unnest(<span class="kw">coalesce</span>(pip.initprivs,pg_catalog.acldefault(<span class="st">&#39;l&#39;</span>,l.lanowner)))) <span class="kw">as</span> foo) <span class="kw">AS</span> lanacl, (<span class="kw">SELECT</span> pg_catalog.array_agg(acl) <span class="kw">FROM</span> (<span class="kw">SELECT</span> pg_catalog.unnest(<span class="kw">coalesce</span>(pip.initprivs,pg_catalog.acldefault(<span class="st">&#39;l&#39;</span>,l.lanowner))) <span class="kw">AS</span> acl <span class="kw">EXCEPT</span> <span class="kw">SELECT</span> pg_catalog.unnest(<span class="kw">coalesce</span>(l.lanacl,pg_catalog.acldefault(<span class="st">&#39;l&#39;</span>,l.lanowner)))) <span class="kw">as</span> foo) <span class="kw">AS</span> rlanacl, <span class="kw">NULL</span> <span class="kw">AS</span> initlanacl, <span class="kw">NULL</span> <span class="kw">AS</span> initrlanacl, (<span class="kw">SELECT</span> rolname <span class="kw">FROM</span> pg_catalog.pg_roles <span class="kw">WHERE</span> <span class="kw">oid</span> = l.lanowner) <span class="kw">AS</span> lanowner <span class="kw">FROM</span> pg_language l <span class="kw">LEFT</span> <span class="kw">JOIN</span> pg_init_privs pip <span class="kw">ON</span> (l.oid = pip.objoid <span class="kw">AND</span> pip.classoid = <span class="st">&#39;pg_type&#39;</span>:<span class="ch">:regclass</span> <span class="kw">AND</span> pip.objsubid = <span class="dv">0</span>) <span class="kw">WHERE</span> l.lanispl <span class="kw">ORDER</span> <span class="kw">BY</span> l.oid
LOG:  statement: <span class="kw">SET</span> search_path = pg_catalog
LOG:  statement: <span class="kw">SELECT</span> p.tableoid, p.oid, p.proname <span class="kw">AS</span> aggname, p.pronamespace <span class="kw">AS</span> aggnamespace, p.pronargs, p.proargtypes, (<span class="kw">SELECT</span> rolname <span class="kw">FROM</span> pg_catalog.pg_roles <span class="kw">WHERE</span> <span class="kw">oid</span> = p.proowner) <span class="kw">AS</span> rolname, (<span class="kw">SELECT</span> pg_catalog.array_agg(acl) <span class="kw">FROM</span> (<span class="kw">SELECT</span> pg_catalog.unnest(<span class="kw">coalesce</span>(p.proacl,pg_catalog.acldefault(<span class="st">&#39;f&#39;</span>,p.proowner))) <span class="kw">AS</span> acl <span class="kw">EXCEPT</span> <span class="kw">SELECT</span> pg_catalog.unnest(<span class="kw">coalesce</span>(pip.initprivs,pg_catalog.acldefault(<span class="st">&#39;f&#39;</span>,p.proowner)))) <span class="kw">as</span> foo) <span class="kw">AS</span> aggacl, (<span class="kw">SELECT</span> pg_catalog.array_agg(acl) <span class="kw">FROM</span> (<span class="kw">SELECT</span> pg_catalog.unnest(<span class="kw">coalesce</span>(pip.initprivs,pg_catalog.acldefault(<span class="st">&#39;f&#39;</span>,p.proowner))) <span class="kw">AS</span> acl <span class="kw">EXCEPT</span> <span class="kw">SELECT</span> pg_catalog.unnest(<span class="kw">coalesce</span>(p.proacl,pg_catalog.acldefault(<span class="st">&#39;f&#39;</span>,p.proowner)))) <span class="kw">as</span> foo) <span class="kw">AS</span> raggacl, <span class="kw">NULL</span> <span class="kw">AS</span> initaggacl, <span class="kw">NULL</span> <span class="kw">AS</span> initraggacl <span class="kw">FROM</span> pg_proc p <span class="kw">LEFT</span> <span class="kw">JOIN</span> pg_init_privs pip <span class="kw">ON</span> (p.oid = pip.objoid <span class="kw">AND</span> pip.classoid = <span class="st">&#39;pg_proc&#39;</span>:<span class="ch">:regclass</span> <span class="kw">AND</span> pip.objsubid = <span class="dv">0</span>) <span class="kw">WHERE</span> p.proisagg <span class="kw">AND</span> (p.pronamespace != (<span class="kw">SELECT</span> <span class="kw">oid</span> <span class="kw">FROM</span> pg_namespace <span class="kw">WHERE</span> nspname = <span class="st">&#39;pg_catalog&#39;</span>) <span class="kw">OR</span> p.proacl <span class="kw">IS</span> <span class="kw">DISTINCT</span> <span class="kw">FROM</span> pip.initprivs)
LOG:  statement: <span class="kw">SET</span> search_path = pg_catalog
LOG:  statement: <span class="kw">SELECT</span> tableoid, <span class="kw">oid</span>, oprname, oprnamespace, (<span class="kw">SELECT</span> rolname <span class="kw">FROM</span> pg_catalog.pg_roles <span class="kw">WHERE</span> <span class="kw">oid</span> = oprowner) <span class="kw">AS</span> rolname, oprkind, oprcode:<span class="ch">:oid</span> <span class="kw">AS</span> oprcode <span class="kw">FROM</span> pg_operator
LOG:  statement: <span class="kw">SET</span> search_path = pg_catalog
LOG:  statement: <span class="kw">SELECT</span> tableoid, <span class="kw">oid</span>, amname, amtype, amhandler:<span class="ch">:pg_catalog</span>.regproc <span class="kw">AS</span> amhandler <span class="kw">FROM</span> pg_am
LOG:  statement: <span class="kw">SET</span> search_path = pg_catalog
LOG:  statement: <span class="kw">SELECT</span> tableoid, <span class="kw">oid</span>, opcname, opcnamespace, (<span class="kw">SELECT</span> rolname <span class="kw">FROM</span> pg_catalog.pg_roles <span class="kw">WHERE</span> <span class="kw">oid</span> = opcowner) <span class="kw">AS</span> rolname <span class="kw">FROM</span> pg_opclass
LOG:  statement: <span class="kw">SET</span> search_path = pg_catalog
LOG:  statement: <span class="kw">SELECT</span> tableoid, <span class="kw">oid</span>, opfname, opfnamespace, (<span class="kw">SELECT</span> rolname <span class="kw">FROM</span> pg_catalog.pg_roles <span class="kw">WHERE</span> <span class="kw">oid</span> = opfowner) <span class="kw">AS</span> rolname <span class="kw">FROM</span> pg_opfamily
LOG:  statement: <span class="kw">SET</span> search_path = pg_catalog
LOG:  statement: <span class="kw">SELECT</span> tableoid, <span class="kw">oid</span>, prsname, prsnamespace, prsstart:<span class="ch">:oid</span>, prstoken:<span class="ch">:oid</span>, prsend:<span class="ch">:oid</span>, prsheadline:<span class="ch">:oid</span>, prslextype:<span class="ch">:oid</span> <span class="kw">FROM</span> pg_ts_parser
LOG:  statement: <span class="kw">SET</span> search_path = pg_catalog
LOG:  statement: <span class="kw">SELECT</span> tableoid, <span class="kw">oid</span>, tmplname, tmplnamespace, tmplinit:<span class="ch">:oid</span>, tmpllexize:<span class="ch">:oid</span> <span class="kw">FROM</span> pg_ts_template
LOG:  statement: <span class="kw">SET</span> search_path = pg_catalog
LOG:  statement: <span class="kw">SELECT</span> tableoid, <span class="kw">oid</span>, dictname, dictnamespace, (<span class="kw">SELECT</span> rolname <span class="kw">FROM</span> pg_catalog.pg_roles <span class="kw">WHERE</span> <span class="kw">oid</span> = dictowner) <span class="kw">AS</span> rolname, dicttemplate, dictinitoption <span class="kw">FROM</span> pg_ts_dict
LOG:  statement: <span class="kw">SET</span> search_path = pg_catalog
LOG:  statement: <span class="kw">SELECT</span> tableoid, <span class="kw">oid</span>, cfgname, cfgnamespace, (<span class="kw">SELECT</span> rolname <span class="kw">FROM</span> pg_catalog.pg_roles <span class="kw">WHERE</span> <span class="kw">oid</span> = cfgowner) <span class="kw">AS</span> rolname, cfgparser <span class="kw">FROM</span> pg_ts_config
LOG:  statement: <span class="kw">SET</span> search_path = pg_catalog
LOG:  statement: <span class="kw">SELECT</span> f.tableoid, f.oid, f.fdwname, (<span class="kw">SELECT</span> rolname <span class="kw">FROM</span> pg_catalog.pg_roles <span class="kw">WHERE</span> <span class="kw">oid</span> = f.fdwowner) <span class="kw">AS</span> rolname, f.fdwhandler:<span class="ch">:pg_catalog</span>.regproc, f.fdwvalidator:<span class="ch">:pg_catalog</span>.regproc, (<span class="kw">SELECT</span> pg_catalog.array_agg(acl) <span class="kw">FROM</span> (<span class="kw">SELECT</span> pg_catalog.unnest(<span class="kw">coalesce</span>(f.fdwacl,pg_catalog.acldefault(<span class="st">&#39;F&#39;</span>,f.fdwowner))) <span class="kw">AS</span> acl <span class="kw">EXCEPT</span> <span class="kw">SELECT</span> pg_catalog.unnest(<span class="kw">coalesce</span>(pip.initprivs,pg_catalog.acldefault(<span class="st">&#39;F&#39;</span>,f.fdwowner)))) <span class="kw">as</span> foo) <span class="kw">AS</span> fdwacl, (<span class="kw">SELECT</span> pg_catalog.array_agg(acl) <span class="kw">FROM</span> (<span class="kw">SELECT</span> pg_catalog.unnest(<span class="kw">coalesce</span>(pip.initprivs,pg_catalog.acldefault(<span class="st">&#39;F&#39;</span>,f.fdwowner))) <span class="kw">AS</span> acl <span class="kw">EXCEPT</span> <span class="kw">SELECT</span> pg_catalog.unnest(<span class="kw">coalesce</span>(f.fdwacl,pg_catalog.acldefault(<span class="st">&#39;F&#39;</span>,f.fdwowner)))) <span class="kw">as</span> foo) <span class="kw">AS</span> rfdwacl, <span class="kw">NULL</span> <span class="kw">AS</span> initfdwacl, <span class="kw">NULL</span> <span class="kw">AS</span> initrfdwacl, array_to_string(<span class="dt">ARRAY</span>(<span class="kw">SELECT</span> quote_ident(option_name) || <span class="st">&#39; &#39;</span> || quote_literal(option_value) <span class="kw">FROM</span> pg_options_to_table(f.fdwoptions) <span class="kw">ORDER</span> <span class="kw">BY</span> option_name), E<span class="st">&#39;,</span>
<span class="st">n_data_wrapper f LEFT JOIN pg_init_privs pip ON (f.oid = pip.objoid AND pip.classoid = &#39;</span>pg_foreign_data_wrapper<span class="st">&#39;::regclass AND pip.objsubid = 0) </span>
<span class="st">LOG:  statement: SET search_path = pg_catalog</span>
<span class="st">LOG:  statement: SELECT f.tableoid, f.oid, f.srvname, (SELECT rolname FROM pg_catalog.pg_roles WHERE oid = f.srvowner) AS rolname, f.srvfdw, f.srvtype, f.srvversion, (SELECT pg_catalog.array_agg(acl) FROM (SELECT pg_catalog.unnest(coalesce(f.srvacl,pg_catalog.acldefault(&#39;</span>S<span class="st">&#39;,f.srvowner))) AS acl EXCEPT SELECT pg_catalog.unnest(coalesce(pip.initprivs,pg_catalog.acldefault(&#39;</span>S<span class="st">&#39;,f.srvowner)))) as foo) AS srvacl, (SELECT pg_catalog.array_agg(acl) FROM (SELECT pg_catalog.unnest(coalesce(pip.initprivs,pg_catalog.acldefault(&#39;</span>S<span class="st">&#39;,f.srvowner))) AS acl EXCEPT SELECT pg_catalog.unnest(coalesce(f.srvacl,pg_catalog.acldefault(&#39;</span>S<span class="st">&#39;,f.srvowner)))) as foo) AS rsrvacl, NULL AS initsrvacl, NULL AS initrsrvacl, array_to_string(ARRAY(SELECT quote_ident(option_name) || &#39;</span> <span class="st">&#39; || quote_literal(option_value) FROM pg_options_to_table(f.srvoptions) ORDER BY option_name), E&#39;</span>,
n_server f <span class="kw">LEFT</span> <span class="kw">JOIN</span> pg_init_privs pip <span class="kw">ON</span> (f.oid = pip.objoid <span class="kw">AND</span> pip.classoid = <span class="st">&#39;pg_foreign_server&#39;</span>:<span class="ch">:regclass</span> <span class="kw">AND</span> pip.objsubid = <span class="dv">0</span>) 
LOG:  statement: <span class="kw">SET</span> search_path = pg_catalog
LOG:  statement: <span class="kw">SELECT</span> <span class="kw">oid</span>, tableoid, (<span class="kw">SELECT</span> rolname <span class="kw">FROM</span> pg_catalog.pg_roles <span class="kw">WHERE</span> <span class="kw">oid</span> = defaclrole) <span class="kw">AS</span> defaclrole, defaclnamespace, defaclobjtype, defaclacl <span class="kw">FROM</span> pg_default_acl
LOG:  statement: <span class="kw">SET</span> search_path = pg_catalog
LOG:  statement: <span class="kw">SELECT</span> tableoid, <span class="kw">oid</span>, collname, collnamespace, (<span class="kw">SELECT</span> rolname <span class="kw">FROM</span> pg_catalog.pg_roles <span class="kw">WHERE</span> <span class="kw">oid</span> = collowner) <span class="kw">AS</span> rolname <span class="kw">FROM</span> pg_collation
LOG:  statement: <span class="kw">SET</span> search_path = pg_catalog
LOG:  statement: <span class="kw">SELECT</span> tableoid, <span class="kw">oid</span>, conname, connamespace, (<span class="kw">SELECT</span> rolname <span class="kw">FROM</span> pg_catalog.pg_roles <span class="kw">WHERE</span> <span class="kw">oid</span> = conowner) <span class="kw">AS</span> rolname <span class="kw">FROM</span> pg_conversion
LOG:  statement: <span class="kw">SET</span> search_path = pg_catalog
LOG:  statement: <span class="kw">SELECT</span> tableoid, <span class="kw">oid</span>, castsource, casttarget, castfunc, castcontext, castmethod <span class="kw">FROM</span> pg_cast <span class="kw">ORDER</span> <span class="kw">BY</span> <span class="dv">3</span>,<span class="dv">4</span>
LOG:  statement: <span class="kw">SET</span> search_path = pg_catalog
LOG:  statement: <span class="kw">SELECT</span> tableoid, <span class="kw">oid</span>, trftype, trflang, trffromsql:<span class="ch">:oid</span>, trftosql:<span class="ch">:oid</span> <span class="kw">FROM</span> pg_transform <span class="kw">ORDER</span> <span class="kw">BY</span> <span class="dv">3</span>,<span class="dv">4</span>
LOG:  statement: <span class="kw">SET</span> search_path = pg_catalog
LOG:  statement: <span class="kw">SELECT</span> inhrelid, inhparent <span class="kw">FROM</span> pg_inherits <span class="kw">WHERE</span> inhparent <span class="kw">NOT</span> <span class="kw">IN</span> (<span class="kw">SELECT</span> <span class="kw">oid</span> <span class="kw">FROM</span> pg_class <span class="kw">WHERE</span> relkind = <span class="st">&#39;P&#39;</span>)
LOG:  statement: <span class="kw">SET</span> search_path = pg_catalog
LOG:  statement: <span class="kw">SELECT</span> inhrelid <span class="kw">as</span> partrelid, inhparent <span class="kw">AS</span> partparent,      pg_get_expr(relpartbound, inhrelid) <span class="kw">AS</span> partbound <span class="kw">FROM</span> pg_class c, pg_inherits <span class="kw">WHERE</span> c.oid = inhrelid <span class="kw">AND</span> c.relispartition
LOG:  statement: <span class="kw">SET</span> search_path = pg_catalog
LOG:  statement: <span class="kw">SELECT</span> e.tableoid, e.oid, evtname, evtenabled, evtevent, (<span class="kw">SELECT</span> rolname <span class="kw">FROM</span> pg_catalog.pg_roles <span class="kw">WHERE</span> <span class="kw">oid</span> = evtowner) <span class="kw">AS</span> evtowner, array_to_string(<span class="dt">array</span>(<span class="kw">select</span> quote_literal(x)  <span class="kw">from</span> unnest(evttags) <span class="kw">as</span> t(x)), <span class="st">&#39;, &#39;</span>) <span class="kw">as</span> evttags, e.evtfoid:<span class="ch">:regproc</span> <span class="kw">as</span> evtfname <span class="kw">FROM</span> pg_event_trigger e <span class="kw">ORDER</span> <span class="kw">BY</span> e.oid
LOG:  statement: <span class="kw">SET</span> search_path = pg_catalog
LOG:  statement: <span class="kw">SELECT</span> conrelid, confrelid <span class="kw">FROM</span> pg_constraint <span class="kw">JOIN</span> pg_depend <span class="kw">ON</span> (objid = confrelid) <span class="kw">WHERE</span> contype = <span class="st">&#39;f&#39;</span> <span class="kw">AND</span> refclassid = <span class="st">&#39;pg_extension&#39;</span>:<span class="ch">:regclass</span> <span class="kw">AND</span> classid = <span class="st">&#39;pg_class&#39;</span>:<span class="ch">:regclass</span>;
LOG:  statement: <span class="kw">SET</span> search_path = <span class="kw">public</span>, pg_catalog
LOG:  statement: <span class="kw">SELECT</span> a.attnum, a.attname, a.atttypmod, a.attstattarget, a.attstorage, t.typstorage, a.attnotnull, a.atthasdef, a.attisdropped, a.attlen, a.attalign, a.attislocal, pg_catalog.format_type(t.oid,a.atttypmod) <span class="kw">AS</span> atttypname, array_to_string(a.attoptions, <span class="st">&#39;, &#39;</span>) <span class="kw">AS</span> attoptions, <span class="kw">CASE</span> <span class="kw">WHEN</span> a.attcollation &lt;&gt; t.typcollation <span class="kw">THEN</span> a.attcollation <span class="kw">ELSE</span> <span class="dv">0</span> <span class="kw">END</span> <span class="kw">AS</span> attcollation, pg_catalog.array_to_string(<span class="dt">ARRAY</span>(<span class="kw">SELECT</span> pg_catalog.quote_ident(option_name) || <span class="st">&#39; &#39;</span> || pg_catalog.quote_literal(option_value) <span class="kw">FROM</span> pg_catalog.pg_options_to_table(attfdwoptions) <span class="kw">ORDER</span> <span class="kw">BY</span> option_name), E<span class="st">&#39;,</span>
<span class="st">alog.pg_attribute a LEFT JOIN pg_catalog.pg_type t ON a.atttypid = t.oid WHERE a.attrelid = &#39;</span><span class="dv">16384</span><span class="st">&#39;::pg_catalog.oid AND a.attnum &gt; 0::pg_catalog.int2 ORDER BY a.attnum</span>
<span class="st">LOG:  statement: SET search_path = public, pg_catalog</span>
<span class="st">LOG:  statement: SELECT a.attnum, a.attname, a.atttypmod, a.attstattarget, a.attstorage, t.typstorage, a.attnotnull, a.atthasdef, a.attisdropped, a.attlen, a.attalign, a.attislocal, pg_catalog.format_type(t.oid,a.atttypmod) AS atttypname, array_to_string(a.attoptions, &#39;</span>, <span class="st">&#39;) AS attoptions, CASE WHEN a.attcollation &lt;&gt; t.typcollation THEN a.attcollation ELSE 0 END AS attcollation, pg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(option_name) || &#39;</span> <span class="st">&#39; || pg_catalog.quote_literal(option_value) FROM pg_catalog.pg_options_to_table(attfdwoptions) ORDER BY option_name), E&#39;</span>,
alog.pg_attribute a <span class="kw">LEFT</span> <span class="kw">JOIN</span> pg_catalog.pg_type t <span class="kw">ON</span> a.atttypid = t.oid <span class="kw">WHERE</span> a.attrelid = <span class="st">&#39;16388&#39;</span>:<span class="ch">:pg_catalog</span>.oid <span class="kw">AND</span> a.attnum &gt; <span class="dv">0</span>:<span class="ch">:pg_catalog</span>.int2 <span class="kw">ORDER</span> <span class="kw">BY</span> a.attnum
LOG:  statement: <span class="kw">SET</span> search_path = pg_catalog
LOG:  statement: <span class="kw">SELECT</span> tableoid, <span class="kw">oid</span>, rulename, ev_class <span class="kw">AS</span> ruletable, ev_type, is_instead, ev_enabled <span class="kw">FROM</span> pg_rewrite <span class="kw">ORDER</span> <span class="kw">BY</span> <span class="kw">oid</span>
LOG:  statement: <span class="kw">SET</span> search_path = <span class="kw">public</span>, pg_catalog
LOG:  statement: <span class="kw">SELECT</span> <span class="kw">oid</span>, tableoid, pol.polname, pol.polcmd, pol.polpermissive, <span class="kw">CASE</span> <span class="kw">WHEN</span> pol.polroles = <span class="st">&#39;{0}&#39;</span> <span class="kw">THEN</span> <span class="kw">NULL</span> <span class="kw">ELSE</span>    pg_catalog.array_to_string(<span class="dt">ARRAY</span>(<span class="kw">SELECT</span> pg_catalog.quote_ident(rolname) <span class="kw">from</span> pg_catalog.pg_roles <span class="kw">WHERE</span> <span class="kw">oid</span> = <span class="kw">ANY</span>(pol.polroles)), <span class="st">&#39;, &#39;</span>) <span class="kw">END</span> <span class="kw">AS</span> polroles, pg_catalog.pg_get_expr(pol.polqual, pol.polrelid) <span class="kw">AS</span> polqual, pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid) <span class="kw">AS</span> polwithcheck <span class="kw">FROM</span> pg_catalog.pg_policy pol <span class="kw">WHERE</span> polrelid = <span class="st">&#39;16384&#39;</span>
LOG:  statement: <span class="kw">SET</span> search_path = <span class="kw">public</span>, pg_catalog
LOG:  statement: <span class="kw">SELECT</span> <span class="kw">oid</span>, tableoid, pol.polname, pol.polcmd, pol.polpermissive, <span class="kw">CASE</span> <span class="kw">WHEN</span> pol.polroles = <span class="st">&#39;{0}&#39;</span> <span class="kw">THEN</span> <span class="kw">NULL</span> <span class="kw">ELSE</span>    pg_catalog.array_to_string(<span class="dt">ARRAY</span>(<span class="kw">SELECT</span> pg_catalog.quote_ident(rolname) <span class="kw">from</span> pg_catalog.pg_roles <span class="kw">WHERE</span> <span class="kw">oid</span> = <span class="kw">ANY</span>(pol.polroles)), <span class="st">&#39;, &#39;</span>) <span class="kw">END</span> <span class="kw">AS</span> polroles, pg_catalog.pg_get_expr(pol.polqual, pol.polrelid) <span class="kw">AS</span> polqual, pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid) <span class="kw">AS</span> polwithcheck <span class="kw">FROM</span> pg_catalog.pg_policy pol <span class="kw">WHERE</span> polrelid = <span class="st">&#39;16388&#39;</span>
LOG:  statement: <span class="kw">SET</span> search_path = pg_catalog
LOG:  statement: <span class="kw">WITH</span> RECURSIVE w <span class="kw">AS</span> ( <span class="kw">SELECT</span> d1.objid, d2.refobjid, c2.relkind <span class="kw">AS</span> refrelkind <span class="kw">FROM</span> pg_depend d1 <span class="kw">JOIN</span> pg_class c1 <span class="kw">ON</span> c1.oid = d1.objid <span class="kw">AND</span> c1.relkind = <span class="st">&#39;m&#39;</span> <span class="kw">JOIN</span> pg_rewrite r1 <span class="kw">ON</span> r1.ev_class = d1.objid <span class="kw">JOIN</span> pg_depend d2 <span class="kw">ON</span> d2.classid = <span class="st">&#39;pg_rewrite&#39;</span>:<span class="ch">:regclass</span> <span class="kw">AND</span> d2.objid = r1.oid <span class="kw">AND</span> d2.refobjid &lt;&gt; d1.objid <span class="kw">JOIN</span> pg_class c2 <span class="kw">ON</span> c2.oid = d2.refobjid <span class="kw">AND</span> c2.relkind <span class="kw">IN</span> (<span class="st">&#39;m&#39;</span>,<span class="st">&#39;v&#39;</span>) <span class="kw">WHERE</span> d1.classid = <span class="st">&#39;pg_class&#39;</span>:<span class="ch">:regclass</span> <span class="kw">UNION</span> <span class="kw">SELECT</span> w.objid, d3.refobjid, c3.relkind <span class="kw">FROM</span> w <span class="kw">JOIN</span> pg_rewrite r3 <span class="kw">ON</span> r3.ev_class = w.refobjid <span class="kw">JOIN</span> pg_depend d3 <span class="kw">ON</span> d3.classid = <span class="st">&#39;pg_rewrite&#39;</span>:<span class="ch">:regclass</span> <span class="kw">AND</span> d3.objid = r3.oid <span class="kw">AND</span> d3.refobjid &lt;&gt; w.refobjid <span class="kw">JOIN</span> pg_class c3 <span class="kw">ON</span> c3.oid = d3.refobjid <span class="kw">AND</span> c3.relkind <span class="kw">IN</span> (<span class="st">&#39;m&#39;</span>,<span class="st">&#39;v&#39;</span>) ) <span class="kw">SELECT</span> <span class="st">&#39;pg_class&#39;</span>:<span class="ch">:regclass</span>:<span class="ch">:oid</span> <span class="kw">AS</span> classid, objid, refobjid <span class="kw">FROM</span> w <span class="kw">WHERE</span> refrelkind = <span class="st">&#39;m&#39;</span>
LOG:  statement: <span class="kw">SET</span> search_path = pg_catalog
LOG:  statement: <span class="kw">SELECT</span> l.oid, (<span class="kw">SELECT</span> rolname <span class="kw">FROM</span> pg_catalog.pg_roles <span class="kw">WHERE</span> <span class="kw">oid</span> = l.lomowner) <span class="kw">AS</span> rolname, (<span class="kw">SELECT</span> pg_catalog.array_agg(acl) <span class="kw">FROM</span> (<span class="kw">SELECT</span> pg_catalog.unnest(<span class="kw">coalesce</span>(l.lomacl,pg_catalog.acldefault(<span class="st">&#39;L&#39;</span>,l.lomowner))) <span class="kw">AS</span> acl <span class="kw">EXCEPT</span> <span class="kw">SELECT</span> pg_catalog.unnest(<span class="kw">coalesce</span>(pip.initprivs,pg_catalog.acldefault(<span class="st">&#39;L&#39;</span>,l.lomowner)))) <span class="kw">as</span> foo) <span class="kw">AS</span> lomacl, (<span class="kw">SELECT</span> pg_catalog.array_agg(acl) <span class="kw">FROM</span> (<span class="kw">SELECT</span> pg_catalog.unnest(<span class="kw">coalesce</span>(pip.initprivs,pg_catalog.acldefault(<span class="st">&#39;L&#39;</span>,l.lomowner))) <span class="kw">AS</span> acl <span class="kw">EXCEPT</span> <span class="kw">SELECT</span> pg_catalog.unnest(<span class="kw">coalesce</span>(l.lomacl,pg_catalog.acldefault(<span class="st">&#39;L&#39;</span>,l.lomowner)))) <span class="kw">as</span> foo) <span class="kw">AS</span> rlomacl, <span class="kw">NULL</span> <span class="kw">AS</span> initlomacl, <span class="kw">NULL</span> <span class="kw">AS</span> initrlomacl <span class="kw">FROM</span> pg_largeobject_metadata l <span class="kw">LEFT</span> <span class="kw">JOIN</span> pg_init_privs pip <span class="kw">ON</span> (l.oid = pip.objoid <span class="kw">AND</span> pip.classoid = <span class="st">&#39;pg_largeobject&#39;</span>:<span class="ch">:regclass</span> <span class="kw">AND</span> pip.objsubid = <span class="dv">0</span>) 
LOG:  statement: <span class="kw">SET</span> search_path = pg_catalog
LOG:  statement: <span class="kw">SELECT</span> classid, objid, refclassid, refobjid, deptype <span class="kw">FROM</span> pg_depend <span class="kw">WHERE</span> deptype != <span class="st">&#39;p&#39;</span> <span class="kw">AND</span> deptype != <span class="st">&#39;e&#39;</span> <span class="kw">ORDER</span> <span class="kw">BY</span> <span class="dv">1</span>,<span class="dv">2</span>
LOG:  statement: <span class="kw">SET</span> search_path = pg_catalog
LOG:  statement: <span class="kw">SELECT</span> tableoid, <span class="kw">oid</span>, (<span class="kw">SELECT</span> rolname <span class="kw">FROM</span> pg_catalog.pg_roles <span class="kw">WHERE</span> <span class="kw">oid</span> = datdba) <span class="kw">AS</span> <span class="kw">dba</span>, pg_encoding_to_char(encoding) <span class="kw">AS</span> encoding, datcollate, datctype, datfrozenxid, datminmxid, (<span class="kw">SELECT</span> spcname <span class="kw">FROM</span> pg_tablespace t <span class="kw">WHERE</span> t.oid = dattablespace) <span class="kw">AS</span> <span class="kw">tablespace</span>, shobj_description(<span class="kw">oid</span>, <span class="st">&#39;pg_database&#39;</span>) <span class="kw">AS</span> description <span class="kw">FROM</span> pg_database <span class="kw">WHERE</span> datname = <span class="st">&#39;postgres&#39;</span>
LOG:  statement: <span class="kw">SELECT</span> provider, <span class="kw">label</span> <span class="kw">FROM</span> pg_catalog.pg_shseclabel <span class="kw">WHERE</span> classoid = <span class="st">&#39;pg_database&#39;</span>:<span class="ch">:pg_catalog</span>.regclass <span class="kw">AND</span> objoid = <span class="dv">12289</span>
LOG:  statement: <span class="kw">SELECT</span> description, classoid, objoid, objsubid <span class="kw">FROM</span> pg_catalog.pg_description <span class="kw">ORDER</span> <span class="kw">BY</span> classoid, objoid, objsubid
LOG:  statement: <span class="kw">SELECT</span> <span class="kw">label</span>, provider, classoid, objoid, objsubid <span class="kw">FROM</span> pg_catalog.pg_seclabel <span class="kw">ORDER</span> <span class="kw">BY</span> classoid, objoid, objsubid
LOG:  statement: <span class="kw">SET</span> search_path = <span class="kw">public</span>, pg_catalog
LOG:  statement: <span class="kw">SET</span> search_path = <span class="kw">public</span>, pg_catalog
<span class="co">--开始备份数据</span>
LOG:  statement: <span class="kw">SET</span> search_path = <span class="kw">public</span>, pg_catalog
LOG:  statement: <span class="kw">COPY</span> public.tb1 (a) <span class="kw">TO</span> stdout;
LOG:  statement: <span class="kw">SET</span> search_path = <span class="kw">public</span>, pg_catalog
LOG:  statement: <span class="kw">COPY</span> public.tb2 (a) <span class="kw">TO</span> stdout;</code></pre></div>
</section><section id="对应pg_dump中的getxxx系列函数" class="slide level2">
<h1>对应pg_dump中的getXXX系列函数</h1>
<pre><code>$ cat src/bin/pg_dump/common.c | grep get[a-zA-Z].* | grep -v &quot;*&quot;
    extinfo = getExtensions(fout, &amp;numExtensions);
    getExtensionMembership(fout, extinfo, numExtensions);
    nspinfo = getNamespaces(fout, &amp;numNamespaces);
    tblinfo = getTables(fout, &amp;numTables);
    getOwnedSeqs(fout, tblinfo, numTables);
    funinfo = getFuncs(fout, &amp;numFuncs);
    typinfo = getTypes(fout, &amp;numTypes);
    getProcLangs(fout, &amp;numProcLangs);
    getAggregates(fout, &amp;numAggregates);
    oprinfo = getOperators(fout, &amp;numOperators);
    getAccessMethods(fout, &amp;numAccessMethods);
    getOpclasses(fout, &amp;numOpclasses);
    getOpfamilies(fout, &amp;numOpfamilies);
    getTSParsers(fout, &amp;numTSParsers);
    getTSTemplates(fout, &amp;numTSTemplates);
    getTSDictionaries(fout, &amp;numTSDicts);
    getTSConfigurations(fout, &amp;numTSConfigs);
    getForeignDataWrappers(fout, &amp;numForeignDataWrappers);
    getForeignServers(fout, &amp;numForeignServers);
    getDefaultACLs(fout, &amp;numDefaultACLs);
    collinfo = getCollations(fout, &amp;numCollations);
    getConversions(fout, &amp;numConversions);
    getCasts(fout, &amp;numCasts);
    getTransforms(fout, &amp;numTransforms);
    inhinfo = getInherits(fout, &amp;numInherits);
    partinfo = getPartitions(fout, &amp;numPartitions);
    getEventTriggers(fout, &amp;numEventTriggers);
    getTableAttrs(fout, tblinfo, numTables);
    getIndexes(fout, tblinfo, numTables);
    getConstraints(fout, tblinfo, numTables);
    getTriggers(fout, tblinfo, numTables);
    getRules(fout, &amp;numRules);
    getPolicies(fout, tblinfo, numTables);
    getTablePartitionKeyInfo(fout, tblinfo, numTables);
</code></pre>
</section></section>
<section><section id="pg_dump-中的事务" class="titleslide slide level1"><h1>pg_dump 中的事务</h1></section><section id="pg_dump-中的事务-1" class="slide level2">
<h1>pg_dump 中的事务 1</h1>
<p>备份是在一个事务里面进行的：</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">BEGIN</span>
<span class="kw">SET</span> <span class="kw">TRANSACTION</span> <span class="kw">ISOLATION</span> <span class="kw">LEVEL</span> <span class="kw">SERIALIZABLE</span>
    <span class="kw">lock</span> <span class="kw">all</span> <span class="kw">tables</span> <span class="kw">in</span> <span class="kw">access</span> <span class="kw">shared</span> <span class="kw">lock</span> <span class="co">--锁住了全部的表</span>
    <span class="fu">dump</span> table1
    <span class="fu">dump</span> table2
    …
    <span class="fu">dump</span> tablen
<span class="kw">commit</span></code></pre></div>
</section><section id="pg_dump-中的事务-2" class="slide level2">
<h1>pg_dump 中的事务 2</h1>
<p>在dump的同时，别的会话可以select，insert update delete。但是不能有drop，alter，truncate这些，否者会被阻塞。</p>
<pre><code>编 号   类 型       对应操作        互 斥
1   Access Share    Select  8
2   Row Share   Select For Update, Select For Share 7,8
3   Row Exclusive   Insert, Update, Delete  5,6,7,8
4   Share Update Exclusive  Vacuum(Non-Full), Analyze, Create Index Concurrently    4,5,6,7,8
5   Share   Create Index(Without Concurrently)  3,4,6,7,8
6   Share Row Exclusive     3,4,5,6,7,8
7   Exclusive       2,3,4,5,6,7,8
8   Access Exclusive    Alter Table, Drop Table, Vacuum Full    1,2,3,4,5,6,7,8</code></pre>
</section></section>
<section><section id="pg_dump-源码解析" class="titleslide slide level1"><h1>pg_dump 源码解析</h1></section><section id="源码文件" class="slide level2">
<h1>源码文件</h1>
<pre><code>ls src/bin/pg_dump</code></pre>
<pre><code>common.c   --获取Catalog元信息，比如很多getXXX函数来读取系统表信息
compress_io.c
compress_io.h
dumputils.c --ACL相关
dumputils.h
Makefile
nls.mk
parallel.c  --并行备份还原的框架
parallel.h
pg_backup_archiver.c  --备份API和初始化不同备份类型
pg_backup_archiver.h
pg_backup_custom.c --custom备份类型的实现
pg_backup_db.c  --连数据库的相关函数
pg_backup_db.h
pg_backup_directory.c --dir备份类型的实现
pg_backup.h
pg_backup_null.c --null备份类型的实现
pg_backup_tar.c --tar备份类型的实现
pg_backup_tar.h
pg_backup_utils.c --pg_dump和pg_restore共享的一些工具函数，比如报错函数等等
pg_backup_utils.h
pg_dumpall.c   --最后生成一个pg_dumpall工具，调用pg_dump来备份一个实例上的所有databases
pg_dump.c --pg_dump的main入口
pg_dump.h
pg_dump_sort.c
pg_restore.c --pg_restore的main入口

</code></pre>
</section><section id="数据结构" class="slide level2">
<h1>数据结构</h1>
<ol type="1">
<li>DumpableObject：记录了备份对象的type，id，name，dependencies... 其他备份对象DumpableObjectType继承DumpableObject，比如TableInfo的第一个成员就是DumpableObject，再加上特有的表的信息。</li>
<li>Archive *g_fout : 全局变量，记录了数据库版本，编码，报错个数...由CreateArchive建立</li>
<li>ArchiveHandle ：继承Archive，增加了备份文件格式，和对应格式的dump函数指针，全局变量等。</li>
<li>ArchiveHandle 中的 struct _tocEntry *toc; 是每个备份对象的信息：比如表定义，oid等等</li>
</ol>
</section><section id="主要流程--初始化" class="slide level2">
<h1>主要流程--初始化</h1>
<p>从pg_dump.c这里开始</p>
<pre><code>pg_dump.c --pg_dump的main入口
参数解析和判断相容性
CreateArchive 初始化g_fout
    初始化对应格式的回调函数指针
        InitArchiveFmt_Custom 
            一般我们用的就是这种模式，都在一个文件里面
        InitArchiveFmt_Files
            toc信息在单独main文件中，每个对象都备份为单独文件，可用于并行备份
        InitArchiveFmt_Null
            导出为sql脚本
        InitArchiveFmt_Tar 
            和files类型很像但是把输出指向一个tar归档，所以备份的是一个文件
</code></pre>
</section><section id="主要流程--重要的函数指针" class="slide level2">
<h1>主要流程--重要的函数指针</h1>
<p>每种归档格式都需要初始化相应的回调函数指针 1. ArchiveEntryPtr： 每个备份对象TOC创建时调用 2. StartDataPtr：表数据调备份前调用 3. WriteDataPtr：备份表表数据时调用 4. EndDataPtr：表数据备份完成调用 5. WriteBytePtr：向输出写数据（1字节） 6. ReadBytePtr：读数据（1字节） 7. WriteBufPtr：写数据 8. ReadBufPtr：读数据 9. _CloseArchive：开始实际写入数据，最后关闭文件</p>
<p>等等，具体可以看<code>struct _archiveHandle</code></p>
</section><section id="主要流程--连接到数据库" class="slide level2">
<h1>主要流程--连接到数据库</h1>
<pre><code>ConnectDatabase ()连接到数据库。
setup_connection()接下来做一些基本的数据库设置：
    clientEncoding
    SET DATESTYLE = ISO
    SET use_std_cast = off
    BEGIN  --开始一个事务
    SET TRANSACTION ISOLATION LEVEL SERIALIZABLE --隔离级别：可串行化
    SET extra_float_digits TO 2</code></pre>
</section><section id="主要流程--处理include和exclude入参" class="slide level2">
<h1>主要流程--处理include和exclude入参</h1>
<ol type="1">
<li>入参schema_include_patterns转为schema_include_oids</li>
<li>入参schema_exclude_patterns转为schema_exclude_oids</li>
<li>参数table_include_patterns转为table_include_oids 4 .使用的函数为expand_schema_name_patterns并在转的过程中检查对应的名称是否存在，如果不存在就会报错。</li>
</ol>
</section><section id="主要流程--获取备份对象信息" class="slide level2">
<h1>主要流程--获取备份对象信息</h1>
<pre><code>getSchemaData()
    getNamespaces()
    getTables()
    getFuncs()
    getXXX() ---查询系统表获取有那些备份对象
</code></pre>
</section><section id="主要流程--拓扑排序" class="slide level2">
<h1>主要流程--拓扑排序</h1>
<pre><code>getDependencies() --从pg_depend获取依赖信息
getDumpableObjects() --创建指针数组，指向备份对象，用于随后的排序。
sortDumpableObjects() --拓扑排序</code></pre>
</section><section id="主要流程--开始归档archiveentry" class="slide level2">
<h1>主要流程--开始归档(ArchiveEntry)</h1>
<pre><code>dumpTable()
dumpTableData()
dumpXXX系列函数获取单个备份对象的信息
接下来调用
    ArchiveEntry()
      分配TocEntry空间，TOC=TableOfContent
      TocEntry里面存放了对象的基本信息（比如表定义）以及
      dataDumper回调函数用于最后输出使用（比如copy语句）</code></pre>
</section><section id="主要流程--处理选项" class="slide level2">
<h1>主要流程--处理选项</h1>
<p>这一步根据备份选项来处理每一个TOC 看函数_tocEntryRequired</p>
<pre><code>typedef enum
{
    REQ_SCHEMA = 0x01,          /* want schema */
    REQ_DATA = 0x02,            /* want data */
    REQ_SPECIAL = 0x04          /* for special TOC entries */
} teReqs;
</code></pre>
</section><section id="主要流程--开始输出" class="slide level2">
<h1>主要流程--开始输出</h1>
<pre><code>if (plainText)
    RestoreArchive(fout); --输出为sql形式
        restore_toc_entry --输出每个备份对象
            _PrintTocData
                dumpTableData_copy --实际的输出函数

    CloseArchive(fout); --输出为custom形式
        _CloseArchive() --回调函数
</code></pre>
</section></section>
<section><section id="pg_restore-参数解析" class="titleslide slide level1"><h1>pg_restore 参数解析</h1></section><section id="help-1" class="slide level2">
<h1>help</h1>
<pre><code>$ ./pg_restore --help</code></pre>
<pre><code>pg_restore 从一个 pg_dump 备份的二进制文件恢复到数据库或者文本文件.

$ ./pg_restore    --help
pg_restore restores a PostgreSQL database from an archive created by pg_dump.

Usage:
  pg_restore [OPTION]... [FILE]

General options:
  -d, --dbname=NAME        connect to database name
  -f, --file=FILENAME      output file name
  -F, --format=c|d|t       backup file format (should be automatic)
  -l, --list               print summarized TOC of the archive
  -v, --verbose            verbose mode
  -V, --version            output version information, then exit
  -?, --help               show this help, then exit

Options controlling the restore:
  -a, --data-only              restore only the data, no schema
  -c, --clean                  clean (drop) database objects before recreating
  -C, --create                 create the target database
  -e, --exit-on-error          exit on error, default is to continue
  -I, --index=NAME             restore named index
  -j, --jobs=NUM               use this many parallel jobs to restore
  -L, --use-list=FILENAME      use table of contents from this file for
                               selecting/ordering output
  -n, --schema=NAME            restore only objects in this schema
  -O, --no-owner               skip restoration of object ownership
  -P, --function=NAME(args)    restore named function
  -s, --schema-only            restore only the schema, no data
  -S, --superuser=NAME         superuser user name to use for disabling triggers
  -t, --table=NAME             restore named relation (table, view, etc.)
  -T, --trigger=NAME           restore named trigger
  -x, --no-privileges          skip restoration of access privileges (grant/revoke)
  -1, --single-transaction     restore as a single transaction
  --disable-triggers           disable triggers during data-only restore
  --enable-row-security        enable row security
  --if-exists                  use IF EXISTS when dropping objects
  --no-data-for-failed-tables  do not restore data of tables that could not be
                               created
  --no-security-labels         do not restore security labels
  --no-tablespaces             do not restore tablespace assignments
  --section=SECTION            restore named section (pre-data, data, or post-data)
  --strict-names               require table and/or schema include patterns to
                               match at least one entity each
  --use-set-session-authorization
                               use SET SESSION AUTHORIZATION commands instead of
                               ALTER OWNER commands to set ownership

Connection options:
  -h, --host=HOSTNAME      database server host or socket directory
  -p, --port=PORT          database server port number
  -U, --username=NAME      connect as specified database user
  -w, --no-password        never prompt for password
  -W, --password           force password prompt (should happen automatically)
  --role=ROLENAME          do SET ROLE before restore

The options -I, -n, -P, -t, -T, and --section can be combined and specified
multiple times to select multiple objects.

If no input file name is supplied, then standard input is used.

Report bugs to &lt;pgsql-bugs@postgresql.org&gt;.
</code></pre>
</section><section id="根据对象列表文件还原1" class="slide level2">
<h1>根据对象列表文件还原1</h1>
<p>还原时，可以先获取备份文件中备份对象的列表，然后在列表中选择需要还原的对象。 首先，执行如下命令，获取备份文件中对象的列表；列表文件包含了备份文件中所有对象的信息：</p>
<pre><code>    pg_restore -l -f dump.lst dumpfile.dmp</code></pre>
<p>生成的对象列表文件&quot;dump.lst&quot;中，会有如下的对象信息：</p>
<pre><code>    3; 2445711 TABLE C_HISTORY SYSTEM
    4; 2609506 TABLE HISTORY SYSTEM
    5; 2445711 TABLE DATA C_HISTORY SYSTEM
    6; 2609506 TABLE DATA HISTORY </code></pre>
</section><section id="根据对象列表文件还原2" class="slide level2">
<h1>根据对象列表文件还原2</h1>
<p>然后，在生成的列表文件中，对不需要还原的对象，在行首标注'；'，或将对象所在的行删除。另外，还可以重新排列各对象在列表文件中顺序，从而指定还原顺序。 最后，通过指定修改后的对象列表文件，还原数据库：</p>
<pre><code>pg_restore  -L dump.lst dumpfile.dmp</code></pre>
</section></section>
<section><section id="pg_restore基本流程" class="titleslide slide level1"><h1>pg_restore基本流程</h1></section><section id="打开归档文件并读取toc" class="slide level2">
<h1>打开归档文件并读取TOC</h1>
<pre><code>(gdb) bt
#0  ReadToc (AH=0x62c3e0) at pg_backup_archiver.c:2520
#1  0x000000000040ee1e in InitArchiveFmt_Custom (AH=0x62c3e0) at pg_backup_custom.c:190
#2  0x0000000000408b81 in _allocAH (FileSpec=0x7fffffffe2d1 &quot;./test.sql&quot;,
    fmt=archUnknown, compression=0, mode=archModeRead,
    setupWorkerPtr=0x4042cb &lt;setupRestoreWorker&gt;) at pg_backup_archiver.c:2334
#3  0x0000000000404363 in OpenArchive (FileSpec=0x7fffffffe2d1 &quot;./test.sql&quot;,
    fmt=archUnknown) at pg_backup_archiver.c:219
#4  0x0000000000403dd9 in main (argc=3, argv=0x7fffffffdf28) at pg_restore.c:383
</code></pre>
</section><section id="恢复数据" class="slide level2">
<h1>恢复数据</h1>
<pre><code>(gdb) bt
#0  restore_toc_entry (AH=0x62c3e0, te=0x631ce0, is_parallel=0 &#39;\000&#39;)
    at pg_backup_archiver.c:711
#1  0x000000000040500e in RestoreArchive (AHX=0x62c3e0) at pg_backup_archiver.c:653
#2  0x0000000000403ea3 in main (argc=3, argv=0x7fffffffdf28) at pg_restore.c:422
(gdb) </code></pre>
</section><section id="例子" class="slide level2">
<h1>例子：</h1>
<pre><code>1. 向服务器发送`copy table from stdin;`
2. 紧接着从归档文件中读取数据
#0  ReadDataFromArchive (AH=0x62c3e0, compression=-1, readF=0x40ff0e &lt;_CustomReadFunc&gt;)
    at compress_io.c:162
#1  0x000000000040f4e1 in _PrintData (AH=0x62c3e0) at pg_backup_custom.c:514
#2  0x000000000040f465 in _PrintTocData (AH=0x62c3e0, te=0x632fe0)
    at pg_backup_custom.c:494
#3  0x00000000004057f9 in restore_toc_entry (AH=0x62c3e0, te=0x632fe0,
    is_parallel=0 &#39;\000&#39;) at pg_backup_archiver.c:892
#4  0x000000000040500e in RestoreArchive (AHX=0x62c3e0) at pg_backup_archiver.c:653
#5  0x0000000000403ea3 in main (argc=3, argv=0x7fffffffdf28) at pg_restore.c:422</code></pre>
</section></section>
<section><section id="pg_restore-事务" class="titleslide slide level1"><h1>pg_restore 事务</h1></section><section id="默认是每个对象开启一个事务" class="slide level2">
<h1>默认是每个对象开启一个事务</h1>
<pre><code>begin;
copy xxx from stdin;
commit;
begin;
copy xxx from stdin;
commit;
...</code></pre>
</section><section id="单事务还原" class="slide level2">
<h1>单事务还原</h1>
<p>如果加上--single-transaction那么是整个还原过程是在一个事务里面</p>
<pre><code>begin;
copy xxx from stdin;
copy xxx from stdin;
...
commit;</code></pre>
</section></section>
    </div>
  </div>

  <script src="reveal.js/lib/js/head.min.js"></script>
  <script src="reveal.js/js/reveal.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // Display controls in the bottom right corner
        controls: true,
        // Display a presentation progress bar
        progress: true,
        // Display the page number of the current slide
        slideNumber: false,

        // Optional reveal.js plugins
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: 'reveal.js/plugin/notes/notes.js', async: true }
        ]
      });
    </script>
    </body>
</html>
