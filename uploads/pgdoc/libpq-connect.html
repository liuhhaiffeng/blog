<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>32.1. Database Connection Control Functions</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="libpq.html" title="Chapter 32. libpq - C Library" /><link rel="next" href="libpq-status.html" title="32.2. Connection Status Functions" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">32.1. Database Connection Control Functions</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="libpq.html" title="Chapter 32. libpq - C Library">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="libpq.html" title="Chapter 32. libpq - C Library">Up</a></td><th width="60%" align="center">Chapter 32. <span xmlns="http://www.w3.org/1999/xhtml" class="application">libpq</span> - C Library</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10devel Documentation">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="libpq-status.html" title="32.2. Connection Status Functions">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="libpq-connect"><div class="titlepage"><div><div><h2 class="title" style="clear: both">32.1. Database Connection Control Functions</h2></div></div></div><p>   The following functions deal with making a connection to a
   <span class="productname">PostgreSQL</span> backend server.  An
   application program can have several backend connections open at
   one time.  (One reason to do that is to access more than one
   database.)  Each connection is represented by a
   <code class="structname">PGconn</code><a id="idm45642355683360" class="indexterm"></a> object, which
   is obtained from the function <code class="function">PQconnectdb</code>,
   <code class="function">PQconnectdbParams</code>, or
   <code class="function">PQsetdbLogin</code>.  Note that these functions will always
   return a non-null object pointer, unless perhaps there is too
   little memory even to allocate the <code class="structname">PGconn</code> object.
   The <code class="function">PQstatus</code> function should be called to check
   the return value for a successful connection before queries are sent
   via the connection object.

   </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>     On Unix, forking a process with open libpq connections can lead to
     unpredictable results because the parent and child processes share
     the same sockets and operating system resources.  For this reason,
     such usage is not recommended, though doing an <code class="function">exec</code> from
     the child process to load a new executable is safe.
    </p></div><p>

   </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>     On Windows, there is a way to improve performance if a single
     database connection is repeatedly started and shutdown.  Internally,
     libpq calls <code class="function">WSAStartup()</code> and <code class="function">WSACleanup()</code> for connection startup
     and shutdown, respectively.  <code class="function">WSAStartup()</code> increments an internal
     Windows library reference count which is decremented by <code class="function">WSACleanup()</code>.
     When the reference count is just one, calling <code class="function">WSACleanup()</code> frees
     all resources and all DLLs are unloaded.  This is an expensive
     operation.  To avoid this, an application can manually call
     <code class="function">WSAStartup()</code> so resources will not be freed when the last database
     connection is closed.
    </p></div><p>

   </p><div class="variablelist"><dl class="variablelist"><dt id="libpq-pqconnectdbparams"><span class="term"><code class="function">PQconnectdbParams</code><a id="idm45642355670624" class="indexterm"></a></span></dt><dd><p>       Makes a new connection to the database server.

</p><pre class="synopsis">PGconn *PQconnectdbParams(const char * const *keywords,
                          const char * const *values,
                          int expand_dbname);</pre><p>
      </p><p>       This function opens a new database connection using the parameters taken
       from two <code class="symbol">NULL</code>-terminated arrays. The first,
       <code class="literal">keywords</code>, is defined as an array of strings, each one
       being a key word. The second, <code class="literal">values</code>, gives the value
       for each key word. Unlike <code class="function">PQsetdbLogin</code> below, the parameter
       set can be extended without changing the function signature, so use of
       this function (or its nonblocking analogs <code class="function">PQconnectStartParams</code>
       and <code class="function">PQconnectPoll</code>) is preferred for new application
       programming.
      </p><p>       The currently recognized parameter key words are listed in
       <a class="xref" href="libpq-connect.html#libpq-paramkeywords" title="32.1.2. Parameter Key Words">Section 32.1.2, “Parameter Key Words”</a>.
      </p><p>       When <code class="literal">expand_dbname</code> is non-zero, the
       <em class="parameter"><code>dbname</code></em> key word value is allowed to be recognized
       as a connection string. Only the first occurrence of
       <em class="parameter"><code>dbname</code></em> is expanded this way, any subsequent
       <em class="parameter"><code>dbname</code></em> value is processed as plain database name. More
       details on the possible connection string formats appear in
       <a class="xref" href="libpq-connect.html#libpq-connstring" title="32.1.1. Connection Strings">Section 32.1.1, “Connection Strings”</a>.
      </p><p>       The passed arrays can be empty to use all default parameters, or can
       contain one or more parameter settings. They should be matched in length.
       Processing will stop at the first <code class="symbol">NULL</code> element
       in the <code class="literal">keywords</code> array.
      </p><p>       If  any  parameter is <code class="symbol">NULL</code> or an empty string, the corresponding
       environment variable (see <a class="xref" href="libpq-envars.html" title="32.14. Environment Variables">Section 32.14, “Environment Variables”</a>) is checked.
       If the  environment  variable is not set either, then the indicated
       built-in defaults are used.
      </p><p>       In general key words are processed from the beginning of these arrays in index
       order. The effect of this is that when key words are repeated, the last processed
       value is retained. Therefore, through careful placement of the
       <em class="parameter"><code>dbname</code></em> key word, it is possible to determine what may
       be overridden by a <em class="parameter"><code>conninfo</code></em> string, and what may not.
      </p></dd><dt id="libpq-pqconnectdb"><span class="term"><code class="function">PQconnectdb</code><a id="idm45642355652320" class="indexterm"></a></span></dt><dd><p>       Makes a new connection to the database server.

</p><pre class="synopsis">PGconn *PQconnectdb(const char *conninfo);</pre><p>
      </p><p>       This function opens a new database connection using the parameters taken
       from the string <code class="literal">conninfo</code>.
      </p><p>       The passed string can be empty to use all default parameters, or it can
       contain one or more parameter settings separated by whitespace,
       or it can contain a <acronym class="acronym">URI</acronym>.
       See <a class="xref" href="libpq-connect.html#libpq-connstring" title="32.1.1. Connection Strings">Section 32.1.1, “Connection Strings”</a> for details.
     </p></dd><dt id="libpq-pqsetdblogin"><span class="term"><code class="function">PQsetdbLogin</code><a id="idm45642355646496" class="indexterm"></a></span></dt><dd><p>       Makes a new connection to the database server.
</p><pre class="synopsis">PGconn *PQsetdbLogin(const char *pghost,
                     const char *pgport,
                     const char *pgoptions,
                     const char *pgtty,
                     const char *dbName,
                     const char *login,
                     const char *pwd);</pre><p>
       </p><p>        This is the predecessor of <code class="function">PQconnectdb</code> with a fixed
        set of parameters.  It has the same functionality except that the
        missing parameters will always take on default values.  Write <code class="symbol">NULL</code> or an
        empty string for any one of the fixed parameters that is to be defaulted.
      </p><p>        If the <em class="parameter"><code>dbName</code></em> contains
        an <code class="symbol">=</code> sign or has a valid connection <acronym class="acronym">URI</acronym> prefix, it
        is taken as a <em class="parameter"><code>conninfo</code></em> string in exactly the same way as
        if it had been passed to <code class="function">PQconnectdb</code>, and the remaining
        parameters are then applied as specified for <code class="function">PQconnectdbParams</code>.
      </p></dd><dt id="libpq-pqsetdb"><span class="term"><code class="function">PQsetdb</code><a id="idm45642355637328" class="indexterm"></a></span></dt><dd><p>   Makes a new connection to the database server.
</p><pre class="synopsis">PGconn *PQsetdb(char *pghost,
                char *pgport,
                char *pgoptions,
                char *pgtty,
                char *dbName);</pre><p>
     </p><p>      This is a macro that calls <code class="function">PQsetdbLogin</code> with null pointers
      for the <em class="parameter"><code>login</code></em> and <em class="parameter"><code>pwd</code></em> parameters.  It is provided
      for backward compatibility with very old programs.
     </p></dd><dt id="libpq-pqconnectstartparams"><span class="term"><code class="function">PQconnectStartParams</code><a id="idm45642355631520" class="indexterm"></a><br /></span><span class="term"><code class="function">PQconnectStart</code><a id="idm45642355630144" class="indexterm"></a><br /></span><span class="term"><code class="function">PQconnectPoll</code><a id="idm45642355628768" class="indexterm"></a></span></dt><dd><p>       <a id="idm45642355627696" class="indexterm"></a>
       Make a connection to the database server in a nonblocking manner.

</p><pre class="synopsis">PGconn *PQconnectStartParams(const char * const *keywords,
                             const char * const *values,
                             int expand_dbname);

PGconn *PQconnectStart(const char *conninfo);

PostgresPollingStatusType PQconnectPoll(PGconn *conn);</pre><p>
      </p><p>       These three functions are used to open a connection to a database server such
       that your application's thread of execution is not blocked on remote I/O
       whilst doing so. The point of this approach is that the waits for I/O to
       complete can occur in the application's main loop, rather than down inside
       <code class="function">PQconnectdbParams</code> or <code class="function">PQconnectdb</code>, and so the
       application can manage this operation in parallel with other activities.
      </p><p>       With <code class="function">PQconnectStartParams</code>, the database connection is made
       using the parameters taken from the <code class="literal">keywords</code> and
       <code class="literal">values</code> arrays, and controlled by <code class="literal">expand_dbname</code>,
       as described above for <code class="function">PQconnectdbParams</code>.
      </p><p>       With <code class="function">PQconnectStart</code>, the database connection is made
       using the parameters taken from the string <code class="literal">conninfo</code> as
       described above for <code class="function">PQconnectdb</code>.
      </p><p>       Neither <code class="function">PQconnectStartParams</code> nor <code class="function">PQconnectStart</code>
       nor <code class="function">PQconnectPoll</code> will block, so long as a number of
       restrictions are met:
       </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>          The <code class="literal">hostaddr</code> and <code class="literal">host</code> parameters are used appropriately to ensure that
          name and reverse name queries are not made. See the documentation of
          these parameters in <a class="xref" href="libpq-connect.html#libpq-paramkeywords" title="32.1.2. Parameter Key Words">Section 32.1.2, “Parameter Key Words”</a> for details.
         </p></li><li class="listitem"><p>          If you call <code class="function">PQtrace</code>, ensure that the stream object
          into which you trace will not block.
         </p></li><li class="listitem"><p>          You ensure that the socket is in the appropriate state
          before calling <code class="function">PQconnectPoll</code>, as described below.
         </p></li></ul></div><p>
      </p><p>       Note: use of <code class="function">PQconnectStartParams</code> is analogous to
       <code class="function">PQconnectStart</code> shown below.
      </p><p>       To begin a nonblocking connection request, call <code class="literal">conn = PQconnectStart("<em class="replaceable"><code>connection_info_string</code></em>")</code>.
       If <code class="varname">conn</code> is null, then <span class="application">libpq</span> has been unable to allocate a new <code class="structname">PGconn</code>
       structure. Otherwise, a valid <code class="structname">PGconn</code> pointer is returned (though not yet
       representing a valid connection to the database). On return from
       <code class="function">PQconnectStart</code>, call <code class="literal">status = PQstatus(conn)</code>. If <code class="varname">status</code> equals
       <code class="symbol">CONNECTION_BAD</code>, <code class="function">PQconnectStart</code> has failed.
      </p><p>       If <code class="function">PQconnectStart</code> succeeds, the next stage is to poll
       <span class="application">libpq</span> so that it can proceed with the connection sequence.
       Use <code class="function">PQsocket(conn)</code> to obtain the descriptor of the
       socket underlying the database connection.
       Loop thus: If <code class="function">PQconnectPoll(conn)</code> last returned
       <code class="symbol">PGRES_POLLING_READING</code>, wait until the socket is ready to
       read (as indicated by <code class="function">select()</code>, <code class="function">poll()</code>, or
       similar system function).
       Then call <code class="function">PQconnectPoll(conn)</code> again.
       Conversely, if <code class="function">PQconnectPoll(conn)</code> last returned
       <code class="symbol">PGRES_POLLING_WRITING</code>, wait until the socket is ready
       to write, then call <code class="function">PQconnectPoll(conn)</code> again.
       If you have yet to call
       <code class="function">PQconnectPoll</code>, i.e., just after the call to
       <code class="function">PQconnectStart</code>, behave as if it last returned
       <code class="symbol">PGRES_POLLING_WRITING</code>.  Continue this loop until
       <code class="function">PQconnectPoll(conn)</code> returns
       <code class="symbol">PGRES_POLLING_FAILED</code>, indicating the connection procedure
       has failed, or <code class="symbol">PGRES_POLLING_OK</code>, indicating the connection
       has been successfully made.
      </p><p>       At any time during connection, the status of the connection can be
       checked by calling <code class="function">PQstatus</code>. If this call returns <code class="symbol">CONNECTION_BAD</code>, then the
       connection procedure has failed; if the call returns <code class="function">CONNECTION_OK</code>, then the
       connection is ready.  Both of these states are equally detectable
       from the return value of <code class="function">PQconnectPoll</code>, described above. Other states might also occur
       during (and only during) an asynchronous connection procedure. These
       indicate the current stage of the connection procedure and might be useful
       to provide feedback to the user for example. These statuses are:

       </p><div class="variablelist"><dl class="variablelist"><dt id="libpq-connection-started"><span class="term"><code class="symbol">CONNECTION_STARTED</code></span></dt><dd><p>           Waiting for connection to be made.
          </p></dd><dt id="libpq-connection-made"><span class="term"><code class="symbol">CONNECTION_MADE</code></span></dt><dd><p>           Connection OK; waiting to send.
          </p></dd><dt id="libpq-connection-awaiting-response"><span class="term"><code class="symbol">CONNECTION_AWAITING_RESPONSE</code></span></dt><dd><p>           Waiting for a response from the server.
          </p></dd><dt id="libpq-connection-auth-ok"><span class="term"><code class="symbol">CONNECTION_AUTH_OK</code></span></dt><dd><p>           Received authentication; waiting for backend start-up to finish.
          </p></dd><dt id="libpq-connection-ssl-startup"><span class="term"><code class="symbol">CONNECTION_SSL_STARTUP</code></span></dt><dd><p>           Negotiating SSL encryption.
          </p></dd><dt id="libpq-connection-setenv"><span class="term"><code class="symbol">CONNECTION_SETENV</code></span></dt><dd><p>           Negotiating environment-driven parameter settings.
          </p></dd></dl></div><p>

       Note that, although these constants will remain (in order to maintain
       compatibility), an application should never rely upon these occurring in a
       particular order, or at all, or on the status always being one of these
       documented values. An application might do something like this:
</p><pre class="programlisting">switch(PQstatus(conn))
{
        case CONNECTION_STARTED:
            feedback = "Connecting...";
            break;

        case CONNECTION_MADE:
            feedback = "Connected to server...";
            break;
.
.
.
        default:
            feedback = "Connecting...";
}</pre><p>
      </p><p>       The <code class="literal">connect_timeout</code> connection parameter is ignored
       when using <code class="function">PQconnectPoll</code>; it is the application's
       responsibility to decide whether an excessive amount of time has elapsed.
       Otherwise, <code class="function">PQconnectStart</code> followed by a
       <code class="function">PQconnectPoll</code> loop is equivalent to
       <code class="function">PQconnectdb</code>.
      </p><p>       Note that if <code class="function">PQconnectStart</code> returns a non-null pointer, you must call
       <code class="function">PQfinish</code> when you are finished with it, in order to dispose of
       the structure and any associated memory blocks. This must be done even if
       the connection attempt fails or is abandoned.
      </p></dd><dt id="libpq-pqconndefaults"><span class="term"><code class="function">PQconndefaults</code><a id="idm45642355568416" class="indexterm"></a></span></dt><dd><p>       Returns the default connection options.
</p><pre class="synopsis">PQconninfoOption *PQconndefaults(void);

typedef struct
{
    char   *keyword;   /* The keyword of the option */
    char   *envvar;    /* Fallback environment variable name */
    char   *compiled;  /* Fallback compiled in default value */
    char   *val;       /* Option's current value, or NULL */
    char   *label;     /* Label for field in connect dialog */
    char   *dispchar;  /* Indicates how to display this field
                          in a connect dialog. Values are:
                          ""        Display entered value as is
                          "*"       Password field - hide value
                          "D"       Debug option - don't show by default */
    int     dispsize;  /* Field size in characters for dialog */
} PQconninfoOption;</pre><p>
      </p><p>       Returns a connection options array.  This can be used to determine
       all possible <code class="function">PQconnectdb</code> options and their
       current default values.  The return value points to an array of
       <code class="structname">PQconninfoOption</code> structures, which ends
       with an entry having a null <code class="structfield">keyword</code> pointer.  The
       null pointer is returned if memory could not be allocated. Note that
       the current default values (<code class="structfield">val</code> fields)
       will depend on environment variables and other context.  A
       missing or invalid service file will be silently ignored.  Callers
       must treat the connection options data as read-only.
      </p><p>       After processing the options array, free it by passing it to
       <code class="function">PQconninfoFree</code>.  If this is not done, a small amount of memory
       is leaked for each call to <code class="function">PQconndefaults</code>.
      </p></dd><dt id="libpq-pqconninfo"><span class="term"><code class="function">PQconninfo</code><a id="idm45642355559968" class="indexterm"></a></span></dt><dd><p>       Returns the connection options used by a live connection.
</p><pre class="synopsis">PQconninfoOption *PQconninfo(PGconn *conn);</pre><p>
      </p><p>       Returns a connection options array.  This can be used to determine
       all possible <code class="function">PQconnectdb</code> options and the
       values that were used to connect to the server. The return
       value points to an array of <code class="structname">PQconninfoOption</code>
       structures, which ends with an entry having a null <code class="structfield">keyword</code>
       pointer. All notes above for <code class="function">PQconndefaults</code> also
       apply to the result of <code class="function">PQconninfo</code>.
      </p></dd><dt id="libpq-pqconninfoparse"><span class="term"><code class="function">PQconninfoParse</code><a id="idm45642355553248" class="indexterm"></a></span></dt><dd><p>       Returns parsed connection options from the provided connection string.

</p><pre class="synopsis">PQconninfoOption *PQconninfoParse(const char *conninfo, char **errmsg);</pre><p>
      </p><p>       Parses a connection string and returns the resulting options as an
       array; or returns <code class="symbol">NULL</code> if there is a problem with the connection
       string.  This function can be used to extract
       the <code class="function">PQconnectdb</code> options in the provided
       connection string.  The return value points to an array of
       <code class="structname">PQconninfoOption</code> structures, which ends
       with an entry having a null <code class="structfield">keyword</code> pointer.
      </p><p>       All legal options will be present in the result array, but the
       <code class="literal">PQconninfoOption</code> for any option not present
       in the connection string will have <code class="literal">val</code> set to
       <code class="literal">NULL</code>; default values are not inserted.
      </p><p>       If <code class="literal">errmsg</code> is not <code class="symbol">NULL</code>, then <code class="literal">*errmsg</code> is set
       to <code class="symbol">NULL</code> on success, else to a <code class="function">malloc</code>'d error string explaining
       the problem.  (It is also possible for <code class="literal">*errmsg</code> to be
       set to <code class="symbol">NULL</code> and the function to return <code class="symbol">NULL</code>;
       this indicates an out-of-memory condition.)
      </p><p>       After processing the options array, free it by passing it to
       <code class="function">PQconninfoFree</code>.  If this is not done, some memory
       is leaked for each call to <code class="function">PQconninfoParse</code>.
       Conversely, if an error occurs and <code class="literal">errmsg</code> is not <code class="symbol">NULL</code>,
       be sure to free the error string using <code class="function">PQfreemem</code>.
      </p></dd><dt id="libpq-pqfinish"><span class="term"><code class="function">PQfinish</code><a id="idm45642355535952" class="indexterm"></a></span></dt><dd><p>       Closes  the  connection to the server.  Also frees
       memory used by the <code class="structname">PGconn</code> object.
</p><pre class="synopsis">void PQfinish(PGconn *conn);</pre><p>
      </p><p>       Note that even if the server connection attempt fails (as
       indicated by <code class="function">PQstatus</code>), the application should call <code class="function">PQfinish</code>
       to free the memory used by the <code class="structname">PGconn</code> object.
       The <code class="structname">PGconn</code> pointer must not be used again after
       <code class="function">PQfinish</code> has been called.
      </p></dd><dt id="libpq-pqreset"><span class="term"><code class="function">PQreset</code><a id="idm45642355528960" class="indexterm"></a></span></dt><dd><p>       Resets the communication channel to the server.
</p><pre class="synopsis">void PQreset(PGconn *conn);</pre><p>
      </p><p>       This function will close the connection
       to the server and attempt to  reestablish  a  new
       connection to the same server, using all the same
       parameters previously used.  This might be useful for
       error recovery if a working connection is lost.
      </p></dd><dt id="libpq-pqresetstart"><span class="term"><code class="function">PQresetStart</code><a id="idm45642355525312" class="indexterm"></a><br /></span><span class="term"><code class="function">PQresetPoll</code><a id="idm45642355523936" class="indexterm"></a></span></dt><dd><p>       Reset the communication channel to the server, in a nonblocking manner.

</p><pre class="synopsis">int PQresetStart(PGconn *conn);

PostgresPollingStatusType PQresetPoll(PGconn *conn);</pre><p>
      </p><p>       These functions will close the connection to the server and attempt to
       reestablish a new connection to the same server, using all the same
       parameters previously used. This can be useful for error recovery if a
       working connection is lost. They differ from <code class="function">PQreset</code> (above) in that they
       act in a nonblocking manner. These functions suffer from the same
       restrictions as <code class="function">PQconnectStartParams</code>, <code class="function">PQconnectStart</code>
       and <code class="function">PQconnectPoll</code>.
      </p><p>       To initiate a connection reset, call
       <code class="function">PQresetStart</code>. If it returns 0, the reset has
       failed. If it returns 1, poll the reset using
       <code class="function">PQresetPoll</code> in exactly the same way as you
       would create the connection using <code class="function">PQconnectPoll</code>.
      </p></dd><dt id="libpq-pqpingparams"><span class="term"><code class="function">PQpingParams</code><a id="idm45642355514656" class="indexterm"></a></span></dt><dd><p>       <code class="function">PQpingParams</code> reports the status of the
       server.  It accepts connection parameters identical to those of
       <code class="function">PQconnectdbParams</code>, described above.  It is not
       necessary to supply correct user name, password, or database name
       values to obtain the server status; however, if incorrect values
       are provided, the server will log a failed connection attempt.

</p><pre class="synopsis">PGPing PQpingParams(const char * const *keywords,
                    const char * const *values,
                    int expand_dbname);</pre><p>

       The function returns one of the following values:

       </p><div class="variablelist"><dl class="variablelist"><dt id="libpq-pqpingparams-pqping-ok"><span class="term"><code class="literal">PQPING_OK</code></span></dt><dd><p>           The server is running and appears to be accepting connections.
          </p></dd><dt id="libpq-pqpingparams-pqping-reject"><span class="term"><code class="literal">PQPING_REJECT</code></span></dt><dd><p>           The server is running but is in a state that disallows connections
           (startup, shutdown, or crash recovery).
          </p></dd><dt id="libpq-pqpingparams-pqping-no-response"><span class="term"><code class="literal">PQPING_NO_RESPONSE</code></span></dt><dd><p>           The server could not be contacted.  This might indicate that the
           server is not running, or that there is something wrong with the
           given connection parameters (for example, wrong port number), or
           that there is a network connectivity problem (for example, a
           firewall blocking the connection request).
          </p></dd><dt id="libpq-pqpingparams-pqping-no-attempt"><span class="term"><code class="literal">PQPING_NO_ATTEMPT</code></span></dt><dd><p>           No attempt was made to contact the server, because the supplied
           parameters were obviously incorrect or there was some client-side
           problem (for example, out of memory).
          </p></dd></dl></div><p>

      </p></dd><dt id="libpq-pqping"><span class="term"><code class="function">PQping</code><a id="idm45642355501824" class="indexterm"></a></span></dt><dd><p>       <code class="function">PQping</code> reports the status of the
       server.  It accepts connection parameters identical to those of
       <code class="function">PQconnectdb</code>, described above.  It is not
       necessary to supply correct user name, password, or database name
       values to obtain the server status; however, if incorrect values
       are provided, the server will log a failed connection attempt.

</p><pre class="synopsis">PGPing PQping(const char *conninfo);</pre><p>
      </p><p>       The return values are the same as for <code class="function">PQpingParams</code>.
      </p></dd></dl></div><p>
  </p><div class="sect2" id="libpq-connstring"><div class="titlepage"><div><div><h3 class="title">32.1.1. Connection Strings</h3></div></div></div><a id="idm45642355496336" class="indexterm"></a><a id="idm45642355494864" class="indexterm"></a><p>    Several <span class="application">libpq</span> functions parse a user-specified string to obtain
    connection parameters.  There are two accepted formats for these strings:
    plain <code class="literal">keyword = value</code> strings
    and URIs.  URIs generally follow
    <a class="ulink" href="http://www.ietf.org/rfc/rfc3986.txt" target="_top">RFC
    3986</a>, except that multi-host connection strings are allowed
    as further described below.
   </p><div class="sect3" id="idm45642355490720"><div class="titlepage"><div><div><h4 class="title">32.1.1.1. Keyword/Value Connection Strings</h4></div></div></div><p>    In the first format, each parameter setting is in the form
    <code class="literal">keyword = value</code>.  Spaces around the equal sign are
    optional. To write an empty value, or a value containing spaces, surround it
    with single quotes, e.g., <code class="literal">keyword = 'a value'</code>. Single
    quotes and backslashes within
    the value must be escaped with a backslash, i.e., <code class="literal">\'</code> and
    <code class="literal">\\</code>.
   </p><p>    Example:
</p><pre class="programlisting">host=localhost port=5432 dbname=mydb connect_timeout=10</pre><p>
   </p><p>    The recognized parameter key words are listed in <a class="xref" href="libpq-connect.html#libpq-paramkeywords" title="32.1.2. Parameter Key Words">Section 32.1.2, “Parameter Key Words”</a>.
   </p></div><div class="sect3" id="idm45642355484928"><div class="titlepage"><div><div><h4 class="title">32.1.1.2. Connection URIs</h4></div></div></div><p>   The general form for a connection <acronym class="acronym">URI</acronym> is:
</p><pre class="synopsis">postgresql://[user[:password]@][netloc][:port][,...][/dbname][?param1=value1&amp;...]</pre><p>
   </p><p>    The <acronym class="acronym">URI</acronym> scheme designator can be either
    <code class="literal">postgresql://</code> or <code class="literal">postgres://</code>.  Each
    of the <acronym class="acronym">URI</acronym> parts is optional.  The following examples
    illustrate valid <acronym class="acronym">URI</acronym> syntax uses:
</p><pre class="programlisting">postgresql://
postgresql://localhost
postgresql://localhost:5433
postgresql://localhost/mydb
postgresql://user@localhost
postgresql://user:secret@localhost
postgresql://other@localhost/otherdb?connect_timeout=10&amp;application_name=myapp
postgresql://host1:123,host2:456/somedb?target_session_attrs=any&amp;application_name=myapp</pre><p>
    Components of the hierarchical part of the <acronym class="acronym">URI</acronym> can also
    be given as parameters.  For example:
</p><pre class="programlisting">postgresql:///mydb?host=localhost&amp;port=5433</pre><p>
   </p><p>    Percent-encoding may be used to include symbols with special meaning in any
    of the <acronym class="acronym">URI</acronym> parts.
   </p><p>    Any connection parameters not corresponding to key words listed in <a class="xref" href="libpq-connect.html#libpq-paramkeywords" title="32.1.2. Parameter Key Words">Section 32.1.2, “Parameter Key Words”</a> are ignored and a warning message about them
    is sent to <code class="filename">stderr</code>.
   </p><p>    For improved compatibility with JDBC connection <acronym class="acronym">URI</acronym>s,
    instances of parameter <code class="literal">ssl=true</code> are translated into
    <code class="literal">sslmode=require</code>.
   </p><p>    The host part may be either host name or an IP address.  To specify an
    IPv6 host address, enclose it in square brackets:
</p><pre class="synopsis">postgresql://[2001:db8::1234]/database</pre><p>
   </p><p>    The host component is interpreted as described for the parameter <a class="xref" href="libpq-connect.html#libpq-connect-host">host</a>.  In particular, a Unix-domain socket
    connection is chosen if the host part is either empty or starts with a
    slash, otherwise a TCP/IP connection is initiated.  Note, however, that the
    slash is a reserved character in the hierarchical part of the URI.  So, to
    specify a non-standard Unix-domain socket directory, either omit the host
    specification in the URI and specify the host as a parameter, or
    percent-encode the path in the host component of the URI:
</p><pre class="programlisting">postgresql:///dbname?host=/var/lib/postgresql
postgresql://%2Fvar%2Flib%2Fpostgresql/dbname</pre><p>
   </p><p>    It is possible to specify multiple host components, each with an optional
    port component, in a single URI.  A URI of the form
    <code class="literal">postgresql://host1:port1,host2:port2,host3:port3/</code>
    is equivalent to a connection string of the form
    <code class="literal">host=host1,host2,host3 port=port1,port2,port3</code>.  Each
    host will be tried in turn until a connection is successfully established.
   </p></div></div><div class="sect2" id="libpq-paramkeywords"><div class="titlepage"><div><div><h3 class="title">32.1.2. Parameter Key Words</h3></div></div></div><p>    The currently recognized parameter key words are:

    </p><div class="variablelist"><dl class="variablelist"><dt id="libpq-connect-host"><span class="term"><code class="literal">host</code></span></dt><dd><p>        Comma-separated list of host names.<a id="idm45642355464128" class="indexterm"></a>
        If a host name begins with a slash, it specifies Unix-domain
        communication rather than TCP/IP communication; the value is the
        name of the directory in which the socket file is stored.  If
        multiple host names are specified, each will be tried in turn in
        the order given.  The default behavior when <code class="literal">host</code> is
        not specified is to connect to a Unix-domain
        socket<a id="idm45642355462192" class="indexterm"></a> in
        <code class="filename">/tmp</code> (or whatever socket directory was specified
        when <span class="productname">PostgreSQL</span> was built). On machines without
        Unix-domain sockets, the default is to connect to <code class="literal">localhost</code>.
       </p></dd><dt id="libpq-connect-hostaddr"><span class="term"><code class="literal">hostaddr</code></span></dt><dd><p>        Numeric IP address of host to connect to.  This should be in the
        standard IPv4 address format, e.g., <code class="literal">172.28.40.9</code>.  If
        your machine supports IPv6, you can also use those addresses.
        TCP/IP communication is
        always used when a nonempty string is specified for this parameter.
       </p><p>        Using <code class="literal">hostaddr</code> instead of <code class="literal">host</code> allows the
        application to avoid a host name look-up, which might be important
        in applications with time constraints. However, a host name is
        required for GSSAPI or SSPI authentication
        methods, as well as for <code class="literal">verify-full</code> SSL
        certificate verification.  The following rules are used:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>           If <code class="literal">host</code> is specified without <code class="literal">hostaddr</code>,
           a host name lookup occurs.
          </p></li><li class="listitem"><p>           If <code class="literal">hostaddr</code> is specified without <code class="literal">host</code>,
           the value for <code class="literal">hostaddr</code> gives the server network address.
           The connection attempt will fail if the authentication
           method requires a host name.
          </p></li><li class="listitem"><p>           If both <code class="literal">host</code> and <code class="literal">hostaddr</code> are specified,
           the value for <code class="literal">hostaddr</code> gives the server network address.
           The value for <code class="literal">host</code> is ignored unless the
           authentication method requires it, in which case it will be
           used as the host name.
          </p></li></ul></div><p>
        Note that authentication is likely to fail if <code class="literal">host</code>
        is not the name of the server at network address <code class="literal">hostaddr</code>.
        Also, note that <code class="literal">host</code> rather than <code class="literal">hostaddr</code>
        is used to identify the connection in <code class="filename">~/.pgpass</code> (see
        <a class="xref" href="libpq-pgpass.html" title="32.15. The Password File">Section 32.15, “The Password File”</a>).
       </p><p>        Without either a host name or host address,
        <span class="application">libpq</span> will connect using a
        local Unix-domain socket; or on machines without Unix-domain
        sockets, it will attempt to connect to <code class="literal">localhost</code>.
       </p></dd><dt id="libpq-connect-port"><span class="term"><code class="literal">port</code></span></dt><dd><p>        Port number to connect to at the server host, or socket file
        name extension for Unix-domain
        connections.<a id="idm45642355436656" class="indexterm"></a>
        If the <code class="literal">host</code> parameter included multiple, comma-separated
        hosts, this parameter may specify a list of ports of equal length,
        or it may specify a single port number to be used for all hosts.
       </p></dd><dt id="libpq-connect-dbname"><span class="term"><code class="literal">dbname</code></span></dt><dd><p>       The database name.  Defaults to be the same as the user name.
       In certain contexts, the value is checked for extended
       formats; see <a class="xref" href="libpq-connect.html#libpq-connstring" title="32.1.1. Connection Strings">Section 32.1.1, “Connection Strings”</a> for more details on
       those.
      </p></dd><dt id="libpq-connect-user"><span class="term"><code class="literal">user</code></span></dt><dd><p>       <span class="productname">PostgreSQL</span> user name to connect as.
       Defaults to be the same as the operating system name of the user
       running the application.
      </p></dd><dt id="libpq-connect-password"><span class="term"><code class="literal">password</code></span></dt><dd><p>       Password to be used if the server demands password authentication.
      </p></dd><dt id="libpq-connect-connect-timeout"><span class="term"><code class="literal">connect_timeout</code></span></dt><dd><p>       Maximum wait for connection, in seconds (write as a decimal integer
       string). Zero or not specified means wait indefinitely.  It is not
       recommended to use a timeout of less than 2 seconds.
       This timeout applies separately to each connection attempt.
       For example, if you specify two hosts and both of them are unreachable,
       and <code class="literal">connect_timeout</code> is 5, the total time spent waiting for a
       connection might be up to 10 seconds.
      </p></dd><dt id="libpq-connect-client-encoding"><span class="term"><code class="literal">client_encoding</code></span></dt><dd><p>       This sets the <code class="varname">client_encoding</code>
       configuration parameter for this connection.  In addition to
       the values accepted by the corresponding server option, you
       can use <code class="literal">auto</code> to determine the right
       encoding from the current locale in the client
       (<code class="envar">LC_CTYPE</code> environment variable on Unix
       systems).
      </p></dd><dt id="libpq-connect-options"><span class="term"><code class="literal">options</code></span></dt><dd><p>        Specifies command-line options to send to the server at connection
        start.  For example, setting this to <code class="literal">-c geqo=off</code> sets the
        session's value of the <code class="varname">geqo</code> parameter to
        <code class="literal">off</code>.  Spaces within this string are considered to
        separate command-line arguments, unless escaped with a backslash
        (<code class="literal">\</code>); write <code class="literal">\\</code> to represent a literal
        backslash.  For a detailed discussion of the available
        options, consult <a class="xref" href="runtime-config.html" title="Chapter 19. Server Configuration">Chapter 19, <em>Server Configuration</em></a>.
       </p></dd><dt id="libpq-connect-application-name"><span class="term"><code class="literal">application_name</code></span></dt><dd><p>        Specifies a value for the <a class="xref" href="runtime-config-logging.html#guc-application-name">application_name</a>
        configuration parameter.
       </p></dd><dt id="libpq-connect-fallback-application-name"><span class="term"><code class="literal">fallback_application_name</code></span></dt><dd><p>        Specifies a fallback value for the <a class="xref" href="runtime-config-logging.html#guc-application-name">application_name</a> configuration parameter.
        This value will be used if no value has been given for
        <code class="literal">application_name</code> via a connection parameter or the
        <code class="envar">PGAPPNAME</code> environment variable.  Specifying
        a fallback name is useful in generic utility programs that
        wish to set a default application name but allow it to be
        overridden by the user.
       </p></dd><dt id="libpq-keepalives"><span class="term"><code class="literal">keepalives</code></span></dt><dd><p>        Controls whether client-side TCP keepalives are used. The default
        value is 1, meaning on, but you can change this to 0, meaning off,
        if keepalives are not wanted.  This parameter is ignored for
        connections made via a Unix-domain socket.
       </p></dd><dt id="libpq-keepalives-idle"><span class="term"><code class="literal">keepalives_idle</code></span></dt><dd><p>        Controls the number of seconds of inactivity after which TCP should
        send a keepalive message to the server.  A value of zero uses the
        system default. This parameter is ignored for connections made via a
        Unix-domain socket, or if keepalives are disabled. It is only supported
        on systems where the <code class="symbol">TCP_KEEPIDLE</code> or <code class="symbol">TCP_KEEPALIVE</code>
        socket option is available, and on Windows; on other systems, it has no
        effect.
       </p></dd><dt id="libpq-keepalives-interval"><span class="term"><code class="literal">keepalives_interval</code></span></dt><dd><p>        Controls the number of seconds after which a TCP keepalive message
        that is not acknowledged by the server should be retransmitted.  A
        value of zero uses the system default. This parameter is ignored for
        connections made via a Unix-domain socket, or if keepalives are disabled.
        It is only supported on systems where the <code class="symbol">TCP_KEEPINTVL</code>
        socket option is available, and on Windows; on other systems, it has no
        effect.
       </p></dd><dt id="libpq-keepalives-count"><span class="term"><code class="literal">keepalives_count</code></span></dt><dd><p>        Controls the number of TCP keepalives that can be lost before the
        client's connection to the server is considered dead.  A value of
        zero uses the system default. This parameter is ignored for
        connections made via a Unix-domain socket, or if keepalives are disabled.
        It is only supported on systems where the <code class="symbol">TCP_KEEPCNT</code>
        socket option is available; on other systems, it has no effect.
       </p></dd><dt id="libpq-connect-tty"><span class="term"><code class="literal">tty</code></span></dt><dd><p>       Ignored (formerly, this specified where to send server debug output).
      </p></dd><dt id="libpq-connect-sslmode"><span class="term"><code class="literal">sslmode</code></span></dt><dd><p>        This option determines whether or with what priority a secure
        <acronym class="acronym">SSL</acronym> TCP/IP connection will be negotiated with the
        server. There are six modes:

        </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">disable</code></span></dt><dd><p>            only try a non-<acronym class="acronym">SSL</acronym> connection
           </p></dd><dt><span class="term"><code class="literal">allow</code></span></dt><dd><p>            first try a non-<acronym class="acronym">SSL</acronym> connection; if that
            fails, try an <acronym class="acronym">SSL</acronym> connection
           </p></dd><dt><span class="term"><code class="literal">prefer</code> (default)</span></dt><dd><p>            first try an <acronym class="acronym">SSL</acronym> connection; if that fails,
            try a non-<acronym class="acronym">SSL</acronym> connection
           </p></dd><dt><span class="term"><code class="literal">require</code></span></dt><dd><p>            only try an <acronym class="acronym">SSL</acronym> connection. If a root CA
            file is present, verify the certificate in the same way as
            if <code class="literal">verify-ca</code> was specified
           </p></dd><dt><span class="term"><code class="literal">verify-ca</code></span></dt><dd><p>            only try an <acronym class="acronym">SSL</acronym> connection, and verify that
            the server certificate is issued by a trusted
            certificate authority (<acronym class="acronym">CA</acronym>)
           </p></dd><dt><span class="term"><code class="literal">verify-full</code></span></dt><dd><p>            only try an <acronym class="acronym">SSL</acronym> connection, verify that the
            server certificate is issued by a
            trusted <acronym class="acronym">CA</acronym> and that the requested server host name
            matches that in the certificate
           </p></dd></dl></div><p>

        See <a class="xref" href="libpq-ssl.html" title="32.18. SSL Support">Section 32.18, “SSL Support”</a> for a detailed description of how
        these options work.
       </p><p>        <code class="literal">sslmode</code> is ignored for Unix domain socket
        communication.
        If <span class="productname">PostgreSQL</span> is compiled without SSL support,
        using options <code class="literal">require</code>, <code class="literal">verify-ca</code>, or
        <code class="literal">verify-full</code> will cause an error, while
        options <code class="literal">allow</code> and <code class="literal">prefer</code> will be
        accepted but <span class="application">libpq</span> will not actually attempt
        an <acronym class="acronym">SSL</acronym>
        connection.<a id="idm45642355371280" class="indexterm"></a>
       </p></dd><dt id="libpq-connect-requiressl"><span class="term"><code class="literal">requiressl</code></span></dt><dd><p>        This option is deprecated in favor of the <code class="literal">sslmode</code>
        setting.
       </p><p>        If set to 1, an <acronym class="acronym">SSL</acronym> connection to the server
        is required (this is equivalent to <code class="literal">sslmode</code>
        <code class="literal">require</code>).  <span class="application">libpq</span> will then refuse
        to connect if the server does not accept an
        <acronym class="acronym">SSL</acronym> connection.  If set to 0 (default),
        <span class="application">libpq</span> will negotiate the connection type with
        the server (equivalent to <code class="literal">sslmode</code>
        <code class="literal">prefer</code>).  This option is only available if
        <span class="productname">PostgreSQL</span> is compiled with SSL support.
       </p></dd><dt id="libpq-connect-sslcompression"><span class="term"><code class="literal">sslcompression</code></span></dt><dd><p>        If set to 1 (default), data sent over SSL connections will be
        compressed.
        If set to 0, compression will be disabled (this requires
        <span class="productname">OpenSSL</span> 1.0.0 or later).
        This parameter is ignored if a connection without SSL is made,
        or if the version of <span class="productname">OpenSSL</span> used does not support
        it.
       </p><p>        Compression uses CPU time, but can improve throughput if
        the network is the bottleneck.
        Disabling compression can improve response time and throughput
        if CPU performance is the limiting factor.
       </p></dd><dt id="libpq-connect-sslcert"><span class="term"><code class="literal">sslcert</code></span></dt><dd><p>        This parameter specifies the file name of the client SSL
        certificate, replacing the default
        <code class="filename">~/.postgresql/postgresql.crt</code>.
        This parameter is ignored if an SSL connection is not made.
       </p></dd><dt id="libpq-connect-sslkey"><span class="term"><code class="literal">sslkey</code></span></dt><dd><p>        This parameter specifies the location for the secret key used for
        the client certificate. It can either specify a file name that will
        be used instead of the default
        <code class="filename">~/.postgresql/postgresql.key</code>, or it can specify a key
        obtained from an external <span class="quote">“<span class="quote">engine</span>”</span> (engines are
        <span class="productname">OpenSSL</span> loadable modules).  An external engine
        specification should consist of a colon-separated engine name and
        an engine-specific key identifier.  This parameter is ignored if an
        SSL connection is not made.
       </p></dd><dt id="libpq-connect-sslrootcert"><span class="term"><code class="literal">sslrootcert</code></span></dt><dd><p>        This parameter specifies the name of a file containing SSL
        certificate authority (<acronym class="acronym">CA</acronym>) certificate(s).
        If the file exists, the server's certificate will be verified
        to be signed by one of these authorities.  The default is
        <code class="filename">~/.postgresql/root.crt</code>.
       </p></dd><dt id="libpq-connect-sslcrl"><span class="term"><code class="literal">sslcrl</code></span></dt><dd><p>        This parameter specifies the file name of the SSL certificate
        revocation list (CRL).  Certificates listed in this file, if it
        exists, will be rejected while attempting to authenticate the
        server's certificate.  The default is
        <code class="filename">~/.postgresql/root.crl</code>.
       </p></dd><dt id="libpq-connect-requirepeer"><span class="term"><code class="literal">requirepeer</code></span></dt><dd><p>        This parameter specifies the operating-system user name of the
        server, for example <code class="literal">requirepeer=postgres</code>.
        When making a Unix-domain socket connection, if this
        parameter is set, the client checks at the beginning of the
        connection that the server process is running under the specified
        user name; if it is not, the connection is aborted with an error.
        This parameter can be used to provide server authentication similar
        to that available with SSL certificates on TCP/IP connections.
        (Note that if the Unix-domain socket is in
        <code class="filename">/tmp</code> or another publicly writable location,
        any user could start a server listening there.  Use this parameter
        to ensure that you are connected to a server run by a trusted user.)
        This option is only supported on platforms for which the
        <code class="literal">peer</code> authentication method is implemented; see
        <a class="xref" href="auth-methods.html#auth-peer" title="20.3.6. Peer Authentication">Section 20.3.6, “Peer Authentication”</a>.
       </p></dd><dt id="libpq-connect-krbsrvname"><span class="term"><code class="literal">krbsrvname</code></span></dt><dd><p>        Kerberos service name to use when authenticating with GSSAPI.
        This must match the service name specified in the server
        configuration for Kerberos authentication to succeed. (See also
        <a class="xref" href="auth-methods.html#gssapi-auth" title="20.3.3. GSSAPI Authentication">Section 20.3.3, “GSSAPI Authentication”</a>.)
       </p></dd><dt id="libpq-connect-gsslib"><span class="term"><code class="literal">gsslib</code></span></dt><dd><p>        GSS library to use for GSSAPI authentication. Only used on Windows.
        Set to <code class="literal">gssapi</code> to force libpq to use the GSSAPI
        library for authentication instead of the default SSPI.
       </p></dd><dt id="libpq-connect-service"><span class="term"><code class="literal">service</code></span></dt><dd><p>        Service name to use for additional parameters.  It specifies a service
        name in <code class="filename">pg_service.conf</code> that holds additional connection parameters.
        This allows applications to specify only a service name so connection parameters
        can be centrally maintained. See <a class="xref" href="libpq-pgservice.html" title="32.16. The Connection Service File">Section 32.16, “The Connection Service File”</a>.
       </p></dd><dt id="libpq-connect-target-session-attrs"><span class="term"><code class="literal">target_session_attrs</code></span></dt><dd><p>        If this parameter is set to <code class="literal">read-write</code>, only a
        connection in which read-write transactions are accepted by default
        is considered acceptable.  The query
        <code class="literal">show transaction_read_only</code> will be sent upon any
        successful connection; if it returns <code class="literal">on</code>, the connection
        will be closed.  If multiple hosts were specified in the connection
        string, any remaining servers will be tried just as if the connection
        attempt had failed.  The default value of this parameter,
        <code class="literal">any</code>, regards all connections as acceptable.
      </p></dd></dl></div><p>
   </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="libpq.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="libpq.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="libpq-status.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 32. <span class="application">libpq</span> - C Library </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 32.2. Connection Status Functions</td></tr></table></div></body></html>