<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\access\heap\pruneheap.c</title>
<LINK REL=StyleSheet HREF="../../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\access\heap\pruneheap.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:29 2017
</td></tr>
<tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * pruneheap.c 
 *    heap page pruning and HOT-chain management code 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * 
 * IDENTIFICATION 
 *    src/backend/access/heap/pruneheap.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"access/heapam.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/heapam_xlog.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/transam.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/htup_details.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/xlog.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/catalog.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"miscadmin.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"pgstat.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/bufmgr.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/snapmgr.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/rel.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/tqual.h"</span> 
 
<span class='Comment_Multi_Line'>/* Working data for heap_page_prune and subroutines */ 
</span><span class='Control'>typedef</span> <span class='Control'>struct</span> 
<span class='Delimiter'>{ 
</span><a name="LN32"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Member'>new_prune_xid</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* new prune hint value for page */ 
</span><a name="LN33"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Member'>latestRemovedXid</span><span class='Delimiter'>;</span>     <span class='Comment_Multi_Line'>/* latest xid to be removed by this 
                                         * prune */ 
</span><a name="LN35"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>nredirected</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* numbers of entries in arrays below */ 
</span><a name="LN36"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>ndead</span><span class='Delimiter'>; 
</span><a name="LN37"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>nunused</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* arrays that accumulate indexes of items to be changed */ 
</span><a name="LN39"></a>    <a href="../../../include/storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Member'>redirected</span><span class='Delimiter'>[</span><a href="../../../include/access/htup_details.h.html#LN574"><span class='Ref_to_Const'>MaxHeapTuplesPerPage</span></a> <span class='Operator'>* </span><span class='Number'>2</span><span class='Delimiter'>]; 
</span><a name="LN40"></a>    <a href="../../../include/storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Member'>nowdead</span><span class='Delimiter'>[</span><a href="../../../include/access/htup_details.h.html#LN574"><span class='Ref_to_Const'>MaxHeapTuplesPerPage</span></a><span class='Delimiter'>]; 
</span><a name="LN41"></a>    <a href="../../../include/storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Member'>nowunused</span><span class='Delimiter'>[</span><a href="../../../include/access/htup_details.h.html#LN574"><span class='Ref_to_Const'>MaxHeapTuplesPerPage</span></a><span class='Delimiter'>]; 
</span>    <span class='Comment_Multi_Line'>/* marked[i] is TRUE if item i is entered in one of the above arrays */ 
</span><a name="LN43"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>marked</span><span class='Delimiter'>[</span><a href="../../../include/access/htup_details.h.html#LN574"><span class='Ref_to_Const'>MaxHeapTuplesPerPage</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>]; 
</span><a name="LN44"></a>} <span class='Declare_Typedef'>PruneState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* Local functions */ 
</span><a name="LN47"></a><span class='Keyword'>static int </span><span class='Declare_Prototype'>heap_prune_chain</span><span class='Parentheses'>(</span><a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>relation</span><span class='Delimiter'>, </span><a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a> <span class='Declare_Parameter'>buffer</span><span class='Delimiter'>, 
</span><a name="LN48"></a>                 <a href="../../../include/storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Parameter'>rootoffnum</span><span class='Delimiter'>, 
</span><a name="LN49"></a>                 <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>OldestXmin</span><span class='Delimiter'>, 
</span><a name="LN50"></a>                 <a href="pruneheap.c.html#LN30"><span class='Ref_to_Typedef'>PruneState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>prstate</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN51"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>heap_prune_record_prunable</span><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN30"><span class='Ref_to_Typedef'>PruneState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>prstate</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>xid</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN52"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>heap_prune_record_redirect</span><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN30"><span class='Ref_to_Typedef'>PruneState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>prstate</span><span class='Delimiter'>, 
</span><a name="LN53"></a>                           <a href="../../../include/storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Parameter'>offnum</span><span class='Delimiter'>, </span><a href="../../../include/storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Parameter'>rdoffnum</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN54"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>heap_prune_record_dead</span><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN30"><span class='Ref_to_Typedef'>PruneState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>prstate</span><span class='Delimiter'>, </span><a href="../../../include/storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Parameter'>offnum</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN55"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>heap_prune_record_unused</span><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN30"><span class='Ref_to_Typedef'>PruneState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>prstate</span><span class='Delimiter'>, </span><a href="../../../include/storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Parameter'>offnum</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Optionally prune and repair fragmentation in the specified page. 
 * 
 * This is an opportunistic function.  It will perform housekeeping 
 * only if the page heuristically looks like a candidate for pruning and we 
 * can acquire buffer cleanup lock without blocking. 
 * 
 * Note: this is called quite often.  It's important that it fall out quickly 
 * if there's not any use in pruning. 
 * 
 * Caller must have pin on the buffer, and must *not* have a lock on it. 
 * 
 * OldestXmin is the cutoff XID used to distinguish whether tuples are DEAD 
 * or RECENTLY_DEAD (see HeapTupleSatisfiesVacuum). 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN74"></a><span class='Declare_Function'>heap_page_prune_opt</span><span class='Parentheses'>(</span><a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>relation</span><span class='Delimiter'>, </span><a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a> <span class='Declare_Parameter'>buffer</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN76"></a>    <a href="../../../include/storage/bufpage.h.html#LN73"><span class='Ref_to_Typedef'>Page</span></a>        <span class='Declare_Local'>page</span> <span class='Operator'>= </span><a href="../../../include/storage/bufmgr.h.html#LN159"><span class='Ref_to_Macro'>BufferGetPage</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN74"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN77"></a>    <a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a>        <span class='Declare_Local'>minfree</span><span class='Delimiter'>; 
</span><a name="LN78"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>OldestXmin</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We can't write WAL in recovery mode, so there's no point trying to 
     * clean the page. The master will likely issue a cleaning WAL record soon 
     * anyway, so this is no particular loss. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN242"><span class='Ref_to_Proto'>RecoveryInProgress</span></a><span class='Parentheses'>())</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Use the appropriate xmin horizon for this relation. If it's a proper 
     * catalog relation or a user defined, additional, catalog relation, we 
     * need to use the horizon that includes slots, otherwise the data-only 
     * horizon can be used. Note that the toast relation of user defined 
     * relations are *not* considered catalog relations. 
     * 
     * It is OK to apply the old snapshot limit before acquiring the cleanup 
     * lock because the worst that can happen is that we are not quite as 
     * aggressive about the cleanup (by however many transaction IDs are 
     * consumed between this point and acquiring the lock).  This allows us to 
     * save significant overhead in the case where the page is found not to be 
     * prunable. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/catalog/catalog.h.html#LN31"><span class='Ref_to_Proto'>IsCatalogRelation</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN74"><span class='Ref_to_Parameter'>relation</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>        <a href="../../../include/utils/rel.h.html#LN559"><span class='Ref_to_Macro'>RelationIsAccessibleInLogicalDecoding</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN74"><span class='Ref_to_Parameter'>relation</span></a><span class='Parentheses'>))</span> 
        <a href="pruneheap.c.html#LN78"><span class='Ref_To_Local'>OldestXmin</span></a> <span class='Operator'>= </span><a href="../../utils/time/snapmgr.c.html#LN165"><span class='Ref_to_Global_Var'>RecentGlobalXmin</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="pruneheap.c.html#LN78"><span class='Ref_To_Local'>OldestXmin</span></a> <span class='Operator'>= 
</span>            <a href="../../../include/utils/snapmgr.h.html#LN93"><span class='Ref_to_Proto'>TransactionIdLimitedForOldSnapshots</span></a><span class='Parentheses'>(</span><a href="../../utils/time/snapmgr.c.html#LN166"><span class='Ref_to_Global_Var'>RecentGlobalDataXmin</span></a><span class='Delimiter'>, 
</span>                                                <a href="pruneheap.c.html#LN74"><span class='Ref_to_Parameter'>relation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN78"><span class='Ref_To_Local'>OldestXmin</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Let's see if we really need pruning. 
     * 
     * Forget it if page is not hinted to contain something prunable that's 
     * older than OldestXmin. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/storage/bufpage.h.html#LN388"><span class='Ref_to_Macro'>PageIsPrunable</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN76"><span class='Ref_To_Local'>page</span></a><span class='Delimiter'>, </span><a href="pruneheap.c.html#LN78"><span class='Ref_To_Local'>OldestXmin</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We prune when a previous UPDATE failed to find enough space on the page 
     * for a new tuple version, or when free space falls below the relation's 
     * fill-factor target (but not less than 10%). 
     * 
     * Checking free space here is questionable since we aren't holding any 
     * lock on the buffer; in the worst case we could get a bogus answer. It's 
     * unlikely to be *seriously* wrong, though, since reading either pd_lower 
     * or pd_upper is probably atomic.  Avoiding taking a lock seems more 
     * important than sometimes getting a wrong answer in what is after all 
     * just a heuristic estimate. 
     */ 
</span>    <a href="pruneheap.c.html#LN77"><span class='Ref_To_Local'>minfree</span></a> <span class='Operator'>= </span><a href="../../../include/utils/rel.h.html#LN307"><span class='Ref_to_Macro'>RelationGetTargetPageFreeSpace</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN74"><span class='Ref_to_Parameter'>relation</span></a><span class='Delimiter'>, 
</span>                                             <a href="../../../include/utils/rel.h.html#LN286"><span class='Ref_to_Const'>HEAP_DEFAULT_FILLFACTOR</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="pruneheap.c.html#LN77"><span class='Ref_To_Local'>minfree</span></a> <span class='Operator'>= </span><a href="../../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN10"><span class='Ref_to_Macro'>Max</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN77"><span class='Ref_To_Local'>minfree</span></a><span class='Delimiter'>, </span>BLCKSZ <span class='Operator'>/ </span><span class='Number'>10</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/bufpage.h.html#LN374"><span class='Ref_to_Macro'>PageIsFull</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN76"><span class='Ref_To_Local'>page</span></a><span class='Parentheses'>) </span><span class='Operator'>|| </span><a href="../../../include/storage/bufpage.h.html#LN429"><span class='Ref_to_Proto'>PageGetHeapFreeSpace</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN76"><span class='Ref_To_Local'>page</span></a><span class='Parentheses'>) </span><span class='Operator'>&LT; </span><a href="pruneheap.c.html#LN77"><span class='Ref_To_Local'>minfree</span></a><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* OK, try to get exclusive buffer lock */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/storage/bufmgr.h.html#LN217"><span class='Ref_to_Proto'>ConditionalLockBufferForCleanup</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN74"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Now that we have buffer lock, get accurate information about the 
         * page's free space, and recheck the heuristic about whether to 
         * prune. (We needn't recheck PageIsPrunable, since no one else could 
         * have pruned while we hold pin.) 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/bufpage.h.html#LN374"><span class='Ref_to_Macro'>PageIsFull</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN76"><span class='Ref_To_Local'>page</span></a><span class='Parentheses'>) </span><span class='Operator'>|| </span><a href="../../../include/storage/bufpage.h.html#LN429"><span class='Ref_to_Proto'>PageGetHeapFreeSpace</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN76"><span class='Ref_To_Local'>page</span></a><span class='Parentheses'>) </span><span class='Operator'>&LT; </span><a href="pruneheap.c.html#LN77"><span class='Ref_To_Local'>minfree</span></a><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span><a name="LN151"></a>            <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>ignore</span> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>;</span>        <span class='Comment_Multi_Line'>/* return value not 
                                                                 * needed */ 
</span> 
            <span class='Comment_Multi_Line'>/* OK to prune */ 
</span>            <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="pruneheap.c.html#LN180"><span class='Ref_to_Func'>heap_page_prune</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN74"><span class='Ref_to_Parameter'>relation</span></a><span class='Delimiter'>, </span><a href="pruneheap.c.html#LN74"><span class='Ref_to_Parameter'>buffer</span></a><span class='Delimiter'>, </span><a href="pruneheap.c.html#LN78"><span class='Ref_To_Local'>OldestXmin</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="pruneheap.c.html#LN151"><span class='Ref_To_Local'>ignore</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* And release buffer lock */ 
</span>        <a href="../../../include/storage/bufmgr.h.html#LN214"><span class='Ref_to_Proto'>LockBuffer</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN74"><span class='Ref_to_Parameter'>buffer</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/bufmgr.h.html#LN86"><span class='Ref_to_Const'>BUFFER_LOCK_UNLOCK</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if PageIsFull(page)||Pag... &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end heap_page_prune_opt &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * Prune and repair fragmentation in the specified page. 
 * 
 * Caller must have pin and buffer cleanup lock on the page. 
 * 
 * OldestXmin is the cutoff XID used to distinguish whether tuples are DEAD 
 * or RECENTLY_DEAD (see HeapTupleSatisfiesVacuum). 
 * 
 * If report_stats is true then we send the number of reclaimed heap-only 
 * tuples to pgstats.  (This must be FALSE during vacuum, since vacuum will 
 * send its own new total to pgstats, and we don't want this delta applied 
 * on top of that.) 
 * 
 * Returns the number of tuples deleted from the page and sets 
 * latestRemovedXid. 
 */ 
</span><span class='Keyword'>int 
</span><a name="LN181"></a><span class='Declare_Function'>heap_page_prune</span><span class='Parentheses'>(</span><a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>relation</span><span class='Delimiter'>, </span><a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a> <span class='Declare_Parameter'>buffer</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>OldestXmin</span><span class='Delimiter'>, 
</span><a name="LN182"></a>                <span class='Keyword'>bool </span><span class='Declare_Parameter'>report_stats</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>latestRemovedXid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN184"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>ndeleted</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN185"></a>    <a href="../../../include/storage/bufpage.h.html#LN73"><span class='Ref_to_Typedef'>Page</span></a>        <span class='Declare_Local'>page</span> <span class='Operator'>= </span><a href="../../../include/storage/bufmgr.h.html#LN159"><span class='Ref_to_Macro'>BufferGetPage</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN181"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN186"></a>    <a href="../../../include/storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Local'>offnum</span><span class='Delimiter'>, 
</span><a name="LN187"></a>                <span class='Declare_Local'>maxoff</span><span class='Delimiter'>; 
</span><a name="LN188"></a>    <a href="pruneheap.c.html#LN30"><span class='Ref_to_Typedef'>PruneState</span></a>  <span class='Declare_Local'>prstate</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Our strategy is to scan the page and make lists of items to change, 
     * then apply the changes within a critical section.  This keeps as much 
     * logic as possible out of the critical section, and also ensures that 
     * WAL replay will work the same as the normal case. 
     * 
     * First, initialize the new pd_prune_xid value to zero (indicating no 
     * prunable tuples).  If we find any tuples which may soon become 
     * prunable, we will save the lowest relevant XID in new_prune_xid. Also 
     * initialize the rest of our working state. 
     */ 
</span>    <a href="pruneheap.c.html#LN188"><span class='Ref_To_Local'>prstate</span></a><span class='Operator'>.</span><a href="pruneheap.c.html#LN32"><span class='Ref_to_Member'>new_prune_xid</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>; 
</span>    <a href="pruneheap.c.html#LN188"><span class='Ref_To_Local'>prstate</span></a><span class='Operator'>.</span><a href="pruneheap.c.html#LN33"><span class='Ref_to_Member'>latestRemovedXid</span></a> <span class='Operator'>= *</span><a href="pruneheap.c.html#LN182"><span class='Ref_to_Parameter'>latestRemovedXid</span></a><span class='Delimiter'>; 
</span>    <a href="pruneheap.c.html#LN188"><span class='Ref_To_Local'>prstate</span></a><span class='Operator'>.</span><a href="pruneheap.c.html#LN35"><span class='Ref_to_Member'>nredirected</span></a> <span class='Operator'>= </span><a href="pruneheap.c.html#LN188"><span class='Ref_To_Local'>prstate</span></a><span class='Operator'>.</span><a href="pruneheap.c.html#LN36"><span class='Ref_to_Member'>ndead</span></a> <span class='Operator'>= </span><a href="pruneheap.c.html#LN188"><span class='Ref_To_Local'>prstate</span></a><span class='Operator'>.</span><a href="pruneheap.c.html#LN37"><span class='Ref_to_Member'>nunused</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    memset<span class='Parentheses'>(</span><a href="pruneheap.c.html#LN188"><span class='Ref_To_Local'>prstate</span></a><span class='Operator'>.</span><a href="pruneheap.c.html#LN43"><span class='Ref_to_Member'>marked</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN188"><span class='Ref_To_Local'>prstate</span></a><span class='Operator'>.</span><a href="pruneheap.c.html#LN43"><span class='Ref_to_Member'>marked</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Scan the page */ 
</span>    <a href="pruneheap.c.html#LN187"><span class='Ref_To_Local'>maxoff</span></a> <span class='Operator'>= </span><a href="../../../include/storage/bufpage.h.html#LN353"><span class='Ref_to_Macro'>PageGetMaxOffsetNumber</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN185"><span class='Ref_To_Local'>page</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="pruneheap.c.html#LN186"><span class='Ref_To_Local'>offnum</span></a> <span class='Operator'>= </span><a href="../../../include/storage/off.h.html#LN26"><span class='Ref_to_Const'>FirstOffsetNumber</span></a><span class='Delimiter'>; 
</span>         <a href="pruneheap.c.html#LN186"><span class='Ref_To_Local'>offnum</span></a> <span class='Operator'>&LT;= </span><a href="pruneheap.c.html#LN187"><span class='Ref_To_Local'>maxoff</span></a><span class='Delimiter'>; 
</span>         <a href="pruneheap.c.html#LN186"><span class='Ref_To_Local'>offnum</span></a> <span class='Operator'>= </span><a href="../../../include/storage/off.h.html#LN52"><span class='Ref_to_Macro'>OffsetNumberNext</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN186"><span class='Ref_To_Local'>offnum</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN212"></a>        <a href="../../../include/storage/itemid.h.html#LN30"><span class='Ref_to_Typedef'>ItemId</span></a>      <span class='Declare_Local'>itemid</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Ignore items already processed as part of an earlier chain */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="pruneheap.c.html#LN188"><span class='Ref_To_Local'>prstate</span></a><span class='Operator'>.</span><a href="pruneheap.c.html#LN43"><span class='Ref_to_Member'>marked</span></a><span class='Delimiter'>[</span><a href="pruneheap.c.html#LN186"><span class='Ref_To_Local'>offnum</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Nothing to do if slot is empty or already dead */ 
</span>        <a href="pruneheap.c.html#LN212"><span class='Ref_To_Local'>itemid</span></a> <span class='Operator'>= </span><a href="../../../include/storage/bufpage.h.html#LN231"><span class='Ref_to_Macro'>PageGetItemId</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN185"><span class='Ref_To_Local'>page</span></a><span class='Delimiter'>, </span><a href="pruneheap.c.html#LN186"><span class='Ref_To_Local'>offnum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/storage/itemid.h.html#LN90"><span class='Ref_to_Macro'>ItemIdIsUsed</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN212"><span class='Ref_To_Local'>itemid</span></a><span class='Parentheses'>) </span><span class='Operator'>|| </span><a href="../../../include/storage/itemid.h.html#LN111"><span class='Ref_to_Macro'>ItemIdIsDead</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN212"><span class='Ref_To_Local'>itemid</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Process this item or chain of items */ 
</span>        <a href="pruneheap.c.html#LN184"><span class='Ref_To_Local'>ndeleted</span></a> <span class='Operator'>+= </span><a href="pruneheap.c.html#LN47"><span class='Ref_to_Proto'>heap_prune_chain</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN181"><span class='Ref_to_Parameter'>relation</span></a><span class='Delimiter'>, </span><a href="pruneheap.c.html#LN181"><span class='Ref_to_Parameter'>buffer</span></a><span class='Delimiter'>, </span><a href="pruneheap.c.html#LN186"><span class='Ref_To_Local'>offnum</span></a><span class='Delimiter'>, 
</span>                                     <a href="pruneheap.c.html#LN181"><span class='Ref_to_Parameter'>OldestXmin</span></a><span class='Delimiter'>, 
</span>                                     <span class='Operator'>&</span><a href="pruneheap.c.html#LN188"><span class='Ref_To_Local'>prstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for offnum=FirstOffsetNum... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* Any error while applying the changes is critical */ 
</span>    <a href="../../../include/miscadmin.h.html#LN132"><span class='Ref_to_Macro'>START_CRIT_SECTION</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Have we found any prunable items? */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="pruneheap.c.html#LN188"><span class='Ref_To_Local'>prstate</span></a><span class='Operator'>.</span><a href="pruneheap.c.html#LN35"><span class='Ref_to_Member'>nredirected</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span> <span class='Operator'>|| </span><a href="pruneheap.c.html#LN188"><span class='Ref_To_Local'>prstate</span></a><span class='Operator'>.</span><a href="pruneheap.c.html#LN36"><span class='Ref_to_Member'>ndead</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span> <span class='Operator'>|| </span><a href="pruneheap.c.html#LN188"><span class='Ref_To_Local'>prstate</span></a><span class='Operator'>.</span><a href="pruneheap.c.html#LN37"><span class='Ref_to_Member'>nunused</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Apply the planned item changes, then repair page fragmentation, and 
         * update the page's hint bit about whether it has free line pointers. 
         */ 
</span>        <a href="../../../include/access/heapam.h.html#LN188"><span class='Ref_to_Proto'>heap_page_prune_execute</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN181"><span class='Ref_to_Parameter'>buffer</span></a><span class='Delimiter'>, 
</span>                                <a href="pruneheap.c.html#LN188"><span class='Ref_To_Local'>prstate</span></a><span class='Operator'>.</span><a href="pruneheap.c.html#LN39"><span class='Ref_to_Member'>redirected</span></a><span class='Delimiter'>, </span><a href="pruneheap.c.html#LN188"><span class='Ref_To_Local'>prstate</span></a><span class='Operator'>.</span><a href="pruneheap.c.html#LN35"><span class='Ref_to_Member'>nredirected</span></a><span class='Delimiter'>, 
</span>                                <a href="pruneheap.c.html#LN188"><span class='Ref_To_Local'>prstate</span></a><span class='Operator'>.</span><a href="pruneheap.c.html#LN40"><span class='Ref_to_Member'>nowdead</span></a><span class='Delimiter'>, </span><a href="pruneheap.c.html#LN188"><span class='Ref_To_Local'>prstate</span></a><span class='Operator'>.</span><a href="pruneheap.c.html#LN36"><span class='Ref_to_Member'>ndead</span></a><span class='Delimiter'>, 
</span>                                <a href="pruneheap.c.html#LN188"><span class='Ref_To_Local'>prstate</span></a><span class='Operator'>.</span><a href="pruneheap.c.html#LN41"><span class='Ref_to_Member'>nowunused</span></a><span class='Delimiter'>, </span><a href="pruneheap.c.html#LN188"><span class='Ref_To_Local'>prstate</span></a><span class='Operator'>.</span><a href="pruneheap.c.html#LN37"><span class='Ref_to_Member'>nunused</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Update the page's pd_prune_xid field to either zero, or the lowest 
         * XID of any soon-prunable tuple. 
         */ 
</span>        <span class='Parentheses'>((</span><a href="../../../include/storage/bufpage.h.html#LN161"><span class='Ref_to_Typedef'>PageHeader</span></a><span class='Parentheses'>) </span><a href="pruneheap.c.html#LN185"><span class='Ref_To_Local'>page</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>pd_prune_xid <span class='Operator'>= </span><a href="pruneheap.c.html#LN188"><span class='Ref_To_Local'>prstate</span></a><span class='Operator'>.</span><a href="pruneheap.c.html#LN32"><span class='Ref_to_Member'>new_prune_xid</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Also clear the "page is full" flag, since there's no point in 
         * repeating the prune/defrag process until something else happens to 
         * the page. 
         */ 
</span>        <a href="../../../include/storage/bufpage.h.html#LN378"><span class='Ref_to_Macro'>PageClearFull</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN185"><span class='Ref_To_Local'>page</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/storage/bufmgr.h.html#LN176"><span class='Ref_to_Proto'>MarkBufferDirty</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN181"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Emit a WAL HEAP_CLEAN record showing what we did 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/rel.h.html#LN505"><span class='Ref_to_Macro'>RelationNeedsWAL</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN181"><span class='Ref_to_Parameter'>relation</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN264"></a>            <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>recptr</span><span class='Delimiter'>; 
</span> 
            <a href="pruneheap.c.html#LN264"><span class='Ref_To_Local'>recptr</span></a> <span class='Operator'>= </span><a href="../../../include/access/heapam_xlog.h.html#LN383"><span class='Ref_to_Proto'>log_heap_clean</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN181"><span class='Ref_to_Parameter'>relation</span></a><span class='Delimiter'>, </span><a href="pruneheap.c.html#LN181"><span class='Ref_to_Parameter'>buffer</span></a><span class='Delimiter'>, 
</span>                                    <a href="pruneheap.c.html#LN188"><span class='Ref_To_Local'>prstate</span></a><span class='Operator'>.</span><a href="pruneheap.c.html#LN39"><span class='Ref_to_Member'>redirected</span></a><span class='Delimiter'>, </span><a href="pruneheap.c.html#LN188"><span class='Ref_To_Local'>prstate</span></a><span class='Operator'>.</span><a href="pruneheap.c.html#LN35"><span class='Ref_to_Member'>nredirected</span></a><span class='Delimiter'>, 
</span>                                    <a href="pruneheap.c.html#LN188"><span class='Ref_To_Local'>prstate</span></a><span class='Operator'>.</span><a href="pruneheap.c.html#LN40"><span class='Ref_to_Member'>nowdead</span></a><span class='Delimiter'>, </span><a href="pruneheap.c.html#LN188"><span class='Ref_To_Local'>prstate</span></a><span class='Operator'>.</span><a href="pruneheap.c.html#LN36"><span class='Ref_to_Member'>ndead</span></a><span class='Delimiter'>, 
</span>                                    <a href="pruneheap.c.html#LN188"><span class='Ref_To_Local'>prstate</span></a><span class='Operator'>.</span><a href="pruneheap.c.html#LN41"><span class='Ref_to_Member'>nowunused</span></a><span class='Delimiter'>, </span><a href="pruneheap.c.html#LN188"><span class='Ref_To_Local'>prstate</span></a><span class='Operator'>.</span><a href="pruneheap.c.html#LN37"><span class='Ref_to_Member'>nunused</span></a><span class='Delimiter'>, 
</span>                                    <a href="pruneheap.c.html#LN188"><span class='Ref_To_Local'>prstate</span></a><span class='Operator'>.</span><a href="pruneheap.c.html#LN33"><span class='Ref_to_Member'>latestRemovedXid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="../../../include/storage/bufpage.h.html#LN364"><span class='Ref_to_Macro'>PageSetLSN</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/bufmgr.h.html#LN159"><span class='Ref_to_Macro'>BufferGetPage</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN181"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="pruneheap.c.html#LN264"><span class='Ref_To_Local'>recptr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if prstate.nredirected&GT;0... &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * If we didn't prune anything, but have found a new value for the 
         * pd_prune_xid field, update it and mark the buffer dirty. This is 
         * treated as a non-WAL-logged hint. 
         * 
         * Also clear the "page is full" flag if it is set, since there's no 
         * point in repeating the prune/defrag process until something else 
         * happens to the page. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(((</span><a href="../../../include/storage/bufpage.h.html#LN161"><span class='Ref_to_Typedef'>PageHeader</span></a><span class='Parentheses'>) </span><a href="pruneheap.c.html#LN185"><span class='Ref_To_Local'>page</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>pd_prune_xid <span class='Operator'>!= </span><a href="pruneheap.c.html#LN188"><span class='Ref_To_Local'>prstate</span></a><span class='Operator'>.</span><a href="pruneheap.c.html#LN32"><span class='Ref_to_Member'>new_prune_xid</span></a> <span class='Operator'>|| 
</span>            <a href="../../../include/storage/bufpage.h.html#LN374"><span class='Ref_to_Macro'>PageIsFull</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN185"><span class='Ref_To_Local'>page</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Parentheses'>((</span><a href="../../../include/storage/bufpage.h.html#LN161"><span class='Ref_to_Typedef'>PageHeader</span></a><span class='Parentheses'>) </span><a href="pruneheap.c.html#LN185"><span class='Ref_To_Local'>page</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>pd_prune_xid <span class='Operator'>= </span><a href="pruneheap.c.html#LN188"><span class='Ref_To_Local'>prstate</span></a><span class='Operator'>.</span><a href="pruneheap.c.html#LN32"><span class='Ref_to_Member'>new_prune_xid</span></a><span class='Delimiter'>; 
</span>            <a href="../../../include/storage/bufpage.h.html#LN378"><span class='Ref_to_Macro'>PageClearFull</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN185"><span class='Ref_To_Local'>page</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/storage/bufmgr.h.html#LN211"><span class='Ref_to_Proto'>MarkBufferDirtyHint</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN181"><span class='Ref_to_Parameter'>buffer</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/miscadmin.h.html#LN134"><span class='Ref_to_Macro'>END_CRIT_SECTION</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If requested, report the number of tuples reclaimed to pgstats. This is 
     * ndeleted minus ndead, because we don't want to count a now-DEAD root 
     * item as a deletion for this purpose. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="pruneheap.c.html#LN182"><span class='Ref_to_Parameter'>report_stats</span></a> <span class='Operator'>&& </span><a href="pruneheap.c.html#LN184"><span class='Ref_To_Local'>ndeleted</span></a> <span class='Operator'>&GT; </span><a href="pruneheap.c.html#LN188"><span class='Ref_To_Local'>prstate</span></a><span class='Operator'>.</span><a href="pruneheap.c.html#LN36"><span class='Ref_to_Member'>ndead</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/pgstat.h.html#LN1291"><span class='Ref_to_Proto'>pgstat_update_heap_dead_tuples</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN181"><span class='Ref_to_Parameter'>relation</span></a><span class='Delimiter'>, </span><a href="pruneheap.c.html#LN184"><span class='Ref_To_Local'>ndeleted</span></a> <span class='Operator'>- </span><a href="pruneheap.c.html#LN188"><span class='Ref_To_Local'>prstate</span></a><span class='Operator'>.</span><a href="pruneheap.c.html#LN36"><span class='Ref_to_Member'>ndead</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Operator'>*</span><a href="pruneheap.c.html#LN182"><span class='Ref_to_Parameter'>latestRemovedXid</span></a> <span class='Operator'>= </span><a href="pruneheap.c.html#LN188"><span class='Ref_To_Local'>prstate</span></a><span class='Operator'>.</span><a href="pruneheap.c.html#LN33"><span class='Ref_to_Member'>latestRemovedXid</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * XXX Should we update the FSM information of this page ? 
     * 
     * There are two schools of thought here. We may not want to update FSM 
     * information so that the page is not used for unrelated UPDATEs/INSERTs 
     * and any free space in this page will remain available for further 
     * UPDATEs in *this* page, thus improving chances for doing HOT updates. 
     * 
     * But for a large table and where a page does not receive further UPDATEs 
     * for a long time, we might waste this space by not updating the FSM 
     * information. The relation may get extended and fragmented further. 
     * 
     * One possibility is to leave "fillfactor" worth of space in this page 
     * and update FSM with the remaining space. 
     */ 
</span> 
    <span class='Control'>return</span> <a href="pruneheap.c.html#LN184"><span class='Ref_To_Local'>ndeleted</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end heap_page_prune &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * Prune specified item pointer or a HOT chain originating at that item. 
 * 
 * If the item is an index-referenced tuple (i.e. not a heap-only tuple), 
 * the HOT chain is pruned by removing all DEAD tuples at the start of the HOT 
 * chain.  We also prune any RECENTLY_DEAD tuples preceding a DEAD tuple. 
 * This is OK because a RECENTLY_DEAD tuple preceding a DEAD tuple is really 
 * DEAD, the OldestXmin test is just too coarse to detect it. 
 * 
 * The root line pointer is redirected to the tuple immediately after the 
 * latest DEAD tuple.  If all tuples in the chain are DEAD, the root line 
 * pointer is marked LP_DEAD.  (This includes the case of a DEAD simple 
 * tuple, which we treat as a chain of length 1.) 
 * 
 * OldestXmin is the cutoff XID used to identify dead tuples. 
 * 
 * We don't actually change the page here, except perhaps for hint-bit updates 
 * caused by HeapTupleSatisfiesVacuum.  We just add entries to the arrays in 
 * prstate showing the changes to be made.  Items to be redirected are added 
 * to the redirected[] array (two entries per redirection); items to be set to 
 * LP_DEAD state are added to nowdead[]; and items to be set to LP_UNUSED 
 * state are added to nowunused[]. 
 * 
 * Returns the number of tuples (to be) deleted from the page. 
 */ 
</span><span class='Keyword'>static int 
</span><a name="LN353"></a><span class='Declare_Function'>heap_prune_chain</span><span class='Parentheses'>(</span><a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>relation</span><span class='Delimiter'>, </span><a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a> <span class='Declare_Parameter'>buffer</span><span class='Delimiter'>, </span><a href="../../../include/storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Parameter'>rootoffnum</span><span class='Delimiter'>, 
</span><a name="LN354"></a>                 <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>OldestXmin</span><span class='Delimiter'>, 
</span><a name="LN355"></a>                 <a href="pruneheap.c.html#LN30"><span class='Ref_to_Typedef'>PruneState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>prstate</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN357"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>ndeleted</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN358"></a>    <a href="../../../include/storage/bufpage.h.html#LN73"><span class='Ref_to_Typedef'>Page</span></a>        <span class='Declare_Local'>dp</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/bufpage.h.html#LN73"><span class='Ref_to_Typedef'>Page</span></a><span class='Parentheses'>) </span><a href="../../../include/storage/bufmgr.h.html#LN159"><span class='Ref_to_Macro'>BufferGetPage</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN353"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN359"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>priorXmax</span> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>; 
</span><a name="LN360"></a>    <a href="../../../include/storage/itemid.h.html#LN30"><span class='Ref_to_Typedef'>ItemId</span></a>      <span class='Declare_Local'>rootlp</span><span class='Delimiter'>; 
</span><a name="LN361"></a>    <a href="../../../include/access/htup.h.html#LN22"><span class='Ref_to_Typedef'>HeapTupleHeader</span></a> <span class='Declare_Local'>htup</span><span class='Delimiter'>; 
</span><a name="LN362"></a>    <a href="../../../include/storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Local'>latestdead</span> <span class='Operator'>= </span><a href="../../../include/storage/off.h.html#LN25"><span class='Ref_to_Const'>InvalidOffsetNumber</span></a><span class='Delimiter'>, 
</span><a name="LN363"></a>                <span class='Declare_Local'>maxoff</span> <span class='Operator'>= </span><a href="../../../include/storage/bufpage.h.html#LN353"><span class='Ref_to_Macro'>PageGetMaxOffsetNumber</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN358"><span class='Ref_To_Local'>dp</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span><a name="LN364"></a>                <span class='Declare_Local'>offnum</span><span class='Delimiter'>; 
</span><a name="LN365"></a>    <a href="../../../include/storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Local'>chainitems</span><span class='Delimiter'>[</span><a href="../../../include/access/htup_details.h.html#LN574"><span class='Ref_to_Const'>MaxHeapTuplesPerPage</span></a><span class='Delimiter'>]; 
</span><a name="LN366"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>nchain</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>, 
</span><a name="LN367"></a>                <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN368"></a>    <a href="../../../include/access/htup.h.html#LN61"><span class='Ref_to_Struct'>HeapTupleData</span></a> <span class='Declare_Local'>tup</span><span class='Delimiter'>; 
</span> 
    <a href="pruneheap.c.html#LN368"><span class='Ref_To_Local'>tup</span></a><span class='Operator'>.</span><a href="../../../include/access/htup.h.html#LN65"><span class='Ref_to_Member'>t_tableOid</span></a> <span class='Operator'>= </span><a href="../../../include/utils/rel.h.html#LN416"><span class='Ref_to_Macro'>RelationGetRelid</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN353"><span class='Ref_to_Parameter'>relation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="pruneheap.c.html#LN360"><span class='Ref_To_Local'>rootlp</span></a> <span class='Operator'>= </span><a href="../../../include/storage/bufpage.h.html#LN231"><span class='Ref_to_Macro'>PageGetItemId</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN358"><span class='Ref_To_Local'>dp</span></a><span class='Delimiter'>, </span><a href="pruneheap.c.html#LN353"><span class='Ref_to_Parameter'>rootoffnum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If it's a heap-only tuple, then it is not the start of a HOT chain. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/itemid.h.html#LN97"><span class='Ref_to_Macro'>ItemIdIsNormal</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN360"><span class='Ref_To_Local'>rootlp</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="pruneheap.c.html#LN361"><span class='Ref_To_Local'>htup</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN22"><span class='Ref_to_Typedef'>HeapTupleHeader</span></a><span class='Parentheses'>) </span><a href="../../../include/storage/bufpage.h.html#LN336"><span class='Ref_to_Macro'>PageGetItem</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN358"><span class='Ref_To_Local'>dp</span></a><span class='Delimiter'>, </span><a href="pruneheap.c.html#LN360"><span class='Ref_To_Local'>rootlp</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="pruneheap.c.html#LN368"><span class='Ref_To_Local'>tup</span></a><span class='Operator'>.</span><a href="../../../include/access/htup.h.html#LN66"><span class='Ref_to_Member'>t_data</span></a> <span class='Operator'>= </span><a href="pruneheap.c.html#LN361"><span class='Ref_To_Local'>htup</span></a><span class='Delimiter'>; 
</span>        <a href="pruneheap.c.html#LN368"><span class='Ref_To_Local'>tup</span></a><span class='Operator'>.</span><a href="../../../include/access/htup.h.html#LN63"><span class='Ref_to_Member'>t_len</span></a> <span class='Operator'>= </span><a href="../../../include/storage/itemid.h.html#LN57"><span class='Ref_to_Macro'>ItemIdGetLength</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN360"><span class='Ref_To_Local'>rootlp</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/itemptr.h.html#LN103"><span class='Ref_to_Macro'>ItemPointerSet</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN368"><span class='Ref_To_Local'>tup</span></a><span class='Operator'>.</span><a href="../../../include/access/htup.h.html#LN64"><span class='Ref_to_Member'>t_self</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="../../../include/storage/bufmgr.h.html#LN187"><span class='Ref_to_Proto'>BufferGetBlockNumber</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN353"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="pruneheap.c.html#LN353"><span class='Ref_to_Parameter'>rootoffnum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/htup_details.h.html#LN501"><span class='Ref_to_Macro'>HeapTupleHeaderIsHeapOnly</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN361"><span class='Ref_To_Local'>htup</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * If the tuple is DEAD and doesn't chain to anything else, mark 
             * it unused immediately.  (If it does chain, we can only remove 
             * it as part of pruning its chain.) 
             * 
             * We need this primarily to handle aborted HOT updates, that is, 
             * XMIN_INVALID heap-only tuples.  Those might not be linked to by 
             * any chain, since the parent tuple might be re-updated before 
             * any pruning occurs.  So we have to be able to reap them 
             * separately from chain-pruning.  (Note that 
             * HeapTupleHeaderIsHotUpdated will never return true for an 
             * XMIN_INVALID tuple, so this code will work even when there were 
             * sequential updates within the aborted transaction.) 
             * 
             * Note that we might first arrive at a dead heap-only tuple 
             * either here or while following a chain below.  Whichever path 
             * gets there first will mark the tuple unused. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/tqual.h.html#LN74"><span class='Ref_to_Proto'>HeapTupleSatisfiesVacuum</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="pruneheap.c.html#LN368"><span class='Ref_To_Local'>tup</span></a><span class='Delimiter'>, </span><a href="pruneheap.c.html#LN354"><span class='Ref_to_Parameter'>OldestXmin</span></a><span class='Delimiter'>, </span><a href="pruneheap.c.html#LN353"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>) 
</span>                <span class='Operator'>== </span><a href="../../../include/utils/tqual.h.html#LN50"><span class='Ref_to_EnumConst'>HEAPTUPLE_DEAD</span></a> <span class='Operator'>&& !</span><a href="../../../include/access/htup_details.h.html#LN484"><span class='Ref_to_Macro'>HeapTupleHeaderIsHotUpdated</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN361"><span class='Ref_To_Local'>htup</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <a href="pruneheap.c.html#LN55"><span class='Ref_to_Proto'>heap_prune_record_unused</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN355"><span class='Ref_to_Parameter'>prstate</span></a><span class='Delimiter'>, </span><a href="pruneheap.c.html#LN353"><span class='Ref_to_Parameter'>rootoffnum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="../../../include/access/heapam_xlog.h.html#LN369"><span class='Ref_to_Proto'>HeapTupleHeaderAdvanceLatestRemovedXid</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN361"><span class='Ref_To_Local'>htup</span></a><span class='Delimiter'>, 
</span>                                                 <span class='Operator'>&</span><a href="pruneheap.c.html#LN355"><span class='Ref_to_Parameter'>prstate</span></a><span class='Operator'>-&GT;</span><a href="pruneheap.c.html#LN33"><span class='Ref_to_Member'>latestRemovedXid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="pruneheap.c.html#LN357"><span class='Ref_To_Local'>ndeleted</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* Nothing more to do */ 
</span>            <span class='Control'>return</span> <a href="pruneheap.c.html#LN357"><span class='Ref_To_Local'>ndeleted</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if HeapTupleHeaderIsHeap... &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if ItemIdIsNormal(rootlp... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* Start from the root tuple */ 
</span>    <a href="pruneheap.c.html#LN364"><span class='Ref_To_Local'>offnum</span></a> <span class='Operator'>= </span><a href="pruneheap.c.html#LN353"><span class='Ref_to_Parameter'>rootoffnum</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* while not end of the chain */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>;;</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN425"></a>        <a href="../../../include/storage/itemid.h.html#LN30"><span class='Ref_to_Typedef'>ItemId</span></a>      <span class='Declare_Local'>lp</span><span class='Delimiter'>; 
</span><a name="LN426"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>tupdead</span><span class='Delimiter'>, 
</span><a name="LN427"></a>                    <span class='Declare_Local'>recent_dead</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Some sanity checks */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="pruneheap.c.html#LN364"><span class='Ref_To_Local'>offnum</span></a> <span class='Operator'>&LT; </span><a href="../../../include/storage/off.h.html#LN26"><span class='Ref_to_Const'>FirstOffsetNumber</span></a> <span class='Operator'>|| </span><a href="pruneheap.c.html#LN364"><span class='Ref_To_Local'>offnum</span></a> <span class='Operator'>&GT; </span><a href="pruneheap.c.html#LN363"><span class='Ref_To_Local'>maxoff</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* If item is already processed, stop --- it must not be same chain */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="pruneheap.c.html#LN355"><span class='Ref_to_Parameter'>prstate</span></a><span class='Operator'>-&GT;</span><a href="pruneheap.c.html#LN43"><span class='Ref_to_Member'>marked</span></a><span class='Delimiter'>[</span><a href="pruneheap.c.html#LN364"><span class='Ref_To_Local'>offnum</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <a href="pruneheap.c.html#LN425"><span class='Ref_To_Local'>lp</span></a> <span class='Operator'>= </span><a href="../../../include/storage/bufpage.h.html#LN231"><span class='Ref_to_Macro'>PageGetItemId</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN358"><span class='Ref_To_Local'>dp</span></a><span class='Delimiter'>, </span><a href="pruneheap.c.html#LN364"><span class='Ref_To_Local'>offnum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Unused item obviously isn't part of the chain */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/storage/itemid.h.html#LN90"><span class='Ref_to_Macro'>ItemIdIsUsed</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN425"><span class='Ref_To_Local'>lp</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If we are looking at the redirected root line pointer, jump to the 
         * first normal tuple in the chain.  If we find a redirect somewhere 
         * else, stop --- it must not be same chain. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/itemid.h.html#LN104"><span class='Ref_to_Macro'>ItemIdIsRedirected</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN425"><span class='Ref_To_Local'>lp</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="pruneheap.c.html#LN366"><span class='Ref_To_Local'>nchain</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <span class='Control'>break</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* not at start of chain */ 
</span>            <a href="pruneheap.c.html#LN365"><span class='Ref_To_Local'>chainitems</span></a><span class='Delimiter'>[</span><a href="pruneheap.c.html#LN366"><span class='Ref_To_Local'>nchain</span></a><span class='Operator'>++</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="pruneheap.c.html#LN364"><span class='Ref_To_Local'>offnum</span></a><span class='Delimiter'>; 
</span>            <a href="pruneheap.c.html#LN364"><span class='Ref_To_Local'>offnum</span></a> <span class='Operator'>= </span><a href="../../../include/storage/itemid.h.html#LN76"><span class='Ref_to_Macro'>ItemIdGetRedirect</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN360"><span class='Ref_To_Local'>rootlp</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Likewise, a dead item pointer can't be part of the chain. (We 
         * already eliminated the case of dead root tuple outside this 
         * function.) 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/itemid.h.html#LN111"><span class='Ref_to_Macro'>ItemIdIsDead</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN425"><span class='Ref_To_Local'>lp</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/storage/itemid.h.html#LN97"><span class='Ref_to_Macro'>ItemIdIsNormal</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN425"><span class='Ref_To_Local'>lp</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="pruneheap.c.html#LN361"><span class='Ref_To_Local'>htup</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN22"><span class='Ref_to_Typedef'>HeapTupleHeader</span></a><span class='Parentheses'>) </span><a href="../../../include/storage/bufpage.h.html#LN336"><span class='Ref_to_Macro'>PageGetItem</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN358"><span class='Ref_To_Local'>dp</span></a><span class='Delimiter'>, </span><a href="pruneheap.c.html#LN425"><span class='Ref_To_Local'>lp</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="pruneheap.c.html#LN368"><span class='Ref_To_Local'>tup</span></a><span class='Operator'>.</span><a href="../../../include/access/htup.h.html#LN66"><span class='Ref_to_Member'>t_data</span></a> <span class='Operator'>= </span><a href="pruneheap.c.html#LN361"><span class='Ref_To_Local'>htup</span></a><span class='Delimiter'>; 
</span>        <a href="pruneheap.c.html#LN368"><span class='Ref_To_Local'>tup</span></a><span class='Operator'>.</span><a href="../../../include/access/htup.h.html#LN63"><span class='Ref_to_Member'>t_len</span></a> <span class='Operator'>= </span><a href="../../../include/storage/itemid.h.html#LN57"><span class='Ref_to_Macro'>ItemIdGetLength</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN425"><span class='Ref_To_Local'>lp</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/itemptr.h.html#LN103"><span class='Ref_to_Macro'>ItemPointerSet</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN368"><span class='Ref_To_Local'>tup</span></a><span class='Operator'>.</span><a href="../../../include/access/htup.h.html#LN64"><span class='Ref_to_Member'>t_self</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="../../../include/storage/bufmgr.h.html#LN187"><span class='Ref_to_Proto'>BufferGetBlockNumber</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN353"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="pruneheap.c.html#LN364"><span class='Ref_To_Local'>offnum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Check the tuple XMIN against prior XMAX, if any 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN359"><span class='Ref_To_Local'>priorXmax</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>            <span class='Operator'>!</span><a href="../../../include/access/transam.h.html#LN42"><span class='Ref_to_Macro'>TransactionIdEquals</span></a><span class='Parentheses'>(</span><a href="../../../include/access/htup_details.h.html#LN306"><span class='Ref_to_Macro'>HeapTupleHeaderGetXmin</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN361"><span class='Ref_To_Local'>htup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="pruneheap.c.html#LN359"><span class='Ref_To_Local'>priorXmax</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * OK, this tuple is indeed a member of the chain. 
         */ 
</span>        <a href="pruneheap.c.html#LN365"><span class='Ref_To_Local'>chainitems</span></a><span class='Delimiter'>[</span><a href="pruneheap.c.html#LN366"><span class='Ref_To_Local'>nchain</span></a><span class='Operator'>++</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="pruneheap.c.html#LN364"><span class='Ref_To_Local'>offnum</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Check tuple's visibility status. 
         */ 
</span>        <a href="pruneheap.c.html#LN426"><span class='Ref_To_Local'>tupdead</span></a> <span class='Operator'>= </span><a href="pruneheap.c.html#LN427"><span class='Ref_To_Local'>recent_dead</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="../../../include/utils/tqual.h.html#LN74"><span class='Ref_to_Proto'>HeapTupleSatisfiesVacuum</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="pruneheap.c.html#LN368"><span class='Ref_To_Local'>tup</span></a><span class='Delimiter'>, </span><a href="pruneheap.c.html#LN354"><span class='Ref_to_Parameter'>OldestXmin</span></a><span class='Delimiter'>, </span><a href="pruneheap.c.html#LN353"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>case</span> <a href="../../../include/utils/tqual.h.html#LN50"><span class='Ref_to_EnumConst'>HEAPTUPLE_DEAD</span></a><span class='Operator'>: 
</span>                <a href="pruneheap.c.html#LN426"><span class='Ref_To_Local'>tupdead</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>case</span> <a href="../../../include/utils/tqual.h.html#LN52"><span class='Ref_to_EnumConst'>HEAPTUPLE_RECENTLY_DEAD</span></a><span class='Operator'>: 
</span>                <a href="pruneheap.c.html#LN427"><span class='Ref_To_Local'>recent_dead</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * This tuple may soon become DEAD.  Update the hint field so 
                 * that the page is reconsidered for pruning in future. 
                 */ 
</span>                <a href="pruneheap.c.html#LN51"><span class='Ref_to_Proto'>heap_prune_record_prunable</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN355"><span class='Ref_to_Parameter'>prstate</span></a><span class='Delimiter'>, 
</span>                                           <a href="../../../include/access/htup_details.h.html#LN358"><span class='Ref_to_Macro'>HeapTupleHeaderGetUpdateXid</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN361"><span class='Ref_To_Local'>htup</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>case</span> <a href="../../../include/utils/tqual.h.html#LN54"><span class='Ref_to_EnumConst'>HEAPTUPLE_DELETE_IN_PROGRESS</span></a><span class='Operator'>: 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * This tuple may soon become DEAD.  Update the hint field so 
                 * that the page is reconsidered for pruning in future. 
                 */ 
</span>                <a href="pruneheap.c.html#LN51"><span class='Ref_to_Proto'>heap_prune_record_prunable</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN355"><span class='Ref_to_Parameter'>prstate</span></a><span class='Delimiter'>, 
</span>                                           <a href="../../../include/access/htup_details.h.html#LN358"><span class='Ref_to_Macro'>HeapTupleHeaderGetUpdateXid</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN361"><span class='Ref_To_Local'>htup</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>case</span> <a href="../../../include/utils/tqual.h.html#LN51"><span class='Ref_to_EnumConst'>HEAPTUPLE_LIVE</span></a><span class='Operator'>: 
</span>            <span class='Control'>case</span> <a href="../../../include/utils/tqual.h.html#LN53"><span class='Ref_to_EnumConst'>HEAPTUPLE_INSERT_IN_PROGRESS</span></a><span class='Operator'>: 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * If we wanted to optimize for aborts, we might consider 
                 * marking the page prunable when we see INSERT_IN_PROGRESS. 
                 * But we don't.  See related decisions about when to mark the 
                 * page prunable in heapam.c. 
                 */ 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>default</span><span class='Operator'>: 
</span>                <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unexpected HeapTupleSatisfiesVacuum result"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch HeapTupleSatisfiesVac... &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* 
         * Remember the last DEAD tuple seen.  We will advance past 
         * RECENTLY_DEAD tuples just in case there's a DEAD one after them; 
         * but we can't advance past anything else.  (XXX is it really worth 
         * continuing to scan beyond RECENTLY_DEAD?  The case where we will 
         * find another DEAD tuple is a fairly unusual corner case.) 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="pruneheap.c.html#LN426"><span class='Ref_To_Local'>tupdead</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="pruneheap.c.html#LN362"><span class='Ref_To_Local'>latestdead</span></a> <span class='Operator'>= </span><a href="pruneheap.c.html#LN364"><span class='Ref_To_Local'>offnum</span></a><span class='Delimiter'>; 
</span>            <a href="../../../include/access/heapam_xlog.h.html#LN369"><span class='Ref_to_Proto'>HeapTupleHeaderAdvanceLatestRemovedXid</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN361"><span class='Ref_To_Local'>htup</span></a><span class='Delimiter'>, 
</span>                                                 <span class='Operator'>&</span><a href="pruneheap.c.html#LN355"><span class='Ref_to_Parameter'>prstate</span></a><span class='Operator'>-&GT;</span><a href="pruneheap.c.html#LN33"><span class='Ref_to_Member'>latestRemovedXid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="pruneheap.c.html#LN427"><span class='Ref_To_Local'>recent_dead</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If the tuple is not HOT-updated, then we are at the end of this 
         * HOT-update chain. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/htup_details.h.html#LN484"><span class='Ref_to_Macro'>HeapTupleHeaderIsHotUpdated</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN361"><span class='Ref_To_Local'>htup</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Advance to next chain member. 
         */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/storage/itemptr.h.html#LN74"><span class='Ref_to_Macro'>ItemPointerGetBlockNumber</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="pruneheap.c.html#LN361"><span class='Ref_To_Local'>htup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup_details.h.html#LN149"><span class='Ref_to_Member'>t_ctid</span></a><span class='Parentheses'>) </span><span class='Operator'>== 
</span>               <a href="../../../include/storage/bufmgr.h.html#LN187"><span class='Ref_to_Proto'>BufferGetBlockNumber</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN353"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="pruneheap.c.html#LN364"><span class='Ref_To_Local'>offnum</span></a> <span class='Operator'>= </span><a href="../../../include/storage/itemptr.h.html#LN93"><span class='Ref_to_Macro'>ItemPointerGetOffsetNumber</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="pruneheap.c.html#LN361"><span class='Ref_To_Local'>htup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup_details.h.html#LN149"><span class='Ref_to_Member'>t_ctid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="pruneheap.c.html#LN359"><span class='Ref_To_Local'>priorXmax</span></a> <span class='Operator'>= </span><a href="../../../include/access/htup_details.h.html#LN358"><span class='Ref_to_Macro'>HeapTupleHeaderGetUpdateXid</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN361"><span class='Ref_To_Local'>htup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for ;; &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * If we found a DEAD tuple in the chain, adjust the HOT chain so that all 
     * the DEAD tuples at the start of the chain are removed and the root line 
     * pointer is appropriately redirected. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/off.h.html#LN39"><span class='Ref_to_Macro'>OffsetNumberIsValid</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN362"><span class='Ref_To_Local'>latestdead</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Mark as unused each intermediate item that we are able to remove 
         * from the chain. 
         * 
         * When the previous item is the last dead tuple seen, we are at the 
         * right candidate for redirection. 
         */ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="pruneheap.c.html#LN367"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; </span><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN367"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="pruneheap.c.html#LN366"><span class='Ref_To_Local'>nchain</span></a><span class='Parentheses'>) </span><span class='Operator'>&& </span><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN365"><span class='Ref_To_Local'>chainitems</span></a><span class='Delimiter'>[</span><a href="pruneheap.c.html#LN367"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>!= </span><a href="pruneheap.c.html#LN362"><span class='Ref_To_Local'>latestdead</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; </span><a href="pruneheap.c.html#LN367"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <a href="pruneheap.c.html#LN55"><span class='Ref_to_Proto'>heap_prune_record_unused</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN355"><span class='Ref_to_Parameter'>prstate</span></a><span class='Delimiter'>, </span><a href="pruneheap.c.html#LN365"><span class='Ref_To_Local'>chainitems</span></a><span class='Delimiter'>[</span><a href="pruneheap.c.html#LN367"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="pruneheap.c.html#LN357"><span class='Ref_To_Local'>ndeleted</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If the root entry had been a normal tuple, we are deleting it, so 
         * count it in the result.  But changing a redirect (even to DEAD 
         * state) doesn't count. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/itemid.h.html#LN97"><span class='Ref_to_Macro'>ItemIdIsNormal</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN360"><span class='Ref_To_Local'>rootlp</span></a><span class='Parentheses'>))</span> 
            <a href="pruneheap.c.html#LN357"><span class='Ref_To_Local'>ndeleted</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If the DEAD tuple is at the end of the chain, the entire chain is 
         * dead and the root line pointer can be marked dead.  Otherwise just 
         * redirect the root to the correct chain member. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="pruneheap.c.html#LN367"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&GT;= </span><a href="pruneheap.c.html#LN366"><span class='Ref_To_Local'>nchain</span></a><span class='Parentheses'>) 
</span>            <a href="pruneheap.c.html#LN54"><span class='Ref_to_Proto'>heap_prune_record_dead</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN355"><span class='Ref_to_Parameter'>prstate</span></a><span class='Delimiter'>, </span><a href="pruneheap.c.html#LN353"><span class='Ref_to_Parameter'>rootoffnum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="pruneheap.c.html#LN52"><span class='Ref_to_Proto'>heap_prune_record_redirect</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN355"><span class='Ref_to_Parameter'>prstate</span></a><span class='Delimiter'>, </span><a href="pruneheap.c.html#LN353"><span class='Ref_to_Parameter'>rootoffnum</span></a><span class='Delimiter'>, </span><a href="pruneheap.c.html#LN365"><span class='Ref_To_Local'>chainitems</span></a><span class='Delimiter'>[</span><a href="pruneheap.c.html#LN367"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if OffsetNumberIsValid(l... &raquo; </span> 
    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="pruneheap.c.html#LN366"><span class='Ref_To_Local'>nchain</span></a> <span class='Operator'>&LT; </span><span class='Number'>2</span> <span class='Operator'>&& </span><a href="../../../include/storage/itemid.h.html#LN104"><span class='Ref_to_Macro'>ItemIdIsRedirected</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN360"><span class='Ref_To_Local'>rootlp</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * We found a redirect item that doesn't point to a valid follow-on 
         * item.  This can happen if the loop in heap_page_prune caused us to 
         * visit the dead successor of a redirect item before visiting the 
         * redirect item.  We can clean up by setting the redirect item to 
         * DEAD state. 
         */ 
</span>        <a href="pruneheap.c.html#LN54"><span class='Ref_to_Proto'>heap_prune_record_dead</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN355"><span class='Ref_to_Parameter'>prstate</span></a><span class='Delimiter'>, </span><a href="pruneheap.c.html#LN353"><span class='Ref_to_Parameter'>rootoffnum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="pruneheap.c.html#LN357"><span class='Ref_To_Local'>ndeleted</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end heap_prune_chain &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* Record lowest soon-prunable XID */ 
</span><span class='Keyword'>static void 
</span><a name="LN619"></a><span class='Declare_Function'>heap_prune_record_prunable</span><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN30"><span class='Ref_to_Typedef'>PruneState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>prstate</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>xid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * This should exactly match the PageSetPrunable macro.  We can't store 
     * directly into the page header yet, so we update working state. 
     */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN619"><span class='Ref_to_Parameter'>xid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN619"><span class='Ref_to_Parameter'>prstate</span></a><span class='Operator'>-&GT;</span><a href="pruneheap.c.html#LN32"><span class='Ref_to_Member'>new_prune_xid</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>        <a href="../../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN619"><span class='Ref_to_Parameter'>xid</span></a><span class='Delimiter'>, </span><a href="pruneheap.c.html#LN619"><span class='Ref_to_Parameter'>prstate</span></a><span class='Operator'>-&GT;</span><a href="pruneheap.c.html#LN32"><span class='Ref_to_Member'>new_prune_xid</span></a><span class='Parentheses'>))</span> 
        <a href="pruneheap.c.html#LN619"><span class='Ref_to_Parameter'>prstate</span></a><span class='Operator'>-&GT;</span><a href="pruneheap.c.html#LN32"><span class='Ref_to_Member'>new_prune_xid</span></a> <span class='Operator'>= </span><a href="pruneheap.c.html#LN619"><span class='Ref_to_Parameter'>xid</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* Record item pointer to be redirected */ 
</span><span class='Keyword'>static void 
</span><a name="LN633"></a><span class='Declare_Function'>heap_prune_record_redirect</span><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN30"><span class='Ref_to_Typedef'>PruneState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>prstate</span><span class='Delimiter'>, 
</span><a name="LN634"></a>                           <a href="../../../include/storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Parameter'>offnum</span><span class='Delimiter'>, </span><a href="../../../include/storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Parameter'>rdoffnum</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN633"><span class='Ref_to_Parameter'>prstate</span></a><span class='Operator'>-&GT;</span><a href="pruneheap.c.html#LN35"><span class='Ref_to_Member'>nredirected</span></a> <span class='Operator'>&LT; </span><a href="../../../include/access/htup_details.h.html#LN574"><span class='Ref_to_Const'>MaxHeapTuplesPerPage</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="pruneheap.c.html#LN633"><span class='Ref_to_Parameter'>prstate</span></a><span class='Operator'>-&GT;</span><a href="pruneheap.c.html#LN39"><span class='Ref_to_Member'>redirected</span></a><span class='Delimiter'>[</span><a href="pruneheap.c.html#LN633"><span class='Ref_to_Parameter'>prstate</span></a><span class='Operator'>-&GT;</span><a href="pruneheap.c.html#LN35"><span class='Ref_to_Member'>nredirected</span></a> <span class='Operator'>* </span><span class='Number'>2</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="pruneheap.c.html#LN634"><span class='Ref_to_Parameter'>offnum</span></a><span class='Delimiter'>; 
</span>    <a href="pruneheap.c.html#LN633"><span class='Ref_to_Parameter'>prstate</span></a><span class='Operator'>-&GT;</span><a href="pruneheap.c.html#LN39"><span class='Ref_to_Member'>redirected</span></a><span class='Delimiter'>[</span><a href="pruneheap.c.html#LN633"><span class='Ref_to_Parameter'>prstate</span></a><span class='Operator'>-&GT;</span><a href="pruneheap.c.html#LN35"><span class='Ref_to_Member'>nredirected</span></a> <span class='Operator'>* </span><span class='Number'>2</span> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="pruneheap.c.html#LN634"><span class='Ref_to_Parameter'>rdoffnum</span></a><span class='Delimiter'>; 
</span>    <a href="pruneheap.c.html#LN633"><span class='Ref_to_Parameter'>prstate</span></a><span class='Operator'>-&GT;</span><a href="pruneheap.c.html#LN35"><span class='Ref_to_Member'>nredirected</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="pruneheap.c.html#LN633"><span class='Ref_to_Parameter'>prstate</span></a><span class='Operator'>-&GT;</span><a href="pruneheap.c.html#LN43"><span class='Ref_to_Member'>marked</span></a><span class='Delimiter'>[</span><a href="pruneheap.c.html#LN634"><span class='Ref_to_Parameter'>offnum</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="pruneheap.c.html#LN633"><span class='Ref_to_Parameter'>prstate</span></a><span class='Operator'>-&GT;</span><a href="pruneheap.c.html#LN43"><span class='Ref_to_Member'>marked</span></a><span class='Delimiter'>[</span><a href="pruneheap.c.html#LN634"><span class='Ref_to_Parameter'>offnum</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="pruneheap.c.html#LN633"><span class='Ref_to_Parameter'>prstate</span></a><span class='Operator'>-&GT;</span><a href="pruneheap.c.html#LN43"><span class='Ref_to_Member'>marked</span></a><span class='Delimiter'>[</span><a href="pruneheap.c.html#LN634"><span class='Ref_to_Parameter'>rdoffnum</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="pruneheap.c.html#LN633"><span class='Ref_to_Parameter'>prstate</span></a><span class='Operator'>-&GT;</span><a href="pruneheap.c.html#LN43"><span class='Ref_to_Member'>marked</span></a><span class='Delimiter'>[</span><a href="pruneheap.c.html#LN634"><span class='Ref_to_Parameter'>rdoffnum</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* Record item pointer to be marked dead */ 
</span><span class='Keyword'>static void 
</span><a name="LN648"></a><span class='Declare_Function'>heap_prune_record_dead</span><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN30"><span class='Ref_to_Typedef'>PruneState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>prstate</span><span class='Delimiter'>, </span><a href="../../../include/storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Parameter'>offnum</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN648"><span class='Ref_to_Parameter'>prstate</span></a><span class='Operator'>-&GT;</span><a href="pruneheap.c.html#LN36"><span class='Ref_to_Member'>ndead</span></a> <span class='Operator'>&LT; </span><a href="../../../include/access/htup_details.h.html#LN574"><span class='Ref_to_Const'>MaxHeapTuplesPerPage</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="pruneheap.c.html#LN648"><span class='Ref_to_Parameter'>prstate</span></a><span class='Operator'>-&GT;</span><a href="pruneheap.c.html#LN40"><span class='Ref_to_Member'>nowdead</span></a><span class='Delimiter'>[</span><a href="pruneheap.c.html#LN648"><span class='Ref_to_Parameter'>prstate</span></a><span class='Operator'>-&GT;</span><a href="pruneheap.c.html#LN36"><span class='Ref_to_Member'>ndead</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="pruneheap.c.html#LN648"><span class='Ref_to_Parameter'>offnum</span></a><span class='Delimiter'>; 
</span>    <a href="pruneheap.c.html#LN648"><span class='Ref_to_Parameter'>prstate</span></a><span class='Operator'>-&GT;</span><a href="pruneheap.c.html#LN36"><span class='Ref_to_Member'>ndead</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="pruneheap.c.html#LN648"><span class='Ref_to_Parameter'>prstate</span></a><span class='Operator'>-&GT;</span><a href="pruneheap.c.html#LN43"><span class='Ref_to_Member'>marked</span></a><span class='Delimiter'>[</span><a href="pruneheap.c.html#LN648"><span class='Ref_to_Parameter'>offnum</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="pruneheap.c.html#LN648"><span class='Ref_to_Parameter'>prstate</span></a><span class='Operator'>-&GT;</span><a href="pruneheap.c.html#LN43"><span class='Ref_to_Member'>marked</span></a><span class='Delimiter'>[</span><a href="pruneheap.c.html#LN648"><span class='Ref_to_Parameter'>offnum</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* Record item pointer to be marked unused */ 
</span><span class='Keyword'>static void 
</span><a name="LN659"></a><span class='Declare_Function'>heap_prune_record_unused</span><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN30"><span class='Ref_to_Typedef'>PruneState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>prstate</span><span class='Delimiter'>, </span><a href="../../../include/storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Parameter'>offnum</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN659"><span class='Ref_to_Parameter'>prstate</span></a><span class='Operator'>-&GT;</span><a href="pruneheap.c.html#LN37"><span class='Ref_to_Member'>nunused</span></a> <span class='Operator'>&LT; </span><a href="../../../include/access/htup_details.h.html#LN574"><span class='Ref_to_Const'>MaxHeapTuplesPerPage</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="pruneheap.c.html#LN659"><span class='Ref_to_Parameter'>prstate</span></a><span class='Operator'>-&GT;</span><a href="pruneheap.c.html#LN41"><span class='Ref_to_Member'>nowunused</span></a><span class='Delimiter'>[</span><a href="pruneheap.c.html#LN659"><span class='Ref_to_Parameter'>prstate</span></a><span class='Operator'>-&GT;</span><a href="pruneheap.c.html#LN37"><span class='Ref_to_Member'>nunused</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="pruneheap.c.html#LN659"><span class='Ref_to_Parameter'>offnum</span></a><span class='Delimiter'>; 
</span>    <a href="pruneheap.c.html#LN659"><span class='Ref_to_Parameter'>prstate</span></a><span class='Operator'>-&GT;</span><a href="pruneheap.c.html#LN37"><span class='Ref_to_Member'>nunused</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="pruneheap.c.html#LN659"><span class='Ref_to_Parameter'>prstate</span></a><span class='Operator'>-&GT;</span><a href="pruneheap.c.html#LN43"><span class='Ref_to_Member'>marked</span></a><span class='Delimiter'>[</span><a href="pruneheap.c.html#LN659"><span class='Ref_to_Parameter'>offnum</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="pruneheap.c.html#LN659"><span class='Ref_to_Parameter'>prstate</span></a><span class='Operator'>-&GT;</span><a href="pruneheap.c.html#LN43"><span class='Ref_to_Member'>marked</span></a><span class='Delimiter'>[</span><a href="pruneheap.c.html#LN659"><span class='Ref_to_Parameter'>offnum</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
} 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Perform the actual page changes needed by heap_page_prune. 
 * It is expected that the caller has suitable pin and lock on the 
 * buffer, and is inside a critical section. 
 * 
 * This is split out because it is also used by heap_xlog_clean() 
 * to replay the WAL record when needed after a crash.  Note that the 
 * arguments are identical to those of log_heap_clean(). 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN679"></a><span class='Declare_Function'>heap_page_prune_execute</span><span class='Parentheses'>(</span><a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a> <span class='Declare_Parameter'>buffer</span><span class='Delimiter'>, 
</span><a name="LN680"></a>                        <a href="../../../include/storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>redirected</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>nredirected</span><span class='Delimiter'>, 
</span><a name="LN681"></a>                        <a href="../../../include/storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>nowdead</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>ndead</span><span class='Delimiter'>, 
</span><a name="LN682"></a>                        <a href="../../../include/storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>nowunused</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>nunused</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN684"></a>    <a href="../../../include/storage/bufpage.h.html#LN73"><span class='Ref_to_Typedef'>Page</span></a>        <span class='Declare_Local'>page</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/bufpage.h.html#LN73"><span class='Ref_to_Typedef'>Page</span></a><span class='Parentheses'>) </span><a href="../../../include/storage/bufmgr.h.html#LN159"><span class='Ref_to_Macro'>BufferGetPage</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN679"><span class='Ref_to_Parameter'>buffer</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN685"></a>    <a href="../../../include/storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Operator'>*</span><span class='Declare_Local'>offnum</span><span class='Delimiter'>; 
</span><a name="LN686"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Update all redirected line pointers */ 
</span>    <a href="pruneheap.c.html#LN685"><span class='Ref_To_Local'>offnum</span></a> <span class='Operator'>= </span><a href="pruneheap.c.html#LN680"><span class='Ref_to_Parameter'>redirected</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="pruneheap.c.html#LN686"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="pruneheap.c.html#LN686"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="pruneheap.c.html#LN680"><span class='Ref_to_Parameter'>nredirected</span></a><span class='Delimiter'>; </span><a href="pruneheap.c.html#LN686"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN692"></a>        <a href="../../../include/storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Local'>fromoff</span> <span class='Operator'>= *</span><a href="pruneheap.c.html#LN685"><span class='Ref_To_Local'>offnum</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span><a name="LN693"></a>        <a href="../../../include/storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Local'>tooff</span> <span class='Operator'>= *</span><a href="pruneheap.c.html#LN685"><span class='Ref_To_Local'>offnum</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span><a name="LN694"></a>        <a href="../../../include/storage/itemid.h.html#LN30"><span class='Ref_to_Typedef'>ItemId</span></a>      <span class='Declare_Local'>fromlp</span> <span class='Operator'>= </span><a href="../../../include/storage/bufpage.h.html#LN231"><span class='Ref_to_Macro'>PageGetItemId</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN684"><span class='Ref_To_Local'>page</span></a><span class='Delimiter'>, </span><a href="pruneheap.c.html#LN692"><span class='Ref_To_Local'>fromoff</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/storage/itemid.h.html#LN150"><span class='Ref_to_Macro'>ItemIdSetRedirect</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN694"><span class='Ref_To_Local'>fromlp</span></a><span class='Delimiter'>, </span><a href="pruneheap.c.html#LN693"><span class='Ref_To_Local'>tooff</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Update all now-dead line pointers */ 
</span>    <a href="pruneheap.c.html#LN685"><span class='Ref_To_Local'>offnum</span></a> <span class='Operator'>= </span><a href="pruneheap.c.html#LN681"><span class='Ref_to_Parameter'>nowdead</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="pruneheap.c.html#LN686"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="pruneheap.c.html#LN686"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="pruneheap.c.html#LN681"><span class='Ref_to_Parameter'>ndead</span></a><span class='Delimiter'>; </span><a href="pruneheap.c.html#LN686"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN703"></a>        <a href="../../../include/storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Local'>off</span> <span class='Operator'>= *</span><a href="pruneheap.c.html#LN685"><span class='Ref_To_Local'>offnum</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span><a name="LN704"></a>        <a href="../../../include/storage/itemid.h.html#LN30"><span class='Ref_to_Typedef'>ItemId</span></a>      <span class='Declare_Local'>lp</span> <span class='Operator'>= </span><a href="../../../include/storage/bufpage.h.html#LN231"><span class='Ref_to_Macro'>PageGetItemId</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN684"><span class='Ref_To_Local'>page</span></a><span class='Delimiter'>, </span><a href="pruneheap.c.html#LN703"><span class='Ref_To_Local'>off</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/storage/itemid.h.html#LN162"><span class='Ref_to_Macro'>ItemIdSetDead</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN704"><span class='Ref_To_Local'>lp</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Update all now-unused line pointers */ 
</span>    <a href="pruneheap.c.html#LN685"><span class='Ref_To_Local'>offnum</span></a> <span class='Operator'>= </span><a href="pruneheap.c.html#LN682"><span class='Ref_to_Parameter'>nowunused</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="pruneheap.c.html#LN686"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="pruneheap.c.html#LN686"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="pruneheap.c.html#LN682"><span class='Ref_to_Parameter'>nunused</span></a><span class='Delimiter'>; </span><a href="pruneheap.c.html#LN686"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN713"></a>        <a href="../../../include/storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Local'>off</span> <span class='Operator'>= *</span><a href="pruneheap.c.html#LN685"><span class='Ref_To_Local'>offnum</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span><a name="LN714"></a>        <a href="../../../include/storage/itemid.h.html#LN30"><span class='Ref_to_Typedef'>ItemId</span></a>      <span class='Declare_Local'>lp</span> <span class='Operator'>= </span><a href="../../../include/storage/bufpage.h.html#LN231"><span class='Ref_to_Macro'>PageGetItemId</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN684"><span class='Ref_To_Local'>page</span></a><span class='Delimiter'>, </span><a href="pruneheap.c.html#LN713"><span class='Ref_To_Local'>off</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/storage/itemid.h.html#LN126"><span class='Ref_to_Macro'>ItemIdSetUnused</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN714"><span class='Ref_To_Local'>lp</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Finally, repair any fragmentation, and update the page's hint bit about 
     * whether it has free pointers. 
     */ 
</span>    <a href="../../../include/storage/bufpage.h.html#LN425"><span class='Ref_to_Proto'>PageRepairFragmentation</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN684"><span class='Ref_To_Local'>page</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end heap_page_prune_execute &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * For all items in this page, find their respective root line pointers. 
 * If item k is part of a HOT-chain with root at item j, then we set 
 * root_offsets[k - 1] = j. 
 * 
 * The passed-in root_offsets array must have MaxHeapTuplesPerPage entries. 
 * We zero out all unused entries. 
 * 
 * The function must be called with at least share lock on the buffer, to 
 * prevent concurrent prune operations. 
 * 
 * Note: The information collected here is valid only as long as the caller 
 * holds a pin on the buffer. Once pin is released, a tuple might be pruned 
 * and reused by a completely unrelated tuple. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN743"></a><span class='Declare_Function'>heap_get_root_tuples</span><span class='Parentheses'>(</span><a href="../../../include/storage/bufpage.h.html#LN73"><span class='Ref_to_Typedef'>Page</span></a> <span class='Declare_Parameter'>page</span><span class='Delimiter'>, </span><a href="../../../include/storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root_offsets</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN745"></a>    <a href="../../../include/storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Local'>offnum</span><span class='Delimiter'>, 
</span><a name="LN746"></a>                <span class='Declare_Local'>maxoff</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/c.h.html#LN856"><span class='Ref_to_Macro'>MemSet</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN743"><span class='Ref_to_Parameter'>root_offsets</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><a href="../../../include/access/htup_details.h.html#LN574"><span class='Ref_to_Const'>MaxHeapTuplesPerPage</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="pruneheap.c.html#LN746"><span class='Ref_To_Local'>maxoff</span></a> <span class='Operator'>= </span><a href="../../../include/storage/bufpage.h.html#LN353"><span class='Ref_to_Macro'>PageGetMaxOffsetNumber</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN743"><span class='Ref_to_Parameter'>page</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="pruneheap.c.html#LN745"><span class='Ref_To_Local'>offnum</span></a> <span class='Operator'>= </span><a href="../../../include/storage/off.h.html#LN26"><span class='Ref_to_Const'>FirstOffsetNumber</span></a><span class='Delimiter'>; </span><a href="pruneheap.c.html#LN745"><span class='Ref_To_Local'>offnum</span></a> <span class='Operator'>&LT;= </span><a href="pruneheap.c.html#LN746"><span class='Ref_To_Local'>maxoff</span></a><span class='Delimiter'>; </span><a href="pruneheap.c.html#LN745"><span class='Ref_To_Local'>offnum</span></a> <span class='Operator'>= </span><a href="../../../include/storage/off.h.html#LN52"><span class='Ref_to_Macro'>OffsetNumberNext</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN745"><span class='Ref_To_Local'>offnum</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN753"></a>        <a href="../../../include/storage/itemid.h.html#LN30"><span class='Ref_to_Typedef'>ItemId</span></a>      <span class='Declare_Local'>lp</span> <span class='Operator'>= </span><a href="../../../include/storage/bufpage.h.html#LN231"><span class='Ref_to_Macro'>PageGetItemId</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN743"><span class='Ref_to_Parameter'>page</span></a><span class='Delimiter'>, </span><a href="pruneheap.c.html#LN745"><span class='Ref_To_Local'>offnum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN754"></a>        <a href="../../../include/access/htup.h.html#LN22"><span class='Ref_to_Typedef'>HeapTupleHeader</span></a> <span class='Declare_Local'>htup</span><span class='Delimiter'>; 
</span><a name="LN755"></a>        <a href="../../../include/storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Local'>nextoffnum</span><span class='Delimiter'>; 
</span><a name="LN756"></a>        <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>priorXmax</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* skip unused and dead items */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/storage/itemid.h.html#LN90"><span class='Ref_to_Macro'>ItemIdIsUsed</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN753"><span class='Ref_To_Local'>lp</span></a><span class='Parentheses'>) </span><span class='Operator'>|| </span><a href="../../../include/storage/itemid.h.html#LN111"><span class='Ref_to_Macro'>ItemIdIsDead</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN753"><span class='Ref_To_Local'>lp</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/itemid.h.html#LN97"><span class='Ref_to_Macro'>ItemIdIsNormal</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN753"><span class='Ref_To_Local'>lp</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="pruneheap.c.html#LN754"><span class='Ref_To_Local'>htup</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN22"><span class='Ref_to_Typedef'>HeapTupleHeader</span></a><span class='Parentheses'>) </span><a href="../../../include/storage/bufpage.h.html#LN336"><span class='Ref_to_Macro'>PageGetItem</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN743"><span class='Ref_to_Parameter'>page</span></a><span class='Delimiter'>, </span><a href="pruneheap.c.html#LN753"><span class='Ref_To_Local'>lp</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Check if this tuple is part of a HOT-chain rooted at some other 
             * tuple. If so, skip it for now; we'll process it when we find 
             * its root. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/htup_details.h.html#LN501"><span class='Ref_to_Macro'>HeapTupleHeaderIsHeapOnly</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN754"><span class='Ref_To_Local'>htup</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * This is either a plain tuple or the root of a HOT-chain. 
             * Remember it in the mapping. 
             */ 
</span>            <a href="pruneheap.c.html#LN743"><span class='Ref_to_Parameter'>root_offsets</span></a><span class='Delimiter'>[</span><a href="pruneheap.c.html#LN745"><span class='Ref_To_Local'>offnum</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="pruneheap.c.html#LN745"><span class='Ref_To_Local'>offnum</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* If it's not the start of a HOT-chain, we're done with it */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/htup_details.h.html#LN484"><span class='Ref_to_Macro'>HeapTupleHeaderIsHotUpdated</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN754"><span class='Ref_To_Local'>htup</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Set up to scan the HOT-chain */ 
</span>            <a href="pruneheap.c.html#LN755"><span class='Ref_To_Local'>nextoffnum</span></a> <span class='Operator'>= </span><a href="../../../include/storage/itemptr.h.html#LN93"><span class='Ref_to_Macro'>ItemPointerGetOffsetNumber</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="pruneheap.c.html#LN754"><span class='Ref_To_Local'>htup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup_details.h.html#LN149"><span class='Ref_to_Member'>t_ctid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="pruneheap.c.html#LN756"><span class='Ref_To_Local'>priorXmax</span></a> <span class='Operator'>= </span><a href="../../../include/access/htup_details.h.html#LN358"><span class='Ref_to_Macro'>HeapTupleHeaderGetUpdateXid</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN754"><span class='Ref_To_Local'>htup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if ItemIdIsNormal(lp) &raquo; </span> 
        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Must be a redirect item. We do not set its root_offsets entry */ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/storage/itemid.h.html#LN104"><span class='Ref_to_Macro'>ItemIdIsRedirected</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN753"><span class='Ref_To_Local'>lp</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* Set up to scan the HOT-chain */ 
</span>            <a href="pruneheap.c.html#LN755"><span class='Ref_To_Local'>nextoffnum</span></a> <span class='Operator'>= </span><a href="../../../include/storage/itemid.h.html#LN76"><span class='Ref_to_Macro'>ItemIdGetRedirect</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN753"><span class='Ref_To_Local'>lp</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="pruneheap.c.html#LN756"><span class='Ref_To_Local'>priorXmax</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Now follow the HOT-chain and collect other tuples in the chain. 
         * 
         * Note: Even though this is a nested loop, the complexity of the 
         * function is O(N) because a tuple in the page should be visited not 
         * more than twice, once in the outer loop and once in HOT-chain 
         * chases. 
         */ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>;;</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="pruneheap.c.html#LN753"><span class='Ref_To_Local'>lp</span></a> <span class='Operator'>= </span><a href="../../../include/storage/bufpage.h.html#LN231"><span class='Ref_to_Macro'>PageGetItemId</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN743"><span class='Ref_to_Parameter'>page</span></a><span class='Delimiter'>, </span><a href="pruneheap.c.html#LN755"><span class='Ref_To_Local'>nextoffnum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Check for broken chains */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/storage/itemid.h.html#LN97"><span class='Ref_to_Macro'>ItemIdIsNormal</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN753"><span class='Ref_To_Local'>lp</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
            <a href="pruneheap.c.html#LN754"><span class='Ref_To_Local'>htup</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN22"><span class='Ref_to_Typedef'>HeapTupleHeader</span></a><span class='Parentheses'>) </span><a href="../../../include/storage/bufpage.h.html#LN336"><span class='Ref_to_Macro'>PageGetItem</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN743"><span class='Ref_to_Parameter'>page</span></a><span class='Delimiter'>, </span><a href="pruneheap.c.html#LN753"><span class='Ref_To_Local'>lp</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN756"><span class='Ref_To_Local'>priorXmax</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>                <span class='Operator'>!</span><a href="../../../include/access/transam.h.html#LN42"><span class='Ref_to_Macro'>TransactionIdEquals</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN756"><span class='Ref_To_Local'>priorXmax</span></a><span class='Delimiter'>, </span><a href="../../../include/access/htup_details.h.html#LN306"><span class='Ref_to_Macro'>HeapTupleHeaderGetXmin</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN754"><span class='Ref_To_Local'>htup</span></a><span class='Parentheses'>)))</span> 
                <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Remember the root line pointer for this item */ 
</span>            <a href="pruneheap.c.html#LN743"><span class='Ref_to_Parameter'>root_offsets</span></a><span class='Delimiter'>[</span><a href="pruneheap.c.html#LN755"><span class='Ref_To_Local'>nextoffnum</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="pruneheap.c.html#LN745"><span class='Ref_To_Local'>offnum</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Advance to next chain member, if any */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/htup_details.h.html#LN484"><span class='Ref_to_Macro'>HeapTupleHeaderIsHotUpdated</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN754"><span class='Ref_To_Local'>htup</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
            <a href="pruneheap.c.html#LN755"><span class='Ref_To_Local'>nextoffnum</span></a> <span class='Operator'>= </span><a href="../../../include/storage/itemptr.h.html#LN93"><span class='Ref_to_Macro'>ItemPointerGetOffsetNumber</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="pruneheap.c.html#LN754"><span class='Ref_To_Local'>htup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup_details.h.html#LN149"><span class='Ref_to_Member'>t_ctid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="pruneheap.c.html#LN756"><span class='Ref_To_Local'>priorXmax</span></a> <span class='Operator'>= </span><a href="../../../include/access/htup_details.h.html#LN358"><span class='Ref_to_Macro'>HeapTupleHeaderGetUpdateXid</span></a><span class='Parentheses'>(</span><a href="pruneheap.c.html#LN754"><span class='Ref_To_Local'>htup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for ;; &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for offnum=FirstOffsetNum... &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end heap_get_root_tuples &raquo; </span> 
</pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>