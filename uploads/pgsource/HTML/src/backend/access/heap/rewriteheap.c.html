<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\access\heap\rewriteheap.c</title>
<LINK REL=StyleSheet HREF="../../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\access\heap\rewriteheap.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:29 2017
</td></tr>
<tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * rewriteheap.c 
 *    Support functions to rewrite tables. 
 * 
 * These functions provide a facility to completely rewrite a heap, while 
 * preserving visibility information and update chains. 
 * 
 * INTERFACE 
 * 
 * The caller is responsible for creating the new heap, all catalog 
 * changes, supplying the tuples to be written to the new heap, and 
 * rebuilding indexes.  The caller must hold AccessExclusiveLock on the 
 * target table, because we assume no one else is writing into it. 
 * 
 * To use the facility: 
 * 
 * begin_heap_rewrite 
 * while (fetch next tuple) 
 * { 
 *     if (tuple is dead) 
 *         rewrite_heap_dead_tuple 
 *     else 
 *     { 
 *         // do any transformations here if required 
 *         rewrite_heap_tuple 
 *     } 
 * } 
 * end_heap_rewrite 
 * 
 * The contents of the new relation shouldn't be relied on until after 
 * end_heap_rewrite is called. 
 * 
 * 
 * IMPLEMENTATION 
 * 
 * This would be a fairly trivial affair, except that we need to maintain 
 * the ctid chains that link versions of an updated tuple together. 
 * Since the newly stored tuples will have tids different from the original 
 * ones, if we just copied t_ctid fields to the new table the links would 
 * be wrong.  When we are required to copy a (presumably recently-dead or 
 * delete-in-progress) tuple whose ctid doesn't point to itself, we have 
 * to substitute the correct ctid instead. 
 * 
 * For each ctid reference from A -&GT; B, we might encounter either A first 
 * or B first.  (Note that a tuple in the middle of a chain is both A and B 
 * of different pairs.) 
 * 
 * If we encounter A first, we'll store the tuple in the unresolved_tups 
 * hash table. When we later encounter B, we remove A from the hash table, 
 * fix the ctid to point to the new location of B, and insert both A and B 
 * to the new heap. 
 * 
 * If we encounter B first, we can insert B to the new heap right away. 
 * We then add an entry to the old_new_tid_map hash table showing B's 
 * original tid (in the old heap) and new tid (in the new heap). 
 * When we later encounter A, we get the new location of B from the table, 
 * and can write A immediately with the correct ctid. 
 * 
 * Entries in the hash tables can be removed as soon as the later tuple 
 * is encountered.  That helps to keep the memory usage down.  At the end, 
 * both tables are usually empty; we should have encountered both A and B 
 * of each pair.  However, it's possible for A to be RECENTLY_DEAD and B 
 * entirely DEAD according to HeapTupleSatisfiesVacuum, because the test 
 * for deadness using OldestXmin is not exact.  In such a case we might 
 * encounter B first, and skip it, and find A later.  Then A would be added 
 * to unresolved_tups, and stay there until end of the rewrite.  Since 
 * this case is very unusual, we don't worry about the memory usage. 
 * 
 * Using in-memory hash tables means that we use some memory for each live 
 * update chain in the table, from the time we find one end of the 
 * reference until we find the other end.  That shouldn't be a problem in 
 * practice, but if you do something like an UPDATE without a where-clause 
 * on a large table, and then run CLUSTER in the same transaction, you 
 * could run out of memory.  It doesn't seem worthwhile to add support for 
 * spill-to-disk, as there shouldn't be that many RECENTLY_DEAD tuples in a 
 * table under normal circumstances.  Furthermore, in the typical scenario 
 * of CLUSTERing on an unchanging key column, we'll see all the versions 
 * of a given tuple together anyway, and so the peak memory usage is only 
 * proportional to the number of RECENTLY_DEAD versions of a single row, not 
 * in the whole table.  Note that if we do fail halfway through a CLUSTER, 
 * the old table is still valid, so failure is not catastrophic. 
 * 
 * We can't use the normal heap_insert function to insert into the new 
 * heap, because heap_insert overwrites the visibility information. 
 * We use a special-purpose raw_heap_insert function instead, which 
 * is optimized for bulk inserting a lot of tuples, knowing that we have 
 * exclusive access to the heap.  raw_heap_insert builds new pages in 
 * local storage.  When a page is full, or at the end of the process, 
 * we insert it to WAL as a single record and then write it to disk 
 * directly through smgr.  Note, however, that any data sent to the new 
 * heap's TOAST table will go through the normal bufmgr. 
 * 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994-5, Regents of the University of California 
 * 
 * IDENTIFICATION 
 *    src/backend/access/heap/rewriteheap.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>&LT;sys/stat.h&GT;</span> 
<span class='Keyword'>#include </span><span class='String'>&LT;unistd.h&GT;</span> 
 
<span class='Keyword'>#include </span><span class='String'>"miscadmin.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"access/heapam.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/heapam_xlog.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/rewriteheap.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/transam.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/tuptoaster.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/xact.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/xloginsert.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"catalog/catalog.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"lib/ilist.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"pgstat.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"replication/logical.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"replication/slot.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"storage/bufmgr.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/fd.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/smgr.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"utils/memutils.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/rel.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/tqual.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"storage/procarray.h"</span> 
 
<span class='Comment_Multi_Line'>/* 
 * State associated with a rewrite operation. This is opaque to the user 
 * of the rewrite facility. 
 */ 
</span><a name="LN140"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>RewriteStateData</span> 
<span class='Delimiter'>{ 
</span><a name="LN142"></a>    <a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Member'>rs_old_rel</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* source heap */ 
</span><a name="LN143"></a>    <a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Member'>rs_new_rel</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* destination heap */ 
</span><a name="LN144"></a>    <a href="../../../include/storage/bufpage.h.html#LN73"><span class='Ref_to_Typedef'>Page</span></a>        <span class='Declare_Member'>rs_buffer</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* page currently being built */ 
</span><a name="LN145"></a>    <a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Member'>rs_blockno</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* block where page will go */ 
</span><a name="LN146"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>rs_buffer_valid</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* T if any tuples in buffer */ 
</span><a name="LN147"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>rs_use_wal</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* must we WAL-log inserts? */ 
</span><a name="LN148"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>rs_logical_rewrite</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* do we need to do logical rewriting */ 
</span><a name="LN149"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Member'>rs_oldest_xmin</span><span class='Delimiter'>;</span>       <span class='Comment_Multi_Line'>/* oldest xmin used by caller to 
                                         * determine tuple visibility */ 
</span><a name="LN151"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Member'>rs_freeze_xid</span><span class='Delimiter'>;</span><span class='Comment_Multi_Line'>/* Xid that will be used as freeze cutoff 
                                 * point */ 
</span><a name="LN153"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Member'>rs_logical_xmin</span><span class='Delimiter'>;</span>      <span class='Comment_Multi_Line'>/* Xid that will be used as cutoff 
                                         * point for logical rewrites */ 
</span><a name="LN155"></a>    <a href="../../../include/c.h.html#LN406"><span class='Ref_to_Typedef'>MultiXactId</span></a> <span class='Declare_Member'>rs_cutoff_multi</span><span class='Delimiter'>;</span><span class='Comment_Multi_Line'>/* MultiXactId that will be used as cutoff 
                                 * point for multixacts */ 
</span><a name="LN157"></a>    <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Member'>rs_cxt</span><span class='Delimiter'>;</span>       <span class='Comment_Multi_Line'>/* for hash tables and entries and tuples in 
                                 * them */ 
</span><a name="LN159"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Member'>rs_begin_lsn</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* XLogInsertLsn when starting the rewrite */ 
</span><a name="LN160"></a>    <a href="../../utils/hash/dynahash.c.html#LN192"><span class='Ref_to_Struct'>HTAB</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>rs_unresolved_tups</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* unmatched A tuples */ 
</span><a name="LN161"></a>    <a href="../../utils/hash/dynahash.c.html#LN192"><span class='Ref_to_Struct'>HTAB</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>rs_old_new_tid_map</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* unmatched B tuples */ 
</span><a name="LN162"></a>    <a href="../../utils/hash/dynahash.c.html#LN192"><span class='Ref_to_Struct'>HTAB</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>rs_logical_mappings</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* logical remapping files */ 
</span><a name="LN163"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Member'>rs_num_rewrite_mappings</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* # in memory mappings */ 
</span><a name="LN164"></a><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end RewriteStateData &raquo; </span>   <span class='Declare_Typedef'>RewriteStateData</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * The lookup keys for the hash tables are tuple TID and xmin (we must check 
 * both to avoid false matches from dead tuples).  Beware that there is 
 * probably some padding space in this struct; it must be zeroed out for 
 * correct hashtable operation. 
 */ 
</span><span class='Control'>typedef</span> <span class='Control'>struct</span> 
<span class='Delimiter'>{ 
</span><a name="LN174"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Member'>xmin</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* tuple xmin */ 
</span><a name="LN175"></a>    <a href="../../../include/storage/itemptr.h.html#LN35"><span class='Ref_to_Struct'>ItemPointerData</span></a> <span class='Declare_Member'>tid</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* tuple location in old heap */ 
</span><a name="LN176"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>TidHashKey</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Entry structures for the hash tables 
 */ 
</span><span class='Control'>typedef</span> <span class='Control'>struct</span> 
<span class='Delimiter'>{ 
</span><a name="LN183"></a>    <a href="rewriteheap.c.html#LN172"><span class='Ref_to_Typedef'>TidHashKey</span></a>  <span class='Declare_Member'>key</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* expected xmin/old location of B tuple */ 
</span><a name="LN184"></a>    <a href="../../../include/storage/itemptr.h.html#LN35"><span class='Ref_to_Struct'>ItemPointerData</span></a> <span class='Declare_Member'>old_tid</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* A's location in the old heap */ 
</span><a name="LN185"></a>    <a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Member'>tuple</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* A's tuple contents */ 
</span><a name="LN186"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>UnresolvedTupData</span><span class='Delimiter'>; 
</span> 
<a name="LN188"></a><span class='Control'>typedef</span> <a href="rewriteheap.c.html#LN181"><span class='Ref_to_Typedef'>UnresolvedTupData</span></a> <span class='Operator'>*</span><span class='Declare_Typedef'>UnresolvedTup</span><span class='Delimiter'>; 
</span> 
<span class='Control'>typedef</span> <span class='Control'>struct</span> 
<span class='Delimiter'>{ 
</span><a name="LN192"></a>    <a href="rewriteheap.c.html#LN172"><span class='Ref_to_Typedef'>TidHashKey</span></a>  <span class='Declare_Member'>key</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* actual xmin/old location of B tuple */ 
</span><a name="LN193"></a>    <a href="../../../include/storage/itemptr.h.html#LN35"><span class='Ref_to_Struct'>ItemPointerData</span></a> <span class='Declare_Member'>new_tid</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* where we put it in the new heap */ 
</span><a name="LN194"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>OldToNewMappingData</span><span class='Delimiter'>; 
</span> 
<a name="LN196"></a><span class='Control'>typedef</span> <a href="rewriteheap.c.html#LN190"><span class='Ref_to_Typedef'>OldToNewMappingData</span></a> <span class='Operator'>*</span><span class='Declare_Typedef'>OldToNewMapping</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * In-Memory data for an xid that might need logical remapping entries 
 * to be logged. 
 */ 
</span><a name="LN202"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>RewriteMappingFile</span> 
<span class='Delimiter'>{ 
</span><a name="LN204"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Member'>xid</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* xid that might need to see the row */ 
</span><a name="LN205"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>vfd</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* fd of mappings file */ 
</span><a name="LN206"></a>    off_t       <span class='Declare_Member'>off</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* how far have we written yet */ 
</span><a name="LN207"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Member'>num_mappings</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* number of in-memory mappings */ 
</span><a name="LN208"></a>    <a href="../../../include/lib/ilist.h.html#LN134"><span class='Ref_to_Struct'>dlist_head</span></a>  <span class='Declare_Member'>mappings</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* list of in-memory mappings */ 
</span><a name="LN209"></a>    <span class='Keyword'>char</span>        <span class='Declare_Member'>path</span><span class='Delimiter'>[</span><a href="../../../include/pg_config_manual.h.html#LN88"><span class='Ref_to_Const'>MAXPGPATH</span></a><span class='Delimiter'>];</span>    <span class='Comment_Single_Line'>/* path, for error messages */ 
</span><a name="LN210"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>RewriteMappingFile</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * A single In-Memory logical rewrite mapping, hanging off 
 * RewriteMappingFile-&GT;mappings. 
 */ 
</span><a name="LN216"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>RewriteMappingDataEntry</span> 
<span class='Delimiter'>{ 
</span><a name="LN218"></a>    <a href="../../../include/access/rewriteheap.h.html#LN34"><span class='Ref_to_Struct'>LogicalRewriteMappingData</span></a> <span class='Declare_Member'>map</span><span class='Delimiter'>;</span>      <span class='Comment_Multi_Line'>/* map between old and new location of 
                                         * the tuple */ 
</span><a name="LN220"></a>    <a href="../../../include/lib/ilist.h.html#LN120"><span class='Ref_to_Struct'>dlist_node</span></a>  <span class='Declare_Member'>node</span><span class='Delimiter'>; 
</span><a name="LN221"></a>} <span class='Declare_Typedef'>RewriteMappingDataEntry</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* prototypes for internal functions */ 
</span><a name="LN225"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>raw_heap_insert</span><span class='Parentheses'>(</span><a href="../../../include/access/rewriteheap.h.html#LN21"><span class='Ref_to_Typedef'>RewriteState</span></a> <span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a> <span class='Declare_Parameter'>tup</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* internal logical remapping prototypes */ 
</span><a name="LN228"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>logical_begin_heap_rewrite</span><span class='Parentheses'>(</span><a href="../../../include/access/rewriteheap.h.html#LN21"><span class='Ref_to_Typedef'>RewriteState</span></a> <span class='Declare_Parameter'>state</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN229"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>logical_rewrite_heap_tuple</span><span class='Parentheses'>(</span><a href="../../../include/access/rewriteheap.h.html#LN21"><span class='Ref_to_Typedef'>RewriteState</span></a> <span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><a href="../../../include/storage/itemptr.h.html#LN35"><span class='Ref_to_Struct'>ItemPointerData</span></a> <span class='Declare_Parameter'>old_tid</span><span class='Delimiter'>, </span><a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a> <span class='Declare_Parameter'>new_tuple</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN230"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>logical_end_heap_rewrite</span><span class='Parentheses'>(</span><a href="../../../include/access/rewriteheap.h.html#LN21"><span class='Ref_to_Typedef'>RewriteState</span></a> <span class='Declare_Parameter'>state</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Begin a rewrite of a table 
 * 
 * old_heap     old, locked heap relation tuples will be read from 
 * new_heap     new, locked heap relation to insert tuples to 
 * oldest_xmin  xid used by the caller to determine which tuples are dead 
 * freeze_xid   xid before which tuples will be frozen 
 * min_multi    multixact before which multis will be removed 
 * use_wal      should the inserts to the new heap be WAL-logged? 
 * 
 * Returns an opaque RewriteState, allocated in current memory context, 
 * to be used in subsequent calls to the other functions. 
 */ 
</span><a href="../../../include/access/rewriteheap.h.html#LN21"><span class='Ref_to_Typedef'>RewriteState</span></a> 
<a name="LN247"></a><span class='Declare_Function'>begin_heap_rewrite</span><span class='Parentheses'>(</span><a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>old_heap</span><span class='Delimiter'>, </span><a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>new_heap</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>oldest_xmin</span><span class='Delimiter'>, 
</span><a name="LN248"></a>                   <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>freeze_xid</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN406"><span class='Ref_to_Typedef'>MultiXactId</span></a> <span class='Declare_Parameter'>cutoff_multi</span><span class='Delimiter'>, 
</span><a name="LN249"></a>                   <span class='Keyword'>bool </span><span class='Declare_Parameter'>use_wal</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN251"></a>    <a href="../../../include/access/rewriteheap.h.html#LN21"><span class='Ref_to_Typedef'>RewriteState</span></a> <span class='Declare_Local'>state</span><span class='Delimiter'>; 
</span><a name="LN252"></a>    <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>rw_cxt</span><span class='Delimiter'>; 
</span><a name="LN253"></a>    <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>old_cxt</span><span class='Delimiter'>; 
</span><a name="LN254"></a>    <a href="../../../include/utils/hsearch.h.html#LN64"><span class='Ref_to_Struct'>HASHCTL</span></a>     <span class='Declare_Local'>hash_ctl</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * To ease cleanup, make a separate context that will contain the 
     * RewriteState struct itself plus all subsidiary data. 
     */ 
</span>    <a href="rewriteheap.c.html#LN252"><span class='Ref_To_Local'>rw_cxt</span></a> <span class='Operator'>= </span><a href="../../../include/utils/memutils.h.html#LN145"><span class='Ref_to_Proto'>AllocSetContextCreate</span></a><span class='Parentheses'>(</span><a href="../../utils/mmgr/mcxt.c.html#LN36"><span class='Ref_to_Global_Var'>CurrentMemoryContext</span></a><span class='Delimiter'>, 
</span>                                   <span class='String'>"Table rewrite"</span><span class='Delimiter'>, 
</span>                                   <a href="../../../include/utils/memutils.h.html#LN164"><span class='Ref_to_Const'>ALLOCSET_DEFAULT_SIZES</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="rewriteheap.c.html#LN253"><span class='Ref_To_Local'>old_cxt</span></a> <span class='Operator'>= </span><a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN252"><span class='Ref_To_Local'>rw_cxt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Create and fill in the state struct */ 
</span>    <a href="rewriteheap.c.html#LN251"><span class='Ref_To_Local'>state</span></a> <span class='Operator'>= </span><a href="../../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN140"><span class='Ref_to_Struct'>RewriteStateData</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="rewriteheap.c.html#LN251"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN142"><span class='Ref_to_Member'>rs_old_rel</span></a> <span class='Operator'>= </span><a href="rewriteheap.c.html#LN247"><span class='Ref_to_Parameter'>old_heap</span></a><span class='Delimiter'>; 
</span>    <a href="rewriteheap.c.html#LN251"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN143"><span class='Ref_to_Member'>rs_new_rel</span></a> <span class='Operator'>= </span><a href="rewriteheap.c.html#LN247"><span class='Ref_to_Parameter'>new_heap</span></a><span class='Delimiter'>; 
</span>    <a href="rewriteheap.c.html#LN251"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN144"><span class='Ref_to_Member'>rs_buffer</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/bufpage.h.html#LN73"><span class='Ref_to_Typedef'>Page</span></a><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span>BLCKSZ<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* new_heap needn't be empty, just locked */ 
</span>    <a href="rewriteheap.c.html#LN251"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN145"><span class='Ref_to_Member'>rs_blockno</span></a> <span class='Operator'>= </span><a href="../../../include/storage/bufmgr.h.html#LN198"><span class='Ref_to_Macro'>RelationGetNumberOfBlocks</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN247"><span class='Ref_to_Parameter'>new_heap</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="rewriteheap.c.html#LN251"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN146"><span class='Ref_to_Member'>rs_buffer_valid</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="rewriteheap.c.html#LN251"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN147"><span class='Ref_to_Member'>rs_use_wal</span></a> <span class='Operator'>= </span><a href="rewriteheap.c.html#LN249"><span class='Ref_to_Parameter'>use_wal</span></a><span class='Delimiter'>; 
</span>    <a href="rewriteheap.c.html#LN251"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN149"><span class='Ref_to_Member'>rs_oldest_xmin</span></a> <span class='Operator'>= </span><a href="rewriteheap.c.html#LN247"><span class='Ref_to_Parameter'>oldest_xmin</span></a><span class='Delimiter'>; 
</span>    <a href="rewriteheap.c.html#LN251"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN151"><span class='Ref_to_Member'>rs_freeze_xid</span></a> <span class='Operator'>= </span><a href="rewriteheap.c.html#LN248"><span class='Ref_to_Parameter'>freeze_xid</span></a><span class='Delimiter'>; 
</span>    <a href="rewriteheap.c.html#LN251"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN155"><span class='Ref_to_Member'>rs_cutoff_multi</span></a> <span class='Operator'>= </span><a href="rewriteheap.c.html#LN248"><span class='Ref_to_Parameter'>cutoff_multi</span></a><span class='Delimiter'>; 
</span>    <a href="rewriteheap.c.html#LN251"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN157"><span class='Ref_to_Member'>rs_cxt</span></a> <span class='Operator'>= </span><a href="rewriteheap.c.html#LN252"><span class='Ref_To_Local'>rw_cxt</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Initialize hash tables used to track update chains */ 
</span>    memset<span class='Parentheses'>(</span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN254"><span class='Ref_To_Local'>hash_ctl</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN254"><span class='Ref_To_Local'>hash_ctl</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="rewriteheap.c.html#LN254"><span class='Ref_To_Local'>hash_ctl</span></a><span class='Operator'>.</span><a href="../../../include/utils/hsearch.h.html#LN71"><span class='Ref_to_Member'>keysize</span></a> <span class='Operator'>= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN172"><span class='Ref_to_Typedef'>TidHashKey</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="rewriteheap.c.html#LN254"><span class='Ref_To_Local'>hash_ctl</span></a><span class='Operator'>.</span><a href="../../../include/utils/hsearch.h.html#LN72"><span class='Ref_to_Member'>entrysize</span></a> <span class='Operator'>= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN181"><span class='Ref_to_Typedef'>UnresolvedTupData</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="rewriteheap.c.html#LN254"><span class='Ref_To_Local'>hash_ctl</span></a><span class='Operator'>.</span><a href="../../../include/utils/hsearch.h.html#LN77"><span class='Ref_to_Member'>hcxt</span></a> <span class='Operator'>= </span><a href="rewriteheap.c.html#LN251"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN157"><span class='Ref_to_Member'>rs_cxt</span></a><span class='Delimiter'>; 
</span> 
    <a href="rewriteheap.c.html#LN251"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN160"><span class='Ref_to_Member'>rs_unresolved_tups</span></a> <span class='Operator'>= 
</span>        <a href="../../../include/utils/hsearch.h.html#LN121"><span class='Ref_to_Proto'>hash_create</span></a><span class='Parentheses'>(</span><span class='String'>"Rewrite / Unresolved ctids"</span><span class='Delimiter'>, 
</span>                    <span class='Number'>128</span><span class='Delimiter'>,</span>        <span class='Comment_Single_Line'>/* arbitrary initial size */ 
</span>                    <span class='Operator'>&</span><a href="rewriteheap.c.html#LN254"><span class='Ref_To_Local'>hash_ctl</span></a><span class='Delimiter'>, 
</span>                    <a href="../../../include/utils/hsearch.h.html#LN86"><span class='Ref_to_Const'>HASH_ELEM</span></a> <span class='Operator'>| </span><a href="../../../include/utils/hsearch.h.html#LN87"><span class='Ref_to_Const'>HASH_BLOBS</span></a> <span class='Operator'>| </span><a href="../../../include/utils/hsearch.h.html#LN92"><span class='Ref_to_Const'>HASH_CONTEXT</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="rewriteheap.c.html#LN254"><span class='Ref_To_Local'>hash_ctl</span></a><span class='Operator'>.</span><a href="../../../include/utils/hsearch.h.html#LN72"><span class='Ref_to_Member'>entrysize</span></a> <span class='Operator'>= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN190"><span class='Ref_to_Typedef'>OldToNewMappingData</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="rewriteheap.c.html#LN251"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN161"><span class='Ref_to_Member'>rs_old_new_tid_map</span></a> <span class='Operator'>= 
</span>        <a href="../../../include/utils/hsearch.h.html#LN121"><span class='Ref_to_Proto'>hash_create</span></a><span class='Parentheses'>(</span><span class='String'>"Rewrite / Old to new tid map"</span><span class='Delimiter'>, 
</span>                    <span class='Number'>128</span><span class='Delimiter'>,</span>        <span class='Comment_Single_Line'>/* arbitrary initial size */ 
</span>                    <span class='Operator'>&</span><a href="rewriteheap.c.html#LN254"><span class='Ref_To_Local'>hash_ctl</span></a><span class='Delimiter'>, 
</span>                    <a href="../../../include/utils/hsearch.h.html#LN86"><span class='Ref_to_Const'>HASH_ELEM</span></a> <span class='Operator'>| </span><a href="../../../include/utils/hsearch.h.html#LN87"><span class='Ref_to_Const'>HASH_BLOBS</span></a> <span class='Operator'>| </span><a href="../../../include/utils/hsearch.h.html#LN92"><span class='Ref_to_Const'>HASH_CONTEXT</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN253"><span class='Ref_To_Local'>old_cxt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="rewriteheap.c.html#LN228"><span class='Ref_to_Proto'>logical_begin_heap_rewrite</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN251"><span class='Ref_To_Local'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="rewriteheap.c.html#LN251"><span class='Ref_To_Local'>state</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end begin_heap_rewrite &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * End a rewrite. 
 * 
 * state and any other resources are freed. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN313"></a><span class='Declare_Function'>end_heap_rewrite</span><span class='Parentheses'>(</span><a href="../../../include/access/rewriteheap.h.html#LN21"><span class='Ref_to_Typedef'>RewriteState</span></a> <span class='Declare_Parameter'>state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN315"></a>    <a href="../../../include/utils/hsearch.h.html#LN111"><span class='Ref_to_Typedef'>HASH_SEQ_STATUS</span></a> <span class='Declare_Local'>seq_status</span><span class='Delimiter'>; 
</span><a name="LN316"></a>    <a href="rewriteheap.c.html#LN188"><span class='Ref_to_Typedef'>UnresolvedTup</span></a> <span class='Declare_Local'>unresolved</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Write any remaining tuples in the UnresolvedTups table. If we have any 
     * left, they should in fact be dead, but let's err on the safe side. 
     */ 
</span>    <a href="../../../include/utils/hsearch.h.html#LN134"><span class='Ref_to_Proto'>hash_seq_init</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN315"><span class='Ref_To_Local'>seq_status</span></a><span class='Delimiter'>, </span><a href="rewriteheap.c.html#LN313"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN160"><span class='Ref_to_Member'>rs_unresolved_tups</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>while</span> <span class='Parentheses'>((</span><a href="rewriteheap.c.html#LN316"><span class='Ref_To_Local'>unresolved</span></a> <span class='Operator'>= </span><a href="../../../include/utils/hsearch.h.html#LN135"><span class='Ref_to_Proto'>hash_seq_search</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN315"><span class='Ref_To_Local'>seq_status</span></a><span class='Parentheses'>))</span> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../include/storage/itemptr.h.html#LN148"><span class='Ref_to_Macro'>ItemPointerSetInvalid</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN316"><span class='Ref_To_Local'>unresolved</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN185"><span class='Ref_to_Member'>tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN66"><span class='Ref_to_Member'>t_data</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup_details.h.html#LN149"><span class='Ref_to_Member'>t_ctid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="rewriteheap.c.html#LN225"><span class='Ref_to_Proto'>raw_heap_insert</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN313"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="rewriteheap.c.html#LN316"><span class='Ref_To_Local'>unresolved</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN185"><span class='Ref_to_Member'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Write the last page, if any */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN313"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN146"><span class='Ref_to_Member'>rs_buffer_valid</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN313"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN147"><span class='Ref_to_Member'>rs_use_wal</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/access/xloginsert.h.html#LN54"><span class='Ref_to_Proto'>log_newpage</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN313"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN143"><span class='Ref_to_Member'>rs_new_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN84"><span class='Ref_to_Member'>rd_node</span></a><span class='Delimiter'>, 
</span>                        <a href="../../../include/common/relpath.h.html#LN26"><span class='Ref_to_EnumConst'>MAIN_FORKNUM</span></a><span class='Delimiter'>, 
</span>                        <a href="rewriteheap.c.html#LN313"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN145"><span class='Ref_to_Member'>rs_blockno</span></a><span class='Delimiter'>, 
</span>                        <a href="rewriteheap.c.html#LN313"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN144"><span class='Ref_to_Member'>rs_buffer</span></a><span class='Delimiter'>, 
</span>                        <span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/utils/rel.h.html#LN460"><span class='Ref_to_Macro'>RelationOpenSmgr</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN313"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN143"><span class='Ref_to_Member'>rs_new_rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/storage/bufpage.h.html#LN436"><span class='Ref_to_Proto'>PageSetChecksumInplace</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN313"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN144"><span class='Ref_to_Member'>rs_buffer</span></a><span class='Delimiter'>, </span><a href="rewriteheap.c.html#LN313"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN145"><span class='Ref_to_Member'>rs_blockno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/storage/smgr.h.html#LN94"><span class='Ref_to_Proto'>smgrextend</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN313"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN143"><span class='Ref_to_Member'>rs_new_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN86"><span class='Ref_to_Member'>rd_smgr</span></a><span class='Delimiter'>, </span><a href="../../../include/common/relpath.h.html#LN26"><span class='Ref_to_EnumConst'>MAIN_FORKNUM</span></a><span class='Delimiter'>, </span><a href="rewriteheap.c.html#LN313"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN145"><span class='Ref_to_Member'>rs_blockno</span></a><span class='Delimiter'>, 
</span>                   <span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="rewriteheap.c.html#LN313"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN144"><span class='Ref_to_Member'>rs_buffer</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the rel is WAL-logged, must fsync before commit.  We use heap_sync 
     * to ensure that the toast table gets fsync'd too. 
     * 
     * It's obvious that we must do this when not WAL-logging. It's less 
     * obvious that we have to do it even if we did WAL-log the pages. The 
     * reason is the same as in tablecmds.c's copy_relation_data(): we're 
     * writing data that's not in shared buffers, and so a CHECKPOINT 
     * occurring during the rewriteheap operation won't have fsync'd data we 
     * wrote before the checkpoint. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/rel.h.html#LN505"><span class='Ref_to_Macro'>RelationNeedsWAL</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN313"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN143"><span class='Ref_to_Member'>rs_new_rel</span></a><span class='Parentheses'>))</span> 
        <a href="../../../include/access/heapam.h.html#LN180"><span class='Ref_to_Proto'>heap_sync</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN313"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN143"><span class='Ref_to_Member'>rs_new_rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="rewriteheap.c.html#LN230"><span class='Ref_to_Proto'>logical_end_heap_rewrite</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN313"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Deleting the context frees everything */ 
</span>    <a href="../../../include/utils/memutils.h.html#LN74"><span class='Ref_to_Proto'>MemoryContextDelete</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN313"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN157"><span class='Ref_to_Member'>rs_cxt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end end_heap_rewrite &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Add a tuple to the new heap. 
 * 
 * Visibility information is copied from the original tuple, except that 
 * we "freeze" very-old tuples.  Note that since we scribble on new_tuple, 
 * it had better be temp storage not a pointer to the original tuple. 
 * 
 * state        opaque state as returned by begin_heap_rewrite 
 * old_tuple    original tuple in the old heap 
 * new_tuple    new, rewritten tuple to be inserted to new heap 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN379"></a><span class='Declare_Function'>rewrite_heap_tuple</span><span class='Parentheses'>(</span><a href="../../../include/access/rewriteheap.h.html#LN21"><span class='Ref_to_Typedef'>RewriteState</span></a> <span class='Declare_Parameter'>state</span><span class='Delimiter'>, 
</span><a name="LN380"></a>                   <a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a> <span class='Declare_Parameter'>old_tuple</span><span class='Delimiter'>, </span><a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a> <span class='Declare_Parameter'>new_tuple</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN382"></a>    <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>old_cxt</span><span class='Delimiter'>; 
</span><a name="LN383"></a>    <a href="../../../include/storage/itemptr.h.html#LN35"><span class='Ref_to_Struct'>ItemPointerData</span></a> <span class='Declare_Local'>old_tid</span><span class='Delimiter'>; 
</span><a name="LN384"></a>    <a href="rewriteheap.c.html#LN172"><span class='Ref_to_Typedef'>TidHashKey</span></a>  <span class='Declare_Local'>hashkey</span><span class='Delimiter'>; 
</span><a name="LN385"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>found</span><span class='Delimiter'>; 
</span><a name="LN386"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>free_new</span><span class='Delimiter'>; 
</span> 
    <a href="rewriteheap.c.html#LN382"><span class='Ref_To_Local'>old_cxt</span></a> <span class='Operator'>= </span><a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN379"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN157"><span class='Ref_to_Member'>rs_cxt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Copy the original tuple's visibility information into new_tuple. 
     * 
     * XXX we might later need to copy some t_infomask2 bits, too? Right now, 
     * we intentionally clear the HOT status bits. 
     */ 
</span>    memcpy<span class='Parentheses'>(</span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN380"><span class='Ref_to_Parameter'>new_tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN66"><span class='Ref_to_Member'>t_data</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup_details.h.html#LN147"><span class='Ref_to_Member'>t_choice</span></a><span class='Operator'>.</span>t_heap<span class='Delimiter'>, 
</span>           <span class='Operator'>&</span><a href="rewriteheap.c.html#LN380"><span class='Ref_to_Parameter'>old_tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN66"><span class='Ref_to_Member'>t_data</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup_details.h.html#LN147"><span class='Ref_to_Member'>t_choice</span></a><span class='Operator'>.</span>t_heap<span class='Delimiter'>, 
</span>           <span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/access/htup_details.h.html#LN115"><span class='Ref_to_Struct'>HeapTupleFields</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="rewriteheap.c.html#LN380"><span class='Ref_to_Parameter'>new_tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN66"><span class='Ref_to_Member'>t_data</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup_details.h.html#LN156"><span class='Ref_to_Member'>t_infomask</span></a> <span class='Operator'>&= ~</span><a href="../../../include/access/htup_details.h.html#LN203"><span class='Ref_to_Const'>HEAP_XACT_MASK</span></a><span class='Delimiter'>; 
</span>    <a href="rewriteheap.c.html#LN380"><span class='Ref_to_Parameter'>new_tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN66"><span class='Ref_to_Member'>t_data</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup_details.h.html#LN154"><span class='Ref_to_Member'>t_infomask2</span></a> <span class='Operator'>&= ~</span><a href="../../../include/access/htup_details.h.html#LN268"><span class='Ref_to_Const'>HEAP2_XACT_MASK</span></a><span class='Delimiter'>; 
</span>    <a href="rewriteheap.c.html#LN380"><span class='Ref_to_Parameter'>new_tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN66"><span class='Ref_to_Member'>t_data</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup_details.h.html#LN156"><span class='Ref_to_Member'>t_infomask</span></a> <span class='Operator'>|= 
</span>        <a href="rewriteheap.c.html#LN380"><span class='Ref_to_Parameter'>old_tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN66"><span class='Ref_to_Member'>t_data</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup_details.h.html#LN156"><span class='Ref_to_Member'>t_infomask</span></a> <span class='Operator'>& </span><a href="../../../include/access/htup_details.h.html#LN203"><span class='Ref_to_Const'>HEAP_XACT_MASK</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * While we have our hands on the tuple, we may as well freeze any 
     * eligible xmin or xmax, so that future VACUUM effort can be saved. 
     */ 
</span>    <a href="../../../include/access/heapam.h.html#LN169"><span class='Ref_to_Proto'>heap_freeze_tuple</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN380"><span class='Ref_to_Parameter'>new_tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN66"><span class='Ref_to_Member'>t_data</span></a><span class='Delimiter'>, </span><a href="rewriteheap.c.html#LN379"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN151"><span class='Ref_to_Member'>rs_freeze_xid</span></a><span class='Delimiter'>, 
</span>                      <a href="rewriteheap.c.html#LN379"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN155"><span class='Ref_to_Member'>rs_cutoff_multi</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Invalid ctid means that ctid should point to the tuple itself. We'll 
     * override it later if the tuple is part of an update chain. 
     */ 
</span>    <a href="../../../include/storage/itemptr.h.html#LN148"><span class='Ref_to_Macro'>ItemPointerSetInvalid</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN380"><span class='Ref_to_Parameter'>new_tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN66"><span class='Ref_to_Member'>t_data</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup_details.h.html#LN149"><span class='Ref_to_Member'>t_ctid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the tuple has been updated, check the old-to-new mapping hash table. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>((</span><a href="rewriteheap.c.html#LN380"><span class='Ref_to_Parameter'>old_tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN66"><span class='Ref_to_Member'>t_data</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup_details.h.html#LN156"><span class='Ref_to_Member'>t_infomask</span></a> <span class='Operator'>& </span><a href="../../../include/access/htup_details.h.html#LN192"><span class='Ref_to_Const'>HEAP_XMAX_INVALID</span></a><span class='Parentheses'>)</span> <span class='Operator'>|| 
</span>          <a href="../../../include/utils/tqual.h.html#LN81"><span class='Ref_to_Proto'>HeapTupleHeaderIsOnlyLocked</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN380"><span class='Ref_to_Parameter'>old_tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN66"><span class='Ref_to_Member'>t_data</span></a><span class='Parentheses'>))</span> <span class='Operator'>&& 
</span>        <span class='Operator'>!</span><span class='Parentheses'>(</span><a href="../../storage/page/itemptr.c.html#LN27"><span class='Ref_to_Func'>ItemPointerEquals</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN380"><span class='Ref_to_Parameter'>old_tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN64"><span class='Ref_to_Member'>t_self</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                            <span class='Operator'>&</span><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN380"><span class='Ref_to_Parameter'>old_tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN66"><span class='Ref_to_Member'>t_data</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup_details.h.html#LN149"><span class='Ref_to_Member'>t_ctid</span></a><span class='Parentheses'>))))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN426"></a>        <a href="rewriteheap.c.html#LN196"><span class='Ref_to_Typedef'>OldToNewMapping</span></a> <span class='Declare_Local'>mapping</span><span class='Delimiter'>; 
</span> 
        memset<span class='Parentheses'>(</span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN384"><span class='Ref_To_Local'>hashkey</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN384"><span class='Ref_To_Local'>hashkey</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="rewriteheap.c.html#LN384"><span class='Ref_To_Local'>hashkey</span></a><span class='Operator'>.</span><a href="rewriteheap.c.html#LN174"><span class='Ref_to_Member'>xmin</span></a> <span class='Operator'>= </span><a href="../../../include/access/htup_details.h.html#LN358"><span class='Ref_to_Macro'>HeapTupleHeaderGetUpdateXid</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN380"><span class='Ref_to_Parameter'>old_tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN66"><span class='Ref_to_Member'>t_data</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="rewriteheap.c.html#LN384"><span class='Ref_To_Local'>hashkey</span></a><span class='Operator'>.</span><a href="rewriteheap.c.html#LN175"><span class='Ref_to_Member'>tid</span></a> <span class='Operator'>= </span><a href="rewriteheap.c.html#LN380"><span class='Ref_to_Parameter'>old_tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN66"><span class='Ref_to_Member'>t_data</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup_details.h.html#LN149"><span class='Ref_to_Member'>t_ctid</span></a><span class='Delimiter'>; 
</span> 
        <a href="rewriteheap.c.html#LN426"><span class='Ref_To_Local'>mapping</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN196"><span class='Ref_to_Typedef'>OldToNewMapping</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/utils/hsearch.h.html#LN125"><span class='Ref_to_Proto'>hash_search</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN379"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN161"><span class='Ref_to_Member'>rs_old_new_tid_map</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN384"><span class='Ref_To_Local'>hashkey</span></a><span class='Delimiter'>, 
</span>                        <a href="../../../include/utils/hsearch.h.html#LN104"><span class='Ref_to_EnumConst'>HASH_FIND</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN426"><span class='Ref_To_Local'>mapping</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * We've already copied the tuple that t_ctid points to, so we can 
             * set the ctid of this tuple to point to the new location, and 
             * insert it right away. 
             */ 
</span>            <a href="rewriteheap.c.html#LN380"><span class='Ref_to_Parameter'>new_tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN66"><span class='Ref_to_Member'>t_data</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup_details.h.html#LN149"><span class='Ref_to_Member'>t_ctid</span></a> <span class='Operator'>= </span><a href="rewriteheap.c.html#LN426"><span class='Ref_To_Local'>mapping</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN193"><span class='Ref_to_Member'>new_tid</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* We don't need the mapping entry anymore */ 
</span>            <a href="../../../include/utils/hsearch.h.html#LN125"><span class='Ref_to_Proto'>hash_search</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN379"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN161"><span class='Ref_to_Member'>rs_old_new_tid_map</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN384"><span class='Ref_To_Local'>hashkey</span></a><span class='Delimiter'>, 
</span>                        <a href="../../../include/utils/hsearch.h.html#LN106"><span class='Ref_to_EnumConst'>HASH_REMOVE</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN385"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN385"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * We haven't seen the tuple t_ctid points to yet. Stash this 
             * tuple into unresolved_tups to be written later. 
             */ 
</span><a name="LN456"></a>            <a href="rewriteheap.c.html#LN188"><span class='Ref_to_Typedef'>UnresolvedTup</span></a> <span class='Declare_Local'>unresolved</span><span class='Delimiter'>; 
</span> 
            <a href="rewriteheap.c.html#LN456"><span class='Ref_To_Local'>unresolved</span></a> <span class='Operator'>= </span><a href="../../../include/utils/hsearch.h.html#LN125"><span class='Ref_to_Proto'>hash_search</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN379"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN160"><span class='Ref_to_Member'>rs_unresolved_tups</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN384"><span class='Ref_To_Local'>hashkey</span></a><span class='Delimiter'>, 
</span>                                     <a href="../../../include/utils/hsearch.h.html#LN105"><span class='Ref_to_EnumConst'>HASH_ENTER</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN385"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="rewriteheap.c.html#LN385"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="rewriteheap.c.html#LN456"><span class='Ref_To_Local'>unresolved</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN184"><span class='Ref_to_Member'>old_tid</span></a> <span class='Operator'>= </span><a href="rewriteheap.c.html#LN380"><span class='Ref_to_Parameter'>old_tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN64"><span class='Ref_to_Member'>t_self</span></a><span class='Delimiter'>; 
</span>            <a href="rewriteheap.c.html#LN456"><span class='Ref_To_Local'>unresolved</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN185"><span class='Ref_to_Member'>tuple</span></a> <span class='Operator'>= </span><a href="../common/heaptuple.c.html#LN606"><span class='Ref_to_Func'>heap_copytuple</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN380"><span class='Ref_to_Parameter'>new_tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * We can't do anything more now, since we don't know where the 
             * tuple will be written. 
             */ 
</span>            <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN382"><span class='Ref_To_Local'>old_cxt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !((old_tuple-&GT;t_data-... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Now we will write the tuple, and then check to see if it is the B tuple 
     * in any new or known pair.  When we resolve a known pair, we will be 
     * able to write that pair's A tuple, and then we have to check if it 
     * resolves some other pair.  Hence, we need a loop here. 
     */ 
</span>    <a href="rewriteheap.c.html#LN383"><span class='Ref_To_Local'>old_tid</span></a> <span class='Operator'>= </span><a href="rewriteheap.c.html#LN380"><span class='Ref_to_Parameter'>old_tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN64"><span class='Ref_to_Member'>t_self</span></a><span class='Delimiter'>; 
</span>    <a href="rewriteheap.c.html#LN386"><span class='Ref_To_Local'>free_new</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>;;</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN485"></a>        <a href="../../../include/storage/itemptr.h.html#LN35"><span class='Ref_to_Struct'>ItemPointerData</span></a> <span class='Declare_Local'>new_tid</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Insert the tuple and find out where it's put in new_heap */ 
</span>        <a href="rewriteheap.c.html#LN225"><span class='Ref_to_Proto'>raw_heap_insert</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN379"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="rewriteheap.c.html#LN380"><span class='Ref_to_Parameter'>new_tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="rewriteheap.c.html#LN485"><span class='Ref_To_Local'>new_tid</span></a> <span class='Operator'>= </span><a href="rewriteheap.c.html#LN380"><span class='Ref_to_Parameter'>new_tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN64"><span class='Ref_to_Member'>t_self</span></a><span class='Delimiter'>; 
</span> 
        <a href="rewriteheap.c.html#LN229"><span class='Ref_to_Proto'>logical_rewrite_heap_tuple</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN379"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="rewriteheap.c.html#LN383"><span class='Ref_To_Local'>old_tid</span></a><span class='Delimiter'>, </span><a href="rewriteheap.c.html#LN380"><span class='Ref_to_Parameter'>new_tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If the tuple is the updated version of a row, and the prior version 
         * wouldn't be DEAD yet, then we need to either resolve the prior 
         * version (if it's waiting in rs_unresolved_tups), or make an entry 
         * in rs_old_new_tid_map (so we can resolve it when we do see it). The 
         * previous tuple's xmax would equal this one's xmin, so it's 
         * RECENTLY_DEAD if and only if the xmin is not before OldestXmin. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="rewriteheap.c.html#LN380"><span class='Ref_to_Parameter'>new_tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN66"><span class='Ref_to_Member'>t_data</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup_details.h.html#LN156"><span class='Ref_to_Member'>t_infomask</span></a> <span class='Operator'>& </span><a href="../../../include/access/htup_details.h.html#LN194"><span class='Ref_to_Const'>HEAP_UPDATED</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>            <span class='Operator'>!</span><a href="../../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="../../../include/access/htup_details.h.html#LN306"><span class='Ref_to_Macro'>HeapTupleHeaderGetXmin</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN380"><span class='Ref_to_Parameter'>new_tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN66"><span class='Ref_to_Member'>t_data</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                   <a href="rewriteheap.c.html#LN379"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN149"><span class='Ref_to_Member'>rs_oldest_xmin</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Okay, this is B in an update pair.  See if we've seen A. 
             */ 
</span><a name="LN508"></a>            <a href="rewriteheap.c.html#LN188"><span class='Ref_to_Typedef'>UnresolvedTup</span></a> <span class='Declare_Local'>unresolved</span><span class='Delimiter'>; 
</span> 
            memset<span class='Parentheses'>(</span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN384"><span class='Ref_To_Local'>hashkey</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN384"><span class='Ref_To_Local'>hashkey</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="rewriteheap.c.html#LN384"><span class='Ref_To_Local'>hashkey</span></a><span class='Operator'>.</span><a href="rewriteheap.c.html#LN174"><span class='Ref_to_Member'>xmin</span></a> <span class='Operator'>= </span><a href="../../../include/access/htup_details.h.html#LN306"><span class='Ref_to_Macro'>HeapTupleHeaderGetXmin</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN380"><span class='Ref_to_Parameter'>new_tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN66"><span class='Ref_to_Member'>t_data</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="rewriteheap.c.html#LN384"><span class='Ref_To_Local'>hashkey</span></a><span class='Operator'>.</span><a href="rewriteheap.c.html#LN175"><span class='Ref_to_Member'>tid</span></a> <span class='Operator'>= </span><a href="rewriteheap.c.html#LN383"><span class='Ref_To_Local'>old_tid</span></a><span class='Delimiter'>; 
</span> 
            <a href="rewriteheap.c.html#LN508"><span class='Ref_To_Local'>unresolved</span></a> <span class='Operator'>= </span><a href="../../../include/utils/hsearch.h.html#LN125"><span class='Ref_to_Proto'>hash_search</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN379"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN160"><span class='Ref_to_Member'>rs_unresolved_tups</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN384"><span class='Ref_To_Local'>hashkey</span></a><span class='Delimiter'>, 
</span>                                     <a href="../../../include/utils/hsearch.h.html#LN104"><span class='Ref_to_EnumConst'>HASH_FIND</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN508"><span class='Ref_To_Local'>unresolved</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * We have seen and memorized the previous tuple already. Now 
                 * that we know where we inserted the tuple its t_ctid points 
                 * to, fix its t_ctid and insert it to the new heap. 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN386"><span class='Ref_To_Local'>free_new</span></a><span class='Parentheses'>) 
</span>                    <a href="../../../include/access/htup_details.h.html#LN815"><span class='Ref_to_Proto'>heap_freetuple</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN380"><span class='Ref_to_Parameter'>new_tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="rewriteheap.c.html#LN380"><span class='Ref_to_Parameter'>new_tuple</span></a> <span class='Operator'>= </span><a href="rewriteheap.c.html#LN508"><span class='Ref_To_Local'>unresolved</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN185"><span class='Ref_to_Member'>tuple</span></a><span class='Delimiter'>; 
</span>                <a href="rewriteheap.c.html#LN386"><span class='Ref_To_Local'>free_new</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <a href="rewriteheap.c.html#LN383"><span class='Ref_To_Local'>old_tid</span></a> <span class='Operator'>= </span><a href="rewriteheap.c.html#LN508"><span class='Ref_To_Local'>unresolved</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN184"><span class='Ref_to_Member'>old_tid</span></a><span class='Delimiter'>; 
</span>                <a href="rewriteheap.c.html#LN380"><span class='Ref_to_Parameter'>new_tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN66"><span class='Ref_to_Member'>t_data</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup_details.h.html#LN149"><span class='Ref_to_Member'>t_ctid</span></a> <span class='Operator'>= </span><a href="rewriteheap.c.html#LN485"><span class='Ref_To_Local'>new_tid</span></a><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * We don't need the hash entry anymore, but don't free its 
                 * tuple just yet. 
                 */ 
</span>                <a href="../../../include/utils/hsearch.h.html#LN125"><span class='Ref_to_Proto'>hash_search</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN379"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN160"><span class='Ref_to_Member'>rs_unresolved_tups</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN384"><span class='Ref_To_Local'>hashkey</span></a><span class='Delimiter'>, 
</span>                            <a href="../../../include/utils/hsearch.h.html#LN106"><span class='Ref_to_EnumConst'>HASH_REMOVE</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN385"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN385"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* loop back to insert the previous tuple in the chain */ 
</span>                <span class='Control'>continue</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if unresolved!=NULL &raquo; </span> 
            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * Remember the new tid of this tuple. We'll use it to set the 
                 * ctid when we find the previous tuple in the chain. 
                 */ 
</span><a name="LN548"></a>                <a href="rewriteheap.c.html#LN196"><span class='Ref_to_Typedef'>OldToNewMapping</span></a> <span class='Declare_Local'>mapping</span><span class='Delimiter'>; 
</span> 
                <a href="rewriteheap.c.html#LN548"><span class='Ref_To_Local'>mapping</span></a> <span class='Operator'>= </span><a href="../../../include/utils/hsearch.h.html#LN125"><span class='Ref_to_Proto'>hash_search</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN379"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN161"><span class='Ref_to_Member'>rs_old_new_tid_map</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN384"><span class='Ref_To_Local'>hashkey</span></a><span class='Delimiter'>, 
</span>                                      <a href="../../../include/utils/hsearch.h.html#LN105"><span class='Ref_to_EnumConst'>HASH_ENTER</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN385"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="rewriteheap.c.html#LN385"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="rewriteheap.c.html#LN548"><span class='Ref_To_Local'>mapping</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN193"><span class='Ref_to_Member'>new_tid</span></a> <span class='Operator'>= </span><a href="rewriteheap.c.html#LN485"><span class='Ref_To_Local'>new_tid</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if (new_tuple-&GT;t_data-&GT;t... &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* Done with this (chain of) tuples, for now */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN386"><span class='Ref_To_Local'>free_new</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/access/htup_details.h.html#LN815"><span class='Ref_to_Proto'>heap_freetuple</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN380"><span class='Ref_to_Parameter'>new_tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for ;; &raquo; </span> 
 
    <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN382"><span class='Ref_To_Local'>old_cxt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end rewrite_heap_tuple &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Register a dead tuple with an ongoing rewrite. Dead tuples are not 
 * copied to the new table, but we still make note of them so that we 
 * can release some resources earlier. 
 * 
 * Returns true if a tuple was removed from the unresolved_tups table. 
 * This indicates that that tuple, previously thought to be "recently dead", 
 * is now known really dead and won't be written to the output. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN577"></a><span class='Declare_Function'>rewrite_heap_dead_tuple</span><span class='Parentheses'>(</span><a href="../../../include/access/rewriteheap.h.html#LN21"><span class='Ref_to_Typedef'>RewriteState</span></a> <span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a> <span class='Declare_Parameter'>old_tuple</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * If we have already seen an earlier tuple in the update chain that 
     * points to this tuple, let's forget about that earlier tuple. It's in 
     * fact dead as well, our simple xmax &LT; OldestXmin test in 
     * HeapTupleSatisfiesVacuum just wasn't enough to detect it. It happens 
     * when xmin of a tuple is greater than xmax, which sounds 
     * counter-intuitive but is perfectly valid. 
     * 
     * We don't bother to try to detect the situation the other way round, 
     * when we encounter the dead tuple first and then the recently dead one 
     * that points to it. If that happens, we'll have some unmatched entries 
     * in the UnresolvedTups hash table at the end. That can happen anyway, 
     * because a vacuum might have removed the dead tuple in the chain before 
     * us. 
     */ 
</span><a name="LN594"></a>    <a href="rewriteheap.c.html#LN188"><span class='Ref_to_Typedef'>UnresolvedTup</span></a> <span class='Declare_Local'>unresolved</span><span class='Delimiter'>; 
</span><a name="LN595"></a>    <a href="rewriteheap.c.html#LN172"><span class='Ref_to_Typedef'>TidHashKey</span></a>  <span class='Declare_Local'>hashkey</span><span class='Delimiter'>; 
</span><a name="LN596"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>found</span><span class='Delimiter'>; 
</span> 
    memset<span class='Parentheses'>(</span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN595"><span class='Ref_To_Local'>hashkey</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN595"><span class='Ref_To_Local'>hashkey</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="rewriteheap.c.html#LN595"><span class='Ref_To_Local'>hashkey</span></a><span class='Operator'>.</span><a href="rewriteheap.c.html#LN174"><span class='Ref_to_Member'>xmin</span></a> <span class='Operator'>= </span><a href="../../../include/access/htup_details.h.html#LN306"><span class='Ref_to_Macro'>HeapTupleHeaderGetXmin</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN577"><span class='Ref_to_Parameter'>old_tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN66"><span class='Ref_to_Member'>t_data</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="rewriteheap.c.html#LN595"><span class='Ref_To_Local'>hashkey</span></a><span class='Operator'>.</span><a href="rewriteheap.c.html#LN175"><span class='Ref_to_Member'>tid</span></a> <span class='Operator'>= </span><a href="rewriteheap.c.html#LN577"><span class='Ref_to_Parameter'>old_tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN64"><span class='Ref_to_Member'>t_self</span></a><span class='Delimiter'>; 
</span> 
    <a href="rewriteheap.c.html#LN594"><span class='Ref_To_Local'>unresolved</span></a> <span class='Operator'>= </span><a href="../../../include/utils/hsearch.h.html#LN125"><span class='Ref_to_Proto'>hash_search</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN577"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN160"><span class='Ref_to_Member'>rs_unresolved_tups</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN595"><span class='Ref_To_Local'>hashkey</span></a><span class='Delimiter'>, 
</span>                             <a href="../../../include/utils/hsearch.h.html#LN104"><span class='Ref_to_EnumConst'>HASH_FIND</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN594"><span class='Ref_To_Local'>unresolved</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Need to free the contained tuple as well as the hashtable entry */ 
</span>        <a href="../../../include/access/htup_details.h.html#LN815"><span class='Ref_to_Proto'>heap_freetuple</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN594"><span class='Ref_To_Local'>unresolved</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN185"><span class='Ref_to_Member'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/utils/hsearch.h.html#LN125"><span class='Ref_to_Proto'>hash_search</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN577"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN160"><span class='Ref_to_Member'>rs_unresolved_tups</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN595"><span class='Ref_To_Local'>hashkey</span></a><span class='Delimiter'>, 
</span>                    <a href="../../../include/utils/hsearch.h.html#LN106"><span class='Ref_to_EnumConst'>HASH_REMOVE</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN596"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN596"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end rewrite_heap_dead_tuple &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Insert a tuple to the new relation.  This has to track heap_insert 
 * and its subsidiary functions! 
 * 
 * t_self of the tuple is set to the new TID of the tuple. If t_ctid of the 
 * tuple is invalid on entry, it's replaced with the new TID as well (in 
 * the inserted data only, not in the caller's copy). 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN627"></a><span class='Declare_Function'>raw_heap_insert</span><span class='Parentheses'>(</span><a href="../../../include/access/rewriteheap.h.html#LN21"><span class='Ref_to_Typedef'>RewriteState</span></a> <span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a> <span class='Declare_Parameter'>tup</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN629"></a>    <a href="../../../include/storage/bufpage.h.html#LN73"><span class='Ref_to_Typedef'>Page</span></a>        <span class='Declare_Local'>page</span> <span class='Operator'>= </span><a href="rewriteheap.c.html#LN627"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN144"><span class='Ref_to_Member'>rs_buffer</span></a><span class='Delimiter'>; 
</span><a name="LN630"></a>    <a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a>        <span class='Declare_Local'>pageFreeSpace</span><span class='Delimiter'>, 
</span><a name="LN631"></a>                <span class='Declare_Local'>saveFreeSpace</span><span class='Delimiter'>; 
</span><a name="LN632"></a>    <a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a>        <span class='Declare_Local'>len</span><span class='Delimiter'>; 
</span><a name="LN633"></a>    <a href="../../../include/storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Local'>newoff</span><span class='Delimiter'>; 
</span><a name="LN634"></a>    <a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>heaptup</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the new tuple is too big for storage or contains already toasted 
     * out-of-line attributes from some other relation, invoke the toaster. 
     * 
     * Note: below this point, heaptup is the data we actually intend to store 
     * into the relation; tup is the caller's original untoasted data. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN627"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN143"><span class='Ref_to_Member'>rs_new_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relkind <span class='Operator'>== </span><a href="../../../include/catalog/pg_class.h.html#LN162"><span class='Ref_to_Const'>RELKIND_TOASTVALUE</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* toast table entries should never be recursively toasted */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/htup_details.h.html#LN673"><span class='Ref_to_Macro'>HeapTupleHasExternal</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN627"><span class='Ref_to_Parameter'>tup</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="rewriteheap.c.html#LN634"><span class='Ref_To_Local'>heaptup</span></a> <span class='Operator'>= </span><a href="rewriteheap.c.html#LN627"><span class='Ref_to_Parameter'>tup</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/htup_details.h.html#LN673"><span class='Ref_to_Macro'>HeapTupleHasExternal</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN627"><span class='Ref_to_Parameter'>tup</span></a><span class='Parentheses'>) </span><span class='Operator'>|| </span><a href="rewriteheap.c.html#LN627"><span class='Ref_to_Parameter'>tup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN63"><span class='Ref_to_Member'>t_len</span></a> <span class='Operator'>&GT; </span><a href="../../../include/access/tuptoaster.h.html#LN54"><span class='Ref_to_Const'>TOAST_TUPLE_THRESHOLD</span></a><span class='Parentheses'>)</span> 
        <a href="rewriteheap.c.html#LN634"><span class='Ref_To_Local'>heaptup</span></a> <span class='Operator'>= </span><a href="../../../include/access/tuptoaster.h.html#LN134"><span class='Ref_to_Proto'>toast_insert_or_update</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN627"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN143"><span class='Ref_to_Member'>rs_new_rel</span></a><span class='Delimiter'>, </span><a href="rewriteheap.c.html#LN627"><span class='Ref_to_Parameter'>tup</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                                         <a href="../../../include/access/heapam.h.html#LN28"><span class='Ref_to_Const'>HEAP_INSERT_SKIP_FSM</span></a> <span class='Operator'>| 
</span>                                         <span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN627"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN147"><span class='Ref_to_Member'>rs_use_wal</span></a> <span class='Operator'>? 
</span>                                          <span class='Number'>0</span> <span class='Operator'>: </span><a href="../../../include/access/heapam.h.html#LN27"><span class='Ref_to_Const'>HEAP_INSERT_SKIP_WAL</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="rewriteheap.c.html#LN634"><span class='Ref_To_Local'>heaptup</span></a> <span class='Operator'>= </span><a href="rewriteheap.c.html#LN627"><span class='Ref_to_Parameter'>tup</span></a><span class='Delimiter'>; 
</span> 
    <a href="rewriteheap.c.html#LN632"><span class='Ref_To_Local'>len</span></a> <span class='Operator'>= </span><a href="../../../include/c.h.html#LN587"><span class='Ref_to_Macro'>MAXALIGN</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN634"><span class='Ref_To_Local'>heaptup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN63"><span class='Ref_to_Member'>t_len</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* be conservative */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we're gonna fail for oversize tuple, do it right away 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN632"><span class='Ref_To_Local'>len</span></a> <span class='Operator'>&GT; </span><a href="../../../include/access/htup_details.h.html#LN560"><span class='Ref_to_Const'>MaxHeapTupleSize</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_PROGRAM_LIMIT_EXCEEDED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"row is too big: size %zu, maximum size %zu"</span><span class='Delimiter'>, 
</span>                        <a href="rewriteheap.c.html#LN632"><span class='Ref_To_Local'>len</span></a><span class='Delimiter'>, </span><a href="../../../include/access/htup_details.h.html#LN560"><span class='Ref_to_Const'>MaxHeapTupleSize</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Compute desired extra freespace due to fillfactor option */ 
</span>    <a href="rewriteheap.c.html#LN631"><span class='Ref_To_Local'>saveFreeSpace</span></a> <span class='Operator'>= </span><a href="../../../include/utils/rel.h.html#LN307"><span class='Ref_to_Macro'>RelationGetTargetPageFreeSpace</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN627"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN143"><span class='Ref_to_Member'>rs_new_rel</span></a><span class='Delimiter'>, 
</span>                                                   <a href="../../../include/utils/rel.h.html#LN286"><span class='Ref_to_Const'>HEAP_DEFAULT_FILLFACTOR</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Now we can check to see if there's enough free space already. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN627"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN146"><span class='Ref_to_Member'>rs_buffer_valid</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="rewriteheap.c.html#LN630"><span class='Ref_To_Local'>pageFreeSpace</span></a> <span class='Operator'>= </span><a href="../../../include/storage/bufpage.h.html#LN429"><span class='Ref_to_Proto'>PageGetHeapFreeSpace</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN629"><span class='Ref_To_Local'>page</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN632"><span class='Ref_To_Local'>len</span></a> <span class='Operator'>+ </span><a href="rewriteheap.c.html#LN631"><span class='Ref_To_Local'>saveFreeSpace</span></a> <span class='Operator'>&GT; </span><a href="rewriteheap.c.html#LN630"><span class='Ref_To_Local'>pageFreeSpace</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Doesn't fit, so write out the existing page */ 
</span> 
            <span class='Comment_Multi_Line'>/* XLOG stuff */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN627"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN147"><span class='Ref_to_Member'>rs_use_wal</span></a><span class='Parentheses'>) 
</span>                <a href="../../../include/access/xloginsert.h.html#LN54"><span class='Ref_to_Proto'>log_newpage</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN627"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN143"><span class='Ref_to_Member'>rs_new_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN84"><span class='Ref_to_Member'>rd_node</span></a><span class='Delimiter'>, 
</span>                            <a href="../../../include/common/relpath.h.html#LN26"><span class='Ref_to_EnumConst'>MAIN_FORKNUM</span></a><span class='Delimiter'>, 
</span>                            <a href="rewriteheap.c.html#LN627"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN145"><span class='Ref_to_Member'>rs_blockno</span></a><span class='Delimiter'>, 
</span>                            <a href="rewriteheap.c.html#LN629"><span class='Ref_To_Local'>page</span></a><span class='Delimiter'>, 
</span>                            <span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Now write the page. We say isTemp = true even if it's not a 
             * temp table, because there's no need for smgr to schedule an 
             * fsync for this write; we'll do it ourselves in 
             * end_heap_rewrite. 
             */ 
</span>            <a href="../../../include/utils/rel.h.html#LN460"><span class='Ref_to_Macro'>RelationOpenSmgr</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN627"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN143"><span class='Ref_to_Member'>rs_new_rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="../../../include/storage/bufpage.h.html#LN436"><span class='Ref_to_Proto'>PageSetChecksumInplace</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN629"><span class='Ref_To_Local'>page</span></a><span class='Delimiter'>, </span><a href="rewriteheap.c.html#LN627"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN145"><span class='Ref_to_Member'>rs_blockno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="../../../include/storage/smgr.h.html#LN94"><span class='Ref_to_Proto'>smgrextend</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN627"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN143"><span class='Ref_to_Member'>rs_new_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN86"><span class='Ref_to_Member'>rd_smgr</span></a><span class='Delimiter'>, </span><a href="../../../include/common/relpath.h.html#LN26"><span class='Ref_to_EnumConst'>MAIN_FORKNUM</span></a><span class='Delimiter'>, 
</span>                       <a href="rewriteheap.c.html#LN627"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN145"><span class='Ref_to_Member'>rs_blockno</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="rewriteheap.c.html#LN629"><span class='Ref_To_Local'>page</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="rewriteheap.c.html#LN627"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN145"><span class='Ref_to_Member'>rs_blockno</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <a href="rewriteheap.c.html#LN627"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN146"><span class='Ref_to_Member'>rs_buffer_valid</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if len+saveFreeSpace&GT;pag... &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if state-&GT;rs_buffer_vali... &raquo; </span> 
 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="rewriteheap.c.html#LN627"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN146"><span class='Ref_to_Member'>rs_buffer_valid</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Initialize a new empty page */ 
</span>        <a href="../../storage/page/bufpage.c.html#LN39"><span class='Ref_to_Func'>PageInit</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN629"><span class='Ref_To_Local'>page</span></a><span class='Delimiter'>, </span>BLCKSZ<span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="rewriteheap.c.html#LN627"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN146"><span class='Ref_to_Member'>rs_buffer_valid</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* And now we can insert the tuple into the page */ 
</span>    <a href="rewriteheap.c.html#LN633"><span class='Ref_To_Local'>newoff</span></a> <span class='Operator'>= </span><a href="../../../include/storage/bufpage.h.html#LN412"><span class='Ref_to_Macro'>PageAddItem</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN629"><span class='Ref_To_Local'>page</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/storage/item.h.html#LN16"><span class='Ref_to_Typedef'>Item</span></a><span class='Parentheses'>) </span><a href="rewriteheap.c.html#LN634"><span class='Ref_To_Local'>heaptup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN66"><span class='Ref_to_Member'>t_data</span></a><span class='Delimiter'>, </span><a href="rewriteheap.c.html#LN634"><span class='Ref_To_Local'>heaptup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN63"><span class='Ref_to_Member'>t_len</span></a><span class='Delimiter'>, 
</span>                         <a href="../../../include/storage/off.h.html#LN25"><span class='Ref_to_Const'>InvalidOffsetNumber</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN633"><span class='Ref_To_Local'>newoff</span></a> <span class='Operator'>== </span><a href="../../../include/storage/off.h.html#LN25"><span class='Ref_to_Const'>InvalidOffsetNumber</span></a><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"failed to add tuple"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Update caller's t_self to the actual position where it was stored */ 
</span>    <a href="../../../include/storage/itemptr.h.html#LN103"><span class='Ref_to_Macro'>ItemPointerSet</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN627"><span class='Ref_to_Parameter'>tup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN64"><span class='Ref_to_Member'>t_self</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="rewriteheap.c.html#LN627"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN145"><span class='Ref_to_Member'>rs_blockno</span></a><span class='Delimiter'>, </span><a href="rewriteheap.c.html#LN633"><span class='Ref_To_Local'>newoff</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Insert the correct position into CTID of the stored tuple, too, if the 
     * caller didn't supply a valid CTID. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/storage/itemptr.h.html#LN58"><span class='Ref_to_Macro'>ItemPointerIsValid</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN627"><span class='Ref_to_Parameter'>tup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN66"><span class='Ref_to_Member'>t_data</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup_details.h.html#LN149"><span class='Ref_to_Member'>t_ctid</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN729"></a>        <a href="../../../include/storage/itemid.h.html#LN30"><span class='Ref_to_Typedef'>ItemId</span></a>      <span class='Declare_Local'>newitemid</span><span class='Delimiter'>; 
</span><a name="LN730"></a>        <a href="../../../include/access/htup.h.html#LN22"><span class='Ref_to_Typedef'>HeapTupleHeader</span></a> <span class='Declare_Local'>onpage_tup</span><span class='Delimiter'>; 
</span> 
        <a href="rewriteheap.c.html#LN729"><span class='Ref_To_Local'>newitemid</span></a> <span class='Operator'>= </span><a href="../../../include/storage/bufpage.h.html#LN231"><span class='Ref_to_Macro'>PageGetItemId</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN629"><span class='Ref_To_Local'>page</span></a><span class='Delimiter'>, </span><a href="rewriteheap.c.html#LN633"><span class='Ref_To_Local'>newoff</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="rewriteheap.c.html#LN730"><span class='Ref_To_Local'>onpage_tup</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/htup.h.html#LN22"><span class='Ref_to_Typedef'>HeapTupleHeader</span></a><span class='Parentheses'>) </span><a href="../../../include/storage/bufpage.h.html#LN336"><span class='Ref_to_Macro'>PageGetItem</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN629"><span class='Ref_To_Local'>page</span></a><span class='Delimiter'>, </span><a href="rewriteheap.c.html#LN729"><span class='Ref_To_Local'>newitemid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="rewriteheap.c.html#LN730"><span class='Ref_To_Local'>onpage_tup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup_details.h.html#LN149"><span class='Ref_to_Member'>t_ctid</span></a> <span class='Operator'>= </span><a href="rewriteheap.c.html#LN627"><span class='Ref_to_Parameter'>tup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN64"><span class='Ref_to_Member'>t_self</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* If heaptup is a private copy, release it. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN634"><span class='Ref_To_Local'>heaptup</span></a> <span class='Operator'>!= </span><a href="rewriteheap.c.html#LN627"><span class='Ref_to_Parameter'>tup</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/access/htup_details.h.html#LN815"><span class='Ref_to_Proto'>heap_freetuple</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN634"><span class='Ref_To_Local'>heaptup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end raw_heap_insert &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* ------------------------------------------------------------------------ 
 * Logical rewrite support 
 * 
 * When doing logical decoding - which relies on using cmin/cmax of catalog 
 * tuples, via xl_heap_new_cid records - heap rewrites have to log enough 
 * information to allow the decoding backend to updates its internal mapping 
 * of (relfilenode,ctid) =&GT; (cmin, cmax) to be correct for the rewritten heap. 
 * 
 * For that, every time we find a tuple that's been modified in a catalog 
 * relation within the xmin horizon of any decoding slot, we log a mapping 
 * from the old to the new location. 
 * 
 * To deal with rewrites that abort the filename of a mapping file contains 
 * the xid of the transaction performing the rewrite, which then can be 
 * checked before being read in. 
 * 
 * For efficiency we don't immediately spill every single map mapping for a 
 * row to disk but only do so in batches when we've collected several of them 
 * in memory or when end_heap_rewrite() has been called. 
 * 
 * Crash-Safety: This module diverts from the usual patterns of doing WAL 
 * since it cannot rely on checkpoint flushing out all buffers and thus 
 * waiting for exclusive locks on buffers. Usually the XLogInsert() covering 
 * buffer modifications is performed while the buffer(s) that are being 
 * modified are exclusively locked guaranteeing that both the WAL record and 
 * the modified heap are on either side of the checkpoint. But since the 
 * mapping files we log aren't in shared_buffers that interlock doesn't work. 
 * 
 * Instead we simply write the mapping files out to disk, *before* the 
 * XLogInsert() is performed. That guarantees that either the XLogInsert() is 
 * inserted after the checkpoint's redo pointer or that the checkpoint (via 
 * LogicalRewriteHeapCheckpoint()) has flushed the (partial) mapping file to 
 * disk. That leaves the tail end that has not yet been flushed open to 
 * corruption, which is solved by including the current offset in the 
 * xl_heap_rewrite_mapping records and truncating the mapping file to it 
 * during replay. Every time a rewrite is finished all generated mapping files 
 * are synced to disk. 
 * 
 * Note that if we were only concerned about crash safety we wouldn't have to 
 * deal with WAL logging at all - an fsync() at the end of a rewrite would be 
 * sufficient for crash safety. Any mapping that hasn't been safely flushed to 
 * disk has to be by an aborted (explicitly or via a crash) transaction and is 
 * ignored by virtue of the xid in its name being subject to a 
 * TransactionDidCommit() check. But we want to support having standbys via 
 * physical replication, both for availability and to do logical decoding 
 * there. 
 * ------------------------------------------------------------------------ 
 */ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Do preparations for logging logical mappings during a rewrite if 
 * necessary. If we detect that we don't need to log anything we'll prevent 
 * any further action by the various logical rewrite functions. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN798"></a><span class='Declare_Function'>logical_begin_heap_rewrite</span><span class='Parentheses'>(</span><a href="../../../include/access/rewriteheap.h.html#LN21"><span class='Ref_to_Typedef'>RewriteState</span></a> <span class='Declare_Parameter'>state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN800"></a>    <a href="../../../include/utils/hsearch.h.html#LN64"><span class='Ref_to_Struct'>HASHCTL</span></a>     <span class='Declare_Local'>hash_ctl</span><span class='Delimiter'>; 
</span><a name="LN801"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>logical_xmin</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We only need to persist these mappings if the rewritten table can be 
     * accessed during logical decoding, if not, we can skip doing any 
     * additional work. 
     */ 
</span>    <a href="rewriteheap.c.html#LN798"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN148"><span class='Ref_to_Member'>rs_logical_rewrite</span></a> <span class='Operator'>= 
</span>        <a href="../../../include/utils/rel.h.html#LN559"><span class='Ref_to_Macro'>RelationIsAccessibleInLogicalDecoding</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN798"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN142"><span class='Ref_to_Member'>rs_old_rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="rewriteheap.c.html#LN798"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN148"><span class='Ref_to_Member'>rs_logical_rewrite</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/procarray.h.html#LN124"><span class='Ref_to_Proto'>ProcArrayGetReplicationSlotXmin</span></a><span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN801"><span class='Ref_To_Local'>logical_xmin</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If there are no logical slots in progress we don't need to do anything, 
     * there cannot be any remappings for relevant rows yet. The relation's 
     * lock protects us against races. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN801"><span class='Ref_To_Local'>logical_xmin</span></a> <span class='Operator'>== </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="rewriteheap.c.html#LN798"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN148"><span class='Ref_to_Member'>rs_logical_rewrite</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="rewriteheap.c.html#LN798"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN153"><span class='Ref_to_Member'>rs_logical_xmin</span></a> <span class='Operator'>= </span><a href="rewriteheap.c.html#LN801"><span class='Ref_To_Local'>logical_xmin</span></a><span class='Delimiter'>; 
</span>    <a href="rewriteheap.c.html#LN798"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN159"><span class='Ref_to_Member'>rs_begin_lsn</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlog.h.html#LN248"><span class='Ref_to_Proto'>GetXLogInsertRecPtr</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="rewriteheap.c.html#LN798"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN163"><span class='Ref_to_Member'>rs_num_rewrite_mappings</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    memset<span class='Parentheses'>(</span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN800"><span class='Ref_To_Local'>hash_ctl</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN800"><span class='Ref_To_Local'>hash_ctl</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="rewriteheap.c.html#LN800"><span class='Ref_To_Local'>hash_ctl</span></a><span class='Operator'>.</span><a href="../../../include/utils/hsearch.h.html#LN71"><span class='Ref_to_Member'>keysize</span></a> <span class='Operator'>= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="rewriteheap.c.html#LN800"><span class='Ref_To_Local'>hash_ctl</span></a><span class='Operator'>.</span><a href="../../../include/utils/hsearch.h.html#LN72"><span class='Ref_to_Member'>entrysize</span></a> <span class='Operator'>= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../replication/logical/reorderbuffer.c.html#LN2995"><span class='Ref_to_Struct'>RewriteMappingFile</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="rewriteheap.c.html#LN800"><span class='Ref_To_Local'>hash_ctl</span></a><span class='Operator'>.</span><a href="../../../include/utils/hsearch.h.html#LN77"><span class='Ref_to_Member'>hcxt</span></a> <span class='Operator'>= </span><a href="rewriteheap.c.html#LN798"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN157"><span class='Ref_to_Member'>rs_cxt</span></a><span class='Delimiter'>; 
</span> 
    <a href="rewriteheap.c.html#LN798"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN162"><span class='Ref_to_Member'>rs_logical_mappings</span></a> <span class='Operator'>= 
</span>        <a href="../../../include/utils/hsearch.h.html#LN121"><span class='Ref_to_Proto'>hash_create</span></a><span class='Parentheses'>(</span><span class='String'>"Logical rewrite mapping"</span><span class='Delimiter'>, 
</span>                    <span class='Number'>128</span><span class='Delimiter'>,</span>        <span class='Comment_Single_Line'>/* arbitrary initial size */ 
</span>                    <span class='Operator'>&</span><a href="rewriteheap.c.html#LN800"><span class='Ref_To_Local'>hash_ctl</span></a><span class='Delimiter'>, 
</span>                    <a href="../../../include/utils/hsearch.h.html#LN86"><span class='Ref_to_Const'>HASH_ELEM</span></a> <span class='Operator'>| </span><a href="../../../include/utils/hsearch.h.html#LN87"><span class='Ref_to_Const'>HASH_BLOBS</span></a> <span class='Operator'>| </span><a href="../../../include/utils/hsearch.h.html#LN92"><span class='Ref_to_Const'>HASH_CONTEXT</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end logical_begin_heap_rewrite &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Flush all logical in-memory mappings to disk, but don't fsync them yet. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN847"></a><span class='Declare_Function'>logical_heap_rewrite_flush_mappings</span><span class='Parentheses'>(</span><a href="../../../include/access/rewriteheap.h.html#LN21"><span class='Ref_to_Typedef'>RewriteState</span></a> <span class='Declare_Parameter'>state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN849"></a>    <a href="../../../include/utils/hsearch.h.html#LN111"><span class='Ref_to_Typedef'>HASH_SEQ_STATUS</span></a> <span class='Declare_Local'>seq_status</span><span class='Delimiter'>; 
</span><a name="LN850"></a>    <a href="../../replication/logical/reorderbuffer.c.html#LN2995"><span class='Ref_to_Struct'>RewriteMappingFile</span></a> <span class='Operator'>*</span><span class='Declare_Local'>src</span><span class='Delimiter'>; 
</span><a name="LN851"></a>    <a href="../../../include/lib/ilist.h.html#LN177"><span class='Ref_to_Struct'>dlist_mutable_iter</span></a> <span class='Declare_Local'>iter</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN847"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN148"><span class='Ref_to_Member'>rs_logical_rewrite</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* no logical rewrite in progress, no need to iterate over mappings */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN847"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN163"><span class='Ref_to_Member'>rs_num_rewrite_mappings</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN24"><span class='Ref_to_Const'>DEBUG1</span></a><span class='Delimiter'>, </span><span class='String'>"flushing %u logical rewrite mapping entries"</span><span class='Delimiter'>, 
</span>         <a href="rewriteheap.c.html#LN847"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN163"><span class='Ref_to_Member'>rs_num_rewrite_mappings</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/hsearch.h.html#LN134"><span class='Ref_to_Proto'>hash_seq_init</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN849"><span class='Ref_To_Local'>seq_status</span></a><span class='Delimiter'>, </span><a href="rewriteheap.c.html#LN847"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN162"><span class='Ref_to_Member'>rs_logical_mappings</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>while</span> <span class='Parentheses'>((</span><a href="rewriteheap.c.html#LN850"><span class='Ref_To_Local'>src</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../replication/logical/reorderbuffer.c.html#LN2995"><span class='Ref_to_Struct'>RewriteMappingFile</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/utils/hsearch.h.html#LN135"><span class='Ref_to_Proto'>hash_seq_search</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN849"><span class='Ref_To_Local'>seq_status</span></a><span class='Parentheses'>))</span> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span><a name="LN865"></a>        <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>waldata</span><span class='Delimiter'>; 
</span><a name="LN866"></a>        <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>waldata_start</span><span class='Delimiter'>; 
</span><a name="LN867"></a>        <a href="../../../include/access/heapam_xlog.h.html#LN359"><span class='Ref_to_Struct'>xl_heap_rewrite_mapping</span></a> <span class='Declare_Local'>xlrec</span><span class='Delimiter'>; 
</span><a name="LN868"></a>        <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>dboid</span><span class='Delimiter'>; 
</span><a name="LN869"></a>        <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>len</span><span class='Delimiter'>; 
</span><a name="LN870"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>written</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* this file hasn't got any new mappings */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN850"><span class='Ref_To_Local'>src</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN207"><span class='Ref_to_Member'>num_mappings</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN847"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN142"><span class='Ref_to_Member'>rs_old_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relisshared<span class='Parentheses'>) 
</span>            <a href="rewriteheap.c.html#LN868"><span class='Ref_To_Local'>dboid</span></a> <span class='Operator'>= </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="rewriteheap.c.html#LN868"><span class='Ref_To_Local'>dboid</span></a> <span class='Operator'>= </span><a href="../../utils/init/globals.c.html#LN76"><span class='Ref_to_Global_Var'>MyDatabaseId</span></a><span class='Delimiter'>; 
</span> 
        <a href="rewriteheap.c.html#LN867"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>.</span><a href="../../../include/access/heapam_xlog.h.html#LN365"><span class='Ref_to_Member'>num_mappings</span></a> <span class='Operator'>= </span><a href="rewriteheap.c.html#LN850"><span class='Ref_To_Local'>src</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN207"><span class='Ref_to_Member'>num_mappings</span></a><span class='Delimiter'>; 
</span>        <a href="rewriteheap.c.html#LN867"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>.</span><a href="../../../include/access/heapam_xlog.h.html#LN363"><span class='Ref_to_Member'>mapped_rel</span></a> <span class='Operator'>= </span><a href="../../../include/utils/rel.h.html#LN416"><span class='Ref_to_Macro'>RelationGetRelid</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN847"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN142"><span class='Ref_to_Member'>rs_old_rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="rewriteheap.c.html#LN867"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>.</span><a href="../../../include/access/heapam_xlog.h.html#LN361"><span class='Ref_to_Member'>mapped_xid</span></a> <span class='Operator'>= </span><a href="rewriteheap.c.html#LN850"><span class='Ref_To_Local'>src</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN204"><span class='Ref_to_Member'>xid</span></a><span class='Delimiter'>; 
</span>        <a href="rewriteheap.c.html#LN867"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>.</span><a href="../../../include/access/heapam_xlog.h.html#LN362"><span class='Ref_to_Member'>mapped_db</span></a> <span class='Operator'>= </span><a href="rewriteheap.c.html#LN868"><span class='Ref_To_Local'>dboid</span></a><span class='Delimiter'>; 
</span>        <a href="rewriteheap.c.html#LN867"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>.</span><a href="../../../include/access/heapam_xlog.h.html#LN364"><span class='Ref_to_Member'>offset</span></a> <span class='Operator'>= </span><a href="rewriteheap.c.html#LN850"><span class='Ref_To_Local'>src</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN206"><span class='Ref_to_Member'>off</span></a><span class='Delimiter'>; 
</span>        <a href="rewriteheap.c.html#LN867"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>.</span><a href="../../../include/access/heapam_xlog.h.html#LN366"><span class='Ref_to_Member'>start_lsn</span></a> <span class='Operator'>= </span><a href="rewriteheap.c.html#LN847"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN159"><span class='Ref_to_Member'>rs_begin_lsn</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* write all mappings consecutively */ 
</span>        <a href="rewriteheap.c.html#LN869"><span class='Ref_To_Local'>len</span></a> <span class='Operator'>= </span><a href="rewriteheap.c.html#LN850"><span class='Ref_To_Local'>src</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN207"><span class='Ref_to_Member'>num_mappings</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/access/rewriteheap.h.html#LN34"><span class='Ref_to_Struct'>LogicalRewriteMappingData</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="rewriteheap.c.html#LN866"><span class='Ref_To_Local'>waldata_start</span></a> <span class='Operator'>= </span><a href="rewriteheap.c.html#LN865"><span class='Ref_To_Local'>waldata</span></a> <span class='Operator'>= </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN869"><span class='Ref_To_Local'>len</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * collect data we need to write out, but don't modify ondisk data yet 
         */ 
</span>        <a href="../../../include/lib/ilist.h.html#LN523"><span class='Ref_to_Macro'>dlist_foreach_modify</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN851"><span class='Ref_To_Local'>iter</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN850"><span class='Ref_To_Local'>src</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN208"><span class='Ref_to_Member'>mappings</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN897"></a>            <a href="rewriteheap.c.html#LN216"><span class='Ref_to_Struct'>RewriteMappingDataEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>pmap</span><span class='Delimiter'>; 
</span> 
            <a href="rewriteheap.c.html#LN897"><span class='Ref_To_Local'>pmap</span></a> <span class='Operator'>= </span><a href="../../../include/lib/ilist.h.html#LN476"><span class='Ref_to_Macro'>dlist_container</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN216"><span class='Ref_to_Struct'>RewriteMappingDataEntry</span></a><span class='Delimiter'>, </span><a href="../../replication/repl_gram.y.html#LN52"><span class='Ref_to_Global_Var'>node</span></a><span class='Delimiter'>, </span><a href="rewriteheap.c.html#LN851"><span class='Ref_To_Local'>iter</span></a><span class='Operator'>.</span><a href="../../../include/lib/ilist.h.html#LN179"><span class='Ref_to_Member'>cur</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            memcpy<span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN865"><span class='Ref_To_Local'>waldata</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN897"><span class='Ref_To_Local'>pmap</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN218"><span class='Ref_to_Member'>map</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN897"><span class='Ref_To_Local'>pmap</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN218"><span class='Ref_to_Member'>map</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="rewriteheap.c.html#LN865"><span class='Ref_To_Local'>waldata</span></a> <span class='Operator'>+= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN897"><span class='Ref_To_Local'>pmap</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN218"><span class='Ref_to_Member'>map</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* remove from the list and free */ 
</span>            <a href="../../../include/lib/ilist.h.html#LN356"><span class='Ref_to_Func'>dlist_delete</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN897"><span class='Ref_To_Local'>pmap</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN220"><span class='Ref_to_Member'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN897"><span class='Ref_To_Local'>pmap</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* update bookkeeping */ 
</span>            <a href="rewriteheap.c.html#LN847"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN163"><span class='Ref_to_Member'>rs_num_rewrite_mappings</span></a><span class='Operator'>--</span><span class='Delimiter'>; 
</span>            <a href="rewriteheap.c.html#LN850"><span class='Ref_To_Local'>src</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN207"><span class='Ref_to_Member'>num_mappings</span></a><span class='Operator'>--</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN850"><span class='Ref_To_Local'>src</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN207"><span class='Ref_to_Member'>num_mappings</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN865"><span class='Ref_To_Local'>waldata</span></a> <span class='Operator'>== </span><a href="rewriteheap.c.html#LN866"><span class='Ref_To_Local'>waldata_start</span></a> <span class='Operator'>+ </span><a href="rewriteheap.c.html#LN869"><span class='Ref_To_Local'>len</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Note that we deviate from the usual WAL coding practices here, 
         * check the above "Logical rewrite support" comment for reasoning. 
         */ 
</span>        <a href="rewriteheap.c.html#LN870"><span class='Ref_To_Local'>written</span></a> <span class='Operator'>= </span><a href="../../../include/storage/fd.h.html#LN72"><span class='Ref_to_Proto'>FileWrite</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN850"><span class='Ref_To_Local'>src</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN205"><span class='Ref_to_Member'>vfd</span></a><span class='Delimiter'>, </span><a href="rewriteheap.c.html#LN866"><span class='Ref_To_Local'>waldata_start</span></a><span class='Delimiter'>, </span><a href="rewriteheap.c.html#LN869"><span class='Ref_To_Local'>len</span></a><span class='Delimiter'>, 
</span>                            <a href="../../../include/pgstat.h.html#LN868"><span class='Ref_to_EnumConst'>WAIT_EVENT_LOGICAL_REWRITE_WRITE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN870"><span class='Ref_To_Local'>written</span></a> <span class='Operator'>!= </span><a href="rewriteheap.c.html#LN869"><span class='Ref_To_Local'>len</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                     <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not write to file \"%s\", wrote %d of %d: %m"</span><span class='Delimiter'>, </span><a href="rewriteheap.c.html#LN850"><span class='Ref_To_Local'>src</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN209"><span class='Ref_to_Member'>path</span></a><span class='Delimiter'>, 
</span>                            <a href="rewriteheap.c.html#LN870"><span class='Ref_To_Local'>written</span></a><span class='Delimiter'>, </span><a href="rewriteheap.c.html#LN869"><span class='Ref_To_Local'>len</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <a href="rewriteheap.c.html#LN850"><span class='Ref_To_Local'>src</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN206"><span class='Ref_to_Member'>off</span></a> <span class='Operator'>+= </span><a href="rewriteheap.c.html#LN869"><span class='Ref_To_Local'>len</span></a><span class='Delimiter'>; 
</span> 
        <a href="../../../include/access/xloginsert.h.html#LN41"><span class='Ref_to_Proto'>XLogBeginInsert</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <a href="../../../include/access/xloginsert.h.html#LN45"><span class='Ref_to_Proto'>XLogRegisterData</span></a><span class='Parentheses'>((</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) (</span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN867"><span class='Ref_To_Local'>xlrec</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN867"><span class='Ref_To_Local'>xlrec</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="../../../include/access/xloginsert.h.html#LN45"><span class='Ref_to_Proto'>XLogRegisterData</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN866"><span class='Ref_To_Local'>waldata_start</span></a><span class='Delimiter'>, </span><a href="rewriteheap.c.html#LN869"><span class='Ref_To_Local'>len</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* write xlog record */ 
</span>        <a href="../../../include/access/xloginsert.h.html#LN43"><span class='Ref_to_Proto'>XLogInsert</span></a><span class='Parentheses'>(</span>RM_HEAP2_ID<span class='Delimiter'>, </span><a href="../../../include/access/heapam_xlog.h.html#LN52"><span class='Ref_to_Const'>XLOG_HEAP2_REWRITE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN866"><span class='Ref_To_Local'>waldata_start</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while (src=(RewriteMappingF... &raquo; </span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN847"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN163"><span class='Ref_to_Member'>rs_num_rewrite_mappings</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end logical_heap_rewrite_flush_mappings &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Logical remapping part of end_heap_rewrite(). 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN945"></a><span class='Declare_Function'>logical_end_heap_rewrite</span><span class='Parentheses'>(</span><a href="../../../include/access/rewriteheap.h.html#LN21"><span class='Ref_to_Typedef'>RewriteState</span></a> <span class='Declare_Parameter'>state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN947"></a>    <a href="../../../include/utils/hsearch.h.html#LN111"><span class='Ref_to_Typedef'>HASH_SEQ_STATUS</span></a> <span class='Declare_Local'>seq_status</span><span class='Delimiter'>; 
</span><a name="LN948"></a>    <a href="../../replication/logical/reorderbuffer.c.html#LN2995"><span class='Ref_to_Struct'>RewriteMappingFile</span></a> <span class='Operator'>*</span><span class='Declare_Local'>src</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* done, no logical rewrite in progress */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="rewriteheap.c.html#LN945"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN148"><span class='Ref_to_Member'>rs_logical_rewrite</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* writeout remaining in-memory entries */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN945"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN163"><span class='Ref_to_Member'>rs_num_rewrite_mappings</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="rewriteheap.c.html#LN846"><span class='Ref_to_Func'>logical_heap_rewrite_flush_mappings</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN945"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Iterate over all mappings we have written and fsync the files. */ 
</span>    <a href="../../../include/utils/hsearch.h.html#LN134"><span class='Ref_to_Proto'>hash_seq_init</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN947"><span class='Ref_To_Local'>seq_status</span></a><span class='Delimiter'>, </span><a href="rewriteheap.c.html#LN945"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN162"><span class='Ref_to_Member'>rs_logical_mappings</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>while</span> <span class='Parentheses'>((</span><a href="rewriteheap.c.html#LN948"><span class='Ref_To_Local'>src</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../replication/logical/reorderbuffer.c.html#LN2995"><span class='Ref_to_Struct'>RewriteMappingFile</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/utils/hsearch.h.html#LN135"><span class='Ref_to_Proto'>hash_seq_search</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN947"><span class='Ref_To_Local'>seq_status</span></a><span class='Parentheses'>))</span> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/fd.h.html#LN73"><span class='Ref_to_Proto'>FileSync</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN948"><span class='Ref_To_Local'>src</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN205"><span class='Ref_to_Member'>vfd</span></a><span class='Delimiter'>, </span><a href="../../../include/pgstat.h.html#LN866"><span class='Ref_to_EnumConst'>WAIT_EVENT_LOGICAL_REWRITE_SYNC</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                     <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not fsync file \"%s\": %m"</span><span class='Delimiter'>, </span><a href="rewriteheap.c.html#LN948"><span class='Ref_To_Local'>src</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN209"><span class='Ref_to_Member'>path</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/fd.h.html#LN69"><span class='Ref_to_Proto'>FileClose</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN948"><span class='Ref_To_Local'>src</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN205"><span class='Ref_to_Member'>vfd</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Comment_Multi_Line'>/* memory context cleanup will deal with the rest */ 
</span><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end logical_end_heap_rewrite &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Log a single (old-&GT;new) mapping for 'xid'. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN975"></a><span class='Declare_Function'>logical_rewrite_log_mapping</span><span class='Parentheses'>(</span><a href="../../../include/access/rewriteheap.h.html#LN21"><span class='Ref_to_Typedef'>RewriteState</span></a> <span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>xid</span><span class='Delimiter'>, 
</span><a name="LN976"></a>                            <a href="../../../include/access/rewriteheap.h.html#LN34"><span class='Ref_to_Struct'>LogicalRewriteMappingData</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>map</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN978"></a>    <a href="../../replication/logical/reorderbuffer.c.html#LN2995"><span class='Ref_to_Struct'>RewriteMappingFile</span></a> <span class='Operator'>*</span><span class='Declare_Local'>src</span><span class='Delimiter'>; 
</span><a name="LN979"></a>    <a href="rewriteheap.c.html#LN216"><span class='Ref_to_Struct'>RewriteMappingDataEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>pmap</span><span class='Delimiter'>; 
</span><a name="LN980"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>relid</span><span class='Delimiter'>; 
</span><a name="LN981"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>found</span><span class='Delimiter'>; 
</span> 
    <a href="rewriteheap.c.html#LN980"><span class='Ref_To_Local'>relid</span></a> <span class='Operator'>= </span><a href="../../../include/utils/rel.h.html#LN416"><span class='Ref_to_Macro'>RelationGetRelid</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN975"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN142"><span class='Ref_to_Member'>rs_old_rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* look for existing mappings for this 'mapped' xid */ 
</span>    <a href="rewriteheap.c.html#LN978"><span class='Ref_To_Local'>src</span></a> <span class='Operator'>= </span><a href="../../../include/utils/hsearch.h.html#LN125"><span class='Ref_to_Proto'>hash_search</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN975"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN162"><span class='Ref_to_Member'>rs_logical_mappings</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN975"><span class='Ref_to_Parameter'>xid</span></a><span class='Delimiter'>, 
</span>                      <a href="../../../include/utils/hsearch.h.html#LN105"><span class='Ref_to_EnumConst'>HASH_ENTER</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN981"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We haven't yet had the need to map anything for this xid, create 
     * per-xid data structures. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="rewriteheap.c.html#LN981"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN995"></a>        <span class='Keyword'>char</span>        <span class='Declare_Local'>path</span><span class='Delimiter'>[</span><a href="../../../include/pg_config_manual.h.html#LN88"><span class='Ref_to_Const'>MAXPGPATH</span></a><span class='Delimiter'>]; 
</span><a name="LN996"></a>        <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>dboid</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN975"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN142"><span class='Ref_to_Member'>rs_old_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relisshared<span class='Parentheses'>) 
</span>            <a href="rewriteheap.c.html#LN996"><span class='Ref_To_Local'>dboid</span></a> <span class='Operator'>= </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="rewriteheap.c.html#LN996"><span class='Ref_To_Local'>dboid</span></a> <span class='Operator'>= </span><a href="../../utils/init/globals.c.html#LN76"><span class='Ref_to_Global_Var'>MyDatabaseId</span></a><span class='Delimiter'>; 
</span> 
        <a href="../../../pl/plperl/plperl.h.html#LN60"><span class='Ref_to_Macro'>snprintf</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN995"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, </span><a href="../../../include/pg_config_manual.h.html#LN88"><span class='Ref_to_Const'>MAXPGPATH</span></a><span class='Delimiter'>, 
</span>                 <span class='String'>"pg_logical/mappings/"</span> <a href="../../../include/access/rewriteheap.h.html#LN53"><span class='Ref_to_Const'>LOGICAL_REWRITE_FORMAT</span></a><span class='Delimiter'>, 
</span>                 <a href="rewriteheap.c.html#LN996"><span class='Ref_To_Local'>dboid</span></a><span class='Delimiter'>, </span><a href="rewriteheap.c.html#LN980"><span class='Ref_To_Local'>relid</span></a><span class='Delimiter'>, 
</span>                 <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="rewriteheap.c.html#LN975"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN159"><span class='Ref_to_Member'>rs_begin_lsn</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="rewriteheap.c.html#LN975"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN159"><span class='Ref_to_Member'>rs_begin_lsn</span></a><span class='Delimiter'>, 
</span>                 <a href="rewriteheap.c.html#LN975"><span class='Ref_to_Parameter'>xid</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xact.h.html#LN333"><span class='Ref_to_Proto'>GetCurrentTransactionId</span></a><span class='Parentheses'>())</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/lib/ilist.h.html#LN276"><span class='Ref_to_Func'>dlist_init</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN978"><span class='Ref_To_Local'>src</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN208"><span class='Ref_to_Member'>mappings</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="rewriteheap.c.html#LN978"><span class='Ref_To_Local'>src</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN207"><span class='Ref_to_Member'>num_mappings</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="rewriteheap.c.html#LN978"><span class='Ref_To_Local'>src</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN206"><span class='Ref_to_Member'>off</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        memcpy<span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN978"><span class='Ref_To_Local'>src</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN209"><span class='Ref_to_Member'>path</span></a><span class='Delimiter'>, </span><a href="rewriteheap.c.html#LN995"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN995"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="rewriteheap.c.html#LN978"><span class='Ref_To_Local'>src</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN205"><span class='Ref_to_Member'>vfd</span></a> <span class='Operator'>= </span><a href="../../../include/storage/fd.h.html#LN67"><span class='Ref_to_Proto'>PathNameOpenFile</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN995"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, 
</span>                                    O_CREAT <span class='Operator'>| </span>O_EXCL <span class='Operator'>| </span>O_WRONLY <span class='Operator'>| </span><a href="../../../include/c.h.html#LN1032"><span class='Ref_to_Const'>PG_BINARY</span></a><span class='Delimiter'>, 
</span>                                    <a href="../../../include/port/win32.h.html#LN424"><span class='Ref_to_Const'>S_IRUSR</span></a> <span class='Operator'>| </span><a href="../../../include/port/win32.h.html#LN425"><span class='Ref_to_Const'>S_IWUSR</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN978"><span class='Ref_To_Local'>src</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN205"><span class='Ref_to_Member'>vfd</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                     <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not create file \"%s\": %m"</span><span class='Delimiter'>, </span><a href="rewriteheap.c.html#LN995"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !found &raquo; </span> 
 
    <a href="rewriteheap.c.html#LN979"><span class='Ref_To_Local'>pmap</span></a> <span class='Operator'>= </span><a href="../../../include/utils/palloc.h.html#LN70"><span class='Ref_to_Proto'>MemoryContextAlloc</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN975"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN157"><span class='Ref_to_Member'>rs_cxt</span></a><span class='Delimiter'>, 
</span>                              <span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN216"><span class='Ref_to_Struct'>RewriteMappingDataEntry</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    memcpy<span class='Parentheses'>(</span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN979"><span class='Ref_To_Local'>pmap</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN218"><span class='Ref_to_Member'>map</span></a><span class='Delimiter'>, </span><a href="rewriteheap.c.html#LN976"><span class='Ref_to_Parameter'>map</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/access/rewriteheap.h.html#LN34"><span class='Ref_to_Struct'>LogicalRewriteMappingData</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/lib/ilist.h.html#LN315"><span class='Ref_to_Func'>dlist_push_tail</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN978"><span class='Ref_To_Local'>src</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN208"><span class='Ref_to_Member'>mappings</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN979"><span class='Ref_To_Local'>pmap</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN220"><span class='Ref_to_Member'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="rewriteheap.c.html#LN978"><span class='Ref_To_Local'>src</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN207"><span class='Ref_to_Member'>num_mappings</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <a href="rewriteheap.c.html#LN975"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN163"><span class='Ref_to_Member'>rs_num_rewrite_mappings</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Write out buffer every time we've too many in-memory entries across all 
     * mapping files. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN975"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN163"><span class='Ref_to_Member'>rs_num_rewrite_mappings</span></a> <span class='Operator'>&GT;= </span><span class='Number'>1000</span> <span class='Comment_Multi_Line'>/* arbitrary number */ </span><span class='Parentheses'>) 
</span>        <a href="rewriteheap.c.html#LN846"><span class='Ref_to_Func'>logical_heap_rewrite_flush_mappings</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN975"><span class='Ref_to_Parameter'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end logical_rewrite_log_mapping &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Perform logical remapping for a tuple that's mapped from old_tid to 
 * new_tuple-&GT;t_self by rewrite_heap_tuple() if necessary for the tuple. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1043"></a><span class='Declare_Function'>logical_rewrite_heap_tuple</span><span class='Parentheses'>(</span><a href="../../../include/access/rewriteheap.h.html#LN21"><span class='Ref_to_Typedef'>RewriteState</span></a> <span class='Declare_Parameter'>state</span><span class='Delimiter'>, </span><a href="../../../include/storage/itemptr.h.html#LN35"><span class='Ref_to_Struct'>ItemPointerData</span></a> <span class='Declare_Parameter'>old_tid</span><span class='Delimiter'>, 
</span><a name="LN1044"></a>                           <a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a> <span class='Declare_Parameter'>new_tuple</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1046"></a>    <a href="../../../include/storage/itemptr.h.html#LN35"><span class='Ref_to_Struct'>ItemPointerData</span></a> <span class='Declare_Local'>new_tid</span> <span class='Operator'>= </span><a href="rewriteheap.c.html#LN1044"><span class='Ref_to_Parameter'>new_tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN64"><span class='Ref_to_Member'>t_self</span></a><span class='Delimiter'>; 
</span><a name="LN1047"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>cutoff</span> <span class='Operator'>= </span><a href="rewriteheap.c.html#LN1043"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN153"><span class='Ref_to_Member'>rs_logical_xmin</span></a><span class='Delimiter'>; 
</span><a name="LN1048"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>xmin</span><span class='Delimiter'>; 
</span><a name="LN1049"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>xmax</span><span class='Delimiter'>; 
</span><a name="LN1050"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>do_log_xmin</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN1051"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>do_log_xmax</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN1052"></a>    <a href="../../../include/access/rewriteheap.h.html#LN34"><span class='Ref_to_Struct'>LogicalRewriteMappingData</span></a> <span class='Declare_Local'>map</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* no logical rewrite in progress, we don't need to log anything */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="rewriteheap.c.html#LN1043"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN148"><span class='Ref_to_Member'>rs_logical_rewrite</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <a href="rewriteheap.c.html#LN1048"><span class='Ref_To_Local'>xmin</span></a> <span class='Operator'>= </span><a href="../../../include/access/htup_details.h.html#LN306"><span class='Ref_to_Macro'>HeapTupleHeaderGetXmin</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN1044"><span class='Ref_to_Parameter'>new_tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN66"><span class='Ref_to_Member'>t_data</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* use *GetUpdateXid to correctly deal with multixacts */ 
</span>    <a href="rewriteheap.c.html#LN1049"><span class='Ref_To_Local'>xmax</span></a> <span class='Operator'>= </span><a href="../../../include/access/htup_details.h.html#LN358"><span class='Ref_to_Macro'>HeapTupleHeaderGetUpdateXid</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN1044"><span class='Ref_to_Parameter'>new_tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN66"><span class='Ref_to_Member'>t_data</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Log the mapping iff the tuple has been created recently. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN1048"><span class='Ref_To_Local'>xmin</span></a><span class='Parentheses'>) </span><span class='Operator'>&& !</span><a href="../../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN1048"><span class='Ref_To_Local'>xmin</span></a><span class='Delimiter'>, </span><a href="rewriteheap.c.html#LN1047"><span class='Ref_To_Local'>cutoff</span></a><span class='Parentheses'>))</span> 
        <a href="rewriteheap.c.html#LN1050"><span class='Ref_To_Local'>do_log_xmin</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN1049"><span class='Ref_To_Local'>xmax</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * no xmax is set, can't have any permanent ones, so this check is 
         * sufficient 
         */ 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/htup_details.h.html#LN215"><span class='Ref_to_Macro'>HEAP_XMAX_IS_LOCKED_ONLY</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN1044"><span class='Ref_to_Parameter'>new_tuple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN66"><span class='Ref_to_Member'>t_data</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup_details.h.html#LN156"><span class='Ref_to_Member'>t_infomask</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* only locked, we don't care */ 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN1049"><span class='Ref_To_Local'>xmax</span></a><span class='Delimiter'>, </span><a href="rewriteheap.c.html#LN1047"><span class='Ref_To_Local'>cutoff</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* tuple has been deleted recently, log */ 
</span>        <a href="rewriteheap.c.html#LN1051"><span class='Ref_To_Local'>do_log_xmax</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* if neither needs to be logged, we're done */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="rewriteheap.c.html#LN1050"><span class='Ref_To_Local'>do_log_xmin</span></a> <span class='Operator'>&& !</span><a href="rewriteheap.c.html#LN1051"><span class='Ref_To_Local'>do_log_xmax</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* fill out mapping information */ 
</span>    <a href="rewriteheap.c.html#LN1052"><span class='Ref_To_Local'>map</span></a><span class='Operator'>.</span><a href="../../../include/access/rewriteheap.h.html#LN36"><span class='Ref_to_Member'>old_node</span></a> <span class='Operator'>= </span><a href="rewriteheap.c.html#LN1043"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN142"><span class='Ref_to_Member'>rs_old_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN84"><span class='Ref_to_Member'>rd_node</span></a><span class='Delimiter'>; 
</span>    <a href="rewriteheap.c.html#LN1052"><span class='Ref_To_Local'>map</span></a><span class='Operator'>.</span><a href="../../../include/access/rewriteheap.h.html#LN38"><span class='Ref_to_Member'>old_tid</span></a> <span class='Operator'>= </span><a href="rewriteheap.c.html#LN1043"><span class='Ref_to_Parameter'>old_tid</span></a><span class='Delimiter'>; 
</span>    <a href="rewriteheap.c.html#LN1052"><span class='Ref_To_Local'>map</span></a><span class='Operator'>.</span><a href="../../../include/access/rewriteheap.h.html#LN37"><span class='Ref_to_Member'>new_node</span></a> <span class='Operator'>= </span><a href="rewriteheap.c.html#LN1043"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="rewriteheap.c.html#LN143"><span class='Ref_to_Member'>rs_new_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN84"><span class='Ref_to_Member'>rd_node</span></a><span class='Delimiter'>; 
</span>    <a href="rewriteheap.c.html#LN1052"><span class='Ref_To_Local'>map</span></a><span class='Operator'>.</span><a href="../../../include/access/rewriteheap.h.html#LN39"><span class='Ref_to_Member'>new_tid</span></a> <span class='Operator'>= </span><a href="rewriteheap.c.html#LN1046"><span class='Ref_To_Local'>new_tid</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* --- 
     * Now persist the mapping for the individual xids that are affected. We 
     * need to log for both xmin and xmax if they aren't the same transaction 
     * since the mapping files are per "affected" xid. 
     * We don't muster all that much effort detecting whether xmin and xmax 
     * are actually the same transaction, we just check whether the xid is the 
     * same disregarding subtransactions. Logging too much is relatively 
     * harmless and we could never do the check fully since subtransaction 
     * data is thrown away during restarts. 
     * --- 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN1050"><span class='Ref_To_Local'>do_log_xmin</span></a><span class='Parentheses'>) 
</span>        <a href="rewriteheap.c.html#LN974"><span class='Ref_to_Func'>logical_rewrite_log_mapping</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN1043"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="rewriteheap.c.html#LN1048"><span class='Ref_To_Local'>xmin</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN1052"><span class='Ref_To_Local'>map</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* separately log mapping for xmax unless it'd be redundant */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN1051"><span class='Ref_To_Local'>do_log_xmax</span></a> <span class='Operator'>&& !</span><a href="../../../include/access/transam.h.html#LN42"><span class='Ref_to_Macro'>TransactionIdEquals</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN1048"><span class='Ref_To_Local'>xmin</span></a><span class='Delimiter'>, </span><a href="rewriteheap.c.html#LN1049"><span class='Ref_To_Local'>xmax</span></a><span class='Parentheses'>))</span> 
        <a href="rewriteheap.c.html#LN974"><span class='Ref_to_Func'>logical_rewrite_log_mapping</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN1043"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>, </span><a href="rewriteheap.c.html#LN1049"><span class='Ref_To_Local'>xmax</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN1052"><span class='Ref_To_Local'>map</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end logical_rewrite_heap_tuple &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Replay XLOG_HEAP2_REWRITE records 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1117"></a><span class='Declare_Function'>heap_xlog_logical_rewrite</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogreader.h.html#LN68"><span class='Ref_to_Struct'>XLogReaderState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>r</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1119"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>path</span><span class='Delimiter'>[</span><a href="../../../include/pg_config_manual.h.html#LN88"><span class='Ref_to_Const'>MAXPGPATH</span></a><span class='Delimiter'>]; 
</span><a name="LN1120"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>fd</span><span class='Delimiter'>; 
</span><a name="LN1121"></a>    <a href="../../../include/access/heapam_xlog.h.html#LN359"><span class='Ref_to_Struct'>xl_heap_rewrite_mapping</span></a> <span class='Operator'>*</span><span class='Declare_Local'>xlrec</span><span class='Delimiter'>; 
</span><a name="LN1122"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>len</span><span class='Delimiter'>; 
</span><a name="LN1123"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>data</span><span class='Delimiter'>; 
</span> 
    <a href="rewriteheap.c.html#LN1121"><span class='Ref_To_Local'>xlrec</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/heapam_xlog.h.html#LN359"><span class='Ref_to_Struct'>xl_heap_rewrite_mapping</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/access/xlogreader.h.html#LN219"><span class='Ref_to_Macro'>XLogRecGetData</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN1117"><span class='Ref_to_Parameter'>r</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../pl/plperl/plperl.h.html#LN60"><span class='Ref_to_Macro'>snprintf</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN1119"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, </span><a href="../../../include/pg_config_manual.h.html#LN88"><span class='Ref_to_Const'>MAXPGPATH</span></a><span class='Delimiter'>, 
</span>             <span class='String'>"pg_logical/mappings/"</span> <a href="../../../include/access/rewriteheap.h.html#LN53"><span class='Ref_to_Const'>LOGICAL_REWRITE_FORMAT</span></a><span class='Delimiter'>, 
</span>             <a href="rewriteheap.c.html#LN1121"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/heapam_xlog.h.html#LN362"><span class='Ref_to_Member'>mapped_db</span></a><span class='Delimiter'>, </span><a href="rewriteheap.c.html#LN1121"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/heapam_xlog.h.html#LN363"><span class='Ref_to_Member'>mapped_rel</span></a><span class='Delimiter'>, 
</span>             <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="rewriteheap.c.html#LN1121"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/heapam_xlog.h.html#LN366"><span class='Ref_to_Member'>start_lsn</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>             <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="rewriteheap.c.html#LN1121"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/heapam_xlog.h.html#LN366"><span class='Ref_to_Member'>start_lsn</span></a><span class='Delimiter'>, 
</span>             <a href="rewriteheap.c.html#LN1121"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/heapam_xlog.h.html#LN361"><span class='Ref_to_Member'>mapped_xid</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xlogreader.h.html#LN217"><span class='Ref_to_Macro'>XLogRecGetXid</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN1117"><span class='Ref_to_Parameter'>r</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="rewriteheap.c.html#LN1120"><span class='Ref_To_Local'>fd</span></a> <span class='Operator'>= </span><a href="../../../include/storage/fd.h.html#LN96"><span class='Ref_to_Proto'>OpenTransientFile</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN1119"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, 
</span>                           O_CREAT <span class='Operator'>| </span>O_WRONLY <span class='Operator'>| </span><a href="../../../include/c.h.html#LN1032"><span class='Ref_to_Const'>PG_BINARY</span></a><span class='Delimiter'>, 
</span>                           <a href="../../../include/port/win32.h.html#LN424"><span class='Ref_to_Const'>S_IRUSR</span></a> <span class='Operator'>| </span><a href="../../../include/port/win32.h.html#LN425"><span class='Ref_to_Const'>S_IWUSR</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN1120"><span class='Ref_To_Local'>fd</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not create file \"%s\": %m"</span><span class='Delimiter'>, </span><a href="rewriteheap.c.html#LN1119"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Truncate all data that's not guaranteed to have been safely fsynced (by 
     * previous record or by the last checkpoint). 
     */ 
</span>    <a href="../../../include/pgstat.h.html#LN1206"><span class='Ref_to_Func'>pgstat_report_wait_start</span></a><span class='Parentheses'>(</span><a href="../../../include/pgstat.h.html#LN867"><span class='Ref_to_EnumConst'>WAIT_EVENT_LOGICAL_REWRITE_TRUNCATE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/port/win32.h.html#LN58"><span class='Ref_to_Macro'>ftruncate</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN1120"><span class='Ref_To_Local'>fd</span></a><span class='Delimiter'>, </span><a href="rewriteheap.c.html#LN1121"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/heapam_xlog.h.html#LN364"><span class='Ref_to_Member'>offset</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not truncate file \"%s\" to %u: %m"</span><span class='Delimiter'>, 
</span>                        <a href="rewriteheap.c.html#LN1119"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="rewriteheap.c.html#LN1121"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/heapam_xlog.h.html#LN364"><span class='Ref_to_Member'>offset</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/pgstat.h.html#LN1230"><span class='Ref_to_Func'>pgstat_report_wait_end</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* now seek to the position we want to write our data to */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span>lseek<span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN1120"><span class='Ref_To_Local'>fd</span></a><span class='Delimiter'>, </span><a href="rewriteheap.c.html#LN1121"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/heapam_xlog.h.html#LN364"><span class='Ref_to_Member'>offset</span></a><span class='Delimiter'>, </span>SEEK_SET<span class='Parentheses'>) </span><span class='Operator'>!= </span><a href="rewriteheap.c.html#LN1121"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/heapam_xlog.h.html#LN364"><span class='Ref_to_Member'>offset</span></a><span class='Parentheses'>)</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not seek to end of file \"%s\": %m"</span><span class='Delimiter'>, 
</span>                        <a href="rewriteheap.c.html#LN1119"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <a href="rewriteheap.c.html#LN1123"><span class='Ref_To_Local'>data</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlogreader.h.html#LN219"><span class='Ref_to_Macro'>XLogRecGetData</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN1117"><span class='Ref_to_Parameter'>r</span></a><span class='Parentheses'>) </span><span class='Operator'>+ </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="rewriteheap.c.html#LN1121"><span class='Ref_To_Local'>xlrec</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="rewriteheap.c.html#LN1122"><span class='Ref_To_Local'>len</span></a> <span class='Operator'>= </span><a href="rewriteheap.c.html#LN1121"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/heapam_xlog.h.html#LN365"><span class='Ref_to_Member'>num_mappings</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/access/rewriteheap.h.html#LN34"><span class='Ref_to_Struct'>LogicalRewriteMappingData</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* write out tail end of mapping file (again) */ 
</span>    <a href="../../../include/pgstat.h.html#LN1206"><span class='Ref_to_Func'>pgstat_report_wait_start</span></a><span class='Parentheses'>(</span><a href="../../../include/pgstat.h.html#LN865"><span class='Ref_to_EnumConst'>WAIT_EVENT_LOGICAL_REWRITE_MAPPING_WRITE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../interfaces/libpq/win32.h.html#LN13"><span class='Ref_to_Macro'>write</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN1120"><span class='Ref_To_Local'>fd</span></a><span class='Delimiter'>, </span><a href="rewriteheap.c.html#LN1123"><span class='Ref_To_Local'>data</span></a><span class='Delimiter'>, </span><a href="rewriteheap.c.html#LN1122"><span class='Ref_To_Local'>len</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><a href="rewriteheap.c.html#LN1122"><span class='Ref_To_Local'>len</span></a><span class='Parentheses'>)</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not write to file \"%s\": %m"</span><span class='Delimiter'>, </span><a href="rewriteheap.c.html#LN1119"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/pgstat.h.html#LN1230"><span class='Ref_to_Func'>pgstat_report_wait_end</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now fsync all previously written data. We could improve things and only 
     * do this for the last write to a file, but the required bookkeeping 
     * doesn't seem worth the trouble. 
     */ 
</span>    <a href="../../../include/pgstat.h.html#LN1206"><span class='Ref_to_Func'>pgstat_report_wait_start</span></a><span class='Parentheses'>(</span><a href="../../../include/pgstat.h.html#LN864"><span class='Ref_to_EnumConst'>WAIT_EVENT_LOGICAL_REWRITE_MAPPING_SYNC</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/fd.h.html#LN114"><span class='Ref_to_Proto'>pg_fsync</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN1120"><span class='Ref_To_Local'>fd</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not fsync file \"%s\": %m"</span><span class='Delimiter'>, </span><a href="rewriteheap.c.html#LN1119"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/pgstat.h.html#LN1230"><span class='Ref_to_Func'>pgstat_report_wait_end</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/fd.h.html#LN97"><span class='Ref_to_Proto'>CloseTransientFile</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN1120"><span class='Ref_To_Local'>fd</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end heap_xlog_logical_rewrite &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* --- 
 * Perform a checkpoint for logical rewrite mappings 
 * 
 * This serves two tasks: 
 * 1) Remove all mappings not needed anymore based on the logical restart LSN 
 * 2) Flush all remaining mappings to disk, so that replay after a checkpoint 
 *    only has to deal with the parts of a mapping that have been written out 
 *    after the checkpoint started. 
 * --- 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1199"></a><span class='Declare_Function'>CheckPointLogicalRewriteHeap</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1201"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>cutoff</span><span class='Delimiter'>; 
</span><a name="LN1202"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>redo</span><span class='Delimiter'>; 
</span><a name="LN1203"></a>    <a href="../../../port/dirent.c.html#LN24"><span class='Ref_to_Struct'>DIR</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>mappings_dir</span><span class='Delimiter'>; 
</span><a name="LN1204"></a>    <span class='Control'>struct</span> <a href="../../../include/port/win32_msvc/dirent.h.html#LN8"><span class='Ref_to_Struct'>dirent</span></a> <span class='Operator'>*</span><span class='Declare_Local'>mapping_de</span><span class='Delimiter'>; 
</span><a name="LN1205"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>path</span><span class='Delimiter'>[</span><a href="../../../include/pg_config_manual.h.html#LN88"><span class='Ref_to_Const'>MAXPGPATH</span></a> <span class='Operator'>+ </span><span class='Number'>20</span><span class='Delimiter'>]; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We start of with a minimum of the last redo pointer. No new decoding 
     * slot will start before that, so that's a safe upper bound for removal. 
     */ 
</span>    <a href="rewriteheap.c.html#LN1202"><span class='Ref_To_Local'>redo</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlog.h.html#LN273"><span class='Ref_to_Proto'>GetRedoRecPtr</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* now check for the restart ptrs from existing slots */ 
</span>    <a href="rewriteheap.c.html#LN1201"><span class='Ref_To_Local'>cutoff</span></a> <span class='Operator'>= </span><a href="../../../include/replication/slot.h.html#LN177"><span class='Ref_to_Proto'>ReplicationSlotsComputeLogicalRestartLSN</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* don't start earlier than the restart lsn */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN1201"><span class='Ref_To_Local'>cutoff</span></a> <span class='Operator'>!= </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a> <span class='Operator'>&& </span><a href="rewriteheap.c.html#LN1202"><span class='Ref_To_Local'>redo</span></a> <span class='Operator'>&LT; </span><a href="rewriteheap.c.html#LN1201"><span class='Ref_To_Local'>cutoff</span></a><span class='Parentheses'>) 
</span>        <a href="rewriteheap.c.html#LN1201"><span class='Ref_To_Local'>cutoff</span></a> <span class='Operator'>= </span><a href="rewriteheap.c.html#LN1202"><span class='Ref_To_Local'>redo</span></a><span class='Delimiter'>; 
</span> 
    <a href="rewriteheap.c.html#LN1203"><span class='Ref_To_Local'>mappings_dir</span></a> <span class='Operator'>= </span><a href="../../../include/storage/fd.h.html#LN91"><span class='Ref_to_Proto'>AllocateDir</span></a><span class='Parentheses'>(</span><span class='String'>"pg_logical/mappings"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>while</span> <span class='Parentheses'>((</span><a href="rewriteheap.c.html#LN1204"><span class='Ref_To_Local'>mapping_de</span></a> <span class='Operator'>= </span><a href="../../../include/storage/fd.h.html#LN92"><span class='Ref_to_Proto'>ReadDir</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN1203"><span class='Ref_To_Local'>mappings_dir</span></a><span class='Delimiter'>, </span><span class='String'>"pg_logical/mappings"</span><span class='Parentheses'>))</span> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1223"></a>        <span class='Control'>struct</span> <a href="../../../include/port.h.html#LN275"><span class='Ref_to_Macro'>stat</span></a> <span class='Declare_Local'>statbuf</span><span class='Delimiter'>; 
</span><a name="LN1224"></a>        <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>dboid</span><span class='Delimiter'>; 
</span><a name="LN1225"></a>        <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>relid</span><span class='Delimiter'>; 
</span><a name="LN1226"></a>        <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>lsn</span><span class='Delimiter'>; 
</span><a name="LN1227"></a>        <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>rewrite_xid</span><span class='Delimiter'>; 
</span><a name="LN1228"></a>        <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>create_xid</span><span class='Delimiter'>; 
</span><a name="LN1229"></a>        <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>hi</span><span class='Delimiter'>, 
</span><a name="LN1230"></a>                    <span class='Declare_Local'>lo</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN1204"><span class='Ref_To_Local'>mapping_de</span></a><span class='Operator'>-&GT;</span><a href="../../../include/port/win32_msvc/dirent.h.html#LN13"><span class='Ref_to_Member'>d_name</span></a><span class='Delimiter'>, </span><span class='String'>"."</span><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span> <span class='Operator'>|| 
</span>            strcmp<span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN1204"><span class='Ref_To_Local'>mapping_de</span></a><span class='Operator'>-&GT;</span><a href="../../../include/port/win32_msvc/dirent.h.html#LN13"><span class='Ref_to_Member'>d_name</span></a><span class='Delimiter'>, </span><span class='String'>".."</span><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <a href="../../../pl/plperl/plperl.h.html#LN60"><span class='Ref_to_Macro'>snprintf</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN1205"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN1205"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='String'>"pg_logical/mappings/%s"</span><span class='Delimiter'>, </span><a href="rewriteheap.c.html#LN1204"><span class='Ref_To_Local'>mapping_de</span></a><span class='Operator'>-&GT;</span><a href="../../../include/port/win32_msvc/dirent.h.html#LN13"><span class='Ref_to_Member'>d_name</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/port/win32.h.html#LN261"><span class='Ref_to_Macro'>lstat</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN1205"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN1223"><span class='Ref_To_Local'>statbuf</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span> <span class='Operator'>&& !</span><a href="../../../include/port/win32.h.html#LN430"><span class='Ref_to_Macro'>S_ISREG</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN1223"><span class='Ref_To_Local'>statbuf</span></a><span class='Operator'>.</span>st_mode<span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Skip over files that cannot be ours. */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span>strncmp<span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN1204"><span class='Ref_To_Local'>mapping_de</span></a><span class='Operator'>-&GT;</span><a href="../../../include/port/win32_msvc/dirent.h.html#LN13"><span class='Ref_to_Member'>d_name</span></a><span class='Delimiter'>, </span><span class='String'>"map-"</span><span class='Delimiter'>, </span><span class='Number'>4</span><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span>sscanf<span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN1204"><span class='Ref_To_Local'>mapping_de</span></a><span class='Operator'>-&GT;</span><a href="../../../include/port/win32_msvc/dirent.h.html#LN13"><span class='Ref_to_Member'>d_name</span></a><span class='Delimiter'>, </span><a href="../../../include/access/rewriteheap.h.html#LN53"><span class='Ref_to_Const'>LOGICAL_REWRITE_FORMAT</span></a><span class='Delimiter'>, 
</span>                   <span class='Operator'>&</span><a href="rewriteheap.c.html#LN1224"><span class='Ref_To_Local'>dboid</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN1225"><span class='Ref_To_Local'>relid</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN1229"><span class='Ref_To_Local'>hi</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN1230"><span class='Ref_To_Local'>lo</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN1227"><span class='Ref_To_Local'>rewrite_xid</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="rewriteheap.c.html#LN1228"><span class='Ref_To_Local'>create_xid</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>6</span><span class='Parentheses'>)</span> 
            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"could not parse filename \"%s\""</span><span class='Delimiter'>, </span><a href="rewriteheap.c.html#LN1204"><span class='Ref_To_Local'>mapping_de</span></a><span class='Operator'>-&GT;</span><a href="../../../include/port/win32_msvc/dirent.h.html#LN13"><span class='Ref_to_Member'>d_name</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="rewriteheap.c.html#LN1226"><span class='Ref_To_Local'>lsn</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a><span class='Parentheses'>) </span><a href="rewriteheap.c.html#LN1229"><span class='Ref_To_Local'>hi</span></a><span class='Parentheses'>)</span> <span class='Operator'>&LT;&LT; </span><span class='Number'>32</span> <span class='Operator'>| </span><a href="rewriteheap.c.html#LN1230"><span class='Ref_To_Local'>lo</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN1226"><span class='Ref_To_Local'>lsn</span></a> <span class='Operator'>&LT; </span><a href="rewriteheap.c.html#LN1201"><span class='Ref_To_Local'>cutoff</span></a> <span class='Operator'>|| </span><a href="rewriteheap.c.html#LN1201"><span class='Ref_To_Local'>cutoff</span></a> <span class='Operator'>== </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN24"><span class='Ref_to_Const'>DEBUG1</span></a><span class='Delimiter'>, </span><span class='String'>"removing logical rewrite file \"%s\""</span><span class='Delimiter'>, </span><a href="rewriteheap.c.html#LN1205"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../timezone/private.h.html#LN59"><span class='Ref_to_Proto'>unlink</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN1205"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>) </span><span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                         <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not remove file \"%s\": %m"</span><span class='Delimiter'>, </span><a href="rewriteheap.c.html#LN1205"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span><a name="LN1260"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>fd</span> <span class='Operator'>= </span><a href="../../../include/storage/fd.h.html#LN96"><span class='Ref_to_Proto'>OpenTransientFile</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN1205"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, </span>O_RDONLY <span class='Operator'>| </span><a href="../../../include/c.h.html#LN1032"><span class='Ref_to_Const'>PG_BINARY</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * The file cannot vanish due to concurrency since this function 
             * is the only one removing logical mappings and it's run while 
             * CheckpointLock is held exclusively. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN1260"><span class='Ref_To_Local'>fd</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                         <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not open file \"%s\": %m"</span><span class='Delimiter'>, </span><a href="rewriteheap.c.html#LN1205"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * We could try to avoid fsyncing files that either haven't 
             * changed or have only been created since the checkpoint's start, 
             * but it's currently not deemed worth the effort. 
             */ 
</span>            <a href="../../../include/pgstat.h.html#LN1206"><span class='Ref_to_Func'>pgstat_report_wait_start</span></a><span class='Parentheses'>(</span><a href="../../../include/pgstat.h.html#LN863"><span class='Ref_to_EnumConst'>WAIT_EVENT_LOGICAL_REWRITE_CHECKPOINT_SYNC</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/fd.h.html#LN114"><span class='Ref_to_Proto'>pg_fsync</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN1260"><span class='Ref_To_Local'>fd</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                         <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not fsync file \"%s\": %m"</span><span class='Delimiter'>, </span><a href="rewriteheap.c.html#LN1205"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <a href="../../../include/pgstat.h.html#LN1230"><span class='Ref_to_Func'>pgstat_report_wait_end</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>            <a href="../../../include/storage/fd.h.html#LN97"><span class='Ref_to_Proto'>CloseTransientFile</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN1260"><span class='Ref_To_Local'>fd</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while (mapping_de=ReadDir(m... &raquo; </span> 
    <a href="../../../include/storage/fd.h.html#LN93"><span class='Ref_to_Proto'>FreeDir</span></a><span class='Parentheses'>(</span><a href="rewriteheap.c.html#LN1203"><span class='Ref_To_Local'>mappings_dir</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end CheckPointLogicalRewriteHeap &raquo; </span> 
</pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>