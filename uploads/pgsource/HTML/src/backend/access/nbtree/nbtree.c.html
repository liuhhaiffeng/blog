<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\access\nbtree\nbtree.c</title>
<LINK REL=StyleSheet HREF="../../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\access\nbtree\nbtree.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:29 2017
</td></tr>
<tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * nbtree.c 
 *    Implementation of Lehman and Yao's btree management algorithm for 
 *    Postgres. 
 * 
 * NOTES 
 *    This file contains only the public interface routines. 
 * 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * IDENTIFICATION 
 *    src/backend/access/nbtree/nbtree.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"access/nbtree.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/relscan.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/xlog.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/index.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"commands/vacuum.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"pgstat.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/condition_variable.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/indexfsm.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/ipc.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/lmgr.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/smgr.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"tcop/tcopprot.h"</span>      <span class='Comment_Single_Line'>/* pgrminclude ignore */ 
</span><span class='Keyword'>#include </span><span class='String'>"utils/builtins.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/index_selfuncs.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/memutils.h"</span> 
 
 
<span class='Comment_Multi_Line'>/* Working state for btbuild and its callback */ 
</span><span class='Control'>typedef</span> <span class='Control'>struct</span> 
<span class='Delimiter'>{ 
</span><a name="LN40"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>isUnique</span><span class='Delimiter'>; 
</span><a name="LN41"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>haveDead</span><span class='Delimiter'>; 
</span><a name="LN42"></a>    <a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Member'>heapRel</span><span class='Delimiter'>; 
</span><a name="LN43"></a>    <a href="nbtsort.c.html#LN84"><span class='Ref_to_Struct'>BTSpool</span></a>    <span class='Operator'>*</span><span class='Declare_Member'>spool</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * spool2 is needed only when the index is a unique index. Dead tuples are 
     * put into spool2 instead of spool in order to avoid uniqueness check. 
     */ 
</span><a name="LN49"></a>    <a href="nbtsort.c.html#LN84"><span class='Ref_to_Struct'>BTSpool</span></a>    <span class='Operator'>*</span><span class='Declare_Member'>spool2</span><span class='Delimiter'>; 
</span><a name="LN50"></a>    <span class='Keyword'>double</span>      <span class='Declare_Member'>indtuples</span><span class='Delimiter'>; 
</span><a name="LN51"></a>} <span class='Declare_Typedef'>BTBuildState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* Working state needed by btvacuumpage */ 
</span><span class='Control'>typedef</span> <span class='Control'>struct</span> 
<span class='Delimiter'>{ 
</span><a name="LN56"></a>    <a href="../../../include/access/genam.h.html#LN43"><span class='Ref_to_Struct'>IndexVacuumInfo</span></a> <span class='Operator'>*</span><span class='Declare_Member'>info</span><span class='Delimiter'>; 
</span><a name="LN57"></a>    <a href="../../../include/access/genam.h.html#LN70"><span class='Ref_to_Struct'>IndexBulkDeleteResult</span></a> <span class='Operator'>*</span><span class='Declare_Member'>stats</span><span class='Delimiter'>; 
</span><a name="LN58"></a>    <a href="../../../include/access/genam.h.html#LN82"><span class='Ref_to_Typedef'>IndexBulkDeleteCallback</span></a> <span class='Declare_Member'>callback</span><span class='Delimiter'>; 
</span><a name="LN59"></a>    <span class='Keyword'>void</span>       <span class='Operator'>*</span><span class='Declare_Member'>callback_state</span><span class='Delimiter'>; 
</span><a name="LN60"></a>    <a href="../../../include/access/nbtree.h.html#LN25"><span class='Ref_to_Typedef'>BTCycleId</span></a>   <span class='Declare_Member'>cycleid</span><span class='Delimiter'>; 
</span><a name="LN61"></a>    <a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Member'>lastBlockVacuumed</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* highest blkno actually vacuumed */ 
</span><a name="LN62"></a>    <a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Member'>lastBlockLocked</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* highest blkno we've cleanup-locked */ 
</span><a name="LN63"></a>    <a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Member'>totFreePages</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* true total # of free pages */ 
</span><a name="LN64"></a>    <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Member'>pagedelcontext</span><span class='Delimiter'>; 
</span><a name="LN65"></a>} <span class='Declare_Typedef'>BTVacState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * BTPARALLEL_NOT_INITIALIZED indicates that the scan has not started. 
 * 
 * BTPARALLEL_ADVANCING indicates that some process is advancing the scan to 
 * a new page; others must wait. 
 * 
 * BTPARALLEL_IDLE indicates that no backend is currently advancing the scan 
 * to a new page; some process can start doing that. 
 * 
 * BTPARALLEL_DONE indicates that the scan is complete (including error exit). 
 * We reach this state once for every distinct combination of array keys. 
 */ 
</span><span class='Control'>typedef</span> <span class='Control'>enum</span> 
<span class='Delimiter'>{ 
</span><a name="LN81"></a>    <span class='Declare_Enum_Const'>BTPARALLEL_NOT_INITIALIZED</span><span class='Delimiter'>, 
</span><a name="LN82"></a>    <span class='Declare_Enum_Const'>BTPARALLEL_ADVANCING</span><span class='Delimiter'>, 
</span><a name="LN83"></a>    <span class='Declare_Enum_Const'>BTPARALLEL_IDLE</span><span class='Delimiter'>, 
</span><a name="LN84"></a>    <span class='Declare_Enum_Const'>BTPARALLEL_DONE</span> 
<a name="LN85"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>BTPS_State</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * BTParallelScanDescData contains btree specific shared information required 
 * for parallel scan. 
 */ 
</span><a name="LN91"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>BTParallelScanDescData</span> 
<span class='Delimiter'>{ 
</span><a name="LN93"></a>    <a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Member'>btps_scanPage</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* latest or next page to be scanned */ 
</span><a name="LN94"></a>    <a href="nbtree.c.html#LN79"><span class='Ref_to_Typedef'>BTPS_State</span></a>  <span class='Declare_Member'>btps_pageStatus</span><span class='Delimiter'>;</span><span class='Comment_Multi_Line'>/* indicates whether next page is available 
                                 * for scan. see above for possible states of 
                                 * parallel scan. */ 
</span><a name="LN97"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>btps_arrayKeyCount</span><span class='Delimiter'>;</span>     <span class='Comment_Multi_Line'>/* count indicating number of array 
                                         * scan keys processed by parallel 
                                         * scan */ 
</span><a name="LN100"></a>    <a href="../../../include/storage/s_lock.h.html#LN137"><span class='Ref_to_Typedef'>slock_t</span></a>     <span class='Declare_Member'>btps_mutex</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* protects above variables */ 
</span><a name="LN101"></a>    <a href="../../../include/storage/condition_variable.h.html#LN27"><span class='Ref_to_Typedef'>ConditionVariable</span></a> <span class='Declare_Member'>btps_cv</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* used to synchronize parallel scan */ 
</span><a name="LN102"></a><span class='Delimiter'>}</span>   <span class='Declare_Typedef'>BTParallelScanDescData</span><span class='Delimiter'>; 
</span> 
<a name="LN104"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <a href="nbtree.c.html#LN91"><span class='Ref_to_Struct'>BTParallelScanDescData</span></a> <span class='Operator'>*</span><span class='Declare_Typedef'>BTParallelScanDesc</span><span class='Delimiter'>; 
</span> 
 
<a name="LN107"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>btbuildCallback</span><span class='Parentheses'>(</span><a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>index</span><span class='Delimiter'>, 
</span><a name="LN108"></a>                <a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a> <span class='Declare_Parameter'>htup</span><span class='Delimiter'>, 
</span><a name="LN109"></a>                <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>values</span><span class='Delimiter'>, 
</span><a name="LN110"></a>                <span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>isnull</span><span class='Delimiter'>, 
</span><a name="LN111"></a>                <span class='Keyword'>bool </span><span class='Declare_Parameter'>tupleIsAlive</span><span class='Delimiter'>, 
</span><a name="LN112"></a>                <span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN113"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>btvacuumscan</span><span class='Parentheses'>(</span><a href="../../../include/access/genam.h.html#LN43"><span class='Ref_to_Struct'>IndexVacuumInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>info</span><span class='Delimiter'>, </span><a href="../../../include/access/genam.h.html#LN70"><span class='Ref_to_Struct'>IndexBulkDeleteResult</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stats</span><span class='Delimiter'>, 
</span><a name="LN114"></a>             <a href="../../../include/access/genam.h.html#LN82"><span class='Ref_to_Typedef'>IndexBulkDeleteCallback</span></a> <span class='Declare_Parameter'>callback</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>callback_state</span><span class='Delimiter'>, 
</span><a name="LN115"></a>             <a href="../../../include/access/nbtree.h.html#LN25"><span class='Ref_to_Typedef'>BTCycleId</span></a> <span class='Declare_Parameter'>cycleid</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN116"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>btvacuumpage</span><span class='Parentheses'>(</span><a href="nbtree.c.html#LN54"><span class='Ref_to_Typedef'>BTVacState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>vstate</span><span class='Delimiter'>, </span><a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Parameter'>blkno</span><span class='Delimiter'>, 
</span><a name="LN117"></a>             <a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Parameter'>orig_blkno</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Btree handler function: return IndexAmRoutine with access method parameters 
 * and callbacks. 
 */ 
</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN125"></a><span class='Declare_Function'>bthandler</span><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN127"></a>    <a href="../../../include/access/amapi.h.html#LN158"><span class='Ref_to_Struct'>IndexAmRoutine</span></a> <span class='Operator'>*</span><span class='Declare_Local'>amroutine</span> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/access/amapi.h.html#LN158"><span class='Ref_to_Struct'>IndexAmRoutine</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="nbtree.c.html#LN127"><span class='Ref_To_Local'>amroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/amapi.h.html#LN166"><span class='Ref_to_Member'>amstrategies</span></a> <span class='Operator'>= </span><a href="../../../include/access/stratnum.h.html#LN34"><span class='Ref_to_Const'>BTMaxStrategyNumber</span></a><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN127"><span class='Ref_To_Local'>amroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/amapi.h.html#LN168"><span class='Ref_to_Member'>amsupport</span></a> <span class='Operator'>= </span><a href="../../../include/access/nbtree.h.html#LN230"><span class='Ref_to_Const'>BTNProcs</span></a><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN127"><span class='Ref_To_Local'>amroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/amapi.h.html#LN170"><span class='Ref_to_Member'>amcanorder</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN127"><span class='Ref_To_Local'>amroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/amapi.h.html#LN172"><span class='Ref_to_Member'>amcanorderbyop</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN127"><span class='Ref_To_Local'>amroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/amapi.h.html#LN174"><span class='Ref_to_Member'>amcanbackward</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN127"><span class='Ref_To_Local'>amroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/amapi.h.html#LN176"><span class='Ref_to_Member'>amcanunique</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN127"><span class='Ref_To_Local'>amroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/amapi.h.html#LN178"><span class='Ref_to_Member'>amcanmulticol</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN127"><span class='Ref_To_Local'>amroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/amapi.h.html#LN180"><span class='Ref_to_Member'>amoptionalkey</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN127"><span class='Ref_To_Local'>amroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/amapi.h.html#LN182"><span class='Ref_to_Member'>amsearcharray</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN127"><span class='Ref_To_Local'>amroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/amapi.h.html#LN184"><span class='Ref_to_Member'>amsearchnulls</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN127"><span class='Ref_To_Local'>amroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/amapi.h.html#LN186"><span class='Ref_to_Member'>amstorage</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN127"><span class='Ref_To_Local'>amroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/amapi.h.html#LN188"><span class='Ref_to_Member'>amclusterable</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN127"><span class='Ref_To_Local'>amroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/amapi.h.html#LN190"><span class='Ref_to_Member'>ampredlocks</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN127"><span class='Ref_To_Local'>amroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/amapi.h.html#LN192"><span class='Ref_to_Member'>amcanparallel</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN127"><span class='Ref_To_Local'>amroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/amapi.h.html#LN194"><span class='Ref_to_Member'>amkeytype</span></a> <span class='Operator'>= </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span> 
    <a href="nbtree.c.html#LN127"><span class='Ref_To_Local'>amroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/amapi.h.html#LN197"><span class='Ref_to_Member'>ambuild</span></a> <span class='Operator'>= </span><a href="nbtree.c.html#LN172"><span class='Ref_to_Func'>btbuild</span></a><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN127"><span class='Ref_To_Local'>amroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/amapi.h.html#LN198"><span class='Ref_to_Member'>ambuildempty</span></a> <span class='Operator'>= </span><a href="nbtree.c.html#LN281"><span class='Ref_to_Func'>btbuildempty</span></a><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN127"><span class='Ref_To_Local'>amroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/amapi.h.html#LN199"><span class='Ref_to_Member'>aminsert</span></a> <span class='Operator'>= </span><a href="nbtree.c.html#LN317"><span class='Ref_to_Func'>btinsert</span></a><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN127"><span class='Ref_To_Local'>amroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/amapi.h.html#LN200"><span class='Ref_to_Member'>ambulkdelete</span></a> <span class='Operator'>= </span><a href="../../../include/access/nbtree.h.html#LN450"><span class='Ref_to_Proto'>btbulkdelete</span></a><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN127"><span class='Ref_To_Local'>amroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/amapi.h.html#LN201"><span class='Ref_to_Member'>amvacuumcleanup</span></a> <span class='Operator'>= </span><a href="../../../include/access/nbtree.h.html#LN454"><span class='Ref_to_Proto'>btvacuumcleanup</span></a><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN127"><span class='Ref_To_Local'>amroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/amapi.h.html#LN202"><span class='Ref_to_Member'>amcanreturn</span></a> <span class='Operator'>= </span><a href="../../../include/access/nbtree.h.html#LN456"><span class='Ref_to_Proto'>btcanreturn</span></a><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN127"><span class='Ref_To_Local'>amroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/amapi.h.html#LN203"><span class='Ref_to_Member'>amcostestimate</span></a> <span class='Operator'>= </span><a href="../../../include/utils/index_selfuncs.h.html#LN32"><span class='Ref_to_Proto'>btcostestimate</span></a><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN127"><span class='Ref_To_Local'>amroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/amapi.h.html#LN204"><span class='Ref_to_Member'>amoptions</span></a> <span class='Operator'>= </span><a href="../../../include/access/nbtree.h.html#LN536"><span class='Ref_to_Proto'>btoptions</span></a><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN127"><span class='Ref_To_Local'>amroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/amapi.h.html#LN205"><span class='Ref_to_Member'>amproperty</span></a> <span class='Operator'>= </span><a href="../../../include/access/nbtree.h.html#LN537"><span class='Ref_to_Proto'>btproperty</span></a><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN127"><span class='Ref_To_Local'>amroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/amapi.h.html#LN206"><span class='Ref_to_Member'>amvalidate</span></a> <span class='Operator'>= </span><a href="nbtvalidate.c.html#LN36"><span class='Ref_to_Func'>btvalidate</span></a><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN127"><span class='Ref_To_Local'>amroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/amapi.h.html#LN207"><span class='Ref_to_Member'>ambeginscan</span></a> <span class='Operator'>= </span><a href="../../../include/access/nbtree.h.html#LN439"><span class='Ref_to_Proto'>btbeginscan</span></a><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN127"><span class='Ref_To_Local'>amroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/amapi.h.html#LN208"><span class='Ref_to_Member'>amrescan</span></a> <span class='Operator'>= </span><a href="../../../include/access/nbtree.h.html#LN444"><span class='Ref_to_Proto'>btrescan</span></a><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN127"><span class='Ref_To_Local'>amroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/amapi.h.html#LN209"><span class='Ref_to_Member'>amgettuple</span></a> <span class='Operator'>= </span><a href="nbtree.c.html#LN340"><span class='Ref_to_Func'>btgettuple</span></a><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN127"><span class='Ref_To_Local'>amroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/amapi.h.html#LN210"><span class='Ref_to_Member'>amgetbitmap</span></a> <span class='Operator'>= </span><a href="nbtree.c.html#LN414"><span class='Ref_to_Func'>btgetbitmap</span></a><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN127"><span class='Ref_To_Local'>amroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/amapi.h.html#LN211"><span class='Ref_to_Member'>amendscan</span></a> <span class='Operator'>= </span><a href="../../../include/access/nbtree.h.html#LN447"><span class='Ref_to_Proto'>btendscan</span></a><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN127"><span class='Ref_To_Local'>amroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/amapi.h.html#LN212"><span class='Ref_to_Member'>ammarkpos</span></a> <span class='Operator'>= </span><a href="../../../include/access/nbtree.h.html#LN448"><span class='Ref_to_Proto'>btmarkpos</span></a><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN127"><span class='Ref_To_Local'>amroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/amapi.h.html#LN213"><span class='Ref_to_Member'>amrestrpos</span></a> <span class='Operator'>= </span><a href="../../../include/access/nbtree.h.html#LN449"><span class='Ref_to_Proto'>btrestrpos</span></a><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN127"><span class='Ref_To_Local'>amroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/amapi.h.html#LN216"><span class='Ref_to_Member'>amestimateparallelscan</span></a> <span class='Operator'>= </span><a href="../../../include/access/nbtree.h.html#LN440"><span class='Ref_to_Proto'>btestimateparallelscan</span></a><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN127"><span class='Ref_To_Local'>amroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/amapi.h.html#LN217"><span class='Ref_to_Member'>aminitparallelscan</span></a> <span class='Operator'>= </span><a href="../../../include/access/nbtree.h.html#LN441"><span class='Ref_to_Proto'>btinitparallelscan</span></a><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN127"><span class='Ref_To_Local'>amroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/amapi.h.html#LN218"><span class='Ref_to_Member'>amparallelrescan</span></a> <span class='Operator'>= </span><a href="../../../include/access/nbtree.h.html#LN446"><span class='Ref_to_Proto'>btparallelrescan</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../../include/fmgr.h.html#LN320"><span class='Ref_to_Macro'>PG_RETURN_POINTER</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN127"><span class='Ref_To_Local'>amroutine</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end bthandler &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 *  btbuild() -- build a new btree index. 
 */ 
</span><a href="../../../include/access/genam.h.html#LN29"><span class='Ref_to_Struct'>IndexBuildResult</span></a> <span class='Operator'>* 
</span><a name="LN173"></a><span class='Declare_Function'>btbuild</span><span class='Parentheses'>(</span><a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>heap</span><span class='Delimiter'>, </span><a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>index</span><span class='Delimiter'>, </span><a href="../../../include/nodes/execnodes.h.html#LN130"><span class='Ref_to_Struct'>IndexInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>indexInfo</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN175"></a>    <a href="../../../include/access/genam.h.html#LN29"><span class='Ref_to_Struct'>IndexBuildResult</span></a> <span class='Operator'>*</span><span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span><a name="LN176"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>reltuples</span><span class='Delimiter'>; 
</span><a name="LN177"></a>    <a href="nbtree.c.html#LN38"><span class='Ref_to_Typedef'>BTBuildState</span></a> <span class='Declare_Local'>buildstate</span><span class='Delimiter'>; 
</span> 
    <a href="nbtree.c.html#LN177"><span class='Ref_To_Local'>buildstate</span></a><span class='Operator'>.</span><a href="nbtree.c.html#LN40"><span class='Ref_to_Member'>isUnique</span></a> <span class='Operator'>= </span><a href="nbtree.c.html#LN173"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/execnodes.h.html#LN145"><span class='Ref_to_Member'>ii_Unique</span></a><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN177"><span class='Ref_To_Local'>buildstate</span></a><span class='Operator'>.</span><a href="nbtree.c.html#LN41"><span class='Ref_to_Member'>haveDead</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN177"><span class='Ref_To_Local'>buildstate</span></a><span class='Operator'>.</span><a href="nbtree.c.html#LN42"><span class='Ref_to_Member'>heapRel</span></a> <span class='Operator'>= </span><a href="nbtree.c.html#LN173"><span class='Ref_to_Parameter'>heap</span></a><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN177"><span class='Ref_To_Local'>buildstate</span></a><span class='Operator'>.</span><a href="nbtree.c.html#LN43"><span class='Ref_to_Member'>spool</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN177"><span class='Ref_To_Local'>buildstate</span></a><span class='Operator'>.</span><a href="nbtree.c.html#LN49"><span class='Ref_to_Member'>spool2</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN177"><span class='Ref_To_Local'>buildstate</span></a><span class='Operator'>.</span><a href="nbtree.c.html#LN50"><span class='Ref_to_Member'>indtuples</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifdef</span> BTREE_BUILD_STATS 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../utils/misc/guc.c.html#LN442"><span class='Ref_to_Global_Var'>log_btree_build_stats</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/tcop/tcopprot.h.html#LN82"><span class='Ref_to_Proto'>ResetUsage</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span>   <span class='Comment_Single_Line'>/* BTREE_BUILD_STATS */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We expect to be called exactly once for any index relation. If that's 
     * not the case, big trouble's what we have. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/bufmgr.h.html#LN198"><span class='Ref_to_Macro'>RelationGetNumberOfBlocks</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN173"><span class='Ref_to_Parameter'>index</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"index \"%s\" already contains data"</span><span class='Delimiter'>, 
</span>             <a href="../../../include/utils/rel.h.html#LN436"><span class='Ref_to_Macro'>RelationGetRelationName</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN173"><span class='Ref_to_Parameter'>index</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="nbtree.c.html#LN177"><span class='Ref_To_Local'>buildstate</span></a><span class='Operator'>.</span><a href="nbtree.c.html#LN43"><span class='Ref_to_Member'>spool</span></a> <span class='Operator'>= </span><a href="nbtsort.c.html#LN150"><span class='Ref_to_Func'>_bt_spoolinit</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN173"><span class='Ref_to_Parameter'>heap</span></a><span class='Delimiter'>, </span><a href="nbtree.c.html#LN173"><span class='Ref_to_Parameter'>index</span></a><span class='Delimiter'>, </span><a href="nbtree.c.html#LN173"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/execnodes.h.html#LN145"><span class='Ref_to_Member'>ii_Unique</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If building a unique index, put dead tuples in a second spool to keep 
     * them out of the uniqueness check. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN173"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/execnodes.h.html#LN145"><span class='Ref_to_Member'>ii_Unique</span></a><span class='Parentheses'>) 
</span>        <a href="nbtree.c.html#LN177"><span class='Ref_To_Local'>buildstate</span></a><span class='Operator'>.</span><a href="nbtree.c.html#LN49"><span class='Ref_to_Member'>spool2</span></a> <span class='Operator'>= </span><a href="nbtsort.c.html#LN150"><span class='Ref_to_Func'>_bt_spoolinit</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN173"><span class='Ref_to_Parameter'>heap</span></a><span class='Delimiter'>, </span><a href="nbtree.c.html#LN173"><span class='Ref_to_Parameter'>index</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* do the heap scan */ 
</span>    <a href="nbtree.c.html#LN176"><span class='Ref_To_Local'>reltuples</span></a> <span class='Operator'>= </span><a href="../../../include/catalog/index.h.html#LN97"><span class='Ref_to_Proto'>IndexBuildHeapScan</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN173"><span class='Ref_to_Parameter'>heap</span></a><span class='Delimiter'>, </span><a href="nbtree.c.html#LN173"><span class='Ref_to_Parameter'>index</span></a><span class='Delimiter'>, </span><a href="nbtree.c.html#LN173"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, 
</span>                                   <a href="nbtree.c.html#LN107"><span class='Ref_to_Proto'>btbuildCallback</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><a href="nbtree.c.html#LN177"><span class='Ref_To_Local'>buildstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* okay, all heap tuples are indexed */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN177"><span class='Ref_To_Local'>buildstate</span></a><span class='Operator'>.</span><a href="nbtree.c.html#LN49"><span class='Ref_to_Member'>spool2</span></a> <span class='Operator'>&& !</span><a href="nbtree.c.html#LN177"><span class='Ref_To_Local'>buildstate</span></a><span class='Operator'>.</span><a href="nbtree.c.html#LN41"><span class='Ref_to_Member'>haveDead</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* spool2 turns out to be unnecessary */ 
</span>        <a href="nbtsort.c.html#LN178"><span class='Ref_to_Func'>_bt_spooldestroy</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN177"><span class='Ref_To_Local'>buildstate</span></a><span class='Operator'>.</span><a href="nbtree.c.html#LN49"><span class='Ref_to_Member'>spool2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="nbtree.c.html#LN177"><span class='Ref_To_Local'>buildstate</span></a><span class='Operator'>.</span><a href="nbtree.c.html#LN49"><span class='Ref_to_Member'>spool2</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Finish the build by (1) completing the sort of the spool file, (2) 
     * inserting the sorted tuples into btree pages and (3) building the upper 
     * levels. 
     */ 
</span>    <a href="nbtsort.c.html#LN199"><span class='Ref_to_Func'>_bt_leafbuild</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN177"><span class='Ref_To_Local'>buildstate</span></a><span class='Operator'>.</span><a href="nbtree.c.html#LN43"><span class='Ref_to_Member'>spool</span></a><span class='Delimiter'>, </span><a href="nbtree.c.html#LN177"><span class='Ref_To_Local'>buildstate</span></a><span class='Operator'>.</span><a href="nbtree.c.html#LN49"><span class='Ref_to_Member'>spool2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="nbtsort.c.html#LN178"><span class='Ref_to_Func'>_bt_spooldestroy</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN177"><span class='Ref_To_Local'>buildstate</span></a><span class='Operator'>.</span><a href="nbtree.c.html#LN43"><span class='Ref_to_Member'>spool</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN177"><span class='Ref_To_Local'>buildstate</span></a><span class='Operator'>.</span><a href="nbtree.c.html#LN49"><span class='Ref_to_Member'>spool2</span></a><span class='Parentheses'>) 
</span>        <a href="nbtsort.c.html#LN178"><span class='Ref_to_Func'>_bt_spooldestroy</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN177"><span class='Ref_To_Local'>buildstate</span></a><span class='Operator'>.</span><a href="nbtree.c.html#LN49"><span class='Ref_to_Member'>spool2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifdef</span> BTREE_BUILD_STATS 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../utils/misc/guc.c.html#LN442"><span class='Ref_to_Global_Var'>log_btree_build_stats</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/tcop/tcopprot.h.html#LN83"><span class='Ref_to_Proto'>ShowUsage</span></a><span class='Parentheses'>(</span><span class='String'>"BTREE BUILD STATS"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/tcop/tcopprot.h.html#LN82"><span class='Ref_to_Proto'>ResetUsage</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span><span class='Directive'>#endif</span>   <span class='Comment_Single_Line'>/* BTREE_BUILD_STATS */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Return statistics 
     */ 
</span>    <a href="nbtree.c.html#LN175"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/genam.h.html#LN29"><span class='Ref_to_Struct'>IndexBuildResult</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/access/genam.h.html#LN29"><span class='Ref_to_Struct'>IndexBuildResult</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="nbtree.c.html#LN175"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/genam.h.html#LN31"><span class='Ref_to_Member'>heap_tuples</span></a> <span class='Operator'>= </span><a href="nbtree.c.html#LN176"><span class='Ref_To_Local'>reltuples</span></a><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN175"><span class='Ref_To_Local'>result</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/genam.h.html#LN32"><span class='Ref_to_Member'>index_tuples</span></a> <span class='Operator'>= </span><a href="nbtree.c.html#LN177"><span class='Ref_To_Local'>buildstate</span></a><span class='Operator'>.</span><a href="nbtree.c.html#LN50"><span class='Ref_to_Member'>indtuples</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="nbtree.c.html#LN175"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end btbuild &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Per-tuple callback from IndexBuildHeapScan 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN253"></a><span class='Declare_Function'>btbuildCallback</span><span class='Parentheses'>(</span><a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>index</span><span class='Delimiter'>, 
</span><a name="LN254"></a>                <a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a> <span class='Declare_Parameter'>htup</span><span class='Delimiter'>, 
</span><a name="LN255"></a>                <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>values</span><span class='Delimiter'>, 
</span><a name="LN256"></a>                <span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>isnull</span><span class='Delimiter'>, 
</span><a name="LN257"></a>                <span class='Keyword'>bool </span><span class='Declare_Parameter'>tupleIsAlive</span><span class='Delimiter'>, 
</span><a name="LN258"></a>                <span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN260"></a>    <a href="nbtree.c.html#LN38"><span class='Ref_to_Typedef'>BTBuildState</span></a> <span class='Operator'>*</span><span class='Declare_Local'>buildstate</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="nbtree.c.html#LN38"><span class='Ref_to_Typedef'>BTBuildState</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nbtree.c.html#LN258"><span class='Ref_to_Parameter'>state</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * insert the index tuple into the appropriate spool file for subsequent 
     * processing 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN257"><span class='Ref_to_Parameter'>tupleIsAlive</span></a> <span class='Operator'>|| </span><a href="nbtree.c.html#LN260"><span class='Ref_To_Local'>buildstate</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN49"><span class='Ref_to_Member'>spool2</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="nbtsort.c.html#LN188"><span class='Ref_to_Func'>_bt_spool</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN260"><span class='Ref_To_Local'>buildstate</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN43"><span class='Ref_to_Member'>spool</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nbtree.c.html#LN254"><span class='Ref_to_Parameter'>htup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN64"><span class='Ref_to_Member'>t_self</span></a><span class='Delimiter'>, </span><a href="nbtree.c.html#LN255"><span class='Ref_to_Parameter'>values</span></a><span class='Delimiter'>, </span><a href="nbtree.c.html#LN256"><span class='Ref_to_Parameter'>isnull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* dead tuples are put into spool2 */ 
</span>        <a href="nbtree.c.html#LN260"><span class='Ref_To_Local'>buildstate</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN41"><span class='Ref_to_Member'>haveDead</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <a href="nbtsort.c.html#LN188"><span class='Ref_to_Func'>_bt_spool</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN260"><span class='Ref_To_Local'>buildstate</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN49"><span class='Ref_to_Member'>spool2</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nbtree.c.html#LN254"><span class='Ref_to_Parameter'>htup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/htup.h.html#LN64"><span class='Ref_to_Member'>t_self</span></a><span class='Delimiter'>, </span><a href="nbtree.c.html#LN255"><span class='Ref_to_Parameter'>values</span></a><span class='Delimiter'>, </span><a href="nbtree.c.html#LN256"><span class='Ref_to_Parameter'>isnull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="nbtree.c.html#LN260"><span class='Ref_To_Local'>buildstate</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN50"><span class='Ref_to_Member'>indtuples</span></a> <span class='Operator'>+= </span><span class='Number'>1</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end btbuildCallback &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 *  btbuildempty() -- build an empty btree index in the initialization fork 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN282"></a><span class='Declare_Function'>btbuildempty</span><span class='Parentheses'>(</span><a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>index</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN284"></a>    <a href="../../../include/storage/bufpage.h.html#LN73"><span class='Ref_to_Typedef'>Page</span></a>        <span class='Declare_Local'>metapage</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Construct metapage. */ 
</span>    <a href="nbtree.c.html#LN284"><span class='Ref_To_Local'>metapage</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/storage/bufpage.h.html#LN73"><span class='Ref_to_Typedef'>Page</span></a><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span>BLCKSZ<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="nbtpage.c.html#LN47"><span class='Ref_to_Func'>_bt_initmetapage</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN284"><span class='Ref_To_Local'>metapage</span></a><span class='Delimiter'>, </span><a href="../../../include/access/nbtree.h.html#LN167"><span class='Ref_to_Const'>P_NONE</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Write the page and log it.  It might seem that an immediate sync would 
     * be sufficient to guarantee that the file exists on disk, but recovery 
     * itself might remove it while replaying, for example, an 
     * XLOG_DBASE_CREATE or XLOG_TBLSPC_CREATE record.  Therefore, we need 
     * this even when wal_level=minimal. 
     */ 
</span>    <a href="../../../include/storage/bufpage.h.html#LN436"><span class='Ref_to_Proto'>PageSetChecksumInplace</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN284"><span class='Ref_To_Local'>metapage</span></a><span class='Delimiter'>, </span><a href="../../../include/access/nbtree.h.html#LN108"><span class='Ref_to_Const'>BTREE_METAPAGE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/smgr.h.html#LN100"><span class='Ref_to_Proto'>smgrwrite</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN282"><span class='Ref_to_Parameter'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN86"><span class='Ref_to_Member'>rd_smgr</span></a><span class='Delimiter'>, </span><a href="../../../include/common/relpath.h.html#LN29"><span class='Ref_to_EnumConst'>INIT_FORKNUM</span></a><span class='Delimiter'>, </span><a href="../../../include/access/nbtree.h.html#LN108"><span class='Ref_to_Const'>BTREE_METAPAGE</span></a><span class='Delimiter'>, 
</span>              <span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nbtree.c.html#LN284"><span class='Ref_To_Local'>metapage</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/access/xloginsert.h.html#LN54"><span class='Ref_to_Proto'>log_newpage</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nbtree.c.html#LN282"><span class='Ref_to_Parameter'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN86"><span class='Ref_to_Member'>rd_smgr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/smgr.h.html#LN42"><span class='Ref_to_Member'>smgr_rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN73"><span class='Ref_to_Member'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/common/relpath.h.html#LN29"><span class='Ref_to_EnumConst'>INIT_FORKNUM</span></a><span class='Delimiter'>, 
</span>                <a href="../../../include/access/nbtree.h.html#LN108"><span class='Ref_to_Const'>BTREE_METAPAGE</span></a><span class='Delimiter'>, </span><a href="nbtree.c.html#LN284"><span class='Ref_To_Local'>metapage</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * An immediate sync is required even if we xlog'd the page, because the 
     * write did not go through shared_buffers and therefore a concurrent 
     * checkpoint may have moved the redo pointer past our xlog record. 
     */ 
</span>    <a href="../../../include/storage/smgr.h.html#LN107"><span class='Ref_to_Proto'>smgrimmedsync</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN282"><span class='Ref_to_Parameter'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN86"><span class='Ref_to_Member'>rd_smgr</span></a><span class='Delimiter'>, </span><a href="../../../include/common/relpath.h.html#LN29"><span class='Ref_to_EnumConst'>INIT_FORKNUM</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end btbuildempty &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 *  btinsert() -- insert an index tuple into a btree. 
 * 
 *      Descend the tree recursively, find the appropriate location for our 
 *      new tuple, and put it there. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN318"></a><span class='Declare_Function'>btinsert</span><span class='Parentheses'>(</span><a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>rel</span><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>values</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>isnull</span><span class='Delimiter'>, 
</span><a name="LN319"></a>         <a href="../../../include/storage/itemptr.h.html#LN47"><span class='Ref_to_Typedef'>ItemPointer</span></a> <span class='Declare_Parameter'>ht_ctid</span><span class='Delimiter'>, </span><a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>heapRel</span><span class='Delimiter'>, 
</span><a name="LN320"></a>         <a href="../../../include/access/genam.h.html#LN110"><span class='Ref_to_Enum'>IndexUniqueCheck</span></a> <span class='Declare_Parameter'>checkUnique</span><span class='Delimiter'>, 
</span><a name="LN321"></a>         <a href="../../../include/nodes/execnodes.h.html#LN130"><span class='Ref_to_Struct'>IndexInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>indexInfo</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN323"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span><a name="LN324"></a>    <a href="../../../include/access/itup.h.html#LN52"><span class='Ref_to_Typedef'>IndexTuple</span></a>  <span class='Declare_Local'>itup</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* generate an index tuple */ 
</span>    <a href="nbtree.c.html#LN324"><span class='Ref_To_Local'>itup</span></a> <span class='Operator'>= </span><a href="../common/indextuple.c.html#LN35"><span class='Ref_to_Func'>index_form_tuple</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/rel.h.html#LN428"><span class='Ref_to_Macro'>RelationGetDescr</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN318"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="nbtree.c.html#LN318"><span class='Ref_to_Parameter'>values</span></a><span class='Delimiter'>, </span><a href="nbtree.c.html#LN318"><span class='Ref_to_Parameter'>isnull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN324"><span class='Ref_To_Local'>itup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/itup.h.html#LN36"><span class='Ref_to_Member'>t_tid</span></a> <span class='Operator'>= *</span><a href="nbtree.c.html#LN319"><span class='Ref_to_Parameter'>ht_ctid</span></a><span class='Delimiter'>; 
</span> 
    <a href="nbtree.c.html#LN323"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="nbtinsert.c.html#LN106"><span class='Ref_to_Func'>_bt_doinsert</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN318"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="nbtree.c.html#LN324"><span class='Ref_To_Local'>itup</span></a><span class='Delimiter'>, </span><a href="nbtree.c.html#LN320"><span class='Ref_to_Parameter'>checkUnique</span></a><span class='Delimiter'>, </span><a href="nbtree.c.html#LN319"><span class='Ref_to_Parameter'>heapRel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN324"><span class='Ref_To_Local'>itup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="nbtree.c.html#LN323"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 *  btgettuple() -- Get the next tuple in the scan. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN341"></a><span class='Declare_Function'>btgettuple</span><span class='Parentheses'>(</span><a href="../../../include/access/genam.h.html#LN85"><span class='Ref_to_Typedef'>IndexScanDesc</span></a> <span class='Declare_Parameter'>scan</span><span class='Delimiter'>, </span><a href="../../../include/access/sdir.h.html#LN21"><span class='Ref_to_Enum'>ScanDirection</span></a> <span class='Declare_Parameter'>dir</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN343"></a>    <a href="../../../include/access/nbtree.h.html#LN416"><span class='Ref_to_Typedef'>BTScanOpaque</span></a> <span class='Declare_Local'>so</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN416"><span class='Ref_to_Typedef'>BTScanOpaque</span></a><span class='Parentheses'>) </span><a href="nbtree.c.html#LN341"><span class='Ref_to_Parameter'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN104"><span class='Ref_to_Member'>opaque</span></a><span class='Delimiter'>; 
</span><a name="LN344"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>res</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* btree indexes are never lossy */ 
</span>    <a href="nbtree.c.html#LN341"><span class='Ref_to_Parameter'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN121"><span class='Ref_to_Member'>xs_recheck</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we have any array keys, initialize them during first call for a 
     * scan.  We can't do this in btrescan because we don't know the scan 
     * direction at that time. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN343"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN383"><span class='Ref_to_Member'>numArrayKeys</span></a> <span class='Operator'>&& !</span><a href="../../../include/access/nbtree.h.html#LN349"><span class='Ref_to_Macro'>BTScanPosIsValid</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN343"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN412"><span class='Ref_to_Member'>currPos</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* punt if we have any unsatisfiable array keys */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN343"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN383"><span class='Ref_to_Member'>numArrayKeys</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
        <a href="nbtutils.c.html#LN519"><span class='Ref_to_Func'>_bt_start_array_keys</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN341"><span class='Ref_to_Parameter'>scan</span></a><span class='Delimiter'>, </span><a href="nbtree.c.html#LN341"><span class='Ref_to_Parameter'>dir</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* This loop handles advancing to the next array elements, if any */ 
</span>    <span class='Control'>do</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * If we've already initialized this scan, we can just advance it in 
         * the appropriate direction.  If we haven't done so yet, we call 
         * _bt_first() to get the first item in the scan. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/nbtree.h.html#LN349"><span class='Ref_to_Macro'>BTScanPosIsValid</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN343"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN412"><span class='Ref_to_Member'>currPos</span></a><span class='Parentheses'>))</span> 
            <a href="nbtree.c.html#LN344"><span class='Ref_To_Local'>res</span></a> <span class='Operator'>= </span><a href="../../../include/access/nbtree.h.html#LN508"><span class='Ref_to_Proto'>_bt_first</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN341"><span class='Ref_to_Parameter'>scan</span></a><span class='Delimiter'>, </span><a href="nbtree.c.html#LN341"><span class='Ref_to_Parameter'>dir</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Check to see if we should kill the previously-fetched tuple. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN341"><span class='Ref_to_Parameter'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN98"><span class='Ref_to_Member'>kill_prior_tuple</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * Yes, remember it for later. (We'll deal with all such 
                 * tuples at once right before leaving the index page.)  The 
                 * test for numKilled overrun is not just paranoia: if the 
                 * caller reverses direction in the indexscan then the same 
                 * item might get entered multiple times. It's not worth 
                 * trying to optimize that, so we don't detect it, but instead 
                 * just forget any excess entries. 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN343"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN391"><span class='Ref_to_Member'>killedItems</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>                    <a href="nbtree.c.html#LN343"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN391"><span class='Ref_to_Member'>killedItems</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Operator'>*</span><span class='Parentheses'>) 
</span>                        <a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="../../../include/access/itup.h.html#LN136"><span class='Ref_to_Const'>MaxIndexTuplesPerPage</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN343"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN392"><span class='Ref_to_Member'>numKilled</span></a> <span class='Operator'>&LT; </span><a href="../../../include/access/itup.h.html#LN136"><span class='Ref_to_Const'>MaxIndexTuplesPerPage</span></a><span class='Parentheses'>) 
</span>                    <a href="nbtree.c.html#LN343"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN391"><span class='Ref_to_Member'>killedItems</span></a><span class='Delimiter'>[</span><a href="nbtree.c.html#LN343"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN392"><span class='Ref_to_Member'>numKilled</span></a><span class='Operator'>++</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="nbtree.c.html#LN343"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN412"><span class='Ref_to_Member'>currPos</span></a><span class='Operator'>.</span><a href="../../../include/access/nbtree.h.html#LN325"><span class='Ref_to_Member'>itemIndex</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Now continue the scan. 
             */ 
</span>            <a href="nbtree.c.html#LN344"><span class='Ref_To_Local'>res</span></a> <span class='Operator'>= </span><a href="../../../include/access/nbtree.h.html#LN509"><span class='Ref_to_Proto'>_bt_next</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN341"><span class='Ref_to_Parameter'>scan</span></a><span class='Delimiter'>, </span><a href="nbtree.c.html#LN341"><span class='Ref_to_Parameter'>dir</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* If we have a tuple, return it ... */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN344"><span class='Ref_To_Local'>res</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* ... otherwise see if we have more array keys to deal with */ 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end do &raquo; </span> <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN343"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN383"><span class='Ref_to_Member'>numArrayKeys</span></a> <span class='Operator'>&& </span><a href="../../../include/access/nbtree.h.html#LN522"><span class='Ref_to_Proto'>_bt_advance_array_keys</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN341"><span class='Ref_to_Parameter'>scan</span></a><span class='Delimiter'>, </span><a href="nbtree.c.html#LN341"><span class='Ref_to_Parameter'>dir</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="nbtree.c.html#LN344"><span class='Ref_To_Local'>res</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end btgettuple &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * btgetbitmap() -- gets all matching tuples, and adds them to a bitmap 
 */ 
</span><a href="../../../include/c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a> 
<a name="LN415"></a><span class='Declare_Function'>btgetbitmap</span><span class='Parentheses'>(</span><a href="../../../include/access/genam.h.html#LN85"><span class='Ref_to_Typedef'>IndexScanDesc</span></a> <span class='Declare_Parameter'>scan</span><span class='Delimiter'>, </span><a href="../../nodes/tidbitmap.c.html#LN146"><span class='Ref_to_Struct'>TIDBitmap</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>tbm</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN417"></a>    <a href="../../../include/access/nbtree.h.html#LN416"><span class='Ref_to_Typedef'>BTScanOpaque</span></a> <span class='Declare_Local'>so</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN416"><span class='Ref_to_Typedef'>BTScanOpaque</span></a><span class='Parentheses'>) </span><a href="nbtree.c.html#LN415"><span class='Ref_to_Parameter'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN104"><span class='Ref_to_Member'>opaque</span></a><span class='Delimiter'>; 
</span><a name="LN418"></a>    <a href="../../../include/c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a>       <span class='Declare_Local'>ntids</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN419"></a>    <a href="../../../include/storage/itemptr.h.html#LN47"><span class='Ref_to_Typedef'>ItemPointer</span></a> <span class='Declare_Local'>heapTid</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we have any array keys, initialize them. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN417"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN383"><span class='Ref_to_Member'>numArrayKeys</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* punt if we have any unsatisfiable array keys */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN417"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN383"><span class='Ref_to_Member'>numArrayKeys</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <a href="nbtree.c.html#LN418"><span class='Ref_To_Local'>ntids</span></a><span class='Delimiter'>; 
</span> 
        <a href="nbtutils.c.html#LN519"><span class='Ref_to_Func'>_bt_start_array_keys</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN415"><span class='Ref_to_Parameter'>scan</span></a><span class='Delimiter'>, </span><a href="../../../include/access/sdir.h.html#LN25"><span class='Ref_to_EnumConst'>ForwardScanDirection</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* This loop handles advancing to the next array elements, if any */ 
</span>    <span class='Control'>do</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Fetch the first page & tuple */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN508"><span class='Ref_to_Proto'>_bt_first</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN415"><span class='Ref_to_Parameter'>scan</span></a><span class='Delimiter'>, </span><a href="../../../include/access/sdir.h.html#LN25"><span class='Ref_to_EnumConst'>ForwardScanDirection</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Save tuple ID, and continue scanning */ 
</span>            <a href="nbtree.c.html#LN419"><span class='Ref_To_Local'>heapTid</span></a> <span class='Operator'>= &</span><a href="nbtree.c.html#LN415"><span class='Ref_to_Parameter'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN118"><span class='Ref_to_Member'>xs_ctup</span></a><span class='Operator'>.</span><a href="../../../include/access/htup.h.html#LN64"><span class='Ref_to_Member'>t_self</span></a><span class='Delimiter'>; 
</span>            <a href="../../../include/nodes/tidbitmap.h.html#LN54"><span class='Ref_to_Proto'>tbm_add_tuples</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN415"><span class='Ref_to_Parameter'>tbm</span></a><span class='Delimiter'>, </span><a href="nbtree.c.html#LN419"><span class='Ref_To_Local'>heapTid</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="nbtree.c.html#LN418"><span class='Ref_To_Local'>ntids</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>;;</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * Advance to next tuple within page.  This is the same as the 
                 * easy case in _bt_next(). 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>++</span><a href="nbtree.c.html#LN417"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN412"><span class='Ref_to_Member'>currPos</span></a><span class='Operator'>.</span><a href="../../../include/access/nbtree.h.html#LN325"><span class='Ref_to_Member'>itemIndex</span></a> <span class='Operator'>&GT; </span><a href="nbtree.c.html#LN417"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN412"><span class='Ref_to_Member'>currPos</span></a><span class='Operator'>.</span><a href="../../../include/access/nbtree.h.html#LN324"><span class='Ref_to_Member'>lastItem</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* let _bt_next do the heavy lifting */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/nbtree.h.html#LN509"><span class='Ref_to_Proto'>_bt_next</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN415"><span class='Ref_to_Parameter'>scan</span></a><span class='Delimiter'>, </span><a href="../../../include/access/sdir.h.html#LN25"><span class='Ref_to_EnumConst'>ForwardScanDirection</span></a><span class='Parentheses'>))</span> 
                        <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
                <span class='Comment_Multi_Line'>/* Save tuple ID, and continue scanning */ 
</span>                <a href="nbtree.c.html#LN419"><span class='Ref_To_Local'>heapTid</span></a> <span class='Operator'>= &</span><a href="nbtree.c.html#LN417"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN412"><span class='Ref_to_Member'>currPos</span></a><span class='Operator'>.</span><a href="../../../include/access/nbtree.h.html#LN327"><span class='Ref_to_Member'>items</span></a><span class='Delimiter'>[</span><a href="nbtree.c.html#LN417"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN412"><span class='Ref_to_Member'>currPos</span></a><span class='Operator'>.</span><a href="../../../include/access/nbtree.h.html#LN325"><span class='Ref_to_Member'>itemIndex</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/access/nbtree.h.html#LN288"><span class='Ref_to_Member'>heapTid</span></a><span class='Delimiter'>; 
</span>                <a href="../../../include/nodes/tidbitmap.h.html#LN54"><span class='Ref_to_Proto'>tbm_add_tuples</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN415"><span class='Ref_to_Parameter'>tbm</span></a><span class='Delimiter'>, </span><a href="nbtree.c.html#LN419"><span class='Ref_To_Local'>heapTid</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="nbtree.c.html#LN418"><span class='Ref_To_Local'>ntids</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if _bt_first(scan,Forwar... &raquo; </span> 
        <span class='Comment_Multi_Line'>/* Now see if we have more array keys to deal with */ 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end do &raquo; </span> <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN417"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN383"><span class='Ref_to_Member'>numArrayKeys</span></a> <span class='Operator'>&& </span><a href="../../../include/access/nbtree.h.html#LN522"><span class='Ref_to_Proto'>_bt_advance_array_keys</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN415"><span class='Ref_to_Parameter'>scan</span></a><span class='Delimiter'>, </span><a href="../../../include/access/sdir.h.html#LN25"><span class='Ref_to_EnumConst'>ForwardScanDirection</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="nbtree.c.html#LN418"><span class='Ref_To_Local'>ntids</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end btgetbitmap &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 *  btbeginscan() -- start a scan on a btree index 
 */ 
</span><a href="../../../include/access/genam.h.html#LN85"><span class='Ref_to_Typedef'>IndexScanDesc</span></a> 
<a name="LN473"></a><span class='Declare_Function'>btbeginscan</span><span class='Parentheses'>(</span><a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>rel</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>nkeys</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>norderbys</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN475"></a>    <a href="../../../include/access/genam.h.html#LN85"><span class='Ref_to_Typedef'>IndexScanDesc</span></a> <span class='Declare_Local'>scan</span><span class='Delimiter'>; 
</span><a name="LN476"></a>    <a href="../../../include/access/nbtree.h.html#LN416"><span class='Ref_to_Typedef'>BTScanOpaque</span></a> <span class='Declare_Local'>so</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* no order by operators allowed */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nbtree.c.html#LN473"><span class='Ref_to_Parameter'>norderbys</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* get the scan */ 
</span>    <a href="nbtree.c.html#LN475"><span class='Ref_To_Local'>scan</span></a> <span class='Operator'>= </span><a href="../index/genam.c.html#LN76"><span class='Ref_to_Func'>RelationGetIndexScan</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN473"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="nbtree.c.html#LN473"><span class='Ref_to_Parameter'>nkeys</span></a><span class='Delimiter'>, </span><a href="nbtree.c.html#LN473"><span class='Ref_to_Parameter'>norderbys</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* allocate private workspace */ 
</span>    <a href="nbtree.c.html#LN476"><span class='Ref_To_Local'>so</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN416"><span class='Ref_to_Typedef'>BTScanOpaque</span></a><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN374"><span class='Ref_to_Struct'>BTScanOpaqueData</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/access/nbtree.h.html#LN355"><span class='Ref_to_Macro'>BTScanPosInvalidate</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN476"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN412"><span class='Ref_to_Member'>currPos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/access/nbtree.h.html#LN355"><span class='Ref_to_Macro'>BTScanPosInvalidate</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN476"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN413"><span class='Ref_to_Member'>markPos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN475"><span class='Ref_To_Local'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN90"><span class='Ref_to_Member'>numberOfKeys</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="nbtree.c.html#LN476"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN379"><span class='Ref_to_Member'>keyData</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN475"><span class='Ref_To_Local'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN90"><span class='Ref_to_Member'>numberOfKeys</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/access/skey.h.html#LN63"><span class='Ref_to_Struct'>ScanKeyData</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="nbtree.c.html#LN476"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN379"><span class='Ref_to_Member'>keyData</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <a href="nbtree.c.html#LN476"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN382"><span class='Ref_to_Member'>arrayKeyData</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* assume no array keys for now */ 
</span>    <a href="nbtree.c.html#LN476"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN383"><span class='Ref_to_Member'>numArrayKeys</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN476"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN387"><span class='Ref_to_Member'>arrayKeys</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN476"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN388"><span class='Ref_to_Member'>arrayContext</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <a href="nbtree.c.html#LN476"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN391"><span class='Ref_to_Member'>killedItems</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* until needed */ 
</span>    <a href="nbtree.c.html#LN476"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN392"><span class='Ref_to_Member'>numKilled</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We don't know yet whether the scan will be index-only, so we do not 
     * allocate the tuple workspace arrays until btrescan.  However, we set up 
     * scan-&GT;xs_itupdesc whether we'll need it or not, since that's so cheap. 
     */ 
</span>    <a href="nbtree.c.html#LN476"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN399"><span class='Ref_to_Member'>currTuples</span></a> <span class='Operator'>= </span><a href="nbtree.c.html#LN476"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN400"><span class='Ref_to_Member'>markTuples</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <a href="nbtree.c.html#LN475"><span class='Ref_To_Local'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN113"><span class='Ref_to_Member'>xs_itupdesc</span></a> <span class='Operator'>= </span><a href="../../../include/utils/rel.h.html#LN428"><span class='Ref_to_Macro'>RelationGetDescr</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN473"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="nbtree.c.html#LN475"><span class='Ref_To_Local'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN104"><span class='Ref_to_Member'>opaque</span></a> <span class='Operator'>= </span><a href="nbtree.c.html#LN476"><span class='Ref_To_Local'>so</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="nbtree.c.html#LN475"><span class='Ref_To_Local'>scan</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end btbeginscan &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 *  btrescan() -- rescan an index relation 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN519"></a><span class='Declare_Function'>btrescan</span><span class='Parentheses'>(</span><a href="../../../include/access/genam.h.html#LN85"><span class='Ref_to_Typedef'>IndexScanDesc</span></a> <span class='Declare_Parameter'>scan</span><span class='Delimiter'>, </span><a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a> <span class='Declare_Parameter'>scankey</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>nscankeys</span><span class='Delimiter'>, 
</span><a name="LN520"></a>         <a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a> <span class='Declare_Parameter'>orderbys</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>norderbys</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN522"></a>    <a href="../../../include/access/nbtree.h.html#LN416"><span class='Ref_to_Typedef'>BTScanOpaque</span></a> <span class='Declare_Local'>so</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN416"><span class='Ref_to_Typedef'>BTScanOpaque</span></a><span class='Parentheses'>) </span><a href="nbtree.c.html#LN519"><span class='Ref_to_Parameter'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN104"><span class='Ref_to_Member'>opaque</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* we aren't holding any read locks, but gotta drop the pins */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN349"><span class='Ref_to_Macro'>BTScanPosIsValid</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN522"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN412"><span class='Ref_to_Member'>currPos</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Before leaving current page, deal with any killed items */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN522"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN392"><span class='Ref_to_Member'>numKilled</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <a href="../../../include/access/nbtree.h.html#LN529"><span class='Ref_to_Proto'>_bt_killitems</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN519"><span class='Ref_to_Parameter'>scan</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/access/nbtree.h.html#LN343"><span class='Ref_to_Macro'>BTScanPosUnpinIfPinned</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN522"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN412"><span class='Ref_to_Member'>currPos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/access/nbtree.h.html#LN355"><span class='Ref_to_Macro'>BTScanPosInvalidate</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN522"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN412"><span class='Ref_to_Member'>currPos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="nbtree.c.html#LN522"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN409"><span class='Ref_to_Member'>markItemIndex</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN522"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN385"><span class='Ref_to_Member'>arrayKeyCount</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="../../../include/access/nbtree.h.html#LN343"><span class='Ref_to_Macro'>BTScanPosUnpinIfPinned</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN522"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN413"><span class='Ref_to_Member'>markPos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/access/nbtree.h.html#LN355"><span class='Ref_to_Macro'>BTScanPosInvalidate</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN522"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN413"><span class='Ref_to_Member'>markPos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Allocate tuple workspace arrays, if needed for an index-only scan and 
     * not already done in a previous rescan call.  To save on palloc 
     * overhead, both workspaces are allocated as one palloc block; only this 
     * function and btendscan know that. 
     * 
     * NOTE: this data structure also makes it safe to return data from a 
     * "name" column, even though btree name_ops uses an underlying storage 
     * datatype of cstring.  The risk there is that "name" is supposed to be 
     * padded to NAMEDATALEN, but the actual index tuple is probably shorter. 
     * However, since we only return data out of tuples sitting in the 
     * currTuples array, a fetch of NAMEDATALEN bytes can at worst pull some 
     * data out of the markTuples array --- running off the end of memory for 
     * a SIGSEGV is not possible.  Yeah, this is ugly as sin, but it beats 
     * adding special-case treatment for name_ops elsewhere. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN519"><span class='Ref_to_Parameter'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN94"><span class='Ref_to_Member'>xs_want_itup</span></a> <span class='Operator'>&& </span><a href="nbtree.c.html#LN522"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN399"><span class='Ref_to_Member'>currTuples</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="nbtree.c.html#LN522"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN399"><span class='Ref_to_Member'>currTuples</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span>BLCKSZ <span class='Operator'>* </span><span class='Number'>2</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="nbtree.c.html#LN522"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN400"><span class='Ref_to_Member'>markTuples</span></a> <span class='Operator'>= </span><a href="nbtree.c.html#LN522"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN399"><span class='Ref_to_Member'>currTuples</span></a> <span class='Operator'>+ </span>BLCKSZ<span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Reset the scan keys. Note that keys ordering stuff moved to _bt_first. 
     * - vadim 05/05/97 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN519"><span class='Ref_to_Parameter'>scankey</span></a> <span class='Operator'>&& </span><a href="nbtree.c.html#LN519"><span class='Ref_to_Parameter'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN90"><span class='Ref_to_Member'>numberOfKeys</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="../../../include/c.h.html#LN1057"><span class='Ref_to_Macro'>memmove</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN519"><span class='Ref_to_Parameter'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN92"><span class='Ref_to_Member'>keyData</span></a><span class='Delimiter'>, 
</span>                <a href="nbtree.c.html#LN519"><span class='Ref_to_Parameter'>scankey</span></a><span class='Delimiter'>, 
</span>                <a href="nbtree.c.html#LN519"><span class='Ref_to_Parameter'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN90"><span class='Ref_to_Member'>numberOfKeys</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/access/skey.h.html#LN63"><span class='Ref_to_Struct'>ScanKeyData</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN522"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN378"><span class='Ref_to_Member'>numberOfKeys</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* until _bt_preprocess_keys sets it */ 
</span> 
    <span class='Comment_Multi_Line'>/* If any keys are SK_SEARCHARRAY type, set up array-key info */ 
</span>    <a href="nbtutils.c.html#LN190"><span class='Ref_to_Func'>_bt_preprocess_array_keys</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN519"><span class='Ref_to_Parameter'>scan</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end btrescan &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 *  btendscan() -- close down a scan 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN579"></a><span class='Declare_Function'>btendscan</span><span class='Parentheses'>(</span><a href="../../../include/access/genam.h.html#LN85"><span class='Ref_to_Typedef'>IndexScanDesc</span></a> <span class='Declare_Parameter'>scan</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN581"></a>    <a href="../../../include/access/nbtree.h.html#LN416"><span class='Ref_to_Typedef'>BTScanOpaque</span></a> <span class='Declare_Local'>so</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN416"><span class='Ref_to_Typedef'>BTScanOpaque</span></a><span class='Parentheses'>) </span><a href="nbtree.c.html#LN579"><span class='Ref_to_Parameter'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN104"><span class='Ref_to_Member'>opaque</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* we aren't holding any read locks, but gotta drop the pins */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN349"><span class='Ref_to_Macro'>BTScanPosIsValid</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN581"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN412"><span class='Ref_to_Member'>currPos</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Before leaving current page, deal with any killed items */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN581"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN392"><span class='Ref_to_Member'>numKilled</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <a href="../../../include/access/nbtree.h.html#LN529"><span class='Ref_to_Proto'>_bt_killitems</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN579"><span class='Ref_to_Parameter'>scan</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/access/nbtree.h.html#LN343"><span class='Ref_to_Macro'>BTScanPosUnpinIfPinned</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN581"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN412"><span class='Ref_to_Member'>currPos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="nbtree.c.html#LN581"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN409"><span class='Ref_to_Member'>markItemIndex</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <a href="../../../include/access/nbtree.h.html#LN343"><span class='Ref_to_Macro'>BTScanPosUnpinIfPinned</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN581"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN413"><span class='Ref_to_Member'>markPos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* No need to invalidate positions, the RAM is about to be freed. */ 
</span> 
    <span class='Comment_Multi_Line'>/* Release storage */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN581"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN379"><span class='Ref_to_Member'>keyData</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN581"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN379"><span class='Ref_to_Member'>keyData</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* so-&GT;arrayKeyData and so-&GT;arrayKeys are in arrayContext */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN581"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN388"><span class='Ref_to_Member'>arrayContext</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/memutils.h.html#LN74"><span class='Ref_to_Proto'>MemoryContextDelete</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN581"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN388"><span class='Ref_to_Member'>arrayContext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN581"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN391"><span class='Ref_to_Member'>killedItems</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN581"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN391"><span class='Ref_to_Member'>killedItems</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN581"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN399"><span class='Ref_to_Member'>currTuples</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN581"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN399"><span class='Ref_to_Member'>currTuples</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* so-&GT;markTuples should not be pfree'd, see btrescan */ 
</span>    <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN581"><span class='Ref_To_Local'>so</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end btendscan &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 *  btmarkpos() -- save current scan position 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN615"></a><span class='Declare_Function'>btmarkpos</span><span class='Parentheses'>(</span><a href="../../../include/access/genam.h.html#LN85"><span class='Ref_to_Typedef'>IndexScanDesc</span></a> <span class='Declare_Parameter'>scan</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN617"></a>    <a href="../../../include/access/nbtree.h.html#LN416"><span class='Ref_to_Typedef'>BTScanOpaque</span></a> <span class='Declare_Local'>so</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN416"><span class='Ref_to_Typedef'>BTScanOpaque</span></a><span class='Parentheses'>) </span><a href="nbtree.c.html#LN615"><span class='Ref_to_Parameter'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN104"><span class='Ref_to_Member'>opaque</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* There may be an old mark with a pin (but no lock). */ 
</span>    <a href="../../../include/access/nbtree.h.html#LN343"><span class='Ref_to_Macro'>BTScanPosUnpinIfPinned</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN617"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN413"><span class='Ref_to_Member'>markPos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Just record the current itemIndex.  If we later step to next page 
     * before releasing the marked position, _bt_steppage makes a full copy of 
     * the currPos struct in markPos.  If (as often happens) the mark is moved 
     * before we leave the page, we don't have to do that work. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN349"><span class='Ref_to_Macro'>BTScanPosIsValid</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN617"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN412"><span class='Ref_to_Member'>currPos</span></a><span class='Parentheses'>))</span> 
        <a href="nbtree.c.html#LN617"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN409"><span class='Ref_to_Member'>markItemIndex</span></a> <span class='Operator'>= </span><a href="nbtree.c.html#LN617"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN412"><span class='Ref_to_Member'>currPos</span></a><span class='Operator'>.</span><a href="../../../include/access/nbtree.h.html#LN325"><span class='Ref_to_Member'>itemIndex</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../include/access/nbtree.h.html#LN355"><span class='Ref_to_Macro'>BTScanPosInvalidate</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN617"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN413"><span class='Ref_to_Member'>markPos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="nbtree.c.html#LN617"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN409"><span class='Ref_to_Member'>markItemIndex</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Also record the current positions of any array keys */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN617"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN383"><span class='Ref_to_Member'>numArrayKeys</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/access/nbtree.h.html#LN523"><span class='Ref_to_Proto'>_bt_mark_array_keys</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN615"><span class='Ref_to_Parameter'>scan</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end btmarkpos &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 *  btrestrpos() -- restore scan to last saved position 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN645"></a><span class='Declare_Function'>btrestrpos</span><span class='Parentheses'>(</span><a href="../../../include/access/genam.h.html#LN85"><span class='Ref_to_Typedef'>IndexScanDesc</span></a> <span class='Declare_Parameter'>scan</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN647"></a>    <a href="../../../include/access/nbtree.h.html#LN416"><span class='Ref_to_Typedef'>BTScanOpaque</span></a> <span class='Declare_Local'>so</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN416"><span class='Ref_to_Typedef'>BTScanOpaque</span></a><span class='Parentheses'>) </span><a href="nbtree.c.html#LN645"><span class='Ref_to_Parameter'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN104"><span class='Ref_to_Member'>opaque</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Restore the marked positions of any array keys */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN647"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN383"><span class='Ref_to_Member'>numArrayKeys</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/access/nbtree.h.html#LN524"><span class='Ref_to_Proto'>_bt_restore_array_keys</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN645"><span class='Ref_to_Parameter'>scan</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN647"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN409"><span class='Ref_to_Member'>markItemIndex</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * The scan has never moved to a new page since the last mark.  Just 
         * restore the itemIndex. 
         * 
         * NB: In this case we can't count on anything in so-&GT;markPos to be 
         * accurate. 
         */ 
</span>        <a href="nbtree.c.html#LN647"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN412"><span class='Ref_to_Member'>currPos</span></a><span class='Operator'>.</span><a href="../../../include/access/nbtree.h.html#LN325"><span class='Ref_to_Member'>itemIndex</span></a> <span class='Operator'>= </span><a href="nbtree.c.html#LN647"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN409"><span class='Ref_to_Member'>markItemIndex</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * The scan moved to a new page after last mark or restore, and we are 
         * now restoring to the marked page.  We aren't holding any read 
         * locks, but if we're still holding the pin for the current position, 
         * we must drop it. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN349"><span class='Ref_to_Macro'>BTScanPosIsValid</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN647"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN412"><span class='Ref_to_Member'>currPos</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Before leaving current page, deal with any killed items */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN647"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN392"><span class='Ref_to_Member'>numKilled</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <a href="../../../include/access/nbtree.h.html#LN529"><span class='Ref_to_Proto'>_bt_killitems</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN645"><span class='Ref_to_Parameter'>scan</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/access/nbtree.h.html#LN343"><span class='Ref_to_Macro'>BTScanPosUnpinIfPinned</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN647"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN412"><span class='Ref_to_Member'>currPos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN349"><span class='Ref_to_Macro'>BTScanPosIsValid</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN647"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN413"><span class='Ref_to_Member'>markPos</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* bump pin on mark buffer for assignment to current buffer */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN332"><span class='Ref_to_Macro'>BTScanPosIsPinned</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN647"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN413"><span class='Ref_to_Member'>markPos</span></a><span class='Parentheses'>))</span> 
                <a href="../../../include/storage/bufmgr.h.html#LN177"><span class='Ref_to_Proto'>IncrBufferRefCount</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN647"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN413"><span class='Ref_to_Member'>markPos</span></a><span class='Operator'>.</span><a href="../../../include/access/nbtree.h.html#LN295"><span class='Ref_to_Member'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            memcpy<span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nbtree.c.html#LN647"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN412"><span class='Ref_to_Member'>currPos</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nbtree.c.html#LN647"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN413"><span class='Ref_to_Member'>markPos</span></a><span class='Delimiter'>, 
</span>                   <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN293"><span class='Ref_to_Struct'>BTScanPosData</span></a><span class='Delimiter'>, </span>items<span class='Delimiter'>[</span><span class='Number'>1</span><span class='Delimiter'>]</span><span class='Parentheses'>) </span><span class='Operator'>+ 
</span>                   <a href="nbtree.c.html#LN647"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN413"><span class='Ref_to_Member'>markPos</span></a><span class='Operator'>.</span><a href="../../../include/access/nbtree.h.html#LN324"><span class='Ref_to_Member'>lastItem</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN286"><span class='Ref_to_Struct'>BTScanPosItem</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN647"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN399"><span class='Ref_to_Member'>currTuples</span></a><span class='Parentheses'>) 
</span>                memcpy<span class='Parentheses'>(</span><a href="nbtree.c.html#LN647"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN399"><span class='Ref_to_Member'>currTuples</span></a><span class='Delimiter'>, </span><a href="nbtree.c.html#LN647"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN400"><span class='Ref_to_Member'>markTuples</span></a><span class='Delimiter'>, 
</span>                       <a href="nbtree.c.html#LN647"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN413"><span class='Ref_to_Member'>markPos</span></a><span class='Operator'>.</span><a href="../../../include/access/nbtree.h.html#LN314"><span class='Ref_to_Member'>nextTupleOffset</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
            <a href="../../../include/access/nbtree.h.html#LN355"><span class='Ref_to_Macro'>BTScanPosInvalidate</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN647"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN412"><span class='Ref_to_Member'>currPos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end btrestrpos &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * btestimateparallelscan -- estimate storage for BTParallelScanDescData 
 */ 
</span><a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a> 
<a name="LN701"></a><span class='Declare_Function'>btestimateparallelscan</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="nbtree.c.html#LN91"><span class='Ref_to_Struct'>BTParallelScanDescData</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * btinitparallelscan -- initialize BTParallelScanDesc for parallel btree scan 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN710"></a><span class='Declare_Function'>btinitparallelscan</span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>target</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN712"></a>    <a href="nbtree.c.html#LN104"><span class='Ref_to_Typedef'>BTParallelScanDesc</span></a> <span class='Declare_Local'>bt_target</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="nbtree.c.html#LN104"><span class='Ref_to_Typedef'>BTParallelScanDesc</span></a><span class='Parentheses'>) </span><a href="nbtree.c.html#LN710"><span class='Ref_to_Parameter'>target</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/spin.h.html#LN59"><span class='Ref_to_Macro'>SpinLockInit</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nbtree.c.html#LN712"><span class='Ref_To_Local'>bt_target</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN100"><span class='Ref_to_Member'>btps_mutex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN712"><span class='Ref_To_Local'>bt_target</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN93"><span class='Ref_to_Member'>btps_scanPage</span></a> <span class='Operator'>= </span><a href="../../../include/storage/block.h.html#LN32"><span class='Ref_to_Const'>InvalidBlockNumber</span></a><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN712"><span class='Ref_To_Local'>bt_target</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN94"><span class='Ref_to_Member'>btps_pageStatus</span></a> <span class='Operator'>= </span><a href="nbtree.c.html#LN81"><span class='Ref_to_EnumConst'>BTPARALLEL_NOT_INITIALIZED</span></a><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN712"><span class='Ref_To_Local'>bt_target</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN97"><span class='Ref_to_Member'>btps_arrayKeyCount</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/condition_variable.h.html#LN34"><span class='Ref_to_Proto'>ConditionVariableInit</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nbtree.c.html#LN712"><span class='Ref_To_Local'>bt_target</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN101"><span class='Ref_to_Member'>btps_cv</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 *  btparallelrescan() -- reset parallel scan 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN725"></a><span class='Declare_Function'>btparallelrescan</span><span class='Parentheses'>(</span><a href="../../../include/access/genam.h.html#LN85"><span class='Ref_to_Typedef'>IndexScanDesc</span></a> <span class='Declare_Parameter'>scan</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN727"></a>    <a href="nbtree.c.html#LN104"><span class='Ref_to_Typedef'>BTParallelScanDesc</span></a> <span class='Declare_Local'>btscan</span><span class='Delimiter'>; 
</span><a name="LN728"></a>    <a href="../../../include/access/genam.h.html#LN88"><span class='Ref_to_Typedef'>ParallelIndexScanDesc</span></a> <span class='Declare_Local'>parallel_scan</span> <span class='Operator'>= </span><a href="nbtree.c.html#LN725"><span class='Ref_to_Parameter'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN138"><span class='Ref_to_Member'>parallel_scan</span></a><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nbtree.c.html#LN728"><span class='Ref_To_Local'>parallel_scan</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="nbtree.c.html#LN727"><span class='Ref_To_Local'>btscan</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="nbtree.c.html#LN104"><span class='Ref_to_Typedef'>BTParallelScanDesc</span></a><span class='Parentheses'>) </span><a href="../../../include/c.h.html#LN534"><span class='Ref_to_Macro'>OffsetToPointer</span></a><span class='Parentheses'>((</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nbtree.c.html#LN728"><span class='Ref_To_Local'>parallel_scan</span></a><span class='Delimiter'>, 
</span>                                                  <a href="nbtree.c.html#LN728"><span class='Ref_To_Local'>parallel_scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN146"><span class='Ref_to_Member'>ps_offset</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * In theory, we don't need to acquire the spinlock here, because there 
     * shouldn't be any other workers running at this point, but we do so for 
     * consistency. 
     */ 
</span>    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nbtree.c.html#LN727"><span class='Ref_To_Local'>btscan</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN100"><span class='Ref_to_Member'>btps_mutex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN727"><span class='Ref_To_Local'>btscan</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN93"><span class='Ref_to_Member'>btps_scanPage</span></a> <span class='Operator'>= </span><a href="../../../include/storage/block.h.html#LN32"><span class='Ref_to_Const'>InvalidBlockNumber</span></a><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN727"><span class='Ref_To_Local'>btscan</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN94"><span class='Ref_to_Member'>btps_pageStatus</span></a> <span class='Operator'>= </span><a href="nbtree.c.html#LN81"><span class='Ref_to_EnumConst'>BTPARALLEL_NOT_INITIALIZED</span></a><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN727"><span class='Ref_To_Local'>btscan</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN97"><span class='Ref_to_Member'>btps_arrayKeyCount</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nbtree.c.html#LN727"><span class='Ref_To_Local'>btscan</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN100"><span class='Ref_to_Member'>btps_mutex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end btparallelrescan &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * _bt_parallel_seize() -- Begin the process of advancing the scan to a new 
 *      page.  Other scans must wait until we call bt_parallel_release() or 
 *      bt_parallel_done(). 
 * 
 * The return value is true if we successfully seized the scan and false 
 * if we did not.  The latter case occurs if no pages remain for the current 
 * set of scankeys. 
 * 
 * If the return value is true, *pageno returns the next or current page 
 * of the scan (depending on the scan direction).  An invalid block number 
 * means the scan hasn't yet started, and P_NONE means we've reached the end. 
 * The first time a participating process reaches the last page, it will return 
 * true and set *pageno to P_NONE; after that, further attempts to seize the 
 * scan will return false. 
 * 
 * Callers should ignore the value of pageno if the return value is false. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN766"></a><span class='Declare_Function'>_bt_parallel_seize</span><span class='Parentheses'>(</span><a href="../../../include/access/genam.h.html#LN85"><span class='Ref_to_Typedef'>IndexScanDesc</span></a> <span class='Declare_Parameter'>scan</span><span class='Delimiter'>, </span><a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pageno</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN768"></a>    <a href="../../../include/access/nbtree.h.html#LN416"><span class='Ref_to_Typedef'>BTScanOpaque</span></a> <span class='Declare_Local'>so</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN416"><span class='Ref_to_Typedef'>BTScanOpaque</span></a><span class='Parentheses'>) </span><a href="nbtree.c.html#LN766"><span class='Ref_to_Parameter'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN104"><span class='Ref_to_Member'>opaque</span></a><span class='Delimiter'>; 
</span><a name="LN769"></a>    <a href="nbtree.c.html#LN79"><span class='Ref_to_Typedef'>BTPS_State</span></a>  <span class='Declare_Local'>pageStatus</span><span class='Delimiter'>; 
</span><a name="LN770"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>exit_loop</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN771"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>status</span> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span><a name="LN772"></a>    <a href="../../../include/access/genam.h.html#LN88"><span class='Ref_to_Typedef'>ParallelIndexScanDesc</span></a> <span class='Declare_Local'>parallel_scan</span> <span class='Operator'>= </span><a href="nbtree.c.html#LN766"><span class='Ref_to_Parameter'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN138"><span class='Ref_to_Member'>parallel_scan</span></a><span class='Delimiter'>; 
</span><a name="LN773"></a>    <a href="nbtree.c.html#LN104"><span class='Ref_to_Typedef'>BTParallelScanDesc</span></a> <span class='Declare_Local'>btscan</span><span class='Delimiter'>; 
</span> 
    <span class='Operator'>*</span><a href="nbtree.c.html#LN766"><span class='Ref_to_Parameter'>pageno</span></a> <span class='Operator'>= </span><a href="../../../include/access/nbtree.h.html#LN167"><span class='Ref_to_Const'>P_NONE</span></a><span class='Delimiter'>; 
</span> 
    <a href="nbtree.c.html#LN773"><span class='Ref_To_Local'>btscan</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="nbtree.c.html#LN104"><span class='Ref_to_Typedef'>BTParallelScanDesc</span></a><span class='Parentheses'>) </span><a href="../../../include/c.h.html#LN534"><span class='Ref_to_Macro'>OffsetToPointer</span></a><span class='Parentheses'>((</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nbtree.c.html#LN772"><span class='Ref_To_Local'>parallel_scan</span></a><span class='Delimiter'>, 
</span>                                                  <a href="nbtree.c.html#LN772"><span class='Ref_To_Local'>parallel_scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN146"><span class='Ref_to_Member'>ps_offset</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>while</span> <span class='Parentheses'>(</span><span class='Number'>1</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nbtree.c.html#LN773"><span class='Ref_To_Local'>btscan</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN100"><span class='Ref_to_Member'>btps_mutex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="nbtree.c.html#LN769"><span class='Ref_To_Local'>pageStatus</span></a> <span class='Operator'>= </span><a href="nbtree.c.html#LN773"><span class='Ref_To_Local'>btscan</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN94"><span class='Ref_to_Member'>btps_pageStatus</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN768"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN385"><span class='Ref_to_Member'>arrayKeyCount</span></a> <span class='Operator'>&LT; </span><a href="nbtree.c.html#LN773"><span class='Ref_To_Local'>btscan</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN97"><span class='Ref_to_Member'>btps_arrayKeyCount</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Parallel scan has already advanced to a new set of scankeys. */ 
</span>            <a href="nbtree.c.html#LN771"><span class='Ref_To_Local'>status</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN769"><span class='Ref_To_Local'>pageStatus</span></a> <span class='Operator'>== </span><a href="nbtree.c.html#LN84"><span class='Ref_to_EnumConst'>BTPARALLEL_DONE</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * We're done with this set of scankeys.  This may be the end, or 
             * there could be more sets to try. 
             */ 
</span>            <a href="nbtree.c.html#LN771"><span class='Ref_To_Local'>status</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN769"><span class='Ref_To_Local'>pageStatus</span></a> <span class='Operator'>!= </span><a href="nbtree.c.html#LN82"><span class='Ref_to_EnumConst'>BTPARALLEL_ADVANCING</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * We have successfully seized control of the scan for the purpose 
             * of advancing it to a new page! 
             */ 
</span>            <a href="nbtree.c.html#LN773"><span class='Ref_To_Local'>btscan</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN94"><span class='Ref_to_Member'>btps_pageStatus</span></a> <span class='Operator'>= </span><a href="nbtree.c.html#LN82"><span class='Ref_to_EnumConst'>BTPARALLEL_ADVANCING</span></a><span class='Delimiter'>; 
</span>            <span class='Operator'>*</span><a href="nbtree.c.html#LN766"><span class='Ref_to_Parameter'>pageno</span></a> <span class='Operator'>= </span><a href="nbtree.c.html#LN773"><span class='Ref_To_Local'>btscan</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN93"><span class='Ref_to_Member'>btps_scanPage</span></a><span class='Delimiter'>; 
</span>            <a href="nbtree.c.html#LN770"><span class='Ref_To_Local'>exit_loop</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nbtree.c.html#LN773"><span class='Ref_To_Local'>btscan</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN100"><span class='Ref_to_Member'>btps_mutex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN770"><span class='Ref_To_Local'>exit_loop</span></a> <span class='Operator'>|| !</span><a href="nbtree.c.html#LN771"><span class='Ref_To_Local'>status</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/condition_variable.h.html#LN44"><span class='Ref_to_Proto'>ConditionVariableSleep</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nbtree.c.html#LN773"><span class='Ref_To_Local'>btscan</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN101"><span class='Ref_to_Member'>btps_cv</span></a><span class='Delimiter'>, </span><a href="../../../include/pgstat.h.html#LN802"><span class='Ref_to_EnumConst'>WAIT_EVENT_BTREE_PAGE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while 1 &raquo; </span> 
    <a href="../../../include/storage/condition_variable.h.html#LN45"><span class='Ref_to_Proto'>ConditionVariableCancelSleep</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="nbtree.c.html#LN771"><span class='Ref_To_Local'>status</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end _bt_parallel_seize &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * _bt_parallel_release() -- Complete the process of advancing the scan to a 
 *      new page.  We now have the new value btps_scanPage; some other backend 
 *      can now begin advancing the scan. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN824"></a><span class='Declare_Function'>_bt_parallel_release</span><span class='Parentheses'>(</span><a href="../../../include/access/genam.h.html#LN85"><span class='Ref_to_Typedef'>IndexScanDesc</span></a> <span class='Declare_Parameter'>scan</span><span class='Delimiter'>, </span><a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Parameter'>scan_page</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN826"></a>    <a href="../../../include/access/genam.h.html#LN88"><span class='Ref_to_Typedef'>ParallelIndexScanDesc</span></a> <span class='Declare_Local'>parallel_scan</span> <span class='Operator'>= </span><a href="nbtree.c.html#LN824"><span class='Ref_to_Parameter'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN138"><span class='Ref_to_Member'>parallel_scan</span></a><span class='Delimiter'>; 
</span><a name="LN827"></a>    <a href="nbtree.c.html#LN104"><span class='Ref_to_Typedef'>BTParallelScanDesc</span></a> <span class='Declare_Local'>btscan</span><span class='Delimiter'>; 
</span> 
    <a href="nbtree.c.html#LN827"><span class='Ref_To_Local'>btscan</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="nbtree.c.html#LN104"><span class='Ref_to_Typedef'>BTParallelScanDesc</span></a><span class='Parentheses'>) </span><a href="../../../include/c.h.html#LN534"><span class='Ref_to_Macro'>OffsetToPointer</span></a><span class='Parentheses'>((</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nbtree.c.html#LN826"><span class='Ref_To_Local'>parallel_scan</span></a><span class='Delimiter'>, 
</span>                                                  <a href="nbtree.c.html#LN826"><span class='Ref_To_Local'>parallel_scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN146"><span class='Ref_to_Member'>ps_offset</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nbtree.c.html#LN827"><span class='Ref_To_Local'>btscan</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN100"><span class='Ref_to_Member'>btps_mutex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN827"><span class='Ref_To_Local'>btscan</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN93"><span class='Ref_to_Member'>btps_scanPage</span></a> <span class='Operator'>= </span><a href="nbtree.c.html#LN824"><span class='Ref_to_Parameter'>scan_page</span></a><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN827"><span class='Ref_To_Local'>btscan</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN94"><span class='Ref_to_Member'>btps_pageStatus</span></a> <span class='Operator'>= </span><a href="nbtree.c.html#LN83"><span class='Ref_to_EnumConst'>BTPARALLEL_IDLE</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nbtree.c.html#LN827"><span class='Ref_To_Local'>btscan</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN100"><span class='Ref_to_Member'>btps_mutex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/condition_variable.h.html#LN55"><span class='Ref_to_Proto'>ConditionVariableSignal</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nbtree.c.html#LN827"><span class='Ref_To_Local'>btscan</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN101"><span class='Ref_to_Member'>btps_cv</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * _bt_parallel_done() -- Mark the parallel scan as complete. 
 * 
 * When there are no pages left to scan, this function should be called to 
 * notify other workers.  Otherwise, they might wait forever for the scan to 
 * advance to the next page. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN847"></a><span class='Declare_Function'>_bt_parallel_done</span><span class='Parentheses'>(</span><a href="../../../include/access/genam.h.html#LN85"><span class='Ref_to_Typedef'>IndexScanDesc</span></a> <span class='Declare_Parameter'>scan</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN849"></a>    <a href="../../../include/access/nbtree.h.html#LN416"><span class='Ref_to_Typedef'>BTScanOpaque</span></a> <span class='Declare_Local'>so</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN416"><span class='Ref_to_Typedef'>BTScanOpaque</span></a><span class='Parentheses'>) </span><a href="nbtree.c.html#LN847"><span class='Ref_to_Parameter'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN104"><span class='Ref_to_Member'>opaque</span></a><span class='Delimiter'>; 
</span><a name="LN850"></a>    <a href="../../../include/access/genam.h.html#LN88"><span class='Ref_to_Typedef'>ParallelIndexScanDesc</span></a> <span class='Declare_Local'>parallel_scan</span> <span class='Operator'>= </span><a href="nbtree.c.html#LN847"><span class='Ref_to_Parameter'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN138"><span class='Ref_to_Member'>parallel_scan</span></a><span class='Delimiter'>; 
</span><a name="LN851"></a>    <a href="nbtree.c.html#LN104"><span class='Ref_to_Typedef'>BTParallelScanDesc</span></a> <span class='Declare_Local'>btscan</span><span class='Delimiter'>; 
</span><a name="LN852"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>status_changed</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Do nothing, for non-parallel scans */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN850"><span class='Ref_To_Local'>parallel_scan</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <a href="nbtree.c.html#LN851"><span class='Ref_To_Local'>btscan</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="nbtree.c.html#LN104"><span class='Ref_to_Typedef'>BTParallelScanDesc</span></a><span class='Parentheses'>) </span><a href="../../../include/c.h.html#LN534"><span class='Ref_to_Macro'>OffsetToPointer</span></a><span class='Parentheses'>((</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nbtree.c.html#LN850"><span class='Ref_To_Local'>parallel_scan</span></a><span class='Delimiter'>, 
</span>                                                  <a href="nbtree.c.html#LN850"><span class='Ref_To_Local'>parallel_scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN146"><span class='Ref_to_Member'>ps_offset</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Mark the parallel scan as done for this combination of scan keys, 
     * unless some other process already did so.  See also 
     * _bt_advance_array_keys. 
     */ 
</span>    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nbtree.c.html#LN851"><span class='Ref_To_Local'>btscan</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN100"><span class='Ref_to_Member'>btps_mutex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN849"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN385"><span class='Ref_to_Member'>arrayKeyCount</span></a> <span class='Operator'>&GT;= </span><a href="nbtree.c.html#LN851"><span class='Ref_To_Local'>btscan</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN97"><span class='Ref_to_Member'>btps_arrayKeyCount</span></a> <span class='Operator'>&& 
</span>        <a href="nbtree.c.html#LN851"><span class='Ref_To_Local'>btscan</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN94"><span class='Ref_to_Member'>btps_pageStatus</span></a> <span class='Operator'>!= </span><a href="nbtree.c.html#LN84"><span class='Ref_to_EnumConst'>BTPARALLEL_DONE</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="nbtree.c.html#LN851"><span class='Ref_To_Local'>btscan</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN94"><span class='Ref_to_Member'>btps_pageStatus</span></a> <span class='Operator'>= </span><a href="nbtree.c.html#LN84"><span class='Ref_to_EnumConst'>BTPARALLEL_DONE</span></a><span class='Delimiter'>; 
</span>        <a href="nbtree.c.html#LN852"><span class='Ref_To_Local'>status_changed</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nbtree.c.html#LN851"><span class='Ref_To_Local'>btscan</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN100"><span class='Ref_to_Member'>btps_mutex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* wake up all the workers associated with this parallel scan */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN852"><span class='Ref_To_Local'>status_changed</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/condition_variable.h.html#LN56"><span class='Ref_to_Proto'>ConditionVariableBroadcast</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nbtree.c.html#LN851"><span class='Ref_To_Local'>btscan</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN101"><span class='Ref_to_Member'>btps_cv</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end _bt_parallel_done &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * _bt_parallel_advance_array_keys() -- Advances the parallel scan for array 
 *          keys. 
 * 
 * Updates the count of array keys processed for both local and parallel 
 * scans. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN888"></a><span class='Declare_Function'>_bt_parallel_advance_array_keys</span><span class='Parentheses'>(</span><a href="../../../include/access/genam.h.html#LN85"><span class='Ref_to_Typedef'>IndexScanDesc</span></a> <span class='Declare_Parameter'>scan</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN890"></a>    <a href="../../../include/access/nbtree.h.html#LN416"><span class='Ref_to_Typedef'>BTScanOpaque</span></a> <span class='Declare_Local'>so</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN416"><span class='Ref_to_Typedef'>BTScanOpaque</span></a><span class='Parentheses'>) </span><a href="nbtree.c.html#LN888"><span class='Ref_to_Parameter'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN104"><span class='Ref_to_Member'>opaque</span></a><span class='Delimiter'>; 
</span><a name="LN891"></a>    <a href="../../../include/access/genam.h.html#LN88"><span class='Ref_to_Typedef'>ParallelIndexScanDesc</span></a> <span class='Declare_Local'>parallel_scan</span> <span class='Operator'>= </span><a href="nbtree.c.html#LN888"><span class='Ref_to_Parameter'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN138"><span class='Ref_to_Member'>parallel_scan</span></a><span class='Delimiter'>; 
</span><a name="LN892"></a>    <a href="nbtree.c.html#LN104"><span class='Ref_to_Typedef'>BTParallelScanDesc</span></a> <span class='Declare_Local'>btscan</span><span class='Delimiter'>; 
</span> 
    <a href="nbtree.c.html#LN892"><span class='Ref_To_Local'>btscan</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="nbtree.c.html#LN104"><span class='Ref_to_Typedef'>BTParallelScanDesc</span></a><span class='Parentheses'>) </span><a href="../../../include/c.h.html#LN534"><span class='Ref_to_Macro'>OffsetToPointer</span></a><span class='Parentheses'>((</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nbtree.c.html#LN891"><span class='Ref_To_Local'>parallel_scan</span></a><span class='Delimiter'>, 
</span>                                                  <a href="nbtree.c.html#LN891"><span class='Ref_To_Local'>parallel_scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN146"><span class='Ref_to_Member'>ps_offset</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="nbtree.c.html#LN890"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN385"><span class='Ref_to_Member'>arrayKeyCount</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nbtree.c.html#LN892"><span class='Ref_To_Local'>btscan</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN100"><span class='Ref_to_Member'>btps_mutex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN892"><span class='Ref_To_Local'>btscan</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN94"><span class='Ref_to_Member'>btps_pageStatus</span></a> <span class='Operator'>== </span><a href="nbtree.c.html#LN84"><span class='Ref_to_EnumConst'>BTPARALLEL_DONE</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="nbtree.c.html#LN892"><span class='Ref_To_Local'>btscan</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN93"><span class='Ref_to_Member'>btps_scanPage</span></a> <span class='Operator'>= </span><a href="../../../include/storage/block.h.html#LN32"><span class='Ref_to_Const'>InvalidBlockNumber</span></a><span class='Delimiter'>; 
</span>        <a href="nbtree.c.html#LN892"><span class='Ref_To_Local'>btscan</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN94"><span class='Ref_to_Member'>btps_pageStatus</span></a> <span class='Operator'>= </span><a href="nbtree.c.html#LN81"><span class='Ref_to_EnumConst'>BTPARALLEL_NOT_INITIALIZED</span></a><span class='Delimiter'>; 
</span>        <a href="nbtree.c.html#LN892"><span class='Ref_To_Local'>btscan</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN97"><span class='Ref_to_Member'>btps_arrayKeyCount</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nbtree.c.html#LN892"><span class='Ref_To_Local'>btscan</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN100"><span class='Ref_to_Member'>btps_mutex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end _bt_parallel_advance_array_keys &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Bulk deletion of all index entries pointing to a set of heap tuples. 
 * The set of target tuples is specified via a callback routine that tells 
 * whether any given heap tuple (identified by ItemPointer) is being deleted. 
 * 
 * Result: a palloc'd struct containing statistical info for VACUUM displays. 
 */ 
</span><a href="../../../include/access/genam.h.html#LN70"><span class='Ref_to_Struct'>IndexBulkDeleteResult</span></a> <span class='Operator'>* 
</span><a name="LN916"></a><span class='Declare_Function'>btbulkdelete</span><span class='Parentheses'>(</span><a href="../../../include/access/genam.h.html#LN43"><span class='Ref_to_Struct'>IndexVacuumInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>info</span><span class='Delimiter'>, </span><a href="../../../include/access/genam.h.html#LN70"><span class='Ref_to_Struct'>IndexBulkDeleteResult</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stats</span><span class='Delimiter'>, 
</span><a name="LN917"></a>             <a href="../../../include/access/genam.h.html#LN82"><span class='Ref_to_Typedef'>IndexBulkDeleteCallback</span></a> <span class='Declare_Parameter'>callback</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>callback_state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN919"></a>    <a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>rel</span> <span class='Operator'>= </span><a href="nbtree.c.html#LN916"><span class='Ref_to_Parameter'>info</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/genam.h.html#LN45"><span class='Ref_to_Member'>index</span></a><span class='Delimiter'>; 
</span><a name="LN920"></a>    <a href="../../../include/access/nbtree.h.html#LN25"><span class='Ref_to_Typedef'>BTCycleId</span></a>   <span class='Declare_Local'>cycleid</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* allocate stats if first time through, else re-use existing struct */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN916"><span class='Ref_to_Parameter'>stats</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="nbtree.c.html#LN916"><span class='Ref_to_Parameter'>stats</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/genam.h.html#LN70"><span class='Ref_to_Struct'>IndexBulkDeleteResult</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/access/genam.h.html#LN70"><span class='Ref_to_Struct'>IndexBulkDeleteResult</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Establish the vacuum cycle ID to use for this scan */ 
</span>    <span class='Comment_Multi_Line'>/* The ENSURE stuff ensures we clean up shared memory on failure */ 
</span>    <a href="../../../include/storage/ipc.h.html#LN46"><span class='Ref_to_Macro'>PG_ENSURE_ERROR_CLEANUP</span></a><span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN533"><span class='Ref_to_Proto'>_bt_end_vacuum_callback</span></a><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN919"><span class='Ref_To_Local'>rel</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>{ 
</span>        <a href="nbtree.c.html#LN920"><span class='Ref_To_Local'>cycleid</span></a> <span class='Operator'>= </span><a href="../../../include/access/nbtree.h.html#LN531"><span class='Ref_to_Proto'>_bt_start_vacuum</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN919"><span class='Ref_To_Local'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="nbtree.c.html#LN113"><span class='Ref_to_Proto'>btvacuumscan</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN916"><span class='Ref_to_Parameter'>info</span></a><span class='Delimiter'>, </span><a href="nbtree.c.html#LN916"><span class='Ref_to_Parameter'>stats</span></a><span class='Delimiter'>, </span><a href="nbtree.c.html#LN917"><span class='Ref_to_Parameter'>callback</span></a><span class='Delimiter'>, </span><a href="nbtree.c.html#LN917"><span class='Ref_to_Parameter'>callback_state</span></a><span class='Delimiter'>, </span><a href="nbtree.c.html#LN920"><span class='Ref_To_Local'>cycleid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="../../../include/storage/ipc.h.html#LN51"><span class='Ref_to_Macro'>PG_END_ENSURE_ERROR_CLEANUP</span></a><span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN533"><span class='Ref_to_Proto'>_bt_end_vacuum_callback</span></a><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN919"><span class='Ref_To_Local'>rel</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/access/nbtree.h.html#LN532"><span class='Ref_to_Proto'>_bt_end_vacuum</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN919"><span class='Ref_To_Local'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="nbtree.c.html#LN916"><span class='Ref_to_Parameter'>stats</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end btbulkdelete &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Post-VACUUM cleanup. 
 * 
 * Result: a palloc'd struct containing statistical info for VACUUM displays. 
 */ 
</span><a href="../../../include/access/genam.h.html#LN70"><span class='Ref_to_Struct'>IndexBulkDeleteResult</span></a> <span class='Operator'>* 
</span><a name="LN946"></a><span class='Declare_Function'>btvacuumcleanup</span><span class='Parentheses'>(</span><a href="../../../include/access/genam.h.html#LN43"><span class='Ref_to_Struct'>IndexVacuumInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>info</span><span class='Delimiter'>, </span><a href="../../../include/access/genam.h.html#LN70"><span class='Ref_to_Struct'>IndexBulkDeleteResult</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stats</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* No-op in ANALYZE ONLY mode */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN946"><span class='Ref_to_Parameter'>info</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/genam.h.html#LN46"><span class='Ref_to_Member'>analyze_only</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="nbtree.c.html#LN946"><span class='Ref_to_Parameter'>stats</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If btbulkdelete was called, we need not do anything, just return the 
     * stats from the latest btbulkdelete call.  If it wasn't called, we must 
     * still do a pass over the index, to recycle any newly-recyclable pages 
     * and to obtain index statistics. 
     * 
     * Since we aren't going to actually delete any leaf items, there's no 
     * need to go through all the vacuum-cycle-ID pushups. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN946"><span class='Ref_to_Parameter'>stats</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="nbtree.c.html#LN946"><span class='Ref_to_Parameter'>stats</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/genam.h.html#LN70"><span class='Ref_to_Struct'>IndexBulkDeleteResult</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/access/genam.h.html#LN70"><span class='Ref_to_Struct'>IndexBulkDeleteResult</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="nbtree.c.html#LN113"><span class='Ref_to_Proto'>btvacuumscan</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN946"><span class='Ref_to_Parameter'>info</span></a><span class='Delimiter'>, </span><a href="nbtree.c.html#LN946"><span class='Ref_to_Parameter'>stats</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Finally, vacuum the FSM */ 
</span>    <a href="../../../include/storage/indexfsm.h.html#LN23"><span class='Ref_to_Proto'>IndexFreeSpaceMapVacuum</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN946"><span class='Ref_to_Parameter'>info</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/genam.h.html#LN45"><span class='Ref_to_Member'>index</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * It's quite possible for us to be fooled by concurrent page splits into 
     * double-counting some index tuples, so disbelieve any total that exceeds 
     * the underlying heap's count ... if we know that accurately.  Otherwise 
     * this might just make matters worse. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="nbtree.c.html#LN946"><span class='Ref_to_Parameter'>info</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/genam.h.html#LN47"><span class='Ref_to_Member'>estimated_count</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN946"><span class='Ref_to_Parameter'>stats</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/genam.h.html#LN75"><span class='Ref_to_Member'>num_index_tuples</span></a> <span class='Operator'>&GT; </span><a href="nbtree.c.html#LN946"><span class='Ref_to_Parameter'>info</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/genam.h.html#LN49"><span class='Ref_to_Member'>num_heap_tuples</span></a><span class='Parentheses'>) 
</span>            <a href="nbtree.c.html#LN946"><span class='Ref_to_Parameter'>stats</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/genam.h.html#LN75"><span class='Ref_to_Member'>num_index_tuples</span></a> <span class='Operator'>= </span><a href="nbtree.c.html#LN946"><span class='Ref_to_Parameter'>info</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/genam.h.html#LN49"><span class='Ref_to_Member'>num_heap_tuples</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="nbtree.c.html#LN946"><span class='Ref_to_Parameter'>stats</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end btvacuumcleanup &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * btvacuumscan --- scan the index for VACUUMing purposes 
 * 
 * This combines the functions of looking for leaf tuples that are deletable 
 * according to the vacuum callback, looking for empty pages that can be 
 * deleted, and looking for old deleted pages that can be recycled.  Both 
 * btbulkdelete and btvacuumcleanup invoke this (the latter only if no 
 * btbulkdelete call occurred). 
 * 
 * The caller is responsible for initially allocating/zeroing a stats struct 
 * and for obtaining a vacuum cycle ID if necessary. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN998"></a><span class='Declare_Function'>btvacuumscan</span><span class='Parentheses'>(</span><a href="../../../include/access/genam.h.html#LN43"><span class='Ref_to_Struct'>IndexVacuumInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>info</span><span class='Delimiter'>, </span><a href="../../../include/access/genam.h.html#LN70"><span class='Ref_to_Struct'>IndexBulkDeleteResult</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stats</span><span class='Delimiter'>, 
</span><a name="LN999"></a>             <a href="../../../include/access/genam.h.html#LN82"><span class='Ref_to_Typedef'>IndexBulkDeleteCallback</span></a> <span class='Declare_Parameter'>callback</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>callback_state</span><span class='Delimiter'>, 
</span><a name="LN1000"></a>             <a href="../../../include/access/nbtree.h.html#LN25"><span class='Ref_to_Typedef'>BTCycleId</span></a> <span class='Declare_Parameter'>cycleid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1002"></a>    <a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>rel</span> <span class='Operator'>= </span><a href="nbtree.c.html#LN998"><span class='Ref_to_Parameter'>info</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/genam.h.html#LN45"><span class='Ref_to_Member'>index</span></a><span class='Delimiter'>; 
</span><a name="LN1003"></a>    <a href="nbtree.c.html#LN54"><span class='Ref_to_Typedef'>BTVacState</span></a>  <span class='Declare_Local'>vstate</span><span class='Delimiter'>; 
</span><a name="LN1004"></a>    <a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Local'>num_pages</span><span class='Delimiter'>; 
</span><a name="LN1005"></a>    <a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Local'>blkno</span><span class='Delimiter'>; 
</span><a name="LN1006"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>needLock</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Reset counts that will be incremented during the scan; needed in case 
     * of multiple scans during a single VACUUM command 
     */ 
</span>    <a href="nbtree.c.html#LN998"><span class='Ref_to_Parameter'>stats</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/genam.h.html#LN74"><span class='Ref_to_Member'>estimated_count</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN998"><span class='Ref_to_Parameter'>stats</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/genam.h.html#LN75"><span class='Ref_to_Member'>num_index_tuples</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN998"><span class='Ref_to_Parameter'>stats</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/genam.h.html#LN77"><span class='Ref_to_Member'>pages_deleted</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Set up info to pass down to btvacuumpage */ 
</span>    <a href="nbtree.c.html#LN1003"><span class='Ref_To_Local'>vstate</span></a><span class='Operator'>.</span><a href="nbtree.c.html#LN56"><span class='Ref_to_Member'>info</span></a> <span class='Operator'>= </span><a href="nbtree.c.html#LN998"><span class='Ref_to_Parameter'>info</span></a><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN1003"><span class='Ref_To_Local'>vstate</span></a><span class='Operator'>.</span><a href="nbtree.c.html#LN57"><span class='Ref_to_Member'>stats</span></a> <span class='Operator'>= </span><a href="nbtree.c.html#LN998"><span class='Ref_to_Parameter'>stats</span></a><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN1003"><span class='Ref_To_Local'>vstate</span></a><span class='Operator'>.</span><a href="nbtree.c.html#LN58"><span class='Ref_to_Member'>callback</span></a> <span class='Operator'>= </span><a href="nbtree.c.html#LN999"><span class='Ref_to_Parameter'>callback</span></a><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN1003"><span class='Ref_To_Local'>vstate</span></a><span class='Operator'>.</span><a href="nbtree.c.html#LN59"><span class='Ref_to_Member'>callback_state</span></a> <span class='Operator'>= </span><a href="nbtree.c.html#LN999"><span class='Ref_to_Parameter'>callback_state</span></a><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN1003"><span class='Ref_To_Local'>vstate</span></a><span class='Operator'>.</span><a href="nbtree.c.html#LN60"><span class='Ref_to_Member'>cycleid</span></a> <span class='Operator'>= </span><a href="nbtree.c.html#LN1000"><span class='Ref_to_Parameter'>cycleid</span></a><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN1003"><span class='Ref_To_Local'>vstate</span></a><span class='Operator'>.</span><a href="nbtree.c.html#LN61"><span class='Ref_to_Member'>lastBlockVacuumed</span></a> <span class='Operator'>= </span><a href="../../../include/access/nbtree.h.html#LN108"><span class='Ref_to_Const'>BTREE_METAPAGE</span></a><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* Initialise at first block */ 
</span>    <a href="nbtree.c.html#LN1003"><span class='Ref_To_Local'>vstate</span></a><span class='Operator'>.</span><a href="nbtree.c.html#LN62"><span class='Ref_to_Member'>lastBlockLocked</span></a> <span class='Operator'>= </span><a href="../../../include/access/nbtree.h.html#LN108"><span class='Ref_to_Const'>BTREE_METAPAGE</span></a><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN1003"><span class='Ref_To_Local'>vstate</span></a><span class='Operator'>.</span><a href="nbtree.c.html#LN63"><span class='Ref_to_Member'>totFreePages</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Create a temporary memory context to run _bt_pagedel in */ 
</span>    <a href="nbtree.c.html#LN1003"><span class='Ref_To_Local'>vstate</span></a><span class='Operator'>.</span><a href="nbtree.c.html#LN64"><span class='Ref_to_Member'>pagedelcontext</span></a> <span class='Operator'>= </span><a href="../../../include/utils/memutils.h.html#LN145"><span class='Ref_to_Proto'>AllocSetContextCreate</span></a><span class='Parentheses'>(</span><a href="../../utils/mmgr/mcxt.c.html#LN36"><span class='Ref_to_Global_Var'>CurrentMemoryContext</span></a><span class='Delimiter'>, 
</span>                                                  <span class='String'>"_bt_pagedel"</span><span class='Delimiter'>, 
</span>                                                  <a href="../../../include/utils/memutils.h.html#LN164"><span class='Ref_to_Const'>ALLOCSET_DEFAULT_SIZES</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * The outer loop iterates over all index pages except the metapage, in 
     * physical order (we hope the kernel will cooperate in providing 
     * read-ahead for speed).  It is critical that we visit all leaf pages, 
     * including ones added after we start the scan, else we might fail to 
     * delete some deletable tuples.  Hence, we must repeatedly check the 
     * relation length.  We must acquire the relation-extension lock while 
     * doing so to avoid a race condition: if someone else is extending the 
     * relation, there is a window where bufmgr/smgr have created a new 
     * all-zero page but it hasn't yet been write-locked by _bt_getbuf(). If 
     * we manage to scan such a page here, we'll improperly assume it can be 
     * recycled.  Taking the lock synchronizes things enough to prevent a 
     * problem: either num_pages won't include the new page, or _bt_getbuf 
     * already has write lock on the buffer and it will be fully initialized 
     * before we can examine it.  (See also vacuumlazy.c, which has the same 
     * issue.)  Also, we need not worry if a page is added immediately after 
     * we look; the page splitting code already has write-lock on the left 
     * page before it adds a right page, so we must already have processed any 
     * tuples due to be moved into such a page. 
     * 
     * We can skip locking for new or temp relations, however, since no one 
     * else could be accessing them. 
     */ 
</span>    <a href="nbtree.c.html#LN1006"><span class='Ref_To_Local'>needLock</span></a> <span class='Operator'>= !</span><a href="../../../include/utils/rel.h.html#LN523"><span class='Ref_to_Macro'>RELATION_IS_LOCAL</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN1002"><span class='Ref_To_Local'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="nbtree.c.html#LN1005"><span class='Ref_To_Local'>blkno</span></a> <span class='Operator'>= </span><a href="../../../include/access/nbtree.h.html#LN108"><span class='Ref_to_Const'>BTREE_METAPAGE</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>;;</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Get the current relation length */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN1006"><span class='Ref_To_Local'>needLock</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/storage/lmgr.h.html#LN53"><span class='Ref_to_Proto'>LockRelationForExtension</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN1002"><span class='Ref_To_Local'>rel</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lockdefs.h.html#LN43"><span class='Ref_to_Const'>ExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="nbtree.c.html#LN1004"><span class='Ref_To_Local'>num_pages</span></a> <span class='Operator'>= </span><a href="../../../include/storage/bufmgr.h.html#LN198"><span class='Ref_to_Macro'>RelationGetNumberOfBlocks</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN1002"><span class='Ref_To_Local'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN1006"><span class='Ref_To_Local'>needLock</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/storage/lmgr.h.html#LN54"><span class='Ref_to_Proto'>UnlockRelationForExtension</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN1002"><span class='Ref_To_Local'>rel</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lockdefs.h.html#LN43"><span class='Ref_to_Const'>ExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Quit if we've scanned the whole relation */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN1005"><span class='Ref_To_Local'>blkno</span></a> <span class='Operator'>&GT;= </span><a href="nbtree.c.html#LN1004"><span class='Ref_To_Local'>num_pages</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* Iterate over pages, then loop back to recheck length */ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>; </span><a href="nbtree.c.html#LN1005"><span class='Ref_To_Local'>blkno</span></a> <span class='Operator'>&LT; </span><a href="nbtree.c.html#LN1004"><span class='Ref_To_Local'>num_pages</span></a><span class='Delimiter'>; </span><a href="nbtree.c.html#LN1005"><span class='Ref_To_Local'>blkno</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="nbtree.c.html#LN116"><span class='Ref_to_Proto'>btvacuumpage</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nbtree.c.html#LN1003"><span class='Ref_To_Local'>vstate</span></a><span class='Delimiter'>, </span><a href="nbtree.c.html#LN1005"><span class='Ref_To_Local'>blkno</span></a><span class='Delimiter'>, </span><a href="nbtree.c.html#LN1005"><span class='Ref_To_Local'>blkno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Check to see if we need to issue one final WAL record for this index, 
     * which may be needed for correctness on a hot standby node when non-MVCC 
     * index scans could take place. 
     * 
     * If the WAL is replayed in hot standby, the replay process needs to get 
     * cleanup locks on all index leaf pages, just as we've been doing here. 
     * However, we won't issue any WAL records about pages that have no items 
     * to be deleted.  For pages between pages we've vacuumed, the replay code 
     * will take locks under the direction of the lastBlockVacuumed fields in 
     * the XLOG_BTREE_VACUUM WAL records.  To cover pages after the last one 
     * we vacuum, we need to issue a dummy XLOG_BTREE_VACUUM WAL record 
     * against the last leaf page in the index, if that one wasn't vacuumed. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN158"><span class='Ref_to_Macro'>XLogStandbyInfoActive</span></a><span class='Parentheses'>() </span><span class='Operator'>&& 
</span>        <a href="nbtree.c.html#LN1003"><span class='Ref_To_Local'>vstate</span></a><span class='Operator'>.</span><a href="nbtree.c.html#LN61"><span class='Ref_to_Member'>lastBlockVacuumed</span></a> <span class='Operator'>&LT; </span><a href="nbtree.c.html#LN1003"><span class='Ref_To_Local'>vstate</span></a><span class='Operator'>.</span><a href="nbtree.c.html#LN62"><span class='Ref_to_Member'>lastBlockLocked</span></a><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1093"></a>        <a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a>      <span class='Declare_Local'>buf</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * The page should be valid, but we can't use _bt_getbuf() because we 
         * want to use a nondefault buffer access strategy.  Since we aren't 
         * going to delete any items, getting cleanup lock again is probably 
         * overkill, but for consistency do that anyway. 
         */ 
</span>        <a href="nbtree.c.html#LN1093"><span class='Ref_To_Local'>buf</span></a> <span class='Operator'>= </span><a href="../../../include/storage/bufmgr.h.html#LN168"><span class='Ref_to_Proto'>ReadBufferExtended</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN1002"><span class='Ref_To_Local'>rel</span></a><span class='Delimiter'>, </span><a href="../../../include/common/relpath.h.html#LN26"><span class='Ref_to_EnumConst'>MAIN_FORKNUM</span></a><span class='Delimiter'>, </span><a href="nbtree.c.html#LN1003"><span class='Ref_To_Local'>vstate</span></a><span class='Operator'>.</span><a href="nbtree.c.html#LN62"><span class='Ref_to_Member'>lastBlockLocked</span></a><span class='Delimiter'>, 
</span>                                 <a href="../../../include/storage/bufmgr.h.html#LN39"><span class='Ref_to_EnumConst'>RBM_NORMAL</span></a><span class='Delimiter'>, </span><a href="nbtree.c.html#LN998"><span class='Ref_to_Parameter'>info</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/genam.h.html#LN50"><span class='Ref_to_Member'>strategy</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/bufmgr.h.html#LN216"><span class='Ref_to_Proto'>LockBufferForCleanup</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN1093"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/access/nbtree.h.html#LN481"><span class='Ref_to_Proto'>_bt_checkpage</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN1002"><span class='Ref_To_Local'>rel</span></a><span class='Delimiter'>, </span><a href="nbtree.c.html#LN1093"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/access/nbtree.h.html#LN490"><span class='Ref_to_Proto'>_bt_delitems_vacuum</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN1002"><span class='Ref_To_Local'>rel</span></a><span class='Delimiter'>, </span><a href="nbtree.c.html#LN1093"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><a href="nbtree.c.html#LN1003"><span class='Ref_To_Local'>vstate</span></a><span class='Operator'>.</span><a href="nbtree.c.html#LN61"><span class='Ref_to_Member'>lastBlockVacuumed</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/access/nbtree.h.html#LN485"><span class='Ref_to_Proto'>_bt_relbuf</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN1002"><span class='Ref_To_Local'>rel</span></a><span class='Delimiter'>, </span><a href="nbtree.c.html#LN1093"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/utils/memutils.h.html#LN74"><span class='Ref_to_Proto'>MemoryContextDelete</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN1003"><span class='Ref_To_Local'>vstate</span></a><span class='Operator'>.</span><a href="nbtree.c.html#LN64"><span class='Ref_to_Member'>pagedelcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* update statistics */ 
</span>    <a href="nbtree.c.html#LN998"><span class='Ref_to_Parameter'>stats</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/genam.h.html#LN72"><span class='Ref_to_Member'>num_pages</span></a> <span class='Operator'>= </span><a href="nbtree.c.html#LN1004"><span class='Ref_To_Local'>num_pages</span></a><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN998"><span class='Ref_to_Parameter'>stats</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/genam.h.html#LN78"><span class='Ref_to_Member'>pages_free</span></a> <span class='Operator'>= </span><a href="nbtree.c.html#LN1003"><span class='Ref_To_Local'>vstate</span></a><span class='Operator'>.</span><a href="nbtree.c.html#LN63"><span class='Ref_to_Member'>totFreePages</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end btvacuumscan &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * btvacuumpage --- VACUUM one page 
 * 
 * This processes a single page for btvacuumscan().  In some cases we 
 * must go back and re-examine previously-scanned pages; this routine 
 * recurses when necessary to handle that case. 
 * 
 * blkno is the page to process.  orig_blkno is the highest block number 
 * reached by the outer btvacuumscan loop (the same as blkno, unless we 
 * are recursing to re-examine a previous page). 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1128"></a><span class='Declare_Function'>btvacuumpage</span><span class='Parentheses'>(</span><a href="nbtree.c.html#LN54"><span class='Ref_to_Typedef'>BTVacState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>vstate</span><span class='Delimiter'>, </span><a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Parameter'>blkno</span><span class='Delimiter'>, </span><a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Parameter'>orig_blkno</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1130"></a>    <a href="../../../include/access/genam.h.html#LN43"><span class='Ref_to_Struct'>IndexVacuumInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>info</span> <span class='Operator'>= </span><a href="nbtree.c.html#LN1128"><span class='Ref_to_Parameter'>vstate</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN56"><span class='Ref_to_Member'>info</span></a><span class='Delimiter'>; 
</span><a name="LN1131"></a>    <a href="../../../include/access/genam.h.html#LN70"><span class='Ref_to_Struct'>IndexBulkDeleteResult</span></a> <span class='Operator'>*</span><span class='Declare_Local'>stats</span> <span class='Operator'>= </span><a href="nbtree.c.html#LN1128"><span class='Ref_to_Parameter'>vstate</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN57"><span class='Ref_to_Member'>stats</span></a><span class='Delimiter'>; 
</span><a name="LN1132"></a>    <a href="../../../include/access/genam.h.html#LN82"><span class='Ref_to_Typedef'>IndexBulkDeleteCallback</span></a> <span class='Declare_Local'>callback</span> <span class='Operator'>= </span><a href="nbtree.c.html#LN1128"><span class='Ref_to_Parameter'>vstate</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN58"><span class='Ref_to_Member'>callback</span></a><span class='Delimiter'>; 
</span><a name="LN1133"></a>    <span class='Keyword'>void</span>       <span class='Operator'>*</span><span class='Declare_Local'>callback_state</span> <span class='Operator'>= </span><a href="nbtree.c.html#LN1128"><span class='Ref_to_Parameter'>vstate</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN59"><span class='Ref_to_Member'>callback_state</span></a><span class='Delimiter'>; 
</span><a name="LN1134"></a>    <a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>rel</span> <span class='Operator'>= </span><a href="nbtree.c.html#LN1130"><span class='Ref_To_Local'>info</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/genam.h.html#LN45"><span class='Ref_to_Member'>index</span></a><span class='Delimiter'>; 
</span><a name="LN1135"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>delete_now</span><span class='Delimiter'>; 
</span><a name="LN1136"></a>    <a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Local'>recurse_to</span><span class='Delimiter'>; 
</span><a name="LN1137"></a>    <a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a>      <span class='Declare_Local'>buf</span><span class='Delimiter'>; 
</span><a name="LN1138"></a>    <a href="../../../include/storage/bufpage.h.html#LN73"><span class='Ref_to_Typedef'>Page</span></a>        <span class='Declare_Local'>page</span><span class='Delimiter'>; 
</span><a name="LN1139"></a>    <a href="../../../include/access/nbtree.h.html#LN66"><span class='Ref_to_Typedef'>BTPageOpaque</span></a> <span class='Declare_Local'>opaque</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
<a name="LN1141"></a><span class='Label'>restart</span><span class='Operator'>: 
</span>    <a href="nbtree.c.html#LN1135"><span class='Ref_To_Local'>delete_now</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN1136"><span class='Ref_To_Local'>recurse_to</span></a> <span class='Operator'>= </span><a href="../../../include/access/nbtree.h.html#LN167"><span class='Ref_to_Const'>P_NONE</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* call vacuum_delay_point while not holding any buffer lock */ 
</span>    <a href="../../../include/commands/vacuum.h.html#LN188"><span class='Ref_to_Proto'>vacuum_delay_point</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We can't use _bt_getbuf() here because it always applies 
     * _bt_checkpage(), which will barf on an all-zero page. We want to 
     * recycle all-zero pages, not fail.  Also, we want to use a nondefault 
     * buffer access strategy. 
     */ 
</span>    <a href="nbtree.c.html#LN1137"><span class='Ref_To_Local'>buf</span></a> <span class='Operator'>= </span><a href="../../../include/storage/bufmgr.h.html#LN168"><span class='Ref_to_Proto'>ReadBufferExtended</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN1134"><span class='Ref_To_Local'>rel</span></a><span class='Delimiter'>, </span><a href="../../../include/common/relpath.h.html#LN26"><span class='Ref_to_EnumConst'>MAIN_FORKNUM</span></a><span class='Delimiter'>, </span><a href="nbtree.c.html#LN1128"><span class='Ref_to_Parameter'>blkno</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/bufmgr.h.html#LN39"><span class='Ref_to_EnumConst'>RBM_NORMAL</span></a><span class='Delimiter'>, 
</span>                             <a href="nbtree.c.html#LN1130"><span class='Ref_To_Local'>info</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/genam.h.html#LN50"><span class='Ref_to_Member'>strategy</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/bufmgr.h.html#LN214"><span class='Ref_to_Proto'>LockBuffer</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN1137"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><a href="../../../include/access/nbtree.h.html#LN237"><span class='Ref_to_Const'>BT_READ</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="nbtree.c.html#LN1138"><span class='Ref_To_Local'>page</span></a> <span class='Operator'>= </span><a href="../../../include/storage/bufmgr.h.html#LN159"><span class='Ref_to_Macro'>BufferGetPage</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN1137"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/storage/bufpage.h.html#LN225"><span class='Ref_to_Macro'>PageIsNew</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN1138"><span class='Ref_To_Local'>page</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../include/access/nbtree.h.html#LN481"><span class='Ref_to_Proto'>_bt_checkpage</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN1134"><span class='Ref_To_Local'>rel</span></a><span class='Delimiter'>, </span><a href="nbtree.c.html#LN1137"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="nbtree.c.html#LN1139"><span class='Ref_To_Local'>opaque</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN66"><span class='Ref_to_Typedef'>BTPageOpaque</span></a><span class='Parentheses'>) </span><a href="../../../include/storage/bufpage.h.html#LN322"><span class='Ref_to_Macro'>PageGetSpecialPointer</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN1138"><span class='Ref_To_Local'>page</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we are recursing, the only case we want to do anything with is a 
     * live leaf page having the current vacuum cycle ID.  Any other state 
     * implies we already saw the page (eg, deleted it as being empty). 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN1128"><span class='Ref_to_Parameter'>blkno</span></a> <span class='Operator'>!= </span><a href="nbtree.c.html#LN1128"><span class='Ref_to_Parameter'>orig_blkno</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN487"><span class='Ref_to_Proto'>_bt_page_recyclable</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN1138"><span class='Ref_To_Local'>page</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>            <a href="../../../include/access/nbtree.h.html#LN180"><span class='Ref_to_Macro'>P_IGNORE</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN1139"><span class='Ref_To_Local'>opaque</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>            <span class='Operator'>!</span><a href="../../../include/access/nbtree.h.html#LN175"><span class='Ref_to_Macro'>P_ISLEAF</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN1139"><span class='Ref_To_Local'>opaque</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>            <a href="nbtree.c.html#LN1139"><span class='Ref_To_Local'>opaque</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN63"><span class='Ref_to_Member'>btpo_cycleid</span></a> <span class='Operator'>!= </span><a href="nbtree.c.html#LN1128"><span class='Ref_to_Parameter'>vstate</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN60"><span class='Ref_to_Member'>cycleid</span></a><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <a href="../../../include/access/nbtree.h.html#LN485"><span class='Ref_to_Proto'>_bt_relbuf</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN1134"><span class='Ref_To_Local'>rel</span></a><span class='Delimiter'>, </span><a href="nbtree.c.html#LN1137"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Page is valid, see what to do with it */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN487"><span class='Ref_to_Proto'>_bt_page_recyclable</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN1138"><span class='Ref_To_Local'>page</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Okay to recycle this page */ 
</span>        <a href="../../../include/storage/indexfsm.h.html#LN20"><span class='Ref_to_Proto'>RecordFreeIndexPage</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN1134"><span class='Ref_To_Local'>rel</span></a><span class='Delimiter'>, </span><a href="nbtree.c.html#LN1128"><span class='Ref_to_Parameter'>blkno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="nbtree.c.html#LN1128"><span class='Ref_to_Parameter'>vstate</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN63"><span class='Ref_to_Member'>totFreePages</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <a href="nbtree.c.html#LN1131"><span class='Ref_To_Local'>stats</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/genam.h.html#LN77"><span class='Ref_to_Member'>pages_deleted</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN177"><span class='Ref_to_Macro'>P_ISDELETED</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN1139"><span class='Ref_To_Local'>opaque</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Already deleted, but can't recycle yet */ 
</span>        <a href="nbtree.c.html#LN1131"><span class='Ref_To_Local'>stats</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/genam.h.html#LN77"><span class='Ref_to_Member'>pages_deleted</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN179"><span class='Ref_to_Macro'>P_ISHALFDEAD</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN1139"><span class='Ref_To_Local'>opaque</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Half-dead, try to delete */ 
</span>        <a href="nbtree.c.html#LN1135"><span class='Ref_To_Local'>delete_now</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN175"><span class='Ref_to_Macro'>P_ISLEAF</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN1139"><span class='Ref_To_Local'>opaque</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1201"></a>        <a href="../../../include/storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Local'>deletable</span><span class='Delimiter'>[</span><a href="../../../include/storage/off.h.html#LN27"><span class='Ref_to_Const'>MaxOffsetNumber</span></a><span class='Delimiter'>]; 
</span><a name="LN1202"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>ndeletable</span><span class='Delimiter'>; 
</span><a name="LN1203"></a>        <a href="../../../include/storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Local'>offnum</span><span class='Delimiter'>, 
</span><a name="LN1204"></a>                    <span class='Declare_Local'>minoff</span><span class='Delimiter'>, 
</span><a name="LN1205"></a>                    <span class='Declare_Local'>maxoff</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Trade in the initial read lock for a super-exclusive write lock on 
         * this page.  We must get such a lock on every leaf page over the 
         * course of the vacuum scan, whether or not it actually contains any 
         * deletable tuples --- see nbtree/README. 
         */ 
</span>        <a href="../../../include/storage/bufmgr.h.html#LN214"><span class='Ref_to_Proto'>LockBuffer</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN1137"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/bufmgr.h.html#LN86"><span class='Ref_to_Const'>BUFFER_LOCK_UNLOCK</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/bufmgr.h.html#LN216"><span class='Ref_to_Proto'>LockBufferForCleanup</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN1137"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Remember highest leaf page number we've taken cleanup lock on; see 
         * notes in btvacuumscan 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN1128"><span class='Ref_to_Parameter'>blkno</span></a> <span class='Operator'>&GT; </span><a href="nbtree.c.html#LN1128"><span class='Ref_to_Parameter'>vstate</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN62"><span class='Ref_to_Member'>lastBlockLocked</span></a><span class='Parentheses'>) 
</span>            <a href="nbtree.c.html#LN1128"><span class='Ref_to_Parameter'>vstate</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN62"><span class='Ref_to_Member'>lastBlockLocked</span></a> <span class='Operator'>= </span><a href="nbtree.c.html#LN1128"><span class='Ref_to_Parameter'>blkno</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Check whether we need to recurse back to earlier pages.  What we 
         * are concerned about is a page split that happened since we started 
         * the vacuum scan.  If the split moved some tuples to a lower page 
         * then we might have missed 'em.  If so, set up for tail recursion. 
         * (Must do this before possibly clearing btpo_cycleid below!) 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN1128"><span class='Ref_to_Parameter'>vstate</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN60"><span class='Ref_to_Member'>cycleid</span></a> <span class='Operator'>!= </span><span class='Number'>0</span> <span class='Operator'>&& 
</span>            <a href="nbtree.c.html#LN1139"><span class='Ref_To_Local'>opaque</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN63"><span class='Ref_to_Member'>btpo_cycleid</span></a> <span class='Operator'>== </span><a href="nbtree.c.html#LN1128"><span class='Ref_to_Parameter'>vstate</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN60"><span class='Ref_to_Member'>cycleid</span></a> <span class='Operator'>&& 
</span>            <span class='Operator'>!</span><span class='Parentheses'>(</span><a href="nbtree.c.html#LN1139"><span class='Ref_To_Local'>opaque</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN62"><span class='Ref_to_Member'>btpo_flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/nbtree.h.html#LN74"><span class='Ref_to_Const'>BTP_SPLIT_END</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>            <span class='Operator'>!</span><a href="../../../include/access/nbtree.h.html#LN174"><span class='Ref_to_Macro'>P_RIGHTMOST</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN1139"><span class='Ref_To_Local'>opaque</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>            <a href="nbtree.c.html#LN1139"><span class='Ref_To_Local'>opaque</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN56"><span class='Ref_to_Member'>btpo_next</span></a> <span class='Operator'>&LT; </span><a href="nbtree.c.html#LN1128"><span class='Ref_to_Parameter'>orig_blkno</span></a><span class='Parentheses'>)</span> 
            <a href="nbtree.c.html#LN1136"><span class='Ref_To_Local'>recurse_to</span></a> <span class='Operator'>= </span><a href="nbtree.c.html#LN1139"><span class='Ref_To_Local'>opaque</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN56"><span class='Ref_to_Member'>btpo_next</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Scan over all items to see which ones need deleted according to the 
         * callback function. 
         */ 
</span>        <a href="nbtree.c.html#LN1202"><span class='Ref_To_Local'>ndeletable</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="nbtree.c.html#LN1204"><span class='Ref_To_Local'>minoff</span></a> <span class='Operator'>= </span><a href="../../../include/access/nbtree.h.html#LN204"><span class='Ref_to_Macro'>P_FIRSTDATAKEY</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN1139"><span class='Ref_To_Local'>opaque</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="nbtree.c.html#LN1205"><span class='Ref_To_Local'>maxoff</span></a> <span class='Operator'>= </span><a href="../../../include/storage/bufpage.h.html#LN353"><span class='Ref_to_Macro'>PageGetMaxOffsetNumber</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN1138"><span class='Ref_To_Local'>page</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN1132"><span class='Ref_To_Local'>callback</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN1203"><span class='Ref_To_Local'>offnum</span></a> <span class='Operator'>= </span><a href="nbtree.c.html#LN1204"><span class='Ref_To_Local'>minoff</span></a><span class='Delimiter'>; 
</span>                 <a href="nbtree.c.html#LN1203"><span class='Ref_To_Local'>offnum</span></a> <span class='Operator'>&LT;= </span><a href="nbtree.c.html#LN1205"><span class='Ref_To_Local'>maxoff</span></a><span class='Delimiter'>; 
</span>                 <a href="nbtree.c.html#LN1203"><span class='Ref_To_Local'>offnum</span></a> <span class='Operator'>= </span><a href="../../../include/storage/off.h.html#LN52"><span class='Ref_to_Macro'>OffsetNumberNext</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN1203"><span class='Ref_To_Local'>offnum</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span><a name="LN1250"></a>                <a href="../../../include/access/itup.h.html#LN52"><span class='Ref_to_Typedef'>IndexTuple</span></a>  <span class='Declare_Local'>itup</span><span class='Delimiter'>; 
</span><a name="LN1251"></a>                <a href="../../../include/storage/itemptr.h.html#LN47"><span class='Ref_to_Typedef'>ItemPointer</span></a> <span class='Declare_Local'>htup</span><span class='Delimiter'>; 
</span> 
                <a href="nbtree.c.html#LN1250"><span class='Ref_To_Local'>itup</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/itup.h.html#LN52"><span class='Ref_to_Typedef'>IndexTuple</span></a><span class='Parentheses'>) </span><a href="../../../include/storage/bufpage.h.html#LN336"><span class='Ref_to_Macro'>PageGetItem</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN1138"><span class='Ref_To_Local'>page</span></a><span class='Delimiter'>, 
</span>                                                <a href="../../../include/storage/bufpage.h.html#LN231"><span class='Ref_to_Macro'>PageGetItemId</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN1138"><span class='Ref_To_Local'>page</span></a><span class='Delimiter'>, </span><a href="nbtree.c.html#LN1203"><span class='Ref_To_Local'>offnum</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <a href="nbtree.c.html#LN1251"><span class='Ref_To_Local'>htup</span></a> <span class='Operator'>= &</span><span class='Parentheses'>(</span><a href="nbtree.c.html#LN1250"><span class='Ref_To_Local'>itup</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/itup.h.html#LN36"><span class='Ref_to_Member'>t_tid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * During Hot Standby we currently assume that 
                 * XLOG_BTREE_VACUUM records do not produce conflicts. That is 
                 * only true as long as the callback function depends only 
                 * upon whether the index tuple refers to heap tuples removed 
                 * in the initial heap scan. When vacuum starts it derives a 
                 * value of OldestXmin. Backends taking later snapshots could 
                 * have a RecentGlobalXmin with a later xid than the vacuum's 
                 * OldestXmin, so it is possible that row versions deleted 
                 * after OldestXmin could be marked as killed by other 
                 * backends. The callback function *could* look at the index 
                 * tuple state in isolation and decide to delete the index 
                 * tuple, though currently it does not. If it ever did, we 
                 * would need to reconsider whether XLOG_BTREE_VACUUM records 
                 * should cause conflicts. If they did cause conflicts they 
                 * would be fairly harsh conflicts, since we haven't yet 
                 * worked out a way to pass a useful value for 
                 * latestRemovedXid on the XLOG_BTREE_VACUUM records. This 
                 * applies to *any* type of index that marks index tuples as 
                 * killed. 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN1132"><span class='Ref_To_Local'>callback</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN1251"><span class='Ref_To_Local'>htup</span></a><span class='Delimiter'>, </span><a href="nbtree.c.html#LN1133"><span class='Ref_To_Local'>callback_state</span></a><span class='Parentheses'>))</span> 
                    <a href="nbtree.c.html#LN1201"><span class='Ref_To_Local'>deletable</span></a><span class='Delimiter'>[</span><a href="nbtree.c.html#LN1202"><span class='Ref_To_Local'>ndeletable</span></a><span class='Operator'>++</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="nbtree.c.html#LN1203"><span class='Ref_To_Local'>offnum</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for offnum=minoff;offnum&LT;... &raquo; </span> 
        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if callback &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* 
         * Apply any needed deletes.  We issue just one _bt_delitems_vacuum() 
         * call per page, so as to minimize WAL traffic. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN1202"><span class='Ref_To_Local'>ndeletable</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Notice that the issued XLOG_BTREE_VACUUM WAL record includes 
             * all information to the replay code to allow it to get a cleanup 
             * lock on all pages between the previous lastBlockVacuumed and 
             * this page. This ensures that WAL replay locks all leaf pages at 
             * some point, which is important should non-MVCC scans be 
             * requested. This is currently unused on standby, but we record 
             * it anyway, so that the WAL contains the required information. 
             * 
             * Since we can visit leaf pages out-of-order when recursing, 
             * replay might end up locking such pages an extra time, but it 
             * doesn't seem worth the amount of bookkeeping it'd take to avoid 
             * that. 
             */ 
</span>            <a href="../../../include/access/nbtree.h.html#LN490"><span class='Ref_to_Proto'>_bt_delitems_vacuum</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN1134"><span class='Ref_To_Local'>rel</span></a><span class='Delimiter'>, </span><a href="nbtree.c.html#LN1137"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><a href="nbtree.c.html#LN1201"><span class='Ref_To_Local'>deletable</span></a><span class='Delimiter'>, </span><a href="nbtree.c.html#LN1202"><span class='Ref_To_Local'>ndeletable</span></a><span class='Delimiter'>, 
</span>                                <a href="nbtree.c.html#LN1128"><span class='Ref_to_Parameter'>vstate</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN61"><span class='Ref_to_Member'>lastBlockVacuumed</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Remember highest leaf page number we've issued a 
             * XLOG_BTREE_VACUUM WAL record for. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN1128"><span class='Ref_to_Parameter'>blkno</span></a> <span class='Operator'>&GT; </span><a href="nbtree.c.html#LN1128"><span class='Ref_to_Parameter'>vstate</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN61"><span class='Ref_to_Member'>lastBlockVacuumed</span></a><span class='Parentheses'>) 
</span>                <a href="nbtree.c.html#LN1128"><span class='Ref_to_Parameter'>vstate</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN61"><span class='Ref_to_Member'>lastBlockVacuumed</span></a> <span class='Operator'>= </span><a href="nbtree.c.html#LN1128"><span class='Ref_to_Parameter'>blkno</span></a><span class='Delimiter'>; 
</span> 
            <a href="nbtree.c.html#LN1131"><span class='Ref_To_Local'>stats</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/genam.h.html#LN76"><span class='Ref_to_Member'>tuples_removed</span></a> <span class='Operator'>+= </span><a href="nbtree.c.html#LN1202"><span class='Ref_To_Local'>ndeletable</span></a><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* must recompute maxoff */ 
</span>            <a href="nbtree.c.html#LN1205"><span class='Ref_To_Local'>maxoff</span></a> <span class='Operator'>= </span><a href="../../../include/storage/bufpage.h.html#LN353"><span class='Ref_to_Macro'>PageGetMaxOffsetNumber</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN1138"><span class='Ref_To_Local'>page</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if ndeletable&GT;0 &raquo; </span> 
        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * If the page has been split during this vacuum cycle, it seems 
             * worth expending a write to clear btpo_cycleid even if we don't 
             * have any deletions to do.  (If we do, _bt_delitems_vacuum takes 
             * care of this.)  This ensures we won't process the page again. 
             * 
             * We treat this like a hint-bit update because there's no need to 
             * WAL-log it. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN1128"><span class='Ref_to_Parameter'>vstate</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN60"><span class='Ref_to_Member'>cycleid</span></a> <span class='Operator'>!= </span><span class='Number'>0</span> <span class='Operator'>&& 
</span>                <a href="nbtree.c.html#LN1139"><span class='Ref_To_Local'>opaque</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN63"><span class='Ref_to_Member'>btpo_cycleid</span></a> <span class='Operator'>== </span><a href="nbtree.c.html#LN1128"><span class='Ref_to_Parameter'>vstate</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN60"><span class='Ref_to_Member'>cycleid</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="nbtree.c.html#LN1139"><span class='Ref_To_Local'>opaque</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN63"><span class='Ref_to_Member'>btpo_cycleid</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>                <a href="../../../include/storage/bufmgr.h.html#LN211"><span class='Ref_to_Proto'>MarkBufferDirtyHint</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN1137"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If it's now empty, try to delete; else count the live tuples. We 
         * don't delete when recursing, though, to avoid putting entries into 
         * freePages out-of-order (doesn't seem worth any extra code to handle 
         * the case). 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN1204"><span class='Ref_To_Local'>minoff</span></a> <span class='Operator'>&GT; </span><a href="nbtree.c.html#LN1205"><span class='Ref_To_Local'>maxoff</span></a><span class='Parentheses'>) 
</span>            <a href="nbtree.c.html#LN1135"><span class='Ref_To_Local'>delete_now</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="nbtree.c.html#LN1128"><span class='Ref_to_Parameter'>blkno</span></a> <span class='Operator'>== </span><a href="nbtree.c.html#LN1128"><span class='Ref_to_Parameter'>orig_blkno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="nbtree.c.html#LN1131"><span class='Ref_To_Local'>stats</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/genam.h.html#LN75"><span class='Ref_to_Member'>num_index_tuples</span></a> <span class='Operator'>+= </span><a href="nbtree.c.html#LN1205"><span class='Ref_To_Local'>maxoff</span></a> <span class='Operator'>- </span><a href="nbtree.c.html#LN1204"><span class='Ref_To_Local'>minoff</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if P_ISLEAF(opaque) &raquo; </span> 
 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN1135"><span class='Ref_To_Local'>delete_now</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1350"></a>        <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldcontext</span><span class='Delimiter'>; 
</span><a name="LN1351"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>ndel</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Run pagedel in a temp context to avoid memory leakage */ 
</span>        <a href="../../../include/utils/memutils.h.html#LN73"><span class='Ref_to_Proto'>MemoryContextReset</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN1128"><span class='Ref_to_Parameter'>vstate</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN64"><span class='Ref_to_Member'>pagedelcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="nbtree.c.html#LN1350"><span class='Ref_To_Local'>oldcontext</span></a> <span class='Operator'>= </span><a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN1128"><span class='Ref_to_Parameter'>vstate</span></a><span class='Operator'>-&GT;</span><a href="nbtree.c.html#LN64"><span class='Ref_to_Member'>pagedelcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="nbtree.c.html#LN1351"><span class='Ref_To_Local'>ndel</span></a> <span class='Operator'>= </span><a href="../../../include/access/nbtree.h.html#LN493"><span class='Ref_to_Proto'>_bt_pagedel</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN1134"><span class='Ref_To_Local'>rel</span></a><span class='Delimiter'>, </span><a href="nbtree.c.html#LN1137"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* count only this page, else may double-count parent */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN1351"><span class='Ref_To_Local'>ndel</span></a><span class='Parentheses'>) 
</span>            <a href="nbtree.c.html#LN1131"><span class='Ref_To_Local'>stats</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/genam.h.html#LN77"><span class='Ref_to_Member'>pages_deleted</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN1350"><span class='Ref_To_Local'>oldcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* pagedel released buffer, so we shouldn't */ 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
        <a href="../../../include/access/nbtree.h.html#LN485"><span class='Ref_to_Proto'>_bt_relbuf</span></a><span class='Parentheses'>(</span><a href="nbtree.c.html#LN1134"><span class='Ref_To_Local'>rel</span></a><span class='Delimiter'>, </span><a href="nbtree.c.html#LN1137"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * This is really tail recursion, but if the compiler is too stupid to 
     * optimize it as such, we'd eat an uncomfortably large amount of stack 
     * space per recursion level (due to the deletable[] array). A failure is 
     * improbable since the number of levels isn't likely to be large ... but 
     * just in case, let's hand-optimize into a loop. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtree.c.html#LN1136"><span class='Ref_To_Local'>recurse_to</span></a> <span class='Operator'>!= </span><a href="../../../include/access/nbtree.h.html#LN167"><span class='Ref_to_Const'>P_NONE</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="nbtree.c.html#LN1128"><span class='Ref_to_Parameter'>blkno</span></a> <span class='Operator'>= </span><a href="nbtree.c.html#LN1136"><span class='Ref_To_Local'>recurse_to</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>goto</span> <span class='Symbol_Characters'>&uarr;</span><a href="nbtree.c.html#LN1141"><span class='Ref_to_Label'>restart</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end btvacuumpage &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 *  btcanreturn() -- Check whether btree indexes support index-only scans. 
 * 
 * btrees always do, so this is trivial. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN1389"></a><span class='Declare_Function'>btcanreturn</span><span class='Parentheses'>(</span><a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>index</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>attno</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
} 
</span></pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>