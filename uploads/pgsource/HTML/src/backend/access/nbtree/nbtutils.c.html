<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\access\nbtree\nbtutils.c</title>
<LINK REL=StyleSheet HREF="../../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\access\nbtree\nbtutils.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:29 2017
</td></tr>
<tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * nbtutils.c 
 *    Utility code for Postgres btree implementation. 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * 
 * IDENTIFICATION 
 *    src/backend/access/nbtree/nbtutils.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span> 
<span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>&LT;time.h&GT;</span> 
 
<span class='Keyword'>#include </span><span class='String'>"access/nbtree.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/reloptions.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/relscan.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"miscadmin.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/array.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/lsyscache.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/memutils.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/rel.h"</span> 
 
 
<a name="LN29"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>BTSortArrayContext</span> 
<span class='Delimiter'>{ 
</span><a name="LN31"></a>    <a href="../../../include/fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a>    <span class='Declare_Member'>flinfo</span><span class='Delimiter'>; 
</span><a name="LN32"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>collation</span><span class='Delimiter'>; 
</span><a name="LN33"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>reverse</span><span class='Delimiter'>; 
</span><a name="LN34"></a>} <span class='Declare_Typedef'>BTSortArrayContext</span><span class='Delimiter'>; 
</span> 
<a name="LN36"></a><span class='Keyword'>static </span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Prototype'>_bt_find_extreme_element</span><span class='Parentheses'>(</span><a href="../../../include/access/genam.h.html#LN85"><span class='Ref_to_Typedef'>IndexScanDesc</span></a> <span class='Declare_Parameter'>scan</span><span class='Delimiter'>, </span><a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a> <span class='Declare_Parameter'>skey</span><span class='Delimiter'>, 
</span><a name="LN37"></a>                         <a href="../../../include/access/stratnum.h.html#LN21"><span class='Ref_to_Typedef'>StrategyNumber</span></a> <span class='Declare_Parameter'>strat</span><span class='Delimiter'>, 
</span><a name="LN38"></a>                         <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>elems</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>nelems</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN39"></a><span class='Keyword'>static int </span><span class='Declare_Prototype'>_bt_sort_array_elements</span><span class='Parentheses'>(</span><a href="../../../include/access/genam.h.html#LN85"><span class='Ref_to_Typedef'>IndexScanDesc</span></a> <span class='Declare_Parameter'>scan</span><span class='Delimiter'>, </span><a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a> <span class='Declare_Parameter'>skey</span><span class='Delimiter'>, 
</span><a name="LN40"></a>                        <span class='Keyword'>bool </span><span class='Declare_Parameter'>reverse</span><span class='Delimiter'>, 
</span><a name="LN41"></a>                        <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>elems</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>nelems</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN42"></a><span class='Keyword'>static int</span>  <span class='Declare_Prototype'>_bt_compare_array_elements</span><span class='Parentheses'>(</span><span class='Keyword'>const void </span><span class='Operator'>*</span><span class='Declare_Parameter'>a</span><span class='Delimiter'>, </span><span class='Keyword'>const void </span><span class='Operator'>*</span><span class='Declare_Parameter'>b</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>arg</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN43"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>_bt_compare_scankey_args</span><span class='Parentheses'>(</span><a href="../../../include/access/genam.h.html#LN85"><span class='Ref_to_Typedef'>IndexScanDesc</span></a> <span class='Declare_Parameter'>scan</span><span class='Delimiter'>, </span><a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a> <span class='Declare_Parameter'>op</span><span class='Delimiter'>, 
</span><a name="LN44"></a>                         <a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a> <span class='Declare_Parameter'>leftarg</span><span class='Delimiter'>, </span><a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a> <span class='Declare_Parameter'>rightarg</span><span class='Delimiter'>, 
</span><a name="LN45"></a>                         <span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>result</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN46"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>_bt_fix_scankey_strategy</span><span class='Parentheses'>(</span><a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a> <span class='Declare_Parameter'>skey</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN254"><span class='Ref_to_Typedef'>int16</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>indoption</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN47"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>_bt_mark_scankey_required</span><span class='Parentheses'>(</span><a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a> <span class='Declare_Parameter'>skey</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN48"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>_bt_check_rowcompare</span><span class='Parentheses'>(</span><a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a> <span class='Declare_Parameter'>skey</span><span class='Delimiter'>, 
</span><a name="LN49"></a>                     <a href="../../../include/access/itup.h.html#LN52"><span class='Ref_to_Typedef'>IndexTuple</span></a> <span class='Declare_Parameter'>tuple</span><span class='Delimiter'>, </span><a href="../../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a> <span class='Declare_Parameter'>tupdesc</span><span class='Delimiter'>, 
</span><a name="LN50"></a>                     <a href="../../../include/access/sdir.h.html#LN21"><span class='Ref_to_Enum'>ScanDirection</span></a> <span class='Declare_Parameter'>dir</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>continuescan</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * _bt_mkscankey 
 *      Build an insertion scan key that contains comparison data from itup 
 *      as well as comparator routines appropriate to the key datatypes. 
 * 
 *      The result is intended for use with _bt_compare(). 
 */ 
</span><a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a> 
<a name="LN61"></a><span class='Declare_Function'>_bt_mkscankey</span><span class='Parentheses'>(</span><a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>rel</span><span class='Delimiter'>, </span><a href="../../../include/access/itup.h.html#LN52"><span class='Ref_to_Typedef'>IndexTuple</span></a> <span class='Declare_Parameter'>itup</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN63"></a>    <a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a>     <span class='Declare_Local'>skey</span><span class='Delimiter'>; 
</span><a name="LN64"></a>    <a href="../../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a>   <span class='Declare_Local'>itupdesc</span><span class='Delimiter'>; 
</span><a name="LN65"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>natts</span><span class='Delimiter'>; 
</span><a name="LN66"></a>    <a href="../../../include/c.h.html#LN254"><span class='Ref_to_Typedef'>int16</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>indoption</span><span class='Delimiter'>; 
</span><a name="LN67"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <a href="nbtutils.c.html#LN64"><span class='Ref_To_Local'>itupdesc</span></a> <span class='Operator'>= </span><a href="../../../include/utils/rel.h.html#LN428"><span class='Ref_to_Macro'>RelationGetDescr</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN61"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="nbtutils.c.html#LN65"><span class='Ref_To_Local'>natts</span></a> <span class='Operator'>= </span><a href="../../../include/utils/rel.h.html#LN422"><span class='Ref_to_Macro'>RelationGetNumberOfAttributes</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN61"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="nbtutils.c.html#LN66"><span class='Ref_To_Local'>indoption</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN61"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN185"><span class='Ref_to_Member'>rd_indoption</span></a><span class='Delimiter'>; 
</span> 
    <a href="nbtutils.c.html#LN63"><span class='Ref_To_Local'>skey</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN65"><span class='Ref_To_Local'>natts</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/access/skey.h.html#LN63"><span class='Ref_to_Struct'>ScanKeyData</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN67"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nbtutils.c.html#LN67"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="nbtutils.c.html#LN65"><span class='Ref_To_Local'>natts</span></a><span class='Delimiter'>; </span><a href="nbtutils.c.html#LN67"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN77"></a>        <a href="../../../include/fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>procinfo</span><span class='Delimiter'>; 
</span><a name="LN78"></a>        <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>arg</span><span class='Delimiter'>; 
</span><a name="LN79"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>null</span><span class='Delimiter'>; 
</span><a name="LN80"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>flags</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We can use the cached (default) support procs since no cross-type 
         * comparison can be needed. 
         */ 
</span>        <a href="nbtutils.c.html#LN77"><span class='Ref_To_Local'>procinfo</span></a> <span class='Operator'>= </span><a href="../../../include/access/genam.h.html#LN174"><span class='Ref_to_Proto'>index_getprocinfo</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN61"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN67"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>, </span><a href="../../../include/access/nbtree.h.html#LN228"><span class='Ref_to_Const'>BTORDER_PROC</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="nbtutils.c.html#LN78"><span class='Ref_To_Local'>arg</span></a> <span class='Operator'>= </span><a href="../../../include/access/itup.h.html#LN99"><span class='Ref_to_Macro'>index_getattr</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN61"><span class='Ref_to_Parameter'>itup</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN67"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN64"><span class='Ref_To_Local'>itupdesc</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nbtutils.c.html#LN79"><span class='Ref_To_Local'>null</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="nbtutils.c.html#LN80"><span class='Ref_To_Local'>flags</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN79"><span class='Ref_To_Local'>null</span></a> <span class='Operator'>? </span><a href="../../../include/access/skey.h.html#LN114"><span class='Ref_to_Const'>SK_ISNULL</span></a> <span class='Operator'>: </span><span class='Number'>0</span><span class='Parentheses'>) </span><span class='Operator'>| </span><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN66"><span class='Ref_To_Local'>indoption</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN67"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>&LT;&LT; </span><a href="../../../include/access/nbtree.h.html#LN425"><span class='Ref_to_Const'>SK_BT_INDOPTION_SHIFT</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../common/scankey.c.html#LN99"><span class='Ref_to_Func'>ScanKeyEntryInitializeWithInfo</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nbtutils.c.html#LN63"><span class='Ref_To_Local'>skey</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN67"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], 
</span>                                       <a href="nbtutils.c.html#LN80"><span class='Ref_To_Local'>flags</span></a><span class='Delimiter'>, 
</span>                                       <span class='Parentheses'>(</span><a href="../../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a><span class='Parentheses'>) (</span><a href="nbtutils.c.html#LN67"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                       <a href="../../../include/access/stratnum.h.html#LN23"><span class='Ref_to_Const'>InvalidStrategy</span></a><span class='Delimiter'>, 
</span>                                       <a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, 
</span>                                       <a href="nbtutils.c.html#LN61"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN192"><span class='Ref_to_Member'>rd_indcollation</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN67"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], 
</span>                                       <a href="nbtutils.c.html#LN77"><span class='Ref_To_Local'>procinfo</span></a><span class='Delimiter'>, 
</span>                                       <a href="nbtutils.c.html#LN78"><span class='Ref_To_Local'>arg</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;natts;i++ &raquo; </span> 
 
    <span class='Control'>return</span> <a href="nbtutils.c.html#LN63"><span class='Ref_To_Local'>skey</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end _bt_mkscankey &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * _bt_mkscankey_nodata 
 *      Build an insertion scan key that contains 3-way comparator routines 
 *      appropriate to the key datatypes, but no comparison data.  The 
 *      comparison data ultimately used must match the key datatypes. 
 * 
 *      The result cannot be used with _bt_compare(), unless comparison 
 *      data is first stored into the key entries.  Currently this 
 *      routine is only called by nbtsort.c and tuplesort.c, which have 
 *      their own comparison routines. 
 */ 
</span><a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a> 
<a name="LN114"></a><span class='Declare_Function'>_bt_mkscankey_nodata</span><span class='Parentheses'>(</span><a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>rel</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN116"></a>    <a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a>     <span class='Declare_Local'>skey</span><span class='Delimiter'>; 
</span><a name="LN117"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>natts</span><span class='Delimiter'>; 
</span><a name="LN118"></a>    <a href="../../../include/c.h.html#LN254"><span class='Ref_to_Typedef'>int16</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>indoption</span><span class='Delimiter'>; 
</span><a name="LN119"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <a href="nbtutils.c.html#LN117"><span class='Ref_To_Local'>natts</span></a> <span class='Operator'>= </span><a href="../../../include/utils/rel.h.html#LN422"><span class='Ref_to_Macro'>RelationGetNumberOfAttributes</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN114"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="nbtutils.c.html#LN118"><span class='Ref_To_Local'>indoption</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN114"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN185"><span class='Ref_to_Member'>rd_indoption</span></a><span class='Delimiter'>; 
</span> 
    <a href="nbtutils.c.html#LN116"><span class='Ref_To_Local'>skey</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN117"><span class='Ref_To_Local'>natts</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/access/skey.h.html#LN63"><span class='Ref_to_Struct'>ScanKeyData</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN119"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nbtutils.c.html#LN119"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="nbtutils.c.html#LN117"><span class='Ref_To_Local'>natts</span></a><span class='Delimiter'>; </span><a href="nbtutils.c.html#LN119"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN128"></a>        <a href="../../../include/fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>procinfo</span><span class='Delimiter'>; 
</span><a name="LN129"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>flags</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We can use the cached (default) support procs since no cross-type 
         * comparison can be needed. 
         */ 
</span>        <a href="nbtutils.c.html#LN128"><span class='Ref_To_Local'>procinfo</span></a> <span class='Operator'>= </span><a href="../../../include/access/genam.h.html#LN174"><span class='Ref_to_Proto'>index_getprocinfo</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN114"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN119"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>, </span><a href="../../../include/access/nbtree.h.html#LN228"><span class='Ref_to_Const'>BTORDER_PROC</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="nbtutils.c.html#LN129"><span class='Ref_To_Local'>flags</span></a> <span class='Operator'>= </span><a href="../../../include/access/skey.h.html#LN114"><span class='Ref_to_Const'>SK_ISNULL</span></a> <span class='Operator'>| </span><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN118"><span class='Ref_To_Local'>indoption</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN119"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>&LT;&LT; </span><a href="../../../include/access/nbtree.h.html#LN425"><span class='Ref_to_Const'>SK_BT_INDOPTION_SHIFT</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../common/scankey.c.html#LN99"><span class='Ref_to_Func'>ScanKeyEntryInitializeWithInfo</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nbtutils.c.html#LN116"><span class='Ref_To_Local'>skey</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN119"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], 
</span>                                       <a href="nbtutils.c.html#LN129"><span class='Ref_To_Local'>flags</span></a><span class='Delimiter'>, 
</span>                                       <span class='Parentheses'>(</span><a href="../../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a><span class='Parentheses'>) (</span><a href="nbtutils.c.html#LN119"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                       <a href="../../../include/access/stratnum.h.html#LN23"><span class='Ref_to_Const'>InvalidStrategy</span></a><span class='Delimiter'>, 
</span>                                       <a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, 
</span>                                       <a href="nbtutils.c.html#LN114"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN192"><span class='Ref_to_Member'>rd_indcollation</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN119"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], 
</span>                                       <a href="nbtutils.c.html#LN128"><span class='Ref_To_Local'>procinfo</span></a><span class='Delimiter'>, 
</span>                                       <span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;natts;i++ &raquo; </span> 
 
    <span class='Control'>return</span> <a href="nbtutils.c.html#LN116"><span class='Ref_To_Local'>skey</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end _bt_mkscankey_nodata &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * free a scan key made by either _bt_mkscankey or _bt_mkscankey_nodata. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN154"></a><span class='Declare_Function'>_bt_freeskey</span><span class='Parentheses'>(</span><a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a> <span class='Declare_Parameter'>skey</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN154"><span class='Ref_to_Parameter'>skey</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * free a retracement stack made by _bt_search. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN163"></a><span class='Declare_Function'>_bt_freestack</span><span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN258"><span class='Ref_to_Typedef'>BTStack</span></a> <span class='Declare_Parameter'>stack</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN165"></a>    <a href="../../../include/access/nbtree.h.html#LN258"><span class='Ref_to_Typedef'>BTStack</span></a>     <span class='Declare_Local'>ostack</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN163"><span class='Ref_to_Parameter'>stack</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="nbtutils.c.html#LN165"><span class='Ref_To_Local'>ostack</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN163"><span class='Ref_to_Parameter'>stack</span></a><span class='Delimiter'>; 
</span>        <a href="nbtutils.c.html#LN163"><span class='Ref_to_Parameter'>stack</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN163"><span class='Ref_to_Parameter'>stack</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN255"><span class='Ref_to_Member'>bts_parent</span></a><span class='Delimiter'>; 
</span>        <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN165"><span class='Ref_To_Local'>ostack</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
} 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 *  _bt_preprocess_array_keys() -- Preprocess SK_SEARCHARRAY scan keys 
 * 
 * If there are any SK_SEARCHARRAY scan keys, deconstruct the array(s) and 
 * set up BTArrayKeyInfo info for each one that is an equality-type key. 
 * Prepare modified scan keys in so-&GT;arrayKeyData, which will hold the current 
 * array elements during each primitive indexscan operation.  For inequality 
 * array keys, it's sufficient to find the extreme element value and replace 
 * the whole array with that scalar value. 
 * 
 * Note: the reason we need so-&GT;arrayKeyData, rather than just scribbling 
 * on scan-&GT;keyData, is that callers are permitted to call btrescan without 
 * supplying a new set of scankey data. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN191"></a><span class='Declare_Function'>_bt_preprocess_array_keys</span><span class='Parentheses'>(</span><a href="../../../include/access/genam.h.html#LN85"><span class='Ref_to_Typedef'>IndexScanDesc</span></a> <span class='Declare_Parameter'>scan</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN193"></a>    <a href="../../../include/access/nbtree.h.html#LN416"><span class='Ref_to_Typedef'>BTScanOpaque</span></a> <span class='Declare_Local'>so</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN416"><span class='Ref_to_Typedef'>BTScanOpaque</span></a><span class='Parentheses'>) </span><a href="nbtutils.c.html#LN191"><span class='Ref_to_Parameter'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN104"><span class='Ref_to_Member'>opaque</span></a><span class='Delimiter'>; 
</span><a name="LN194"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numberOfKeys</span> <span class='Operator'>= </span><a href="nbtutils.c.html#LN191"><span class='Ref_to_Parameter'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN90"><span class='Ref_to_Member'>numberOfKeys</span></a><span class='Delimiter'>; 
</span><a name="LN195"></a>    <a href="../../../include/c.h.html#LN254"><span class='Ref_to_Typedef'>int16</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>indoption</span> <span class='Operator'>= </span><a href="nbtutils.c.html#LN191"><span class='Ref_to_Parameter'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN88"><span class='Ref_to_Member'>indexRelation</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN185"><span class='Ref_to_Member'>rd_indoption</span></a><span class='Delimiter'>; 
</span><a name="LN196"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numArrayKeys</span><span class='Delimiter'>; 
</span><a name="LN197"></a>    <a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a>     <span class='Declare_Local'>cur</span><span class='Delimiter'>; 
</span><a name="LN198"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN199"></a>    <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldContext</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Quick check to see if there are any array keys */ 
</span>    <a href="nbtutils.c.html#LN196"><span class='Ref_To_Local'>numArrayKeys</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN198"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nbtutils.c.html#LN198"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="nbtutils.c.html#LN194"><span class='Ref_To_Local'>numberOfKeys</span></a><span class='Delimiter'>; </span><a href="nbtutils.c.html#LN198"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="nbtutils.c.html#LN197"><span class='Ref_To_Local'>cur</span></a> <span class='Operator'>= &</span><a href="nbtutils.c.html#LN191"><span class='Ref_to_Parameter'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN92"><span class='Ref_to_Member'>keyData</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN198"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN197"><span class='Ref_To_Local'>cur</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/skey.h.html#LN119"><span class='Ref_to_Const'>SK_SEARCHARRAY</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="nbtutils.c.html#LN196"><span class='Ref_To_Local'>numArrayKeys</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN197"><span class='Ref_To_Local'>cur</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><span class='Parentheses'>(</span><a href="../../../include/access/skey.h.html#LN116"><span class='Ref_to_Const'>SK_ROW_HEADER</span></a> <span class='Operator'>| </span><a href="../../../include/access/skey.h.html#LN120"><span class='Ref_to_Const'>SK_SEARCHNULL</span></a> <span class='Operator'>| </span><a href="../../../include/access/skey.h.html#LN121"><span class='Ref_to_Const'>SK_SEARCHNOTNULL</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* If any arrays are null as a whole, we can quit right now. */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN197"><span class='Ref_To_Local'>cur</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/skey.h.html#LN114"><span class='Ref_to_Const'>SK_ISNULL</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="nbtutils.c.html#LN193"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN383"><span class='Ref_to_Member'>numArrayKeys</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>                <a href="nbtutils.c.html#LN193"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN382"><span class='Ref_to_Member'>arrayKeyData</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>                <span class='Control'>return</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Quit if nothing to do. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN196"><span class='Ref_To_Local'>numArrayKeys</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="nbtutils.c.html#LN193"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN383"><span class='Ref_to_Member'>numArrayKeys</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="nbtutils.c.html#LN193"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN382"><span class='Ref_to_Member'>arrayKeyData</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Make a scan-lifespan context to hold array-associated data, or reset it 
     * if we already have one from a previous rescan cycle. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN193"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN388"><span class='Ref_to_Member'>arrayContext</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="nbtutils.c.html#LN193"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN388"><span class='Ref_to_Member'>arrayContext</span></a> <span class='Operator'>= </span><a href="../../../include/utils/memutils.h.html#LN145"><span class='Ref_to_Proto'>AllocSetContextCreate</span></a><span class='Parentheses'>(</span><a href="../../utils/mmgr/mcxt.c.html#LN36"><span class='Ref_to_Global_Var'>CurrentMemoryContext</span></a><span class='Delimiter'>, 
</span>                                                 <span class='String'>"BTree array context"</span><span class='Delimiter'>, 
</span>                                                 <a href="../../../include/utils/memutils.h.html#LN174"><span class='Ref_to_Const'>ALLOCSET_SMALL_SIZES</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="../../../include/utils/memutils.h.html#LN73"><span class='Ref_to_Proto'>MemoryContextReset</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN193"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN388"><span class='Ref_to_Member'>arrayContext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="nbtutils.c.html#LN199"><span class='Ref_To_Local'>oldContext</span></a> <span class='Operator'>= </span><a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN193"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN388"><span class='Ref_to_Member'>arrayContext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Create modifiable copy of scan-&GT;keyData in the workspace context */ 
</span>    <a href="nbtutils.c.html#LN193"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN382"><span class='Ref_to_Member'>arrayKeyData</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN191"><span class='Ref_to_Parameter'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN90"><span class='Ref_to_Member'>numberOfKeys</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/access/skey.h.html#LN63"><span class='Ref_to_Struct'>ScanKeyData</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    memcpy<span class='Parentheses'>(</span><a href="nbtutils.c.html#LN193"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN382"><span class='Ref_to_Member'>arrayKeyData</span></a><span class='Delimiter'>, 
</span>           <a href="nbtutils.c.html#LN191"><span class='Ref_to_Parameter'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN92"><span class='Ref_to_Member'>keyData</span></a><span class='Delimiter'>, 
</span>           <a href="nbtutils.c.html#LN191"><span class='Ref_to_Parameter'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN90"><span class='Ref_to_Member'>numberOfKeys</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/access/skey.h.html#LN63"><span class='Ref_to_Struct'>ScanKeyData</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Allocate space for per-array data in the workspace context */ 
</span>    <a href="nbtutils.c.html#LN193"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN387"><span class='Ref_to_Member'>arrayKeys</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN365"><span class='Ref_to_Struct'>BTArrayKeyInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN196"><span class='Ref_To_Local'>numArrayKeys</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN365"><span class='Ref_to_Struct'>BTArrayKeyInfo</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Now process each array key */ 
</span>    <a href="nbtutils.c.html#LN196"><span class='Ref_To_Local'>numArrayKeys</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN198"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nbtutils.c.html#LN198"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="nbtutils.c.html#LN194"><span class='Ref_To_Local'>numberOfKeys</span></a><span class='Delimiter'>; </span><a href="nbtutils.c.html#LN198"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN254"></a>        <a href="../../../include/utils/array.h.html#LN75"><span class='Ref_to_Typedef'>ArrayType</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>arrayval</span><span class='Delimiter'>; 
</span><a name="LN255"></a>        <a href="../../../include/c.h.html#LN254"><span class='Ref_to_Typedef'>int16</span></a>       <span class='Declare_Local'>elmlen</span><span class='Delimiter'>; 
</span><a name="LN256"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>elmbyval</span><span class='Delimiter'>; 
</span><a name="LN257"></a>        <span class='Keyword'>char</span>        <span class='Declare_Local'>elmalign</span><span class='Delimiter'>; 
</span><a name="LN258"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>num_elems</span><span class='Delimiter'>; 
</span><a name="LN259"></a>        <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>elem_values</span><span class='Delimiter'>; 
</span><a name="LN260"></a>        <span class='Keyword'>bool</span>       <span class='Operator'>*</span><span class='Declare_Local'>elem_nulls</span><span class='Delimiter'>; 
</span><a name="LN261"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>num_nonnulls</span><span class='Delimiter'>; 
</span><a name="LN262"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>j</span><span class='Delimiter'>; 
</span> 
        <a href="nbtutils.c.html#LN197"><span class='Ref_To_Local'>cur</span></a> <span class='Operator'>= &</span><a href="nbtutils.c.html#LN193"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN382"><span class='Ref_to_Member'>arrayKeyData</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN198"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN197"><span class='Ref_To_Local'>cur</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/skey.h.html#LN119"><span class='Ref_to_Const'>SK_SEARCHARRAY</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * First, deconstruct the array into elements.  Anything allocated 
         * here (including a possibly detoasted array value) is in the 
         * workspace context. 
         */ 
</span>        <a href="nbtutils.c.html#LN254"><span class='Ref_To_Local'>arrayval</span></a> <span class='Operator'>= </span><a href="../../../include/utils/array.h.html#LN241"><span class='Ref_to_Macro'>DatumGetArrayTypeP</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN197"><span class='Ref_To_Local'>cur</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN71"><span class='Ref_to_Member'>sk_argument</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* We could cache this data, but not clear it's worth it */ 
</span>        <a href="../../../include/utils/lsyscache.h.html#LN136"><span class='Ref_to_Proto'>get_typlenbyvalalign</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/array.h.html#LN272"><span class='Ref_to_Macro'>ARR_ELEMTYPE</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN254"><span class='Ref_To_Local'>arrayval</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                             <span class='Operator'>&</span><a href="nbtutils.c.html#LN255"><span class='Ref_To_Local'>elmlen</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nbtutils.c.html#LN256"><span class='Ref_To_Local'>elmbyval</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nbtutils.c.html#LN257"><span class='Ref_To_Local'>elmalign</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/utils/array.h.html#LN382"><span class='Ref_to_Proto'>deconstruct_array</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN254"><span class='Ref_To_Local'>arrayval</span></a><span class='Delimiter'>, 
</span>                          <a href="../../../include/utils/array.h.html#LN272"><span class='Ref_to_Macro'>ARR_ELEMTYPE</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN254"><span class='Ref_To_Local'>arrayval</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                          <a href="nbtutils.c.html#LN255"><span class='Ref_To_Local'>elmlen</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN256"><span class='Ref_To_Local'>elmbyval</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN257"><span class='Ref_To_Local'>elmalign</span></a><span class='Delimiter'>, 
</span>                          <span class='Operator'>&</span><a href="nbtutils.c.html#LN259"><span class='Ref_To_Local'>elem_values</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nbtutils.c.html#LN260"><span class='Ref_To_Local'>elem_nulls</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nbtutils.c.html#LN258"><span class='Ref_To_Local'>num_elems</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Compress out any null elements.  We can ignore them since we assume 
         * all btree operators are strict. 
         */ 
</span>        <a href="nbtutils.c.html#LN261"><span class='Ref_To_Local'>num_nonnulls</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN262"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nbtutils.c.html#LN262"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>&LT; </span><a href="nbtutils.c.html#LN258"><span class='Ref_To_Local'>num_elems</span></a><span class='Delimiter'>; </span><a href="nbtutils.c.html#LN262"><span class='Ref_To_Local'>j</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="nbtutils.c.html#LN260"><span class='Ref_To_Local'>elem_nulls</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN262"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>                <a href="nbtutils.c.html#LN259"><span class='Ref_To_Local'>elem_values</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN261"><span class='Ref_To_Local'>num_nonnulls</span></a><span class='Operator'>++</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="nbtutils.c.html#LN259"><span class='Ref_To_Local'>elem_values</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN262"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>]; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* We could pfree(elem_nulls) now, but not worth the cycles */ 
</span> 
        <span class='Comment_Multi_Line'>/* If there's no non-nulls, the scan qual is unsatisfiable */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN261"><span class='Ref_To_Local'>num_nonnulls</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="nbtutils.c.html#LN196"><span class='Ref_To_Local'>numArrayKeys</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If the comparison operator is not equality, then the array qual 
         * degenerates to a simple comparison against the smallest or largest 
         * non-null array element, as appropriate. 
         */ 
</span>        <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN197"><span class='Ref_To_Local'>cur</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN67"><span class='Ref_to_Member'>sk_strategy</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>case</span> <a href="../../../include/access/stratnum.h.html#LN28"><span class='Ref_to_Const'>BTLessStrategyNumber</span></a><span class='Operator'>: 
</span>            <span class='Control'>case</span> <a href="../../../include/access/stratnum.h.html#LN29"><span class='Ref_to_Const'>BTLessEqualStrategyNumber</span></a><span class='Operator'>: 
</span>                <a href="nbtutils.c.html#LN197"><span class='Ref_To_Local'>cur</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN71"><span class='Ref_to_Member'>sk_argument</span></a> <span class='Operator'>= 
</span>                    <a href="nbtutils.c.html#LN36"><span class='Ref_to_Proto'>_bt_find_extreme_element</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN191"><span class='Ref_to_Parameter'>scan</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN197"><span class='Ref_To_Local'>cur</span></a><span class='Delimiter'>, 
</span>                                             <a href="../../../include/access/stratnum.h.html#LN32"><span class='Ref_to_Const'>BTGreaterStrategyNumber</span></a><span class='Delimiter'>, 
</span>                                             <a href="nbtutils.c.html#LN259"><span class='Ref_To_Local'>elem_values</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN261"><span class='Ref_To_Local'>num_nonnulls</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>continue</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../../include/access/stratnum.h.html#LN30"><span class='Ref_to_Const'>BTEqualStrategyNumber</span></a><span class='Operator'>: 
</span>                <span class='Comment_Multi_Line'>/* proceed with rest of loop */ 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../../include/access/stratnum.h.html#LN31"><span class='Ref_to_Const'>BTGreaterEqualStrategyNumber</span></a><span class='Operator'>: 
</span>            <span class='Control'>case</span> <a href="../../../include/access/stratnum.h.html#LN32"><span class='Ref_to_Const'>BTGreaterStrategyNumber</span></a><span class='Operator'>: 
</span>                <a href="nbtutils.c.html#LN197"><span class='Ref_To_Local'>cur</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN71"><span class='Ref_to_Member'>sk_argument</span></a> <span class='Operator'>= 
</span>                    <a href="nbtutils.c.html#LN36"><span class='Ref_to_Proto'>_bt_find_extreme_element</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN191"><span class='Ref_to_Parameter'>scan</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN197"><span class='Ref_To_Local'>cur</span></a><span class='Delimiter'>, 
</span>                                             <a href="../../../include/access/stratnum.h.html#LN28"><span class='Ref_to_Const'>BTLessStrategyNumber</span></a><span class='Delimiter'>, 
</span>                                             <a href="nbtutils.c.html#LN259"><span class='Ref_To_Local'>elem_values</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN261"><span class='Ref_To_Local'>num_nonnulls</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>continue</span><span class='Delimiter'>; 
</span>            <span class='Control'>default</span><span class='Operator'>: 
</span>                <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized StrategyNumber: %d"</span><span class='Delimiter'>, 
</span>                     <span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="nbtutils.c.html#LN197"><span class='Ref_To_Local'>cur</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN67"><span class='Ref_to_Member'>sk_strategy</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch cur-&GT;sk_strategy &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* 
         * Sort the non-null elements and eliminate any duplicates.  We must 
         * sort in the same ordering used by the index column, so that the 
         * successive primitive indexscans produce data in index order. 
         */ 
</span>        <a href="nbtutils.c.html#LN258"><span class='Ref_To_Local'>num_elems</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN39"><span class='Ref_to_Proto'>_bt_sort_array_elements</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN191"><span class='Ref_to_Parameter'>scan</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN197"><span class='Ref_To_Local'>cur</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN195"><span class='Ref_To_Local'>indoption</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN197"><span class='Ref_To_Local'>cur</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN66"><span class='Ref_to_Member'>sk_attno</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>& </span><a href="../../../include/catalog/pg_index.h.html#LN98"><span class='Ref_to_Const'>INDOPTION_DESC</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Delimiter'>, 
</span>                                            <a href="nbtutils.c.html#LN259"><span class='Ref_To_Local'>elem_values</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN261"><span class='Ref_To_Local'>num_nonnulls</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * And set up the BTArrayKeyInfo data. 
         */ 
</span>        <a href="nbtutils.c.html#LN193"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN387"><span class='Ref_to_Member'>arrayKeys</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN196"><span class='Ref_To_Local'>numArrayKeys</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/access/nbtree.h.html#LN367"><span class='Ref_to_Member'>scan_key</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN198"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>; 
</span>        <a href="nbtutils.c.html#LN193"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN387"><span class='Ref_to_Member'>arrayKeys</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN196"><span class='Ref_To_Local'>numArrayKeys</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/access/nbtree.h.html#LN370"><span class='Ref_to_Member'>num_elems</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN258"><span class='Ref_To_Local'>num_elems</span></a><span class='Delimiter'>; 
</span>        <a href="nbtutils.c.html#LN193"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN387"><span class='Ref_to_Member'>arrayKeys</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN196"><span class='Ref_To_Local'>numArrayKeys</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/access/nbtree.h.html#LN371"><span class='Ref_to_Member'>elem_values</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN259"><span class='Ref_To_Local'>elem_values</span></a><span class='Delimiter'>; 
</span>        <a href="nbtutils.c.html#LN196"><span class='Ref_To_Local'>numArrayKeys</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;numberOfKeys;i+... &raquo; </span> 
 
    <a href="nbtutils.c.html#LN193"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN383"><span class='Ref_to_Member'>numArrayKeys</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN196"><span class='Ref_To_Local'>numArrayKeys</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN199"><span class='Ref_To_Local'>oldContext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end _bt_preprocess_array_keys &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * _bt_find_extreme_element() -- get least or greatest array element 
 * 
 * scan and skey identify the index column, whose opfamily determines the 
 * comparison semantics.  strat should be BTLessStrategyNumber to get the 
 * least element, or BTGreaterStrategyNumber to get the greatest. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN363"></a><span class='Declare_Function'>_bt_find_extreme_element</span><span class='Parentheses'>(</span><a href="../../../include/access/genam.h.html#LN85"><span class='Ref_to_Typedef'>IndexScanDesc</span></a> <span class='Declare_Parameter'>scan</span><span class='Delimiter'>, </span><a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a> <span class='Declare_Parameter'>skey</span><span class='Delimiter'>, 
</span><a name="LN364"></a>                         <a href="../../../include/access/stratnum.h.html#LN21"><span class='Ref_to_Typedef'>StrategyNumber</span></a> <span class='Declare_Parameter'>strat</span><span class='Delimiter'>, 
</span><a name="LN365"></a>                         <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>elems</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>nelems</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN367"></a>    <a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>rel</span> <span class='Operator'>= </span><a href="nbtutils.c.html#LN363"><span class='Ref_to_Parameter'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN88"><span class='Ref_to_Member'>indexRelation</span></a><span class='Delimiter'>; 
</span><a name="LN368"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>elemtype</span><span class='Delimiter'>, 
</span><a name="LN369"></a>                <span class='Declare_Local'>cmp_op</span><span class='Delimiter'>; 
</span><a name="LN370"></a>    <a href="../../../include/c.h.html#LN394"><span class='Ref_to_Typedef'>RegProcedure</span></a> <span class='Declare_Local'>cmp_proc</span><span class='Delimiter'>; 
</span><a name="LN371"></a>    <a href="../../../include/fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a>    <span class='Declare_Local'>flinfo</span><span class='Delimiter'>; 
</span><a name="LN372"></a>    <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span><a name="LN373"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Determine the nominal datatype of the array elements.  We have to 
     * support the convention that sk_subtype == InvalidOid means the opclass 
     * input type; this is a hack to simplify life for ScanKeyInit(). 
     */ 
</span>    <a href="nbtutils.c.html#LN368"><span class='Ref_To_Local'>elemtype</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN363"><span class='Ref_to_Parameter'>skey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN68"><span class='Ref_to_Member'>sk_subtype</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN368"><span class='Ref_To_Local'>elemtype</span></a> <span class='Operator'>== </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Parentheses'>) 
</span>        <a href="nbtutils.c.html#LN368"><span class='Ref_To_Local'>elemtype</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN367"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN182"><span class='Ref_to_Member'>rd_opcintype</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN363"><span class='Ref_to_Parameter'>skey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN66"><span class='Ref_to_Member'>sk_attno</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Look up the appropriate comparison operator in the opfamily. 
     * 
     * Note: it's possible that this would fail, if the opfamily is 
     * incomplete, but it seems quite unlikely that an opfamily would omit 
     * non-cross-type comparison operators for any datatype that it supports 
     * at all. 
     */ 
</span>    <a href="nbtutils.c.html#LN369"><span class='Ref_To_Local'>cmp_op</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN70"><span class='Ref_to_Proto'>get_opfamily_member</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN367"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN181"><span class='Ref_to_Member'>rd_opfamily</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN363"><span class='Ref_to_Parameter'>skey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN66"><span class='Ref_to_Member'>sk_attno</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>], 
</span>                                 <a href="nbtutils.c.html#LN368"><span class='Ref_To_Local'>elemtype</span></a><span class='Delimiter'>, 
</span>                                 <a href="nbtutils.c.html#LN368"><span class='Ref_To_Local'>elemtype</span></a><span class='Delimiter'>, 
</span>                                 <a href="nbtutils.c.html#LN364"><span class='Ref_to_Parameter'>strat</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN369"><span class='Ref_To_Local'>cmp_op</span></a><span class='Parentheses'>))</span> 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"missing operator %d(%u,%u) in opfamily %u"</span><span class='Delimiter'>, 
</span>             <a href="nbtutils.c.html#LN364"><span class='Ref_to_Parameter'>strat</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN368"><span class='Ref_To_Local'>elemtype</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN368"><span class='Ref_To_Local'>elemtype</span></a><span class='Delimiter'>, 
</span>             <a href="nbtutils.c.html#LN367"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN181"><span class='Ref_to_Member'>rd_opfamily</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN363"><span class='Ref_to_Parameter'>skey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN66"><span class='Ref_to_Member'>sk_attno</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="nbtutils.c.html#LN370"><span class='Ref_To_Local'>cmp_proc</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN98"><span class='Ref_to_Proto'>get_opcode</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN369"><span class='Ref_To_Local'>cmp_op</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/c.h.html#LN539"><span class='Ref_to_Macro'>RegProcedureIsValid</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN370"><span class='Ref_To_Local'>cmp_proc</span></a><span class='Parentheses'>))</span> 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"missing oprcode for operator %u"</span><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN369"><span class='Ref_To_Local'>cmp_op</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/fmgr.h.html#LN92"><span class='Ref_to_Proto'>fmgr_info</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN370"><span class='Ref_To_Local'>cmp_proc</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nbtutils.c.html#LN371"><span class='Ref_To_Local'>flinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN365"><span class='Ref_to_Parameter'>nelems</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="nbtutils.c.html#LN372"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN365"><span class='Ref_to_Parameter'>elems</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN373"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="nbtutils.c.html#LN373"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="nbtutils.c.html#LN365"><span class='Ref_to_Parameter'>nelems</span></a><span class='Delimiter'>; </span><a href="nbtutils.c.html#LN373"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN398"><span class='Ref_to_Macro'>DatumGetBool</span></a><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN512"><span class='Ref_to_Proto'>FunctionCall2Coll</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nbtutils.c.html#LN371"><span class='Ref_To_Local'>flinfo</span></a><span class='Delimiter'>, 
</span>                                           <a href="nbtutils.c.html#LN363"><span class='Ref_to_Parameter'>skey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN69"><span class='Ref_to_Member'>sk_collation</span></a><span class='Delimiter'>, 
</span>                                           <a href="nbtutils.c.html#LN365"><span class='Ref_to_Parameter'>elems</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN373"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], 
</span>                                           <a href="nbtutils.c.html#LN372"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>)))</span> 
            <a href="nbtutils.c.html#LN372"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN365"><span class='Ref_to_Parameter'>elems</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN373"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="nbtutils.c.html#LN372"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end _bt_find_extreme_element &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * _bt_sort_array_elements() -- sort and de-dup array elements 
 * 
 * The array elements are sorted in-place, and the new number of elements 
 * after duplicate removal is returned. 
 * 
 * scan and skey identify the index column, whose opfamily determines the 
 * comparison semantics.  If reverse is true, we sort in descending order. 
 */ 
</span><span class='Keyword'>static int 
</span><a name="LN430"></a><span class='Declare_Function'>_bt_sort_array_elements</span><span class='Parentheses'>(</span><a href="../../../include/access/genam.h.html#LN85"><span class='Ref_to_Typedef'>IndexScanDesc</span></a> <span class='Declare_Parameter'>scan</span><span class='Delimiter'>, </span><a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a> <span class='Declare_Parameter'>skey</span><span class='Delimiter'>, 
</span><a name="LN431"></a>                        <span class='Keyword'>bool </span><span class='Declare_Parameter'>reverse</span><span class='Delimiter'>, 
</span><a name="LN432"></a>                        <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>elems</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>nelems</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN434"></a>    <a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>rel</span> <span class='Operator'>= </span><a href="nbtutils.c.html#LN430"><span class='Ref_to_Parameter'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN88"><span class='Ref_to_Member'>indexRelation</span></a><span class='Delimiter'>; 
</span><a name="LN435"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>elemtype</span><span class='Delimiter'>; 
</span><a name="LN436"></a>    <a href="../../../include/c.h.html#LN394"><span class='Ref_to_Typedef'>RegProcedure</span></a> <span class='Declare_Local'>cmp_proc</span><span class='Delimiter'>; 
</span><a name="LN437"></a>    <a href="nbtutils.c.html#LN29"><span class='Ref_to_Struct'>BTSortArrayContext</span></a> <span class='Declare_Local'>cxt</span><span class='Delimiter'>; 
</span><a name="LN438"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>last_non_dup</span><span class='Delimiter'>; 
</span><a name="LN439"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN432"><span class='Ref_to_Parameter'>nelems</span></a> <span class='Operator'>&LT;= </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="nbtutils.c.html#LN432"><span class='Ref_to_Parameter'>nelems</span></a><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* no work to do */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Determine the nominal datatype of the array elements.  We have to 
     * support the convention that sk_subtype == InvalidOid means the opclass 
     * input type; this is a hack to simplify life for ScanKeyInit(). 
     */ 
</span>    <a href="nbtutils.c.html#LN435"><span class='Ref_To_Local'>elemtype</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN430"><span class='Ref_to_Parameter'>skey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN68"><span class='Ref_to_Member'>sk_subtype</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN435"><span class='Ref_To_Local'>elemtype</span></a> <span class='Operator'>== </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Parentheses'>) 
</span>        <a href="nbtutils.c.html#LN435"><span class='Ref_To_Local'>elemtype</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN434"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN182"><span class='Ref_to_Member'>rd_opcintype</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN430"><span class='Ref_to_Parameter'>skey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN66"><span class='Ref_to_Member'>sk_attno</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Look up the appropriate comparison function in the opfamily. 
     * 
     * Note: it's possible that this would fail, if the opfamily is 
     * incomplete, but it seems quite unlikely that an opfamily would omit 
     * non-cross-type support functions for any datatype that it supports at 
     * all. 
     */ 
</span>    <a href="nbtutils.c.html#LN436"><span class='Ref_To_Local'>cmp_proc</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN83"><span class='Ref_to_Proto'>get_opfamily_proc</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN434"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN181"><span class='Ref_to_Member'>rd_opfamily</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN430"><span class='Ref_to_Parameter'>skey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN66"><span class='Ref_to_Member'>sk_attno</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>], 
</span>                                 <a href="nbtutils.c.html#LN435"><span class='Ref_To_Local'>elemtype</span></a><span class='Delimiter'>, 
</span>                                 <a href="nbtutils.c.html#LN435"><span class='Ref_To_Local'>elemtype</span></a><span class='Delimiter'>, 
</span>                                 <a href="../../../include/access/nbtree.h.html#LN228"><span class='Ref_to_Const'>BTORDER_PROC</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/c.h.html#LN539"><span class='Ref_to_Macro'>RegProcedureIsValid</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN436"><span class='Ref_To_Local'>cmp_proc</span></a><span class='Parentheses'>))</span> 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"missing support function %d(%u,%u) in opfamily %u"</span><span class='Delimiter'>, 
</span>             <a href="../../../include/access/nbtree.h.html#LN228"><span class='Ref_to_Const'>BTORDER_PROC</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN435"><span class='Ref_To_Local'>elemtype</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN435"><span class='Ref_To_Local'>elemtype</span></a><span class='Delimiter'>, 
</span>             <a href="nbtutils.c.html#LN434"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN181"><span class='Ref_to_Member'>rd_opfamily</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN430"><span class='Ref_to_Parameter'>skey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN66"><span class='Ref_to_Member'>sk_attno</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Sort the array elements */ 
</span>    <a href="../../../include/fmgr.h.html#LN92"><span class='Ref_to_Proto'>fmgr_info</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN436"><span class='Ref_To_Local'>cmp_proc</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nbtutils.c.html#LN437"><span class='Ref_To_Local'>cxt</span></a><span class='Operator'>.</span><a href="nbtutils.c.html#LN31"><span class='Ref_to_Member'>flinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="nbtutils.c.html#LN437"><span class='Ref_To_Local'>cxt</span></a><span class='Operator'>.</span><a href="nbtutils.c.html#LN32"><span class='Ref_to_Member'>collation</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN430"><span class='Ref_to_Parameter'>skey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN69"><span class='Ref_to_Member'>sk_collation</span></a><span class='Delimiter'>; 
</span>    <a href="nbtutils.c.html#LN437"><span class='Ref_To_Local'>cxt</span></a><span class='Operator'>.</span><a href="nbtutils.c.html#LN33"><span class='Ref_to_Member'>reverse</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN431"><span class='Ref_to_Parameter'>reverse</span></a><span class='Delimiter'>; 
</span>    <a href="../../../port/qsort_arg.c.html#LN111"><span class='Ref_to_Func'>qsort_arg</span></a><span class='Parentheses'>((</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nbtutils.c.html#LN432"><span class='Ref_to_Parameter'>elems</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN432"><span class='Ref_to_Parameter'>nelems</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>              <a href="nbtutils.c.html#LN42"><span class='Ref_to_Proto'>_bt_compare_array_elements</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><a href="nbtutils.c.html#LN437"><span class='Ref_To_Local'>cxt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Now scan the sorted elements and remove duplicates */ 
</span>    <a href="nbtutils.c.html#LN438"><span class='Ref_To_Local'>last_non_dup</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN439"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="nbtutils.c.html#LN439"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="nbtutils.c.html#LN432"><span class='Ref_to_Parameter'>nelems</span></a><span class='Delimiter'>; </span><a href="nbtutils.c.html#LN439"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN481"></a>        <a href="../../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Local'>compare</span><span class='Delimiter'>; 
</span> 
        <a href="nbtutils.c.html#LN481"><span class='Ref_To_Local'>compare</span></a> <span class='Operator'>= </span><a href="../../../include/postgres.h.html#LN477"><span class='Ref_to_Macro'>DatumGetInt32</span></a><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN512"><span class='Ref_to_Proto'>FunctionCall2Coll</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nbtutils.c.html#LN437"><span class='Ref_To_Local'>cxt</span></a><span class='Operator'>.</span><a href="nbtutils.c.html#LN31"><span class='Ref_to_Member'>flinfo</span></a><span class='Delimiter'>, 
</span>                                                  <a href="nbtutils.c.html#LN437"><span class='Ref_To_Local'>cxt</span></a><span class='Operator'>.</span><a href="nbtutils.c.html#LN32"><span class='Ref_to_Member'>collation</span></a><span class='Delimiter'>, 
</span>                                                  <a href="nbtutils.c.html#LN432"><span class='Ref_to_Parameter'>elems</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN438"><span class='Ref_To_Local'>last_non_dup</span></a><span class='Delimiter'>], 
</span>                                                  <a href="nbtutils.c.html#LN432"><span class='Ref_to_Parameter'>elems</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN439"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN481"><span class='Ref_To_Local'>compare</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <a href="nbtutils.c.html#LN432"><span class='Ref_to_Parameter'>elems</span></a><span class='Delimiter'>[</span><span class='Operator'>++</span><a href="nbtutils.c.html#LN438"><span class='Ref_To_Local'>last_non_dup</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="nbtutils.c.html#LN432"><span class='Ref_to_Parameter'>elems</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN439"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="nbtutils.c.html#LN438"><span class='Ref_To_Local'>last_non_dup</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end _bt_sort_array_elements &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * qsort_arg comparator for sorting array elements 
 */ 
</span><span class='Keyword'>static int 
</span><a name="LN498"></a><span class='Declare_Function'>_bt_compare_array_elements</span><span class='Parentheses'>(</span><span class='Keyword'>const void </span><span class='Operator'>*</span><span class='Declare_Parameter'>a</span><span class='Delimiter'>, </span><span class='Keyword'>const void </span><span class='Operator'>*</span><span class='Declare_Parameter'>b</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>arg</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN500"></a>    <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>da</span> <span class='Operator'>= *</span><span class='Parentheses'>((</span><span class='Keyword'>const </span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nbtutils.c.html#LN498"><span class='Ref_to_Parameter'>a</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN501"></a>    <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>db</span> <span class='Operator'>= *</span><span class='Parentheses'>((</span><span class='Keyword'>const </span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nbtutils.c.html#LN498"><span class='Ref_to_Parameter'>b</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN502"></a>    <a href="nbtutils.c.html#LN29"><span class='Ref_to_Struct'>BTSortArrayContext</span></a> <span class='Operator'>*</span><span class='Declare_Local'>cxt</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN29"><span class='Ref_to_Struct'>BTSortArrayContext</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nbtutils.c.html#LN498"><span class='Ref_to_Parameter'>arg</span></a><span class='Delimiter'>; 
</span><a name="LN503"></a>    <a href="../../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Local'>compare</span><span class='Delimiter'>; 
</span> 
    <a href="nbtutils.c.html#LN503"><span class='Ref_To_Local'>compare</span></a> <span class='Operator'>= </span><a href="../../../include/postgres.h.html#LN477"><span class='Ref_to_Macro'>DatumGetInt32</span></a><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN512"><span class='Ref_to_Proto'>FunctionCall2Coll</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nbtutils.c.html#LN502"><span class='Ref_To_Local'>cxt</span></a><span class='Operator'>-&GT;</span><a href="nbtutils.c.html#LN31"><span class='Ref_to_Member'>flinfo</span></a><span class='Delimiter'>, 
</span>                                              <a href="nbtutils.c.html#LN502"><span class='Ref_To_Local'>cxt</span></a><span class='Operator'>-&GT;</span><a href="nbtutils.c.html#LN32"><span class='Ref_to_Member'>collation</span></a><span class='Delimiter'>, 
</span>                                              <a href="nbtutils.c.html#LN500"><span class='Ref_To_Local'>da</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN501"><span class='Ref_To_Local'>db</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN502"><span class='Ref_To_Local'>cxt</span></a><span class='Operator'>-&GT;</span><a href="nbtutils.c.html#LN33"><span class='Ref_to_Member'>reverse</span></a><span class='Parentheses'>) 
</span>        <a href="nbtutils.c.html#LN503"><span class='Ref_To_Local'>compare</span></a> <span class='Operator'>= -</span><a href="nbtutils.c.html#LN503"><span class='Ref_To_Local'>compare</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="nbtutils.c.html#LN503"><span class='Ref_To_Local'>compare</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * _bt_start_array_keys() -- Initialize array keys at start of a scan 
 * 
 * Set up the cur_elem counters and fill in the first sk_argument value for 
 * each array scankey.  We can't do this until we know the scan direction. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN520"></a><span class='Declare_Function'>_bt_start_array_keys</span><span class='Parentheses'>(</span><a href="../../../include/access/genam.h.html#LN85"><span class='Ref_to_Typedef'>IndexScanDesc</span></a> <span class='Declare_Parameter'>scan</span><span class='Delimiter'>, </span><a href="../../../include/access/sdir.h.html#LN21"><span class='Ref_to_Enum'>ScanDirection</span></a> <span class='Declare_Parameter'>dir</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN522"></a>    <a href="../../../include/access/nbtree.h.html#LN416"><span class='Ref_to_Typedef'>BTScanOpaque</span></a> <span class='Declare_Local'>so</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN416"><span class='Ref_to_Typedef'>BTScanOpaque</span></a><span class='Parentheses'>) </span><a href="nbtutils.c.html#LN520"><span class='Ref_to_Parameter'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN104"><span class='Ref_to_Member'>opaque</span></a><span class='Delimiter'>; 
</span><a name="LN523"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN523"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nbtutils.c.html#LN523"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="nbtutils.c.html#LN522"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN383"><span class='Ref_to_Member'>numArrayKeys</span></a><span class='Delimiter'>; </span><a href="nbtutils.c.html#LN523"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN527"></a>        <a href="../../../include/access/nbtree.h.html#LN365"><span class='Ref_to_Struct'>BTArrayKeyInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>curArrayKey</span> <span class='Operator'>= &</span><a href="nbtutils.c.html#LN522"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN387"><span class='Ref_to_Member'>arrayKeys</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN523"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span><a name="LN528"></a>        <a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a>     <span class='Declare_Local'>skey</span> <span class='Operator'>= &</span><a href="nbtutils.c.html#LN522"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN382"><span class='Ref_to_Member'>arrayKeyData</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN527"><span class='Ref_To_Local'>curArrayKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN367"><span class='Ref_to_Member'>scan_key</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN527"><span class='Ref_To_Local'>curArrayKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN370"><span class='Ref_to_Member'>num_elems</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/sdir.h.html#LN40"><span class='Ref_to_Macro'>ScanDirectionIsBackward</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN520"><span class='Ref_to_Parameter'>dir</span></a><span class='Parentheses'>))</span> 
            <a href="nbtutils.c.html#LN527"><span class='Ref_To_Local'>curArrayKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN368"><span class='Ref_to_Member'>cur_elem</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN527"><span class='Ref_To_Local'>curArrayKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN370"><span class='Ref_to_Member'>num_elems</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="nbtutils.c.html#LN527"><span class='Ref_To_Local'>curArrayKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN368"><span class='Ref_to_Member'>cur_elem</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="nbtutils.c.html#LN528"><span class='Ref_To_Local'>skey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN71"><span class='Ref_to_Member'>sk_argument</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN527"><span class='Ref_To_Local'>curArrayKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN371"><span class='Ref_to_Member'>elem_values</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN527"><span class='Ref_To_Local'>curArrayKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN368"><span class='Ref_to_Member'>cur_elem</span></a><span class='Delimiter'>]; 
</span>    <span class='Delimiter'>} 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * _bt_advance_array_keys() -- Advance to next set of array elements 
 * 
 * Returns TRUE if there is another set of values to consider, FALSE if not. 
 * On TRUE result, the scankeys are initialized with the next set of values. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN546"></a><span class='Declare_Function'>_bt_advance_array_keys</span><span class='Parentheses'>(</span><a href="../../../include/access/genam.h.html#LN85"><span class='Ref_to_Typedef'>IndexScanDesc</span></a> <span class='Declare_Parameter'>scan</span><span class='Delimiter'>, </span><a href="../../../include/access/sdir.h.html#LN21"><span class='Ref_to_Enum'>ScanDirection</span></a> <span class='Declare_Parameter'>dir</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN548"></a>    <a href="../../../include/access/nbtree.h.html#LN416"><span class='Ref_to_Typedef'>BTScanOpaque</span></a> <span class='Declare_Local'>so</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN416"><span class='Ref_to_Typedef'>BTScanOpaque</span></a><span class='Parentheses'>) </span><a href="nbtutils.c.html#LN546"><span class='Ref_to_Parameter'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN104"><span class='Ref_to_Member'>opaque</span></a><span class='Delimiter'>; 
</span><a name="LN549"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>found</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN550"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We must advance the last array key most quickly, since it will 
     * correspond to the lowest-order index column among the available 
     * qualifications. This is necessary to ensure correct ordering of output 
     * when there are multiple array keys. 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN550"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN548"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN383"><span class='Ref_to_Member'>numArrayKeys</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="nbtutils.c.html#LN550"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nbtutils.c.html#LN550"><span class='Ref_To_Local'>i</span></a><span class='Operator'>--</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN560"></a>        <a href="../../../include/access/nbtree.h.html#LN365"><span class='Ref_to_Struct'>BTArrayKeyInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>curArrayKey</span> <span class='Operator'>= &</span><a href="nbtutils.c.html#LN548"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN387"><span class='Ref_to_Member'>arrayKeys</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN550"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span><a name="LN561"></a>        <a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a>     <span class='Declare_Local'>skey</span> <span class='Operator'>= &</span><a href="nbtutils.c.html#LN548"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN382"><span class='Ref_to_Member'>arrayKeyData</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN560"><span class='Ref_To_Local'>curArrayKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN367"><span class='Ref_to_Member'>scan_key</span></a><span class='Delimiter'>]; 
</span><a name="LN562"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>cur_elem</span> <span class='Operator'>= </span><a href="nbtutils.c.html#LN560"><span class='Ref_To_Local'>curArrayKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN368"><span class='Ref_to_Member'>cur_elem</span></a><span class='Delimiter'>; 
</span><a name="LN563"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>num_elems</span> <span class='Operator'>= </span><a href="nbtutils.c.html#LN560"><span class='Ref_To_Local'>curArrayKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN370"><span class='Ref_to_Member'>num_elems</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/sdir.h.html#LN40"><span class='Ref_to_Macro'>ScanDirectionIsBackward</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN546"><span class='Ref_to_Parameter'>dir</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>--</span><a href="nbtutils.c.html#LN562"><span class='Ref_To_Local'>cur_elem</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="nbtutils.c.html#LN562"><span class='Ref_To_Local'>cur_elem</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN563"><span class='Ref_To_Local'>num_elems</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>                <a href="nbtutils.c.html#LN549"><span class='Ref_To_Local'>found</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* need to advance next array key */ 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
                <a href="nbtutils.c.html#LN549"><span class='Ref_To_Local'>found</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>++</span><a href="nbtutils.c.html#LN562"><span class='Ref_To_Local'>cur_elem</span></a> <span class='Operator'>&GT;= </span><a href="nbtutils.c.html#LN563"><span class='Ref_To_Local'>num_elems</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="nbtutils.c.html#LN562"><span class='Ref_To_Local'>cur_elem</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>                <a href="nbtutils.c.html#LN549"><span class='Ref_To_Local'>found</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* need to advance next array key */ 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
                <a href="nbtutils.c.html#LN549"><span class='Ref_To_Local'>found</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="nbtutils.c.html#LN560"><span class='Ref_To_Local'>curArrayKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN368"><span class='Ref_to_Member'>cur_elem</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN562"><span class='Ref_To_Local'>cur_elem</span></a><span class='Delimiter'>; 
</span>        <a href="nbtutils.c.html#LN561"><span class='Ref_To_Local'>skey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN71"><span class='Ref_to_Member'>sk_argument</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN560"><span class='Ref_To_Local'>curArrayKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN371"><span class='Ref_to_Member'>elem_values</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN562"><span class='Ref_To_Local'>cur_elem</span></a><span class='Delimiter'>]; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN549"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=so-&GT;numArrayKeys-1;... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* advance parallel scan */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN546"><span class='Ref_to_Parameter'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN138"><span class='Ref_to_Member'>parallel_scan</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="../../../include/access/nbtree.h.html#LN464"><span class='Ref_to_Proto'>_bt_parallel_advance_array_keys</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN546"><span class='Ref_to_Parameter'>scan</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="nbtutils.c.html#LN549"><span class='Ref_To_Local'>found</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end _bt_advance_array_keys &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * _bt_mark_array_keys() -- Handle array keys during btmarkpos 
 * 
 * Save the current state of the array keys as the "mark" position. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN605"></a><span class='Declare_Function'>_bt_mark_array_keys</span><span class='Parentheses'>(</span><a href="../../../include/access/genam.h.html#LN85"><span class='Ref_to_Typedef'>IndexScanDesc</span></a> <span class='Declare_Parameter'>scan</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN607"></a>    <a href="../../../include/access/nbtree.h.html#LN416"><span class='Ref_to_Typedef'>BTScanOpaque</span></a> <span class='Declare_Local'>so</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN416"><span class='Ref_to_Typedef'>BTScanOpaque</span></a><span class='Parentheses'>) </span><a href="nbtutils.c.html#LN605"><span class='Ref_to_Parameter'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN104"><span class='Ref_to_Member'>opaque</span></a><span class='Delimiter'>; 
</span><a name="LN608"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN608"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nbtutils.c.html#LN608"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="nbtutils.c.html#LN607"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN383"><span class='Ref_to_Member'>numArrayKeys</span></a><span class='Delimiter'>; </span><a href="nbtutils.c.html#LN608"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN612"></a>        <a href="../../../include/access/nbtree.h.html#LN365"><span class='Ref_to_Struct'>BTArrayKeyInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>curArrayKey</span> <span class='Operator'>= &</span><a href="nbtutils.c.html#LN607"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN387"><span class='Ref_to_Member'>arrayKeys</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN608"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
        <a href="nbtutils.c.html#LN612"><span class='Ref_To_Local'>curArrayKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN369"><span class='Ref_to_Member'>mark_elem</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN612"><span class='Ref_To_Local'>curArrayKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN368"><span class='Ref_to_Member'>cur_elem</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * _bt_restore_array_keys() -- Handle array keys during btrestrpos 
 * 
 * Restore the array keys to where they were when the mark was set. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN624"></a><span class='Declare_Function'>_bt_restore_array_keys</span><span class='Parentheses'>(</span><a href="../../../include/access/genam.h.html#LN85"><span class='Ref_to_Typedef'>IndexScanDesc</span></a> <span class='Declare_Parameter'>scan</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN626"></a>    <a href="../../../include/access/nbtree.h.html#LN416"><span class='Ref_to_Typedef'>BTScanOpaque</span></a> <span class='Declare_Local'>so</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN416"><span class='Ref_to_Typedef'>BTScanOpaque</span></a><span class='Parentheses'>) </span><a href="nbtutils.c.html#LN624"><span class='Ref_to_Parameter'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN104"><span class='Ref_to_Member'>opaque</span></a><span class='Delimiter'>; 
</span><a name="LN627"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>changed</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN628"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Restore each array key to its position when the mark was set */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN628"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nbtutils.c.html#LN628"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="nbtutils.c.html#LN626"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN383"><span class='Ref_to_Member'>numArrayKeys</span></a><span class='Delimiter'>; </span><a href="nbtutils.c.html#LN628"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN633"></a>        <a href="../../../include/access/nbtree.h.html#LN365"><span class='Ref_to_Struct'>BTArrayKeyInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>curArrayKey</span> <span class='Operator'>= &</span><a href="nbtutils.c.html#LN626"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN387"><span class='Ref_to_Member'>arrayKeys</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN628"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span><a name="LN634"></a>        <a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a>     <span class='Declare_Local'>skey</span> <span class='Operator'>= &</span><a href="nbtutils.c.html#LN626"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN382"><span class='Ref_to_Member'>arrayKeyData</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN633"><span class='Ref_To_Local'>curArrayKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN367"><span class='Ref_to_Member'>scan_key</span></a><span class='Delimiter'>]; 
</span><a name="LN635"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>mark_elem</span> <span class='Operator'>= </span><a href="nbtutils.c.html#LN633"><span class='Ref_To_Local'>curArrayKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN369"><span class='Ref_to_Member'>mark_elem</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN633"><span class='Ref_To_Local'>curArrayKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN368"><span class='Ref_to_Member'>cur_elem</span></a> <span class='Operator'>!= </span><a href="nbtutils.c.html#LN635"><span class='Ref_To_Local'>mark_elem</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="nbtutils.c.html#LN633"><span class='Ref_To_Local'>curArrayKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN368"><span class='Ref_to_Member'>cur_elem</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN635"><span class='Ref_To_Local'>mark_elem</span></a><span class='Delimiter'>; 
</span>            <a href="nbtutils.c.html#LN634"><span class='Ref_To_Local'>skey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN71"><span class='Ref_to_Member'>sk_argument</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN633"><span class='Ref_To_Local'>curArrayKey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN371"><span class='Ref_to_Member'>elem_values</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN635"><span class='Ref_To_Local'>mark_elem</span></a><span class='Delimiter'>]; 
</span>            <a href="nbtutils.c.html#LN627"><span class='Ref_To_Local'>changed</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we changed any keys, we must redo _bt_preprocess_keys.  That might 
     * sound like overkill, but in cases with multiple keys per index column 
     * it seems necessary to do the full set of pushups. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN627"><span class='Ref_To_Local'>changed</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/access/nbtree.h.html#LN525"><span class='Ref_to_Proto'>_bt_preprocess_keys</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN624"><span class='Ref_to_Parameter'>scan</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* The mark should have been set on a consistent set of keys... */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN626"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN377"><span class='Ref_to_Member'>qual_ok</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end _bt_restore_array_keys &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 *  _bt_preprocess_keys() -- Preprocess scan keys 
 * 
 * The given search-type keys (in scan-&GT;keyData[] or so-&GT;arrayKeyData[]) 
 * are copied to so-&GT;keyData[] with possible transformation. 
 * scan-&GT;numberOfKeys is the number of input keys, so-&GT;numberOfKeys gets 
 * the number of output keys (possibly less, never greater). 
 * 
 * The output keys are marked with additional sk_flag bits beyond the 
 * system-standard bits supplied by the caller.  The DESC and NULLS_FIRST 
 * indoption bits for the relevant index attribute are copied into the flags. 
 * Also, for a DESC column, we commute (flip) all the sk_strategy numbers 
 * so that the index sorts in the desired direction. 
 * 
 * One key purpose of this routine is to discover which scan keys must be 
 * satisfied to continue the scan.  It also attempts to eliminate redundant 
 * keys and detect contradictory keys.  (If the index opfamily provides 
 * incomplete sets of cross-type operators, we may fail to detect redundant 
 * or contradictory keys, but we can survive that.) 
 * 
 * The output keys must be sorted by index attribute.  Presently we expect 
 * (but verify) that the input keys are already so sorted --- this is done 
 * by match_clauses_to_index() in indxpath.c.  Some reordering of the keys 
 * within each attribute may be done as a byproduct of the processing here, 
 * but no other code depends on that. 
 * 
 * The output keys are marked with flags SK_BT_REQFWD and/or SK_BT_REQBKWD 
 * if they must be satisfied in order to continue the scan forward or backward 
 * respectively.  _bt_checkkeys uses these flags.  For example, if the quals 
 * are "x = 1 AND y &LT; 4 AND z &LT; 5", then _bt_checkkeys will reject a tuple 
 * (1,2,7), but we must continue the scan in case there are tuples (1,3,z). 
 * But once we reach tuples like (1,4,z) we can stop scanning because no 
 * later tuples could match.  This is reflected by marking the x and y keys, 
 * but not the z key, with SK_BT_REQFWD.  In general, the keys for leading 
 * attributes with "=" keys are marked both SK_BT_REQFWD and SK_BT_REQBKWD. 
 * For the first attribute without an "=" key, any "&LT;" and "&LT;=" keys are 
 * marked SK_BT_REQFWD while any "&GT;" and "&GT;=" keys are marked SK_BT_REQBKWD. 
 * This can be seen to be correct by considering the above example.  Note 
 * in particular that if there are no keys for a given attribute, the keys for 
 * subsequent attributes can never be required; for instance "WHERE y = 4" 
 * requires a full-index scan. 
 * 
 * If possible, redundant keys are eliminated: we keep only the tightest 
 * &GT;/&GT;= bound and the tightest &LT;/&LT;= bound, and if there's an = key then 
 * that's the only one returned.  (So, we return either a single = key, 
 * or one or two boundary-condition keys for each attr.)  However, if we 
 * cannot compare two keys for lack of a suitable cross-type operator, 
 * we cannot eliminate either.  If there are two such keys of the same 
 * operator strategy, the second one is just pushed into the output array 
 * without further processing here.  We may also emit both &GT;/&GT;= or both 
 * &LT;/&LT;= keys if we can't compare them.  The logic about required keys still 
 * works if we don't eliminate redundant keys. 
 * 
 * Note that one reason we need direction-sensitive required-key flags is 
 * precisely that we may not be able to eliminate redundant keys.  Suppose 
 * we have "x &GT; 4::int AND x &GT; 10::bigint", and we are unable to determine 
 * which key is more restrictive for lack of a suitable cross-type operator. 
 * _bt_first will arbitrarily pick one of the keys to do the initial 
 * positioning with.  If it picks x &GT; 4, then the x &GT; 10 condition will fail 
 * until we reach index entries &GT; 10; but we can't stop the scan just because 
 * x &GT; 10 is failing.  On the other hand, if we are scanning backwards, then 
 * failure of either key is indeed enough to stop the scan.  (In general, when 
 * inequality keys are present, the initial-positioning code only promises to 
 * position before the first possible match, not exactly at the first match, 
 * for a forward scan; or after the last match for a backward scan.) 
 * 
 * As a byproduct of this work, we can detect contradictory quals such 
 * as "x = 1 AND x &GT; 2".  If we see that, we return so-&GT;qual_ok = FALSE, 
 * indicating the scan need not be run at all since no tuples can match. 
 * (In this case we do not bother completing the output key array!) 
 * Again, missing cross-type operators might cause us to fail to prove the 
 * quals contradictory when they really are, but the scan will work correctly. 
 * 
 * Row comparison keys are currently also treated without any smarts: 
 * we just transfer them into the preprocessed array without any 
 * editorialization.  We can treat them the same as an ordinary inequality 
 * comparison on the row's first index column, for the purposes of the logic 
 * about required keys. 
 * 
 * Note: the reason we have to copy the preprocessed scan keys into private 
 * storage is that we are modifying the array based on comparisons of the 
 * key argument values, which could change on a rescan or after moving to 
 * new elements of array keys.  Therefore we can't overwrite the source data. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN744"></a><span class='Declare_Function'>_bt_preprocess_keys</span><span class='Parentheses'>(</span><a href="../../../include/access/genam.h.html#LN85"><span class='Ref_to_Typedef'>IndexScanDesc</span></a> <span class='Declare_Parameter'>scan</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN746"></a>    <a href="../../../include/access/nbtree.h.html#LN416"><span class='Ref_to_Typedef'>BTScanOpaque</span></a> <span class='Declare_Local'>so</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN416"><span class='Ref_to_Typedef'>BTScanOpaque</span></a><span class='Parentheses'>) </span><a href="nbtutils.c.html#LN744"><span class='Ref_to_Parameter'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN104"><span class='Ref_to_Member'>opaque</span></a><span class='Delimiter'>; 
</span><a name="LN747"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numberOfKeys</span> <span class='Operator'>= </span><a href="nbtutils.c.html#LN744"><span class='Ref_to_Parameter'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN90"><span class='Ref_to_Member'>numberOfKeys</span></a><span class='Delimiter'>; 
</span><a name="LN748"></a>    <a href="../../../include/c.h.html#LN254"><span class='Ref_to_Typedef'>int16</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>indoption</span> <span class='Operator'>= </span><a href="nbtutils.c.html#LN744"><span class='Ref_to_Parameter'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN88"><span class='Ref_to_Member'>indexRelation</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN185"><span class='Ref_to_Member'>rd_indoption</span></a><span class='Delimiter'>; 
</span><a name="LN749"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>new_numberOfKeys</span><span class='Delimiter'>; 
</span><a name="LN750"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numberOfEqualCols</span><span class='Delimiter'>; 
</span><a name="LN751"></a>    <a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a>     <span class='Declare_Local'>inkeys</span><span class='Delimiter'>; 
</span><a name="LN752"></a>    <a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a>     <span class='Declare_Local'>outkeys</span><span class='Delimiter'>; 
</span><a name="LN753"></a>    <a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a>     <span class='Declare_Local'>cur</span><span class='Delimiter'>; 
</span><a name="LN754"></a>    <a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a>     <span class='Declare_Local'>xform</span><span class='Delimiter'>[</span><a href="../../../include/access/stratnum.h.html#LN34"><span class='Ref_to_Const'>BTMaxStrategyNumber</span></a><span class='Delimiter'>]; 
</span><a name="LN755"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>test_result</span><span class='Delimiter'>; 
</span><a name="LN756"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>, 
</span><a name="LN757"></a>                <span class='Declare_Local'>j</span><span class='Delimiter'>; 
</span><a name="LN758"></a>    <a href="../../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a>  <span class='Declare_Local'>attno</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* initialize result variables */ 
</span>    <a href="nbtutils.c.html#LN746"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN377"><span class='Ref_to_Member'>qual_ok</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <a href="nbtutils.c.html#LN746"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN378"><span class='Ref_to_Member'>numberOfKeys</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN747"><span class='Ref_To_Local'>numberOfKeys</span></a> <span class='Operator'>&LT; </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>;</span>                 <span class='Comment_Single_Line'>/* done if qual-less scan */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Read so-&GT;arrayKeyData if array keys are present, else scan-&GT;keyData 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN746"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN382"><span class='Ref_to_Member'>arrayKeyData</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="nbtutils.c.html#LN751"><span class='Ref_To_Local'>inkeys</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN746"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN382"><span class='Ref_to_Member'>arrayKeyData</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="nbtutils.c.html#LN751"><span class='Ref_To_Local'>inkeys</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN744"><span class='Ref_to_Parameter'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN92"><span class='Ref_to_Member'>keyData</span></a><span class='Delimiter'>; 
</span> 
    <a href="nbtutils.c.html#LN752"><span class='Ref_To_Local'>outkeys</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN746"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN379"><span class='Ref_to_Member'>keyData</span></a><span class='Delimiter'>; 
</span>    <a href="nbtutils.c.html#LN753"><span class='Ref_To_Local'>cur</span></a> <span class='Operator'>= &</span><a href="nbtutils.c.html#LN751"><span class='Ref_To_Local'>inkeys</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]; 
</span>    <span class='Comment_Multi_Line'>/* we check that input keys are correctly ordered */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN753"><span class='Ref_To_Local'>cur</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN66"><span class='Ref_to_Member'>sk_attno</span></a> <span class='Operator'>&LT; </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"btree index keys must be ordered by attribute"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* We can short-circuit most of the work if there's just one key */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN747"><span class='Ref_To_Local'>numberOfKeys</span></a> <span class='Operator'>== </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Apply indoption to scankey (might change sk_strategy!) */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="nbtutils.c.html#LN46"><span class='Ref_to_Proto'>_bt_fix_scankey_strategy</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN753"><span class='Ref_To_Local'>cur</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN748"><span class='Ref_To_Local'>indoption</span></a><span class='Parentheses'>))</span> 
            <a href="nbtutils.c.html#LN746"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN377"><span class='Ref_to_Member'>qual_ok</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        memcpy<span class='Parentheses'>(</span><a href="nbtutils.c.html#LN752"><span class='Ref_To_Local'>outkeys</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN753"><span class='Ref_To_Local'>cur</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/access/skey.h.html#LN63"><span class='Ref_to_Struct'>ScanKeyData</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="nbtutils.c.html#LN746"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN378"><span class='Ref_to_Member'>numberOfKeys</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* We can mark the qual as required if it's for first index col */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN753"><span class='Ref_To_Local'>cur</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN66"><span class='Ref_to_Member'>sk_attno</span></a> <span class='Operator'>== </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>            <a href="nbtutils.c.html#LN47"><span class='Ref_to_Proto'>_bt_mark_scankey_required</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN752"><span class='Ref_To_Local'>outkeys</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Otherwise, do the full set of pushups. 
     */ 
</span>    <a href="nbtutils.c.html#LN749"><span class='Ref_To_Local'>new_numberOfKeys</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="nbtutils.c.html#LN750"><span class='Ref_To_Local'>numberOfEqualCols</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Initialize for processing of keys for attr 1. 
     * 
     * xform[i] points to the currently best scan key of strategy type i+1; it 
     * is NULL if we haven't yet found such a key for this attr. 
     */ 
</span>    <a href="nbtutils.c.html#LN758"><span class='Ref_To_Local'>attno</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    memset<span class='Parentheses'>(</span><a href="nbtutils.c.html#LN754"><span class='Ref_To_Local'>xform</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN754"><span class='Ref_To_Local'>xform</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Loop iterates from 0 to numberOfKeys inclusive; we use the last pass to 
     * handle after-last-key processing.  Actual exit from the loop is at the 
     * "break" statement below. 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN756"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>;; </span><a href="nbtutils.c.html#LN753"><span class='Ref_To_Local'>cur</span></a><span class='Operator'>++</span><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN756"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN756"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="nbtutils.c.html#LN747"><span class='Ref_To_Local'>numberOfKeys</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Apply indoption to scankey (might change sk_strategy!) */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="nbtutils.c.html#LN46"><span class='Ref_to_Proto'>_bt_fix_scankey_strategy</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN753"><span class='Ref_To_Local'>cur</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN748"><span class='Ref_To_Local'>indoption</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* NULL can't be matched, so give up */ 
</span>                <a href="nbtutils.c.html#LN746"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN377"><span class='Ref_to_Member'>qual_ok</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                <span class='Control'>return</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If we are at the end of the keys for a particular attr, finish up 
         * processing and emit the cleaned-up keys. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN756"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>== </span><a href="nbtutils.c.html#LN747"><span class='Ref_To_Local'>numberOfKeys</span></a> <span class='Operator'>|| </span><a href="nbtutils.c.html#LN753"><span class='Ref_To_Local'>cur</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN66"><span class='Ref_to_Member'>sk_attno</span></a> <span class='Operator'>!= </span><a href="nbtutils.c.html#LN758"><span class='Ref_To_Local'>attno</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN834"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>priorNumberOfEqualCols</span> <span class='Operator'>= </span><a href="nbtutils.c.html#LN750"><span class='Ref_To_Local'>numberOfEqualCols</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* check input keys are correctly ordered */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN756"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="nbtutils.c.html#LN747"><span class='Ref_To_Local'>numberOfKeys</span></a> <span class='Operator'>&& </span><a href="nbtutils.c.html#LN753"><span class='Ref_To_Local'>cur</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN66"><span class='Ref_to_Member'>sk_attno</span></a> <span class='Operator'>&LT; </span><a href="nbtutils.c.html#LN758"><span class='Ref_To_Local'>attno</span></a><span class='Parentheses'>) 
</span>                <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"btree index keys must be ordered by attribute"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * If = has been specified, all other keys can be eliminated as 
             * redundant.  If we have a case like key = 1 AND key &GT; 2, we can 
             * set qual_ok to false and abandon further processing. 
             * 
             * We also have to deal with the case of "key IS NULL", which is 
             * unsatisfiable in combination with any other index condition. By 
             * the time we get here, that's been classified as an equality 
             * check, and we've rejected any combination of it with a regular 
             * equality condition; but not with other types of conditions. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN754"><span class='Ref_To_Local'>xform</span></a><span class='Delimiter'>[</span><a href="../../../include/access/stratnum.h.html#LN30"><span class='Ref_to_Const'>BTEqualStrategyNumber</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN853"></a>                <a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a>     <span class='Declare_Local'>eq</span> <span class='Operator'>= </span><a href="nbtutils.c.html#LN754"><span class='Ref_To_Local'>xform</span></a><span class='Delimiter'>[</span><a href="../../../include/access/stratnum.h.html#LN30"><span class='Ref_to_Const'>BTEqualStrategyNumber</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]; 
</span> 
                <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN757"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>= </span><a href="../../../include/access/stratnum.h.html#LN34"><span class='Ref_to_Const'>BTMaxStrategyNumber</span></a><span class='Delimiter'>; </span><span class='Operator'>--</span><a href="nbtutils.c.html#LN757"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Delimiter'>;</span><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span><a name="LN857"></a>                    <a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a>     <span class='Declare_Local'>chk</span> <span class='Operator'>= </span><a href="nbtutils.c.html#LN754"><span class='Ref_To_Local'>xform</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN757"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>]; 
</span> 
                    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="nbtutils.c.html#LN857"><span class='Ref_To_Local'>chk</span></a> <span class='Operator'>|| </span><a href="nbtutils.c.html#LN757"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>== </span><span class='Parentheses'>(</span><a href="../../../include/access/stratnum.h.html#LN30"><span class='Ref_to_Const'>BTEqualStrategyNumber</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>))</span> 
                        <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN853"><span class='Ref_To_Local'>eq</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/skey.h.html#LN120"><span class='Ref_to_Const'>SK_SEARCHNULL</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <span class='Comment_Multi_Line'>/* IS NULL is contradictory to anything else */ 
</span>                        <a href="nbtutils.c.html#LN746"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN377"><span class='Ref_to_Member'>qual_ok</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                        <span class='Control'>return</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span> 
                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN43"><span class='Ref_to_Proto'>_bt_compare_scankey_args</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN744"><span class='Ref_to_Parameter'>scan</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN857"><span class='Ref_To_Local'>chk</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN853"><span class='Ref_To_Local'>eq</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN857"><span class='Ref_To_Local'>chk</span></a><span class='Delimiter'>, 
</span>                                                 <span class='Operator'>&</span><a href="nbtutils.c.html#LN755"><span class='Ref_To_Local'>test_result</span></a><span class='Parentheses'>))</span> 
                    <span class='Delimiter'>{ 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="nbtutils.c.html#LN755"><span class='Ref_To_Local'>test_result</span></a><span class='Parentheses'>) 
</span>                        <span class='Delimiter'>{ 
</span>                            <span class='Comment_Multi_Line'>/* keys proven mutually contradictory */ 
</span>                            <a href="nbtutils.c.html#LN746"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN377"><span class='Ref_to_Member'>qual_ok</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                            <span class='Control'>return</span><span class='Delimiter'>; 
</span>                        <span class='Delimiter'>} 
</span>                        <span class='Comment_Multi_Line'>/* else discard the redundant non-equality key */ 
</span>                        <a href="nbtutils.c.html#LN754"><span class='Ref_To_Local'>xform</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN757"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                    <span class='Comment_Multi_Line'>/* else, cannot determine redundancy, keep both keys */ 
</span>                <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for j=BTMaxStrategyNumber... &raquo; </span> 
                <span class='Comment_Multi_Line'>/* track number of attrs for which we have "=" keys */ 
</span>                <a href="nbtutils.c.html#LN750"><span class='Ref_To_Local'>numberOfEqualCols</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if xform[BTEqualStrategy... &raquo; </span> 
 
            <span class='Comment_Multi_Line'>/* try to keep only one of &LT;, &LT;= */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN754"><span class='Ref_To_Local'>xform</span></a><span class='Delimiter'>[</span><a href="../../../include/access/stratnum.h.html#LN28"><span class='Ref_to_Const'>BTLessStrategyNumber</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] 
</span>                <span class='Operator'>&& </span><a href="nbtutils.c.html#LN754"><span class='Ref_To_Local'>xform</span></a><span class='Delimiter'>[</span><a href="../../../include/access/stratnum.h.html#LN29"><span class='Ref_to_Const'>BTLessEqualStrategyNumber</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN891"></a>                <a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a>     <span class='Declare_Local'>lt</span> <span class='Operator'>= </span><a href="nbtutils.c.html#LN754"><span class='Ref_To_Local'>xform</span></a><span class='Delimiter'>[</span><a href="../../../include/access/stratnum.h.html#LN28"><span class='Ref_to_Const'>BTLessStrategyNumber</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]; 
</span><a name="LN892"></a>                <a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a>     <span class='Declare_Local'>le</span> <span class='Operator'>= </span><a href="nbtutils.c.html#LN754"><span class='Ref_To_Local'>xform</span></a><span class='Delimiter'>[</span><a href="../../../include/access/stratnum.h.html#LN29"><span class='Ref_to_Const'>BTLessEqualStrategyNumber</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN43"><span class='Ref_to_Proto'>_bt_compare_scankey_args</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN744"><span class='Ref_to_Parameter'>scan</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN892"><span class='Ref_To_Local'>le</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN891"><span class='Ref_To_Local'>lt</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN892"><span class='Ref_To_Local'>le</span></a><span class='Delimiter'>, 
</span>                                             <span class='Operator'>&</span><a href="nbtutils.c.html#LN755"><span class='Ref_To_Local'>test_result</span></a><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN755"><span class='Ref_To_Local'>test_result</span></a><span class='Parentheses'>) 
</span>                        <a href="nbtutils.c.html#LN754"><span class='Ref_To_Local'>xform</span></a><span class='Delimiter'>[</span><a href="../../../include/access/stratnum.h.html#LN29"><span class='Ref_to_Const'>BTLessEqualStrategyNumber</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>                    <span class='Control'>else</span> 
                        <a href="nbtutils.c.html#LN754"><span class='Ref_To_Local'>xform</span></a><span class='Delimiter'>[</span><a href="../../../include/access/stratnum.h.html#LN28"><span class='Ref_to_Const'>BTLessStrategyNumber</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* try to keep only one of &GT;, &GT;= */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN754"><span class='Ref_To_Local'>xform</span></a><span class='Delimiter'>[</span><a href="../../../include/access/stratnum.h.html#LN32"><span class='Ref_to_Const'>BTGreaterStrategyNumber</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] 
</span>                <span class='Operator'>&& </span><a href="nbtutils.c.html#LN754"><span class='Ref_To_Local'>xform</span></a><span class='Delimiter'>[</span><a href="../../../include/access/stratnum.h.html#LN31"><span class='Ref_to_Const'>BTGreaterEqualStrategyNumber</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN908"></a>                <a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a>     <span class='Declare_Local'>gt</span> <span class='Operator'>= </span><a href="nbtutils.c.html#LN754"><span class='Ref_To_Local'>xform</span></a><span class='Delimiter'>[</span><a href="../../../include/access/stratnum.h.html#LN32"><span class='Ref_to_Const'>BTGreaterStrategyNumber</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]; 
</span><a name="LN909"></a>                <a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a>     <span class='Declare_Local'>ge</span> <span class='Operator'>= </span><a href="nbtutils.c.html#LN754"><span class='Ref_To_Local'>xform</span></a><span class='Delimiter'>[</span><a href="../../../include/access/stratnum.h.html#LN31"><span class='Ref_to_Const'>BTGreaterEqualStrategyNumber</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN43"><span class='Ref_to_Proto'>_bt_compare_scankey_args</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN744"><span class='Ref_to_Parameter'>scan</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN909"><span class='Ref_To_Local'>ge</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN908"><span class='Ref_To_Local'>gt</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN909"><span class='Ref_To_Local'>ge</span></a><span class='Delimiter'>, 
</span>                                             <span class='Operator'>&</span><a href="nbtutils.c.html#LN755"><span class='Ref_To_Local'>test_result</span></a><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN755"><span class='Ref_To_Local'>test_result</span></a><span class='Parentheses'>) 
</span>                        <a href="nbtutils.c.html#LN754"><span class='Ref_To_Local'>xform</span></a><span class='Delimiter'>[</span><a href="../../../include/access/stratnum.h.html#LN31"><span class='Ref_to_Const'>BTGreaterEqualStrategyNumber</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>                    <span class='Control'>else</span> 
                        <a href="nbtutils.c.html#LN754"><span class='Ref_To_Local'>xform</span></a><span class='Delimiter'>[</span><a href="../../../include/access/stratnum.h.html#LN32"><span class='Ref_to_Const'>BTGreaterStrategyNumber</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Emit the cleaned-up keys into the outkeys[] array, and then 
             * mark them if they are required.  They are required (possibly 
             * only in one direction) if all attrs before this one had "=". 
             */ 
</span>            <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN757"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>= </span><a href="../../../include/access/stratnum.h.html#LN34"><span class='Ref_to_Const'>BTMaxStrategyNumber</span></a><span class='Delimiter'>; </span><span class='Operator'>--</span><a href="nbtutils.c.html#LN757"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Delimiter'>;</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN754"><span class='Ref_To_Local'>xform</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN757"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span><a name="LN930"></a>                    <a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a>     <span class='Declare_Local'>outkey</span> <span class='Operator'>= &</span><a href="nbtutils.c.html#LN752"><span class='Ref_To_Local'>outkeys</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN749"><span class='Ref_To_Local'>new_numberOfKeys</span></a><span class='Operator'>++</span><span class='Delimiter'>]; 
</span> 
                    memcpy<span class='Parentheses'>(</span><a href="nbtutils.c.html#LN930"><span class='Ref_To_Local'>outkey</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN754"><span class='Ref_To_Local'>xform</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN757"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>], </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/access/skey.h.html#LN63"><span class='Ref_to_Struct'>ScanKeyData</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN834"><span class='Ref_To_Local'>priorNumberOfEqualCols</span></a> <span class='Operator'>== </span><a href="nbtutils.c.html#LN758"><span class='Ref_To_Local'>attno</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>                        <a href="nbtutils.c.html#LN47"><span class='Ref_to_Proto'>_bt_mark_scankey_required</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN930"><span class='Ref_To_Local'>outkey</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Exit loop here if done. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN756"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>== </span><a href="nbtutils.c.html#LN747"><span class='Ref_To_Local'>numberOfKeys</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Re-initialize for new attno */ 
</span>            <a href="nbtutils.c.html#LN758"><span class='Ref_To_Local'>attno</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN753"><span class='Ref_To_Local'>cur</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN66"><span class='Ref_to_Member'>sk_attno</span></a><span class='Delimiter'>; 
</span>            memset<span class='Parentheses'>(</span><a href="nbtutils.c.html#LN754"><span class='Ref_To_Local'>xform</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN754"><span class='Ref_To_Local'>xform</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if i==numberOfKeys||cur-... &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* check strategy this key's operator corresponds to */ 
</span>        <a href="nbtutils.c.html#LN757"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN753"><span class='Ref_To_Local'>cur</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN67"><span class='Ref_to_Member'>sk_strategy</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* if row comparison, push it directly to the output array */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN753"><span class='Ref_To_Local'>cur</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/skey.h.html#LN116"><span class='Ref_to_Const'>SK_ROW_HEADER</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN955"></a>            <a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a>     <span class='Declare_Local'>outkey</span> <span class='Operator'>= &</span><a href="nbtutils.c.html#LN752"><span class='Ref_To_Local'>outkeys</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN749"><span class='Ref_To_Local'>new_numberOfKeys</span></a><span class='Operator'>++</span><span class='Delimiter'>]; 
</span> 
            memcpy<span class='Parentheses'>(</span><a href="nbtutils.c.html#LN955"><span class='Ref_To_Local'>outkey</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN753"><span class='Ref_To_Local'>cur</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/access/skey.h.html#LN63"><span class='Ref_to_Struct'>ScanKeyData</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN750"><span class='Ref_To_Local'>numberOfEqualCols</span></a> <span class='Operator'>== </span><a href="nbtutils.c.html#LN758"><span class='Ref_To_Local'>attno</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>                <a href="nbtutils.c.html#LN47"><span class='Ref_to_Proto'>_bt_mark_scankey_required</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN955"><span class='Ref_To_Local'>outkey</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * We don't support RowCompare using equality; such a qual would 
             * mess up the numberOfEqualCols tracking. 
             */ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN757"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>!= </span><span class='Parentheses'>(</span><a href="../../../include/access/stratnum.h.html#LN30"><span class='Ref_to_Const'>BTEqualStrategyNumber</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* have we seen one of these before? */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN754"><span class='Ref_To_Local'>xform</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN757"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* nope, so remember this scankey */ 
</span>            <a href="nbtutils.c.html#LN754"><span class='Ref_To_Local'>xform</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN757"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="nbtutils.c.html#LN753"><span class='Ref_To_Local'>cur</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* yup, keep only the more restrictive key */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN43"><span class='Ref_to_Proto'>_bt_compare_scankey_args</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN744"><span class='Ref_to_Parameter'>scan</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN753"><span class='Ref_To_Local'>cur</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN753"><span class='Ref_To_Local'>cur</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN754"><span class='Ref_To_Local'>xform</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN757"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>], 
</span>                                         <span class='Operator'>&</span><a href="nbtutils.c.html#LN755"><span class='Ref_To_Local'>test_result</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN755"><span class='Ref_To_Local'>test_result</span></a><span class='Parentheses'>) 
</span>                    <a href="nbtutils.c.html#LN754"><span class='Ref_To_Local'>xform</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN757"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="nbtutils.c.html#LN753"><span class='Ref_To_Local'>cur</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN757"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>== </span><span class='Parentheses'>(</span><a href="../../../include/access/stratnum.h.html#LN30"><span class='Ref_to_Const'>BTEqualStrategyNumber</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* key == a && key == b, but a != b */ 
</span>                    <a href="nbtutils.c.html#LN746"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN377"><span class='Ref_to_Member'>qual_ok</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                    <span class='Control'>return</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Comment_Multi_Line'>/* else old key is more restrictive, keep it */ 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * We can't determine which key is more restrictive.  Keep the 
                 * previous one in xform[j] and push this one directly to the 
                 * output array. 
                 */ 
</span><a name="LN998"></a>                <a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a>     <span class='Declare_Local'>outkey</span> <span class='Operator'>= &</span><a href="nbtutils.c.html#LN752"><span class='Ref_To_Local'>outkeys</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN749"><span class='Ref_To_Local'>new_numberOfKeys</span></a><span class='Operator'>++</span><span class='Delimiter'>]; 
</span> 
                memcpy<span class='Parentheses'>(</span><a href="nbtutils.c.html#LN998"><span class='Ref_To_Local'>outkey</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN753"><span class='Ref_To_Local'>cur</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/access/skey.h.html#LN63"><span class='Ref_to_Struct'>ScanKeyData</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN750"><span class='Ref_To_Local'>numberOfEqualCols</span></a> <span class='Operator'>== </span><a href="nbtutils.c.html#LN758"><span class='Ref_To_Local'>attno</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>                    <a href="nbtutils.c.html#LN47"><span class='Ref_to_Proto'>_bt_mark_scankey_required</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN998"><span class='Ref_To_Local'>outkey</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;;cur++,i++ &raquo; </span> 
 
    <a href="nbtutils.c.html#LN746"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN378"><span class='Ref_to_Member'>numberOfKeys</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN749"><span class='Ref_To_Local'>new_numberOfKeys</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end _bt_preprocess_keys &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Compare two scankey values using a specified operator. 
 * 
 * The test we want to perform is logically "leftarg op rightarg", where 
 * leftarg and rightarg are the sk_argument values in those ScanKeys, and 
 * the comparison operator is the one in the op ScanKey.  However, in 
 * cross-data-type situations we may need to look up the correct operator in 
 * the index's opfamily: it is the one having amopstrategy = op-&GT;sk_strategy 
 * and amoplefttype/amoprighttype equal to the two argument datatypes. 
 * 
 * If the opfamily doesn't supply a complete set of cross-type operators we 
 * may not be able to make the comparison.  If we can make the comparison 
 * we store the operator result in *result and return TRUE.  We return FALSE 
 * if the comparison could not be made. 
 * 
 * Note: op always points at the same ScanKey as either leftarg or rightarg. 
 * Since we don't scribble on the scankeys, this aliasing should cause no 
 * trouble. 
 * 
 * Note: this routine needs to be insensitive to any DESC option applied 
 * to the index column.  For example, "x &LT; 4" is a tighter constraint than 
 * "x &LT; 5" regardless of which way the index is sorted. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN1034"></a><span class='Declare_Function'>_bt_compare_scankey_args</span><span class='Parentheses'>(</span><a href="../../../include/access/genam.h.html#LN85"><span class='Ref_to_Typedef'>IndexScanDesc</span></a> <span class='Declare_Parameter'>scan</span><span class='Delimiter'>, </span><a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a> <span class='Declare_Parameter'>op</span><span class='Delimiter'>, 
</span><a name="LN1035"></a>                         <a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a> <span class='Declare_Parameter'>leftarg</span><span class='Delimiter'>, </span><a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a> <span class='Declare_Parameter'>rightarg</span><span class='Delimiter'>, 
</span><a name="LN1036"></a>                         <span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>result</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1038"></a>    <a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>rel</span> <span class='Operator'>= </span><a href="nbtutils.c.html#LN1034"><span class='Ref_to_Parameter'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN88"><span class='Ref_to_Member'>indexRelation</span></a><span class='Delimiter'>; 
</span><a name="LN1039"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>lefttype</span><span class='Delimiter'>, 
</span><a name="LN1040"></a>                <span class='Declare_Local'>righttype</span><span class='Delimiter'>, 
</span><a name="LN1041"></a>                <span class='Declare_Local'>optype</span><span class='Delimiter'>, 
</span><a name="LN1042"></a>                <span class='Declare_Local'>opcintype</span><span class='Delimiter'>, 
</span><a name="LN1043"></a>                <span class='Declare_Local'>cmp_op</span><span class='Delimiter'>; 
</span><a name="LN1044"></a>    <a href="../../../include/access/stratnum.h.html#LN21"><span class='Ref_to_Typedef'>StrategyNumber</span></a> <span class='Declare_Local'>strat</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * First, deal with cases where one or both args are NULL.  This should 
     * only happen when the scankeys represent IS NULL/NOT NULL conditions. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="nbtutils.c.html#LN1035"><span class='Ref_to_Parameter'>leftarg</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>| </span><a href="nbtutils.c.html#LN1035"><span class='Ref_to_Parameter'>rightarg</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a><span class='Parentheses'>) </span><span class='Operator'>& </span><a href="../../../include/access/skey.h.html#LN114"><span class='Ref_to_Const'>SK_ISNULL</span></a><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1052"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>leftnull</span><span class='Delimiter'>, 
</span><a name="LN1053"></a>                    <span class='Declare_Local'>rightnull</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1035"><span class='Ref_to_Parameter'>leftarg</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/skey.h.html#LN114"><span class='Ref_to_Const'>SK_ISNULL</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1035"><span class='Ref_to_Parameter'>leftarg</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><span class='Parentheses'>(</span><a href="../../../include/access/skey.h.html#LN120"><span class='Ref_to_Const'>SK_SEARCHNULL</span></a> <span class='Operator'>| </span><a href="../../../include/access/skey.h.html#LN121"><span class='Ref_to_Const'>SK_SEARCHNOTNULL</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="nbtutils.c.html#LN1052"><span class='Ref_To_Local'>leftnull</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
            <a href="nbtutils.c.html#LN1052"><span class='Ref_To_Local'>leftnull</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1035"><span class='Ref_to_Parameter'>rightarg</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/skey.h.html#LN114"><span class='Ref_to_Const'>SK_ISNULL</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1035"><span class='Ref_to_Parameter'>rightarg</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><span class='Parentheses'>(</span><a href="../../../include/access/skey.h.html#LN120"><span class='Ref_to_Const'>SK_SEARCHNULL</span></a> <span class='Operator'>| </span><a href="../../../include/access/skey.h.html#LN121"><span class='Ref_to_Const'>SK_SEARCHNOTNULL</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="nbtutils.c.html#LN1053"><span class='Ref_To_Local'>rightnull</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
            <a href="nbtutils.c.html#LN1053"><span class='Ref_To_Local'>rightnull</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We treat NULL as either greater than or less than all other values. 
         * Since true &GT; false, the tests below work correctly for NULLS LAST 
         * logic.  If the index is NULLS FIRST, we need to flip the strategy. 
         */ 
</span>        <a href="nbtutils.c.html#LN1044"><span class='Ref_To_Local'>strat</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN1034"><span class='Ref_to_Parameter'>op</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN67"><span class='Ref_to_Member'>sk_strategy</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1034"><span class='Ref_to_Parameter'>op</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/nbtree.h.html#LN427"><span class='Ref_to_Const'>SK_BT_NULLS_FIRST</span></a><span class='Parentheses'>) 
</span>            <a href="nbtutils.c.html#LN1044"><span class='Ref_To_Local'>strat</span></a> <span class='Operator'>= </span><a href="../../../include/access/nbtree.h.html#LN214"><span class='Ref_to_Macro'>BTCommuteStrategyNumber</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1044"><span class='Ref_To_Local'>strat</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1044"><span class='Ref_To_Local'>strat</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>case</span> <a href="../../../include/access/stratnum.h.html#LN28"><span class='Ref_to_Const'>BTLessStrategyNumber</span></a><span class='Operator'>: 
</span>                <span class='Operator'>*</span><a href="nbtutils.c.html#LN1036"><span class='Ref_to_Parameter'>result</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1052"><span class='Ref_To_Local'>leftnull</span></a> <span class='Operator'>&LT; </span><a href="nbtutils.c.html#LN1053"><span class='Ref_To_Local'>rightnull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../../include/access/stratnum.h.html#LN29"><span class='Ref_to_Const'>BTLessEqualStrategyNumber</span></a><span class='Operator'>: 
</span>                <span class='Operator'>*</span><a href="nbtutils.c.html#LN1036"><span class='Ref_to_Parameter'>result</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1052"><span class='Ref_To_Local'>leftnull</span></a> <span class='Operator'>&LT;= </span><a href="nbtutils.c.html#LN1053"><span class='Ref_To_Local'>rightnull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../../include/access/stratnum.h.html#LN30"><span class='Ref_to_Const'>BTEqualStrategyNumber</span></a><span class='Operator'>: 
</span>                <span class='Operator'>*</span><a href="nbtutils.c.html#LN1036"><span class='Ref_to_Parameter'>result</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1052"><span class='Ref_To_Local'>leftnull</span></a> <span class='Operator'>== </span><a href="nbtutils.c.html#LN1053"><span class='Ref_To_Local'>rightnull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../../include/access/stratnum.h.html#LN31"><span class='Ref_to_Const'>BTGreaterEqualStrategyNumber</span></a><span class='Operator'>: 
</span>                <span class='Operator'>*</span><a href="nbtutils.c.html#LN1036"><span class='Ref_to_Parameter'>result</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1052"><span class='Ref_To_Local'>leftnull</span></a> <span class='Operator'>&GT;= </span><a href="nbtutils.c.html#LN1053"><span class='Ref_To_Local'>rightnull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../../include/access/stratnum.h.html#LN32"><span class='Ref_to_Const'>BTGreaterStrategyNumber</span></a><span class='Operator'>: 
</span>                <span class='Operator'>*</span><a href="nbtutils.c.html#LN1036"><span class='Ref_to_Parameter'>result</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1052"><span class='Ref_To_Local'>leftnull</span></a> <span class='Operator'>&GT; </span><a href="nbtutils.c.html#LN1053"><span class='Ref_To_Local'>rightnull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>default</span><span class='Operator'>: 
</span>                <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized StrategyNumber: %d"</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="nbtutils.c.html#LN1044"><span class='Ref_To_Local'>strat</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Operator'>*</span><a href="nbtutils.c.html#LN1036"><span class='Ref_to_Parameter'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* keep compiler quiet */ 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch strat &raquo; </span> 
        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if (leftarg-&GT;sk_flags|ri... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * The opfamily we need to worry about is identified by the index column. 
     */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1035"><span class='Ref_to_Parameter'>leftarg</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN66"><span class='Ref_to_Member'>sk_attno</span></a> <span class='Operator'>== </span><a href="nbtutils.c.html#LN1035"><span class='Ref_to_Parameter'>rightarg</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN66"><span class='Ref_to_Member'>sk_attno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="nbtutils.c.html#LN1042"><span class='Ref_To_Local'>opcintype</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN1038"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN182"><span class='Ref_to_Member'>rd_opcintype</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN1035"><span class='Ref_to_Parameter'>leftarg</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN66"><span class='Ref_to_Member'>sk_attno</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Determine the actual datatypes of the ScanKey arguments.  We have to 
     * support the convention that sk_subtype == InvalidOid means the opclass 
     * input type; this is a hack to simplify life for ScanKeyInit(). 
     */ 
</span>    <a href="nbtutils.c.html#LN1039"><span class='Ref_To_Local'>lefttype</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN1035"><span class='Ref_to_Parameter'>leftarg</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN68"><span class='Ref_to_Member'>sk_subtype</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1039"><span class='Ref_To_Local'>lefttype</span></a> <span class='Operator'>== </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Parentheses'>) 
</span>        <a href="nbtutils.c.html#LN1039"><span class='Ref_To_Local'>lefttype</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN1042"><span class='Ref_To_Local'>opcintype</span></a><span class='Delimiter'>; 
</span>    <a href="nbtutils.c.html#LN1040"><span class='Ref_To_Local'>righttype</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN1035"><span class='Ref_to_Parameter'>rightarg</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN68"><span class='Ref_to_Member'>sk_subtype</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1040"><span class='Ref_To_Local'>righttype</span></a> <span class='Operator'>== </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Parentheses'>) 
</span>        <a href="nbtutils.c.html#LN1040"><span class='Ref_To_Local'>righttype</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN1042"><span class='Ref_To_Local'>opcintype</span></a><span class='Delimiter'>; 
</span>    <a href="nbtutils.c.html#LN1041"><span class='Ref_To_Local'>optype</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN1034"><span class='Ref_to_Parameter'>op</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN68"><span class='Ref_to_Member'>sk_subtype</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1041"><span class='Ref_To_Local'>optype</span></a> <span class='Operator'>== </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Parentheses'>) 
</span>        <a href="nbtutils.c.html#LN1041"><span class='Ref_To_Local'>optype</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN1042"><span class='Ref_To_Local'>opcintype</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If leftarg and rightarg match the types expected for the "op" scankey, 
     * we can use its already-looked-up comparison function. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1039"><span class='Ref_To_Local'>lefttype</span></a> <span class='Operator'>== </span><a href="nbtutils.c.html#LN1042"><span class='Ref_To_Local'>opcintype</span></a> <span class='Operator'>&& </span><a href="nbtutils.c.html#LN1040"><span class='Ref_To_Local'>righttype</span></a> <span class='Operator'>== </span><a href="nbtutils.c.html#LN1041"><span class='Ref_To_Local'>optype</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Operator'>*</span><a href="nbtutils.c.html#LN1036"><span class='Ref_to_Parameter'>result</span></a> <span class='Operator'>= </span><a href="../../../include/postgres.h.html#LN398"><span class='Ref_to_Macro'>DatumGetBool</span></a><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN512"><span class='Ref_to_Proto'>FunctionCall2Coll</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nbtutils.c.html#LN1034"><span class='Ref_to_Parameter'>op</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN70"><span class='Ref_to_Member'>sk_func</span></a><span class='Delimiter'>, 
</span>                                                 <a href="nbtutils.c.html#LN1034"><span class='Ref_to_Parameter'>op</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN69"><span class='Ref_to_Member'>sk_collation</span></a><span class='Delimiter'>, 
</span>                                                 <a href="nbtutils.c.html#LN1035"><span class='Ref_to_Parameter'>leftarg</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN71"><span class='Ref_to_Member'>sk_argument</span></a><span class='Delimiter'>, 
</span>                                                 <a href="nbtutils.c.html#LN1035"><span class='Ref_to_Parameter'>rightarg</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN71"><span class='Ref_to_Member'>sk_argument</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Otherwise, we need to go to the syscache to find the appropriate 
     * operator.  (This cannot result in infinite recursion, since no 
     * indexscan initiated by syscache lookup will use cross-data-type 
     * operators.) 
     * 
     * If the sk_strategy was flipped by _bt_fix_scankey_strategy, we have to 
     * un-flip it to get the correct opfamily member. 
     */ 
</span>    <a href="nbtutils.c.html#LN1044"><span class='Ref_To_Local'>strat</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN1034"><span class='Ref_to_Parameter'>op</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN67"><span class='Ref_to_Member'>sk_strategy</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1034"><span class='Ref_to_Parameter'>op</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/nbtree.h.html#LN426"><span class='Ref_to_Const'>SK_BT_DESC</span></a><span class='Parentheses'>) 
</span>        <a href="nbtutils.c.html#LN1044"><span class='Ref_To_Local'>strat</span></a> <span class='Operator'>= </span><a href="../../../include/access/nbtree.h.html#LN214"><span class='Ref_to_Macro'>BTCommuteStrategyNumber</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1044"><span class='Ref_To_Local'>strat</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="nbtutils.c.html#LN1043"><span class='Ref_To_Local'>cmp_op</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN70"><span class='Ref_to_Proto'>get_opfamily_member</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1038"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN181"><span class='Ref_to_Member'>rd_opfamily</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN1035"><span class='Ref_to_Parameter'>leftarg</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN66"><span class='Ref_to_Member'>sk_attno</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>], 
</span>                                 <a href="nbtutils.c.html#LN1039"><span class='Ref_To_Local'>lefttype</span></a><span class='Delimiter'>, 
</span>                                 <a href="nbtutils.c.html#LN1040"><span class='Ref_To_Local'>righttype</span></a><span class='Delimiter'>, 
</span>                                 <a href="nbtutils.c.html#LN1044"><span class='Ref_To_Local'>strat</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1043"><span class='Ref_To_Local'>cmp_op</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1158"></a>        <a href="../../../include/c.h.html#LN394"><span class='Ref_to_Typedef'>RegProcedure</span></a> <span class='Declare_Local'>cmp_proc</span> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN98"><span class='Ref_to_Proto'>get_opcode</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1043"><span class='Ref_To_Local'>cmp_op</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN539"><span class='Ref_to_Macro'>RegProcedureIsValid</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1158"><span class='Ref_To_Local'>cmp_proc</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Operator'>*</span><a href="nbtutils.c.html#LN1036"><span class='Ref_to_Parameter'>result</span></a> <span class='Operator'>= </span><a href="../../../include/postgres.h.html#LN398"><span class='Ref_to_Macro'>DatumGetBool</span></a><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN550"><span class='Ref_to_Proto'>OidFunctionCall2Coll</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1158"><span class='Ref_To_Local'>cmp_proc</span></a><span class='Delimiter'>, 
</span>                                                        <a href="nbtutils.c.html#LN1034"><span class='Ref_to_Parameter'>op</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN69"><span class='Ref_to_Member'>sk_collation</span></a><span class='Delimiter'>, 
</span>                                                        <a href="nbtutils.c.html#LN1035"><span class='Ref_to_Parameter'>leftarg</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN71"><span class='Ref_to_Member'>sk_argument</span></a><span class='Delimiter'>, 
</span>                                                     <a href="nbtutils.c.html#LN1035"><span class='Ref_to_Parameter'>rightarg</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN71"><span class='Ref_to_Member'>sk_argument</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Can't make the comparison */ 
</span>    <span class='Operator'>*</span><a href="nbtutils.c.html#LN1036"><span class='Ref_to_Parameter'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* suppress compiler warnings */ 
</span>    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end _bt_compare_scankey_args &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Adjust a scankey's strategy and flags setting as needed for indoptions. 
 * 
 * We copy the appropriate indoption value into the scankey sk_flags 
 * (shifting to avoid clobbering system-defined flag bits).  Also, if 
 * the DESC option is set, commute (flip) the operator strategy number. 
 * 
 * A secondary purpose is to check for IS NULL/NOT NULL scankeys and set up 
 * the strategy field correctly for them. 
 * 
 * Lastly, for ordinary scankeys (not IS NULL/NOT NULL), we check for a 
 * NULL comparison value.  Since all btree operators are assumed strict, 
 * a NULL means that the qual cannot be satisfied.  We return TRUE if the 
 * comparison value isn't NULL, or FALSE if the scan should be abandoned. 
 * 
 * This function is applied to the *input* scankey structure; therefore 
 * on a rescan we will be looking at already-processed scankeys.  Hence 
 * we have to be careful not to re-commute the strategy if we already did it. 
 * It's a bit ugly to modify the caller's copy of the scankey but in practice 
 * there shouldn't be any problem, since the index's indoptions are certainly 
 * not going to change while the scankey survives. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN1198"></a><span class='Declare_Function'>_bt_fix_scankey_strategy</span><span class='Parentheses'>(</span><a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a> <span class='Declare_Parameter'>skey</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN254"><span class='Ref_to_Typedef'>int16</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>indoption</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1200"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>addflags</span><span class='Delimiter'>; 
</span> 
    <a href="nbtutils.c.html#LN1200"><span class='Ref_To_Local'>addflags</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN1198"><span class='Ref_to_Parameter'>indoption</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN1198"><span class='Ref_to_Parameter'>skey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN66"><span class='Ref_to_Member'>sk_attno</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>&LT;&LT; </span><a href="../../../include/access/nbtree.h.html#LN425"><span class='Ref_to_Const'>SK_BT_INDOPTION_SHIFT</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We treat all btree operators as strict (even if they're not so marked 
     * in pg_proc). This means that it is impossible for an operator condition 
     * with a NULL comparison constant to succeed, and we can reject it right 
     * away. 
     * 
     * However, we now also support "x IS NULL" clauses as search conditions, 
     * so in that case keep going. The planner has not filled in any 
     * particular strategy in this case, so set it to BTEqualStrategyNumber 
     * --- we can treat IS NULL as an equality operator for purposes of search 
     * strategy. 
     * 
     * Likewise, "x IS NOT NULL" is supported.  We treat that as either "less 
     * than NULL" in a NULLS LAST index, or "greater than NULL" in a NULLS 
     * FIRST index. 
     * 
     * Note: someday we might have to fill in sk_collation from the index 
     * column's collation.  At the moment this is a non-issue because we'll 
     * never actually call the comparison operator on a NULL. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1198"><span class='Ref_to_Parameter'>skey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/skey.h.html#LN114"><span class='Ref_to_Const'>SK_ISNULL</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* SK_ISNULL shouldn't be set in a row header scankey */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1198"><span class='Ref_to_Parameter'>skey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/skey.h.html#LN116"><span class='Ref_to_Const'>SK_ROW_HEADER</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Set indoption flags in scankey (might be done already) */ 
</span>        <a href="nbtutils.c.html#LN1198"><span class='Ref_to_Parameter'>skey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>|= </span><a href="nbtutils.c.html#LN1200"><span class='Ref_To_Local'>addflags</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Set correct strategy for IS NULL or NOT NULL search */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1198"><span class='Ref_to_Parameter'>skey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/skey.h.html#LN120"><span class='Ref_to_Const'>SK_SEARCHNULL</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="nbtutils.c.html#LN1198"><span class='Ref_to_Parameter'>skey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN67"><span class='Ref_to_Member'>sk_strategy</span></a> <span class='Operator'>= </span><a href="../../../include/access/stratnum.h.html#LN30"><span class='Ref_to_Const'>BTEqualStrategyNumber</span></a><span class='Delimiter'>; 
</span>            <a href="nbtutils.c.html#LN1198"><span class='Ref_to_Parameter'>skey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN68"><span class='Ref_to_Member'>sk_subtype</span></a> <span class='Operator'>= </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>            <a href="nbtutils.c.html#LN1198"><span class='Ref_to_Parameter'>skey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN69"><span class='Ref_to_Member'>sk_collation</span></a> <span class='Operator'>= </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1198"><span class='Ref_to_Parameter'>skey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/skey.h.html#LN121"><span class='Ref_to_Const'>SK_SEARCHNOTNULL</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1198"><span class='Ref_to_Parameter'>skey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/nbtree.h.html#LN427"><span class='Ref_to_Const'>SK_BT_NULLS_FIRST</span></a><span class='Parentheses'>) 
</span>                <a href="nbtutils.c.html#LN1198"><span class='Ref_to_Parameter'>skey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN67"><span class='Ref_to_Member'>sk_strategy</span></a> <span class='Operator'>= </span><a href="../../../include/access/stratnum.h.html#LN32"><span class='Ref_to_Const'>BTGreaterStrategyNumber</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="nbtutils.c.html#LN1198"><span class='Ref_to_Parameter'>skey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN67"><span class='Ref_to_Member'>sk_strategy</span></a> <span class='Operator'>= </span><a href="../../../include/access/stratnum.h.html#LN28"><span class='Ref_to_Const'>BTLessStrategyNumber</span></a><span class='Delimiter'>; 
</span>            <a href="nbtutils.c.html#LN1198"><span class='Ref_to_Parameter'>skey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN68"><span class='Ref_to_Member'>sk_subtype</span></a> <span class='Operator'>= </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>            <a href="nbtutils.c.html#LN1198"><span class='Ref_to_Parameter'>skey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN69"><span class='Ref_to_Member'>sk_collation</span></a> <span class='Operator'>= </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* regular qual, so it cannot be satisfied */ 
</span>            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* Needn't do the rest */ 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if skey-&GT;sk_flags&SK_ISN... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* Adjust strategy for DESC, if we didn't already */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="nbtutils.c.html#LN1200"><span class='Ref_To_Local'>addflags</span></a> <span class='Operator'>& </span><a href="../../../include/access/nbtree.h.html#LN426"><span class='Ref_to_Const'>SK_BT_DESC</span></a><span class='Parentheses'>) </span><span class='Operator'>&& !</span><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1198"><span class='Ref_to_Parameter'>skey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/nbtree.h.html#LN426"><span class='Ref_to_Const'>SK_BT_DESC</span></a><span class='Parentheses'>))</span> 
        <a href="nbtutils.c.html#LN1198"><span class='Ref_to_Parameter'>skey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN67"><span class='Ref_to_Member'>sk_strategy</span></a> <span class='Operator'>= </span><a href="../../../include/access/nbtree.h.html#LN214"><span class='Ref_to_Macro'>BTCommuteStrategyNumber</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1198"><span class='Ref_to_Parameter'>skey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN67"><span class='Ref_to_Member'>sk_strategy</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="nbtutils.c.html#LN1198"><span class='Ref_to_Parameter'>skey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>|= </span><a href="nbtutils.c.html#LN1200"><span class='Ref_To_Local'>addflags</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* If it's a row header, fix row member flags and strategies similarly */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1198"><span class='Ref_to_Parameter'>skey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/skey.h.html#LN116"><span class='Ref_to_Const'>SK_ROW_HEADER</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1266"></a>        <a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a>     <span class='Declare_Local'>subkey</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a><span class='Parentheses'>) </span><a href="../../../include/postgres.h.html#LN554"><span class='Ref_to_Macro'>DatumGetPointer</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1198"><span class='Ref_to_Parameter'>skey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN71"><span class='Ref_to_Member'>sk_argument</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>;;</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1266"><span class='Ref_To_Local'>subkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/skey.h.html#LN117"><span class='Ref_to_Const'>SK_ROW_MEMBER</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="nbtutils.c.html#LN1200"><span class='Ref_To_Local'>addflags</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN1198"><span class='Ref_to_Parameter'>indoption</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN1266"><span class='Ref_To_Local'>subkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN66"><span class='Ref_to_Member'>sk_attno</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>&LT;&LT; </span><a href="../../../include/access/nbtree.h.html#LN425"><span class='Ref_to_Const'>SK_BT_INDOPTION_SHIFT</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="nbtutils.c.html#LN1200"><span class='Ref_To_Local'>addflags</span></a> <span class='Operator'>& </span><a href="../../../include/access/nbtree.h.html#LN426"><span class='Ref_to_Const'>SK_BT_DESC</span></a><span class='Parentheses'>) </span><span class='Operator'>&& !</span><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1266"><span class='Ref_To_Local'>subkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/nbtree.h.html#LN426"><span class='Ref_to_Const'>SK_BT_DESC</span></a><span class='Parentheses'>))</span> 
                <a href="nbtutils.c.html#LN1266"><span class='Ref_To_Local'>subkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN67"><span class='Ref_to_Member'>sk_strategy</span></a> <span class='Operator'>= </span><a href="../../../include/access/nbtree.h.html#LN214"><span class='Ref_to_Macro'>BTCommuteStrategyNumber</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1266"><span class='Ref_To_Local'>subkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN67"><span class='Ref_to_Member'>sk_strategy</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="nbtutils.c.html#LN1266"><span class='Ref_To_Local'>subkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>|= </span><a href="nbtutils.c.html#LN1200"><span class='Ref_To_Local'>addflags</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1266"><span class='Ref_To_Local'>subkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/skey.h.html#LN118"><span class='Ref_to_Const'>SK_ROW_END</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <a href="nbtutils.c.html#LN1266"><span class='Ref_To_Local'>subkey</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end _bt_fix_scankey_strategy &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Mark a scankey as "required to continue the scan". 
 * 
 * Depending on the operator type, the key may be required for both scan 
 * directions or just one.  Also, if the key is a row comparison header, 
 * we have to mark its first subsidiary ScanKey as required.  (Subsequent 
 * subsidiary ScanKeys are normally for lower-order columns, and thus 
 * cannot be required, since they're after the first non-equality scankey.) 
 * 
 * Note: when we set required-key flag bits in a subsidiary scankey, we are 
 * scribbling on a data structure belonging to the index AM's caller, not on 
 * our private copy.  This should be OK because the marking will not change 
 * from scan to scan within a query, and so we'd just re-mark the same way 
 * anyway on a rescan.  Something to keep an eye on though. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1300"></a><span class='Declare_Function'>_bt_mark_scankey_required</span><span class='Parentheses'>(</span><a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a> <span class='Declare_Parameter'>skey</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1302"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>addflags</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1300"><span class='Ref_to_Parameter'>skey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN67"><span class='Ref_to_Member'>sk_strategy</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../../include/access/stratnum.h.html#LN28"><span class='Ref_to_Const'>BTLessStrategyNumber</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../include/access/stratnum.h.html#LN29"><span class='Ref_to_Const'>BTLessEqualStrategyNumber</span></a><span class='Operator'>: 
</span>            <a href="nbtutils.c.html#LN1302"><span class='Ref_To_Local'>addflags</span></a> <span class='Operator'>= </span><a href="../../../include/access/nbtree.h.html#LN423"><span class='Ref_to_Const'>SK_BT_REQFWD</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/access/stratnum.h.html#LN30"><span class='Ref_to_Const'>BTEqualStrategyNumber</span></a><span class='Operator'>: 
</span>            <a href="nbtutils.c.html#LN1302"><span class='Ref_To_Local'>addflags</span></a> <span class='Operator'>= </span><a href="../../../include/access/nbtree.h.html#LN423"><span class='Ref_to_Const'>SK_BT_REQFWD</span></a> <span class='Operator'>| </span><a href="../../../include/access/nbtree.h.html#LN424"><span class='Ref_to_Const'>SK_BT_REQBKWD</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/access/stratnum.h.html#LN31"><span class='Ref_to_Const'>BTGreaterEqualStrategyNumber</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../include/access/stratnum.h.html#LN32"><span class='Ref_to_Const'>BTGreaterStrategyNumber</span></a><span class='Operator'>: 
</span>            <a href="nbtutils.c.html#LN1302"><span class='Ref_To_Local'>addflags</span></a> <span class='Operator'>= </span><a href="../../../include/access/nbtree.h.html#LN424"><span class='Ref_to_Const'>SK_BT_REQBKWD</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>default</span><span class='Operator'>: 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized StrategyNumber: %d"</span><span class='Delimiter'>, 
</span>                 <span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="nbtutils.c.html#LN1300"><span class='Ref_to_Parameter'>skey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN67"><span class='Ref_to_Member'>sk_strategy</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="nbtutils.c.html#LN1302"><span class='Ref_To_Local'>addflags</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* keep compiler quiet */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="nbtutils.c.html#LN1300"><span class='Ref_to_Parameter'>skey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>|= </span><a href="nbtutils.c.html#LN1302"><span class='Ref_To_Local'>addflags</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1300"><span class='Ref_to_Parameter'>skey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/skey.h.html#LN116"><span class='Ref_to_Const'>SK_ROW_HEADER</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1328"></a>        <a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a>     <span class='Declare_Local'>subkey</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a><span class='Parentheses'>) </span><a href="../../../include/postgres.h.html#LN554"><span class='Ref_to_Macro'>DatumGetPointer</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1300"><span class='Ref_to_Parameter'>skey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN71"><span class='Ref_to_Member'>sk_argument</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* First subkey should be same column/operator as the header */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1328"><span class='Ref_To_Local'>subkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/skey.h.html#LN117"><span class='Ref_to_Const'>SK_ROW_MEMBER</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1328"><span class='Ref_To_Local'>subkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN66"><span class='Ref_to_Member'>sk_attno</span></a> <span class='Operator'>== </span><a href="nbtutils.c.html#LN1300"><span class='Ref_to_Parameter'>skey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN66"><span class='Ref_to_Member'>sk_attno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1328"><span class='Ref_To_Local'>subkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN67"><span class='Ref_to_Member'>sk_strategy</span></a> <span class='Operator'>== </span><a href="nbtutils.c.html#LN1300"><span class='Ref_to_Parameter'>skey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN67"><span class='Ref_to_Member'>sk_strategy</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="nbtutils.c.html#LN1328"><span class='Ref_To_Local'>subkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>|= </span><a href="nbtutils.c.html#LN1302"><span class='Ref_To_Local'>addflags</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end _bt_mark_scankey_required &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Test whether an indextuple satisfies all the scankey conditions. 
 * 
 * If so, return the address of the index tuple on the index page. 
 * If not, return NULL. 
 * 
 * If the tuple fails to pass the qual, we also determine whether there's 
 * any need to continue the scan beyond this tuple, and set *continuescan 
 * accordingly.  See comments for _bt_preprocess_keys(), above, about how 
 * this is done. 
 * 
 * scan: index scan descriptor (containing a search-type scankey) 
 * page: buffer page containing index tuple 
 * offnum: offset number of index tuple (must be a valid item!) 
 * dir: direction we are scanning in 
 * continuescan: output parameter (will be set correctly in all cases) 
 * 
 * Caller must hold pin and lock on the index page. 
 */ 
</span><a href="../../../include/access/itup.h.html#LN52"><span class='Ref_to_Typedef'>IndexTuple</span></a> 
<a name="LN1358"></a><span class='Declare_Function'>_bt_checkkeys</span><span class='Parentheses'>(</span><a href="../../../include/access/genam.h.html#LN85"><span class='Ref_to_Typedef'>IndexScanDesc</span></a> <span class='Declare_Parameter'>scan</span><span class='Delimiter'>, 
</span><a name="LN1359"></a>              <a href="../../../include/storage/bufpage.h.html#LN73"><span class='Ref_to_Typedef'>Page</span></a> <span class='Declare_Parameter'>page</span><span class='Delimiter'>, </span><a href="../../../include/storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Parameter'>offnum</span><span class='Delimiter'>, 
</span><a name="LN1360"></a>              <a href="../../../include/access/sdir.h.html#LN21"><span class='Ref_to_Enum'>ScanDirection</span></a> <span class='Declare_Parameter'>dir</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>continuescan</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1362"></a>    <a href="../../../include/storage/itemid.h.html#LN30"><span class='Ref_to_Typedef'>ItemId</span></a>      <span class='Declare_Local'>iid</span> <span class='Operator'>= </span><a href="../../../include/storage/bufpage.h.html#LN231"><span class='Ref_to_Macro'>PageGetItemId</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1359"><span class='Ref_to_Parameter'>page</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN1359"><span class='Ref_to_Parameter'>offnum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1363"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>tuple_alive</span><span class='Delimiter'>; 
</span><a name="LN1364"></a>    <a href="../../../include/access/itup.h.html#LN52"><span class='Ref_to_Typedef'>IndexTuple</span></a>  <span class='Declare_Local'>tuple</span><span class='Delimiter'>; 
</span><a name="LN1365"></a>    <a href="../../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a>   <span class='Declare_Local'>tupdesc</span><span class='Delimiter'>; 
</span><a name="LN1366"></a>    <a href="../../../include/access/nbtree.h.html#LN416"><span class='Ref_to_Typedef'>BTScanOpaque</span></a> <span class='Declare_Local'>so</span><span class='Delimiter'>; 
</span><a name="LN1367"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>keysz</span><span class='Delimiter'>; 
</span><a name="LN1368"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>ikey</span><span class='Delimiter'>; 
</span><a name="LN1369"></a>    <a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a>     <span class='Declare_Local'>key</span><span class='Delimiter'>; 
</span> 
    <span class='Operator'>*</span><a href="nbtutils.c.html#LN1360"><span class='Ref_to_Parameter'>continuescan</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* default assumption */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the scan specifies not to return killed tuples, then we treat a 
     * killed tuple as not passing the qual.  Most of the time, it's a win to 
     * not bother examining the tuple's index keys, but just return 
     * immediately with continuescan = true to proceed to the next tuple. 
     * However, if this is the last tuple on the page, we should check the 
     * index keys to prevent uselessly advancing to the next page. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1358"><span class='Ref_to_Parameter'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN99"><span class='Ref_to_Member'>ignore_killed_tuples</span></a> <span class='Operator'>&& </span><a href="../../../include/storage/itemid.h.html#LN111"><span class='Ref_to_Macro'>ItemIdIsDead</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1362"><span class='Ref_To_Local'>iid</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* return immediately if there are more tuples on the page */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/sdir.h.html#LN54"><span class='Ref_to_Macro'>ScanDirectionIsForward</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1360"><span class='Ref_to_Parameter'>dir</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1359"><span class='Ref_to_Parameter'>offnum</span></a> <span class='Operator'>&LT; </span><a href="../../../include/storage/bufpage.h.html#LN353"><span class='Ref_to_Macro'>PageGetMaxOffsetNumber</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1359"><span class='Ref_to_Parameter'>page</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span><a name="LN1391"></a>            <a href="../../../include/access/nbtree.h.html#LN66"><span class='Ref_to_Typedef'>BTPageOpaque</span></a> <span class='Declare_Local'>opaque</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN66"><span class='Ref_to_Typedef'>BTPageOpaque</span></a><span class='Parentheses'>) </span><a href="../../../include/storage/bufpage.h.html#LN322"><span class='Ref_to_Macro'>PageGetSpecialPointer</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1359"><span class='Ref_to_Parameter'>page</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1359"><span class='Ref_to_Parameter'>offnum</span></a> <span class='Operator'>&GT; </span><a href="../../../include/access/nbtree.h.html#LN204"><span class='Ref_to_Macro'>P_FIRSTDATAKEY</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1391"><span class='Ref_To_Local'>opaque</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * OK, we want to check the keys so we can set continuescan correctly, 
         * but we'll return NULL even if the tuple passes the key tests. 
         */ 
</span>        <a href="nbtutils.c.html#LN1363"><span class='Ref_To_Local'>tuple_alive</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if scan-&GT;ignore_killed_t... &raquo; </span> 
    <span class='Control'>else</span> 
        <a href="nbtutils.c.html#LN1363"><span class='Ref_To_Local'>tuple_alive</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <a href="nbtutils.c.html#LN1364"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/itup.h.html#LN52"><span class='Ref_to_Typedef'>IndexTuple</span></a><span class='Parentheses'>) </span><a href="../../../include/storage/bufpage.h.html#LN336"><span class='Ref_to_Macro'>PageGetItem</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1359"><span class='Ref_to_Parameter'>page</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN1362"><span class='Ref_To_Local'>iid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="nbtutils.c.html#LN1365"><span class='Ref_To_Local'>tupdesc</span></a> <span class='Operator'>= </span><a href="../../../include/utils/rel.h.html#LN428"><span class='Ref_to_Macro'>RelationGetDescr</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1358"><span class='Ref_to_Parameter'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN88"><span class='Ref_to_Member'>indexRelation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="nbtutils.c.html#LN1366"><span class='Ref_To_Local'>so</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN416"><span class='Ref_to_Typedef'>BTScanOpaque</span></a><span class='Parentheses'>) </span><a href="nbtutils.c.html#LN1358"><span class='Ref_to_Parameter'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN104"><span class='Ref_to_Member'>opaque</span></a><span class='Delimiter'>; 
</span>    <a href="nbtutils.c.html#LN1367"><span class='Ref_To_Local'>keysz</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN1366"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN378"><span class='Ref_to_Member'>numberOfKeys</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1369"><span class='Ref_To_Local'>key</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN1366"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN379"><span class='Ref_to_Member'>keyData</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN1368"><span class='Ref_To_Local'>ikey</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nbtutils.c.html#LN1368"><span class='Ref_To_Local'>ikey</span></a> <span class='Operator'>&LT; </span><a href="nbtutils.c.html#LN1367"><span class='Ref_To_Local'>keysz</span></a><span class='Delimiter'>; </span><a href="nbtutils.c.html#LN1369"><span class='Ref_To_Local'>key</span></a><span class='Operator'>++</span><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN1368"><span class='Ref_To_Local'>ikey</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1414"></a>        <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>datum</span><span class='Delimiter'>; 
</span><a name="LN1415"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>isNull</span><span class='Delimiter'>; 
</span><a name="LN1416"></a>        <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>test</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* row-comparison keys need special processing */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1369"><span class='Ref_To_Local'>key</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/skey.h.html#LN116"><span class='Ref_to_Const'>SK_ROW_HEADER</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN48"><span class='Ref_to_Proto'>_bt_check_rowcompare</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1369"><span class='Ref_To_Local'>key</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN1364"><span class='Ref_To_Local'>tuple</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN1365"><span class='Ref_To_Local'>tupdesc</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN1360"><span class='Ref_to_Parameter'>dir</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN1360"><span class='Ref_to_Parameter'>continuescan</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>continue</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="nbtutils.c.html#LN1414"><span class='Ref_To_Local'>datum</span></a> <span class='Operator'>= </span><a href="../../../include/access/itup.h.html#LN99"><span class='Ref_to_Macro'>index_getattr</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1364"><span class='Ref_To_Local'>tuple</span></a><span class='Delimiter'>, 
</span>                              <a href="nbtutils.c.html#LN1369"><span class='Ref_To_Local'>key</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN66"><span class='Ref_to_Member'>sk_attno</span></a><span class='Delimiter'>, 
</span>                              <a href="nbtutils.c.html#LN1365"><span class='Ref_To_Local'>tupdesc</span></a><span class='Delimiter'>, 
</span>                              <span class='Operator'>&</span><a href="nbtutils.c.html#LN1415"><span class='Ref_To_Local'>isNull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1369"><span class='Ref_To_Local'>key</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/skey.h.html#LN114"><span class='Ref_to_Const'>SK_ISNULL</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Handle IS NULL/NOT NULL tests */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1369"><span class='Ref_To_Local'>key</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/skey.h.html#LN120"><span class='Ref_to_Const'>SK_SEARCHNULL</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1415"><span class='Ref_To_Local'>isNull</span></a><span class='Parentheses'>) 
</span>                    <span class='Control'>continue</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* tuple satisfies this qual */ 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1369"><span class='Ref_To_Local'>key</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/skey.h.html#LN121"><span class='Ref_to_Const'>SK_SEARCHNOTNULL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="nbtutils.c.html#LN1415"><span class='Ref_To_Local'>isNull</span></a><span class='Parentheses'>) 
</span>                    <span class='Control'>continue</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* tuple satisfies this qual */ 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Tuple fails this qual.  If it's a required qual for the current 
             * scan direction, then we can conclude no further tuples will 
             * pass, either. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="nbtutils.c.html#LN1369"><span class='Ref_To_Local'>key</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/nbtree.h.html#LN423"><span class='Ref_to_Const'>SK_BT_REQFWD</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                <a href="../../../include/access/sdir.h.html#LN54"><span class='Ref_to_Macro'>ScanDirectionIsForward</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1360"><span class='Ref_to_Parameter'>dir</span></a><span class='Parentheses'>))</span> 
                <span class='Operator'>*</span><a href="nbtutils.c.html#LN1360"><span class='Ref_to_Parameter'>continuescan</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="nbtutils.c.html#LN1369"><span class='Ref_To_Local'>key</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/nbtree.h.html#LN424"><span class='Ref_to_Const'>SK_BT_REQBKWD</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                     <a href="../../../include/access/sdir.h.html#LN40"><span class='Ref_to_Macro'>ScanDirectionIsBackward</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1360"><span class='Ref_to_Parameter'>dir</span></a><span class='Parentheses'>))</span> 
                <span class='Operator'>*</span><a href="nbtutils.c.html#LN1360"><span class='Ref_to_Parameter'>continuescan</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * In any case, this indextuple doesn't match the qual. 
             */ 
</span>            <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if key-&GT;sk_flags&SK_ISNU... &raquo; </span> 
 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1415"><span class='Ref_To_Local'>isNull</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1369"><span class='Ref_To_Local'>key</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/nbtree.h.html#LN427"><span class='Ref_to_Const'>SK_BT_NULLS_FIRST</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * Since NULLs are sorted before non-NULLs, we know we have 
                 * reached the lower limit of the range of values for this 
                 * index attr.  On a backward scan, we can stop if this qual 
                 * is one of the "must match" subset.  We can stop regardless 
                 * of whether the qual is &GT; or &LT;, so long as it's required, 
                 * because it's not possible for any future tuples to pass. On 
                 * a forward scan, however, we must keep going, because we may 
                 * have initially positioned to the start of the index. 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="nbtutils.c.html#LN1369"><span class='Ref_To_Local'>key</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN423"><span class='Ref_to_Const'>SK_BT_REQFWD</span></a> <span class='Operator'>| </span><a href="../../../include/access/nbtree.h.html#LN424"><span class='Ref_to_Const'>SK_BT_REQBKWD</span></a><span class='Parentheses'>))</span> <span class='Operator'>&& 
</span>                    <a href="../../../include/access/sdir.h.html#LN40"><span class='Ref_to_Macro'>ScanDirectionIsBackward</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1360"><span class='Ref_to_Parameter'>dir</span></a><span class='Parentheses'>))</span> 
                    <span class='Operator'>*</span><a href="nbtutils.c.html#LN1360"><span class='Ref_to_Parameter'>continuescan</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * Since NULLs are sorted after non-NULLs, we know we have 
                 * reached the upper limit of the range of values for this 
                 * index attr.  On a forward scan, we can stop if this qual is 
                 * one of the "must match" subset.  We can stop regardless of 
                 * whether the qual is &GT; or &LT;, so long as it's required, 
                 * because it's not possible for any future tuples to pass. On 
                 * a backward scan, however, we must keep going, because we 
                 * may have initially positioned to the end of the index. 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="nbtutils.c.html#LN1369"><span class='Ref_To_Local'>key</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN423"><span class='Ref_to_Const'>SK_BT_REQFWD</span></a> <span class='Operator'>| </span><a href="../../../include/access/nbtree.h.html#LN424"><span class='Ref_to_Const'>SK_BT_REQBKWD</span></a><span class='Parentheses'>))</span> <span class='Operator'>&& 
</span>                    <a href="../../../include/access/sdir.h.html#LN54"><span class='Ref_to_Macro'>ScanDirectionIsForward</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1360"><span class='Ref_to_Parameter'>dir</span></a><span class='Parentheses'>))</span> 
                    <span class='Operator'>*</span><a href="nbtutils.c.html#LN1360"><span class='Ref_to_Parameter'>continuescan</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * In any case, this indextuple doesn't match the qual. 
             */ 
</span>            <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if isNull &raquo; </span> 
 
        <a href="nbtutils.c.html#LN1416"><span class='Ref_To_Local'>test</span></a> <span class='Operator'>= </span><a href="../../../include/fmgr.h.html#LN512"><span class='Ref_to_Proto'>FunctionCall2Coll</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nbtutils.c.html#LN1369"><span class='Ref_To_Local'>key</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN70"><span class='Ref_to_Member'>sk_func</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN1369"><span class='Ref_To_Local'>key</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN69"><span class='Ref_to_Member'>sk_collation</span></a><span class='Delimiter'>, 
</span>                                 <a href="nbtutils.c.html#LN1414"><span class='Ref_To_Local'>datum</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN1369"><span class='Ref_To_Local'>key</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN71"><span class='Ref_to_Member'>sk_argument</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/postgres.h.html#LN398"><span class='Ref_to_Macro'>DatumGetBool</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1416"><span class='Ref_To_Local'>test</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Tuple fails this qual.  If it's a required qual for the current 
             * scan direction, then we can conclude no further tuples will 
             * pass, either. 
             * 
             * Note: because we stop the scan as soon as any required equality 
             * qual fails, it is critical that equality quals be used for the 
             * initial positioning in _bt_first() when they are available. See 
             * comments in _bt_first(). 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="nbtutils.c.html#LN1369"><span class='Ref_To_Local'>key</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/nbtree.h.html#LN423"><span class='Ref_to_Const'>SK_BT_REQFWD</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                <a href="../../../include/access/sdir.h.html#LN54"><span class='Ref_to_Macro'>ScanDirectionIsForward</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1360"><span class='Ref_to_Parameter'>dir</span></a><span class='Parentheses'>))</span> 
                <span class='Operator'>*</span><a href="nbtutils.c.html#LN1360"><span class='Ref_to_Parameter'>continuescan</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="nbtutils.c.html#LN1369"><span class='Ref_To_Local'>key</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/nbtree.h.html#LN424"><span class='Ref_to_Const'>SK_BT_REQBKWD</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                     <a href="../../../include/access/sdir.h.html#LN40"><span class='Ref_to_Macro'>ScanDirectionIsBackward</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1360"><span class='Ref_to_Parameter'>dir</span></a><span class='Parentheses'>))</span> 
                <span class='Operator'>*</span><a href="nbtutils.c.html#LN1360"><span class='Ref_to_Parameter'>continuescan</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * In any case, this indextuple doesn't match the qual. 
             */ 
</span>            <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !DatumGetBool(test) &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for key=so-&GT;keyData,ikey=... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* Check for failure due to it being a killed tuple. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="nbtutils.c.html#LN1363"><span class='Ref_To_Local'>tuple_alive</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* If we get here, the tuple passes all index quals. */ 
</span>    <span class='Control'>return</span> <a href="nbtutils.c.html#LN1364"><span class='Ref_To_Local'>tuple</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end _bt_checkkeys &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Test whether an indextuple satisfies a row-comparison scan condition. 
 * 
 * Return true if so, false if not.  If not, also clear *continuescan if 
 * it's not possible for any future tuples in the current scan direction 
 * to pass the qual. 
 * 
 * This is a subroutine for _bt_checkkeys, which see for more info. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN1552"></a><span class='Declare_Function'>_bt_check_rowcompare</span><span class='Parentheses'>(</span><a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a> <span class='Declare_Parameter'>skey</span><span class='Delimiter'>, </span><a href="../../../include/access/itup.h.html#LN52"><span class='Ref_to_Typedef'>IndexTuple</span></a> <span class='Declare_Parameter'>tuple</span><span class='Delimiter'>, </span><a href="../../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a> <span class='Declare_Parameter'>tupdesc</span><span class='Delimiter'>, 
</span><a name="LN1553"></a>                     <a href="../../../include/access/sdir.h.html#LN21"><span class='Ref_to_Enum'>ScanDirection</span></a> <span class='Declare_Parameter'>dir</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>continuescan</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1555"></a>    <a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a>     <span class='Declare_Local'>subkey</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a><span class='Parentheses'>) </span><a href="../../../include/postgres.h.html#LN554"><span class='Ref_to_Macro'>DatumGetPointer</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1552"><span class='Ref_to_Parameter'>skey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN71"><span class='Ref_to_Member'>sk_argument</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1556"></a>    <a href="../../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Local'>cmpresult</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN1557"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* First subkey should be same as the header says */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1555"><span class='Ref_To_Local'>subkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN66"><span class='Ref_to_Member'>sk_attno</span></a> <span class='Operator'>== </span><a href="nbtutils.c.html#LN1552"><span class='Ref_to_Parameter'>skey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN66"><span class='Ref_to_Member'>sk_attno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Loop over columns of the row condition */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>;;</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1565"></a>        <a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>datum</span><span class='Delimiter'>; 
</span><a name="LN1566"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>isNull</span><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1555"><span class='Ref_To_Local'>subkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/skey.h.html#LN117"><span class='Ref_to_Const'>SK_ROW_MEMBER</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="nbtutils.c.html#LN1565"><span class='Ref_To_Local'>datum</span></a> <span class='Operator'>= </span><a href="../../../include/access/itup.h.html#LN99"><span class='Ref_to_Macro'>index_getattr</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1552"><span class='Ref_to_Parameter'>tuple</span></a><span class='Delimiter'>, 
</span>                              <a href="nbtutils.c.html#LN1555"><span class='Ref_To_Local'>subkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN66"><span class='Ref_to_Member'>sk_attno</span></a><span class='Delimiter'>, 
</span>                              <a href="nbtutils.c.html#LN1552"><span class='Ref_to_Parameter'>tupdesc</span></a><span class='Delimiter'>, 
</span>                              <span class='Operator'>&</span><a href="nbtutils.c.html#LN1566"><span class='Ref_To_Local'>isNull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1566"><span class='Ref_To_Local'>isNull</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1555"><span class='Ref_To_Local'>subkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/nbtree.h.html#LN427"><span class='Ref_to_Const'>SK_BT_NULLS_FIRST</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * Since NULLs are sorted before non-NULLs, we know we have 
                 * reached the lower limit of the range of values for this 
                 * index attr.  On a backward scan, we can stop if this qual 
                 * is one of the "must match" subset.  We can stop regardless 
                 * of whether the qual is &GT; or &LT;, so long as it's required, 
                 * because it's not possible for any future tuples to pass. On 
                 * a forward scan, however, we must keep going, because we may 
                 * have initially positioned to the start of the index. 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="nbtutils.c.html#LN1555"><span class='Ref_To_Local'>subkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN423"><span class='Ref_to_Const'>SK_BT_REQFWD</span></a> <span class='Operator'>| </span><a href="../../../include/access/nbtree.h.html#LN424"><span class='Ref_to_Const'>SK_BT_REQBKWD</span></a><span class='Parentheses'>))</span> <span class='Operator'>&& 
</span>                    <a href="../../../include/access/sdir.h.html#LN40"><span class='Ref_to_Macro'>ScanDirectionIsBackward</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1553"><span class='Ref_to_Parameter'>dir</span></a><span class='Parentheses'>))</span> 
                    <span class='Operator'>*</span><a href="nbtutils.c.html#LN1553"><span class='Ref_to_Parameter'>continuescan</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * Since NULLs are sorted after non-NULLs, we know we have 
                 * reached the upper limit of the range of values for this 
                 * index attr.  On a forward scan, we can stop if this qual is 
                 * one of the "must match" subset.  We can stop regardless of 
                 * whether the qual is &GT; or &LT;, so long as it's required, 
                 * because it's not possible for any future tuples to pass. On 
                 * a backward scan, however, we must keep going, because we 
                 * may have initially positioned to the end of the index. 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="nbtutils.c.html#LN1555"><span class='Ref_To_Local'>subkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN423"><span class='Ref_to_Const'>SK_BT_REQFWD</span></a> <span class='Operator'>| </span><a href="../../../include/access/nbtree.h.html#LN424"><span class='Ref_to_Const'>SK_BT_REQBKWD</span></a><span class='Parentheses'>))</span> <span class='Operator'>&& 
</span>                    <a href="../../../include/access/sdir.h.html#LN54"><span class='Ref_to_Macro'>ScanDirectionIsForward</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1553"><span class='Ref_to_Parameter'>dir</span></a><span class='Parentheses'>))</span> 
                    <span class='Operator'>*</span><a href="nbtutils.c.html#LN1553"><span class='Ref_to_Parameter'>continuescan</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * In any case, this indextuple doesn't match the qual. 
             */ 
</span>            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if isNull &raquo; </span> 
 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1555"><span class='Ref_To_Local'>subkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/skey.h.html#LN114"><span class='Ref_to_Const'>SK_ISNULL</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Unlike the simple-scankey case, this isn't a disallowed case. 
             * But it can never match.  If all the earlier row comparison 
             * columns are required for the scan direction, we can stop the 
             * scan, because there can't be another tuple that will succeed. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1555"><span class='Ref_To_Local'>subkey</span></a> <span class='Operator'>!= </span><span class='Parentheses'>(</span><a href="../../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a><span class='Parentheses'>) </span><a href="../../../include/postgres.h.html#LN554"><span class='Ref_to_Macro'>DatumGetPointer</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1552"><span class='Ref_to_Parameter'>skey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN71"><span class='Ref_to_Member'>sk_argument</span></a><span class='Parentheses'>))</span> 
                <a href="nbtutils.c.html#LN1555"><span class='Ref_To_Local'>subkey</span></a><span class='Operator'>--</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="nbtutils.c.html#LN1555"><span class='Ref_To_Local'>subkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/nbtree.h.html#LN423"><span class='Ref_to_Const'>SK_BT_REQFWD</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                <a href="../../../include/access/sdir.h.html#LN54"><span class='Ref_to_Macro'>ScanDirectionIsForward</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1553"><span class='Ref_to_Parameter'>dir</span></a><span class='Parentheses'>))</span> 
                <span class='Operator'>*</span><a href="nbtutils.c.html#LN1553"><span class='Ref_to_Parameter'>continuescan</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="nbtutils.c.html#LN1555"><span class='Ref_To_Local'>subkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/nbtree.h.html#LN424"><span class='Ref_to_Const'>SK_BT_REQBKWD</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                     <a href="../../../include/access/sdir.h.html#LN40"><span class='Ref_to_Macro'>ScanDirectionIsBackward</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1553"><span class='Ref_to_Parameter'>dir</span></a><span class='Parentheses'>))</span> 
                <span class='Operator'>*</span><a href="nbtutils.c.html#LN1553"><span class='Ref_to_Parameter'>continuescan</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* Perform the test --- three-way comparison not bool operator */ 
</span>        <a href="nbtutils.c.html#LN1556"><span class='Ref_To_Local'>cmpresult</span></a> <span class='Operator'>= </span><a href="../../../include/postgres.h.html#LN477"><span class='Ref_to_Macro'>DatumGetInt32</span></a><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN512"><span class='Ref_to_Proto'>FunctionCall2Coll</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nbtutils.c.html#LN1555"><span class='Ref_To_Local'>subkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN70"><span class='Ref_to_Member'>sk_func</span></a><span class='Delimiter'>, 
</span>                                                    <a href="nbtutils.c.html#LN1555"><span class='Ref_To_Local'>subkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN69"><span class='Ref_to_Member'>sk_collation</span></a><span class='Delimiter'>, 
</span>                                                    <a href="nbtutils.c.html#LN1565"><span class='Ref_To_Local'>datum</span></a><span class='Delimiter'>, 
</span>                                                    <a href="nbtutils.c.html#LN1555"><span class='Ref_To_Local'>subkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN71"><span class='Ref_to_Member'>sk_argument</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1555"><span class='Ref_To_Local'>subkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/nbtree.h.html#LN426"><span class='Ref_to_Const'>SK_BT_DESC</span></a><span class='Parentheses'>) 
</span>            <a href="nbtutils.c.html#LN1556"><span class='Ref_To_Local'>cmpresult</span></a> <span class='Operator'>= -</span><a href="nbtutils.c.html#LN1556"><span class='Ref_To_Local'>cmpresult</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Done comparing if unequal, else advance to next column */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1556"><span class='Ref_To_Local'>cmpresult</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1555"><span class='Ref_To_Local'>subkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/skey.h.html#LN118"><span class='Ref_to_Const'>SK_ROW_END</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <a href="nbtutils.c.html#LN1555"><span class='Ref_To_Local'>subkey</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for ;; &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * At this point cmpresult indicates the overall result of the row 
     * comparison, and subkey points to the deciding column (or the last 
     * column if the result is "="). 
     */ 
</span>    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1555"><span class='Ref_To_Local'>subkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN67"><span class='Ref_to_Member'>sk_strategy</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* EQ and NE cases aren't allowed here */ 
</span>        <span class='Control'>case</span> <a href="../../../include/access/stratnum.h.html#LN28"><span class='Ref_to_Const'>BTLessStrategyNumber</span></a><span class='Operator'>: 
</span>            <a href="nbtutils.c.html#LN1557"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1556"><span class='Ref_To_Local'>cmpresult</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/access/stratnum.h.html#LN29"><span class='Ref_to_Const'>BTLessEqualStrategyNumber</span></a><span class='Operator'>: 
</span>            <a href="nbtutils.c.html#LN1557"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1556"><span class='Ref_To_Local'>cmpresult</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/access/stratnum.h.html#LN31"><span class='Ref_to_Const'>BTGreaterEqualStrategyNumber</span></a><span class='Operator'>: 
</span>            <a href="nbtutils.c.html#LN1557"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1556"><span class='Ref_To_Local'>cmpresult</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/access/stratnum.h.html#LN32"><span class='Ref_to_Const'>BTGreaterStrategyNumber</span></a><span class='Operator'>: 
</span>            <a href="nbtutils.c.html#LN1557"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1556"><span class='Ref_To_Local'>cmpresult</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>default</span><span class='Operator'>: 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized RowCompareType: %d"</span><span class='Delimiter'>, 
</span>                 <span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="nbtutils.c.html#LN1555"><span class='Ref_To_Local'>subkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN67"><span class='Ref_to_Member'>sk_strategy</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="nbtutils.c.html#LN1557"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* keep compiler quiet */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch subkey-&GT;sk_strategy &raquo; </span> 
 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="nbtutils.c.html#LN1557"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Tuple fails this qual.  If it's a required qual for the current 
         * scan direction, then we can conclude no further tuples will pass, 
         * either.  Note we have to look at the deciding column, not 
         * necessarily the first or last column of the row condition. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="nbtutils.c.html#LN1555"><span class='Ref_To_Local'>subkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/nbtree.h.html#LN423"><span class='Ref_to_Const'>SK_BT_REQFWD</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>            <a href="../../../include/access/sdir.h.html#LN54"><span class='Ref_to_Macro'>ScanDirectionIsForward</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1553"><span class='Ref_to_Parameter'>dir</span></a><span class='Parentheses'>))</span> 
            <span class='Operator'>*</span><a href="nbtutils.c.html#LN1553"><span class='Ref_to_Parameter'>continuescan</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="nbtutils.c.html#LN1555"><span class='Ref_To_Local'>subkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/nbtree.h.html#LN424"><span class='Ref_to_Const'>SK_BT_REQBKWD</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                 <a href="../../../include/access/sdir.h.html#LN40"><span class='Ref_to_Macro'>ScanDirectionIsBackward</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1553"><span class='Ref_to_Parameter'>dir</span></a><span class='Parentheses'>))</span> 
            <span class='Operator'>*</span><a href="nbtutils.c.html#LN1553"><span class='Ref_to_Parameter'>continuescan</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="nbtutils.c.html#LN1557"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end _bt_check_rowcompare &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * _bt_killitems - set LP_DEAD state for items an indexscan caller has 
 * told us were killed 
 * 
 * scan-&GT;opaque, referenced locally through so, contains information about the 
 * current page and killed tuples thereon (generally, this should only be 
 * called if so-&GT;numKilled &GT; 0). 
 * 
 * The caller does not have a lock on the page and may or may not have the 
 * page pinned in a buffer.  Note that read-lock is sufficient for setting 
 * LP_DEAD status (which is only a hint). 
 * 
 * We match items by heap TID before assuming they are the right ones to 
 * delete.  We cope with cases where items have moved right due to insertions. 
 * If an item has moved off the current page due to a split, we'll fail to 
 * find it and do nothing (this is not an error case --- we assume the item 
 * will eventually get marked in a future indexscan). 
 * 
 * Note that if we hold a pin on the target page continuously from initially 
 * reading the items until applying this function, VACUUM cannot have deleted 
 * any items from the page, and so there is no need to search left from the 
 * recorded offset.  (This observation also guarantees that the item is still 
 * the right one to delete, which might otherwise be questionable since heap 
 * TIDs can get recycled.)  This holds true even if the page has been modified 
 * by inserts and page splits, so there is no need to consult the LSN. 
 * 
 * If the pin was released after reading the page, then we re-read it.  If it 
 * has been modified since we read it (as determined by the LSN), we dare not 
 * flag any entries because it is possible that the old entry was vacuumed 
 * away and the TID was re-used by a completely different heap tuple. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1731"></a><span class='Declare_Function'>_bt_killitems</span><span class='Parentheses'>(</span><a href="../../../include/access/genam.h.html#LN85"><span class='Ref_to_Typedef'>IndexScanDesc</span></a> <span class='Declare_Parameter'>scan</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1733"></a>    <a href="../../../include/access/nbtree.h.html#LN416"><span class='Ref_to_Typedef'>BTScanOpaque</span></a> <span class='Declare_Local'>so</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN416"><span class='Ref_to_Typedef'>BTScanOpaque</span></a><span class='Parentheses'>) </span><a href="nbtutils.c.html#LN1731"><span class='Ref_to_Parameter'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN104"><span class='Ref_to_Member'>opaque</span></a><span class='Delimiter'>; 
</span><a name="LN1734"></a>    <a href="../../../include/storage/bufpage.h.html#LN73"><span class='Ref_to_Typedef'>Page</span></a>        <span class='Declare_Local'>page</span><span class='Delimiter'>; 
</span><a name="LN1735"></a>    <a href="../../../include/access/nbtree.h.html#LN66"><span class='Ref_to_Typedef'>BTPageOpaque</span></a> <span class='Declare_Local'>opaque</span><span class='Delimiter'>; 
</span><a name="LN1736"></a>    <a href="../../../include/storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Local'>minoff</span><span class='Delimiter'>; 
</span><a name="LN1737"></a>    <a href="../../../include/storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Local'>maxoff</span><span class='Delimiter'>; 
</span><a name="LN1738"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN1739"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numKilled</span> <span class='Operator'>= </span><a href="nbtutils.c.html#LN1733"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN392"><span class='Ref_to_Member'>numKilled</span></a><span class='Delimiter'>; 
</span><a name="LN1740"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>killedsomething</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN349"><span class='Ref_to_Macro'>BTScanPosIsValid</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1733"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN412"><span class='Ref_to_Member'>currPos</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Always reset the scan state, so we don't look for same items on other 
     * pages. 
     */ 
</span>    <a href="nbtutils.c.html#LN1733"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN392"><span class='Ref_to_Member'>numKilled</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN332"><span class='Ref_to_Macro'>BTScanPosIsPinned</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1733"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN412"><span class='Ref_to_Member'>currPos</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * We have held the pin on this page since we read the index tuples, 
         * so all we need to do is lock it.  The pin will have prevented 
         * re-use of any TID on the page, so there is no need to check the 
         * LSN. 
         */ 
</span>        <a href="../../../include/storage/bufmgr.h.html#LN214"><span class='Ref_to_Proto'>LockBuffer</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1733"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN412"><span class='Ref_to_Member'>currPos</span></a><span class='Operator'>.</span><a href="../../../include/access/nbtree.h.html#LN295"><span class='Ref_to_Member'>buf</span></a><span class='Delimiter'>, </span><a href="../../../include/access/nbtree.h.html#LN237"><span class='Ref_to_Const'>BT_READ</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="nbtutils.c.html#LN1734"><span class='Ref_To_Local'>page</span></a> <span class='Operator'>= </span><a href="../../../include/storage/bufmgr.h.html#LN159"><span class='Ref_to_Macro'>BufferGetPage</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1733"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN412"><span class='Ref_to_Member'>currPos</span></a><span class='Operator'>.</span><a href="../../../include/access/nbtree.h.html#LN295"><span class='Ref_to_Member'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1764"></a>        <a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a>      <span class='Declare_Local'>buf</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Attempt to re-read the buffer, getting pin and lock. */ 
</span>        <a href="nbtutils.c.html#LN1764"><span class='Ref_To_Local'>buf</span></a> <span class='Operator'>= </span><a href="../../../include/access/nbtree.h.html#LN482"><span class='Ref_to_Proto'>_bt_getbuf</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1731"><span class='Ref_to_Parameter'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN88"><span class='Ref_to_Member'>indexRelation</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN1733"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN412"><span class='Ref_to_Member'>currPos</span></a><span class='Operator'>.</span><a href="../../../include/access/nbtree.h.html#LN298"><span class='Ref_to_Member'>currPage</span></a><span class='Delimiter'>, </span><a href="../../../include/access/nbtree.h.html#LN237"><span class='Ref_to_Const'>BT_READ</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* It might not exist anymore; in which case we can't hint it. */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/storage/bufmgr.h.html#LN113"><span class='Ref_to_Macro'>BufferIsValid</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1764"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
        <a href="nbtutils.c.html#LN1734"><span class='Ref_To_Local'>page</span></a> <span class='Operator'>= </span><a href="../../../include/storage/bufmgr.h.html#LN159"><span class='Ref_to_Macro'>BufferGetPage</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1764"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/bufpage.h.html#LN362"><span class='Ref_to_Macro'>PageGetLSN</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1734"><span class='Ref_To_Local'>page</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="nbtutils.c.html#LN1733"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN412"><span class='Ref_to_Member'>currPos</span></a><span class='Operator'>.</span><a href="../../../include/access/nbtree.h.html#LN297"><span class='Ref_to_Member'>lsn</span></a><span class='Parentheses'>)</span> 
            <a href="nbtutils.c.html#LN1733"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN412"><span class='Ref_to_Member'>currPos</span></a><span class='Operator'>.</span><a href="../../../include/access/nbtree.h.html#LN295"><span class='Ref_to_Member'>buf</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN1764"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Modified while not pinned means hinting is not safe. */ 
</span>            <a href="../../../include/access/nbtree.h.html#LN485"><span class='Ref_to_Proto'>_bt_relbuf</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1731"><span class='Ref_to_Parameter'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/relscan.h.html#LN88"><span class='Ref_to_Member'>indexRelation</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN1764"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
    <a href="nbtutils.c.html#LN1735"><span class='Ref_To_Local'>opaque</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN66"><span class='Ref_to_Typedef'>BTPageOpaque</span></a><span class='Parentheses'>) </span><a href="../../../include/storage/bufpage.h.html#LN322"><span class='Ref_to_Macro'>PageGetSpecialPointer</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1734"><span class='Ref_To_Local'>page</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="nbtutils.c.html#LN1736"><span class='Ref_To_Local'>minoff</span></a> <span class='Operator'>= </span><a href="../../../include/access/nbtree.h.html#LN204"><span class='Ref_to_Macro'>P_FIRSTDATAKEY</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1735"><span class='Ref_To_Local'>opaque</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="nbtutils.c.html#LN1737"><span class='Ref_To_Local'>maxoff</span></a> <span class='Operator'>= </span><a href="../../../include/storage/bufpage.h.html#LN353"><span class='Ref_to_Macro'>PageGetMaxOffsetNumber</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1734"><span class='Ref_To_Local'>page</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1738"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nbtutils.c.html#LN1738"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="nbtutils.c.html#LN1739"><span class='Ref_To_Local'>numKilled</span></a><span class='Delimiter'>; </span><a href="nbtutils.c.html#LN1738"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1790"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>itemIndex</span> <span class='Operator'>= </span><a href="nbtutils.c.html#LN1733"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN391"><span class='Ref_to_Member'>killedItems</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN1738"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span><a name="LN1791"></a>        <a href="../../../include/access/nbtree.h.html#LN286"><span class='Ref_to_Struct'>BTScanPosItem</span></a> <span class='Operator'>*</span><span class='Declare_Local'>kitem</span> <span class='Operator'>= &</span><a href="nbtutils.c.html#LN1733"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN412"><span class='Ref_to_Member'>currPos</span></a><span class='Operator'>.</span><a href="../../../include/access/nbtree.h.html#LN327"><span class='Ref_to_Member'>items</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN1790"><span class='Ref_To_Local'>itemIndex</span></a><span class='Delimiter'>]; 
</span><a name="LN1792"></a>        <a href="../../../include/storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Local'>offnum</span> <span class='Operator'>= </span><a href="nbtutils.c.html#LN1791"><span class='Ref_To_Local'>kitem</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN289"><span class='Ref_to_Member'>indexOffset</span></a><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1790"><span class='Ref_To_Local'>itemIndex</span></a> <span class='Operator'>&GT;= </span><a href="nbtutils.c.html#LN1733"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN412"><span class='Ref_to_Member'>currPos</span></a><span class='Operator'>.</span><a href="../../../include/access/nbtree.h.html#LN323"><span class='Ref_to_Member'>firstItem</span></a> <span class='Operator'>&& 
</span>               <a href="nbtutils.c.html#LN1790"><span class='Ref_To_Local'>itemIndex</span></a> <span class='Operator'>&LT;= </span><a href="nbtutils.c.html#LN1733"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN412"><span class='Ref_to_Member'>currPos</span></a><span class='Operator'>.</span><a href="../../../include/access/nbtree.h.html#LN324"><span class='Ref_to_Member'>lastItem</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1792"><span class='Ref_To_Local'>offnum</span></a> <span class='Operator'>&LT; </span><a href="nbtutils.c.html#LN1736"><span class='Ref_To_Local'>minoff</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* pure paranoia */ 
</span>        <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1792"><span class='Ref_To_Local'>offnum</span></a> <span class='Operator'>&LT;= </span><a href="nbtutils.c.html#LN1737"><span class='Ref_To_Local'>maxoff</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1800"></a>            <a href="../../../include/storage/itemid.h.html#LN30"><span class='Ref_to_Typedef'>ItemId</span></a>      <span class='Declare_Local'>iid</span> <span class='Operator'>= </span><a href="../../../include/storage/bufpage.h.html#LN231"><span class='Ref_to_Macro'>PageGetItemId</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1734"><span class='Ref_To_Local'>page</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN1792"><span class='Ref_To_Local'>offnum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1801"></a>            <a href="../../../include/access/itup.h.html#LN52"><span class='Ref_to_Typedef'>IndexTuple</span></a>  <span class='Declare_Local'>ituple</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/itup.h.html#LN52"><span class='Ref_to_Typedef'>IndexTuple</span></a><span class='Parentheses'>) </span><a href="../../../include/storage/bufpage.h.html#LN336"><span class='Ref_to_Macro'>PageGetItem</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1734"><span class='Ref_To_Local'>page</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN1800"><span class='Ref_To_Local'>iid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../storage/page/itemptr.c.html#LN27"><span class='Ref_to_Func'>ItemPointerEquals</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nbtutils.c.html#LN1801"><span class='Ref_To_Local'>ituple</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/itup.h.html#LN36"><span class='Ref_to_Member'>t_tid</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nbtutils.c.html#LN1791"><span class='Ref_To_Local'>kitem</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN288"><span class='Ref_to_Member'>heapTid</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* found the item */ 
</span>                <a href="../../../include/storage/itemid.h.html#LN177"><span class='Ref_to_Macro'>ItemIdMarkDead</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1800"><span class='Ref_To_Local'>iid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="nbtutils.c.html#LN1740"><span class='Ref_To_Local'>killedsomething</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* out of inner search loop */ 
</span>            <span class='Delimiter'>} 
</span>            <a href="nbtutils.c.html#LN1792"><span class='Ref_To_Local'>offnum</span></a> <span class='Operator'>= </span><a href="../../../include/storage/off.h.html#LN52"><span class='Ref_to_Macro'>OffsetNumberNext</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1792"><span class='Ref_To_Local'>offnum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;numKilled;i++ &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Since this can be redone later if needed, mark as dirty hint. 
     * 
     * Whenever we mark anything LP_DEAD, we also set the page's 
     * BTP_HAS_GARBAGE flag, which is likewise just a hint. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1740"><span class='Ref_To_Local'>killedsomething</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="nbtutils.c.html#LN1735"><span class='Ref_To_Local'>opaque</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN62"><span class='Ref_to_Member'>btpo_flags</span></a> <span class='Operator'>|= </span><a href="../../../include/access/nbtree.h.html#LN75"><span class='Ref_to_Const'>BTP_HAS_GARBAGE</span></a><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/bufmgr.h.html#LN211"><span class='Ref_to_Proto'>MarkBufferDirtyHint</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1733"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN412"><span class='Ref_to_Member'>currPos</span></a><span class='Operator'>.</span><a href="../../../include/access/nbtree.h.html#LN295"><span class='Ref_to_Member'>buf</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/storage/bufmgr.h.html#LN214"><span class='Ref_to_Proto'>LockBuffer</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1733"><span class='Ref_To_Local'>so</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/nbtree.h.html#LN412"><span class='Ref_to_Member'>currPos</span></a><span class='Operator'>.</span><a href="../../../include/access/nbtree.h.html#LN295"><span class='Ref_to_Member'>buf</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/bufmgr.h.html#LN86"><span class='Ref_to_Const'>BUFFER_LOCK_UNLOCK</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end _bt_killitems &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * The following routines manage a shared-memory area in which we track 
 * assignment of "vacuum cycle IDs" to currently-active btree vacuuming 
 * operations.  There is a single counter which increments each time we 
 * start a vacuum to assign it a cycle ID.  Since multiple vacuums could 
 * be active concurrently, we have to track the cycle ID for each active 
 * vacuum; this requires at most MaxBackends entries (usually far fewer). 
 * We assume at most one vacuum can be active for a given index. 
 * 
 * Access to the shared memory area is controlled by BtreeVacuumLock. 
 * In principle we could use a separate lmgr locktag for each index, 
 * but a single LWLock is much cheaper, and given the short time that 
 * the lock is ever held, the concurrency hit should be minimal. 
 */ 
</span> 
<a name="LN1845"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>BTOneVacInfo</span> 
<span class='Delimiter'>{ 
</span><a name="LN1847"></a>    <a href="../../../include/utils/rel.h.html#LN35"><span class='Ref_to_Struct'>LockRelId</span></a>   <span class='Declare_Member'>relid</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* global identifier of an index */ 
</span><a name="LN1848"></a>    <a href="../../../include/access/nbtree.h.html#LN25"><span class='Ref_to_Typedef'>BTCycleId</span></a>   <span class='Declare_Member'>cycleid</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* cycle ID for its active VACUUM */ 
</span><a name="LN1849"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>BTOneVacInfo</span><span class='Delimiter'>; 
</span> 
<a name="LN1851"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>BTVacInfo</span> 
<span class='Delimiter'>{ 
</span><a name="LN1853"></a>    <a href="../../../include/access/nbtree.h.html#LN25"><span class='Ref_to_Typedef'>BTCycleId</span></a>   <span class='Declare_Member'>cycle_ctr</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* cycle ID most recently assigned */ 
</span><a name="LN1854"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>num_vacuums</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* number of currently active VACUUMs */ 
</span><a name="LN1855"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>max_vacuums</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* allocated length of vacuums[] array */ 
</span><a name="LN1856"></a>    <a href="nbtutils.c.html#LN1845"><span class='Ref_to_Struct'>BTOneVacInfo</span></a> <span class='Declare_Member'>vacuums</span><span class='Delimiter'>[</span>FLEXIBLE_ARRAY_MEMBER<span class='Delimiter'>]; 
</span><a name="LN1857"></a>} <span class='Declare_Typedef'>BTVacInfo</span><span class='Delimiter'>; 
</span> 
<a name="LN1859"></a><span class='Keyword'>static </span><a href="nbtutils.c.html#LN1851"><span class='Ref_to_Struct'>BTVacInfo</span></a> <span class='Operator'>*</span><span class='Declare_Var'>btvacinfo</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * _bt_vacuum_cycleid --- get the active vacuum cycle ID for an index, 
 *      or zero if there is no active VACUUM 
 * 
 * Note: for correct interlocking, the caller must already hold pin and 
 * exclusive lock on each buffer it will store the cycle ID into.  This 
 * ensures that even if a VACUUM starts immediately afterwards, it cannot 
 * process those pages until the page split is complete. 
 */ 
</span><a href="../../../include/access/nbtree.h.html#LN25"><span class='Ref_to_Typedef'>BTCycleId</span></a> 
<a name="LN1872"></a><span class='Declare_Function'>_bt_vacuum_cycleid</span><span class='Parentheses'>(</span><a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>rel</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1874"></a>    <a href="../../../include/access/nbtree.h.html#LN25"><span class='Ref_to_Typedef'>BTCycleId</span></a>   <span class='Declare_Local'>result</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN1875"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Share lock is enough since this is a read-only operation */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>BtreeVacuumLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1875"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nbtutils.c.html#LN1875"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="nbtutils.c.html#LN1859"><span class='Ref_to_Global_Var'>btvacinfo</span></a><span class='Operator'>-&GT;</span><a href="nbtutils.c.html#LN1854"><span class='Ref_to_Member'>num_vacuums</span></a><span class='Delimiter'>; </span><a href="nbtutils.c.html#LN1875"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1882"></a>        <a href="nbtutils.c.html#LN1845"><span class='Ref_to_Struct'>BTOneVacInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>vac</span> <span class='Operator'>= &</span><a href="nbtutils.c.html#LN1859"><span class='Ref_to_Global_Var'>btvacinfo</span></a><span class='Operator'>-&GT;</span><a href="nbtutils.c.html#LN1856"><span class='Ref_to_Member'>vacuums</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN1875"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1882"><span class='Ref_To_Local'>vac</span></a><span class='Operator'>-&GT;</span><a href="nbtutils.c.html#LN1847"><span class='Ref_to_Member'>relid</span></a><span class='Operator'>.</span><a href="../../../include/utils/rel.h.html#LN37"><span class='Ref_to_Member'>relId</span></a> <span class='Operator'>== </span><a href="nbtutils.c.html#LN1872"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN116"><span class='Ref_to_Member'>rd_lockInfo</span></a><span class='Operator'>.</span><a href="../../../include/utils/rel.h.html#LN43"><span class='Ref_to_Member'>lockRelId</span></a><span class='Operator'>.</span><a href="../../../include/utils/rel.h.html#LN37"><span class='Ref_to_Member'>relId</span></a> <span class='Operator'>&& 
</span>            <a href="nbtutils.c.html#LN1882"><span class='Ref_To_Local'>vac</span></a><span class='Operator'>-&GT;</span><a href="nbtutils.c.html#LN1847"><span class='Ref_to_Member'>relid</span></a><span class='Operator'>.</span><a href="../../../include/utils/rel.h.html#LN38"><span class='Ref_to_Member'>dbId</span></a> <span class='Operator'>== </span><a href="nbtutils.c.html#LN1872"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN116"><span class='Ref_to_Member'>rd_lockInfo</span></a><span class='Operator'>.</span><a href="../../../include/utils/rel.h.html#LN43"><span class='Ref_to_Member'>lockRelId</span></a><span class='Operator'>.</span><a href="../../../include/utils/rel.h.html#LN38"><span class='Ref_to_Member'>dbId</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="nbtutils.c.html#LN1874"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN1882"><span class='Ref_To_Local'>vac</span></a><span class='Operator'>-&GT;</span><a href="nbtutils.c.html#LN1848"><span class='Ref_to_Member'>cycleid</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>BtreeVacuumLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="nbtutils.c.html#LN1874"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end _bt_vacuum_cycleid &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * _bt_start_vacuum --- assign a cycle ID to a just-starting VACUUM operation 
 * 
 * Note: the caller must guarantee that it will eventually call 
 * _bt_end_vacuum, else we'll permanently leak an array slot.  To ensure 
 * that this happens even in elog(FATAL) scenarios, the appropriate coding 
 * is not just a PG_TRY, but 
 *      PG_ENSURE_ERROR_CLEANUP(_bt_end_vacuum_callback, PointerGetDatum(rel)) 
 */ 
</span><a href="../../../include/access/nbtree.h.html#LN25"><span class='Ref_to_Typedef'>BTCycleId</span></a> 
<a name="LN1906"></a><span class='Declare_Function'>_bt_start_vacuum</span><span class='Parentheses'>(</span><a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>rel</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1908"></a>    <a href="../../../include/access/nbtree.h.html#LN25"><span class='Ref_to_Typedef'>BTCycleId</span></a>   <span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span><a name="LN1909"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN1910"></a>    <a href="nbtutils.c.html#LN1845"><span class='Ref_to_Struct'>BTOneVacInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>vac</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>BtreeVacuumLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Assign the next cycle ID, being careful to avoid zero as well as the 
     * reserved high values. 
     */ 
</span>    <a href="nbtutils.c.html#LN1908"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= ++</span><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1859"><span class='Ref_to_Global_Var'>btvacinfo</span></a><span class='Operator'>-&GT;</span><a href="nbtutils.c.html#LN1853"><span class='Ref_to_Member'>cycle_ctr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1908"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>== </span><span class='Number'>0</span> <span class='Operator'>|| </span><a href="nbtutils.c.html#LN1908"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>&GT; </span><a href="../../../include/access/nbtree.h.html#LN85"><span class='Ref_to_Const'>MAX_BT_CYCLE_ID</span></a><span class='Parentheses'>) 
</span>        <a href="nbtutils.c.html#LN1908"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN1859"><span class='Ref_to_Global_Var'>btvacinfo</span></a><span class='Operator'>-&GT;</span><a href="nbtutils.c.html#LN1853"><span class='Ref_to_Member'>cycle_ctr</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Let's just make sure there's no entry already for this index */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1909"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nbtutils.c.html#LN1909"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="nbtutils.c.html#LN1859"><span class='Ref_to_Global_Var'>btvacinfo</span></a><span class='Operator'>-&GT;</span><a href="nbtutils.c.html#LN1854"><span class='Ref_to_Member'>num_vacuums</span></a><span class='Delimiter'>; </span><a href="nbtutils.c.html#LN1909"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="nbtutils.c.html#LN1910"><span class='Ref_To_Local'>vac</span></a> <span class='Operator'>= &</span><a href="nbtutils.c.html#LN1859"><span class='Ref_to_Global_Var'>btvacinfo</span></a><span class='Operator'>-&GT;</span><a href="nbtutils.c.html#LN1856"><span class='Ref_to_Member'>vacuums</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN1909"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1910"><span class='Ref_To_Local'>vac</span></a><span class='Operator'>-&GT;</span><a href="nbtutils.c.html#LN1847"><span class='Ref_to_Member'>relid</span></a><span class='Operator'>.</span><a href="../../../include/utils/rel.h.html#LN37"><span class='Ref_to_Member'>relId</span></a> <span class='Operator'>== </span><a href="nbtutils.c.html#LN1906"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN116"><span class='Ref_to_Member'>rd_lockInfo</span></a><span class='Operator'>.</span><a href="../../../include/utils/rel.h.html#LN43"><span class='Ref_to_Member'>lockRelId</span></a><span class='Operator'>.</span><a href="../../../include/utils/rel.h.html#LN37"><span class='Ref_to_Member'>relId</span></a> <span class='Operator'>&& 
</span>            <a href="nbtutils.c.html#LN1910"><span class='Ref_To_Local'>vac</span></a><span class='Operator'>-&GT;</span><a href="nbtutils.c.html#LN1847"><span class='Ref_to_Member'>relid</span></a><span class='Operator'>.</span><a href="../../../include/utils/rel.h.html#LN38"><span class='Ref_to_Member'>dbId</span></a> <span class='Operator'>== </span><a href="nbtutils.c.html#LN1906"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN116"><span class='Ref_to_Member'>rd_lockInfo</span></a><span class='Operator'>.</span><a href="../../../include/utils/rel.h.html#LN43"><span class='Ref_to_Member'>lockRelId</span></a><span class='Operator'>.</span><a href="../../../include/utils/rel.h.html#LN38"><span class='Ref_to_Member'>dbId</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Unlike most places in the backend, we have to explicitly 
             * release our LWLock before throwing an error.  This is because 
             * we expect _bt_end_vacuum() to be called before transaction 
             * abort cleanup can run to release LWLocks. 
             */ 
</span>            <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>BtreeVacuumLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"multiple active vacuums for index \"%s\""</span><span class='Delimiter'>, 
</span>                 <a href="../../../include/utils/rel.h.html#LN436"><span class='Ref_to_Macro'>RelationGetRelationName</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1906"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* OK, add an entry */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1859"><span class='Ref_to_Global_Var'>btvacinfo</span></a><span class='Operator'>-&GT;</span><a href="nbtutils.c.html#LN1854"><span class='Ref_to_Member'>num_vacuums</span></a> <span class='Operator'>&GT;= </span><a href="nbtutils.c.html#LN1859"><span class='Ref_to_Global_Var'>btvacinfo</span></a><span class='Operator'>-&GT;</span><a href="nbtutils.c.html#LN1855"><span class='Ref_to_Member'>max_vacuums</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>BtreeVacuumLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"out of btvacinfo slots"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="nbtutils.c.html#LN1910"><span class='Ref_To_Local'>vac</span></a> <span class='Operator'>= &</span><a href="nbtutils.c.html#LN1859"><span class='Ref_to_Global_Var'>btvacinfo</span></a><span class='Operator'>-&GT;</span><a href="nbtutils.c.html#LN1856"><span class='Ref_to_Member'>vacuums</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN1859"><span class='Ref_to_Global_Var'>btvacinfo</span></a><span class='Operator'>-&GT;</span><a href="nbtutils.c.html#LN1854"><span class='Ref_to_Member'>num_vacuums</span></a><span class='Delimiter'>]; 
</span>    <a href="nbtutils.c.html#LN1910"><span class='Ref_To_Local'>vac</span></a><span class='Operator'>-&GT;</span><a href="nbtutils.c.html#LN1847"><span class='Ref_to_Member'>relid</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN1906"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN116"><span class='Ref_to_Member'>rd_lockInfo</span></a><span class='Operator'>.</span><a href="../../../include/utils/rel.h.html#LN43"><span class='Ref_to_Member'>lockRelId</span></a><span class='Delimiter'>; 
</span>    <a href="nbtutils.c.html#LN1910"><span class='Ref_To_Local'>vac</span></a><span class='Operator'>-&GT;</span><a href="nbtutils.c.html#LN1848"><span class='Ref_to_Member'>cycleid</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN1908"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
</span>    <a href="nbtutils.c.html#LN1859"><span class='Ref_to_Global_Var'>btvacinfo</span></a><span class='Operator'>-&GT;</span><a href="nbtutils.c.html#LN1854"><span class='Ref_to_Member'>num_vacuums</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>BtreeVacuumLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="nbtutils.c.html#LN1908"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end _bt_start_vacuum &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * _bt_end_vacuum --- mark a btree VACUUM operation as done 
 * 
 * Note: this is deliberately coded not to complain if no entry is found; 
 * this allows the caller to put PG_TRY around the start_vacuum operation. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1963"></a><span class='Declare_Function'>_bt_end_vacuum</span><span class='Parentheses'>(</span><a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>rel</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1965"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>BtreeVacuumLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Find the array entry */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1965"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nbtutils.c.html#LN1965"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="nbtutils.c.html#LN1859"><span class='Ref_to_Global_Var'>btvacinfo</span></a><span class='Operator'>-&GT;</span><a href="nbtutils.c.html#LN1854"><span class='Ref_to_Member'>num_vacuums</span></a><span class='Delimiter'>; </span><a href="nbtutils.c.html#LN1965"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1972"></a>        <a href="nbtutils.c.html#LN1845"><span class='Ref_to_Struct'>BTOneVacInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>vac</span> <span class='Operator'>= &</span><a href="nbtutils.c.html#LN1859"><span class='Ref_to_Global_Var'>btvacinfo</span></a><span class='Operator'>-&GT;</span><a href="nbtutils.c.html#LN1856"><span class='Ref_to_Member'>vacuums</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN1965"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1972"><span class='Ref_To_Local'>vac</span></a><span class='Operator'>-&GT;</span><a href="nbtutils.c.html#LN1847"><span class='Ref_to_Member'>relid</span></a><span class='Operator'>.</span><a href="../../../include/utils/rel.h.html#LN37"><span class='Ref_to_Member'>relId</span></a> <span class='Operator'>== </span><a href="nbtutils.c.html#LN1963"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN116"><span class='Ref_to_Member'>rd_lockInfo</span></a><span class='Operator'>.</span><a href="../../../include/utils/rel.h.html#LN43"><span class='Ref_to_Member'>lockRelId</span></a><span class='Operator'>.</span><a href="../../../include/utils/rel.h.html#LN37"><span class='Ref_to_Member'>relId</span></a> <span class='Operator'>&& 
</span>            <a href="nbtutils.c.html#LN1972"><span class='Ref_To_Local'>vac</span></a><span class='Operator'>-&GT;</span><a href="nbtutils.c.html#LN1847"><span class='Ref_to_Member'>relid</span></a><span class='Operator'>.</span><a href="../../../include/utils/rel.h.html#LN38"><span class='Ref_to_Member'>dbId</span></a> <span class='Operator'>== </span><a href="nbtutils.c.html#LN1963"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/rel.h.html#LN116"><span class='Ref_to_Member'>rd_lockInfo</span></a><span class='Operator'>.</span><a href="../../../include/utils/rel.h.html#LN43"><span class='Ref_to_Member'>lockRelId</span></a><span class='Operator'>.</span><a href="../../../include/utils/rel.h.html#LN38"><span class='Ref_to_Member'>dbId</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Remove it by shifting down the last entry */ 
</span>            <span class='Operator'>*</span><a href="nbtutils.c.html#LN1972"><span class='Ref_To_Local'>vac</span></a> <span class='Operator'>= </span><a href="nbtutils.c.html#LN1859"><span class='Ref_to_Global_Var'>btvacinfo</span></a><span class='Operator'>-&GT;</span><a href="nbtutils.c.html#LN1856"><span class='Ref_to_Member'>vacuums</span></a><span class='Delimiter'>[</span><a href="nbtutils.c.html#LN1859"><span class='Ref_to_Global_Var'>btvacinfo</span></a><span class='Operator'>-&GT;</span><a href="nbtutils.c.html#LN1854"><span class='Ref_to_Member'>num_vacuums</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]; 
</span>            <a href="nbtutils.c.html#LN1859"><span class='Ref_to_Global_Var'>btvacinfo</span></a><span class='Operator'>-&GT;</span><a href="nbtutils.c.html#LN1854"><span class='Ref_to_Member'>num_vacuums</span></a><span class='Operator'>--</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>BtreeVacuumLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end _bt_end_vacuum &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * _bt_end_vacuum wrapped as an on_shmem_exit callback function 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1991"></a><span class='Declare_Function'>_bt_end_vacuum_callback</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>code</span><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>arg</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/access/nbtree.h.html#LN532"><span class='Ref_to_Proto'>_bt_end_vacuum</span></a><span class='Parentheses'>((</span><a href="../../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a><span class='Parentheses'>) </span><a href="../../../include/postgres.h.html#LN554"><span class='Ref_to_Macro'>DatumGetPointer</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1991"><span class='Ref_to_Parameter'>arg</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * BTreeShmemSize --- report amount of shared memory space needed 
 */ 
</span><a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a> 
<a name="LN2000"></a><span class='Declare_Function'>BTreeShmemSize</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2002"></a>    <a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a>        <span class='Declare_Local'>size</span><span class='Delimiter'>; 
</span> 
    <a href="nbtutils.c.html#LN2002"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>= </span><a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1851"><span class='Ref_to_Struct'>BTVacInfo</span></a><span class='Delimiter'>, </span>vacuums<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="nbtutils.c.html#LN2002"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>= </span><a href="../../../include/storage/shmem.h.html#LN44"><span class='Ref_to_Proto'>add_size</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN2002"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/shmem.h.html#LN45"><span class='Ref_to_Proto'>mul_size</span></a><span class='Parentheses'>(</span><a href="../../utils/init/globals.c.html#LN126"><span class='Ref_to_Global_Var'>MaxBackends</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1845"><span class='Ref_to_Struct'>BTOneVacInfo</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="nbtutils.c.html#LN2002"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * BTreeShmemInit --- initialize this module's shared memory 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN2013"></a><span class='Declare_Function'>BTreeShmemInit</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2015"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>found</span><span class='Delimiter'>; 
</span> 
    <a href="nbtutils.c.html#LN1859"><span class='Ref_to_Global_Var'>btvacinfo</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN1851"><span class='Ref_to_Struct'>BTVacInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/storage/shmem.h.html#LN43"><span class='Ref_to_Proto'>ShmemInitStruct</span></a><span class='Parentheses'>(</span><span class='String'>"BTree Vacuum State"</span><span class='Delimiter'>, 
</span>                                              <a href="../../../include/access/nbtree.h.html#LN534"><span class='Ref_to_Proto'>BTreeShmemSize</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                                              <span class='Operator'>&</span><a href="nbtutils.c.html#LN2015"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../utils/init/globals.c.html#LN100"><span class='Ref_to_Global_Var'>IsUnderPostmaster</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Initialize shared memory area */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="nbtutils.c.html#LN2015"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * It doesn't really matter what the cycle counter starts at, but 
         * having it always start the same doesn't seem good.  Seed with 
         * low-order bits of time() instead. 
         */ 
</span>        <a href="nbtutils.c.html#LN1859"><span class='Ref_to_Global_Var'>btvacinfo</span></a><span class='Operator'>-&GT;</span><a href="nbtutils.c.html#LN1853"><span class='Ref_to_Member'>cycle_ctr</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/nbtree.h.html#LN25"><span class='Ref_to_Typedef'>BTCycleId</span></a><span class='Parentheses'>) </span>time<span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="nbtutils.c.html#LN1859"><span class='Ref_to_Global_Var'>btvacinfo</span></a><span class='Operator'>-&GT;</span><a href="nbtutils.c.html#LN1854"><span class='Ref_to_Member'>num_vacuums</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="nbtutils.c.html#LN1859"><span class='Ref_to_Global_Var'>btvacinfo</span></a><span class='Operator'>-&GT;</span><a href="nbtutils.c.html#LN1855"><span class='Ref_to_Member'>max_vacuums</span></a> <span class='Operator'>= </span><a href="../../utils/init/globals.c.html#LN126"><span class='Ref_to_Global_Var'>MaxBackends</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN2015"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end BTreeShmemInit &raquo; </span> 
 
<a href="../../../include/c.h.html#LN451"><span class='Ref_to_Typedef'>bytea</span></a> <span class='Operator'>* 
</span><a name="LN2041"></a><span class='Declare_Function'>btoptions</span><span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>reloptions</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>validate</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <a href="../../../include/access/reloptions.h.html#LN272"><span class='Ref_to_Proto'>default_reloptions</span></a><span class='Parentheses'>(</span><a href="nbtutils.c.html#LN2041"><span class='Ref_to_Parameter'>reloptions</span></a><span class='Delimiter'>, </span><a href="nbtutils.c.html#LN2041"><span class='Ref_to_Parameter'>validate</span></a><span class='Delimiter'>, </span><a href="../../../include/access/reloptions.h.html#LN41"><span class='Ref_to_EnumConst'>RELOPT_KIND_BTREE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 *  btproperty() -- Check boolean properties of indexes. 
 * 
 * This is optional, but handling AMPROP_RETURNABLE here saves opening the rel 
 * to call btcanreturn. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN2053"></a><span class='Declare_Function'>btproperty</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>index_oid</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>attno</span><span class='Delimiter'>, 
</span><a name="LN2054"></a>           <a href="../../../include/access/amapi.h.html#LN33"><span class='Ref_to_Enum'>IndexAMProperty</span></a> <span class='Declare_Parameter'>prop</span><span class='Delimiter'>, </span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>propname</span><span class='Delimiter'>, 
</span><a name="LN2055"></a>           <span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>res</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>isnull</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN2054"><span class='Ref_to_Parameter'>prop</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../../include/access/amapi.h.html#LN42"><span class='Ref_to_EnumConst'>AMPROP_RETURNABLE</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* answer only for columns, not AM or whole index */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nbtutils.c.html#LN2053"><span class='Ref_to_Parameter'>attno</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* otherwise, btree can always return data */ 
</span>            <span class='Operator'>*</span><a href="nbtutils.c.html#LN2055"><span class='Ref_to_Parameter'>res</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>default</span><span class='Operator'>: 
</span>            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* punt to generic code */ 
</span>    <span class='Delimiter'>} 
} 
</span></pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>