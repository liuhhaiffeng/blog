<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\access\transam\varsup.c</title>
<LINK REL=StyleSheet HREF="../../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\access\transam\varsup.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:30 2017
</td></tr>
<tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
</span><span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * varsup.c 
 *    postgres OID & XID variables support routines 
 * 
 * Copyright (c) 2000-2017, PostgreSQL Global Development Group 
 * 
 * IDENTIFICATION 
 *    src/backend/access/transam/varsup.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span> 
<span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"access/clog.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/commit_ts.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/subtrans.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/transam.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/xact.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/xlog.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"commands/dbcommands.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"miscadmin.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"postmaster/autovacuum.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/pmsignal.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/proc.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/syscache.h"</span> 
 
 
<span class='Comment_Multi_Line'>/* Number of OIDs to prefetch (preallocate) per XLOG write */ 
</span><a name="LN30"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>VAR_OID_PREFETCH</span>        <span class='Number'>8192</span> 
 
<span class='Comment_Multi_Line'>/* pointer to "variable cache" in shared memory (set up by shmem.c) */ 
</span><a name="LN33"></a><a href="../../../include/access/transam.h.html#LN144"><span class='Ref_to_Typedef'>VariableCache</span></a> <span class='Declare_Var'>ShmemVariableCache</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Allocate the next XID for a new transaction or subtransaction. 
 * 
 * The new XID is also stored into MyPgXact before returning. 
 * 
 * Note: when this is called, we are actually already inside a valid 
 * transaction, since XIDs are now not allocated until the transaction 
 * does something.  So it is safe to do a database lookup if we want to 
 * issue a warning about XID wrap. 
 */ 
</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> 
<a name="LN47"></a><span class='Declare_Function'>GetNewTransactionId</span><span class='Parentheses'>(</span><span class='Keyword'>bool </span><span class='Declare_Parameter'>isSubXact</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN49"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>xid</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Workers synchronize transaction state at the beginning of each parallel 
     * operation, so we can't account for new XIDs after that point. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/xact.h.html#LN405"><span class='Ref_to_Proto'>IsInParallelMode</span></a><span class='Parentheses'>())</span> 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cannot assign TransactionIds during a parallel operation"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * During bootstrap initialization, we return the special bootstrap 
     * transaction id. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/miscadmin.h.html#LN369"><span class='Ref_to_Macro'>IsBootstrapProcessingMode</span></a><span class='Parentheses'>())</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="varsup.c.html#LN47"><span class='Ref_to_Parameter'>isSubXact</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../storage/lmgr/proc.c.html#LN67"><span class='Ref_to_Global_Var'>MyPgXact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN208"><span class='Ref_to_Member'>xid</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN31"><span class='Ref_to_Const'>BootstrapTransactionId</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <a href="../../../include/access/transam.h.html#LN31"><span class='Ref_to_Const'>BootstrapTransactionId</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* safety check, we should never get this far in a HS slave */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN242"><span class='Ref_to_Proto'>RecoveryInProgress</span></a><span class='Parentheses'>())</span> 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cannot assign TransactionIds during recovery"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>XidGenLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="varsup.c.html#LN49"><span class='Ref_To_Local'>xid</span></a> <span class='Operator'>= </span><a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN116"><span class='Ref_to_Member'>nextXid</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/*---------- 
     * Check to see if it's safe to assign another XID.  This protects against 
     * catastrophic data loss due to XID wraparound.  The basic rules are: 
     * 
     * If we're past xidVacLimit, start trying to force autovacuum cycles. 
     * If we're past xidWarnLimit, start issuing warnings. 
     * If we're past xidStopLimit, refuse to execute transactions, unless 
     * we are running in single-user mode (which gives an escape hatch 
     * to the DBA who somehow got past the earlier defenses). 
     * 
     * Note that this coding also appears in GetNewMultiXactId. 
     *---------- 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN171"><span class='Ref_to_Proto'>TransactionIdFollowsOrEquals</span></a><span class='Parentheses'>(</span><a href="varsup.c.html#LN49"><span class='Ref_To_Local'>xid</span></a><span class='Delimiter'>, </span><a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN119"><span class='Ref_to_Member'>xidVacLimit</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * For safety's sake, we release XidGenLock while sending signals, 
         * warnings, etc.  This is not so much because we care about 
         * preserving concurrency in this situation, as to avoid any 
         * possibility of deadlock while doing get_database_name(). First, 
         * copy all the shared values we'll need in this path. 
         */ 
</span><a name="LN99"></a>        <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>xidWarnLimit</span> <span class='Operator'>= </span><a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN120"><span class='Ref_to_Member'>xidWarnLimit</span></a><span class='Delimiter'>; 
</span><a name="LN100"></a>        <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>xidStopLimit</span> <span class='Operator'>= </span><a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN121"><span class='Ref_to_Member'>xidStopLimit</span></a><span class='Delimiter'>; 
</span><a name="LN101"></a>        <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>xidWrapLimit</span> <span class='Operator'>= </span><a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN122"><span class='Ref_to_Member'>xidWrapLimit</span></a><span class='Delimiter'>; 
</span><a name="LN102"></a>        <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>oldest_datoid</span> <span class='Operator'>= </span><a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN123"><span class='Ref_to_Member'>oldestXidDB</span></a><span class='Delimiter'>; 
</span> 
        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>XidGenLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * To avoid swamping the postmaster with signals, we issue the autovac 
         * request only once per 64K transaction starts.  This still gives 
         * plenty of chances before we get into real trouble. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../utils/init/globals.c.html#LN100"><span class='Ref_to_Global_Var'>IsUnderPostmaster</span></a> <span class='Operator'>&& </span><span class='Parentheses'>(</span><a href="varsup.c.html#LN49"><span class='Ref_To_Local'>xid</span></a> <span class='Operator'>% </span><span class='Number'>65536</span><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
            <a href="../../../include/storage/pmsignal.h.html#LN45"><span class='Ref_to_Proto'>SendPostmasterSignal</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/pmsignal.h.html#LN28"><span class='Ref_to_EnumConst'>PMSIGNAL_START_AUTOVAC_LAUNCHER</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../utils/init/globals.c.html#LN100"><span class='Ref_to_Global_Var'>IsUnderPostmaster</span></a> <span class='Operator'>&& 
</span>            <a href="../../../include/access/transam.h.html#LN171"><span class='Ref_to_Proto'>TransactionIdFollowsOrEquals</span></a><span class='Parentheses'>(</span><a href="varsup.c.html#LN49"><span class='Ref_To_Local'>xid</span></a><span class='Delimiter'>, </span><a href="varsup.c.html#LN100"><span class='Ref_To_Local'>xidStopLimit</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN117"></a>            <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>oldest_datname</span> <span class='Operator'>= </span><a href="../../../include/commands/dbcommands.h.html#LN29"><span class='Ref_to_Proto'>get_database_name</span></a><span class='Parentheses'>(</span><a href="varsup.c.html#LN102"><span class='Ref_To_Local'>oldest_datoid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* complain even if that DB has disappeared */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="varsup.c.html#LN117"><span class='Ref_To_Local'>oldest_datname</span></a><span class='Parentheses'>) 
</span>                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_PROGRAM_LIMIT_EXCEEDED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"database is not accepting commands to avoid wraparound data loss in database \"%s\""</span><span class='Delimiter'>, 
</span>                                <a href="varsup.c.html#LN117"><span class='Ref_To_Local'>oldest_datname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"Stop the postmaster and vacuum that database in single-user mode.\n"</span> 
                                 <span class='String'>"You might also need to commit or roll back old prepared transactions."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_PROGRAM_LIMIT_EXCEEDED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"database is not accepting commands to avoid wraparound data loss in database with OID %u"</span><span class='Delimiter'>, 
</span>                                <a href="varsup.c.html#LN102"><span class='Ref_To_Local'>oldest_datoid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"Stop the postmaster and vacuum that database in single-user mode.\n"</span> 
                                 <span class='String'>"You might also need to commit or roll back old prepared transactions."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if IsUnderPostmaster&&Tr... &raquo; </span> 
        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN171"><span class='Ref_to_Proto'>TransactionIdFollowsOrEquals</span></a><span class='Parentheses'>(</span><a href="varsup.c.html#LN49"><span class='Ref_To_Local'>xid</span></a><span class='Delimiter'>, </span><a href="varsup.c.html#LN99"><span class='Ref_To_Local'>xidWarnLimit</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN137"></a>            <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>oldest_datname</span> <span class='Operator'>= </span><a href="../../../include/commands/dbcommands.h.html#LN29"><span class='Ref_to_Proto'>get_database_name</span></a><span class='Parentheses'>(</span><a href="varsup.c.html#LN102"><span class='Ref_To_Local'>oldest_datoid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* complain even if that DB has disappeared */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="varsup.c.html#LN137"><span class='Ref_To_Local'>oldest_datname</span></a><span class='Parentheses'>) 
</span>                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN39"><span class='Ref_to_Const'>WARNING</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"database \"%s\" must be vacuumed within %u transactions"</span><span class='Delimiter'>, 
</span>                                <a href="varsup.c.html#LN137"><span class='Ref_To_Local'>oldest_datname</span></a><span class='Delimiter'>, 
</span>                                <a href="varsup.c.html#LN101"><span class='Ref_To_Local'>xidWrapLimit</span></a> <span class='Operator'>- </span><a href="varsup.c.html#LN49"><span class='Ref_To_Local'>xid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"To avoid a database shutdown, execute a database-wide VACUUM in that database.\n"</span> 
                                 <span class='String'>"You might also need to commit or roll back old prepared transactions."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN39"><span class='Ref_to_Const'>WARNING</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"database with OID %u must be vacuumed within %u transactions"</span><span class='Delimiter'>, 
</span>                                <a href="varsup.c.html#LN102"><span class='Ref_To_Local'>oldest_datoid</span></a><span class='Delimiter'>, 
</span>                                <a href="varsup.c.html#LN101"><span class='Ref_To_Local'>xidWrapLimit</span></a> <span class='Operator'>- </span><a href="varsup.c.html#LN49"><span class='Ref_To_Local'>xid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"To avoid a database shutdown, execute a database-wide VACUUM in that database.\n"</span> 
                                 <span class='String'>"You might also need to commit or roll back old prepared transactions."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if TransactionIdFollowsO... &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* Re-acquire lock and start over */ 
</span>        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>XidGenLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="varsup.c.html#LN49"><span class='Ref_To_Local'>xid</span></a> <span class='Operator'>= </span><a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN116"><span class='Ref_to_Member'>nextXid</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if TransactionIdFollowsO... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * If we are allocating the first XID of a new page of the commit log, 
     * zero out that commit-log page before returning. We must do this while 
     * holding XidGenLock, else another xact could acquire and commit a later 
     * XID before we zero the page.  Fortunately, a page of the commit log 
     * holds 32K or more transactions, so we don't have to do this very often. 
     * 
     * Extend pg_subtrans and pg_commit_ts too. 
     */ 
</span>    <a href="../../../include/access/clog.h.html#LN49"><span class='Ref_to_Proto'>ExtendCLOG</span></a><span class='Parentheses'>(</span><a href="varsup.c.html#LN49"><span class='Ref_To_Local'>xid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/access/commit_ts.h.html#LN41"><span class='Ref_to_Proto'>ExtendCommitTs</span></a><span class='Parentheses'>(</span><a href="varsup.c.html#LN49"><span class='Ref_To_Local'>xid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/access/subtrans.h.html#LN26"><span class='Ref_to_Proto'>ExtendSUBTRANS</span></a><span class='Parentheses'>(</span><a href="varsup.c.html#LN49"><span class='Ref_To_Local'>xid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now advance the nextXid counter.  This must not happen until after we 
     * have successfully completed ExtendCLOG() --- if that routine fails, we 
     * want the next incoming transaction to try it again.  We cannot assign 
     * more XIDs until there is CLOG space for them. 
     */ 
</span>    <a href="../../../include/access/transam.h.html#LN47"><span class='Ref_to_Macro'>TransactionIdAdvance</span></a><span class='Parentheses'>(</span><a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN116"><span class='Ref_to_Member'>nextXid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We must store the new XID into the shared ProcArray before releasing 
     * XidGenLock.  This ensures that every active XID older than 
     * latestCompletedXid is present in the ProcArray, which is essential for 
     * correct OldestXmin tracking; see src/backend/access/transam/README. 
     * 
     * XXX by storing xid into MyPgXact without acquiring ProcArrayLock, we 
     * are relying on fetch/store of an xid to be atomic, else other backends 
     * might see a partially-set xid here.  But holding both locks at once 
     * would be a nasty concurrency hit.  So for now, assume atomicity. 
     * 
     * Note that readers of PGXACT xid fields should be careful to fetch the 
     * value only once, rather than assume they can read a value multiple 
     * times and get the same answer each time. 
     * 
     * The same comments apply to the subxact xid count and overflow fields. 
     * 
     * A solution to the atomic-store problem would be to give each PGXACT its 
     * own spinlock used only for fetching/storing that PGXACT's xid and 
     * related fields. 
     * 
     * If there's no room to fit a subtransaction XID into PGPROC, set the 
     * cache-overflowed flag instead.  This forces readers to look in 
     * pg_subtrans to map subtransaction XIDs up to top-level XIDs. There is a 
     * race-condition window, in that the new XID will not appear as running 
     * until its parent link has been placed into pg_subtrans. However, that 
     * will happen before anyone could possibly have a reason to inquire about 
     * the status of the XID, so it seems OK.  (Snapshots taken during this 
     * window *will* include the parent XID, so they will deliver the correct 
     * answer later on when someone does have a reason to inquire.) 
     */ 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Use volatile pointer to prevent code rearrangement; other backends 
         * could be examining my subxids info concurrently, and we don't want 
         * them to see an invalid intermediate state, such as incrementing 
         * nxids before filling the array entry.  Note we are assuming that 
         * TransactionId and int fetch/store are atomic. 
         */ 
</span><a name="LN221"></a>        <span class='Keyword'>volatile </span><a href="../../../include/storage/proc.h.html#LN93"><span class='Ref_to_Struct'>PGPROC</span></a> <span class='Operator'>*</span><span class='Declare_Local'>myproc</span> <span class='Operator'>= </span><a href="../../storage/lmgr/proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Delimiter'>; 
</span><a name="LN222"></a>        <span class='Keyword'>volatile </span><a href="../../../include/storage/proc.h.html#LN206"><span class='Ref_to_Struct'>PGXACT</span></a> <span class='Operator'>*</span><span class='Declare_Local'>mypgxact</span> <span class='Operator'>= </span><a href="../../storage/lmgr/proc.c.html#LN67"><span class='Ref_to_Global_Var'>MyPgXact</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="varsup.c.html#LN47"><span class='Ref_to_Parameter'>isSubXact</span></a><span class='Parentheses'>) 
</span>            <a href="varsup.c.html#LN222"><span class='Ref_To_Local'>mypgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN208"><span class='Ref_to_Member'>xid</span></a> <span class='Operator'>= </span><a href="varsup.c.html#LN49"><span class='Ref_To_Local'>xid</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span><a name="LN228"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>nxids</span> <span class='Operator'>= </span><a href="varsup.c.html#LN222"><span class='Ref_To_Local'>mypgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN222"><span class='Ref_to_Member'>nxids</span></a><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="varsup.c.html#LN228"><span class='Ref_To_Local'>nxids</span></a> <span class='Operator'>&LT; </span><a href="../../../include/storage/proc.h.html#LN34"><span class='Ref_to_Const'>PGPROC_MAX_CACHED_SUBXIDS</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="varsup.c.html#LN221"><span class='Ref_To_Local'>myproc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN157"><span class='Ref_to_Member'>subxids</span></a><span class='Operator'>.</span><a href="../../../include/storage/proc.h.html#LN38"><span class='Ref_to_Member'>xids</span></a><span class='Delimiter'>[</span><a href="varsup.c.html#LN228"><span class='Ref_To_Local'>nxids</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="varsup.c.html#LN49"><span class='Ref_To_Local'>xid</span></a><span class='Delimiter'>; 
</span>                <a href="varsup.c.html#LN222"><span class='Ref_To_Local'>mypgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN222"><span class='Ref_to_Member'>nxids</span></a> <span class='Operator'>= </span><a href="varsup.c.html#LN228"><span class='Ref_To_Local'>nxids</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
                <a href="varsup.c.html#LN222"><span class='Ref_To_Local'>mypgxact</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN218"><span class='Ref_to_Member'>overflowed</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>XidGenLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="varsup.c.html#LN49"><span class='Ref_To_Local'>xid</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end GetNewTransactionId &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Read nextXid but don't allocate it. 
 */ 
</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> 
<a name="LN249"></a><span class='Declare_Function'>ReadNewTransactionId</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN251"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>xid</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>XidGenLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="varsup.c.html#LN251"><span class='Ref_To_Local'>xid</span></a> <span class='Operator'>= </span><a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN116"><span class='Ref_to_Member'>nextXid</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>XidGenLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="varsup.c.html#LN251"><span class='Ref_To_Local'>xid</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Advance the cluster-wide value for the oldest valid clog entry. 
 * 
 * We must acquire CLogTruncationLock to advance the oldestClogXid. It's not 
 * necessary to hold the lock during the actual clog truncation, only when we 
 * advance the limit, as code looking up arbitrary xids is required to hold 
 * CLogTruncationLock from when it tests oldestClogXid through to when it 
 * completes the clog lookup. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN270"></a><span class='Declare_Function'>AdvanceOldestClogXid</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>oldest_datfrozenxid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>CLogTruncationLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN140"><span class='Ref_to_Member'>oldestClogXid</span></a><span class='Delimiter'>, 
</span>                              <a href="varsup.c.html#LN270"><span class='Ref_to_Parameter'>oldest_datfrozenxid</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN140"><span class='Ref_to_Member'>oldestClogXid</span></a> <span class='Operator'>= </span><a href="varsup.c.html#LN270"><span class='Ref_to_Parameter'>oldest_datfrozenxid</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>CLogTruncationLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Determine the last safe XID to allocate using the currently oldest 
 * datfrozenxid (ie, the oldest XID that might exist in any database 
 * of our cluster), and the OID of the (or a) database with that value. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN287"></a><span class='Declare_Function'>SetTransactionIdLimit</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>oldest_datfrozenxid</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>oldest_datoid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN289"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>xidVacLimit</span><span class='Delimiter'>; 
</span><a name="LN290"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>xidWarnLimit</span><span class='Delimiter'>; 
</span><a name="LN291"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>xidStopLimit</span><span class='Delimiter'>; 
</span><a name="LN292"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>xidWrapLimit</span><span class='Delimiter'>; 
</span><a name="LN293"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>curXid</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><a href="varsup.c.html#LN287"><span class='Ref_to_Parameter'>oldest_datfrozenxid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * The place where we actually get into deep trouble is halfway around 
     * from the oldest potentially-existing XID.  (This calculation is 
     * probably off by one or two counts, because the special XIDs reduce the 
     * size of the loop a little bit.  But we throw in plenty of slop below, 
     * so it doesn't matter.) 
     */ 
</span>    <a href="varsup.c.html#LN292"><span class='Ref_To_Local'>xidWrapLimit</span></a> <span class='Operator'>= </span><a href="varsup.c.html#LN287"><span class='Ref_to_Parameter'>oldest_datfrozenxid</span></a> <span class='Operator'>+ </span><span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN34"><span class='Ref_to_Const'>MaxTransactionId</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="varsup.c.html#LN292"><span class='Ref_To_Local'>xidWrapLimit</span></a> <span class='Operator'>&LT; </span><a href="../../../include/access/transam.h.html#LN33"><span class='Ref_to_Const'>FirstNormalTransactionId</span></a><span class='Parentheses'>) 
</span>        <a href="varsup.c.html#LN292"><span class='Ref_To_Local'>xidWrapLimit</span></a> <span class='Operator'>+= </span><a href="../../../include/access/transam.h.html#LN33"><span class='Ref_to_Const'>FirstNormalTransactionId</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We'll refuse to continue assigning XIDs in interactive mode once we get 
     * within 1M transactions of data loss.  This leaves lots of room for the 
     * DBA to fool around fixing things in a standalone backend, while not 
     * being significant compared to total XID space. (Note that since 
     * vacuuming requires one transaction per table cleaned, we had better be 
     * sure there's lots of XIDs left...) 
     */ 
</span>    <a href="varsup.c.html#LN291"><span class='Ref_To_Local'>xidStopLimit</span></a> <span class='Operator'>= </span><a href="varsup.c.html#LN292"><span class='Ref_To_Local'>xidWrapLimit</span></a> <span class='Operator'>- </span><span class='Number'>1000000</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="varsup.c.html#LN291"><span class='Ref_To_Local'>xidStopLimit</span></a> <span class='Operator'>&LT; </span><a href="../../../include/access/transam.h.html#LN33"><span class='Ref_to_Const'>FirstNormalTransactionId</span></a><span class='Parentheses'>) 
</span>        <a href="varsup.c.html#LN291"><span class='Ref_To_Local'>xidStopLimit</span></a> <span class='Operator'>-= </span><a href="../../../include/access/transam.h.html#LN33"><span class='Ref_to_Const'>FirstNormalTransactionId</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We'll start complaining loudly when we get within 10M transactions of 
     * the stop point.  This is kind of arbitrary, but if you let your gas 
     * gauge get down to 1% of full, would you be looking for the next gas 
     * station?  We need to be fairly liberal about this number because there 
     * are lots of scenarios where most transactions are done by automatic 
     * clients that won't pay attention to warnings. (No, we're not gonna make 
     * this configurable.  If you know enough to configure it, you know enough 
     * to not get in this kind of trouble in the first place.) 
     */ 
</span>    <a href="varsup.c.html#LN290"><span class='Ref_To_Local'>xidWarnLimit</span></a> <span class='Operator'>= </span><a href="varsup.c.html#LN291"><span class='Ref_To_Local'>xidStopLimit</span></a> <span class='Operator'>- </span><span class='Number'>10000000</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="varsup.c.html#LN290"><span class='Ref_To_Local'>xidWarnLimit</span></a> <span class='Operator'>&LT; </span><a href="../../../include/access/transam.h.html#LN33"><span class='Ref_to_Const'>FirstNormalTransactionId</span></a><span class='Parentheses'>) 
</span>        <a href="varsup.c.html#LN290"><span class='Ref_To_Local'>xidWarnLimit</span></a> <span class='Operator'>-= </span><a href="../../../include/access/transam.h.html#LN33"><span class='Ref_to_Const'>FirstNormalTransactionId</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We'll start trying to force autovacuums when oldest_datfrozenxid gets 
     * to be more than autovacuum_freeze_max_age transactions old. 
     * 
     * Note: guc.c ensures that autovacuum_freeze_max_age is in a sane range, 
     * so that xidVacLimit will be well before xidWarnLimit. 
     * 
     * Note: autovacuum_freeze_max_age is a PGC_POSTMASTER parameter so that 
     * we don't have to worry about dealing with on-the-fly changes in its 
     * value.  It doesn't look practical to update shared state from a GUC 
     * assign hook (too many processes would try to execute the hook, 
     * resulting in race conditions as well as crashes of those not connected 
     * to shared memory).  Perhaps this can be improved someday.  See also 
     * SetMultiXactIdLimit. 
     */ 
</span>    <a href="varsup.c.html#LN289"><span class='Ref_To_Local'>xidVacLimit</span></a> <span class='Operator'>= </span><a href="varsup.c.html#LN287"><span class='Ref_to_Parameter'>oldest_datfrozenxid</span></a> <span class='Operator'>+ </span><a href="../../postmaster/autovacuum.c.html#LN119"><span class='Ref_to_Global_Var'>autovacuum_freeze_max_age</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="varsup.c.html#LN289"><span class='Ref_To_Local'>xidVacLimit</span></a> <span class='Operator'>&LT; </span><a href="../../../include/access/transam.h.html#LN33"><span class='Ref_to_Const'>FirstNormalTransactionId</span></a><span class='Parentheses'>) 
</span>        <a href="varsup.c.html#LN289"><span class='Ref_To_Local'>xidVacLimit</span></a> <span class='Operator'>+= </span><a href="../../../include/access/transam.h.html#LN33"><span class='Ref_to_Const'>FirstNormalTransactionId</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Grab lock for just long enough to set the new limit values */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>XidGenLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN118"><span class='Ref_to_Member'>oldestXid</span></a> <span class='Operator'>= </span><a href="varsup.c.html#LN287"><span class='Ref_to_Parameter'>oldest_datfrozenxid</span></a><span class='Delimiter'>; 
</span>    <a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN119"><span class='Ref_to_Member'>xidVacLimit</span></a> <span class='Operator'>= </span><a href="varsup.c.html#LN289"><span class='Ref_To_Local'>xidVacLimit</span></a><span class='Delimiter'>; 
</span>    <a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN120"><span class='Ref_to_Member'>xidWarnLimit</span></a> <span class='Operator'>= </span><a href="varsup.c.html#LN290"><span class='Ref_To_Local'>xidWarnLimit</span></a><span class='Delimiter'>; 
</span>    <a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN121"><span class='Ref_to_Member'>xidStopLimit</span></a> <span class='Operator'>= </span><a href="varsup.c.html#LN291"><span class='Ref_To_Local'>xidStopLimit</span></a><span class='Delimiter'>; 
</span>    <a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN122"><span class='Ref_to_Member'>xidWrapLimit</span></a> <span class='Operator'>= </span><a href="varsup.c.html#LN292"><span class='Ref_To_Local'>xidWrapLimit</span></a><span class='Delimiter'>; 
</span>    <a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN123"><span class='Ref_to_Member'>oldestXidDB</span></a> <span class='Operator'>= </span><a href="varsup.c.html#LN287"><span class='Ref_to_Parameter'>oldest_datoid</span></a><span class='Delimiter'>; 
</span>    <a href="varsup.c.html#LN293"><span class='Ref_To_Local'>curXid</span></a> <span class='Operator'>= </span><a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN116"><span class='Ref_to_Member'>nextXid</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>XidGenLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Log the info */ 
</span>    <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN24"><span class='Ref_to_Const'>DEBUG1</span></a><span class='Delimiter'>, 
</span>            <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"transaction ID wrap limit is %u, limited by database with OID %u"</span><span class='Delimiter'>, 
</span>                    <a href="varsup.c.html#LN292"><span class='Ref_To_Local'>xidWrapLimit</span></a><span class='Delimiter'>, </span><a href="varsup.c.html#LN287"><span class='Ref_to_Parameter'>oldest_datoid</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If past the autovacuum force point, immediately signal an autovac 
     * request.  The reason for this is that autovac only processes one 
     * database per invocation.  Once it's finished cleaning up the oldest 
     * database, it'll call here, and we'll signal the postmaster to start 
     * another iteration immediately if there are still any old databases. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN171"><span class='Ref_to_Proto'>TransactionIdFollowsOrEquals</span></a><span class='Parentheses'>(</span><a href="varsup.c.html#LN293"><span class='Ref_To_Local'>curXid</span></a><span class='Delimiter'>, </span><a href="varsup.c.html#LN289"><span class='Ref_To_Local'>xidVacLimit</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>        <a href="../../utils/init/globals.c.html#LN100"><span class='Ref_to_Global_Var'>IsUnderPostmaster</span></a> <span class='Operator'>&& !</span><a href="xlog.c.html#LN191"><span class='Ref_to_Global_Var'>InRecovery</span></a><span class='Parentheses'>)</span> 
        <a href="../../../include/storage/pmsignal.h.html#LN45"><span class='Ref_to_Proto'>SendPostmasterSignal</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/pmsignal.h.html#LN28"><span class='Ref_to_EnumConst'>PMSIGNAL_START_AUTOVAC_LAUNCHER</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Give an immediate warning if past the wrap warn point */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN171"><span class='Ref_to_Proto'>TransactionIdFollowsOrEquals</span></a><span class='Parentheses'>(</span><a href="varsup.c.html#LN293"><span class='Ref_To_Local'>curXid</span></a><span class='Delimiter'>, </span><a href="varsup.c.html#LN290"><span class='Ref_To_Local'>xidWarnLimit</span></a><span class='Parentheses'>) </span><span class='Operator'>&& !</span><a href="xlog.c.html#LN191"><span class='Ref_to_Global_Var'>InRecovery</span></a><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span><a name="LN383"></a>        <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>oldest_datname</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We can be called when not inside a transaction, for example during 
         * StartupXLOG().  In such a case we cannot do database access, so we 
         * must just report the oldest DB's OID. 
         * 
         * Note: it's also possible that get_database_name fails and returns 
         * NULL, for example because the database just got dropped.  We'll 
         * still warn, even though the warning might now be unnecessary. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/xact.h.html#LN329"><span class='Ref_to_Proto'>IsTransactionState</span></a><span class='Parentheses'>())</span> 
            <a href="varsup.c.html#LN383"><span class='Ref_To_Local'>oldest_datname</span></a> <span class='Operator'>= </span><a href="../../../include/commands/dbcommands.h.html#LN29"><span class='Ref_to_Proto'>get_database_name</span></a><span class='Parentheses'>(</span><a href="varsup.c.html#LN287"><span class='Ref_to_Parameter'>oldest_datoid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="varsup.c.html#LN383"><span class='Ref_To_Local'>oldest_datname</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="varsup.c.html#LN383"><span class='Ref_To_Local'>oldest_datname</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN39"><span class='Ref_to_Const'>WARNING</span></a><span class='Delimiter'>, 
</span>            <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"database \"%s\" must be vacuumed within %u transactions"</span><span class='Delimiter'>, 
</span>                    <a href="varsup.c.html#LN383"><span class='Ref_To_Local'>oldest_datname</span></a><span class='Delimiter'>, 
</span>                    <a href="varsup.c.html#LN292"><span class='Ref_To_Local'>xidWrapLimit</span></a> <span class='Operator'>- </span><a href="varsup.c.html#LN293"><span class='Ref_To_Local'>curXid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>             <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"To avoid a database shutdown, execute a database-wide VACUUM in that database.\n"</span> 
                     <span class='String'>"You might also need to commit or roll back old prepared transactions."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN39"><span class='Ref_to_Const'>WARNING</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"database with OID %u must be vacuumed within %u transactions"</span><span class='Delimiter'>, 
</span>                            <a href="varsup.c.html#LN287"><span class='Ref_to_Parameter'>oldest_datoid</span></a><span class='Delimiter'>, 
</span>                            <a href="varsup.c.html#LN292"><span class='Ref_To_Local'>xidWrapLimit</span></a> <span class='Operator'>- </span><a href="varsup.c.html#LN293"><span class='Ref_To_Local'>curXid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"To avoid a database shutdown, execute a database-wide VACUUM in that database.\n"</span> 
                             <span class='String'>"You might also need to commit or roll back old prepared transactions."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if TransactionIdFollowsO... &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end SetTransactionIdLimit &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * ForceTransactionIdLimitUpdate -- does the XID wrap-limit data need updating? 
 * 
 * We primarily check whether oldestXidDB is valid.  The cases we have in 
 * mind are that that database was dropped, or the field was reset to zero 
 * by pg_resetwal.  In either case we should force recalculation of the 
 * wrap limit.  Also do it if oldestXid is old enough to be forcing 
 * autovacuums or other actions; this ensures we update our state as soon 
 * as possible once extra overhead is being incurred. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN428"></a><span class='Declare_Function'>ForceTransactionIdLimitUpdate</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN430"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>nextXid</span><span class='Delimiter'>; 
</span><a name="LN431"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>xidVacLimit</span><span class='Delimiter'>; 
</span><a name="LN432"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>oldestXid</span><span class='Delimiter'>; 
</span><a name="LN433"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>oldestXidDB</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Locking is probably not really necessary, but let's be careful */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>XidGenLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="varsup.c.html#LN430"><span class='Ref_To_Local'>nextXid</span></a> <span class='Operator'>= </span><a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN116"><span class='Ref_to_Member'>nextXid</span></a><span class='Delimiter'>; 
</span>    <a href="varsup.c.html#LN431"><span class='Ref_To_Local'>xidVacLimit</span></a> <span class='Operator'>= </span><a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN119"><span class='Ref_to_Member'>xidVacLimit</span></a><span class='Delimiter'>; 
</span>    <a href="varsup.c.html#LN432"><span class='Ref_To_Local'>oldestXid</span></a> <span class='Operator'>= </span><a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN118"><span class='Ref_to_Member'>oldestXid</span></a><span class='Delimiter'>; 
</span>    <a href="varsup.c.html#LN433"><span class='Ref_To_Local'>oldestXidDB</span></a> <span class='Operator'>= </span><a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN123"><span class='Ref_to_Member'>oldestXidDB</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>XidGenLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><a href="varsup.c.html#LN432"><span class='Ref_To_Local'>oldestXid</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* shouldn't happen, but just in case */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="varsup.c.html#LN431"><span class='Ref_To_Local'>xidVacLimit</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* this shouldn't happen anymore either */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN171"><span class='Ref_to_Proto'>TransactionIdFollowsOrEquals</span></a><span class='Parentheses'>(</span><a href="varsup.c.html#LN430"><span class='Ref_To_Local'>nextXid</span></a><span class='Delimiter'>, </span><a href="varsup.c.html#LN431"><span class='Ref_To_Local'>xidVacLimit</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* past VacLimit, don't delay updating */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/utils/syscache.h.html#LN173"><span class='Ref_to_Macro'>SearchSysCacheExists1</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/syscache.h.html#LN54"><span class='Ref_to_EnumConst'>DATABASEOID</span></a><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="varsup.c.html#LN433"><span class='Ref_To_Local'>oldestXidDB</span></a><span class='Parentheses'>)))</span> 
        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* could happen, per comments above */ 
</span>    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ForceTransactionIdLimitUpdate &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * GetNewObjectId -- allocate a new OID 
 * 
 * OIDs are generated by a cluster-wide counter.  Since they are only 32 bits 
 * wide, counter wraparound will occur eventually, and therefore it is unwise 
 * to assume they are unique unless precautions are taken to make them so. 
 * Hence, this routine should generally not be used directly.  The only 
 * direct callers should be GetNewOid() and GetNewRelFileNode() in 
 * catalog/catalog.c. 
 */ 
</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> 
<a name="LN466"></a><span class='Declare_Function'>GetNewObjectId</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN468"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* safety check, we should never get this far in a HS slave */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN242"><span class='Ref_to_Proto'>RecoveryInProgress</span></a><span class='Parentheses'>())</span> 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cannot assign OIDs during recovery"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>OidGenLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Check for wraparound of the OID counter.  We *must* not return 0 
     * (InvalidOid); and as long as we have to check that, it seems a good 
     * idea to skip over everything below FirstNormalObjectId too. (This 
     * basically just avoids lots of collisions with bootstrap-assigned OIDs 
     * right after a wrap occurs, so as to avoid a possibly large number of 
     * iterations in GetNewOid.)  Note we are relying on unsigned comparison. 
     * 
     * During initdb, we start the OID generator at FirstBootstrapObjectId, so 
     * we only wrap if before that point when in bootstrap or standalone mode. 
     * The first time through this routine after normal postmaster start, the 
     * counter will be forced up to FirstNormalObjectId.  This mechanism 
     * leaves the OIDs between FirstBootstrapObjectId and FirstNormalObjectId 
     * available for automatic assignment during initdb, while ensuring they 
     * will never conflict with user-assigned OIDs. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN110"><span class='Ref_to_Member'>nextOid</span></a> <span class='Operator'>&LT; </span><span class='Parentheses'>((</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a><span class='Parentheses'>) </span><a href="../../../include/access/transam.h.html#LN93"><span class='Ref_to_Const'>FirstNormalObjectId</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../utils/init/globals.c.html#LN99"><span class='Ref_to_Global_Var'>IsPostmasterEnvironment</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* wraparound, or first post-initdb assignment, in normal mode */ 
</span>            <a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN110"><span class='Ref_to_Member'>nextOid</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN93"><span class='Ref_to_Const'>FirstNormalObjectId</span></a><span class='Delimiter'>; 
</span>            <a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN111"><span class='Ref_to_Member'>oidCount</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* we may be bootstrapping, so don't enforce the full range */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN110"><span class='Ref_to_Member'>nextOid</span></a> <span class='Operator'>&LT; </span><span class='Parentheses'>((</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a><span class='Parentheses'>) </span><a href="../../../include/access/transam.h.html#LN92"><span class='Ref_to_Const'>FirstBootstrapObjectId</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* wraparound in standalone mode (unlikely but possible) */ 
</span>                <a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN110"><span class='Ref_to_Member'>nextOid</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN93"><span class='Ref_to_Const'>FirstNormalObjectId</span></a><span class='Delimiter'>; 
</span>                <a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN111"><span class='Ref_to_Member'>oidCount</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* If we run out of logged for use oids then we must log more */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN111"><span class='Ref_to_Member'>oidCount</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/access/xlog.h.html#LN269"><span class='Ref_to_Proto'>XLogPutNextOid</span></a><span class='Parentheses'>(</span><a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN110"><span class='Ref_to_Member'>nextOid</span></a> <span class='Operator'>+ </span><a href="varsup.c.html#LN30"><span class='Ref_to_Const'>VAR_OID_PREFETCH</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN111"><span class='Ref_to_Member'>oidCount</span></a> <span class='Operator'>= </span><a href="varsup.c.html#LN30"><span class='Ref_to_Const'>VAR_OID_PREFETCH</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="varsup.c.html#LN468"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN110"><span class='Ref_to_Member'>nextOid</span></a><span class='Delimiter'>; 
</span> 
    <span class='Parentheses'>(</span><a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN110"><span class='Ref_to_Member'>nextOid</span></a><span class='Parentheses'>)</span><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Parentheses'>(</span><a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN111"><span class='Ref_to_Member'>oidCount</span></a><span class='Parentheses'>)</span><span class='Operator'>--</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>OidGenLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="varsup.c.html#LN468"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end GetNewObjectId &raquo; </span> 
</pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>