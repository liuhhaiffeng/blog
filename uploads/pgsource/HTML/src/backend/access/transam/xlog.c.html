<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\access\transam\xlog.c</title>
<LINK REL=StyleSheet HREF="../../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\access\transam\xlog.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:31 2017
</td></tr>
<tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * xlog.c 
 *      PostgreSQL write-ahead log manager 
 * 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * src/backend/access/transam/xlog.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span> 
<span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>&LT;ctype.h&GT;</span> 
<span class='Keyword'>#include </span><span class='String'>&LT;math.h&GT;</span> 
<span class='Keyword'>#include </span><span class='String'>&LT;time.h&GT;</span> 
<span class='Keyword'>#include </span><span class='String'>&LT;fcntl.h&GT;</span> 
<span class='Keyword'>#include </span><span class='String'>&LT;sys/stat.h&GT;</span> 
<span class='Keyword'>#include </span><span class='String'>&LT;sys/time.h&GT;</span> 
<span class='Keyword'>#include </span><span class='String'>&LT;unistd.h&GT;</span> 
 
<span class='Keyword'>#include </span><span class='String'>"access/clog.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/commit_ts.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/multixact.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/rewriteheap.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/subtrans.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/timeline.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/transam.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/tuptoaster.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/twophase.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/xact.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/xlog_internal.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/xloginsert.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/xlogreader.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/xlogutils.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/catversion.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_control.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_database.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"commands/tablespace.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"miscadmin.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"pgstat.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"port/atomics.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"postmaster/bgwriter.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"postmaster/walwriter.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"postmaster/startup.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"replication/basebackup.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"replication/logical.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"replication/slot.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"replication/origin.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"replication/snapbuild.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"replication/walreceiver.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"replication/walsender.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/bufmgr.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/fd.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/ipc.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/large_object.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/latch.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/pmsignal.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/predicate.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/proc.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/procarray.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/reinit.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/smgr.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/spin.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/backend_random.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/builtins.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/guc.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/memutils.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/pg_lsn.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/ps_status.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/relmapper.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/snapmgr.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/timestamp.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"pg_trace.h"</span> 
 
<a name="LN78"></a><span class='Keyword'>extern </span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Declare_Var'>bootstrap_data_checksum_version</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* File path names (all relative to $PGDATA) */ 
</span><a name="LN81"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>RECOVERY_COMMAND_FILE</span>   <span class='String'>"recovery.conf"</span> 
<a name="LN82"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>RECOVERY_COMMAND_DONE</span>   <span class='String'>"recovery.done"</span> 
<a name="LN83"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>PROMOTE_SIGNAL_FILE</span>     <span class='String'>"promote"</span> 
<a name="LN84"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>FALLBACK_PROMOTE_SIGNAL_FILE</span> <span class='String'>"fallback_promote"</span> 
 
 
<span class='Comment_Multi_Line'>/* User-settable parameters */ 
</span><a name="LN88"></a><span class='Keyword'>int</span>         <span class='Declare_Var'>max_wal_size_mb</span> <span class='Operator'>= </span><span class='Number'>1024</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* 1 GB */ 
</span><a name="LN89"></a><span class='Keyword'>int</span>         <span class='Declare_Var'>min_wal_size_mb</span> <span class='Operator'>= </span><span class='Number'>80</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* 80 MB */ 
</span><a name="LN90"></a><span class='Keyword'>int</span>         <span class='Declare_Var'>wal_keep_segments</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN91"></a><span class='Keyword'>int</span>         <span class='Declare_Var'>XLOGbuffers</span> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span><a name="LN92"></a><span class='Keyword'>int</span>         <span class='Declare_Var'>XLogArchiveTimeout</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN93"></a><span class='Keyword'>int</span>         <span class='Declare_Var'>XLogArchiveMode</span> <span class='Operator'>= </span><a href="../../../include/access/xlog.h.html#LN116"><span class='Ref_to_EnumConst'>ARCHIVE_MODE_OFF</span></a><span class='Delimiter'>; 
</span><a name="LN94"></a><span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Var'>XLogArchiveCommand</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN95"></a><span class='Keyword'>bool</span>        <span class='Declare_Var'>EnableHotStandby</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN96"></a><span class='Keyword'>bool</span>        <span class='Declare_Var'>fullPageWrites</span> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span><a name="LN97"></a><span class='Keyword'>bool</span>        <span class='Declare_Var'>wal_log_hints</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN98"></a><span class='Keyword'>bool</span>        <span class='Declare_Var'>wal_compression</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN99"></a><span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Var'>wal_consistency_checking_string</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN100"></a><span class='Keyword'>bool</span>       <span class='Operator'>*</span><span class='Declare_Var'>wal_consistency_checking</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN101"></a><span class='Keyword'>bool</span>        <span class='Declare_Var'>log_checkpoints</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN102"></a><span class='Keyword'>int</span>         <span class='Declare_Var'>sync_method</span> <span class='Operator'>= </span><a href="../../../include/access/xlogdefs.h.html#LN92"><span class='Ref_to_Const'>DEFAULT_SYNC_METHOD</span></a><span class='Delimiter'>; 
</span><a name="LN103"></a><span class='Keyword'>int</span>         <span class='Declare_Var'>wal_level</span> <span class='Operator'>= </span><a href="../../../include/access/xlog.h.html#LN125"><span class='Ref_to_EnumConst'>WAL_LEVEL_MINIMAL</span></a><span class='Delimiter'>; 
</span><a name="LN104"></a><span class='Keyword'>int</span>         <span class='Declare_Var'>CommitDelay</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* precommit delay in microseconds */ 
</span><a name="LN105"></a><span class='Keyword'>int</span>         <span class='Declare_Var'>CommitSiblings</span> <span class='Operator'>= </span><span class='Number'>5</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* # concurrent xacts needed to sleep */ 
</span><a name="LN106"></a><span class='Keyword'>int</span>         <span class='Declare_Var'>wal_retrieve_retry_interval</span> <span class='Operator'>= </span><span class='Number'>5000</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifdef</span> WAL_DEBUG 
<a name="LN109"></a><span class='Keyword'>bool</span>        <span class='Declare_Var'>XLOG_DEBUG</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Number of WAL insertion locks to use. A higher value allows more insertions 
 * to happen concurrently, but adds some CPU overhead to flushing the WAL, 
 * which needs to iterate all the locks. 
 */ 
</span><a name="LN117"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>NUM_XLOGINSERT_LOCKS</span>  <span class='Number'>8</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Max distance from last checkpoint, before triggering a new xlog-based 
 * checkpoint. 
 */ 
</span><a name="LN123"></a><span class='Keyword'>int</span>         <span class='Declare_Var'>CheckPointSegments</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* Estimated distance between checkpoints, in bytes */ 
</span><a name="LN126"></a><span class='Keyword'>static double </span><span class='Declare_Var'>CheckPointDistanceEstimate</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN127"></a><span class='Keyword'>static double </span><span class='Declare_Var'>PrevCheckPointDistance</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * GUC support 
 */ 
</span><a name="LN132"></a><span class='Keyword'>const </span><span class='Control'>struct</span> <a href="../../../include/utils/guc.h.html#LN163"><span class='Ref_to_Struct'>config_enum_entry</span></a> <span class='Declare_Var'>sync_method_options</span><span class='Delimiter'>[] </span><span class='Operator'>= </span><span class='Delimiter'>{ 
</span>    <span class='Delimiter'>{</span><span class='String'>"fsync"</span><span class='Delimiter'>, </span><a href="../../../include/access/xlog.h.html#LN24"><span class='Ref_to_Const'>SYNC_METHOD_FSYNC</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>}, 
</span><span class='Directive'>#ifdef</span> <a href="../../../include/port/darwin.h.html#LN5"><span class='Ref_to_Const'>HAVE_FSYNC_WRITETHROUGH</span></a> 
    <span class='Delimiter'>{</span><span class='String'>"fsync_writethrough"</span><span class='Delimiter'>, </span><a href="../../../include/access/xlog.h.html#LN27"><span class='Ref_to_Const'>SYNC_METHOD_FSYNC_WRITETHROUGH</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>}, 
</span><span class='Directive'>#endif</span> 
<span class='Directive'>#ifdef</span> HAVE_FDATASYNC 
    <span class='Delimiter'>{</span><span class='String'>"fdatasync"</span><span class='Delimiter'>, </span><a href="../../../include/access/xlog.h.html#LN25"><span class='Ref_to_Const'>SYNC_METHOD_FDATASYNC</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>}, 
</span><span class='Directive'>#endif</span> 
<span class='Directive'>#ifdef</span> <a href="../../../include/access/xlogdefs.h.html#LN74"><span class='Ref_to_Const'>OPEN_SYNC_FLAG</span></a> 
    <span class='Delimiter'>{</span><span class='String'>"open_sync"</span><span class='Delimiter'>, </span><a href="../../../include/access/xlog.h.html#LN26"><span class='Ref_to_Const'>SYNC_METHOD_OPEN</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>}, 
</span><span class='Directive'>#endif</span> 
<span class='Directive'>#ifdef</span> <a href="../../../include/access/xlogdefs.h.html#LN83"><span class='Ref_to_Const'>OPEN_DATASYNC_FLAG</span></a> 
    <span class='Delimiter'>{</span><span class='String'>"open_datasync"</span><span class='Delimiter'>, </span><a href="../../../include/access/xlog.h.html#LN28"><span class='Ref_to_Const'>SYNC_METHOD_OPEN_DSYNC</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>}, 
</span><span class='Directive'>#endif</span> 
    <span class='Delimiter'>{</span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>} 
}; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Although only "on", "off", and "always" are documented, 
 * we accept all the likely variants of "on" and "off". 
 */ 
</span><a name="LN154"></a><span class='Keyword'>const </span><span class='Control'>struct</span> <a href="../../../include/utils/guc.h.html#LN163"><span class='Ref_to_Struct'>config_enum_entry</span></a> <span class='Declare_Var'>archive_mode_options</span><span class='Delimiter'>[] </span><span class='Operator'>= </span><span class='Delimiter'>{ 
</span>    <span class='Delimiter'>{</span><span class='String'>"always"</span><span class='Delimiter'>, </span><a href="../../../include/access/xlog.h.html#LN118"><span class='Ref_to_EnumConst'>ARCHIVE_MODE_ALWAYS</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>}, 
</span>    <span class='Delimiter'>{</span><span class='String'>"on"</span><span class='Delimiter'>, </span><a href="../../../include/access/xlog.h.html#LN117"><span class='Ref_to_EnumConst'>ARCHIVE_MODE_ON</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>}, 
</span>    <span class='Delimiter'>{</span><span class='String'>"off"</span><span class='Delimiter'>, </span><a href="../../../include/access/xlog.h.html#LN116"><span class='Ref_to_EnumConst'>ARCHIVE_MODE_OFF</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>}, 
</span>    <span class='Delimiter'>{</span><span class='String'>"true"</span><span class='Delimiter'>, </span><a href="../../../include/access/xlog.h.html#LN117"><span class='Ref_to_EnumConst'>ARCHIVE_MODE_ON</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>}, 
</span>    <span class='Delimiter'>{</span><span class='String'>"false"</span><span class='Delimiter'>, </span><a href="../../../include/access/xlog.h.html#LN116"><span class='Ref_to_EnumConst'>ARCHIVE_MODE_OFF</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>}, 
</span>    <span class='Delimiter'>{</span><span class='String'>"yes"</span><span class='Delimiter'>, </span><a href="../../../include/access/xlog.h.html#LN117"><span class='Ref_to_EnumConst'>ARCHIVE_MODE_ON</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>}, 
</span>    <span class='Delimiter'>{</span><span class='String'>"no"</span><span class='Delimiter'>, </span><a href="../../../include/access/xlog.h.html#LN116"><span class='Ref_to_EnumConst'>ARCHIVE_MODE_OFF</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>}, 
</span>    <span class='Delimiter'>{</span><span class='String'>"1"</span><span class='Delimiter'>, </span><a href="../../../include/access/xlog.h.html#LN117"><span class='Ref_to_EnumConst'>ARCHIVE_MODE_ON</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>}, 
</span>    <span class='Delimiter'>{</span><span class='String'>"0"</span><span class='Delimiter'>, </span><a href="../../../include/access/xlog.h.html#LN116"><span class='Ref_to_EnumConst'>ARCHIVE_MODE_OFF</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>}, 
</span>    <span class='Delimiter'>{</span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>} 
}; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Statistics for current checkpoint are collected in this global struct. 
 * Because only the checkpointer or a stand-alone backend can perform 
 * checkpoints, this will be unused in normal backends. 
 */ 
</span><a name="LN172"></a><a href="../../../include/access/xlog.h.html#LN196"><span class='Ref_to_Struct'>CheckpointStatsData</span></a> <span class='Declare_Var'>CheckpointStats</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * ThisTimeLineID will be same in all backends --- it identifies current 
 * WAL timeline for the database system. 
 */ 
</span><a name="LN178"></a><a href="../../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a>  <span class='Declare_Var'>ThisTimeLineID</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Are we doing recovery from XLOG? 
 * 
 * This is only ever true in the startup process; it should be read as meaning 
 * "this process is replaying WAL records", rather than "the system is in 
 * recovery mode".  It should be examined primarily by functions that need 
 * to act differently when called from a WAL redo function (e.g., to skip WAL 
 * logging).  To check whether the system is in recovery regardless of which 
 * process you're running in, use RecoveryInProgress() but only after shared 
 * memory startup and lock initialization. 
 */ 
</span><a name="LN191"></a><span class='Keyword'>bool</span>        <span class='Declare_Var'>InRecovery</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* Are we in Hot Standby mode? Only valid in startup process, see xlog.h */ 
</span><a name="LN194"></a><a href="../../../include/access/xlog.h.html#LN63"><span class='Ref_to_Typedef'>HotStandbyState</span></a> <span class='Declare_Var'>standbyState</span> <span class='Operator'>= </span><a href="../../../include/access/xlog.h.html#LN65"><span class='Ref_to_EnumConst'>STANDBY_DISABLED</span></a><span class='Delimiter'>; 
</span> 
<a name="LN196"></a><span class='Keyword'>static </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Var'>LastRec</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* Local copy of WalRcv-&GT;receivedUpto */ 
</span><a name="LN199"></a><span class='Keyword'>static </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Var'>receivedUpto</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN200"></a><span class='Keyword'>static </span><a href="../../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a> <span class='Declare_Var'>receiveTLI</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * During recovery, lastFullPageWrites keeps track of full_page_writes that 
 * the replayed WAL records indicate. It's initialized with full_page_writes 
 * that the recovery starting checkpoint record indicates, and then updated 
 * each time XLOG_FPW_CHANGE record is replayed. 
 */ 
</span><a name="LN208"></a><span class='Keyword'>static bool </span><span class='Declare_Var'>lastFullPageWrites</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Local copy of SharedRecoveryInProgress variable. True actually means "not 
 * known, need to check the shared state". 
 */ 
</span><a name="LN214"></a><span class='Keyword'>static bool </span><span class='Declare_Var'>LocalRecoveryInProgress</span> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Local copy of SharedHotStandbyActive variable. False actually means "not 
 * known, need to check the shared state". 
 */ 
</span><a name="LN220"></a><span class='Keyword'>static bool </span><span class='Declare_Var'>LocalHotStandbyActive</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Local state for XLogInsertAllowed(): 
 *      1: unconditionally allowed to insert XLOG 
 *      0: unconditionally not allowed to insert XLOG 
 *      -1: must check RecoveryInProgress(); disallow until it is false 
 * Most processes start with -1 and transition to 1 after seeing that recovery 
 * is not in progress.  But we can also force the value for special cases. 
 * The coding in XLogInsertAllowed() depends on the first two of these states 
 * being numerically the same as bool true and false. 
 */ 
</span><a name="LN232"></a><span class='Keyword'>static int</span>  <span class='Declare_Var'>LocalXLogInsertAllowed</span> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * When ArchiveRecoveryRequested is set, archive recovery was requested, 
 * ie. recovery.conf file was present. When InArchiveRecovery is set, we are 
 * currently recovering using offline XLOG archives. These variables are only 
 * valid in the startup process. 
 * 
 * When ArchiveRecoveryRequested is true, but InArchiveRecovery is false, we're 
 * currently performing crash recovery using only XLOG files in pg_wal, but 
 * will switch to using offline XLOG archives as soon as we reach the end of 
 * WAL in pg_wal. 
*/ 
</span><a name="LN245"></a><span class='Keyword'>bool</span>        <span class='Declare_Var'>ArchiveRecoveryRequested</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN246"></a><span class='Keyword'>bool</span>        <span class='Declare_Var'>InArchiveRecovery</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* Was the last xlog file restored from archive, or local? */ 
</span><a name="LN249"></a><span class='Keyword'>static bool </span><span class='Declare_Var'>restoredFromArchive</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* Buffers dedicated to consistency checks of size BLCKSZ */ 
</span><a name="LN252"></a><span class='Keyword'>static char </span><span class='Operator'>*</span><span class='Declare_Var'>replay_image_masked</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN253"></a><span class='Keyword'>static char </span><span class='Operator'>*</span><span class='Declare_Var'>master_image_masked</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* options taken from recovery.conf for archive recovery */ 
</span><a name="LN256"></a><span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Var'>recoveryRestoreCommand</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN257"></a><span class='Keyword'>static char </span><span class='Operator'>*</span><span class='Declare_Var'>recoveryEndCommand</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN258"></a><span class='Keyword'>static char </span><span class='Operator'>*</span><span class='Declare_Var'>archiveCleanupCommand</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN259"></a><span class='Keyword'>static </span><a href="../../../include/access/xlog.h.html#LN79"><span class='Ref_to_Typedef'>RecoveryTargetType</span></a> <span class='Declare_Var'>recoveryTarget</span> <span class='Operator'>= </span><a href="../../../include/access/xlog.h.html#LN81"><span class='Ref_to_EnumConst'>RECOVERY_TARGET_UNSET</span></a><span class='Delimiter'>; 
</span><a name="LN260"></a><span class='Keyword'>static bool </span><span class='Declare_Var'>recoveryTargetInclusive</span> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span><a name="LN261"></a><span class='Keyword'>static </span><a href="../../../include/access/xlog_internal.h.html#LN250"><span class='Ref_to_Typedef'>RecoveryTargetAction</span></a> <span class='Declare_Var'>recoveryTargetAction</span> <span class='Operator'>= </span><a href="../../../include/access/xlog_internal.h.html#LN252"><span class='Ref_to_EnumConst'>RECOVERY_TARGET_ACTION_PAUSE</span></a><span class='Delimiter'>; 
</span><a name="LN262"></a><span class='Keyword'>static </span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Var'>recoveryTargetXid</span><span class='Delimiter'>; 
</span><a name="LN263"></a><span class='Keyword'>static </span><a href="../../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <span class='Declare_Var'>recoveryTargetTime</span><span class='Delimiter'>; 
</span><a name="LN264"></a><span class='Keyword'>static char </span><span class='Operator'>*</span><span class='Declare_Var'>recoveryTargetName</span><span class='Delimiter'>; 
</span><a name="LN265"></a><span class='Keyword'>static </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Var'>recoveryTargetLSN</span><span class='Delimiter'>; 
</span><a name="LN266"></a><span class='Keyword'>static int</span>  <span class='Declare_Var'>recovery_min_apply_delay</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN267"></a><span class='Keyword'>static </span><a href="../../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <span class='Declare_Var'>recoveryDelayUntilTime</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* options taken from recovery.conf for XLOG streaming */ 
</span><a name="LN270"></a><span class='Keyword'>static bool </span><span class='Declare_Var'>StandbyModeRequested</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN271"></a><span class='Keyword'>static char </span><span class='Operator'>*</span><span class='Declare_Var'>PrimaryConnInfo</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN272"></a><span class='Keyword'>static char </span><span class='Operator'>*</span><span class='Declare_Var'>PrimarySlotName</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN273"></a><span class='Keyword'>static char </span><span class='Operator'>*</span><span class='Declare_Var'>TriggerFile</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* are we currently in standby mode? */ 
</span><a name="LN276"></a><span class='Keyword'>bool</span>        <span class='Declare_Var'>StandbyMode</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* whether request for fast promotion has been made yet */ 
</span><a name="LN279"></a><span class='Keyword'>static bool </span><span class='Declare_Var'>fast_promote</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * if recoveryStopsBefore/After returns true, it saves information of the stop 
 * point here 
 */ 
</span><a name="LN285"></a><span class='Keyword'>static </span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Var'>recoveryStopXid</span><span class='Delimiter'>; 
</span><a name="LN286"></a><span class='Keyword'>static </span><a href="../../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <span class='Declare_Var'>recoveryStopTime</span><span class='Delimiter'>; 
</span><a name="LN287"></a><span class='Keyword'>static </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Var'>recoveryStopLSN</span><span class='Delimiter'>; 
</span><a name="LN288"></a><span class='Keyword'>static char </span><span class='Declare_Var'>recoveryStopName</span><span class='Delimiter'>[</span><a href="../../../include/access/xlog_internal.h.html#LN137"><span class='Ref_to_Const'>MAXFNAMELEN</span></a><span class='Delimiter'>]; 
</span><a name="LN289"></a><span class='Keyword'>static bool </span><span class='Declare_Var'>recoveryStopAfter</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * During normal operation, the only timeline we care about is ThisTimeLineID. 
 * During recovery, however, things are more complicated.  To simplify life 
 * for rmgr code, we keep ThisTimeLineID set to the "current" timeline as we 
 * scan through the WAL history (that is, it is the line that was active when 
 * the currently-scanned WAL record was generated).  We also need these 
 * timeline values: 
 * 
 * recoveryTargetTLI: the desired timeline that we want to end in. 
 * 
 * recoveryTargetIsLatest: was the requested target timeline 'latest'? 
 * 
 * expectedTLEs: a list of TimeLineHistoryEntries for recoveryTargetTLI and the timelines of 
 * its known parents, newest first (so recoveryTargetTLI is always the 
 * first list member).  Only these TLIs are expected to be seen in the WAL 
 * segments we read, and indeed only these TLIs will be considered as 
 * candidate WAL files to open at all. 
 * 
 * curFileTLI: the TLI appearing in the name of the current input WAL file. 
 * (This is not necessarily the same as ThisTimeLineID, because we could 
 * be scanning data that was copied from an ancestor timeline when the current 
 * file was created.)  During a sequential scan we do not allow this value 
 * to decrease. 
 */ 
</span><a name="LN315"></a><span class='Keyword'>static </span><a href="../../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a> <span class='Declare_Var'>recoveryTargetTLI</span><span class='Delimiter'>; 
</span><a name="LN316"></a><span class='Keyword'>static bool </span><span class='Declare_Var'>recoveryTargetIsLatest</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN317"></a><span class='Keyword'>static </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Var'>expectedTLEs</span><span class='Delimiter'>; 
</span><a name="LN318"></a><span class='Keyword'>static </span><a href="../../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a> <span class='Declare_Var'>curFileTLI</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * ProcLastRecPtr points to the start of the last XLOG record inserted by the 
 * current backend.  It is updated for all inserts.  XactLastRecEnd points to 
 * end+1 of the last record, and is reset when we end a top-level transaction, 
 * or start a new one; so it can be used to tell if the current transaction has 
 * created any XLOG records. 
 * 
 * While in parallel mode, this may not be fully up to date.  When committing, 
 * a transaction can assume this covers all xlog records written either by the 
 * user backend or by any parallel worker which was present at any point during 
 * the transaction.  But when aborting, or when still in parallel mode, other 
 * parallel backends may have written WAL records at later LSNs than the value 
 * stored here.  The parallel leader advances its own copy, when necessary, 
 * in WaitForParallelWorkersToFinish. 
 */ 
</span><a name="LN335"></a><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Var'>ProcLastRecPtr</span> <span class='Operator'>= </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>; 
</span><a name="LN336"></a><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Var'>XactLastRecEnd</span> <span class='Operator'>= </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>; 
</span><a name="LN337"></a><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Var'>XactLastCommitEnd</span> <span class='Operator'>= </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * RedoRecPtr is this backend's local copy of the REDO record pointer 
 * (which is almost but not quite the same as a pointer to the most recent 
 * CHECKPOINT record).  We update this from the shared-memory copy, 
 * XLogCtl-&GT;Insert.RedoRecPtr, whenever we can safely do so (ie, when we 
 * hold an insertion lock).  See XLogInsertRecord for details.  We are also 
 * allowed to update from XLogCtl-&GT;RedoRecPtr if we hold the info_lck; 
 * see GetRedoRecPtr.  A freshly spawned backend obtains the value during 
 * InitXLOGAccess. 
 */ 
</span><a name="LN349"></a><span class='Keyword'>static </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Var'>RedoRecPtr</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * doPageWrites is this backend's local copy of (forcePageWrites || 
 * fullPageWrites).  It is used together with RedoRecPtr to decide whether 
 * a full-page image of a page need to be taken. 
 */ 
</span><a name="LN356"></a><span class='Keyword'>static bool </span><span class='Declare_Var'>doPageWrites</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* Has the recovery code requested a walreceiver wakeup? */ 
</span><a name="LN359"></a><span class='Keyword'>static bool </span><span class='Declare_Var'>doRequestWalReceiverReply</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * RedoStartLSN points to the checkpoint's REDO location which is specified 
 * in a backup label file, backup history file or control file. In standby 
 * mode, XLOG streaming usually starts from the position where an invalid 
 * record was found. But if we fail to read even the initial checkpoint 
 * record, we use the REDO location instead of the checkpoint location as 
 * the start position of XLOG streaming. Otherwise we would have to jump 
 * backwards to the REDO location after reading the checkpoint record, 
 * because the REDO record can precede the checkpoint record. 
 */ 
</span><a name="LN371"></a><span class='Keyword'>static </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Var'>RedoStartLSN</span> <span class='Operator'>= </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/*---------- 
 * Shared-memory data structures for XLOG control 
 * 
 * LogwrtRqst indicates a byte position that we need to write and/or fsync 
 * the log up to (all records before that point must be written or fsynced). 
 * LogwrtResult indicates the byte positions we have already written/fsynced. 
 * These structs are identical but are declared separately to indicate their 
 * slightly different functions. 
 * 
 * To read XLogCtl-&GT;LogwrtResult, you must hold either info_lck or 
 * WALWriteLock.  To update it, you need to hold both locks.  The point of 
 * this arrangement is that the value can be examined by code that already 
 * holds WALWriteLock without needing to grab info_lck as well.  In addition 
 * to the shared variable, each backend has a private copy of LogwrtResult, 
 * which is updated when convenient. 
 * 
 * The request bookkeeping is simpler: there is a shared XLogCtl-&GT;LogwrtRqst 
 * (protected by info_lck), but we don't need to cache any copies of it. 
 * 
 * info_lck is only held long enough to read/update the protected variables, 
 * so it's a plain spinlock.  The other locks are held longer (potentially 
 * over I/O operations), so we use LWLocks for them.  These locks are: 
 * 
 * WALBufMappingLock: must be held to replace a page in the WAL buffer cache. 
 * It is only held while initializing and changing the mapping.  If the 
 * contents of the buffer being replaced haven't been written yet, the mapping 
 * lock is released while the write is done, and reacquired afterwards. 
 * 
 * WALWriteLock: must be held to write WAL buffers to disk (XLogWrite or 
 * XLogFlush). 
 * 
 * ControlFileLock: must be held to read/update control file or create 
 * new log file. 
 * 
 * CheckpointLock: must be held to do a checkpoint or restartpoint (ensures 
 * only one checkpointer at a time; currently, with all checkpoints done by 
 * the checkpointer, this is just pro forma). 
 * 
 *---------- 
 */ 
</span> 
<a name="LN414"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>XLogwrtRqst</span> 
<span class='Delimiter'>{ 
</span><a name="LN416"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Member'>Write</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* last byte + 1 to write out */ 
</span><a name="LN417"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Member'>Flush</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* last byte + 1 to flush */ 
</span><a name="LN418"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>XLogwrtRqst</span><span class='Delimiter'>; 
</span> 
<a name="LN420"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>XLogwrtResult</span> 
<span class='Delimiter'>{ 
</span><a name="LN422"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Member'>Write</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* last byte + 1 written out */ 
</span><a name="LN423"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Member'>Flush</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* last byte + 1 flushed */ 
</span><a name="LN424"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>XLogwrtResult</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Inserting to WAL is protected by a small fixed number of WAL insertion 
 * locks. To insert to the WAL, you must hold one of the locks - it doesn't 
 * matter which one. To lock out other concurrent insertions, you must hold 
 * of them. Each WAL insertion lock consists of a lightweight lock, plus an 
 * indicator of how far the insertion has progressed (insertingAt). 
 * 
 * The insertingAt values are read when a process wants to flush WAL from 
 * the in-memory buffers to disk, to check that all the insertions to the 
 * region the process is about to write out have finished. You could simply 
 * wait for all currently in-progress insertions to finish, but the 
 * insertingAt indicator allows you to ignore insertions to later in the WAL, 
 * so that you only wait for the insertions that are modifying the buffers 
 * you're about to write out. 
 * 
 * This isn't just an optimization. If all the WAL buffers are dirty, an 
 * inserter that's holding a WAL insert lock might need to evict an old WAL 
 * buffer, which requires flushing the WAL. If it's possible for an inserter 
 * to block on another inserter unnecessarily, deadlock can arise when two 
 * inserters holding a WAL insert lock wait for each other to finish their 
 * insertion. 
 * 
 * Small WAL records that don't cross a page boundary never update the value, 
 * the WAL record is just copied to the page and the lock is released. But 
 * to avoid the deadlock-scenario explained above, the indicator is always 
 * updated before sleeping while holding an insertion lock. 
 * 
 * lastImportantAt contains the LSN of the last important WAL record inserted 
 * using a given lock. This value is used to detect if there has been 
 * important WAL activity since the last time some action, like a checkpoint, 
 * was performed - allowing to not repeat the action if not. The LSN is 
 * updated for all insertions, unless the XLOG_MARK_UNIMPORTANT flag was 
 * set. lastImportantAt is never cleared, only overwritten by the LSN of newer 
 * records.  Tracking the WAL activity directly in WALInsertLock has the 
 * advantage of not needing any additional locks to update the value. 
 */ 
</span><span class='Control'>typedef</span> <span class='Control'>struct</span> 
<span class='Delimiter'>{ 
</span><a name="LN464"></a>    <a href="../../../include/storage/lwlock.h.html#LN31"><span class='Ref_to_Struct'>LWLock</span></a>      <span class='Declare_Member'>lock</span><span class='Delimiter'>; 
</span><a name="LN465"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Member'>insertingAt</span><span class='Delimiter'>; 
</span><a name="LN466"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Member'>lastImportantAt</span><span class='Delimiter'>; 
</span><a name="LN467"></a>} <span class='Declare_Typedef'>WALInsertLock</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * All the WAL insertion locks are allocated as an array in shared memory. We 
 * force the array stride to be a power of 2, which saves a few cycles in 
 * indexing, but more importantly also ensures that individual slots don't 
 * cross cache line boundaries. (Of course, we have to also ensure that the 
 * array start address is suitably aligned.) 
 */ 
</span><a name="LN476"></a><span class='Control'>typedef</span> <span class='Control'>union</span> <span class='Declare_Union'>WALInsertLockPadded</span> 
<span class='Delimiter'>{ 
</span><a name="LN478"></a>    <a href="xlog.c.html#LN462"><span class='Ref_to_Typedef'>WALInsertLock</span></a> <span class='Declare_Member'>l</span><span class='Delimiter'>; 
</span><a name="LN479"></a>    <span class='Keyword'>char</span>        <span class='Declare_Member'>pad</span><span class='Delimiter'>[</span><a href="../../../include/pg_config_manual.h.html#LN236"><span class='Ref_to_Const'>PG_CACHE_LINE_SIZE</span></a><span class='Delimiter'>]; 
</span><a name="LN480"></a>} <span class='Declare_Typedef'>WALInsertLockPadded</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * State of an exclusive backup, necessary to control concurrent activities 
 * across sessions when working on exclusive backups. 
 * 
 * EXCLUSIVE_BACKUP_NONE means that there is no exclusive backup actually 
 * running, to be more precise pg_start_backup() is not being executed for 
 * an exclusive backup and there is no exclusive backup in progress. 
 * EXCLUSIVE_BACKUP_STARTING means that pg_start_backup() is starting an 
 * exclusive backup. 
 * EXCLUSIVE_BACKUP_IN_PROGRESS means that pg_start_backup() has finished 
 * running and an exclusive backup is in progress. pg_stop_backup() is 
 * needed to finish it. 
 * EXCLUSIVE_BACKUP_STOPPING means that pg_stop_backup() is stopping an 
 * exclusive backup. 
 */ 
</span><a name="LN497"></a><span class='Control'>typedef</span> <span class='Control'>enum</span> <span class='Declare_Enum'>ExclusiveBackupState</span> 
<span class='Delimiter'>{ 
</span><a name="LN499"></a>    <span class='Declare_Enum_Const'>EXCLUSIVE_BACKUP_NONE</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>, 
</span><a name="LN500"></a>    <span class='Declare_Enum_Const'>EXCLUSIVE_BACKUP_STARTING</span><span class='Delimiter'>, 
</span><a name="LN501"></a>    <span class='Declare_Enum_Const'>EXCLUSIVE_BACKUP_IN_PROGRESS</span><span class='Delimiter'>, 
</span><a name="LN502"></a>    <span class='Declare_Enum_Const'>EXCLUSIVE_BACKUP_STOPPING</span> 
<a name="LN503"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>ExclusiveBackupState</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Session status of running backup, used for sanity checks in SQL-callable 
 * functions to start and stop backups. 
 */ 
</span><a name="LN509"></a><span class='Keyword'>static </span><a href="../../../include/access/xlog.h.html#LN303"><span class='Ref_to_Enum'>SessionBackupState</span></a> <span class='Declare_Var'>sessionBackupState</span> <span class='Operator'>= </span><a href="../../../include/access/xlog.h.html#LN305"><span class='Ref_to_EnumConst'>SESSION_BACKUP_NONE</span></a><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Shared state data for WAL insertion. 
 */ 
</span><a name="LN514"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>XLogCtlInsert</span> 
<span class='Delimiter'>{ 
</span><a name="LN516"></a>    <a href="../../../include/storage/s_lock.h.html#LN137"><span class='Ref_to_Typedef'>slock_t</span></a>     <span class='Declare_Member'>insertpos_lck</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* protects CurrBytePos and PrevBytePos */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * CurrBytePos is the end of reserved WAL. The next record will be 
     * inserted at that position. PrevBytePos is the start position of the 
     * previously inserted (or rather, reserved) record - it is copied to the 
     * prev-link of the next record. These are stored as "usable byte 
     * positions" rather than XLogRecPtrs (see XLogBytePosToRecPtr()). 
     */ 
</span><a name="LN525"></a>    <a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a>      <span class='Declare_Member'>CurrBytePos</span><span class='Delimiter'>; 
</span><a name="LN526"></a>    <a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a>      <span class='Declare_Member'>PrevBytePos</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Make sure the above heavily-contended spinlock and byte positions are 
     * on their own cache line. In particular, the RedoRecPtr and full page 
     * write variables below should be on a different cache line. They are 
     * read on every WAL insertion, but updated rarely, and we don't want 
     * those reads to steal the cache line containing Curr/PrevBytePos. 
     */ 
</span><a name="LN535"></a>    <span class='Keyword'>char</span>        <span class='Declare_Member'>pad</span><span class='Delimiter'>[</span><a href="../../../include/pg_config_manual.h.html#LN236"><span class='Ref_to_Const'>PG_CACHE_LINE_SIZE</span></a><span class='Delimiter'>]; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * fullPageWrites is the master copy used by all backends to determine 
     * whether to write full-page to WAL, instead of using process-local one. 
     * This is required because, when full_page_writes is changed by SIGHUP, 
     * we must WAL-log it before it actually affects WAL-logging by backends. 
     * Checkpointer sets at startup or after SIGHUP. 
     * 
     * To read these fields, you must hold an insertion lock. To modify them, 
     * you must hold ALL the locks. 
     */ 
</span><a name="LN547"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Member'>RedoRecPtr</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* current redo point for insertions */ 
</span><a name="LN548"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>forcePageWrites</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* forcing full-page writes for PITR? */ 
</span><a name="LN549"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>fullPageWrites</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * exclusiveBackupState indicates the state of an exclusive backup (see 
     * comments of ExclusiveBackupState for more details). nonExclusiveBackups 
     * is a counter indicating the number of streaming base backups currently 
     * in progress. forcePageWrites is set to true when either of these is 
     * non-zero. lastBackupStart is the latest checkpoint redo location used 
     * as a starting point for an online backup. 
     */ 
</span><a name="LN559"></a>    <a href="xlog.c.html#LN497"><span class='Ref_to_Enum'>ExclusiveBackupState</span></a> <span class='Declare_Member'>exclusiveBackupState</span><span class='Delimiter'>; 
</span><a name="LN560"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>nonExclusiveBackups</span><span class='Delimiter'>; 
</span><a name="LN561"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Member'>lastBackupStart</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * WAL insertion locks. 
     */ 
</span><a name="LN566"></a>    <a href="xlog.c.html#LN476"><span class='Ref_to_Union'>WALInsertLockPadded</span></a> <span class='Operator'>*</span><span class='Declare_Member'>WALInsertLocks</span><span class='Delimiter'>; 
</span><a name="LN567"></a>}<span class='Auto_Annotations'> &laquo; end XLogCtlInsert &raquo; </span> <span class='Declare_Typedef'>XLogCtlInsert</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Total shared-memory state for XLOG. 
 */ 
</span><a name="LN572"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>XLogCtlData</span> 
<span class='Delimiter'>{ 
</span><a name="LN574"></a>    <a href="xlog.c.html#LN514"><span class='Ref_to_Struct'>XLogCtlInsert</span></a> <span class='Declare_Member'>Insert</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Protected by info_lck: */ 
</span><a name="LN577"></a>    <a href="xlog.c.html#LN414"><span class='Ref_to_Struct'>XLogwrtRqst</span></a> <span class='Declare_Member'>LogwrtRqst</span><span class='Delimiter'>; 
</span><a name="LN578"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Member'>RedoRecPtr</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* a recent copy of Insert-&GT;RedoRecPtr */ 
</span><a name="LN579"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Member'>ckptXidEpoch</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* nextXID & epoch of latest checkpoint */ 
</span><a name="LN580"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Member'>ckptXid</span><span class='Delimiter'>; 
</span><a name="LN581"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Member'>asyncXactLSN</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* LSN of newest async commit/abort */ 
</span><a name="LN582"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Member'>replicationSlotMinLSN</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* oldest LSN needed by any slot */ 
</span> 
<a name="LN584"></a>    <a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a>   <span class='Declare_Member'>lastRemovedSegNo</span><span class='Delimiter'>;</span>       <span class='Comment_Multi_Line'>/* latest removed/recycled XLOG 
                                         * segment */ 
</span> 
    <span class='Comment_Multi_Line'>/* Fake LSN counter, for unlogged relations. Protected by ulsn_lck. */ 
</span><a name="LN588"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Member'>unloggedLSN</span><span class='Delimiter'>; 
</span><a name="LN589"></a>    <a href="../../../include/storage/s_lock.h.html#LN137"><span class='Ref_to_Typedef'>slock_t</span></a>     <span class='Declare_Member'>ulsn_lck</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Time and LSN of last xlog segment switch. Protected by WALWriteLock. */ 
</span><a name="LN592"></a>    <a href="../../../include/pgtime.h.html#LN22"><span class='Ref_to_Typedef'>pg_time_t</span></a>   <span class='Declare_Member'>lastSegSwitchTime</span><span class='Delimiter'>; 
</span><a name="LN593"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Member'>lastSegSwitchLSN</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Protected by info_lck and WALWriteLock (you must hold either lock to 
     * read it, but both to update) 
     */ 
</span><a name="LN599"></a>    <a href="xlog.c.html#LN420"><span class='Ref_to_Struct'>XLogwrtResult</span></a> <span class='Declare_Member'>LogwrtResult</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Latest initialized page in the cache (last byte position + 1). 
     * 
     * To change the identity of a buffer (and InitializedUpTo), you need to 
     * hold WALBufMappingLock.  To change the identity of a buffer that's 
     * still dirty, the old page needs to be written out first, and for that 
     * you need WALWriteLock, and you need to ensure that there are no 
     * in-progress insertions to the page by calling 
     * WaitXLogInsertionsToFinish(). 
     */ 
</span><a name="LN611"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Member'>InitializedUpTo</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * These values do not change after startup, although the pointed-to pages 
     * and xlblocks values certainly do.  xlblock values are protected by 
     * WALBufMappingLock. 
     */ 
</span><a name="LN618"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>pages</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* buffers for unwritten XLOG pages */ 
</span><a name="LN619"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Operator'>*</span><span class='Declare_Member'>xlblocks</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* 1st byte ptr-s + XLOG_BLCKSZ */ 
</span><a name="LN620"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>XLogCacheBlck</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* highest allocated xlog buffer index */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Shared copy of ThisTimeLineID. Does not change after end-of-recovery. 
     * If we created a new timeline when the system was started up, 
     * PrevTimeLineID is the old timeline's ID that we forked off from. 
     * Otherwise it's equal to ThisTimeLineID. 
     */ 
</span><a name="LN628"></a>    <a href="../../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a>  <span class='Declare_Member'>ThisTimeLineID</span><span class='Delimiter'>; 
</span><a name="LN629"></a>    <a href="../../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a>  <span class='Declare_Member'>PrevTimeLineID</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * archiveCleanupCommand is read from recovery.conf but needs to be in 
     * shared memory so that the checkpointer process can access it. 
     */ 
</span><a name="LN635"></a>    <span class='Keyword'>char</span>        <span class='Declare_Member'>archiveCleanupCommand</span><span class='Delimiter'>[</span><a href="../../../include/pg_config_manual.h.html#LN88"><span class='Ref_to_Const'>MAXPGPATH</span></a><span class='Delimiter'>]; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * SharedRecoveryInProgress indicates if we're still in crash or archive 
     * recovery.  Protected by info_lck. 
     */ 
</span><a name="LN641"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>SharedRecoveryInProgress</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * SharedHotStandbyActive indicates if we're still in crash or archive 
     * recovery.  Protected by info_lck. 
     */ 
</span><a name="LN647"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>SharedHotStandbyActive</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * WalWriterSleeping indicates whether the WAL writer is currently in 
     * low-power mode (and hence should be nudged if an async commit occurs). 
     * Protected by info_lck. 
     */ 
</span><a name="LN654"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>WalWriterSleeping</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * recoveryWakeupLatch is used to wake up the startup process to continue 
     * WAL replay, if it is waiting for WAL to arrive or failover trigger file 
     * to appear. 
     */ 
</span><a name="LN661"></a>    <a href="../../../include/storage/latch.h.html#LN109"><span class='Ref_to_Struct'>Latch</span></a>       <span class='Declare_Member'>recoveryWakeupLatch</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * During recovery, we keep a copy of the latest checkpoint record here. 
     * lastCheckPointRecPtr points to start of checkpoint record and 
     * lastCheckPointEndPtr points to end+1 of checkpoint record.  Used by the 
     * checkpointer when it wants to create a restartpoint. 
     * 
     * Protected by info_lck. 
     */ 
</span><a name="LN671"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Member'>lastCheckPointRecPtr</span><span class='Delimiter'>; 
</span><a name="LN672"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Member'>lastCheckPointEndPtr</span><span class='Delimiter'>; 
</span><a name="LN673"></a>    <a href="../../../include/catalog/pg_control.h.html#LN32"><span class='Ref_to_Struct'>CheckPoint</span></a>  <span class='Declare_Member'>lastCheckPoint</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * lastReplayedEndRecPtr points to end+1 of the last record successfully 
     * replayed. When we're currently replaying a record, ie. in a redo 
     * function, replayEndRecPtr points to the end+1 of the record being 
     * replayed, otherwise it's equal to lastReplayedEndRecPtr. 
     */ 
</span><a name="LN681"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Member'>lastReplayedEndRecPtr</span><span class='Delimiter'>; 
</span><a name="LN682"></a>    <a href="../../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a>  <span class='Declare_Member'>lastReplayedTLI</span><span class='Delimiter'>; 
</span><a name="LN683"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Member'>replayEndRecPtr</span><span class='Delimiter'>; 
</span><a name="LN684"></a>    <a href="../../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a>  <span class='Declare_Member'>replayEndTLI</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* timestamp of last COMMIT/ABORT record replayed (or being replayed) */ 
</span><a name="LN686"></a>    <a href="../../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <span class='Declare_Member'>recoveryLastXTime</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * timestamp of when we started replaying the current chunk of WAL data, 
     * only relevant for replication or archive recovery 
     */ 
</span><a name="LN692"></a>    <a href="../../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <span class='Declare_Member'>currentChunkStartTime</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* Are we requested to pause recovery? */ 
</span><a name="LN694"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>recoveryPause</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * lastFpwDisableRecPtr points to the start of the last replayed 
     * XLOG_FPW_CHANGE record that instructs full_page_writes is disabled. 
     */ 
</span><a name="LN700"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Member'>lastFpwDisableRecPtr</span><span class='Delimiter'>; 
</span> 
<a name="LN702"></a>    <a href="../../../include/storage/s_lock.h.html#LN137"><span class='Ref_to_Typedef'>slock_t</span></a>     <span class='Declare_Member'>info_lck</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* locks shared variables shown above */ 
</span><a name="LN703"></a><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end XLogCtlData &raquo; </span> <span class='Declare_Typedef'>XLogCtlData</span><span class='Delimiter'>; 
</span> 
<a name="LN705"></a><span class='Keyword'>static </span><a href="xlog.c.html#LN572"><span class='Ref_to_Struct'>XLogCtlData</span></a> <span class='Operator'>*</span><span class='Declare_Var'>XLogCtl</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* a private copy of XLogCtl-&GT;Insert.WALInsertLocks, for convenience */ 
</span><a name="LN708"></a><span class='Keyword'>static </span><a href="xlog.c.html#LN476"><span class='Ref_to_Union'>WALInsertLockPadded</span></a> <span class='Operator'>*</span><span class='Declare_Var'>WALInsertLocks</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * We maintain an image of pg_control in shared memory. 
 */ 
</span><a name="LN713"></a><span class='Keyword'>static </span><a href="../../../include/catalog/pg_control.h.html#LN102"><span class='Ref_to_Struct'>ControlFileData</span></a> <span class='Operator'>*</span><span class='Declare_Var'>ControlFile</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Calculate the amount of space left on the page after 'endptr'. Beware 
 * multiple evaluation! 
 */ 
</span><a name="LN719"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>INSERT_FREESPACE</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>endptr</span><span class='Parentheses'>)</span>    <span class='Operator'>\ 
</span>    <span class='Parentheses'>(((</span><a href="xlog.c.html#LN719"><span class='Ref_to_Parameter'>endptr</span></a><span class='Parentheses'>) </span><span class='Operator'>% </span>XLOG_BLCKSZ <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> <span class='Operator'>? </span><span class='Number'>0</span> <span class='Operator'>: </span><span class='Parentheses'>(</span>XLOG_BLCKSZ <span class='Operator'>- </span><span class='Parentheses'>(</span><a href="xlog.c.html#LN719"><span class='Ref_to_Parameter'>endptr</span></a><span class='Parentheses'>) </span><span class='Operator'>% </span>XLOG_BLCKSZ<span class='Parentheses'>))</span> 
 
<span class='Comment_Multi_Line'>/* Macro to advance to next buffer index. */ 
</span><a name="LN723"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>NextBufIdx</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>idx</span><span class='Parentheses'>)</span>     <span class='Operator'>\ 
</span>        <span class='Parentheses'>(((</span><a href="xlog.c.html#LN723"><span class='Ref_to_Parameter'>idx</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN620"><span class='Ref_to_Member'>XLogCacheBlck</span></a><span class='Parentheses'>)</span> <span class='Operator'>? </span><span class='Number'>0</span> <span class='Operator'>: </span><span class='Parentheses'>((</span><a href="xlog.c.html#LN723"><span class='Ref_to_Parameter'>idx</span></a><span class='Parentheses'>) </span><span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>))</span> 
 
<span class='Comment_Multi_Line'>/* 
 * XLogRecPtrToBufIdx returns the index of the WAL buffer that holds, or 
 * would hold if it was in cache, the page containing 'recptr'. 
 */ 
</span><a name="LN730"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>XLogRecPtrToBufIdx</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>recptr</span><span class='Parentheses'>)</span>  <span class='Operator'>\ 
</span>    <span class='Parentheses'>(((</span><a href="xlog.c.html#LN730"><span class='Ref_to_Parameter'>recptr</span></a><span class='Parentheses'>) </span><span class='Operator'>/ </span>XLOG_BLCKSZ<span class='Parentheses'>)</span> <span class='Operator'>% </span><span class='Parentheses'>(</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN620"><span class='Ref_to_Member'>XLogCacheBlck</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>))</span> 
 
<span class='Comment_Multi_Line'>/* 
 * These are the number of bytes in a WAL page and segment usable for WAL data. 
 */ 
</span><a name="LN736"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>UsableBytesInPage</span> <span class='Parentheses'>(</span>XLOG_BLCKSZ <span class='Operator'>- </span><a href="../../../include/access/xlog_internal.h.html#LN54"><span class='Ref_to_Const'>SizeOfXLogShortPHD</span></a><span class='Parentheses'>) 
</span><a name="LN737"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>UsableBytesInSegment</span> <span class='Parentheses'>((</span>XLOG_SEG_SIZE <span class='Operator'>/ </span>XLOG_BLCKSZ<span class='Parentheses'>) </span><span class='Operator'>* </span><a href="xlog.c.html#LN736"><span class='Ref_to_Const'>UsableBytesInPage</span></a> <span class='Operator'>- </span><span class='Parentheses'>(</span><a href="../../../include/access/xlog_internal.h.html#LN71"><span class='Ref_to_Const'>SizeOfXLogLongPHD</span></a> <span class='Operator'>- </span><a href="../../../include/access/xlog_internal.h.html#LN54"><span class='Ref_to_Const'>SizeOfXLogShortPHD</span></a><span class='Parentheses'>))</span> 
 
<span class='Comment_Multi_Line'>/* Convert min_wal_size_mb and max wal_size_mb to equivalent segment count */ 
</span><a name="LN740"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>ConvertToXSegs</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>x</span><span class='Parentheses'>)</span>   <span class='Operator'>\ 
</span>    <span class='Parentheses'>(</span><a href="xlog.c.html#LN740"><span class='Ref_to_Parameter'>x</span></a> <span class='Operator'>/ </span><span class='Parentheses'>(</span>XLOG_SEG_SIZE <span class='Operator'>/ </span><span class='Parentheses'>(</span><span class='Number'>1024</span> <span class='Operator'>* </span><span class='Number'>1024</span><span class='Parentheses'>)))</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Private, possibly out-of-date copy of shared LogwrtResult. 
 * See discussion above. 
 */ 
</span><a name="LN747"></a><span class='Keyword'>static </span><a href="xlog.c.html#LN420"><span class='Ref_to_Struct'>XLogwrtResult</span></a> <span class='Declare_Var'>LogwrtResult</span> <span class='Operator'>= </span><span class='Delimiter'>{</span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>}; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Codes indicating where we got a WAL file from during recovery, or where 
 * to attempt to get one. 
 */ 
</span><span class='Control'>typedef</span> <span class='Control'>enum</span> 
<span class='Delimiter'>{ 
</span><a name="LN755"></a>    <span class='Declare_Enum_Const'>XLOG_FROM_ANY</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>,</span>          <span class='Comment_Single_Line'>/* request to read WAL from any source */ 
</span><a name="LN756"></a>    <span class='Declare_Enum_Const'>XLOG_FROM_ARCHIVE</span><span class='Delimiter'>,</span>          <span class='Comment_Single_Line'>/* restored using restore_command */ 
</span><a name="LN757"></a>    <span class='Declare_Enum_Const'>XLOG_FROM_PG_WAL</span><span class='Delimiter'>,</span>           <span class='Comment_Single_Line'>/* existing file in pg_wal */ 
</span><a name="LN758"></a>    <span class='Declare_Enum_Const'>XLOG_FROM_STREAM</span>            <span class='Comment_Single_Line'>/* streamed from master */ 
</span><a name="LN759"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>XLogSource</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* human-readable names for XLogSources, for debugging output */ 
</span><a name="LN762"></a><span class='Keyword'>static const char </span><span class='Operator'>*</span><span class='Declare_Var'>xlogSourceNames</span><span class='Delimiter'>[] </span><span class='Operator'>= </span><span class='Delimiter'>{</span><span class='String'>"any"</span><span class='Delimiter'>, </span><span class='String'>"archive"</span><span class='Delimiter'>, </span><span class='String'>"pg_wal"</span><span class='Delimiter'>, </span><span class='String'>"stream"</span><span class='Delimiter'>}; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * openLogFile is -1 or a kernel FD for an open log file segment. 
 * When it's open, openLogOff is the current seek offset in the file. 
 * openLogSegNo identifies the segment.  These variables are only 
 * used to write the XLOG, and so will normally refer to the active segment. 
 */ 
</span><a name="LN770"></a><span class='Keyword'>static int</span>  <span class='Declare_Var'>openLogFile</span> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span><a name="LN771"></a><span class='Keyword'>static </span><a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a> <span class='Declare_Var'>openLogSegNo</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN772"></a><span class='Keyword'>static </span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Declare_Var'>openLogOff</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * These variables are used similarly to the ones above, but for reading 
 * the XLOG.  Note, however, that readOff generally represents the offset 
 * of the page just read, not the seek position of the FD itself, which 
 * will be just past that page. readLen indicates how much of the current 
 * page has been read into readBuf, and readSource indicates where we got 
 * the currently open file from. 
 */ 
</span><a name="LN782"></a><span class='Keyword'>static int</span>  <span class='Declare_Var'>readFile</span> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span><a name="LN783"></a><span class='Keyword'>static </span><a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a> <span class='Declare_Var'>readSegNo</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN784"></a><span class='Keyword'>static </span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Declare_Var'>readOff</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN785"></a><span class='Keyword'>static </span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Declare_Var'>readLen</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN786"></a><span class='Keyword'>static </span><a href="xlog.c.html#LN753"><span class='Ref_to_Typedef'>XLogSource</span></a> <span class='Declare_Var'>readSource</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* XLOG_FROM_* code */ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Keeps track of which source we're currently reading from. This is 
 * different from readSource in that this is always set, even when we don't 
 * currently have a WAL file open. If lastSourceFailed is set, our last 
 * attempt to read from currentSource failed, and we should try another source 
 * next. 
 */ 
</span><a name="LN795"></a><span class='Keyword'>static </span><a href="xlog.c.html#LN753"><span class='Ref_to_Typedef'>XLogSource</span></a> <span class='Declare_Var'>currentSource</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* XLOG_FROM_* code */ 
</span><a name="LN796"></a><span class='Keyword'>static bool </span><span class='Declare_Var'>lastSourceFailed</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
<a name="LN798"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>XLogPageReadPrivate</span> 
<span class='Delimiter'>{ 
</span><a name="LN800"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>emode</span><span class='Delimiter'>; 
</span><a name="LN801"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>fetching_ckpt</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* are we fetching a checkpoint record? */ 
</span><a name="LN802"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>randAccess</span><span class='Delimiter'>; 
</span><a name="LN803"></a>} <span class='Declare_Typedef'>XLogPageReadPrivate</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * These variables track when we last obtained some WAL data to process, 
 * and where we got it from.  (XLogReceiptSource is initially the same as 
 * readSource, but readSource gets reset to zero when we don't have data 
 * to process right now.  It is also different from currentSource, which 
 * also changes when we try to read from a source and fail, while 
 * XLogReceiptSource tracks where we last successfully read some WAL.) 
 */ 
</span><a name="LN813"></a><span class='Keyword'>static </span><a href="../../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <span class='Declare_Var'>XLogReceiptTime</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN814"></a><span class='Keyword'>static </span><a href="xlog.c.html#LN753"><span class='Ref_to_Typedef'>XLogSource</span></a> <span class='Declare_Var'>XLogReceiptSource</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* XLOG_FROM_* code */ 
</span> 
<span class='Comment_Multi_Line'>/* State information for XLOG reading */ 
</span><a name="LN817"></a><span class='Keyword'>static </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Var'>ReadRecPtr</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* start of last record read */ 
</span><a name="LN818"></a><span class='Keyword'>static </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Var'>EndRecPtr</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* end+1 of last record read */ 
</span> 
<a name="LN820"></a><span class='Keyword'>static </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Var'>minRecoveryPoint</span><span class='Delimiter'>;</span>     <span class='Comment_Multi_Line'>/* local copy of 
                                         * ControlFile-&GT;minRecoveryPoint */ 
</span><a name="LN822"></a><span class='Keyword'>static </span><a href="../../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a> <span class='Declare_Var'>minRecoveryPointTLI</span><span class='Delimiter'>; 
</span><a name="LN823"></a><span class='Keyword'>static bool </span><span class='Declare_Var'>updateMinRecoveryPoint</span> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Have we reached a consistent database state? In crash recovery, we have 
 * to replay all the WAL, so reachedConsistency is never set. During archive 
 * recovery, the database is consistent once minRecoveryPoint is reached. 
 */ 
</span><a name="LN830"></a><span class='Keyword'>bool</span>        <span class='Declare_Var'>reachedConsistency</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
<a name="LN832"></a><span class='Keyword'>static bool </span><span class='Declare_Var'>InRedo</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* Have we launched bgwriter during recovery? */ 
</span><a name="LN835"></a><span class='Keyword'>static bool </span><span class='Declare_Var'>bgwriterLaunched</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* For WALInsertLockAcquire/Release functions */ 
</span><a name="LN838"></a><span class='Keyword'>static int</span>  <span class='Declare_Var'>MyLockNo</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN839"></a><span class='Keyword'>static bool </span><span class='Declare_Var'>holdingAllLocks</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifdef</span> WAL_DEBUG 
<a name="LN842"></a><span class='Keyword'>static </span><a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Var'>walDebugCxt</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
<a name="LN845"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>readRecoveryCommandFile</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN846"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>exitArchiveRecovery</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a> <span class='Declare_Parameter'>endTLI</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>endOfLog</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN847"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>recoveryStopsBefore</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogreader.h.html#LN68"><span class='Ref_to_Struct'>XLogReaderState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>record</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN848"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>recoveryStopsAfter</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogreader.h.html#LN68"><span class='Ref_to_Struct'>XLogReaderState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>record</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN849"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>recoveryPausesHere</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN850"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>recoveryApplyDelay</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogreader.h.html#LN68"><span class='Ref_to_Struct'>XLogReaderState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>record</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN851"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>SetLatestXTime</span><span class='Parentheses'>(</span><a href="../../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <span class='Declare_Parameter'>xtime</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN852"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>SetCurrentChunkStartTime</span><span class='Parentheses'>(</span><a href="../../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <span class='Declare_Parameter'>xtime</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN853"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>CheckRequiredParameterValues</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN854"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>XLogReportParameters</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN855"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>checkTimeLineSwitch</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>lsn</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a> <span class='Declare_Parameter'>newTLI</span><span class='Delimiter'>, 
</span><a name="LN856"></a>                    <a href="../../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a> <span class='Declare_Parameter'>prevTLI</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN857"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>LocalSetXLogInsertAllowed</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN858"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>CreateEndOfRecoveryRecord</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN859"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>CheckPointGuts</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>checkPointRedo</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>flags</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN860"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>KeepLogSeg</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>recptr</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>logSegNo</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN861"></a><span class='Keyword'>static </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Prototype'>XLogGetReplicationSlotMinimumLSN</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<a name="LN863"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>AdvanceXLInsertBuffer</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>upto</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>opportunistic</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN864"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>XLogCheckpointNeeded</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a> <span class='Declare_Parameter'>new_segno</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN865"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>XLogWrite</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN414"><span class='Ref_to_Struct'>XLogwrtRqst</span></a> <span class='Declare_Parameter'>WriteRqst</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>flexible</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN866"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>InstallXLogFileSegment</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>segno</span><span class='Delimiter'>, </span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Declare_Parameter'>tmppath</span><span class='Delimiter'>, 
</span><a name="LN867"></a>                       <span class='Keyword'>bool </span><span class='Declare_Parameter'>find_free</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a> <span class='Declare_Parameter'>max_segno</span><span class='Delimiter'>, 
</span><a name="LN868"></a>                       <span class='Keyword'>bool </span><span class='Declare_Parameter'>use_lock</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN869"></a><span class='Keyword'>static int </span><span class='Declare_Prototype'>XLogFileRead</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a> <span class='Declare_Parameter'>segno</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>emode</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a> <span class='Declare_Parameter'>tli</span><span class='Delimiter'>, 
</span><a name="LN870"></a>             <span class='Keyword'>int </span><span class='Declare_Parameter'>source</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>notfoundOk</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN871"></a><span class='Keyword'>static int</span>  <span class='Declare_Prototype'>XLogFileReadAnyTLI</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a> <span class='Declare_Parameter'>segno</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>emode</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>source</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN872"></a><span class='Keyword'>static int </span><span class='Declare_Prototype'>XLogPageRead</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogreader.h.html#LN68"><span class='Ref_to_Struct'>XLogReaderState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>xlogreader</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>targetPagePtr</span><span class='Delimiter'>, 
</span><a name="LN873"></a>             <span class='Keyword'>int </span><span class='Declare_Parameter'>reqLen</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>targetRecPtr</span><span class='Delimiter'>, </span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Declare_Parameter'>readBuf</span><span class='Delimiter'>, 
</span><a name="LN874"></a>             <a href="../../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>readTLI</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN875"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>WaitForWALToBecomeAvailable</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>RecPtr</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>randAccess</span><span class='Delimiter'>, 
</span><a name="LN876"></a>                            <span class='Keyword'>bool </span><span class='Declare_Parameter'>fetching_ckpt</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>tliRecPtr</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN877"></a><span class='Keyword'>static int</span>  <span class='Declare_Prototype'>emode_for_corrupt_record</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>emode</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>RecPtr</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN878"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>XLogFileClose</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN879"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>PreallocXlogFiles</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>endptr</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN880"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>RemoveOldXlogFiles</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a> <span class='Declare_Parameter'>segno</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>PriorRedoPtr</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>endptr</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN881"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>RemoveXlogFile</span><span class='Parentheses'>(</span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>segname</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>PriorRedoPtr</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>endptr</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN882"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>UpdateLastRemovedPtr</span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Declare_Parameter'>filename</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN883"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>ValidateXLOGDirectoryStructure</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN884"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>CleanupBackupHistory</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN885"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>UpdateMinRecoveryPoint</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>lsn</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>force</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN886"></a><span class='Keyword'>static </span><a href="../../../include/access/xlogrecord.h.html#LN40"><span class='Ref_to_Struct'>XLogRecord</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>ReadRecord</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogreader.h.html#LN68"><span class='Ref_to_Struct'>XLogReaderState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>xlogreader</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>RecPtr</span><span class='Delimiter'>, 
</span><a name="LN887"></a>           <span class='Keyword'>int </span><span class='Declare_Parameter'>emode</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>fetching_ckpt</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN888"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>CheckRecoveryConsistency</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN889"></a><span class='Keyword'>static </span><a href="../../../include/access/xlogrecord.h.html#LN40"><span class='Ref_to_Struct'>XLogRecord</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>ReadCheckpointRecord</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogreader.h.html#LN68"><span class='Ref_to_Struct'>XLogReaderState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>xlogreader</span><span class='Delimiter'>, 
</span><a name="LN890"></a>                     <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>RecPtr</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>whichChkpti</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>report</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN891"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>rescanLatestTimeLine</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN892"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>WriteControlFile</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN893"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>ReadControlFile</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN894"></a><span class='Keyword'>static char </span><span class='Operator'>*</span><span class='Declare_Prototype'>str_time</span><span class='Parentheses'>(</span><a href="../../../include/pgtime.h.html#LN22"><span class='Ref_to_Typedef'>pg_time_t</span></a> <span class='Declare_Parameter'>tnow</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN895"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>CheckForStandbyTrigger</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifdef</span> WAL_DEBUG 
<a name="LN898"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>xlog_outrec</span><span class='Parentheses'>(</span><a href="../../../include/lib/stringinfo.h.html#LN42"><span class='Ref_to_Typedef'>StringInfo</span></a> <span class='Declare_Parameter'>buf</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogreader.h.html#LN68"><span class='Ref_to_Struct'>XLogReaderState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>record</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
<a name="LN900"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>xlog_outdesc</span><span class='Parentheses'>(</span><a href="../../../include/lib/stringinfo.h.html#LN42"><span class='Ref_to_Typedef'>StringInfo</span></a> <span class='Declare_Parameter'>buf</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogreader.h.html#LN68"><span class='Ref_to_Struct'>XLogReaderState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>record</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN901"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>pg_start_backup_callback</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>code</span><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>arg</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN902"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>pg_stop_backup_callback</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>code</span><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>arg</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN903"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>read_backup_label</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>checkPointLoc</span><span class='Delimiter'>, 
</span><a name="LN904"></a>                  <span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>backupEndRequired</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>backupFromStandby</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN905"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>read_tablespace_map</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>tablespaces</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<a name="LN907"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>rm_redo_error_callback</span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>arg</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN908"></a><span class='Keyword'>static int</span>  <span class='Declare_Prototype'>get_sync_bit</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>method</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<a name="LN910"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>CopyXLogRecordToWAL</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>write_len</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>isLogSwitch</span><span class='Delimiter'>, 
</span><a name="LN911"></a>                    <a href="../../../include/access/xlog_internal.h.html#LN240"><span class='Ref_to_Struct'>XLogRecData</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rdata</span><span class='Delimiter'>, 
</span><a name="LN912"></a>                    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>StartPos</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>EndPos</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN913"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>ReserveXLogInsertLocation</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>size</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>StartPos</span><span class='Delimiter'>, 
</span><a name="LN914"></a>                          <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>EndPos</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>PrevPtr</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN915"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>ReserveXLogSwitch</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>StartPos</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>EndPos</span><span class='Delimiter'>, 
</span><a name="LN916"></a>                  <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>PrevPtr</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN917"></a><span class='Keyword'>static </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Prototype'>WaitXLogInsertionsToFinish</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>upto</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN918"></a><span class='Keyword'>static char </span><span class='Operator'>*</span><span class='Declare_Prototype'>GetXLogBuffer</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>ptr</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN919"></a><span class='Keyword'>static </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Prototype'>XLogBytePosToRecPtr</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a> <span class='Declare_Parameter'>bytepos</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN920"></a><span class='Keyword'>static </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Prototype'>XLogBytePosToEndRecPtr</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a> <span class='Declare_Parameter'>bytepos</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN921"></a><span class='Keyword'>static </span><a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a> <span class='Declare_Prototype'>XLogRecPtrToBytePos</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>ptr</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN922"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>checkXLogConsistency</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogreader.h.html#LN68"><span class='Ref_to_Struct'>XLogReaderState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>record</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<a name="LN924"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>WALInsertLockAcquire</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN925"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>WALInsertLockAcquireExclusive</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN926"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>WALInsertLockRelease</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN927"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>WALInsertLockUpdateInsertingAt</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>insertingAt</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Insert an XLOG record represented by an already-constructed chain of data 
 * chunks.  This is a low-level routine; to construct the WAL record header 
 * and data, use the higher-level routines in xloginsert.c. 
 * 
 * If 'fpw_lsn' is valid, it is the oldest LSN among the pages that this 
 * WAL record applies to, that were not included in the record as full page 
 * images.  If fpw_lsn &GT;= RedoRecPtr, the function does not perform the 
 * insertion and returns InvalidXLogRecPtr.  The caller can then recalculate 
 * which pages need a full-page image, and retry.  If fpw_lsn is invalid, the 
 * record is always inserted. 
 * 
 * 'flags' gives more in-depth control on the record being inserted. See 
 * XLogSetRecordFlags() for details. 
 * 
 * The first XLogRecData in the chain must be for the record header, and its 
 * data must be MAXALIGNed.  XLogInsertRecord fills in the xl_prev and 
 * xl_crc fields in the header, the rest of the header must already be filled 
 * by the caller. 
 * 
 * Returns XLOG pointer to end of record (beginning of next record). 
 * This can be used as LSN for data pages affected by the logged action. 
 * (LSN is the XLOG point up to which the XLOG must be flushed to disk 
 * before the data page can be written out.  This implements the basic 
 * WAL rule "write the log before the data".) 
 */ 
</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> 
<a name="LN956"></a><span class='Declare_Function'>XLogInsertRecord</span><span class='Parentheses'>(</span><a href="../../../include/access/xlog_internal.h.html#LN240"><span class='Ref_to_Struct'>XLogRecData</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rdata</span><span class='Delimiter'>, 
</span><a name="LN957"></a>                 <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>fpw_lsn</span><span class='Delimiter'>, 
</span><a name="LN958"></a>                 <a href="../../../include/c.h.html#LN265"><span class='Ref_to_Typedef'>uint8</span></a> <span class='Declare_Parameter'>flags</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN960"></a>    <a href="xlog.c.html#LN514"><span class='Ref_to_Struct'>XLogCtlInsert</span></a> <span class='Operator'>*</span><span class='Declare_Local'>Insert</span> <span class='Operator'>= &</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN574"><span class='Ref_to_Member'>Insert</span></a><span class='Delimiter'>; 
</span><a name="LN961"></a>    <a href="../../../include/port/pg_crc32c.h.html#LN37"><span class='Ref_to_Typedef'>pg_crc32c</span></a>   <span class='Declare_Local'>rdata_crc</span><span class='Delimiter'>; 
</span><a name="LN962"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>inserted</span><span class='Delimiter'>; 
</span><a name="LN963"></a>    <a href="../../../include/access/xlogrecord.h.html#LN40"><span class='Ref_to_Struct'>XLogRecord</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rechdr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/xlogrecord.h.html#LN40"><span class='Ref_to_Struct'>XLogRecord</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="xlog.c.html#LN956"><span class='Ref_to_Parameter'>rdata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlog_internal.h.html#LN243"><span class='Ref_to_Member'>data</span></a><span class='Delimiter'>; 
</span><a name="LN964"></a>    <a href="../../../include/c.h.html#LN265"><span class='Ref_to_Typedef'>uint8</span></a>       <span class='Declare_Local'>info</span> <span class='Operator'>= </span><a href="xlog.c.html#LN963"><span class='Ref_To_Local'>rechdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogrecord.h.html#LN45"><span class='Ref_to_Member'>xl_info</span></a> <span class='Operator'>& ~</span><a href="../../../include/access/xlogrecord.h.html#LN61"><span class='Ref_to_Const'>XLR_INFO_MASK</span></a><span class='Delimiter'>; 
</span><a name="LN965"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>isLogSwitch</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="xlog.c.html#LN963"><span class='Ref_To_Local'>rechdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogrecord.h.html#LN46"><span class='Ref_to_Member'>xl_rmid</span></a> <span class='Operator'>== </span>RM_XLOG_ID <span class='Operator'>&& 
</span>                               <a href="xlog.c.html#LN964"><span class='Ref_To_Local'>info</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_control.h.html#LN69"><span class='Ref_to_Const'>XLOG_SWITCH</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN967"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>StartPos</span><span class='Delimiter'>; 
</span><a name="LN968"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>EndPos</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* we assume that all of the record header is in the first chunk */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN956"><span class='Ref_to_Parameter'>rdata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlog_internal.h.html#LN244"><span class='Ref_to_Member'>len</span></a> <span class='Operator'>&GT;= </span><a href="../../../include/access/xlogrecord.h.html#LN54"><span class='Ref_to_Const'>SizeOfXLogRecord</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* cross-check on whether we should be here or not */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/xlog.h.html#LN245"><span class='Ref_to_Proto'>XLogInsertAllowed</span></a><span class='Parentheses'>())</span> 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cannot make new WAL entries during recovery"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/*---------- 
     * 
     * We have now done all the preparatory work we can without holding a 
     * lock or modifying shared state. From here on, inserting the new WAL 
     * record to the shared WAL buffer cache is a two-step process: 
     * 
     * 1. Reserve the right amount of space from the WAL. The current head of 
     *    reserved space is kept in Insert-&GT;CurrBytePos, and is protected by 
     *    insertpos_lck. 
     * 
     * 2. Copy the record to the reserved WAL space. This involves finding the 
     *    correct WAL buffer containing the reserved space, and copying the 
     *    record in place. This can be done concurrently in multiple processes. 
     * 
     * To keep track of which insertions are still in-progress, each concurrent 
     * inserter acquires an insertion lock. In addition to just indicating that 
     * an insertion is in progress, the lock tells others how far the inserter 
     * has progressed. There is a small fixed number of insertion locks, 
     * determined by NUM_XLOGINSERT_LOCKS. When an inserter crosses a page 
     * boundary, it updates the value stored in the lock to the how far it has 
     * inserted, to allow the previous buffer to be flushed. 
     * 
     * Holding onto an insertion lock also protects RedoRecPtr and 
     * fullPageWrites from changing until the insertion is finished. 
     * 
     * Step 2 can usually be done completely in parallel. If the required WAL 
     * page is not initialized yet, you have to grab WALBufMappingLock to 
     * initialize it, but the WAL writer tries to do that ahead of insertions 
     * to avoid that from happening in the critical path. 
     * 
     *---------- 
     */ 
</span>    <a href="../../../include/miscadmin.h.html#LN132"><span class='Ref_to_Macro'>START_CRIT_SECTION</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN965"><span class='Ref_To_Local'>isLogSwitch</span></a><span class='Parentheses'>) 
</span>        <a href="xlog.c.html#LN925"><span class='Ref_to_Proto'>WALInsertLockAcquireExclusive</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="xlog.c.html#LN924"><span class='Ref_to_Proto'>WALInsertLockAcquire</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Check to see if my copy of RedoRecPtr or doPageWrites is out of date. 
     * If so, may have to go back and have the caller recompute everything. 
     * This can only happen just after a checkpoint, so it's better to be slow 
     * in this case and fast otherwise. 
     * 
     * If we aren't doing full-page writes then RedoRecPtr doesn't actually 
     * affect the contents of the XLOG record, so we'll update our local copy 
     * but not force a recomputation.  (If doPageWrites was just turned off, 
     * we could recompute the record without full pages, but we choose not to 
     * bother.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN349"><span class='Ref_to_Global_Var'>RedoRecPtr</span></a> <span class='Operator'>!= </span><a href="xlog.c.html#LN960"><span class='Ref_To_Local'>Insert</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN547"><span class='Ref_to_Member'>RedoRecPtr</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN349"><span class='Ref_to_Global_Var'>RedoRecPtr</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN960"><span class='Ref_To_Local'>Insert</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN547"><span class='Ref_to_Member'>RedoRecPtr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN349"><span class='Ref_to_Global_Var'>RedoRecPtr</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN960"><span class='Ref_To_Local'>Insert</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN547"><span class='Ref_to_Member'>RedoRecPtr</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="xlog.c.html#LN356"><span class='Ref_to_Global_Var'>doPageWrites</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="xlog.c.html#LN960"><span class='Ref_To_Local'>Insert</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN549"><span class='Ref_to_Member'>fullPageWrites</span></a> <span class='Operator'>|| </span><a href="xlog.c.html#LN960"><span class='Ref_To_Local'>Insert</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN548"><span class='Ref_to_Member'>forcePageWrites</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN957"><span class='Ref_to_Parameter'>fpw_lsn</span></a> <span class='Operator'>!= </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a> <span class='Operator'>&& </span><a href="xlog.c.html#LN957"><span class='Ref_to_Parameter'>fpw_lsn</span></a> <span class='Operator'>&LT;= </span><a href="xlog.c.html#LN349"><span class='Ref_to_Global_Var'>RedoRecPtr</span></a> <span class='Operator'>&& </span><a href="xlog.c.html#LN356"><span class='Ref_to_Global_Var'>doPageWrites</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Oops, some buffer now needs to be backed up that the caller didn't 
         * back up.  Start over. 
         */ 
</span>        <a href="xlog.c.html#LN926"><span class='Ref_to_Proto'>WALInsertLockRelease</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <a href="../../../include/miscadmin.h.html#LN134"><span class='Ref_to_Macro'>END_CRIT_SECTION</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Reserve space for the record in the WAL. This also sets the xl_prev 
     * pointer. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN965"><span class='Ref_To_Local'>isLogSwitch</span></a><span class='Parentheses'>) 
</span>        <a href="xlog.c.html#LN962"><span class='Ref_To_Local'>inserted</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN915"><span class='Ref_to_Proto'>ReserveXLogSwitch</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN967"><span class='Ref_To_Local'>StartPos</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN968"><span class='Ref_To_Local'>EndPos</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN963"><span class='Ref_To_Local'>rechdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogrecord.h.html#LN44"><span class='Ref_to_Member'>xl_prev</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="xlog.c.html#LN913"><span class='Ref_to_Proto'>ReserveXLogInsertLocation</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN963"><span class='Ref_To_Local'>rechdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogrecord.h.html#LN42"><span class='Ref_to_Member'>xl_tot_len</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN967"><span class='Ref_To_Local'>StartPos</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN968"><span class='Ref_To_Local'>EndPos</span></a><span class='Delimiter'>, 
</span>                                  <span class='Operator'>&</span><a href="xlog.c.html#LN963"><span class='Ref_To_Local'>rechdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogrecord.h.html#LN44"><span class='Ref_to_Member'>xl_prev</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN962"><span class='Ref_To_Local'>inserted</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN962"><span class='Ref_To_Local'>inserted</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Now that xl_prev has been filled in, calculate CRC of the record 
         * header. 
         */ 
</span>        <a href="xlog.c.html#LN961"><span class='Ref_To_Local'>rdata_crc</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN963"><span class='Ref_To_Local'>rechdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogrecord.h.html#LN48"><span class='Ref_to_Member'>xl_crc</span></a><span class='Delimiter'>; 
</span>        <a href="../../../include/port/pg_crc32c.h.html#LN45"><span class='Ref_to_Macro'>COMP_CRC32C</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN961"><span class='Ref_To_Local'>rdata_crc</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN963"><span class='Ref_To_Local'>rechdr</span></a><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlogrecord.h.html#LN40"><span class='Ref_to_Struct'>XLogRecord</span></a><span class='Delimiter'>, </span>xl_crc<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="../../../include/port/pg_crc32c.h.html#LN47"><span class='Ref_to_Macro'>FIN_CRC32C</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN961"><span class='Ref_To_Local'>rdata_crc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN963"><span class='Ref_To_Local'>rechdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogrecord.h.html#LN48"><span class='Ref_to_Member'>xl_crc</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN961"><span class='Ref_To_Local'>rdata_crc</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * All the record data, including the header, is now ready to be 
         * inserted. Copy the record in the space reserved. 
         */ 
</span>        <a href="xlog.c.html#LN910"><span class='Ref_to_Proto'>CopyXLogRecordToWAL</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN963"><span class='Ref_To_Local'>rechdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogrecord.h.html#LN42"><span class='Ref_to_Member'>xl_tot_len</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN965"><span class='Ref_To_Local'>isLogSwitch</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN956"><span class='Ref_to_Parameter'>rdata</span></a><span class='Delimiter'>, 
</span>                            <a href="xlog.c.html#LN967"><span class='Ref_To_Local'>StartPos</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN968"><span class='Ref_To_Local'>EndPos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Unless record is flagged as not important, update LSN of last 
         * important record in the current slot. When holding all locks, just 
         * update the first one. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="xlog.c.html#LN958"><span class='Ref_to_Parameter'>flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/xlog.h.html#LN192"><span class='Ref_to_Const'>XLOG_MARK_UNIMPORTANT</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span><a name="LN1083"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>lockno</span> <span class='Operator'>= </span><a href="xlog.c.html#LN839"><span class='Ref_to_Global_Var'>holdingAllLocks</span></a> <span class='Operator'>? </span><span class='Number'>0</span> <span class='Operator'>: </span><a href="xlog.c.html#LN838"><span class='Ref_to_Global_Var'>MyLockNo</span></a><span class='Delimiter'>; 
</span> 
            <a href="xlog.c.html#LN708"><span class='Ref_to_Global_Var'>WALInsertLocks</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN1083"><span class='Ref_To_Local'>lockno</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="xlog.c.html#LN478"><span class='Ref_to_Member'>l</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN466"><span class='Ref_to_Member'>lastImportantAt</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN967"><span class='Ref_To_Local'>StartPos</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if inserted &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * This was an xlog-switch record, but the current insert location was 
         * already exactly at the beginning of a segment, so there was no need 
         * to do anything. 
         */ 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Done! Let others know that we're finished. 
     */ 
</span>    <a href="xlog.c.html#LN926"><span class='Ref_to_Proto'>WALInsertLockRelease</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/access/xact.h.html#LN337"><span class='Ref_to_Proto'>MarkCurrentTransactionIdLoggedIfAny</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/miscadmin.h.html#LN134"><span class='Ref_to_Macro'>END_CRIT_SECTION</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Update shared LogwrtRqst.Write, if we crossed page boundary. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN967"><span class='Ref_To_Local'>StartPos</span></a> <span class='Operator'>/ </span>XLOG_BLCKSZ <span class='Operator'>!= </span><a href="xlog.c.html#LN968"><span class='Ref_To_Local'>EndPos</span></a> <span class='Operator'>/ </span>XLOG_BLCKSZ<span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* advance global request to include new block(s) */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN577"><span class='Ref_to_Member'>LogwrtRqst</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN416"><span class='Ref_to_Member'>Write</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN968"><span class='Ref_To_Local'>EndPos</span></a><span class='Parentheses'>) 
</span>            <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN577"><span class='Ref_to_Member'>LogwrtRqst</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN416"><span class='Ref_to_Member'>Write</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN968"><span class='Ref_To_Local'>EndPos</span></a><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* update local result copy while I have the chance */ 
</span>        <a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN599"><span class='Ref_to_Member'>LogwrtResult</span></a><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If this was an XLOG_SWITCH record, flush the record and the empty 
     * padding space that fills the rest of the segment, and perform 
     * end-of-segment actions (eg, notifying archiver). 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN965"><span class='Ref_To_Local'>isLogSwitch</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        TRACE_POSTGRESQL_WAL_SWITCH<span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <a href="../../../include/access/xlog.h.html#LN225"><span class='Ref_to_Proto'>XLogFlush</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN968"><span class='Ref_To_Local'>EndPos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Even though we reserved the rest of the segment for us, which is 
         * reflected in EndPos, we return a pointer to just the end of the 
         * xlog-switch record. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN962"><span class='Ref_To_Local'>inserted</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="xlog.c.html#LN968"><span class='Ref_To_Local'>EndPos</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN967"><span class='Ref_To_Local'>StartPos</span></a> <span class='Operator'>+ </span><a href="../../../include/access/xlogrecord.h.html#LN54"><span class='Ref_to_Const'>SizeOfXLogRecord</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN967"><span class='Ref_To_Local'>StartPos</span></a> <span class='Operator'>/ </span>XLOG_BLCKSZ <span class='Operator'>!= </span><a href="xlog.c.html#LN968"><span class='Ref_To_Local'>EndPos</span></a> <span class='Operator'>/ </span>XLOG_BLCKSZ<span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN968"><span class='Ref_To_Local'>EndPos</span></a> <span class='Operator'>% </span>XLOG_SEG_SIZE <span class='Operator'>== </span><a href="xlog.c.html#LN968"><span class='Ref_To_Local'>EndPos</span></a> <span class='Operator'>% </span>XLOG_BLCKSZ<span class='Parentheses'>) 
</span>                    <a href="xlog.c.html#LN968"><span class='Ref_To_Local'>EndPos</span></a> <span class='Operator'>+= </span><a href="../../../include/access/xlog_internal.h.html#LN71"><span class='Ref_to_Const'>SizeOfXLogLongPHD</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>else</span> 
                    <a href="xlog.c.html#LN968"><span class='Ref_To_Local'>EndPos</span></a> <span class='Operator'>+= </span><a href="../../../include/access/xlog_internal.h.html#LN54"><span class='Ref_to_Const'>SizeOfXLogShortPHD</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if isLogSwitch &raquo; </span> 
 
<span class='Directive'>#ifdef</span> WAL_DEBUG 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN109"><span class='Ref_to_Global_Var'>XLOG_DEBUG</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1151"></a>        <span class='Keyword'>static </span><a href="../../../include/access/xlogreader.h.html#LN68"><span class='Ref_to_Struct'>XLogReaderState</span></a> <span class='Operator'>*</span><span class='Declare_Local'>debug_reader</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN1152"></a>        <a href="../../../include/lib/stringinfo.h.html#LN34"><span class='Ref_to_Struct'>StringInfoData</span></a> <span class='Declare_Local'>buf</span><span class='Delimiter'>; 
</span><a name="LN1153"></a>        <a href="../../../include/lib/stringinfo.h.html#LN34"><span class='Ref_to_Struct'>StringInfoData</span></a> <span class='Declare_Local'>recordBuf</span><span class='Delimiter'>; 
</span><a name="LN1154"></a>        <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>errormsg</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN1155"></a>        <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldCxt</span><span class='Delimiter'>; 
</span> 
        <a href="xlog.c.html#LN1155"><span class='Ref_To_Local'>oldCxt</span></a> <span class='Operator'>= </span><a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN842"><span class='Ref_to_Global_Var'>walDebugCxt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../lib/stringinfo.c.html#LN44"><span class='Ref_to_Func'>initStringInfo</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN1152"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../bin/pg_waldump/compat.c.html#LN69"><span class='Ref_to_Func'>appendStringInfo</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN1152"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><span class='String'>"INSERT @ %X/%X: "</span><span class='Delimiter'>, 
</span>                         <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN968"><span class='Ref_To_Local'>EndPos</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN968"><span class='Ref_To_Local'>EndPos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We have to piece together the WAL record data from the XLogRecData 
         * entries, so that we can pass it to the rm_desc function as one 
         * contiguous chunk. 
         */ 
</span>        <a href="../../lib/stringinfo.c.html#LN44"><span class='Ref_to_Func'>initStringInfo</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN1153"><span class='Ref_To_Local'>recordBuf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>; </span><a href="xlog.c.html#LN956"><span class='Ref_to_Parameter'>rdata</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; </span><a href="xlog.c.html#LN956"><span class='Ref_to_Parameter'>rdata</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN956"><span class='Ref_to_Parameter'>rdata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlog_internal.h.html#LN242"><span class='Ref_to_Member'>next</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/lib/stringinfo.h.html#LN142"><span class='Ref_to_Proto'>appendBinaryStringInfo</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN1153"><span class='Ref_To_Local'>recordBuf</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN956"><span class='Ref_to_Parameter'>rdata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlog_internal.h.html#LN243"><span class='Ref_to_Member'>data</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN956"><span class='Ref_to_Parameter'>rdata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlog_internal.h.html#LN244"><span class='Ref_to_Member'>len</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN1151"><span class='Ref_To_Local'>debug_reader</span></a><span class='Parentheses'>) 
</span>            <a href="xlog.c.html#LN1151"><span class='Ref_To_Local'>debug_reader</span></a> <span class='Operator'>= </span><a href="xlogreader.c.html#LN65"><span class='Ref_to_Func'>XLogReaderAllocate</span></a><span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN1151"><span class='Ref_To_Local'>debug_reader</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../../bin/pg_waldump/compat.c.html#LN79"><span class='Ref_to_Func'>appendStringInfoString</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN1152"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><span class='String'>"error decoding record: out of memory"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/xlogreader.h.html#LN210"><span class='Ref_to_Proto'>DecodeXLogRecord</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN1151"><span class='Ref_To_Local'>debug_reader</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/access/xlogrecord.h.html#LN40"><span class='Ref_to_Struct'>XLogRecord</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="xlog.c.html#LN1153"><span class='Ref_To_Local'>recordBuf</span></a><span class='Operator'>.</span><a href="../../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Delimiter'>, 
</span>                                   <span class='Operator'>&</span><a href="xlog.c.html#LN1154"><span class='Ref_To_Local'>errormsg</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="../../../bin/pg_waldump/compat.c.html#LN69"><span class='Ref_to_Func'>appendStringInfo</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN1152"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><span class='String'>"error decoding record: %s"</span><span class='Delimiter'>, 
</span>                             <a href="xlog.c.html#LN1154"><span class='Ref_To_Local'>errormsg</span></a> <span class='Operator'>? </span><a href="xlog.c.html#LN1154"><span class='Ref_To_Local'>errormsg</span></a> <span class='Operator'>: </span><span class='String'>"no error message"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <a href="../../../bin/pg_waldump/compat.c.html#LN79"><span class='Ref_to_Func'>appendStringInfoString</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN1152"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><span class='String'>" - "</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN900"><span class='Ref_to_Proto'>xlog_outdesc</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN1152"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN1151"><span class='Ref_To_Local'>debug_reader</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, </span><span class='String'>"%s"</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN1152"><span class='Ref_To_Local'>buf</span></a><span class='Operator'>.</span><a href="../../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN1152"><span class='Ref_To_Local'>buf</span></a><span class='Operator'>.</span><a href="../../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN1153"><span class='Ref_To_Local'>recordBuf</span></a><span class='Operator'>.</span><a href="../../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN1155"><span class='Ref_To_Local'>oldCxt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if XLOG_DEBUG &raquo; </span> 
<span class='Directive'>#endif</span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Update our global variables 
     */ 
</span>    <a href="xlog.c.html#LN335"><span class='Ref_to_Global_Var'>ProcLastRecPtr</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN967"><span class='Ref_To_Local'>StartPos</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN336"><span class='Ref_to_Global_Var'>XactLastRecEnd</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN968"><span class='Ref_To_Local'>EndPos</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="xlog.c.html#LN968"><span class='Ref_To_Local'>EndPos</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end XLogInsertRecord &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Reserves the right amount of space for a record of given size from the WAL. 
 * *StartPos is set to the beginning of the reserved section, *EndPos to 
 * its end+1. *PrevPtr is set to the beginning of the previous record; it is 
 * used to set the xl_prev of this record. 
 * 
 * This is the performance critical part of XLogInsert that must be serialized 
 * across backends. The rest can happen mostly in parallel. Try to keep this 
 * section as short as possible, insertpos_lck can be heavily contended on a 
 * busy system. 
 * 
 * NB: The space calculation here must match the code in CopyXLogRecordToWAL, 
 * where we actually copy the record to the reserved space. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1222"></a><span class='Declare_Function'>ReserveXLogInsertLocation</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>size</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>StartPos</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>EndPos</span><span class='Delimiter'>, 
</span><a name="LN1223"></a>                          <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>PrevPtr</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1225"></a>    <a href="xlog.c.html#LN514"><span class='Ref_to_Struct'>XLogCtlInsert</span></a> <span class='Operator'>*</span><span class='Declare_Local'>Insert</span> <span class='Operator'>= &</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN574"><span class='Ref_to_Member'>Insert</span></a><span class='Delimiter'>; 
</span><a name="LN1226"></a>    <a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a>      <span class='Declare_Local'>startbytepos</span><span class='Delimiter'>; 
</span><a name="LN1227"></a>    <a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a>      <span class='Declare_Local'>endbytepos</span><span class='Delimiter'>; 
</span><a name="LN1228"></a>    <a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a>      <span class='Declare_Local'>prevbytepos</span><span class='Delimiter'>; 
</span> 
    <a href="xlog.c.html#LN1222"><span class='Ref_to_Parameter'>size</span></a> <span class='Operator'>= </span><a href="../../../include/c.h.html#LN587"><span class='Ref_to_Macro'>MAXALIGN</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN1222"><span class='Ref_to_Parameter'>size</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* All (non xlog-switch) records should contain data. */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN1222"><span class='Ref_to_Parameter'>size</span></a> <span class='Operator'>&GT; </span><a href="../../../include/access/xlogrecord.h.html#LN54"><span class='Ref_to_Const'>SizeOfXLogRecord</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * The duration the spinlock needs to be held is minimized by minimizing 
     * the calculations that have to be done while holding the lock. The 
     * current tip of reserved WAL is kept in CurrBytePos, as a byte position 
     * that only counts "usable" bytes in WAL, that is, it excludes all WAL 
     * page headers. The mapping between "usable" byte positions and physical 
     * positions (XLogRecPtrs) can be done outside the locked region, and 
     * because the usable byte position doesn't include any headers, reserving 
     * X bytes from WAL is almost as simple as "CurrBytePos += X". 
     */ 
</span>    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN1225"><span class='Ref_To_Local'>Insert</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN516"><span class='Ref_to_Member'>insertpos_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="xlog.c.html#LN1226"><span class='Ref_To_Local'>startbytepos</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN1225"><span class='Ref_To_Local'>Insert</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN525"><span class='Ref_to_Member'>CurrBytePos</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN1227"><span class='Ref_To_Local'>endbytepos</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN1226"><span class='Ref_To_Local'>startbytepos</span></a> <span class='Operator'>+ </span><a href="xlog.c.html#LN1222"><span class='Ref_to_Parameter'>size</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN1228"><span class='Ref_To_Local'>prevbytepos</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN1225"><span class='Ref_To_Local'>Insert</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN526"><span class='Ref_to_Member'>PrevBytePos</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN1225"><span class='Ref_To_Local'>Insert</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN525"><span class='Ref_to_Member'>CurrBytePos</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN1227"><span class='Ref_To_Local'>endbytepos</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN1225"><span class='Ref_To_Local'>Insert</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN526"><span class='Ref_to_Member'>PrevBytePos</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN1226"><span class='Ref_To_Local'>startbytepos</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN1225"><span class='Ref_To_Local'>Insert</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN516"><span class='Ref_to_Member'>insertpos_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Operator'>*</span><a href="xlog.c.html#LN1222"><span class='Ref_to_Parameter'>StartPos</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN919"><span class='Ref_to_Proto'>XLogBytePosToRecPtr</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN1226"><span class='Ref_To_Local'>startbytepos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="xlog.c.html#LN1222"><span class='Ref_to_Parameter'>EndPos</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN920"><span class='Ref_to_Proto'>XLogBytePosToEndRecPtr</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN1227"><span class='Ref_To_Local'>endbytepos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="xlog.c.html#LN1223"><span class='Ref_to_Parameter'>PrevPtr</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN919"><span class='Ref_to_Proto'>XLogBytePosToRecPtr</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN1228"><span class='Ref_To_Local'>prevbytepos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Check that the conversions between "usable byte positions" and 
     * XLogRecPtrs work consistently in both directions. 
     */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN921"><span class='Ref_to_Proto'>XLogRecPtrToBytePos</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="xlog.c.html#LN1222"><span class='Ref_to_Parameter'>StartPos</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="xlog.c.html#LN1226"><span class='Ref_To_Local'>startbytepos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN921"><span class='Ref_to_Proto'>XLogRecPtrToBytePos</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="xlog.c.html#LN1222"><span class='Ref_to_Parameter'>EndPos</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="xlog.c.html#LN1227"><span class='Ref_To_Local'>endbytepos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN921"><span class='Ref_to_Proto'>XLogRecPtrToBytePos</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="xlog.c.html#LN1223"><span class='Ref_to_Parameter'>PrevPtr</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="xlog.c.html#LN1228"><span class='Ref_To_Local'>prevbytepos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ReserveXLogInsertLocation &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Like ReserveXLogInsertLocation(), but for an xlog-switch record. 
 * 
 * A log-switch record is handled slightly differently. The rest of the 
 * segment will be reserved for this insertion, as indicated by the returned 
 * *EndPos value. However, if we are already at the beginning of the current 
 * segment, *StartPos and *EndPos are set to the current location without 
 * reserving any space, and the function returns false. 
*/ 
</span><span class='Keyword'>static bool 
</span><a name="LN1278"></a><span class='Declare_Function'>ReserveXLogSwitch</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>StartPos</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>EndPos</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>PrevPtr</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1280"></a>    <a href="xlog.c.html#LN514"><span class='Ref_to_Struct'>XLogCtlInsert</span></a> <span class='Operator'>*</span><span class='Declare_Local'>Insert</span> <span class='Operator'>= &</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN574"><span class='Ref_to_Member'>Insert</span></a><span class='Delimiter'>; 
</span><a name="LN1281"></a>    <a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a>      <span class='Declare_Local'>startbytepos</span><span class='Delimiter'>; 
</span><a name="LN1282"></a>    <a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a>      <span class='Declare_Local'>endbytepos</span><span class='Delimiter'>; 
</span><a name="LN1283"></a>    <a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a>      <span class='Declare_Local'>prevbytepos</span><span class='Delimiter'>; 
</span><a name="LN1284"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>size</span> <span class='Operator'>= </span><a href="../../../include/c.h.html#LN587"><span class='Ref_to_Macro'>MAXALIGN</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlogrecord.h.html#LN54"><span class='Ref_to_Const'>SizeOfXLogRecord</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1285"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>ptr</span><span class='Delimiter'>; 
</span><a name="LN1286"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>segleft</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * These calculations are a bit heavy-weight to be done while holding a 
     * spinlock, but since we're holding all the WAL insertion locks, there 
     * are no other inserters competing for it. GetXLogInsertRecPtr() does 
     * compete for it, but that's not called very frequently. 
     */ 
</span>    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN1280"><span class='Ref_To_Local'>Insert</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN516"><span class='Ref_to_Member'>insertpos_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="xlog.c.html#LN1281"><span class='Ref_To_Local'>startbytepos</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN1280"><span class='Ref_To_Local'>Insert</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN525"><span class='Ref_to_Member'>CurrBytePos</span></a><span class='Delimiter'>; 
</span> 
    <a href="xlog.c.html#LN1285"><span class='Ref_To_Local'>ptr</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN920"><span class='Ref_to_Proto'>XLogBytePosToEndRecPtr</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN1281"><span class='Ref_To_Local'>startbytepos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN1285"><span class='Ref_To_Local'>ptr</span></a> <span class='Operator'>% </span>XLOG_SEG_SIZE <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN1280"><span class='Ref_To_Local'>Insert</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN516"><span class='Ref_to_Member'>insertpos_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="xlog.c.html#LN1278"><span class='Ref_to_Parameter'>EndPos</span></a> <span class='Operator'>= *</span><a href="xlog.c.html#LN1278"><span class='Ref_to_Parameter'>StartPos</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN1285"><span class='Ref_To_Local'>ptr</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="xlog.c.html#LN1282"><span class='Ref_To_Local'>endbytepos</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN1281"><span class='Ref_To_Local'>startbytepos</span></a> <span class='Operator'>+ </span><a href="xlog.c.html#LN1284"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN1283"><span class='Ref_To_Local'>prevbytepos</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN1280"><span class='Ref_To_Local'>Insert</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN526"><span class='Ref_to_Member'>PrevBytePos</span></a><span class='Delimiter'>; 
</span> 
    <span class='Operator'>*</span><a href="xlog.c.html#LN1278"><span class='Ref_to_Parameter'>StartPos</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN919"><span class='Ref_to_Proto'>XLogBytePosToRecPtr</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN1281"><span class='Ref_To_Local'>startbytepos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="xlog.c.html#LN1278"><span class='Ref_to_Parameter'>EndPos</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN920"><span class='Ref_to_Proto'>XLogBytePosToEndRecPtr</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN1282"><span class='Ref_To_Local'>endbytepos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="xlog.c.html#LN1286"><span class='Ref_To_Local'>segleft</span></a> <span class='Operator'>= </span>XLOG_SEG_SIZE <span class='Operator'>- </span><span class='Parentheses'>((</span><span class='Operator'>*</span><a href="xlog.c.html#LN1278"><span class='Ref_to_Parameter'>EndPos</span></a><span class='Parentheses'>) </span><span class='Operator'>% </span>XLOG_SEG_SIZE<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN1286"><span class='Ref_To_Local'>segleft</span></a> <span class='Operator'>!= </span>XLOG_SEG_SIZE<span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* consume the rest of the segment */ 
</span>        <span class='Operator'>*</span><a href="xlog.c.html#LN1278"><span class='Ref_to_Parameter'>EndPos</span></a> <span class='Operator'>+= </span><a href="xlog.c.html#LN1286"><span class='Ref_To_Local'>segleft</span></a><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN1282"><span class='Ref_To_Local'>endbytepos</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN921"><span class='Ref_to_Proto'>XLogRecPtrToBytePos</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="xlog.c.html#LN1278"><span class='Ref_to_Parameter'>EndPos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="xlog.c.html#LN1280"><span class='Ref_To_Local'>Insert</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN525"><span class='Ref_to_Member'>CurrBytePos</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN1282"><span class='Ref_To_Local'>endbytepos</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN1280"><span class='Ref_To_Local'>Insert</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN526"><span class='Ref_to_Member'>PrevBytePos</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN1281"><span class='Ref_To_Local'>startbytepos</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN1280"><span class='Ref_To_Local'>Insert</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN516"><span class='Ref_to_Member'>insertpos_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Operator'>*</span><a href="xlog.c.html#LN1278"><span class='Ref_to_Parameter'>PrevPtr</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN919"><span class='Ref_to_Proto'>XLogBytePosToRecPtr</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN1283"><span class='Ref_To_Local'>prevbytepos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>((</span><span class='Operator'>*</span><a href="xlog.c.html#LN1278"><span class='Ref_to_Parameter'>EndPos</span></a><span class='Parentheses'>) </span><span class='Operator'>% </span>XLOG_SEG_SIZE <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN921"><span class='Ref_to_Proto'>XLogRecPtrToBytePos</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="xlog.c.html#LN1278"><span class='Ref_to_Parameter'>EndPos</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="xlog.c.html#LN1282"><span class='Ref_To_Local'>endbytepos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN921"><span class='Ref_to_Proto'>XLogRecPtrToBytePos</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="xlog.c.html#LN1278"><span class='Ref_to_Parameter'>StartPos</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="xlog.c.html#LN1281"><span class='Ref_To_Local'>startbytepos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN921"><span class='Ref_to_Proto'>XLogRecPtrToBytePos</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="xlog.c.html#LN1278"><span class='Ref_to_Parameter'>PrevPtr</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="xlog.c.html#LN1283"><span class='Ref_To_Local'>prevbytepos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ReserveXLogSwitch &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Checks whether the current buffer page and backup page stored in the 
 * WAL record are consistent or not. Before comparing the two pages, a 
 * masking can be applied to the pages to ignore certain areas like hint bits, 
 * unused space between pd_lower and pd_upper among other things. This 
 * function should be called once WAL replay has been completed for a 
 * given record. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1343"></a><span class='Declare_Function'>checkXLogConsistency</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogreader.h.html#LN68"><span class='Ref_to_Struct'>XLogReaderState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>record</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1345"></a>    <a href="../../../include/access/rmgr.h.html#LN10"><span class='Ref_to_Typedef'>RmgrId</span></a>      <span class='Declare_Local'>rmid</span> <span class='Operator'>= </span><a href="../../../include/access/xlogreader.h.html#LN216"><span class='Ref_to_Macro'>XLogRecGetRmid</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN1343"><span class='Ref_to_Parameter'>record</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1346"></a>    <a href="../../../include/storage/relfilenode.h.html#LN56"><span class='Ref_to_Struct'>RelFileNode</span></a> <span class='Declare_Local'>rnode</span><span class='Delimiter'>; 
</span><a name="LN1347"></a>    <a href="../../../include/common/relpath.h.html#LN23"><span class='Ref_to_Enum'>ForkNumber</span></a>  <span class='Declare_Local'>forknum</span><span class='Delimiter'>; 
</span><a name="LN1348"></a>    <a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Local'>blkno</span><span class='Delimiter'>; 
</span><a name="LN1349"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>block_id</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Records with no backup blocks have no need for consistency checks. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/xlogreader.h.html#LN221"><span class='Ref_to_Macro'>XLogRecHasAnyBlockRefs</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN1343"><span class='Ref_to_Parameter'>record</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>((</span><a href="../../../include/access/xlogreader.h.html#LN215"><span class='Ref_to_Macro'>XLogRecGetInfo</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN1343"><span class='Ref_to_Parameter'>record</span></a><span class='Parentheses'>) </span><span class='Operator'>& </span><a href="../../../include/access/xlogrecord.h.html#LN79"><span class='Ref_to_Const'>XLR_CHECK_CONSISTENCY</span></a><span class='Parentheses'>)</span> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN1349"><span class='Ref_To_Local'>block_id</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="xlog.c.html#LN1349"><span class='Ref_To_Local'>block_id</span></a> <span class='Operator'>&LT;= </span><a href="xlog.c.html#LN1343"><span class='Ref_to_Parameter'>record</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogreader.h.html#LN135"><span class='Ref_to_Member'>max_block_id</span></a><span class='Delimiter'>; </span><a href="xlog.c.html#LN1349"><span class='Ref_To_Local'>block_id</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1359"></a>        <a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a>      <span class='Declare_Local'>buf</span><span class='Delimiter'>; 
</span><a name="LN1360"></a>        <a href="../../../include/storage/bufpage.h.html#LN73"><span class='Ref_to_Typedef'>Page</span></a>        <span class='Declare_Local'>page</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/xlogreader.h.html#LN231"><span class='Ref_to_Proto'>XLogRecGetBlockTag</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN1343"><span class='Ref_to_Parameter'>record</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN1349"><span class='Ref_To_Local'>block_id</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN1346"><span class='Ref_To_Local'>rnode</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN1347"><span class='Ref_To_Local'>forknum</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN1348"><span class='Ref_To_Local'>blkno</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * WAL record doesn't contain a block reference with the given id. 
             * Do nothing. 
             */ 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogreader.h.html#LN224"><span class='Ref_to_Macro'>XLogRecHasBlockImage</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN1343"><span class='Ref_to_Parameter'>record</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN1349"><span class='Ref_To_Local'>block_id</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/xlogreader.h.html#LN226"><span class='Ref_to_Macro'>XLogRecBlockImageApply</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN1343"><span class='Ref_to_Parameter'>record</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN1349"><span class='Ref_To_Local'>block_id</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * WAL record has already applied the page, so bypass the 
             * consistency check as that would result in comparing the full 
             * page stored in the record with itself. 
             */ 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Read the contents from the current buffer and store it in a 
         * temporary page. 
         */ 
</span>        <a href="xlog.c.html#LN1359"><span class='Ref_To_Local'>buf</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlogutils.h.html#LN43"><span class='Ref_to_Proto'>XLogReadBufferExtended</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN1346"><span class='Ref_To_Local'>rnode</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN1347"><span class='Ref_To_Local'>forknum</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN1348"><span class='Ref_To_Local'>blkno</span></a><span class='Delimiter'>, 
</span>                                     <a href="../../../include/storage/bufmgr.h.html#LN45"><span class='Ref_to_EnumConst'>RBM_NORMAL_NO_LOG</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/storage/bufmgr.h.html#LN113"><span class='Ref_to_Macro'>BufferIsValid</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN1359"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/storage/bufmgr.h.html#LN214"><span class='Ref_to_Proto'>LockBuffer</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN1359"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/bufmgr.h.html#LN88"><span class='Ref_to_Const'>BUFFER_LOCK_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN1360"><span class='Ref_To_Local'>page</span></a> <span class='Operator'>= </span><a href="../../../include/storage/bufmgr.h.html#LN159"><span class='Ref_to_Macro'>BufferGetPage</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN1359"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Take a copy of the local page where WAL has been applied to have a 
         * comparison base before masking it... 
         */ 
</span>        memcpy<span class='Parentheses'>(</span><a href="xlog.c.html#LN252"><span class='Ref_to_Global_Var'>replay_image_masked</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN1360"><span class='Ref_To_Local'>page</span></a><span class='Delimiter'>, </span>BLCKSZ<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* No need for this page anymore now that a copy is in. */ 
</span>        <a href="../../../include/storage/bufmgr.h.html#LN175"><span class='Ref_to_Proto'>UnlockReleaseBuffer</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN1359"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If the block LSN is already ahead of this WAL record, we can't 
         * expect contents to match.  This can happen if recovery is 
         * restarted. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/bufpage.h.html#LN362"><span class='Ref_to_Macro'>PageGetLSN</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN252"><span class='Ref_to_Global_Var'>replay_image_masked</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT; </span><a href="xlog.c.html#LN1343"><span class='Ref_to_Parameter'>record</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogreader.h.html#LN114"><span class='Ref_to_Member'>EndRecPtr</span></a><span class='Parentheses'>)</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Read the contents from the backup copy, stored in WAL record and 
         * store it in a temporary page. There is no need to allocate a new 
         * page here, a local buffer is fine to hold its contents and a mask 
         * can be directly applied on it. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/xlogreader.h.html#LN229"><span class='Ref_to_Proto'>RestoreBlockImage</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN1343"><span class='Ref_to_Parameter'>record</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN1349"><span class='Ref_To_Local'>block_id</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN253"><span class='Ref_to_Global_Var'>master_image_masked</span></a><span class='Parentheses'>))</span> 
            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"failed to restore block image"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If masking function is defined, mask both the master and replay 
         * images 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="rmgr.c.html#LN35"><span class='Ref_to_Global_Var'>RmgrTable</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN1345"><span class='Ref_To_Local'>rmid</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/access/xlog_internal.h.html#LN281"><span class='Ref_to_Member'>rm_mask</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="rmgr.c.html#LN35"><span class='Ref_to_Global_Var'>RmgrTable</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN1345"><span class='Ref_To_Local'>rmid</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/access/xlog_internal.h.html#LN281"><span class='Ref_to_Member'>rm_mask</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN252"><span class='Ref_to_Global_Var'>replay_image_masked</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN1348"><span class='Ref_To_Local'>blkno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="rmgr.c.html#LN35"><span class='Ref_to_Global_Var'>RmgrTable</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN1345"><span class='Ref_To_Local'>rmid</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/access/xlog_internal.h.html#LN281"><span class='Ref_to_Member'>rm_mask</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN253"><span class='Ref_to_Global_Var'>master_image_masked</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN1348"><span class='Ref_To_Local'>blkno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* Time to compare the master and replay images. */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span>memcmp<span class='Parentheses'>(</span><a href="xlog.c.html#LN252"><span class='Ref_to_Global_Var'>replay_image_masked</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN253"><span class='Ref_to_Global_Var'>master_image_masked</span></a><span class='Delimiter'>, </span>BLCKSZ<span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>               <span class='String'>"inconsistent page found, rel %u/%u/%u, forknum %u, blkno %u"</span><span class='Delimiter'>, 
</span>                 <a href="xlog.c.html#LN1346"><span class='Ref_To_Local'>rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN58"><span class='Ref_to_Member'>spcNode</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN1346"><span class='Ref_To_Local'>rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN59"><span class='Ref_to_Member'>dbNode</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN1346"><span class='Ref_To_Local'>rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN60"><span class='Ref_to_Member'>relNode</span></a><span class='Delimiter'>, 
</span>                 <a href="xlog.c.html#LN1347"><span class='Ref_To_Local'>forknum</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN1348"><span class='Ref_To_Local'>blkno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for block_id=0;block_id&LT;=... &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end checkXLogConsistency &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Subroutine of XLogInsertRecord.  Copies a WAL record to an already-reserved 
 * area in the WAL. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1447"></a><span class='Declare_Function'>CopyXLogRecordToWAL</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>write_len</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>isLogSwitch</span><span class='Delimiter'>, </span><a href="../../../include/access/xlog_internal.h.html#LN240"><span class='Ref_to_Struct'>XLogRecData</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rdata</span><span class='Delimiter'>, 
</span><a name="LN1448"></a>                    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>StartPos</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>EndPos</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1450"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>currpos</span><span class='Delimiter'>; 
</span><a name="LN1451"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>freespace</span><span class='Delimiter'>; 
</span><a name="LN1452"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>written</span><span class='Delimiter'>; 
</span><a name="LN1453"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>CurrPos</span><span class='Delimiter'>; 
</span><a name="LN1454"></a>    <a href="../../../include/access/xlog_internal.h.html#LN56"><span class='Ref_to_Typedef'>XLogPageHeader</span></a> <span class='Declare_Local'>pagehdr</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Get a pointer to the right place in the right WAL buffer to start 
     * inserting to. 
     */ 
</span>    <a href="xlog.c.html#LN1453"><span class='Ref_To_Local'>CurrPos</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN1448"><span class='Ref_to_Parameter'>StartPos</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN1450"><span class='Ref_To_Local'>currpos</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN918"><span class='Ref_to_Proto'>GetXLogBuffer</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN1453"><span class='Ref_To_Local'>CurrPos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN1451"><span class='Ref_To_Local'>freespace</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN719"><span class='Ref_to_Macro'>INSERT_FREESPACE</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN1453"><span class='Ref_To_Local'>CurrPos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * there should be enough space for at least the first field (xl_tot_len) 
     * on this page. 
     */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN1451"><span class='Ref_To_Local'>freespace</span></a> <span class='Operator'>&GT;= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Copy record data */ 
</span>    <a href="xlog.c.html#LN1452"><span class='Ref_To_Local'>written</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN1447"><span class='Ref_to_Parameter'>rdata</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1474"></a>        <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>rdata_data</span> <span class='Operator'>= </span><a href="xlog.c.html#LN1447"><span class='Ref_to_Parameter'>rdata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlog_internal.h.html#LN243"><span class='Ref_to_Member'>data</span></a><span class='Delimiter'>; 
</span><a name="LN1475"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>rdata_len</span> <span class='Operator'>= </span><a href="xlog.c.html#LN1447"><span class='Ref_to_Parameter'>rdata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlog_internal.h.html#LN244"><span class='Ref_to_Member'>len</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN1475"><span class='Ref_To_Local'>rdata_len</span></a> <span class='Operator'>&GT; </span><a href="xlog.c.html#LN1451"><span class='Ref_To_Local'>freespace</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Write what fits on this page, and continue on the next page. 
             */ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN1453"><span class='Ref_To_Local'>CurrPos</span></a> <span class='Operator'>% </span>XLOG_BLCKSZ <span class='Operator'>&GT;= </span><a href="../../../include/access/xlog_internal.h.html#LN54"><span class='Ref_to_Const'>SizeOfXLogShortPHD</span></a> <span class='Operator'>|| </span><a href="xlog.c.html#LN1451"><span class='Ref_To_Local'>freespace</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            memcpy<span class='Parentheses'>(</span><a href="xlog.c.html#LN1450"><span class='Ref_To_Local'>currpos</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN1474"><span class='Ref_To_Local'>rdata_data</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN1451"><span class='Ref_To_Local'>freespace</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN1474"><span class='Ref_To_Local'>rdata_data</span></a> <span class='Operator'>+= </span><a href="xlog.c.html#LN1451"><span class='Ref_To_Local'>freespace</span></a><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN1475"><span class='Ref_To_Local'>rdata_len</span></a> <span class='Operator'>-= </span><a href="xlog.c.html#LN1451"><span class='Ref_To_Local'>freespace</span></a><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN1452"><span class='Ref_To_Local'>written</span></a> <span class='Operator'>+= </span><a href="xlog.c.html#LN1451"><span class='Ref_To_Local'>freespace</span></a><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN1453"><span class='Ref_To_Local'>CurrPos</span></a> <span class='Operator'>+= </span><a href="xlog.c.html#LN1451"><span class='Ref_To_Local'>freespace</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Get pointer to beginning of next page, and set the xlp_rem_len 
             * in the page header. Set XLP_FIRST_IS_CONTRECORD. 
             * 
             * It's safe to set the contrecord flag and xlp_rem_len without a 
             * lock on the page. All the other flags were already set when the 
             * page was initialized, in AdvanceXLInsertBuffer, and we're the 
             * only backend that needs to set the contrecord flag. 
             */ 
</span>            <a href="xlog.c.html#LN1450"><span class='Ref_To_Local'>currpos</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN918"><span class='Ref_to_Proto'>GetXLogBuffer</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN1453"><span class='Ref_To_Local'>CurrPos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN1454"><span class='Ref_To_Local'>pagehdr</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/xlog_internal.h.html#LN56"><span class='Ref_to_Typedef'>XLogPageHeader</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN1450"><span class='Ref_To_Local'>currpos</span></a><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN1454"><span class='Ref_To_Local'>pagehdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlog_internal.h.html#LN51"><span class='Ref_to_Member'>xlp_rem_len</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN1447"><span class='Ref_to_Parameter'>write_len</span></a> <span class='Operator'>- </span><a href="xlog.c.html#LN1452"><span class='Ref_To_Local'>written</span></a><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN1454"><span class='Ref_To_Local'>pagehdr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlog_internal.h.html#LN38"><span class='Ref_to_Member'>xlp_info</span></a> <span class='Operator'>|= </span><a href="../../../include/access/xlog_internal.h.html#LN76"><span class='Ref_to_Const'>XLP_FIRST_IS_CONTRECORD</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* skip over the page header */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN1453"><span class='Ref_To_Local'>CurrPos</span></a> <span class='Operator'>% </span><a href="../../../include/access/xlog_internal.h.html#LN91"><span class='Ref_to_Const'>XLogSegSize</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="xlog.c.html#LN1453"><span class='Ref_To_Local'>CurrPos</span></a> <span class='Operator'>+= </span><a href="../../../include/access/xlog_internal.h.html#LN71"><span class='Ref_to_Const'>SizeOfXLogLongPHD</span></a><span class='Delimiter'>; 
</span>                <a href="xlog.c.html#LN1450"><span class='Ref_To_Local'>currpos</span></a> <span class='Operator'>+= </span><a href="../../../include/access/xlog_internal.h.html#LN71"><span class='Ref_to_Const'>SizeOfXLogLongPHD</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <a href="xlog.c.html#LN1453"><span class='Ref_To_Local'>CurrPos</span></a> <span class='Operator'>+= </span><a href="../../../include/access/xlog_internal.h.html#LN54"><span class='Ref_to_Const'>SizeOfXLogShortPHD</span></a><span class='Delimiter'>; 
</span>                <a href="xlog.c.html#LN1450"><span class='Ref_To_Local'>currpos</span></a> <span class='Operator'>+= </span><a href="../../../include/access/xlog_internal.h.html#LN54"><span class='Ref_to_Const'>SizeOfXLogShortPHD</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <a href="xlog.c.html#LN1451"><span class='Ref_To_Local'>freespace</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN719"><span class='Ref_to_Macro'>INSERT_FREESPACE</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN1453"><span class='Ref_To_Local'>CurrPos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while rdata_len&GT;freespace &raquo; </span> 
 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN1453"><span class='Ref_To_Local'>CurrPos</span></a> <span class='Operator'>% </span>XLOG_BLCKSZ <span class='Operator'>&GT;= </span><a href="../../../include/access/xlog_internal.h.html#LN54"><span class='Ref_to_Const'>SizeOfXLogShortPHD</span></a> <span class='Operator'>|| </span><a href="xlog.c.html#LN1475"><span class='Ref_To_Local'>rdata_len</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        memcpy<span class='Parentheses'>(</span><a href="xlog.c.html#LN1450"><span class='Ref_To_Local'>currpos</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN1474"><span class='Ref_To_Local'>rdata_data</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN1475"><span class='Ref_To_Local'>rdata_len</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN1450"><span class='Ref_To_Local'>currpos</span></a> <span class='Operator'>+= </span><a href="xlog.c.html#LN1475"><span class='Ref_To_Local'>rdata_len</span></a><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN1453"><span class='Ref_To_Local'>CurrPos</span></a> <span class='Operator'>+= </span><a href="xlog.c.html#LN1475"><span class='Ref_To_Local'>rdata_len</span></a><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN1451"><span class='Ref_To_Local'>freespace</span></a> <span class='Operator'>-= </span><a href="xlog.c.html#LN1475"><span class='Ref_To_Local'>rdata_len</span></a><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN1452"><span class='Ref_To_Local'>written</span></a> <span class='Operator'>+= </span><a href="xlog.c.html#LN1475"><span class='Ref_To_Local'>rdata_len</span></a><span class='Delimiter'>; 
</span> 
        <a href="xlog.c.html#LN1447"><span class='Ref_to_Parameter'>rdata</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN1447"><span class='Ref_to_Parameter'>rdata</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlog_internal.h.html#LN242"><span class='Ref_to_Member'>next</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while rdata!=NULL &raquo; </span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN1452"><span class='Ref_To_Local'>written</span></a> <span class='Operator'>== </span><a href="xlog.c.html#LN1447"><span class='Ref_to_Parameter'>write_len</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If this was an xlog-switch, it's not enough to write the switch record, 
     * we also have to consume all the remaining space in the WAL segment. We 
     * have already reserved it for us, but we still need to make sure it's 
     * allocated and zeroed in the WAL buffers so that when the caller (or 
     * someone else) does XLogWrite(), it can really write out all the zeros. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN1447"><span class='Ref_to_Parameter'>isLogSwitch</span></a> <span class='Operator'>&& </span><a href="xlog.c.html#LN1453"><span class='Ref_To_Local'>CurrPos</span></a> <span class='Operator'>% </span>XLOG_SEG_SIZE <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* An xlog-switch record doesn't contain any data besides the header */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN1447"><span class='Ref_to_Parameter'>write_len</span></a> <span class='Operator'>== </span><a href="../../../include/access/xlogrecord.h.html#LN54"><span class='Ref_to_Const'>SizeOfXLogRecord</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We do this one page at a time, to make sure we don't deadlock 
         * against ourselves if wal_buffers &LT; XLOG_SEG_SIZE. 
         */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN1448"><span class='Ref_to_Parameter'>EndPos</span></a> <span class='Operator'>% </span><a href="../../../include/access/xlog_internal.h.html#LN91"><span class='Ref_to_Const'>XLogSegSize</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Use up all the remaining space on the first page */ 
</span>        <a href="xlog.c.html#LN1453"><span class='Ref_To_Local'>CurrPos</span></a> <span class='Operator'>+= </span><a href="xlog.c.html#LN1451"><span class='Ref_To_Local'>freespace</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN1453"><span class='Ref_To_Local'>CurrPos</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN1448"><span class='Ref_to_Parameter'>EndPos</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* initialize the next page (if not initialized already) */ 
</span>            <a href="xlog.c.html#LN927"><span class='Ref_to_Proto'>WALInsertLockUpdateInsertingAt</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN1453"><span class='Ref_To_Local'>CurrPos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN863"><span class='Ref_to_Proto'>AdvanceXLInsertBuffer</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN1453"><span class='Ref_To_Local'>CurrPos</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN1453"><span class='Ref_To_Local'>CurrPos</span></a> <span class='Operator'>+= </span>XLOG_BLCKSZ<span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if isLogSwitch&&CurrPos%... &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Align the end position, so that the next record starts aligned */ 
</span>        <a href="xlog.c.html#LN1453"><span class='Ref_To_Local'>CurrPos</span></a> <span class='Operator'>= </span><a href="../../../include/c.h.html#LN611"><span class='Ref_to_Macro'>MAXALIGN64</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN1453"><span class='Ref_To_Local'>CurrPos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN1453"><span class='Ref_To_Local'>CurrPos</span></a> <span class='Operator'>!= </span><a href="xlog.c.html#LN1448"><span class='Ref_to_Parameter'>EndPos</span></a><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, </span><span class='String'>"space reserved for WAL record does not match what was written"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end CopyXLogRecordToWAL &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Acquire a WAL insertion lock, for inserting to WAL. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1571"></a><span class='Declare_Function'>WALInsertLockAcquire</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1573"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>immed</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * It doesn't matter which of the WAL insertion locks we acquire, so try 
     * the one we used last time.  If the system isn't particularly busy, it's 
     * a good bet that it's still available, and it's good to have some 
     * affinity to a particular lock so that you don't unnecessarily bounce 
     * cache lines between processes when there's no contention. 
     * 
     * If this is the first time through in this backend, pick a lock 
     * (semi-)randomly.  This allows the locks to be used evenly if you have a 
     * lot of very short connections. 
     */ 
</span><a name="LN1586"></a>    <span class='Keyword'>static int</span>  <span class='Declare_Local'>lockToTry</span> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN1586"><span class='Ref_To_Local'>lockToTry</span></a> <span class='Operator'>== -</span><span class='Number'>1</span><span class='Parentheses'>) 
</span>        <a href="xlog.c.html#LN1586"><span class='Ref_To_Local'>lockToTry</span></a> <span class='Operator'>= </span><a href="../../storage/lmgr/proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN108"><span class='Ref_to_Member'>pgprocno</span></a> <span class='Operator'>% </span><a href="xlog.c.html#LN117"><span class='Ref_to_Const'>NUM_XLOGINSERT_LOCKS</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN838"><span class='Ref_to_Global_Var'>MyLockNo</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN1586"><span class='Ref_To_Local'>lockToTry</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * The insertingAt value is initially set to 0, as we don't know our 
     * insert location yet. 
     */ 
</span>    <a href="xlog.c.html#LN1573"><span class='Ref_To_Local'>immed</span></a> <span class='Operator'>= </span><a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN708"><span class='Ref_to_Global_Var'>WALInsertLocks</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN838"><span class='Ref_to_Global_Var'>MyLockNo</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="xlog.c.html#LN478"><span class='Ref_to_Member'>l</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN464"><span class='Ref_to_Member'>lock</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN1573"><span class='Ref_To_Local'>immed</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * If we couldn't get the lock immediately, try another lock next 
         * time.  On a system with more insertion locks than concurrent 
         * inserters, this causes all the inserters to eventually migrate to a 
         * lock that no-one else is using.  On a system with more inserters 
         * than locks, it still helps to distribute the inserters evenly 
         * across the locks. 
         */ 
</span>        <a href="xlog.c.html#LN1586"><span class='Ref_To_Local'>lockToTry</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="xlog.c.html#LN1586"><span class='Ref_To_Local'>lockToTry</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>) </span><span class='Operator'>% </span><a href="xlog.c.html#LN117"><span class='Ref_to_Const'>NUM_XLOGINSERT_LOCKS</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end WALInsertLockAcquire &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Acquire all WAL insertion locks, to prevent other backends from inserting 
 * to WAL. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1616"></a><span class='Declare_Function'>WALInsertLockAcquireExclusive</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1618"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * When holding all the locks, all but the last lock's insertingAt 
     * indicator is set to 0xFFFFFFFFFFFFFFFF, which is higher than any real 
     * XLogRecPtr value, to make sure that no-one blocks waiting on those. 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN1618"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="xlog.c.html#LN1618"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN117"><span class='Ref_to_Const'>NUM_XLOGINSERT_LOCKS</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="xlog.c.html#LN1618"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN708"><span class='Ref_to_Global_Var'>WALInsertLocks</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN1618"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="xlog.c.html#LN478"><span class='Ref_to_Member'>l</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN464"><span class='Ref_to_Member'>lock</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/lwlock.h.html#LN155"><span class='Ref_to_Proto'>LWLockUpdateVar</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN708"><span class='Ref_to_Global_Var'>WALInsertLocks</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN1618"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="xlog.c.html#LN478"><span class='Ref_to_Member'>l</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN464"><span class='Ref_to_Member'>lock</span></a><span class='Delimiter'>, 
</span>                        <span class='Operator'>&</span><a href="xlog.c.html#LN708"><span class='Ref_to_Global_Var'>WALInsertLocks</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN1618"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="xlog.c.html#LN478"><span class='Ref_to_Member'>l</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN465"><span class='Ref_to_Member'>insertingAt</span></a><span class='Delimiter'>, 
</span>                        <a href="../../../include/c.h.html#LN343"><span class='Ref_to_Const'>PG_UINT64_MAX</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Comment_Multi_Line'>/* Variable value reset to 0 at release */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN708"><span class='Ref_to_Global_Var'>WALInsertLocks</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN1618"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="xlog.c.html#LN478"><span class='Ref_to_Member'>l</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN464"><span class='Ref_to_Member'>lock</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="xlog.c.html#LN839"><span class='Ref_to_Global_Var'>holdingAllLocks</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end WALInsertLockAcquireExclusive &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Release our insertion lock (or locks, if we're holding them all). 
 * 
 * NB: Reset all variables to 0, so they cause LWLockWaitForVar to block the 
 * next time the lock is acquired. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1645"></a><span class='Declare_Function'>WALInsertLockRelease</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN839"><span class='Ref_to_Global_Var'>holdingAllLocks</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1649"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN1649"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="xlog.c.html#LN1649"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN117"><span class='Ref_to_Const'>NUM_XLOGINSERT_LOCKS</span></a><span class='Delimiter'>; </span><a href="xlog.c.html#LN1649"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>            <a href="../../../include/storage/lwlock.h.html#LN149"><span class='Ref_to_Proto'>LWLockReleaseClearVar</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN708"><span class='Ref_to_Global_Var'>WALInsertLocks</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN1649"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="xlog.c.html#LN478"><span class='Ref_to_Member'>l</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN464"><span class='Ref_to_Member'>lock</span></a><span class='Delimiter'>, 
</span>                                  <span class='Operator'>&</span><a href="xlog.c.html#LN708"><span class='Ref_to_Global_Var'>WALInsertLocks</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN1649"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="xlog.c.html#LN478"><span class='Ref_to_Member'>l</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN465"><span class='Ref_to_Member'>insertingAt</span></a><span class='Delimiter'>, 
</span>                                  <span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="xlog.c.html#LN839"><span class='Ref_to_Global_Var'>holdingAllLocks</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../include/storage/lwlock.h.html#LN149"><span class='Ref_to_Proto'>LWLockReleaseClearVar</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN708"><span class='Ref_to_Global_Var'>WALInsertLocks</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN838"><span class='Ref_to_Global_Var'>MyLockNo</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="xlog.c.html#LN478"><span class='Ref_to_Member'>l</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN464"><span class='Ref_to_Member'>lock</span></a><span class='Delimiter'>, 
</span>                              <span class='Operator'>&</span><a href="xlog.c.html#LN708"><span class='Ref_to_Global_Var'>WALInsertLocks</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN838"><span class='Ref_to_Global_Var'>MyLockNo</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="xlog.c.html#LN478"><span class='Ref_to_Member'>l</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN465"><span class='Ref_to_Member'>insertingAt</span></a><span class='Delimiter'>, 
</span>                              <span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end WALInsertLockRelease &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Update our insertingAt value, to let others know that we've finished 
 * inserting up to that point. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1671"></a><span class='Declare_Function'>WALInsertLockUpdateInsertingAt</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>insertingAt</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN839"><span class='Ref_to_Global_Var'>holdingAllLocks</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * We use the last lock to mark our actual position, see comments in 
         * WALInsertLockAcquireExclusive. 
         */ 
</span>        <a href="../../../include/storage/lwlock.h.html#LN155"><span class='Ref_to_Proto'>LWLockUpdateVar</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN708"><span class='Ref_to_Global_Var'>WALInsertLocks</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN117"><span class='Ref_to_Const'>NUM_XLOGINSERT_LOCKS</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="xlog.c.html#LN478"><span class='Ref_to_Member'>l</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN464"><span class='Ref_to_Member'>lock</span></a><span class='Delimiter'>, 
</span>                     <span class='Operator'>&</span><a href="xlog.c.html#LN708"><span class='Ref_to_Global_Var'>WALInsertLocks</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN117"><span class='Ref_to_Const'>NUM_XLOGINSERT_LOCKS</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="xlog.c.html#LN478"><span class='Ref_to_Member'>l</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN465"><span class='Ref_to_Member'>insertingAt</span></a><span class='Delimiter'>, 
</span>                        <a href="xlog.c.html#LN1671"><span class='Ref_to_Parameter'>insertingAt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
        <a href="../../../include/storage/lwlock.h.html#LN155"><span class='Ref_to_Proto'>LWLockUpdateVar</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN708"><span class='Ref_to_Global_Var'>WALInsertLocks</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN838"><span class='Ref_to_Global_Var'>MyLockNo</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="xlog.c.html#LN478"><span class='Ref_to_Member'>l</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN464"><span class='Ref_to_Member'>lock</span></a><span class='Delimiter'>, 
</span>                        <span class='Operator'>&</span><a href="xlog.c.html#LN708"><span class='Ref_to_Global_Var'>WALInsertLocks</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN838"><span class='Ref_to_Global_Var'>MyLockNo</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="xlog.c.html#LN478"><span class='Ref_to_Member'>l</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN465"><span class='Ref_to_Member'>insertingAt</span></a><span class='Delimiter'>, 
</span>                        <a href="xlog.c.html#LN1671"><span class='Ref_to_Parameter'>insertingAt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Wait for any WAL insertions &LT; upto to finish. 
 * 
 * Returns the location of the oldest insertion that is still in-progress. 
 * Any WAL prior to that point has been fully copied into WAL buffers, and 
 * can be flushed out to disk. Because this waits for any insertions older 
 * than 'upto' to finish, the return value is always &GT;= 'upto'. 
 * 
 * Note: When you are about to write out WAL, you must call this function 
 * *before* acquiring WALWriteLock, to avoid deadlocks. This function might 
 * need to wait for an insertion to finish (or at least advance to next 
 * uninitialized page), and the inserter might need to evict an old WAL buffer 
 * to make room for a new one, which in turn requires WALWriteLock. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> 
<a name="LN1704"></a><span class='Declare_Function'>WaitXLogInsertionsToFinish</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>upto</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1706"></a>    <a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a>      <span class='Declare_Local'>bytepos</span><span class='Delimiter'>; 
</span><a name="LN1707"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>reservedUpto</span><span class='Delimiter'>; 
</span><a name="LN1708"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>finishedUpto</span><span class='Delimiter'>; 
</span><a name="LN1709"></a>    <a href="xlog.c.html#LN514"><span class='Ref_to_Struct'>XLogCtlInsert</span></a> <span class='Operator'>*</span><span class='Declare_Local'>Insert</span> <span class='Operator'>= &</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN574"><span class='Ref_to_Member'>Insert</span></a><span class='Delimiter'>; 
</span><a name="LN1710"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../storage/lmgr/proc.c.html#LN66"><span class='Ref_to_Global_Var'>MyProc</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, </span><span class='String'>"cannot wait without a PGPROC structure"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Read the current insert position */ 
</span>    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN1709"><span class='Ref_To_Local'>Insert</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN516"><span class='Ref_to_Member'>insertpos_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN1706"><span class='Ref_To_Local'>bytepos</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN1709"><span class='Ref_To_Local'>Insert</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN525"><span class='Ref_to_Member'>CurrBytePos</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN1709"><span class='Ref_To_Local'>Insert</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN516"><span class='Ref_to_Member'>insertpos_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN1707"><span class='Ref_To_Local'>reservedUpto</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN920"><span class='Ref_to_Proto'>XLogBytePosToEndRecPtr</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN1706"><span class='Ref_To_Local'>bytepos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * No-one should request to flush a piece of WAL that hasn't even been 
     * reserved yet. However, it can happen if there is a block with a bogus 
     * LSN on disk, for example. XLogFlush checks for that situation and 
     * complains, but only after the flush. Here we just assume that to mean 
     * that all WAL that has been reserved needs to be finished. In this 
     * corner-case, the return value can be smaller than 'upto' argument. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN1704"><span class='Ref_to_Parameter'>upto</span></a> <span class='Operator'>&GT; </span><a href="xlog.c.html#LN1707"><span class='Ref_To_Local'>reservedUpto</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, </span><span class='String'>"request to flush past end of generated WAL; request %X/%X, currpos %X/%X"</span><span class='Delimiter'>, 
</span>             <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN1704"><span class='Ref_to_Parameter'>upto</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN1704"><span class='Ref_to_Parameter'>upto</span></a><span class='Delimiter'>, 
</span>             <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN1707"><span class='Ref_To_Local'>reservedUpto</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN1707"><span class='Ref_To_Local'>reservedUpto</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN1704"><span class='Ref_to_Parameter'>upto</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN1707"><span class='Ref_To_Local'>reservedUpto</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Loop through all the locks, sleeping on any in-progress insert older 
     * than 'upto'. 
     * 
     * finishedUpto is our return value, indicating the point upto which all 
     * the WAL insertions have been finished. Initialize it to the head of 
     * reserved WAL, and as we iterate through the insertion locks, back it 
     * out for any insertion that's still in progress. 
     */ 
</span>    <a href="xlog.c.html#LN1708"><span class='Ref_To_Local'>finishedUpto</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN1707"><span class='Ref_To_Local'>reservedUpto</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN1710"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="xlog.c.html#LN1710"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN117"><span class='Ref_to_Const'>NUM_XLOGINSERT_LOCKS</span></a><span class='Delimiter'>; </span><a href="xlog.c.html#LN1710"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1749"></a>        <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>insertingat</span> <span class='Operator'>= </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>do</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * See if this insertion is in progress. LWLockWait will wait for 
             * the lock to be released, or for the 'value' to be set by a 
             * LWLockUpdateVar call.  When a lock is initially acquired, its 
             * value is 0 (InvalidXLogRecPtr), which means that we don't know 
             * where it's inserting yet.  We will have to wait for it.  If 
             * it's a small insertion, the record will most likely fit on the 
             * same page and the inserter will release the lock without ever 
             * calling LWLockUpdateVar.  But if it has to sleep, it will 
             * advertise the insertion point with LWLockUpdateVar before 
             * sleeping. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN154"><span class='Ref_to_Proto'>LWLockWaitForVar</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN708"><span class='Ref_to_Global_Var'>WALInsertLocks</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN1710"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="xlog.c.html#LN478"><span class='Ref_to_Member'>l</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN464"><span class='Ref_to_Member'>lock</span></a><span class='Delimiter'>, 
</span>                                 <span class='Operator'>&</span><a href="xlog.c.html#LN708"><span class='Ref_to_Global_Var'>WALInsertLocks</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN1710"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="xlog.c.html#LN478"><span class='Ref_to_Member'>l</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN465"><span class='Ref_to_Member'>insertingAt</span></a><span class='Delimiter'>, 
</span>                                 <a href="xlog.c.html#LN1749"><span class='Ref_To_Local'>insertingat</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN1749"><span class='Ref_To_Local'>insertingat</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* the lock was free, so no insertion in progress */ 
</span>                <a href="xlog.c.html#LN1749"><span class='Ref_To_Local'>insertingat</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * This insertion is still in progress. Have to wait, unless the 
             * inserter has proceeded past 'upto'. 
             */ 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end do &raquo; </span> <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN1749"><span class='Ref_To_Local'>insertingat</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN1704"><span class='Ref_to_Parameter'>upto</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN1749"><span class='Ref_To_Local'>insertingat</span></a> <span class='Operator'>!= </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a> <span class='Operator'>&& </span><a href="xlog.c.html#LN1749"><span class='Ref_To_Local'>insertingat</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN1708"><span class='Ref_To_Local'>finishedUpto</span></a><span class='Parentheses'>) 
</span>            <a href="xlog.c.html#LN1708"><span class='Ref_To_Local'>finishedUpto</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN1749"><span class='Ref_To_Local'>insertingat</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;NUM_XLOGINSERT_... &raquo; </span> 
    <span class='Control'>return</span> <a href="xlog.c.html#LN1708"><span class='Ref_To_Local'>finishedUpto</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end WaitXLogInsertionsToFinish &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Get a pointer to the right location in the WAL buffer containing the 
 * given XLogRecPtr. 
 * 
 * If the page is not initialized yet, it is initialized. That might require 
 * evicting an old dirty buffer from the buffer cache, which means I/O. 
 * 
 * The caller must ensure that the page containing the requested location 
 * isn't evicted yet, and won't be evicted. The way to ensure that is to 
 * hold onto a WAL insertion lock with the insertingAt position set to 
 * something &LT;= ptr. GetXLogBuffer() will update insertingAt if it needs 
 * to evict an old page from the buffer. (This means that once you call 
 * GetXLogBuffer() with a given 'ptr', you must not access anything before 
 * that point anymore, and must not call GetXLogBuffer() with an older 'ptr' 
 * later, because older buffers might be recycled already) 
 */ 
</span><span class='Keyword'>static char </span><span class='Operator'>* 
</span><a name="LN1803"></a><span class='Declare_Function'>GetXLogBuffer</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>ptr</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1805"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>idx</span><span class='Delimiter'>; 
</span><a name="LN1806"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>endptr</span><span class='Delimiter'>; 
</span><a name="LN1807"></a>    <span class='Keyword'>static </span><a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a> <span class='Declare_Local'>cachedPage</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN1808"></a>    <span class='Keyword'>static char </span><span class='Operator'>*</span><span class='Declare_Local'>cachedPos</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN1809"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>expectedEndPtr</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Fast path for the common case that we need to access again the same 
     * page as last time. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN1803"><span class='Ref_to_Parameter'>ptr</span></a> <span class='Operator'>/ </span>XLOG_BLCKSZ <span class='Operator'>== </span><a href="xlog.c.html#LN1807"><span class='Ref_To_Local'>cachedPage</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(((</span><a href="../../../include/access/xlog_internal.h.html#LN56"><span class='Ref_to_Typedef'>XLogPageHeader</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN1808"><span class='Ref_To_Local'>cachedPos</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>xlp_magic <span class='Operator'>== </span><a href="../../../include/access/xlog_internal.h.html#LN33"><span class='Ref_to_Const'>XLOG_PAGE_MAGIC</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(((</span><a href="../../../include/access/xlog_internal.h.html#LN56"><span class='Ref_to_Typedef'>XLogPageHeader</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN1808"><span class='Ref_To_Local'>cachedPos</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>xlp_pageaddr <span class='Operator'>== </span><a href="xlog.c.html#LN1803"><span class='Ref_to_Parameter'>ptr</span></a> <span class='Operator'>- </span><span class='Parentheses'>(</span><a href="xlog.c.html#LN1803"><span class='Ref_to_Parameter'>ptr</span></a> <span class='Operator'>% </span>XLOG_BLCKSZ<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <a href="xlog.c.html#LN1808"><span class='Ref_To_Local'>cachedPos</span></a> <span class='Operator'>+ </span><a href="xlog.c.html#LN1803"><span class='Ref_to_Parameter'>ptr</span></a> <span class='Operator'>% </span>XLOG_BLCKSZ<span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * The XLog buffer cache is organized so that a page is always loaded to a 
     * particular buffer.  That way we can easily calculate the buffer a given 
     * page must be loaded into, from the XLogRecPtr alone. 
     */ 
</span>    <a href="xlog.c.html#LN1805"><span class='Ref_To_Local'>idx</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN730"><span class='Ref_to_Macro'>XLogRecPtrToBufIdx</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN1803"><span class='Ref_to_Parameter'>ptr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * See what page is loaded in the buffer at the moment. It could be the 
     * page we're looking for, or something older. It can't be anything newer 
     * - that would imply the page we're looking for has already been written 
     * out to disk and evicted, and the caller is responsible for making sure 
     * that doesn't happen. 
     * 
     * However, we don't hold a lock while we read the value. If someone has 
     * just initialized the page, it's possible that we get a "torn read" of 
     * the XLogRecPtr if 64-bit fetches are not atomic on this platform. In 
     * that case we will see a bogus value. That's ok, we'll grab the mapping 
     * lock (in AdvanceXLInsertBuffer) and retry if we see anything else than 
     * the page we're looking for. But it means that when we do this unlocked 
     * read, we might see a value that appears to be ahead of the page we're 
     * looking for. Don't PANIC on that, until we've verified the value while 
     * holding the lock. 
     */ 
</span>    <a href="xlog.c.html#LN1809"><span class='Ref_To_Local'>expectedEndPtr</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN1803"><span class='Ref_to_Parameter'>ptr</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN1809"><span class='Ref_To_Local'>expectedEndPtr</span></a> <span class='Operator'>+= </span>XLOG_BLCKSZ <span class='Operator'>- </span><a href="xlog.c.html#LN1803"><span class='Ref_to_Parameter'>ptr</span></a> <span class='Operator'>% </span>XLOG_BLCKSZ<span class='Delimiter'>; 
</span> 
    <a href="xlog.c.html#LN1806"><span class='Ref_To_Local'>endptr</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN619"><span class='Ref_to_Member'>xlblocks</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN1805"><span class='Ref_To_Local'>idx</span></a><span class='Delimiter'>]; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN1809"><span class='Ref_To_Local'>expectedEndPtr</span></a> <span class='Operator'>!= </span><a href="xlog.c.html#LN1806"><span class='Ref_To_Local'>endptr</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1852"></a>        <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>initializedUpto</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Before calling AdvanceXLInsertBuffer(), which can block, let others 
         * know how far we're finished with inserting the record. 
         * 
         * NB: If 'ptr' points to just after the page header, advertise a 
         * position at the beginning of the page rather than 'ptr' itself. If 
         * there are no other insertions running, someone might try to flush 
         * up to our advertised location. If we advertised a position after 
         * the page header, someone might try to flush the page header, even 
         * though page might actually not be initialized yet. As the first 
         * inserter on the page, we are effectively responsible for making 
         * sure that it's initialized, before we let insertingAt to move past 
         * the page header. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN1803"><span class='Ref_to_Parameter'>ptr</span></a> <span class='Operator'>% </span>XLOG_BLCKSZ <span class='Operator'>== </span><a href="../../../include/access/xlog_internal.h.html#LN54"><span class='Ref_to_Const'>SizeOfXLogShortPHD</span></a> <span class='Operator'>&& 
</span>            <a href="xlog.c.html#LN1803"><span class='Ref_to_Parameter'>ptr</span></a> <span class='Operator'>% </span>XLOG_SEG_SIZE <span class='Operator'>&GT; </span>XLOG_BLCKSZ<span class='Parentheses'>) 
</span>            <a href="xlog.c.html#LN1852"><span class='Ref_To_Local'>initializedUpto</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN1803"><span class='Ref_to_Parameter'>ptr</span></a> <span class='Operator'>- </span><a href="../../../include/access/xlog_internal.h.html#LN54"><span class='Ref_to_Const'>SizeOfXLogShortPHD</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN1803"><span class='Ref_to_Parameter'>ptr</span></a> <span class='Operator'>% </span>XLOG_BLCKSZ <span class='Operator'>== </span><a href="../../../include/access/xlog_internal.h.html#LN71"><span class='Ref_to_Const'>SizeOfXLogLongPHD</span></a> <span class='Operator'>&& 
</span>                 <a href="xlog.c.html#LN1803"><span class='Ref_to_Parameter'>ptr</span></a> <span class='Operator'>% </span>XLOG_SEG_SIZE <span class='Operator'>&LT; </span>XLOG_BLCKSZ<span class='Parentheses'>) 
</span>            <a href="xlog.c.html#LN1852"><span class='Ref_To_Local'>initializedUpto</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN1803"><span class='Ref_to_Parameter'>ptr</span></a> <span class='Operator'>- </span><a href="../../../include/access/xlog_internal.h.html#LN71"><span class='Ref_to_Const'>SizeOfXLogLongPHD</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="xlog.c.html#LN1852"><span class='Ref_To_Local'>initializedUpto</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN1803"><span class='Ref_to_Parameter'>ptr</span></a><span class='Delimiter'>; 
</span> 
        <a href="xlog.c.html#LN927"><span class='Ref_to_Proto'>WALInsertLockUpdateInsertingAt</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN1852"><span class='Ref_To_Local'>initializedUpto</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="xlog.c.html#LN863"><span class='Ref_to_Proto'>AdvanceXLInsertBuffer</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN1803"><span class='Ref_to_Parameter'>ptr</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN1806"><span class='Ref_To_Local'>endptr</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN619"><span class='Ref_to_Member'>xlblocks</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN1805"><span class='Ref_To_Local'>idx</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN1809"><span class='Ref_To_Local'>expectedEndPtr</span></a> <span class='Operator'>!= </span><a href="xlog.c.html#LN1806"><span class='Ref_To_Local'>endptr</span></a><span class='Parentheses'>) 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, </span><span class='String'>"could not find WAL buffer for %X/%X"</span><span class='Delimiter'>, 
</span>                 <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN1803"><span class='Ref_to_Parameter'>ptr</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN1803"><span class='Ref_to_Parameter'>ptr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if expectedEndPtr!=endpt... &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Make sure the initialization of the page is visible to us, and 
         * won't arrive later to overwrite the WAL data we write on the page. 
         */ 
</span>        <a href="../../../include/port/atomics.h.html#LN147"><span class='Ref_to_Macro'>pg_memory_barrier</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Found the buffer holding this page. Return a pointer to the right 
     * offset within the page. 
     */ 
</span>    <a href="xlog.c.html#LN1807"><span class='Ref_To_Local'>cachedPage</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN1803"><span class='Ref_to_Parameter'>ptr</span></a> <span class='Operator'>/ </span>XLOG_BLCKSZ<span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN1808"><span class='Ref_To_Local'>cachedPos</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN618"><span class='Ref_to_Member'>pages</span></a> <span class='Operator'>+ </span><a href="xlog.c.html#LN1805"><span class='Ref_To_Local'>idx</span></a> <span class='Operator'>* </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a><span class='Parentheses'>) </span>XLOG_BLCKSZ<span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(((</span><a href="../../../include/access/xlog_internal.h.html#LN56"><span class='Ref_to_Typedef'>XLogPageHeader</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN1808"><span class='Ref_To_Local'>cachedPos</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>xlp_magic <span class='Operator'>== </span><a href="../../../include/access/xlog_internal.h.html#LN33"><span class='Ref_to_Const'>XLOG_PAGE_MAGIC</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(((</span><a href="../../../include/access/xlog_internal.h.html#LN56"><span class='Ref_to_Typedef'>XLogPageHeader</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN1808"><span class='Ref_To_Local'>cachedPos</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>xlp_pageaddr <span class='Operator'>== </span><a href="xlog.c.html#LN1803"><span class='Ref_to_Parameter'>ptr</span></a> <span class='Operator'>- </span><span class='Parentheses'>(</span><a href="xlog.c.html#LN1803"><span class='Ref_to_Parameter'>ptr</span></a> <span class='Operator'>% </span>XLOG_BLCKSZ<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="xlog.c.html#LN1808"><span class='Ref_To_Local'>cachedPos</span></a> <span class='Operator'>+ </span><a href="xlog.c.html#LN1803"><span class='Ref_to_Parameter'>ptr</span></a> <span class='Operator'>% </span>XLOG_BLCKSZ<span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end GetXLogBuffer &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Converts a "usable byte position" to XLogRecPtr. A usable byte position 
 * is the position starting from the beginning of WAL, excluding all WAL 
 * page headers. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> 
<a name="LN1914"></a><span class='Declare_Function'>XLogBytePosToRecPtr</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a> <span class='Declare_Parameter'>bytepos</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1916"></a>    <a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a>      <span class='Declare_Local'>fullsegs</span><span class='Delimiter'>; 
</span><a name="LN1917"></a>    <a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a>      <span class='Declare_Local'>fullpages</span><span class='Delimiter'>; 
</span><a name="LN1918"></a>    <a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a>      <span class='Declare_Local'>bytesleft</span><span class='Delimiter'>; 
</span><a name="LN1919"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>seg_offset</span><span class='Delimiter'>; 
</span><a name="LN1920"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span> 
    <a href="xlog.c.html#LN1916"><span class='Ref_To_Local'>fullsegs</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN1914"><span class='Ref_to_Parameter'>bytepos</span></a> <span class='Operator'>/ </span><a href="xlog.c.html#LN737"><span class='Ref_to_Const'>UsableBytesInSegment</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN1918"><span class='Ref_To_Local'>bytesleft</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN1914"><span class='Ref_to_Parameter'>bytepos</span></a> <span class='Operator'>% </span><a href="xlog.c.html#LN737"><span class='Ref_to_Const'>UsableBytesInSegment</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN1918"><span class='Ref_To_Local'>bytesleft</span></a> <span class='Operator'>&LT; </span>XLOG_BLCKSZ <span class='Operator'>- </span><a href="../../../include/access/xlog_internal.h.html#LN71"><span class='Ref_to_Const'>SizeOfXLogLongPHD</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* fits on first page of segment */ 
</span>        <a href="xlog.c.html#LN1919"><span class='Ref_To_Local'>seg_offset</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN1918"><span class='Ref_To_Local'>bytesleft</span></a> <span class='Operator'>+ </span><a href="../../../include/access/xlog_internal.h.html#LN71"><span class='Ref_to_Const'>SizeOfXLogLongPHD</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* account for the first page on segment with long header */ 
</span>        <a href="xlog.c.html#LN1919"><span class='Ref_To_Local'>seg_offset</span></a> <span class='Operator'>= </span>XLOG_BLCKSZ<span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN1918"><span class='Ref_To_Local'>bytesleft</span></a> <span class='Operator'>-= </span>XLOG_BLCKSZ <span class='Operator'>- </span><a href="../../../include/access/xlog_internal.h.html#LN71"><span class='Ref_to_Const'>SizeOfXLogLongPHD</span></a><span class='Delimiter'>; 
</span> 
        <a href="xlog.c.html#LN1917"><span class='Ref_To_Local'>fullpages</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN1918"><span class='Ref_To_Local'>bytesleft</span></a> <span class='Operator'>/ </span><a href="xlog.c.html#LN736"><span class='Ref_to_Const'>UsableBytesInPage</span></a><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN1918"><span class='Ref_To_Local'>bytesleft</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN1918"><span class='Ref_To_Local'>bytesleft</span></a> <span class='Operator'>% </span><a href="xlog.c.html#LN736"><span class='Ref_to_Const'>UsableBytesInPage</span></a><span class='Delimiter'>; 
</span> 
        <a href="xlog.c.html#LN1919"><span class='Ref_To_Local'>seg_offset</span></a> <span class='Operator'>+= </span><a href="xlog.c.html#LN1917"><span class='Ref_To_Local'>fullpages</span></a> <span class='Operator'>* </span>XLOG_BLCKSZ <span class='Operator'>+ </span><a href="xlog.c.html#LN1918"><span class='Ref_To_Local'>bytesleft</span></a> <span class='Operator'>+ </span><a href="../../../include/access/xlog_internal.h.html#LN54"><span class='Ref_to_Const'>SizeOfXLogShortPHD</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/access/xlog_internal.h.html#LN94"><span class='Ref_to_Macro'>XLogSegNoOffsetToRecPtr</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN1916"><span class='Ref_To_Local'>fullsegs</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN1919"><span class='Ref_To_Local'>seg_offset</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN1920"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="xlog.c.html#LN1920"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end XLogBytePosToRecPtr &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Like XLogBytePosToRecPtr, but if the position is at a page boundary, 
 * returns a pointer to the beginning of the page (ie. before page header), 
 * not to where the first xlog record on that page would go to. This is used 
 * when converting a pointer to the end of a record. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> 
<a name="LN1954"></a><span class='Declare_Function'>XLogBytePosToEndRecPtr</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a> <span class='Declare_Parameter'>bytepos</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1956"></a>    <a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a>      <span class='Declare_Local'>fullsegs</span><span class='Delimiter'>; 
</span><a name="LN1957"></a>    <a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a>      <span class='Declare_Local'>fullpages</span><span class='Delimiter'>; 
</span><a name="LN1958"></a>    <a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a>      <span class='Declare_Local'>bytesleft</span><span class='Delimiter'>; 
</span><a name="LN1959"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>seg_offset</span><span class='Delimiter'>; 
</span><a name="LN1960"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span> 
    <a href="xlog.c.html#LN1956"><span class='Ref_To_Local'>fullsegs</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN1954"><span class='Ref_to_Parameter'>bytepos</span></a> <span class='Operator'>/ </span><a href="xlog.c.html#LN737"><span class='Ref_to_Const'>UsableBytesInSegment</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN1958"><span class='Ref_To_Local'>bytesleft</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN1954"><span class='Ref_to_Parameter'>bytepos</span></a> <span class='Operator'>% </span><a href="xlog.c.html#LN737"><span class='Ref_to_Const'>UsableBytesInSegment</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN1958"><span class='Ref_To_Local'>bytesleft</span></a> <span class='Operator'>&LT; </span>XLOG_BLCKSZ <span class='Operator'>- </span><a href="../../../include/access/xlog_internal.h.html#LN71"><span class='Ref_to_Const'>SizeOfXLogLongPHD</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* fits on first page of segment */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN1958"><span class='Ref_To_Local'>bytesleft</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <a href="xlog.c.html#LN1959"><span class='Ref_To_Local'>seg_offset</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="xlog.c.html#LN1959"><span class='Ref_To_Local'>seg_offset</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN1958"><span class='Ref_To_Local'>bytesleft</span></a> <span class='Operator'>+ </span><a href="../../../include/access/xlog_internal.h.html#LN71"><span class='Ref_to_Const'>SizeOfXLogLongPHD</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* account for the first page on segment with long header */ 
</span>        <a href="xlog.c.html#LN1959"><span class='Ref_To_Local'>seg_offset</span></a> <span class='Operator'>= </span>XLOG_BLCKSZ<span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN1958"><span class='Ref_To_Local'>bytesleft</span></a> <span class='Operator'>-= </span>XLOG_BLCKSZ <span class='Operator'>- </span><a href="../../../include/access/xlog_internal.h.html#LN71"><span class='Ref_to_Const'>SizeOfXLogLongPHD</span></a><span class='Delimiter'>; 
</span> 
        <a href="xlog.c.html#LN1957"><span class='Ref_To_Local'>fullpages</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN1958"><span class='Ref_To_Local'>bytesleft</span></a> <span class='Operator'>/ </span><a href="xlog.c.html#LN736"><span class='Ref_to_Const'>UsableBytesInPage</span></a><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN1958"><span class='Ref_To_Local'>bytesleft</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN1958"><span class='Ref_To_Local'>bytesleft</span></a> <span class='Operator'>% </span><a href="xlog.c.html#LN736"><span class='Ref_to_Const'>UsableBytesInPage</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN1958"><span class='Ref_To_Local'>bytesleft</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <a href="xlog.c.html#LN1959"><span class='Ref_To_Local'>seg_offset</span></a> <span class='Operator'>+= </span><a href="xlog.c.html#LN1957"><span class='Ref_To_Local'>fullpages</span></a> <span class='Operator'>* </span>XLOG_BLCKSZ <span class='Operator'>+ </span><a href="xlog.c.html#LN1958"><span class='Ref_To_Local'>bytesleft</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="xlog.c.html#LN1959"><span class='Ref_To_Local'>seg_offset</span></a> <span class='Operator'>+= </span><a href="xlog.c.html#LN1957"><span class='Ref_To_Local'>fullpages</span></a> <span class='Operator'>* </span>XLOG_BLCKSZ <span class='Operator'>+ </span><a href="xlog.c.html#LN1958"><span class='Ref_To_Local'>bytesleft</span></a> <span class='Operator'>+ </span><a href="../../../include/access/xlog_internal.h.html#LN54"><span class='Ref_to_Const'>SizeOfXLogShortPHD</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/access/xlog_internal.h.html#LN94"><span class='Ref_to_Macro'>XLogSegNoOffsetToRecPtr</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN1956"><span class='Ref_To_Local'>fullsegs</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN1959"><span class='Ref_To_Local'>seg_offset</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN1960"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="xlog.c.html#LN1960"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end XLogBytePosToEndRecPtr &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Convert an XLogRecPtr to a "usable byte position". 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a> 
<a name="LN1997"></a><span class='Declare_Function'>XLogRecPtrToBytePos</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>ptr</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1999"></a>    <a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a>      <span class='Declare_Local'>fullsegs</span><span class='Delimiter'>; 
</span><a name="LN2000"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>fullpages</span><span class='Delimiter'>; 
</span><a name="LN2001"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>offset</span><span class='Delimiter'>; 
</span><a name="LN2002"></a>    <a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a>      <span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/access/xlog_internal.h.html#LN105"><span class='Ref_to_Macro'>XLByteToSeg</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN1997"><span class='Ref_to_Parameter'>ptr</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN1999"><span class='Ref_To_Local'>fullsegs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="xlog.c.html#LN2000"><span class='Ref_To_Local'>fullpages</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="xlog.c.html#LN1997"><span class='Ref_to_Parameter'>ptr</span></a> <span class='Operator'>% </span>XLOG_SEG_SIZE<span class='Parentheses'>) </span><span class='Operator'>/ </span>XLOG_BLCKSZ<span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN2001"><span class='Ref_To_Local'>offset</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN1997"><span class='Ref_to_Parameter'>ptr</span></a> <span class='Operator'>% </span>XLOG_BLCKSZ<span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN2000"><span class='Ref_To_Local'>fullpages</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="xlog.c.html#LN2002"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN1999"><span class='Ref_To_Local'>fullsegs</span></a> <span class='Operator'>* </span><a href="xlog.c.html#LN737"><span class='Ref_to_Const'>UsableBytesInSegment</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN2001"><span class='Ref_To_Local'>offset</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN2001"><span class='Ref_To_Local'>offset</span></a> <span class='Operator'>&GT;= </span><a href="../../../include/access/xlog_internal.h.html#LN71"><span class='Ref_to_Const'>SizeOfXLogLongPHD</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN2002"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>+= </span><a href="xlog.c.html#LN2001"><span class='Ref_To_Local'>offset</span></a> <span class='Operator'>- </span><a href="../../../include/access/xlog_internal.h.html#LN71"><span class='Ref_to_Const'>SizeOfXLogLongPHD</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="xlog.c.html#LN2002"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN1999"><span class='Ref_To_Local'>fullsegs</span></a> <span class='Operator'>* </span><a href="xlog.c.html#LN737"><span class='Ref_to_Const'>UsableBytesInSegment</span></a> <span class='Operator'>+ 
</span>            <span class='Parentheses'>(</span>XLOG_BLCKSZ <span class='Operator'>- </span><a href="../../../include/access/xlog_internal.h.html#LN71"><span class='Ref_to_Const'>SizeOfXLogLongPHD</span></a><span class='Parentheses'>) </span><span class='Operator'>+ </span><span class='Comment_Single_Line'>/* account for first page */ 
</span>            <span class='Parentheses'>(</span><a href="xlog.c.html#LN2000"><span class='Ref_To_Local'>fullpages</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="xlog.c.html#LN736"><span class='Ref_to_Const'>UsableBytesInPage</span></a><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* full pages */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN2001"><span class='Ref_To_Local'>offset</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN2001"><span class='Ref_To_Local'>offset</span></a> <span class='Operator'>&GT;= </span><a href="../../../include/access/xlog_internal.h.html#LN54"><span class='Ref_to_Const'>SizeOfXLogShortPHD</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN2002"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>+= </span><a href="xlog.c.html#LN2001"><span class='Ref_To_Local'>offset</span></a> <span class='Operator'>- </span><a href="../../../include/access/xlog_internal.h.html#LN54"><span class='Ref_to_Const'>SizeOfXLogShortPHD</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="xlog.c.html#LN2002"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end XLogRecPtrToBytePos &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Initialize XLOG buffers, writing out old buffers if they still contain 
 * unwritten data, upto the page containing 'upto'. Or if 'opportunistic' is 
 * true, initialize as many pages as we can without having to write out 
 * unwritten data. Any new pages are initialized to zeros, with pages headers 
 * initialized properly. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2041"></a><span class='Declare_Function'>AdvanceXLInsertBuffer</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>upto</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>opportunistic</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2043"></a>    <a href="xlog.c.html#LN514"><span class='Ref_to_Struct'>XLogCtlInsert</span></a> <span class='Operator'>*</span><span class='Declare_Local'>Insert</span> <span class='Operator'>= &</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN574"><span class='Ref_to_Member'>Insert</span></a><span class='Delimiter'>; 
</span><a name="LN2044"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>nextidx</span><span class='Delimiter'>; 
</span><a name="LN2045"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>OldPageRqstPtr</span><span class='Delimiter'>; 
</span><a name="LN2046"></a>    <a href="xlog.c.html#LN414"><span class='Ref_to_Struct'>XLogwrtRqst</span></a> <span class='Declare_Local'>WriteRqst</span><span class='Delimiter'>; 
</span><a name="LN2047"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>NewPageEndPtr</span> <span class='Operator'>= </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>; 
</span><a name="LN2048"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>NewPageBeginPtr</span><span class='Delimiter'>; 
</span><a name="LN2049"></a>    <a href="../../../include/access/xlog_internal.h.html#LN56"><span class='Ref_to_Typedef'>XLogPageHeader</span></a> <span class='Declare_Local'>NewPage</span><span class='Delimiter'>; 
</span><a name="LN2050"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>npages</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>WALBufMappingLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now that we have the lock, check if someone initialized the page 
     * already. 
     */ 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN2041"><span class='Ref_to_Parameter'>upto</span></a> <span class='Operator'>&GT;= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN611"><span class='Ref_to_Member'>InitializedUpTo</span></a> <span class='Operator'>|| </span><a href="xlog.c.html#LN2041"><span class='Ref_to_Parameter'>opportunistic</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="xlog.c.html#LN2044"><span class='Ref_To_Local'>nextidx</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN730"><span class='Ref_to_Macro'>XLogRecPtrToBufIdx</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN611"><span class='Ref_to_Member'>InitializedUpTo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Get ending-offset of the buffer page we need to replace (this may 
         * be zero if the buffer hasn't been used yet).  Fall through if it's 
         * already written out. 
         */ 
</span>        <a href="xlog.c.html#LN2045"><span class='Ref_To_Local'>OldPageRqstPtr</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN619"><span class='Ref_to_Member'>xlblocks</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN2044"><span class='Ref_To_Local'>nextidx</span></a><span class='Delimiter'>]; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN422"><span class='Ref_to_Member'>Write</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN2045"><span class='Ref_To_Local'>OldPageRqstPtr</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Nope, got work to do. If we just want to pre-initialize as much 
             * as we can without flushing, give up now. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN2041"><span class='Ref_to_Parameter'>opportunistic</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Before waiting, get info_lck and update LogwrtResult */ 
</span>            <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN577"><span class='Ref_to_Member'>LogwrtRqst</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN416"><span class='Ref_to_Member'>Write</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN2045"><span class='Ref_To_Local'>OldPageRqstPtr</span></a><span class='Parentheses'>) 
</span>                <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN577"><span class='Ref_to_Member'>LogwrtRqst</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN416"><span class='Ref_to_Member'>Write</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN2045"><span class='Ref_To_Local'>OldPageRqstPtr</span></a><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN599"><span class='Ref_to_Member'>LogwrtResult</span></a><span class='Delimiter'>; 
</span>            <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Now that we have an up-to-date LogwrtResult value, see if we 
             * still need to write it or if someone else already did. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN422"><span class='Ref_to_Member'>Write</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN2045"><span class='Ref_To_Local'>OldPageRqstPtr</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * Must acquire write lock. Release WALBufMappingLock first, 
                 * to make sure that all insertions that we need to wait for 
                 * can finish (up to this same position). Otherwise we risk 
                 * deadlock. 
                 */ 
</span>                <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>WALBufMappingLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="xlog.c.html#LN917"><span class='Ref_to_Proto'>WaitXLogInsertionsToFinish</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN2045"><span class='Ref_To_Local'>OldPageRqstPtr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>WALWriteLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN599"><span class='Ref_to_Member'>LogwrtResult</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN422"><span class='Ref_to_Member'>Write</span></a> <span class='Operator'>&GT;= </span><a href="xlog.c.html#LN2045"><span class='Ref_To_Local'>OldPageRqstPtr</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* OK, someone wrote it already */ 
</span>                    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>WALWriteLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>else</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* Have to write it ourselves */ 
</span>                    TRACE_POSTGRESQL_WAL_BUFFER_WRITE_DIRTY_START<span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>                    <a href="xlog.c.html#LN2046"><span class='Ref_To_Local'>WriteRqst</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN416"><span class='Ref_to_Member'>Write</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN2045"><span class='Ref_To_Local'>OldPageRqstPtr</span></a><span class='Delimiter'>; 
</span>                    <a href="xlog.c.html#LN2046"><span class='Ref_To_Local'>WriteRqst</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN417"><span class='Ref_to_Member'>Flush</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>                    <a href="xlog.c.html#LN865"><span class='Ref_to_Proto'>XLogWrite</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN2046"><span class='Ref_To_Local'>WriteRqst</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>WALWriteLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    TRACE_POSTGRESQL_WAL_BUFFER_WRITE_DIRTY_DONE<span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Comment_Multi_Line'>/* Re-acquire WALBufMappingLock and retry */ 
</span>                <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>WALBufMappingLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>continue</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if LogwrtResult.Write&LT;Ol... &raquo; </span> 
        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if LogwrtResult.Write&LT;Ol... &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* 
         * Now the next buffer slot is free and we can set it up to be the 
         * next output page. 
         */ 
</span>        <a href="xlog.c.html#LN2048"><span class='Ref_To_Local'>NewPageBeginPtr</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN611"><span class='Ref_to_Member'>InitializedUpTo</span></a><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN2047"><span class='Ref_To_Local'>NewPageEndPtr</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN2048"><span class='Ref_To_Local'>NewPageBeginPtr</span></a> <span class='Operator'>+ </span>XLOG_BLCKSZ<span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN730"><span class='Ref_to_Macro'>XLogRecPtrToBufIdx</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN2048"><span class='Ref_To_Local'>NewPageBeginPtr</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="xlog.c.html#LN2044"><span class='Ref_To_Local'>nextidx</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="xlog.c.html#LN2049"><span class='Ref_To_Local'>NewPage</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/xlog_internal.h.html#LN56"><span class='Ref_to_Typedef'>XLogPageHeader</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN618"><span class='Ref_to_Member'>pages</span></a> <span class='Operator'>+ </span><a href="xlog.c.html#LN2044"><span class='Ref_To_Local'>nextidx</span></a> <span class='Operator'>* </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a><span class='Parentheses'>) </span>XLOG_BLCKSZ<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Be sure to re-zero the buffer so that bytes beyond what we've 
         * written will look like zeroes and not valid XLOG records... 
         */ 
</span>        <a href="../../../include/c.h.html#LN856"><span class='Ref_to_Macro'>MemSet</span></a><span class='Parentheses'>((</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="xlog.c.html#LN2049"><span class='Ref_To_Local'>NewPage</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span>XLOG_BLCKSZ<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Fill the new page's header 
         */ 
</span>        <a href="xlog.c.html#LN2049"><span class='Ref_To_Local'>NewPage</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlog_internal.h.html#LN37"><span class='Ref_to_Member'>xlp_magic</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlog_internal.h.html#LN33"><span class='Ref_to_Const'>XLOG_PAGE_MAGIC</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* NewPage-&GT;xlp_info = 0; */</span>    <span class='Comment_Single_Line'>/* done by memset */ 
</span>        <a href="xlog.c.html#LN2049"><span class='Ref_To_Local'>NewPage</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlog_internal.h.html#LN39"><span class='Ref_to_Member'>xlp_tli</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN2049"><span class='Ref_To_Local'>NewPage</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlog_internal.h.html#LN40"><span class='Ref_to_Member'>xlp_pageaddr</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN2048"><span class='Ref_To_Local'>NewPageBeginPtr</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* NewPage-&GT;xlp_rem_len = 0; */ </span><span class='Comment_Single_Line'>/* done by memset */ 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If online backup is not in progress, mark the header to indicate 
         * that* WAL records beginning in this page have removable backup 
         * blocks.  This allows the WAL archiver to know whether it is safe to 
         * compress archived WAL data by transforming full-block records into 
         * the non-full-block format.  It is sufficient to record this at the 
         * page level because we force a page switch (in fact a segment 
         * switch) when starting a backup, so the flag will be off before any 
         * records can be written during the backup.  At the end of a backup, 
         * the last page will be marked as all unsafe when perhaps only part 
         * is unsafe, but at worst the archiver would miss the opportunity to 
         * compress a few records. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN2043"><span class='Ref_To_Local'>Insert</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN548"><span class='Ref_to_Member'>forcePageWrites</span></a><span class='Parentheses'>) 
</span>            <a href="xlog.c.html#LN2049"><span class='Ref_To_Local'>NewPage</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlog_internal.h.html#LN38"><span class='Ref_to_Member'>xlp_info</span></a> <span class='Operator'>|= </span><a href="../../../include/access/xlog_internal.h.html#LN80"><span class='Ref_to_Const'>XLP_BKP_REMOVABLE</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If first page of an XLOG segment file, make it a long header. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="xlog.c.html#LN2049"><span class='Ref_To_Local'>NewPage</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlog_internal.h.html#LN40"><span class='Ref_to_Member'>xlp_pageaddr</span></a> <span class='Operator'>% </span><a href="../../../include/access/xlog_internal.h.html#LN91"><span class='Ref_to_Const'>XLogSegSize</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span><a name="LN2173"></a>            <a href="../../../include/access/xlog_internal.h.html#LN73"><span class='Ref_to_Typedef'>XLogLongPageHeader</span></a> <span class='Declare_Local'>NewLongPage</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/xlog_internal.h.html#LN73"><span class='Ref_to_Typedef'>XLogLongPageHeader</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN2049"><span class='Ref_To_Local'>NewPage</span></a><span class='Delimiter'>; 
</span> 
            <a href="xlog.c.html#LN2173"><span class='Ref_To_Local'>NewLongPage</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlog_internal.h.html#LN66"><span class='Ref_to_Member'>xlp_sysid</span></a> <span class='Operator'>= </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN108"><span class='Ref_to_Member'>system_identifier</span></a><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN2173"><span class='Ref_To_Local'>NewLongPage</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlog_internal.h.html#LN67"><span class='Ref_to_Member'>xlp_seg_size</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlog_internal.h.html#LN91"><span class='Ref_to_Const'>XLogSegSize</span></a><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN2173"><span class='Ref_To_Local'>NewLongPage</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlog_internal.h.html#LN68"><span class='Ref_to_Member'>xlp_xlog_blcksz</span></a> <span class='Operator'>= </span>XLOG_BLCKSZ<span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN2049"><span class='Ref_To_Local'>NewPage</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlog_internal.h.html#LN38"><span class='Ref_to_Member'>xlp_info</span></a> <span class='Operator'>|= </span><a href="../../../include/access/xlog_internal.h.html#LN78"><span class='Ref_to_Const'>XLP_LONG_HEADER</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Make sure the initialization of the page becomes visible to others 
         * before the xlblocks update. GetXLogBuffer() reads xlblocks without 
         * holding a lock. 
         */ 
</span>        <a href="../../../include/port/atomics.h.html#LN161"><span class='Ref_to_Macro'>pg_write_barrier</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Operator'>*</span><span class='Parentheses'>((</span><span class='Keyword'>volatile </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN619"><span class='Ref_to_Member'>xlblocks</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN2044"><span class='Ref_To_Local'>nextidx</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span> <span class='Operator'>= </span><a href="xlog.c.html#LN2047"><span class='Ref_To_Local'>NewPageEndPtr</span></a><span class='Delimiter'>; 
</span> 
        <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN611"><span class='Ref_to_Member'>InitializedUpTo</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN2047"><span class='Ref_To_Local'>NewPageEndPtr</span></a><span class='Delimiter'>; 
</span> 
        <a href="xlog.c.html#LN2050"><span class='Ref_To_Local'>npages</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while upto&GT;=XLogCtl-&GT;Initia... &raquo; </span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>WALBufMappingLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifdef</span> WAL_DEBUG 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN109"><span class='Ref_to_Global_Var'>XLOG_DEBUG</span></a> <span class='Operator'>&& </span><a href="xlog.c.html#LN2050"><span class='Ref_To_Local'>npages</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN24"><span class='Ref_to_Const'>DEBUG1</span></a><span class='Delimiter'>, </span><span class='String'>"initialized %d pages, up to %X/%X"</span><span class='Delimiter'>, 
</span>             <a href="xlog.c.html#LN2050"><span class='Ref_To_Local'>npages</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN2047"><span class='Ref_To_Local'>NewPageEndPtr</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN2047"><span class='Ref_To_Local'>NewPageEndPtr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span><span class='Directive'>#endif</span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end AdvanceXLInsertBuffer &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Calculate CheckPointSegments based on max_wal_size_mb and 
 * checkpoint_completion_target. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2210"></a><span class='Declare_Function'>CalculateCheckpointSegments</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2212"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>target</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/*------- 
     * Calculate the distance at which to trigger a checkpoint, to avoid 
     * exceeding max_wal_size_mb. This is based on two assumptions: 
     * 
     * a) we keep WAL for two checkpoint cycles, back to the "prev" checkpoint. 
     * b) during checkpoint, we consume checkpoint_completion_target * 
     *    number of segments consumed between checkpoints. 
     *------- 
     */ 
</span>    <a href="xlog.c.html#LN2212"><span class='Ref_To_Local'>target</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="xlog.c.html#LN740"><span class='Ref_to_Macro'>ConvertToXSegs</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN88"><span class='Ref_to_Global_Var'>max_wal_size_mb</span></a><span class='Parentheses'>) </span><span class='Operator'>/ </span><span class='Parentheses'>(</span><span class='Number'>2</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>+ </span><a href="../../postmaster/checkpointer.c.html#LN146"><span class='Ref_to_Global_Var'>CheckPointCompletionTarget</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* round down */ 
</span>    <a href="xlog.c.html#LN123"><span class='Ref_to_Global_Var'>CheckPointSegments</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="xlog.c.html#LN2212"><span class='Ref_To_Local'>target</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN123"><span class='Ref_to_Global_Var'>CheckPointSegments</span></a> <span class='Operator'>&LT; </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>        <a href="xlog.c.html#LN123"><span class='Ref_to_Global_Var'>CheckPointSegments</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end CalculateCheckpointSegments &raquo; </span> 
 
<span class='Keyword'>void 
</span><a name="LN2233"></a><span class='Declare_Function'>assign_max_wal_size</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>newval</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>extra</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="xlog.c.html#LN88"><span class='Ref_to_Global_Var'>max_wal_size_mb</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN2233"><span class='Ref_to_Parameter'>newval</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN2209"><span class='Ref_to_Func'>CalculateCheckpointSegments</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
} 
</span> 
<span class='Keyword'>void 
</span><a name="LN2240"></a><span class='Declare_Function'>assign_checkpoint_completion_target</span><span class='Parentheses'>(</span><span class='Keyword'>double </span><span class='Declare_Parameter'>newval</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>extra</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../postmaster/checkpointer.c.html#LN146"><span class='Ref_to_Global_Var'>CheckPointCompletionTarget</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN2240"><span class='Ref_to_Parameter'>newval</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN2209"><span class='Ref_to_Func'>CalculateCheckpointSegments</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * At a checkpoint, how many WAL segments to recycle as preallocated future 
 * XLOG segments? Returns the highest segment that should be preallocated. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a> 
<a name="LN2251"></a><span class='Declare_Function'>XLOGfileslop</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>PriorRedoPtr</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2253"></a>    <a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a>   <span class='Declare_Local'>minSegNo</span><span class='Delimiter'>; 
</span><a name="LN2254"></a>    <a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a>   <span class='Declare_Local'>maxSegNo</span><span class='Delimiter'>; 
</span><a name="LN2255"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>distance</span><span class='Delimiter'>; 
</span><a name="LN2256"></a>    <a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a>   <span class='Declare_Local'>recycleSegNo</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Calculate the segment numbers that min_wal_size_mb and max_wal_size_mb 
     * correspond to. Always recycle enough segments to meet the minimum, and 
     * remove enough segments to stay below the maximum. 
     */ 
</span>    <a href="xlog.c.html#LN2253"><span class='Ref_To_Local'>minSegNo</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN2251"><span class='Ref_to_Parameter'>PriorRedoPtr</span></a> <span class='Operator'>/ </span>XLOG_SEG_SIZE <span class='Operator'>+ </span><a href="xlog.c.html#LN740"><span class='Ref_to_Macro'>ConvertToXSegs</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN89"><span class='Ref_to_Global_Var'>min_wal_size_mb</span></a><span class='Parentheses'>) </span><span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN2254"><span class='Ref_To_Local'>maxSegNo</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN2251"><span class='Ref_to_Parameter'>PriorRedoPtr</span></a> <span class='Operator'>/ </span>XLOG_SEG_SIZE <span class='Operator'>+ </span><a href="xlog.c.html#LN740"><span class='Ref_to_Macro'>ConvertToXSegs</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN88"><span class='Ref_to_Global_Var'>max_wal_size_mb</span></a><span class='Parentheses'>) </span><span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Between those limits, recycle enough segments to get us through to the 
     * estimated end of next checkpoint. 
     * 
     * To estimate where the next checkpoint will finish, assume that the 
     * system runs steadily consuming CheckPointDistanceEstimate bytes between 
     * every checkpoint. 
     * 
     * The reason this calculation is done from the prior checkpoint, not the 
     * one that just finished, is that this behaves better if some checkpoint 
     * cycles are abnormally short, like if you perform a manual checkpoint 
     * right after a timed one. The manual checkpoint will make almost a full 
     * cycle's worth of WAL segments available for recycling, because the 
     * segments from the prior's prior, fully-sized checkpoint cycle are no 
     * longer needed. However, the next checkpoint will make only few segments 
     * available for recycling, the ones generated between the timed 
     * checkpoint and the manual one right after that. If at the manual 
     * checkpoint we only retained enough segments to get us to the next timed 
     * one, and removed the rest, then at the next checkpoint we would not 
     * have enough segments around for recycling, to get us to the checkpoint 
     * after that. Basing the calculations on the distance from the prior redo 
     * pointer largely fixes that problem. 
     */ 
</span>    <a href="xlog.c.html#LN2255"><span class='Ref_To_Local'>distance</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Number'>2</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>+ </span><a href="../../postmaster/checkpointer.c.html#LN146"><span class='Ref_to_Global_Var'>CheckPointCompletionTarget</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="xlog.c.html#LN126"><span class='Ref_to_Global_Var'>CheckPointDistanceEstimate</span></a><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* add 10% for good measure. */ 
</span>    <a href="xlog.c.html#LN2255"><span class='Ref_To_Local'>distance</span></a> <span class='Operator'>*= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>10</span><span class='Delimiter'>; 
</span> 
    <a href="xlog.c.html#LN2256"><span class='Ref_To_Local'>recycleSegNo</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a><span class='Parentheses'>) </span>ceil<span class='Parentheses'>(((</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="xlog.c.html#LN2251"><span class='Ref_to_Parameter'>PriorRedoPtr</span></a> <span class='Operator'>+ </span><a href="xlog.c.html#LN2255"><span class='Ref_To_Local'>distance</span></a><span class='Parentheses'>)</span> <span class='Operator'>/ </span>XLOG_SEG_SIZE<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN2256"><span class='Ref_To_Local'>recycleSegNo</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN2253"><span class='Ref_To_Local'>minSegNo</span></a><span class='Parentheses'>) 
</span>        <a href="xlog.c.html#LN2256"><span class='Ref_To_Local'>recycleSegNo</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN2253"><span class='Ref_To_Local'>minSegNo</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN2256"><span class='Ref_To_Local'>recycleSegNo</span></a> <span class='Operator'>&GT; </span><a href="xlog.c.html#LN2254"><span class='Ref_To_Local'>maxSegNo</span></a><span class='Parentheses'>) 
</span>        <a href="xlog.c.html#LN2256"><span class='Ref_To_Local'>recycleSegNo</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN2254"><span class='Ref_To_Local'>maxSegNo</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="xlog.c.html#LN2256"><span class='Ref_To_Local'>recycleSegNo</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end XLOGfileslop &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Check whether we've consumed enough xlog space that a checkpoint is needed. 
 * 
 * new_segno indicates a log file that has just been filled up (or read 
 * during recovery). We measure the distance from RedoRecPtr to new_segno 
 * and see if that exceeds CheckPointSegments. 
 * 
 * Note: it is caller's responsibility that RedoRecPtr is up-to-date. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN2313"></a><span class='Declare_Function'>XLogCheckpointNeeded</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a> <span class='Declare_Parameter'>new_segno</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2315"></a>    <a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a>   <span class='Declare_Local'>old_segno</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/access/xlog_internal.h.html#LN105"><span class='Ref_to_Macro'>XLByteToSeg</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN349"><span class='Ref_to_Global_Var'>RedoRecPtr</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN2315"><span class='Ref_To_Local'>old_segno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN2313"><span class='Ref_to_Parameter'>new_segno</span></a> <span class='Operator'>&GT;= </span><a href="xlog.c.html#LN2315"><span class='Ref_To_Local'>old_segno</span></a> <span class='Operator'>+ </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN123"><span class='Ref_to_Global_Var'>CheckPointSegments</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Write and/or fsync the log at least as far as WriteRqst indicates. 
 * 
 * If flexible == TRUE, we don't have to write as far as WriteRqst, but 
 * may stop at any convenient boundary (such as a cache or logfile boundary). 
 * This option allows us to avoid uselessly issuing multiple writes when a 
 * single one would do. 
 * 
 * Must be called with WALWriteLock held. WaitXLogInsertionsToFinish(WriteRqst) 
 * must be called before grabbing the lock, to make sure the data is ready to 
 * write. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2337"></a><span class='Declare_Function'>XLogWrite</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN414"><span class='Ref_to_Struct'>XLogwrtRqst</span></a> <span class='Declare_Parameter'>WriteRqst</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>flexible</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2339"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>ispartialpage</span><span class='Delimiter'>; 
</span><a name="LN2340"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>last_iteration</span><span class='Delimiter'>; 
</span><a name="LN2341"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>finishing_seg</span><span class='Delimiter'>; 
</span><a name="LN2342"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>use_existent</span><span class='Delimiter'>; 
</span><a name="LN2343"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>curridx</span><span class='Delimiter'>; 
</span><a name="LN2344"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>npages</span><span class='Delimiter'>; 
</span><a name="LN2345"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>startidx</span><span class='Delimiter'>; 
</span><a name="LN2346"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>startoffset</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* We should always be inside a critical section here */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../utils/init/globals.c.html#LN36"><span class='Ref_to_Global_Var'>CritSectionCount</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Update local LogwrtResult (caller probably did this already, but...) 
     */ 
</span>    <a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN599"><span class='Ref_to_Member'>LogwrtResult</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Since successive pages in the xlog cache are consecutively allocated, 
     * we can usually gather multiple pages together and issue just one 
     * write() call.  npages is the number of pages we have determined can be 
     * written together; startidx is the cache block index of the first one, 
     * and startoffset is the file offset at which it should go. The latter 
     * two variables are only valid when npages &GT; 0, but we must initialize 
     * all of them to keep the compiler quiet. 
     */ 
</span>    <a href="xlog.c.html#LN2344"><span class='Ref_To_Local'>npages</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN2345"><span class='Ref_To_Local'>startidx</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN2346"><span class='Ref_To_Local'>startoffset</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Within the loop, curridx is the cache block index of the page to 
     * consider writing.  Begin at the buffer containing the next unwritten 
     * page, or last partially written page. 
     */ 
</span>    <a href="xlog.c.html#LN2343"><span class='Ref_To_Local'>curridx</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN730"><span class='Ref_to_Macro'>XLogRecPtrToBufIdx</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN422"><span class='Ref_to_Member'>Write</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN422"><span class='Ref_to_Member'>Write</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN2337"><span class='Ref_to_Parameter'>WriteRqst</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN416"><span class='Ref_to_Member'>Write</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Make sure we're not ahead of the insert process.  This could happen 
         * if we're passed a bogus WriteRqst.Write that is past the end of the 
         * last page that's been initialized by AdvanceXLInsertBuffer. 
         */ 
</span><a name="LN2383"></a>        <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>EndPtr</span> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN619"><span class='Ref_to_Member'>xlblocks</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN2343"><span class='Ref_To_Local'>curridx</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN422"><span class='Ref_to_Member'>Write</span></a> <span class='Operator'>&GT;= </span><a href="xlog.c.html#LN2383"><span class='Ref_To_Local'>EndPtr</span></a><span class='Parentheses'>) 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, </span><span class='String'>"xlog write request %X/%X is past end of log %X/%X"</span><span class='Delimiter'>, 
</span>                 <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN422"><span class='Ref_to_Member'>Write</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN422"><span class='Ref_to_Member'>Write</span></a><span class='Delimiter'>, 
</span>                 <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN2383"><span class='Ref_To_Local'>EndPtr</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN2383"><span class='Ref_To_Local'>EndPtr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Advance LogwrtResult.Write to end of current buffer page */ 
</span>        <a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN422"><span class='Ref_to_Member'>Write</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN2383"><span class='Ref_To_Local'>EndPtr</span></a><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN2339"><span class='Ref_To_Local'>ispartialpage</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN2337"><span class='Ref_to_Parameter'>WriteRqst</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN416"><span class='Ref_to_Member'>Write</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN422"><span class='Ref_to_Member'>Write</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/xlog_internal.h.html#LN120"><span class='Ref_to_Macro'>XLByteInPrevSeg</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN422"><span class='Ref_to_Member'>Write</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN771"><span class='Ref_to_Global_Var'>openLogSegNo</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Switch to new logfile segment.  We cannot have any pending 
             * pages here (since we dump what we have at segment end). 
             */ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN2344"><span class='Ref_To_Local'>npages</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN770"><span class='Ref_to_Global_Var'>openLogFile</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <a href="xlog.c.html#LN878"><span class='Ref_to_Proto'>XLogFileClose</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>            <a href="../../../include/access/xlog_internal.h.html#LN108"><span class='Ref_to_Macro'>XLByteToPrevSeg</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN422"><span class='Ref_to_Member'>Write</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN771"><span class='Ref_to_Global_Var'>openLogSegNo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* create/use new log file */ 
</span>            <a href="xlog.c.html#LN2342"><span class='Ref_To_Local'>use_existent</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN770"><span class='Ref_to_Global_Var'>openLogFile</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlog.h.html#LN228"><span class='Ref_to_Proto'>XLogFileInit</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN771"><span class='Ref_to_Global_Var'>openLogSegNo</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN2342"><span class='Ref_To_Local'>use_existent</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN772"><span class='Ref_to_Global_Var'>openLogOff</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* Make sure we have the current logfile open */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN770"><span class='Ref_to_Global_Var'>openLogFile</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../../include/access/xlog_internal.h.html#LN108"><span class='Ref_to_Macro'>XLByteToPrevSeg</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN422"><span class='Ref_to_Member'>Write</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN771"><span class='Ref_to_Global_Var'>openLogSegNo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN770"><span class='Ref_to_Global_Var'>openLogFile</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlog.h.html#LN229"><span class='Ref_to_Proto'>XLogFileOpen</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN771"><span class='Ref_to_Global_Var'>openLogSegNo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN772"><span class='Ref_to_Global_Var'>openLogOff</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* Add current page to the set of pending pages-to-dump */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN2344"><span class='Ref_To_Local'>npages</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* first of group */ 
</span>            <a href="xlog.c.html#LN2345"><span class='Ref_To_Local'>startidx</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN2343"><span class='Ref_To_Local'>curridx</span></a><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN2346"><span class='Ref_To_Local'>startoffset</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN422"><span class='Ref_to_Member'>Write</span></a> <span class='Operator'>- </span>XLOG_BLCKSZ<span class='Parentheses'>) </span><span class='Operator'>% </span><a href="../../../include/access/xlog_internal.h.html#LN91"><span class='Ref_to_Const'>XLogSegSize</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <a href="xlog.c.html#LN2344"><span class='Ref_To_Local'>npages</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Dump the set if this will be the last loop iteration, or if we are 
         * at the last page of the cache area (since the next page won't be 
         * contiguous in memory), or if we are at the end of the logfile 
         * segment. 
         */ 
</span>        <a href="xlog.c.html#LN2340"><span class='Ref_To_Local'>last_iteration</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN2337"><span class='Ref_to_Parameter'>WriteRqst</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN416"><span class='Ref_to_Member'>Write</span></a> <span class='Operator'>&LT;= </span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN422"><span class='Ref_to_Member'>Write</span></a><span class='Delimiter'>; 
</span> 
        <a href="xlog.c.html#LN2341"><span class='Ref_To_Local'>finishing_seg</span></a> <span class='Operator'>= !</span><a href="xlog.c.html#LN2339"><span class='Ref_To_Local'>ispartialpage</span></a> <span class='Operator'>&& 
</span>            <span class='Parentheses'>(</span><a href="xlog.c.html#LN2346"><span class='Ref_To_Local'>startoffset</span></a> <span class='Operator'>+ </span><a href="xlog.c.html#LN2344"><span class='Ref_To_Local'>npages</span></a> <span class='Operator'>* </span>XLOG_BLCKSZ<span class='Parentheses'>) </span><span class='Operator'>&GT;= </span><a href="../../../include/access/xlog_internal.h.html#LN91"><span class='Ref_to_Const'>XLogSegSize</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN2340"><span class='Ref_To_Local'>last_iteration</span></a> <span class='Operator'>|| 
</span>            <a href="xlog.c.html#LN2343"><span class='Ref_To_Local'>curridx</span></a> <span class='Operator'>== </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN620"><span class='Ref_to_Member'>XLogCacheBlck</span></a> <span class='Operator'>|| 
</span>            <a href="xlog.c.html#LN2341"><span class='Ref_To_Local'>finishing_seg</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN2444"></a>            <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>from</span><span class='Delimiter'>; 
</span><a name="LN2445"></a>            <a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a>        <span class='Declare_Local'>nbytes</span><span class='Delimiter'>; 
</span><a name="LN2446"></a>            <a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a>        <span class='Declare_Local'>nleft</span><span class='Delimiter'>; 
</span><a name="LN2447"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>written</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Need to seek in the file? */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN772"><span class='Ref_to_Global_Var'>openLogOff</span></a> <span class='Operator'>!= </span><a href="xlog.c.html#LN2346"><span class='Ref_To_Local'>startoffset</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span>lseek<span class='Parentheses'>(</span><a href="xlog.c.html#LN770"><span class='Ref_to_Global_Var'>openLogFile</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span>off_t<span class='Parentheses'>) </span><a href="xlog.c.html#LN2346"><span class='Ref_To_Local'>startoffset</span></a><span class='Delimiter'>, </span>SEEK_SET<span class='Parentheses'>)</span> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                    <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>                            <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                     <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not seek in log file %s to offset %u: %m"</span><span class='Delimiter'>, 
</span>                            <a href="../../../include/access/xlog.h.html#LN254"><span class='Ref_to_Proto'>XLogFileNameP</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN771"><span class='Ref_to_Global_Var'>openLogSegNo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                            <a href="xlog.c.html#LN2346"><span class='Ref_To_Local'>startoffset</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                <a href="xlog.c.html#LN772"><span class='Ref_to_Global_Var'>openLogOff</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN2346"><span class='Ref_To_Local'>startoffset</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* OK to write the page(s) */ 
</span>            <a href="xlog.c.html#LN2444"><span class='Ref_To_Local'>from</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN618"><span class='Ref_to_Member'>pages</span></a> <span class='Operator'>+ </span><a href="xlog.c.html#LN2345"><span class='Ref_To_Local'>startidx</span></a> <span class='Operator'>* </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a><span class='Parentheses'>) </span>XLOG_BLCKSZ<span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN2445"><span class='Ref_To_Local'>nbytes</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN2344"><span class='Ref_To_Local'>npages</span></a> <span class='Operator'>* </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a><span class='Parentheses'>) </span>XLOG_BLCKSZ<span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN2446"><span class='Ref_To_Local'>nleft</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN2445"><span class='Ref_To_Local'>nbytes</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>do</span> 
            <span class='Delimiter'>{ 
</span>                errno <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>                <a href="../../../include/pgstat.h.html#LN1206"><span class='Ref_to_Func'>pgstat_report_wait_start</span></a><span class='Parentheses'>(</span><a href="../../../include/pgstat.h.html#LN904"><span class='Ref_to_EnumConst'>WAIT_EVENT_WAL_WRITE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="xlog.c.html#LN2447"><span class='Ref_To_Local'>written</span></a> <span class='Operator'>= </span><a href="../../../interfaces/libpq/win32.h.html#LN13"><span class='Ref_to_Macro'>write</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN770"><span class='Ref_to_Global_Var'>openLogFile</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN2444"><span class='Ref_To_Local'>from</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN2446"><span class='Ref_To_Local'>nleft</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="../../../include/pgstat.h.html#LN1230"><span class='Ref_to_Func'>pgstat_report_wait_end</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN2447"><span class='Ref_To_Local'>written</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span>errno <span class='Operator'>== </span><a href="../../../interfaces/libpq/win32.h.html#LN17"><span class='Ref_to_Const'>EINTR</span></a><span class='Parentheses'>) 
</span>                        <span class='Control'>continue</span><span class='Delimiter'>; 
</span>                    <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>                            <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                             <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not write to log file %s "</span> 
                                    <span class='String'>"at offset %u, length %zu: %m"</span><span class='Delimiter'>, 
</span>                                 <a href="../../../include/access/xlog.h.html#LN254"><span class='Ref_to_Proto'>XLogFileNameP</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN771"><span class='Ref_to_Global_Var'>openLogSegNo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                    <a href="xlog.c.html#LN772"><span class='Ref_to_Global_Var'>openLogOff</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN2445"><span class='Ref_To_Local'>nbytes</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <a href="xlog.c.html#LN2446"><span class='Ref_To_Local'>nleft</span></a> <span class='Operator'>-= </span><a href="xlog.c.html#LN2447"><span class='Ref_To_Local'>written</span></a><span class='Delimiter'>; 
</span>                <a href="xlog.c.html#LN2444"><span class='Ref_To_Local'>from</span></a> <span class='Operator'>+= </span><a href="xlog.c.html#LN2447"><span class='Ref_To_Local'>written</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} </span><span class='Control'>while</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN2446"><span class='Ref_To_Local'>nleft</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Update state for write */ 
</span>            <a href="xlog.c.html#LN772"><span class='Ref_to_Global_Var'>openLogOff</span></a> <span class='Operator'>+= </span><a href="xlog.c.html#LN2445"><span class='Ref_To_Local'>nbytes</span></a><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN2344"><span class='Ref_To_Local'>npages</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * If we just wrote the whole last page of a logfile segment, 
             * fsync the segment immediately.  This avoids having to go back 
             * and re-open prior segments when an fsync request comes along 
             * later. Doing it here ensures that one and only one backend will 
             * perform this fsync. 
             * 
             * This is also the right place to notify the Archiver that the 
             * segment is ready to copy to archival storage, and to update the 
             * timer for archive_timeout, and to signal for a checkpoint if 
             * too many logfile segments have been used since the last 
             * checkpoint. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN2341"><span class='Ref_To_Local'>finishing_seg</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="../../../include/access/xlog.h.html#LN240"><span class='Ref_to_Proto'>issue_xlog_fsync</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN770"><span class='Ref_to_Global_Var'>openLogFile</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN771"><span class='Ref_to_Global_Var'>openLogSegNo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* signal that we need to wakeup walsenders later */ 
</span>                <a href="../../../include/replication/walsender.h.html#LN57"><span class='Ref_to_Macro'>WalSndWakeupRequest</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
                <a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN423"><span class='Ref_to_Member'>Flush</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN422"><span class='Ref_to_Member'>Write</span></a><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* end of page */ 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN133"><span class='Ref_to_Macro'>XLogArchivingActive</span></a><span class='Parentheses'>())</span> 
                    <a href="../../../include/access/xlog_internal.h.html#LN313"><span class='Ref_to_Proto'>XLogArchiveNotifySeg</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN771"><span class='Ref_to_Global_Var'>openLogSegNo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN592"><span class='Ref_to_Member'>lastSegSwitchTime</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/pgtime.h.html#LN22"><span class='Ref_to_Typedef'>pg_time_t</span></a><span class='Parentheses'>) </span>time<span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN593"><span class='Ref_to_Member'>lastSegSwitchLSN</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN423"><span class='Ref_to_Member'>Flush</span></a><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * Request a checkpoint if we've consumed too much xlog since 
                 * the last one.  For speed, we first check using the local 
                 * copy of RedoRecPtr, which might be out of date; if it looks 
                 * like a checkpoint is needed, forcibly update RedoRecPtr and 
                 * recheck. 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../utils/init/globals.c.html#LN100"><span class='Ref_to_Global_Var'>IsUnderPostmaster</span></a> <span class='Operator'>&& </span><a href="xlog.c.html#LN864"><span class='Ref_to_Proto'>XLogCheckpointNeeded</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN771"><span class='Ref_to_Global_Var'>openLogSegNo</span></a><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="../../../include/access/xlog.h.html#LN273"><span class='Ref_to_Proto'>GetRedoRecPtr</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN864"><span class='Ref_to_Proto'>XLogCheckpointNeeded</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN771"><span class='Ref_to_Global_Var'>openLogSegNo</span></a><span class='Parentheses'>))</span> 
                        <a href="../../../include/postmaster/bgwriter.h.html#LN30"><span class='Ref_to_Proto'>RequestCheckpoint</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN185"><span class='Ref_to_Const'>CHECKPOINT_CAUSE_XLOG</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if finishing_seg &raquo; </span> 
        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if last_iteration||curri... &raquo; </span> 
 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN2339"><span class='Ref_To_Local'>ispartialpage</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Only asked to write a partial page */ 
</span>            <a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN422"><span class='Ref_to_Member'>Write</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN2337"><span class='Ref_to_Parameter'>WriteRqst</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN416"><span class='Ref_to_Member'>Write</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <a href="xlog.c.html#LN2343"><span class='Ref_To_Local'>curridx</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN723"><span class='Ref_to_Macro'>NextBufIdx</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN2343"><span class='Ref_To_Local'>curridx</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* If flexible, break out of loop as soon as we wrote something */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN2337"><span class='Ref_to_Parameter'>flexible</span></a> <span class='Operator'>&& </span><a href="xlog.c.html#LN2344"><span class='Ref_To_Local'>npages</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while LogwrtResult.Write&LT;Wr... &raquo; </span> 
 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN2344"><span class='Ref_To_Local'>npages</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If asked to flush, do so 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN423"><span class='Ref_to_Member'>Flush</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN2337"><span class='Ref_to_Parameter'>WriteRqst</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN417"><span class='Ref_to_Member'>Flush</span></a> <span class='Operator'>&& 
</span>        <a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN423"><span class='Ref_to_Member'>Flush</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN422"><span class='Ref_to_Member'>Write</span></a><span class='Parentheses'>) 
</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Could get here without iterating above loop, in which case we might 
         * have no open file or the wrong one.  However, we do not need to 
         * fsync more than one file. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN102"><span class='Ref_to_Global_Var'>sync_method</span></a> <span class='Operator'>!= </span><a href="../../../include/access/xlog.h.html#LN26"><span class='Ref_to_Const'>SYNC_METHOD_OPEN</span></a> <span class='Operator'>&& 
</span>            <a href="xlog.c.html#LN102"><span class='Ref_to_Global_Var'>sync_method</span></a> <span class='Operator'>!= </span><a href="../../../include/access/xlog.h.html#LN28"><span class='Ref_to_Const'>SYNC_METHOD_OPEN_DSYNC</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN770"><span class='Ref_to_Global_Var'>openLogFile</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span> <span class='Operator'>&& 
</span>                <span class='Operator'>!</span><a href="../../../include/access/xlog_internal.h.html#LN120"><span class='Ref_to_Macro'>XLByteInPrevSeg</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN422"><span class='Ref_to_Member'>Write</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN771"><span class='Ref_to_Global_Var'>openLogSegNo</span></a><span class='Parentheses'>))</span> 
                <a href="xlog.c.html#LN878"><span class='Ref_to_Proto'>XLogFileClose</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN770"><span class='Ref_to_Global_Var'>openLogFile</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="../../../include/access/xlog_internal.h.html#LN108"><span class='Ref_to_Macro'>XLByteToPrevSeg</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN422"><span class='Ref_to_Member'>Write</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN771"><span class='Ref_to_Global_Var'>openLogSegNo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="xlog.c.html#LN770"><span class='Ref_to_Global_Var'>openLogFile</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlog.h.html#LN229"><span class='Ref_to_Proto'>XLogFileOpen</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN771"><span class='Ref_to_Global_Var'>openLogSegNo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="xlog.c.html#LN772"><span class='Ref_to_Global_Var'>openLogOff</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <a href="../../../include/access/xlog.h.html#LN240"><span class='Ref_to_Proto'>issue_xlog_fsync</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN770"><span class='Ref_to_Global_Var'>openLogFile</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN771"><span class='Ref_to_Global_Var'>openLogSegNo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* signal that we need to wakeup walsenders later */ 
</span>        <a href="../../../include/replication/walsender.h.html#LN57"><span class='Ref_to_Macro'>WalSndWakeupRequest</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN423"><span class='Ref_to_Member'>Flush</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN422"><span class='Ref_to_Member'>Write</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if LogwrtResult.Flush&LT;Wr... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Update shared-memory status 
     * 
     * We make sure that the shared 'request' values do not fall behind the 
     * 'result' values.  This is not absolutely essential, but it saves some 
     * code in a couple of places. 
     */ 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN599"><span class='Ref_to_Member'>LogwrtResult</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN577"><span class='Ref_to_Member'>LogwrtRqst</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN416"><span class='Ref_to_Member'>Write</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN422"><span class='Ref_to_Member'>Write</span></a><span class='Parentheses'>) 
</span>            <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN577"><span class='Ref_to_Member'>LogwrtRqst</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN416"><span class='Ref_to_Member'>Write</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN422"><span class='Ref_to_Member'>Write</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN577"><span class='Ref_to_Member'>LogwrtRqst</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN417"><span class='Ref_to_Member'>Flush</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN423"><span class='Ref_to_Member'>Flush</span></a><span class='Parentheses'>) 
</span>            <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN577"><span class='Ref_to_Member'>LogwrtRqst</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN417"><span class='Ref_to_Member'>Flush</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN423"><span class='Ref_to_Member'>Flush</span></a><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end XLogWrite &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Record the LSN for an asynchronous transaction commit/abort 
 * and nudge the WALWriter if there is work for it to do. 
 * (This should not be called for synchronous commits.) 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN2607"></a><span class='Declare_Function'>XLogSetAsyncXactLSN</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>asyncXactLSN</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2609"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>WriteRqstPtr</span> <span class='Operator'>= </span><a href="xlog.c.html#LN2607"><span class='Ref_to_Parameter'>asyncXactLSN</span></a><span class='Delimiter'>; 
</span><a name="LN2610"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>sleeping</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN599"><span class='Ref_to_Member'>LogwrtResult</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN2610"><span class='Ref_To_Local'>sleeping</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN654"><span class='Ref_to_Member'>WalWriterSleeping</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN581"><span class='Ref_to_Member'>asyncXactLSN</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN2607"><span class='Ref_to_Parameter'>asyncXactLSN</span></a><span class='Parentheses'>) 
</span>        <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN581"><span class='Ref_to_Member'>asyncXactLSN</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN2607"><span class='Ref_to_Parameter'>asyncXactLSN</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the WALWriter is sleeping, we should kick it to make it come out of 
     * low-power mode.  Otherwise, determine whether there's a full page of 
     * WAL available to write. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN2610"><span class='Ref_To_Local'>sleeping</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* back off to last completed page boundary */ 
</span>        <a href="xlog.c.html#LN2609"><span class='Ref_To_Local'>WriteRqstPtr</span></a> <span class='Operator'>-= </span><a href="xlog.c.html#LN2609"><span class='Ref_To_Local'>WriteRqstPtr</span></a> <span class='Operator'>% </span>XLOG_BLCKSZ<span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* if we have already flushed that far, we're done */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN2609"><span class='Ref_To_Local'>WriteRqstPtr</span></a> <span class='Operator'>&LT;= </span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN423"><span class='Ref_to_Member'>Flush</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Nudge the WALWriter: it has a full page of WAL to write, or we want it 
     * to come out of low-power mode so that this async commit will reach disk 
     * within the expected amount of time. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../storage/lmgr/proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN245"><span class='Ref_to_Member'>walwriterLatch</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/latch.h.html#LN151"><span class='Ref_to_Proto'>SetLatch</span></a><span class='Parentheses'>(</span><a href="../../storage/lmgr/proc.c.html#LN79"><span class='Ref_to_Global_Var'>ProcGlobal</span></a><span class='Operator'>-&GT;</span><a href="../../../include/storage/proc.h.html#LN245"><span class='Ref_to_Member'>walwriterLatch</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end XLogSetAsyncXactLSN &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Record the LSN up to which we can remove WAL because it's not required by 
 * any replication slot. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN2648"></a><span class='Declare_Function'>XLogSetReplicationSlotMinimumLSN</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>lsn</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN582"><span class='Ref_to_Member'>replicationSlotMinLSN</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN2648"><span class='Ref_to_Parameter'>lsn</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Return the oldest LSN we must retain to satisfy the needs of some 
 * replication slot. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> 
<a name="LN2661"></a><span class='Declare_Function'>XLogGetReplicationSlotMinimumLSN</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2663"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>retval</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN2663"><span class='Ref_To_Local'>retval</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN582"><span class='Ref_to_Member'>replicationSlotMinLSN</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="xlog.c.html#LN2663"><span class='Ref_To_Local'>retval</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Advance minRecoveryPoint in control file. 
 * 
 * If we crash during recovery, we must reach this point again before the 
 * database is consistent. 
 * 
 * If 'force' is true, 'lsn' argument is ignored. Otherwise, minRecoveryPoint 
 * is only updated if it's not already greater than or equal to 'lsn'. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2682"></a><span class='Declare_Function'>UpdateMinRecoveryPoint</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>lsn</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>force</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* Quick check using our local copy of the variable */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN823"><span class='Ref_to_Global_Var'>updateMinRecoveryPoint</span></a> <span class='Operator'>|| </span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN2682"><span class='Ref_to_Parameter'>force</span></a> <span class='Operator'>&& </span><a href="xlog.c.html#LN2682"><span class='Ref_to_Parameter'>lsn</span></a> <span class='Operator'>&LT;= </span><a href="xlog.c.html#LN820"><span class='Ref_to_Global_Var'>minRecoveryPoint</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ControlFileLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* update local copy */ 
</span>    <a href="xlog.c.html#LN820"><span class='Ref_to_Global_Var'>minRecoveryPoint</span></a> <span class='Operator'>= </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN169"><span class='Ref_to_Member'>minRecoveryPoint</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN822"><span class='Ref_to_Global_Var'>minRecoveryPointTLI</span></a> <span class='Operator'>= </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN170"><span class='Ref_to_Member'>minRecoveryPointTLI</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * An invalid minRecoveryPoint means that we need to recover all the WAL, 
     * i.e., we're doing crash recovery.  We never modify the control file's 
     * value in that case, so we can short-circuit future checks here too. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN820"><span class='Ref_to_Global_Var'>minRecoveryPoint</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="xlog.c.html#LN823"><span class='Ref_to_Global_Var'>updateMinRecoveryPoint</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN2682"><span class='Ref_to_Parameter'>force</span></a> <span class='Operator'>|| </span><a href="xlog.c.html#LN820"><span class='Ref_to_Global_Var'>minRecoveryPoint</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN2682"><span class='Ref_to_Parameter'>lsn</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2703"></a>        <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>newMinRecoveryPoint</span><span class='Delimiter'>; 
</span><a name="LN2704"></a>        <a href="../../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a>  <span class='Declare_Local'>newMinRecoveryPointTLI</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * To avoid having to update the control file too often, we update it 
         * all the way to the last record being replayed, even though 'lsn' 
         * would suffice for correctness.  This also allows the 'force' case 
         * to not need a valid 'lsn' value. 
         * 
         * Another important reason for doing it this way is that the passed 
         * 'lsn' value could be bogus, i.e., past the end of available WAL, if 
         * the caller got it from a corrupted heap page.  Accepting such a 
         * value as the min recovery point would prevent us from coming up at 
         * all.  Instead, we just log a warning and continue with recovery. 
         * (See also the comments about corrupt LSNs in XLogFlush.) 
         */ 
</span>        <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN2703"><span class='Ref_To_Local'>newMinRecoveryPoint</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN683"><span class='Ref_to_Member'>replayEndRecPtr</span></a><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN2704"><span class='Ref_To_Local'>newMinRecoveryPointTLI</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN684"><span class='Ref_to_Member'>replayEndTLI</span></a><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN2682"><span class='Ref_to_Parameter'>force</span></a> <span class='Operator'>&& </span><a href="xlog.c.html#LN2703"><span class='Ref_To_Local'>newMinRecoveryPoint</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN2682"><span class='Ref_to_Parameter'>lsn</span></a><span class='Parentheses'>) 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN39"><span class='Ref_to_Const'>WARNING</span></a><span class='Delimiter'>, 
</span>               <span class='String'>"xlog min recovery request %X/%X is past current point %X/%X"</span><span class='Delimiter'>, 
</span>                 <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN2682"><span class='Ref_to_Parameter'>lsn</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN2682"><span class='Ref_to_Parameter'>lsn</span></a><span class='Delimiter'>, 
</span>                 <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN2703"><span class='Ref_To_Local'>newMinRecoveryPoint</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN2703"><span class='Ref_To_Local'>newMinRecoveryPoint</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* update control file */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN169"><span class='Ref_to_Member'>minRecoveryPoint</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN2703"><span class='Ref_To_Local'>newMinRecoveryPoint</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN169"><span class='Ref_to_Member'>minRecoveryPoint</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN2703"><span class='Ref_To_Local'>newMinRecoveryPoint</span></a><span class='Delimiter'>; 
</span>            <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN170"><span class='Ref_to_Member'>minRecoveryPointTLI</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN2704"><span class='Ref_To_Local'>newMinRecoveryPointTLI</span></a><span class='Delimiter'>; 
</span>            <a href="../../../include/access/xlog.h.html#LN256"><span class='Ref_to_Proto'>UpdateControlFile</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN820"><span class='Ref_to_Global_Var'>minRecoveryPoint</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN2703"><span class='Ref_To_Local'>newMinRecoveryPoint</span></a><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN822"><span class='Ref_to_Global_Var'>minRecoveryPointTLI</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN2704"><span class='Ref_To_Local'>newMinRecoveryPointTLI</span></a><span class='Delimiter'>; 
</span> 
            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"updated min recovery point to %X/%X on timeline %u"</span><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN820"><span class='Ref_to_Global_Var'>minRecoveryPoint</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN820"><span class='Ref_to_Global_Var'>minRecoveryPoint</span></a><span class='Delimiter'>, 
</span>                        <a href="xlog.c.html#LN2704"><span class='Ref_To_Local'>newMinRecoveryPointTLI</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if force||minRecoveryPoi... &raquo; </span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ControlFileLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end UpdateMinRecoveryPoint &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Ensure that all XLOG data through the given position is flushed to disk. 
 * 
 * NOTE: this differs from XLogWrite mainly in that the WALWriteLock is not 
 * already held, and we try to avoid acquiring it if possible. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN2757"></a><span class='Declare_Function'>XLogFlush</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>record</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2759"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>WriteRqstPtr</span><span class='Delimiter'>; 
</span><a name="LN2760"></a>    <a href="xlog.c.html#LN414"><span class='Ref_to_Struct'>XLogwrtRqst</span></a> <span class='Declare_Local'>WriteRqst</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * During REDO, we are reading not writing WAL.  Therefore, instead of 
     * trying to flush the WAL, we should update minRecoveryPoint instead. We 
     * test XLogInsertAllowed(), not InRecovery, because we need checkpointer 
     * to act this way too, and because when it tries to write the 
     * end-of-recovery checkpoint, it should indeed flush. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/xlog.h.html#LN245"><span class='Ref_to_Proto'>XLogInsertAllowed</span></a><span class='Parentheses'>())</span> 
    <span class='Delimiter'>{ 
</span>        <a href="xlog.c.html#LN885"><span class='Ref_to_Proto'>UpdateMinRecoveryPoint</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN2757"><span class='Ref_to_Parameter'>record</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Quick exit if already known flushed */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN2757"><span class='Ref_to_Parameter'>record</span></a> <span class='Operator'>&LT;= </span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN423"><span class='Ref_to_Member'>Flush</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifdef</span> WAL_DEBUG 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN109"><span class='Ref_to_Global_Var'>XLOG_DEBUG</span></a><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, </span><span class='String'>"xlog flush request %X/%X; write %X/%X; flush %X/%X"</span><span class='Delimiter'>, 
</span>             <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN2757"><span class='Ref_to_Parameter'>record</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN2757"><span class='Ref_to_Parameter'>record</span></a><span class='Delimiter'>, 
</span>             <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN422"><span class='Ref_to_Member'>Write</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN422"><span class='Ref_to_Member'>Write</span></a><span class='Delimiter'>, 
</span>           <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN423"><span class='Ref_to_Member'>Flush</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN423"><span class='Ref_to_Member'>Flush</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
    <a href="../../../include/miscadmin.h.html#LN132"><span class='Ref_to_Macro'>START_CRIT_SECTION</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Since fsync is usually a horribly expensive operation, we try to 
     * piggyback as much data as we can on each fsync: if we see any more data 
     * entered into the xlog buffer, we'll write and fsync that too, so that 
     * the final value of LogwrtResult.Flush is as large as possible. This 
     * gives us some chance of avoiding another fsync immediately after. 
     */ 
</span> 
    <span class='Comment_Multi_Line'>/* initialize to given target; may increase below */ 
</span>    <a href="xlog.c.html#LN2759"><span class='Ref_To_Local'>WriteRqstPtr</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN2757"><span class='Ref_to_Parameter'>record</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now wait until we get the write lock, or someone else does the flush 
     * for us. 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>;;</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2806"></a>        <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>insertpos</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* read LogwrtResult and update local state */ 
</span>        <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN2759"><span class='Ref_To_Local'>WriteRqstPtr</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN577"><span class='Ref_to_Member'>LogwrtRqst</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN416"><span class='Ref_to_Member'>Write</span></a><span class='Parentheses'>) 
</span>            <a href="xlog.c.html#LN2759"><span class='Ref_To_Local'>WriteRqstPtr</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN577"><span class='Ref_to_Member'>LogwrtRqst</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN416"><span class='Ref_to_Member'>Write</span></a><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN599"><span class='Ref_to_Member'>LogwrtResult</span></a><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* done already? */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN2757"><span class='Ref_to_Parameter'>record</span></a> <span class='Operator'>&LT;= </span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN423"><span class='Ref_to_Member'>Flush</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Before actually performing the write, wait for all in-flight 
         * insertions to the pages we're about to write to finish. 
         */ 
</span>        <a href="xlog.c.html#LN2806"><span class='Ref_To_Local'>insertpos</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN917"><span class='Ref_to_Proto'>WaitXLogInsertionsToFinish</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN2759"><span class='Ref_To_Local'>WriteRqstPtr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Try to get the write lock. If we can't get it immediately, wait 
         * until it's released, and recheck if we still need to do the flush 
         * or if the backend that held the lock did it for us already. This 
         * helps to maintain a good rate of group committing when the system 
         * is bottlenecked by the speed of fsyncing. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/storage/lwlock.h.html#LN147"><span class='Ref_to_Proto'>LWLockAcquireOrWait</span></a><span class='Parentheses'>(</span>WALWriteLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * The lock is now free, but we didn't acquire it yet. Before we 
             * do, loop back to check if someone else flushed the record for 
             * us already. 
             */ 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* Got the lock; recheck whether request is satisfied */ 
</span>        <a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN599"><span class='Ref_to_Member'>LogwrtResult</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN2757"><span class='Ref_to_Parameter'>record</span></a> <span class='Operator'>&LT;= </span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN423"><span class='Ref_to_Member'>Flush</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>WALWriteLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Sleep before flush! By adding a delay here, we may give further 
         * backends the opportunity to join the backlog of group commit 
         * followers; this can significantly improve transaction throughput, 
         * at the risk of increasing transaction latency. 
         * 
         * We do not sleep if enableFsync is not turned on, nor if there are 
         * fewer than CommitSiblings other backends with active transactions. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN104"><span class='Ref_to_Global_Var'>CommitDelay</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="../../utils/init/globals.c.html#LN110"><span class='Ref_to_Global_Var'>enableFsync</span></a> <span class='Operator'>&& 
</span>            <a href="../../../include/storage/procarray.h.html#LN109"><span class='Ref_to_Proto'>MinimumActiveBackends</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN105"><span class='Ref_to_Global_Var'>CommitSiblings</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="../../../port/pgsleep.c.html#LN45"><span class='Ref_to_Func'>pg_usleep</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN104"><span class='Ref_to_Global_Var'>CommitDelay</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Re-check how far we can now flush the WAL. It's generally not 
             * safe to call WaitXLogInsertionsToFinish while holding 
             * WALWriteLock, because an in-progress insertion might need to 
             * also grab WALWriteLock to make progress. But we know that all 
             * the insertions up to insertpos have already finished, because 
             * that's what the earlier WaitXLogInsertionsToFinish() returned. 
             * We're only calling it again to allow insertpos to be moved 
             * further forward, not to actually wait for anyone. 
             */ 
</span>            <a href="xlog.c.html#LN2806"><span class='Ref_To_Local'>insertpos</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN917"><span class='Ref_to_Proto'>WaitXLogInsertionsToFinish</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN2806"><span class='Ref_To_Local'>insertpos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* try to write/flush later additions to XLOG as well */ 
</span>        <a href="xlog.c.html#LN2760"><span class='Ref_To_Local'>WriteRqst</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN416"><span class='Ref_to_Member'>Write</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN2806"><span class='Ref_To_Local'>insertpos</span></a><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN2760"><span class='Ref_To_Local'>WriteRqst</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN417"><span class='Ref_to_Member'>Flush</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN2806"><span class='Ref_To_Local'>insertpos</span></a><span class='Delimiter'>; 
</span> 
        <a href="xlog.c.html#LN865"><span class='Ref_to_Proto'>XLogWrite</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN2760"><span class='Ref_To_Local'>WriteRqst</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>WALWriteLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* done */ 
</span>        <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for ;; &raquo; </span> 
 
    <a href="../../../include/miscadmin.h.html#LN134"><span class='Ref_to_Macro'>END_CRIT_SECTION</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* wake up walsenders now that we've released heavily contended locks */ 
</span>    <a href="../../../include/replication/walsender.h.html#LN63"><span class='Ref_to_Macro'>WalSndWakeupProcessRequests</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we still haven't flushed to the request point then we have a 
     * problem; most likely, the requested flush point is past end of XLOG. 
     * This has been seen to occur when a disk page has a corrupted LSN. 
     * 
     * Formerly we treated this as a PANIC condition, but that hurts the 
     * system's robustness rather than helping it: we do not want to take down 
     * the whole system due to corruption on one data page.  In particular, if 
     * the bad page is encountered again during recovery then we would be 
     * unable to restart the database at all!  (This scenario actually 
     * happened in the field several times with 7.1 releases.)  As of 8.4, bad 
     * LSNs encountered during recovery are UpdateMinRecoveryPoint's problem; 
     * the only time we can reach here during recovery is while flushing the 
     * end-of-recovery checkpoint record, and we don't expect that to have a 
     * bad LSN. 
     * 
     * Note that for calls from xact.c, the ERROR will be promoted to PANIC 
     * since xact.c calls this routine inside a critical section.  However, 
     * calls from bufmgr.c are not within critical sections and so we will not 
     * force a restart for a bad LSN on a data page. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN423"><span class='Ref_to_Member'>Flush</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN2757"><span class='Ref_to_Parameter'>record</span></a><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>        <span class='String'>"xlog flush request %X/%X is not satisfied --- flushed only to %X/%X"</span><span class='Delimiter'>, 
</span>             <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN2757"><span class='Ref_to_Parameter'>record</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN2757"><span class='Ref_to_Parameter'>record</span></a><span class='Delimiter'>, 
</span>           <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN423"><span class='Ref_to_Member'>Flush</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN423"><span class='Ref_to_Member'>Flush</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end XLogFlush &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Write & flush xlog, but without specifying exactly where to. 
 * 
 * We normally write only completed blocks; but if there is nothing to do on 
 * that basis, we check for unwritten async commits in the current incomplete 
 * block, and write through the latest one of those.  Thus, if async commits 
 * are not being used, we will write complete blocks only. 
 * 
 * If, based on the above, there's anything to write we do so immediately. But 
 * to avoid calling fsync, fdatasync et. al. at a rate that'd impact 
 * concurrent IO, we only flush WAL every wal_writer_delay ms, or if there's 
 * more than wal_writer_flush_after unflushed blocks. 
 * 
 * We can guarantee that async commits reach disk after at most three 
 * wal_writer_delay cycles. (When flushing complete blocks, we allow XLogWrite 
 * to write "flexibly", meaning it can stop at the end of the buffer ring; 
 * this makes a difference only with very high load or long wal_writer_delay, 
 * but imposes one extra cycle for the worst case for async commits.) 
 * 
 * This routine is invoked periodically by the background walwriter process. 
 * 
 * Returns TRUE if there was any work to do, even if we skipped flushing due 
 * to wal_writer_delay/wal_writer_flush_after. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN2946"></a><span class='Declare_Function'>XLogBackgroundFlush</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2948"></a>    <a href="xlog.c.html#LN414"><span class='Ref_to_Struct'>XLogwrtRqst</span></a> <span class='Declare_Local'>WriteRqst</span><span class='Delimiter'>; 
</span><a name="LN2949"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>flexible</span> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span><a name="LN2950"></a>    <span class='Keyword'>static </span><a href="../../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <span class='Declare_Local'>lastflush</span><span class='Delimiter'>; 
</span><a name="LN2951"></a>    <a href="../../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <span class='Declare_Local'>now</span><span class='Delimiter'>; 
</span><a name="LN2952"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>flushbytes</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* XLOG doesn't need flushing during recovery */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN242"><span class='Ref_to_Proto'>RecoveryInProgress</span></a><span class='Parentheses'>())</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* read LogwrtResult and update local state */ 
</span>    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN599"><span class='Ref_to_Member'>LogwrtResult</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN2948"><span class='Ref_To_Local'>WriteRqst</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN577"><span class='Ref_to_Member'>LogwrtRqst</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* back off to last completed page boundary */ 
</span>    <a href="xlog.c.html#LN2948"><span class='Ref_To_Local'>WriteRqst</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN416"><span class='Ref_to_Member'>Write</span></a> <span class='Operator'>-= </span><a href="xlog.c.html#LN2948"><span class='Ref_To_Local'>WriteRqst</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN416"><span class='Ref_to_Member'>Write</span></a> <span class='Operator'>% </span>XLOG_BLCKSZ<span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* if we have already flushed that far, consider async commit records */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN2948"><span class='Ref_To_Local'>WriteRqst</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN416"><span class='Ref_to_Member'>Write</span></a> <span class='Operator'>&LT;= </span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN423"><span class='Ref_to_Member'>Flush</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN2948"><span class='Ref_To_Local'>WriteRqst</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN416"><span class='Ref_to_Member'>Write</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN581"><span class='Ref_to_Member'>asyncXactLSN</span></a><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN2949"><span class='Ref_To_Local'>flexible</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* ensure it all gets written */ 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If already known flushed, we're done. Just need to check if we are 
     * holding an open file handle to a logfile that's no longer in use, 
     * preventing the file from being deleted. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN2948"><span class='Ref_To_Local'>WriteRqst</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN416"><span class='Ref_to_Member'>Write</span></a> <span class='Operator'>&LT;= </span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN423"><span class='Ref_to_Member'>Flush</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN770"><span class='Ref_to_Global_Var'>openLogFile</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/xlog_internal.h.html#LN120"><span class='Ref_to_Macro'>XLByteInPrevSeg</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN422"><span class='Ref_to_Member'>Write</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN771"><span class='Ref_to_Global_Var'>openLogSegNo</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <a href="xlog.c.html#LN878"><span class='Ref_to_Proto'>XLogFileClose</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Determine how far to flush WAL, based on the wal_writer_delay and 
     * wal_writer_flush_after GUCs. 
     */ 
</span>    <a href="xlog.c.html#LN2951"><span class='Ref_To_Local'>now</span></a> <span class='Operator'>= </span><a href="../../../include/utils/timestamp.h.html#LN69"><span class='Ref_to_Proto'>GetCurrentTimestamp</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN2952"><span class='Ref_To_Local'>flushbytes</span></a> <span class='Operator'>= 
</span>        <a href="xlog.c.html#LN2948"><span class='Ref_To_Local'>WriteRqst</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN416"><span class='Ref_to_Member'>Write</span></a> <span class='Operator'>/ </span>XLOG_BLCKSZ <span class='Operator'>- </span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN423"><span class='Ref_to_Member'>Flush</span></a> <span class='Operator'>/ </span>XLOG_BLCKSZ<span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../postmaster/walwriter.c.html#LN68"><span class='Ref_to_Global_Var'>WalWriterFlushAfter</span></a> <span class='Operator'>== </span><span class='Number'>0</span> <span class='Operator'>|| </span><a href="xlog.c.html#LN2950"><span class='Ref_To_Local'>lastflush</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* first call, or block based limits disabled */ 
</span>        <a href="xlog.c.html#LN2948"><span class='Ref_To_Local'>WriteRqst</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN417"><span class='Ref_to_Member'>Flush</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN2948"><span class='Ref_To_Local'>WriteRqst</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN416"><span class='Ref_to_Member'>Write</span></a><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN2950"><span class='Ref_To_Local'>lastflush</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN2951"><span class='Ref_To_Local'>now</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/timestamp.h.html#LN74"><span class='Ref_to_Proto'>TimestampDifferenceExceeds</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN2950"><span class='Ref_To_Local'>lastflush</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN2951"><span class='Ref_To_Local'>now</span></a><span class='Delimiter'>, </span><a href="../../postmaster/walwriter.c.html#LN67"><span class='Ref_to_Global_Var'>WalWriterDelay</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Flush the writes at least every WalWriteDelay ms. This is important 
         * to bound the amount of time it takes for an asynchronous commit to 
         * hit disk. 
         */ 
</span>        <a href="xlog.c.html#LN2948"><span class='Ref_To_Local'>WriteRqst</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN417"><span class='Ref_to_Member'>Flush</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN2948"><span class='Ref_To_Local'>WriteRqst</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN416"><span class='Ref_to_Member'>Write</span></a><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN2950"><span class='Ref_To_Local'>lastflush</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN2951"><span class='Ref_To_Local'>now</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN2952"><span class='Ref_To_Local'>flushbytes</span></a> <span class='Operator'>&GT;= </span><a href="../../postmaster/walwriter.c.html#LN68"><span class='Ref_to_Global_Var'>WalWriterFlushAfter</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* exceeded wal_writer_flush_after blocks, flush */ 
</span>        <a href="xlog.c.html#LN2948"><span class='Ref_To_Local'>WriteRqst</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN417"><span class='Ref_to_Member'>Flush</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN2948"><span class='Ref_To_Local'>WriteRqst</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN416"><span class='Ref_to_Member'>Write</span></a><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN2950"><span class='Ref_To_Local'>lastflush</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN2951"><span class='Ref_To_Local'>now</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* no flushing, this time round */ 
</span>        <a href="xlog.c.html#LN2948"><span class='Ref_To_Local'>WriteRqst</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN417"><span class='Ref_to_Member'>Flush</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
<span class='Directive'>#ifdef</span> WAL_DEBUG 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN109"><span class='Ref_to_Global_Var'>XLOG_DEBUG</span></a><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, </span><span class='String'>"xlog bg flush request write %X/%X; flush: %X/%X, current is write %X/%X; flush %X/%X"</span><span class='Delimiter'>, 
</span>             <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN2948"><span class='Ref_To_Local'>WriteRqst</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN416"><span class='Ref_to_Member'>Write</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN2948"><span class='Ref_To_Local'>WriteRqst</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN416"><span class='Ref_to_Member'>Write</span></a><span class='Delimiter'>, 
</span>             <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN2948"><span class='Ref_To_Local'>WriteRqst</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN417"><span class='Ref_to_Member'>Flush</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN2948"><span class='Ref_To_Local'>WriteRqst</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN417"><span class='Ref_to_Member'>Flush</span></a><span class='Delimiter'>, 
</span>             <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN422"><span class='Ref_to_Member'>Write</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN422"><span class='Ref_to_Member'>Write</span></a><span class='Delimiter'>, 
</span>           <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN423"><span class='Ref_to_Member'>Flush</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN423"><span class='Ref_to_Member'>Flush</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
    <a href="../../../include/miscadmin.h.html#LN132"><span class='Ref_to_Macro'>START_CRIT_SECTION</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* now wait for any in-progress insertions to finish and get write lock */ 
</span>    <a href="xlog.c.html#LN917"><span class='Ref_to_Proto'>WaitXLogInsertionsToFinish</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN2948"><span class='Ref_To_Local'>WriteRqst</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN416"><span class='Ref_to_Member'>Write</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>WALWriteLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN599"><span class='Ref_to_Member'>LogwrtResult</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN2948"><span class='Ref_To_Local'>WriteRqst</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN416"><span class='Ref_to_Member'>Write</span></a> <span class='Operator'>&GT; </span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN422"><span class='Ref_to_Member'>Write</span></a> <span class='Operator'>|| 
</span>        <a href="xlog.c.html#LN2948"><span class='Ref_To_Local'>WriteRqst</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN417"><span class='Ref_to_Member'>Flush</span></a> <span class='Operator'>&GT; </span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN423"><span class='Ref_to_Member'>Flush</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="xlog.c.html#LN865"><span class='Ref_to_Proto'>XLogWrite</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN2948"><span class='Ref_To_Local'>WriteRqst</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN2949"><span class='Ref_To_Local'>flexible</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>WALWriteLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/miscadmin.h.html#LN134"><span class='Ref_to_Macro'>END_CRIT_SECTION</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* wake up walsenders now that we've released heavily contended locks */ 
</span>    <a href="../../../include/replication/walsender.h.html#LN63"><span class='Ref_to_Macro'>WalSndWakeupProcessRequests</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Great, done. To take some work off the critical path, try to initialize 
     * as many of the no-longer-needed WAL buffers for future use as we can. 
     */ 
</span>    <a href="xlog.c.html#LN863"><span class='Ref_to_Proto'>AdvanceXLInsertBuffer</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we determined that we need to write data, but somebody else 
     * wrote/flushed already, it should be considered as being active, to 
     * avoid hibernating too early. 
     */ 
</span>    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end XLogBackgroundFlush &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Test whether XLOG data has been flushed up to (at least) the given position. 
 * 
 * Returns true if a flush is still needed.  (It may be that someone else 
 * is already in process of flushing that far, however.) 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN3077"></a><span class='Declare_Function'>XLogNeedsFlush</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>record</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * During recovery, we don't flush WAL but update minRecoveryPoint 
     * instead. So "needs flush" is taken to mean whether minRecoveryPoint 
     * would need to be updated. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN242"><span class='Ref_to_Proto'>RecoveryInProgress</span></a><span class='Parentheses'>())</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Quick exit if already known updated */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN3077"><span class='Ref_to_Parameter'>record</span></a> <span class='Operator'>&LT;= </span><a href="xlog.c.html#LN820"><span class='Ref_to_Global_Var'>minRecoveryPoint</span></a> <span class='Operator'>|| !</span><a href="xlog.c.html#LN823"><span class='Ref_to_Global_Var'>updateMinRecoveryPoint</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Update local copy of minRecoveryPoint. But if the lock is busy, 
         * just return a conservative guess. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/storage/lwlock.h.html#LN146"><span class='Ref_to_Proto'>LWLockConditionalAcquire</span></a><span class='Parentheses'>(</span>ControlFileLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN820"><span class='Ref_to_Global_Var'>minRecoveryPoint</span></a> <span class='Operator'>= </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN169"><span class='Ref_to_Member'>minRecoveryPoint</span></a><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN822"><span class='Ref_to_Global_Var'>minRecoveryPointTLI</span></a> <span class='Operator'>= </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN170"><span class='Ref_to_Member'>minRecoveryPointTLI</span></a><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ControlFileLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * An invalid minRecoveryPoint means that we need to recover all the 
         * WAL, i.e., we're doing crash recovery.  We never modify the control 
         * file's value in that case, so we can short-circuit future checks 
         * here too. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN820"><span class='Ref_to_Global_Var'>minRecoveryPoint</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <a href="xlog.c.html#LN823"><span class='Ref_to_Global_Var'>updateMinRecoveryPoint</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* check again */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN3077"><span class='Ref_to_Parameter'>record</span></a> <span class='Operator'>&LT;= </span><a href="xlog.c.html#LN820"><span class='Ref_to_Global_Var'>minRecoveryPoint</span></a> <span class='Operator'>|| !</span><a href="xlog.c.html#LN823"><span class='Ref_to_Global_Var'>updateMinRecoveryPoint</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if RecoveryInProgress() &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* Quick exit if already known flushed */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN3077"><span class='Ref_to_Parameter'>record</span></a> <span class='Operator'>&LT;= </span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN423"><span class='Ref_to_Member'>Flush</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* read LogwrtResult and update local state */ 
</span>    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN599"><span class='Ref_to_Member'>LogwrtResult</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* check again */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN3077"><span class='Ref_to_Parameter'>record</span></a> <span class='Operator'>&LT;= </span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN423"><span class='Ref_to_Member'>Flush</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end XLogNeedsFlush &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Create a new XLOG file segment, or open a pre-existing one. 
 * 
 * log, seg: identify segment to be created/opened. 
 * 
 * *use_existent: if TRUE, OK to use a pre-existing file (else, any 
 * pre-existing file will be deleted).  On return, TRUE if a pre-existing 
 * file was used. 
 * 
 * use_lock: if TRUE, acquire ControlFileLock while moving file into 
 * place.  This should be TRUE except during bootstrap log creation.  The 
 * caller must *not* hold the lock at call. 
 * 
 * Returns FD of opened file. 
 * 
 * Note: errors here are ERROR not PANIC because we might or might not be 
 * inside a critical section (eg, during checkpoint there is no reason to 
 * take down the system on failure).  They will promote to PANIC if we are 
 * in a critical section. 
 */ 
</span><span class='Keyword'>int 
</span><a name="LN3153"></a><span class='Declare_Function'>XLogFileInit</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a> <span class='Declare_Parameter'>logsegno</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>use_existent</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>use_lock</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3155"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>path</span><span class='Delimiter'>[</span><a href="../../../include/pg_config_manual.h.html#LN88"><span class='Ref_to_Const'>MAXPGPATH</span></a><span class='Delimiter'>]; 
</span><a name="LN3156"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>tmppath</span><span class='Delimiter'>[</span><a href="../../../include/pg_config_manual.h.html#LN88"><span class='Ref_to_Const'>MAXPGPATH</span></a><span class='Delimiter'>]; 
</span><a name="LN3157"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>zbuffer_raw</span><span class='Delimiter'>[</span>XLOG_BLCKSZ <span class='Operator'>+ </span>MAXIMUM_ALIGNOF<span class='Delimiter'>]; 
</span><a name="LN3158"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>zbuffer</span><span class='Delimiter'>; 
</span><a name="LN3159"></a>    <a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a>   <span class='Declare_Local'>installed_segno</span><span class='Delimiter'>; 
</span><a name="LN3160"></a>    <a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a>   <span class='Declare_Local'>max_segno</span><span class='Delimiter'>; 
</span><a name="LN3161"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>fd</span><span class='Delimiter'>; 
</span><a name="LN3162"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>nbytes</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/access/xlog_internal.h.html#LN172"><span class='Ref_to_Macro'>XLogFilePath</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3155"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN3153"><span class='Ref_to_Parameter'>logsegno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Try to use existent file (checkpoint maker may have created it already) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="xlog.c.html#LN3153"><span class='Ref_to_Parameter'>use_existent</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="xlog.c.html#LN3161"><span class='Ref_To_Local'>fd</span></a> <span class='Operator'>= </span><a href="../../../include/storage/fd.h.html#LN100"><span class='Ref_to_Proto'>BasicOpenFile</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3155"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, </span>O_RDWR <span class='Operator'>| </span><a href="../../../include/c.h.html#LN1032"><span class='Ref_to_Const'>PG_BINARY</span></a> <span class='Operator'>| </span><a href="xlog.c.html#LN908"><span class='Ref_to_Proto'>get_sync_bit</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN102"><span class='Ref_to_Global_Var'>sync_method</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                           <a href="../../../include/port/win32.h.html#LN424"><span class='Ref_to_Const'>S_IRUSR</span></a> <span class='Operator'>| </span><a href="../../../include/port/win32.h.html#LN425"><span class='Ref_to_Const'>S_IWUSR</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN3161"><span class='Ref_To_Local'>fd</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span>errno <span class='Operator'>!= </span>ENOENT<span class='Parentheses'>) 
</span>                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                         <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not open file \"%s\": %m"</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN3155"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
            <span class='Control'>return</span> <a href="xlog.c.html#LN3161"><span class='Ref_To_Local'>fd</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Initialize an empty (all zeroes) segment.  NOTE: it is possible that 
     * another process is doing the same thing.  If so, we will end up 
     * pre-creating an extra log segment.  That seems OK, and better than 
     * holding the lock throughout this lengthy process. 
     */ 
</span>    <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Delimiter'>, </span><span class='String'>"creating and filling new WAL file"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../pl/plperl/plperl.h.html#LN60"><span class='Ref_to_Macro'>snprintf</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3156"><span class='Ref_To_Local'>tmppath</span></a><span class='Delimiter'>, </span><a href="../../../include/pg_config_manual.h.html#LN88"><span class='Ref_to_Const'>MAXPGPATH</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xlog_internal.h.html#LN130"><span class='Ref_to_Const'>XLOGDIR</span></a> <span class='String'>"/xlogtemp.%d"</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span>getpid<span class='Parentheses'>())</span><span class='Delimiter'>; 
</span> 
    <a href="../../../timezone/private.h.html#LN59"><span class='Ref_to_Proto'>unlink</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3156"><span class='Ref_To_Local'>tmppath</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* do not use get_sync_bit() here --- want to fsync only at end of fill */ 
</span>    <a href="xlog.c.html#LN3161"><span class='Ref_To_Local'>fd</span></a> <span class='Operator'>= </span><a href="../../../include/storage/fd.h.html#LN100"><span class='Ref_to_Proto'>BasicOpenFile</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3156"><span class='Ref_To_Local'>tmppath</span></a><span class='Delimiter'>, </span>O_RDWR <span class='Operator'>| </span>O_CREAT <span class='Operator'>| </span>O_EXCL <span class='Operator'>| </span><a href="../../../include/c.h.html#LN1032"><span class='Ref_to_Const'>PG_BINARY</span></a><span class='Delimiter'>, 
</span>                       <a href="../../../include/port/win32.h.html#LN424"><span class='Ref_to_Const'>S_IRUSR</span></a> <span class='Operator'>| </span><a href="../../../include/port/win32.h.html#LN425"><span class='Ref_to_Const'>S_IWUSR</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN3161"><span class='Ref_To_Local'>fd</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not create file \"%s\": %m"</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN3156"><span class='Ref_To_Local'>tmppath</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Zero-fill the file.  We have to do this the hard way to ensure that all 
     * the file space has really been allocated --- on platforms that allow 
     * "holes" in files, just seeking to the end doesn't allocate intermediate 
     * space.  This way, we know that we have all the space and (after the 
     * fsync below) that all the indirect blocks are down on disk.  Therefore, 
     * fdatasync(2) or O_DSYNC will be sufficient to sync future writes to the 
     * log file. 
     * 
     * Note: ensure the buffer is reasonably well-aligned; this may save a few 
     * cycles transferring data to the kernel. 
     */ 
</span>    <a href="xlog.c.html#LN3158"><span class='Ref_To_Local'>zbuffer</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/c.h.html#LN587"><span class='Ref_to_Macro'>MAXALIGN</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3157"><span class='Ref_To_Local'>zbuffer_raw</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    memset<span class='Parentheses'>(</span><a href="xlog.c.html#LN3158"><span class='Ref_To_Local'>zbuffer</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span>XLOG_BLCKSZ<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN3162"><span class='Ref_To_Local'>nbytes</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="xlog.c.html#LN3162"><span class='Ref_To_Local'>nbytes</span></a> <span class='Operator'>&LT; </span><a href="../../../include/access/xlog_internal.h.html#LN91"><span class='Ref_to_Const'>XLogSegSize</span></a><span class='Delimiter'>; </span><a href="xlog.c.html#LN3162"><span class='Ref_To_Local'>nbytes</span></a> <span class='Operator'>+= </span>XLOG_BLCKSZ<span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        errno <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="../../../include/pgstat.h.html#LN1206"><span class='Ref_to_Func'>pgstat_report_wait_start</span></a><span class='Parentheses'>(</span><a href="../../../include/pgstat.h.html#LN901"><span class='Ref_to_EnumConst'>WAIT_EVENT_WAL_INIT_WRITE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>((</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="../../../interfaces/libpq/win32.h.html#LN13"><span class='Ref_to_Macro'>write</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3161"><span class='Ref_To_Local'>fd</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN3158"><span class='Ref_To_Local'>zbuffer</span></a><span class='Delimiter'>, </span>XLOG_BLCKSZ<span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span>XLOG_BLCKSZ<span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span><a name="LN3224"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>save_errno</span> <span class='Operator'>= </span>errno<span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * If we fail to make the file, delete it to release disk space 
             */ 
</span>            <a href="../../../timezone/private.h.html#LN59"><span class='Ref_to_Proto'>unlink</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3156"><span class='Ref_To_Local'>tmppath</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="../../../interfaces/libpq/win32.h.html#LN11"><span class='Ref_to_Macro'>close</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3161"><span class='Ref_To_Local'>fd</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* if write didn't set errno, assume problem is no disk space */ 
</span>            errno <span class='Operator'>= </span><a href="xlog.c.html#LN3224"><span class='Ref_To_Local'>save_errno</span></a> <span class='Operator'>? </span><a href="xlog.c.html#LN3224"><span class='Ref_To_Local'>save_errno</span></a> <span class='Operator'>: </span>ENOSPC<span class='Delimiter'>; 
</span> 
            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                     <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not write to file \"%s\": %m"</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN3156"><span class='Ref_To_Local'>tmppath</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <a href="../../../include/pgstat.h.html#LN1230"><span class='Ref_to_Func'>pgstat_report_wait_end</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for nbytes=0;nbytes&LT;XLogS... &raquo; </span> 
 
    <a href="../../../include/pgstat.h.html#LN1206"><span class='Ref_to_Func'>pgstat_report_wait_start</span></a><span class='Parentheses'>(</span><a href="../../../include/pgstat.h.html#LN900"><span class='Ref_to_EnumConst'>WAIT_EVENT_WAL_INIT_SYNC</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/fd.h.html#LN114"><span class='Ref_to_Proto'>pg_fsync</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3161"><span class='Ref_To_Local'>fd</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../interfaces/libpq/win32.h.html#LN11"><span class='Ref_to_Macro'>close</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3161"><span class='Ref_To_Local'>fd</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not fsync file \"%s\": %m"</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN3156"><span class='Ref_To_Local'>tmppath</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="../../../include/pgstat.h.html#LN1230"><span class='Ref_to_Func'>pgstat_report_wait_end</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../interfaces/libpq/win32.h.html#LN11"><span class='Ref_to_Macro'>close</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3161"><span class='Ref_To_Local'>fd</span></a><span class='Parentheses'>))</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not close file \"%s\": %m"</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN3156"><span class='Ref_To_Local'>tmppath</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now move the segment into place with its final name. 
     * 
     * If caller didn't want to use a pre-existing file, get rid of any 
     * pre-existing file.  Otherwise, cope with possibility that someone else 
     * has created the file while we were filling ours: if so, use ours to 
     * pre-create a future log segment. 
     */ 
</span>    <a href="xlog.c.html#LN3159"><span class='Ref_To_Local'>installed_segno</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN3153"><span class='Ref_to_Parameter'>logsegno</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * XXX: What should we use as max_segno? We used to use XLOGfileslop when 
     * that was a constant, but that was always a bit dubious: normally, at a 
     * checkpoint, XLOGfileslop was the offset from the checkpoint record, but 
     * here, it was the offset from the insert location. We can't do the 
     * normal XLOGfileslop calculation here because we don't have access to 
     * the prior checkpoint's redo location. So somewhat arbitrarily, just use 
     * CheckPointSegments. 
     */ 
</span>    <a href="xlog.c.html#LN3160"><span class='Ref_To_Local'>max_segno</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN3153"><span class='Ref_to_Parameter'>logsegno</span></a> <span class='Operator'>+ </span><a href="xlog.c.html#LN123"><span class='Ref_to_Global_Var'>CheckPointSegments</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN866"><span class='Ref_to_Proto'>InstallXLogFileSegment</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN3159"><span class='Ref_To_Local'>installed_segno</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN3156"><span class='Ref_To_Local'>tmppath</span></a><span class='Delimiter'>, 
</span>                                <span class='Operator'>*</span><a href="xlog.c.html#LN3153"><span class='Ref_to_Parameter'>use_existent</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN3160"><span class='Ref_To_Local'>max_segno</span></a><span class='Delimiter'>, 
</span>                                <a href="xlog.c.html#LN3153"><span class='Ref_to_Parameter'>use_lock</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * No need for any more future segments, or InstallXLogFileSegment() 
         * failed to rename the file into place. If the rename failed, opening 
         * the file below will fail. 
         */ 
</span>        <a href="../../../timezone/private.h.html#LN59"><span class='Ref_to_Proto'>unlink</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3156"><span class='Ref_To_Local'>tmppath</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Set flag to tell caller there was no existent file */ 
</span>    <span class='Operator'>*</span><a href="xlog.c.html#LN3153"><span class='Ref_to_Parameter'>use_existent</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Now open original target segment (might not be file I just made) */ 
</span>    <a href="xlog.c.html#LN3161"><span class='Ref_To_Local'>fd</span></a> <span class='Operator'>= </span><a href="../../../include/storage/fd.h.html#LN100"><span class='Ref_to_Proto'>BasicOpenFile</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3155"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, </span>O_RDWR <span class='Operator'>| </span><a href="../../../include/c.h.html#LN1032"><span class='Ref_to_Const'>PG_BINARY</span></a> <span class='Operator'>| </span><a href="xlog.c.html#LN908"><span class='Ref_to_Proto'>get_sync_bit</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN102"><span class='Ref_to_Global_Var'>sync_method</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                       <a href="../../../include/port/win32.h.html#LN424"><span class='Ref_to_Const'>S_IRUSR</span></a> <span class='Operator'>| </span><a href="../../../include/port/win32.h.html#LN425"><span class='Ref_to_Const'>S_IWUSR</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN3161"><span class='Ref_To_Local'>fd</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not open file \"%s\": %m"</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN3155"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Delimiter'>, </span><span class='String'>"done creating and filling new WAL file"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="xlog.c.html#LN3161"><span class='Ref_To_Local'>fd</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end XLogFileInit &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Create a new XLOG file segment by copying a pre-existing one. 
 * 
 * destsegno: identify segment to be created. 
 * 
 * srcTLI, srcsegno: identify segment to be copied (could be from 
 *      a different timeline) 
 * 
 * upto: how much of the source file to copy (the rest is filled with 
 *      zeros) 
 * 
 * Currently this is only used during recovery, and so there are no locking 
 * considerations.  But we should be just as tense as XLogFileInit to avoid 
 * emplacing a bogus file. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN3322"></a><span class='Declare_Function'>XLogFileCopy</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a> <span class='Declare_Parameter'>destsegno</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a> <span class='Declare_Parameter'>srcTLI</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a> <span class='Declare_Parameter'>srcsegno</span><span class='Delimiter'>, 
</span><a name="LN3323"></a>             <span class='Keyword'>int </span><span class='Declare_Parameter'>upto</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3325"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>path</span><span class='Delimiter'>[</span><a href="../../../include/pg_config_manual.h.html#LN88"><span class='Ref_to_Const'>MAXPGPATH</span></a><span class='Delimiter'>]; 
</span><a name="LN3326"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>tmppath</span><span class='Delimiter'>[</span><a href="../../../include/pg_config_manual.h.html#LN88"><span class='Ref_to_Const'>MAXPGPATH</span></a><span class='Delimiter'>]; 
</span><a name="LN3327"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>buffer</span><span class='Delimiter'>[</span>XLOG_BLCKSZ<span class='Delimiter'>]; 
</span><a name="LN3328"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>srcfd</span><span class='Delimiter'>; 
</span><a name="LN3329"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>fd</span><span class='Delimiter'>; 
</span><a name="LN3330"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>nbytes</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Open the source file 
     */ 
</span>    <a href="../../../include/access/xlog_internal.h.html#LN172"><span class='Ref_to_Macro'>XLogFilePath</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3325"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN3322"><span class='Ref_to_Parameter'>srcTLI</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN3322"><span class='Ref_to_Parameter'>srcsegno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN3328"><span class='Ref_To_Local'>srcfd</span></a> <span class='Operator'>= </span><a href="../../../include/storage/fd.h.html#LN96"><span class='Ref_to_Proto'>OpenTransientFile</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3325"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, </span>O_RDONLY <span class='Operator'>| </span><a href="../../../include/c.h.html#LN1032"><span class='Ref_to_Const'>PG_BINARY</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN3328"><span class='Ref_To_Local'>srcfd</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not open file \"%s\": %m"</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN3325"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Copy into a temp file name. 
     */ 
</span>    <a href="../../../pl/plperl/plperl.h.html#LN60"><span class='Ref_to_Macro'>snprintf</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3326"><span class='Ref_To_Local'>tmppath</span></a><span class='Delimiter'>, </span><a href="../../../include/pg_config_manual.h.html#LN88"><span class='Ref_to_Const'>MAXPGPATH</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xlog_internal.h.html#LN130"><span class='Ref_to_Const'>XLOGDIR</span></a> <span class='String'>"/xlogtemp.%d"</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span>getpid<span class='Parentheses'>())</span><span class='Delimiter'>; 
</span> 
    <a href="../../../timezone/private.h.html#LN59"><span class='Ref_to_Proto'>unlink</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3326"><span class='Ref_To_Local'>tmppath</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* do not use get_sync_bit() here --- want to fsync only at end of fill */ 
</span>    <a href="xlog.c.html#LN3329"><span class='Ref_To_Local'>fd</span></a> <span class='Operator'>= </span><a href="../../../include/storage/fd.h.html#LN96"><span class='Ref_to_Proto'>OpenTransientFile</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3326"><span class='Ref_To_Local'>tmppath</span></a><span class='Delimiter'>, </span>O_RDWR <span class='Operator'>| </span>O_CREAT <span class='Operator'>| </span>O_EXCL <span class='Operator'>| </span><a href="../../../include/c.h.html#LN1032"><span class='Ref_to_Const'>PG_BINARY</span></a><span class='Delimiter'>, 
</span>                           <a href="../../../include/port/win32.h.html#LN424"><span class='Ref_to_Const'>S_IRUSR</span></a> <span class='Operator'>| </span><a href="../../../include/port/win32.h.html#LN425"><span class='Ref_to_Const'>S_IWUSR</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN3329"><span class='Ref_To_Local'>fd</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not create file \"%s\": %m"</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN3326"><span class='Ref_To_Local'>tmppath</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Do the data copying. 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN3330"><span class='Ref_To_Local'>nbytes</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="xlog.c.html#LN3330"><span class='Ref_To_Local'>nbytes</span></a> <span class='Operator'>&LT; </span><a href="../../../include/access/xlog_internal.h.html#LN91"><span class='Ref_to_Const'>XLogSegSize</span></a><span class='Delimiter'>; </span><a href="xlog.c.html#LN3330"><span class='Ref_To_Local'>nbytes</span></a> <span class='Operator'>+= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN3327"><span class='Ref_To_Local'>buffer</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN3362"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>nread</span><span class='Delimiter'>; 
</span> 
        <a href="xlog.c.html#LN3362"><span class='Ref_To_Local'>nread</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN3323"><span class='Ref_to_Parameter'>upto</span></a> <span class='Operator'>- </span><a href="xlog.c.html#LN3330"><span class='Ref_To_Local'>nbytes</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * The part that is not read from the source file is filled with 
         * zeros. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN3362"><span class='Ref_To_Local'>nread</span></a> <span class='Operator'>&LT; </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN3327"><span class='Ref_To_Local'>buffer</span></a><span class='Parentheses'>))</span> 
            memset<span class='Parentheses'>(</span><a href="xlog.c.html#LN3327"><span class='Ref_To_Local'>buffer</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN3327"><span class='Ref_To_Local'>buffer</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN3362"><span class='Ref_To_Local'>nread</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN3362"><span class='Ref_To_Local'>nread</span></a> <span class='Operator'>&GT; </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN3327"><span class='Ref_To_Local'>buffer</span></a><span class='Parentheses'>))</span> 
                <a href="xlog.c.html#LN3362"><span class='Ref_To_Local'>nread</span></a> <span class='Operator'>= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN3327"><span class='Ref_To_Local'>buffer</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            errno <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <a href="../../../include/pgstat.h.html#LN1206"><span class='Ref_to_Func'>pgstat_report_wait_start</span></a><span class='Parentheses'>(</span><a href="../../../include/pgstat.h.html#LN897"><span class='Ref_to_EnumConst'>WAIT_EVENT_WAL_COPY_READ</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../interfaces/libpq/win32.h.html#LN12"><span class='Ref_to_Macro'>read</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3328"><span class='Ref_To_Local'>srcfd</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN3327"><span class='Ref_To_Local'>buffer</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN3362"><span class='Ref_To_Local'>nread</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><a href="xlog.c.html#LN3362"><span class='Ref_To_Local'>nread</span></a><span class='Parentheses'>)</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span>errno <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                    <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                            <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                             <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not read file \"%s\": %m"</span><span class='Delimiter'>, 
</span>                                    <a href="xlog.c.html#LN3325"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                <span class='Control'>else</span> 
                    <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                            <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"not enough data in file \"%s\""</span><span class='Delimiter'>, 
</span>                                    <a href="xlog.c.html#LN3325"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <a href="../../../include/pgstat.h.html#LN1230"><span class='Ref_to_Func'>pgstat_report_wait_end</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if nread&GT;0 &raquo; </span> 
        errno <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="../../../include/pgstat.h.html#LN1206"><span class='Ref_to_Func'>pgstat_report_wait_start</span></a><span class='Parentheses'>(</span><a href="../../../include/pgstat.h.html#LN899"><span class='Ref_to_EnumConst'>WAIT_EVENT_WAL_COPY_WRITE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>((</span><span class='Keyword'>int</span><span class='Parentheses'>)</span> <a href="../../../interfaces/libpq/win32.h.html#LN13"><span class='Ref_to_Macro'>write</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3329"><span class='Ref_To_Local'>fd</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN3327"><span class='Ref_To_Local'>buffer</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN3327"><span class='Ref_To_Local'>buffer</span></a><span class='Parentheses'>))</span> <span class='Operator'>!= </span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>)</span> <span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN3327"><span class='Ref_To_Local'>buffer</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN3397"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>save_errno</span> <span class='Operator'>= </span>errno<span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * If we fail to make the file, delete it to release disk space 
             */ 
</span>            <a href="../../../timezone/private.h.html#LN59"><span class='Ref_to_Proto'>unlink</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3326"><span class='Ref_To_Local'>tmppath</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* if write didn't set errno, assume problem is no disk space */ 
</span>            errno <span class='Operator'>= </span><a href="xlog.c.html#LN3397"><span class='Ref_To_Local'>save_errno</span></a> <span class='Operator'>? </span><a href="xlog.c.html#LN3397"><span class='Ref_To_Local'>save_errno</span></a> <span class='Operator'>: </span>ENOSPC<span class='Delimiter'>; 
</span> 
            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                     <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not write to file \"%s\": %m"</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN3326"><span class='Ref_To_Local'>tmppath</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <a href="../../../include/pgstat.h.html#LN1230"><span class='Ref_to_Func'>pgstat_report_wait_end</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for nbytes=0;nbytes&LT;XLogS... &raquo; </span> 
 
    <a href="../../../include/pgstat.h.html#LN1206"><span class='Ref_to_Func'>pgstat_report_wait_start</span></a><span class='Parentheses'>(</span><a href="../../../include/pgstat.h.html#LN898"><span class='Ref_to_EnumConst'>WAIT_EVENT_WAL_COPY_SYNC</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/fd.h.html#LN114"><span class='Ref_to_Proto'>pg_fsync</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3329"><span class='Ref_To_Local'>fd</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not fsync file \"%s\": %m"</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN3326"><span class='Ref_To_Local'>tmppath</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/pgstat.h.html#LN1230"><span class='Ref_to_Func'>pgstat_report_wait_end</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/fd.h.html#LN97"><span class='Ref_to_Proto'>CloseTransientFile</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3329"><span class='Ref_To_Local'>fd</span></a><span class='Parentheses'>))</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not close file \"%s\": %m"</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN3326"><span class='Ref_To_Local'>tmppath</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/fd.h.html#LN97"><span class='Ref_to_Proto'>CloseTransientFile</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3328"><span class='Ref_To_Local'>srcfd</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now move the segment into place with its final name. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN866"><span class='Ref_to_Proto'>InstallXLogFileSegment</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN3322"><span class='Ref_to_Parameter'>destsegno</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN3326"><span class='Ref_To_Local'>tmppath</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>))</span> 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"InstallXLogFileSegment should not have failed"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end XLogFileCopy &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Install a new XLOG segment file as a current or future log segment. 
 * 
 * This is used both to install a newly-created segment (which has a temp 
 * filename while it's being created) and to recycle an old segment. 
 * 
 * *segno: identify segment to install as (or first possible target). 
 * When find_free is TRUE, this is modified on return to indicate the 
 * actual installation location or last segment searched. 
 * 
 * tmppath: initial name of file to install.  It will be renamed into place. 
 * 
 * find_free: if TRUE, install the new segment at the first empty segno 
 * number at or after the passed numbers.  If FALSE, install the new segment 
 * exactly where specified, deleting any existing segment file there. 
 * 
 * max_segno: maximum segment number to install the new file as.  Fail if no 
 * free slot is found between *segno and max_segno. (Ignored when find_free 
 * is FALSE.) 
 * 
 * use_lock: if TRUE, acquire ControlFileLock while moving file into 
 * place.  This should be TRUE except during bootstrap log creation.  The 
 * caller must *not* hold the lock at call. 
 * 
 * Returns TRUE if the file was installed successfully.  FALSE indicates that 
 * max_segno limit was exceeded, or an error occurred while renaming the 
 * file into place. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN3463"></a><span class='Declare_Function'>InstallXLogFileSegment</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>segno</span><span class='Delimiter'>, </span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Declare_Parameter'>tmppath</span><span class='Delimiter'>, 
</span><a name="LN3464"></a>                       <span class='Keyword'>bool </span><span class='Declare_Parameter'>find_free</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a> <span class='Declare_Parameter'>max_segno</span><span class='Delimiter'>, 
</span><a name="LN3465"></a>                       <span class='Keyword'>bool </span><span class='Declare_Parameter'>use_lock</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3467"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>path</span><span class='Delimiter'>[</span><a href="../../../include/pg_config_manual.h.html#LN88"><span class='Ref_to_Const'>MAXPGPATH</span></a><span class='Delimiter'>]; 
</span><a name="LN3468"></a>    <span class='Control'>struct</span> <a href="../../../include/port.h.html#LN275"><span class='Ref_to_Macro'>stat</span></a> <span class='Declare_Local'>stat_buf</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/access/xlog_internal.h.html#LN172"><span class='Ref_to_Macro'>XLogFilePath</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3467"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Delimiter'>, </span><span class='Operator'>*</span><a href="xlog.c.html#LN3463"><span class='Ref_to_Parameter'>segno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We want to be sure that only one process does this at a time. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN3465"><span class='Ref_to_Parameter'>use_lock</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ControlFileLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN3464"><span class='Ref_to_Parameter'>find_free</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Force installation: get rid of any pre-existing segment file */ 
</span>        <a href="../../../include/storage/fd.h.html#LN121"><span class='Ref_to_Proto'>durable_unlink</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3467"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/elog.h.html#LN24"><span class='Ref_to_Const'>DEBUG1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Find a free slot to put it in */ 
</span>        <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="../../../include/port.h.html#LN275"><span class='Ref_to_Macro'>stat</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3467"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN3468"><span class='Ref_To_Local'>stat_buf</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>((</span><span class='Operator'>*</span><a href="xlog.c.html#LN3463"><span class='Ref_to_Parameter'>segno</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT;= </span><a href="xlog.c.html#LN3464"><span class='Ref_to_Parameter'>max_segno</span></a><span class='Parentheses'>)</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* Failed to find a free slot within specified range */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN3465"><span class='Ref_to_Parameter'>use_lock</span></a><span class='Parentheses'>) 
</span>                    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ControlFileLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="xlog.c.html#LN3463"><span class='Ref_to_Parameter'>segno</span></a><span class='Parentheses'>)</span><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <a href="../../../include/access/xlog_internal.h.html#LN172"><span class='Ref_to_Macro'>XLogFilePath</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3467"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Delimiter'>, </span><span class='Operator'>*</span><a href="xlog.c.html#LN3463"><span class='Ref_to_Parameter'>segno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Perform the rename using link if available, paranoidly trying to avoid 
     * overwriting an existing file (there shouldn't be one). 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/fd.h.html#LN122"><span class='Ref_to_Proto'>durable_link_or_rename</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3463"><span class='Ref_to_Parameter'>tmppath</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN3467"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN3465"><span class='Ref_to_Parameter'>use_lock</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ControlFileLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* durable_link_or_rename already emitted log message */ 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN3465"><span class='Ref_to_Parameter'>use_lock</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ControlFileLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end InstallXLogFileSegment &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Open a pre-existing logfile segment for writing. 
 */ 
</span><span class='Keyword'>int 
</span><a name="LN3522"></a><span class='Declare_Function'>XLogFileOpen</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a> <span class='Declare_Parameter'>segno</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3524"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>path</span><span class='Delimiter'>[</span><a href="../../../include/pg_config_manual.h.html#LN88"><span class='Ref_to_Const'>MAXPGPATH</span></a><span class='Delimiter'>]; 
</span><a name="LN3525"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>fd</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/access/xlog_internal.h.html#LN172"><span class='Ref_to_Macro'>XLogFilePath</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3524"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN3522"><span class='Ref_to_Parameter'>segno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="xlog.c.html#LN3525"><span class='Ref_To_Local'>fd</span></a> <span class='Operator'>= </span><a href="../../../include/storage/fd.h.html#LN100"><span class='Ref_to_Proto'>BasicOpenFile</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3524"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, </span>O_RDWR <span class='Operator'>| </span><a href="../../../include/c.h.html#LN1032"><span class='Ref_to_Const'>PG_BINARY</span></a> <span class='Operator'>| </span><a href="xlog.c.html#LN908"><span class='Ref_to_Proto'>get_sync_bit</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN102"><span class='Ref_to_Global_Var'>sync_method</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                       <a href="../../../include/port/win32.h.html#LN424"><span class='Ref_to_Const'>S_IRUSR</span></a> <span class='Operator'>| </span><a href="../../../include/port/win32.h.html#LN425"><span class='Ref_to_Const'>S_IWUSR</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN3525"><span class='Ref_To_Local'>fd</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>            <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not open write-ahead log file \"%s\": %m"</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN3524"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="xlog.c.html#LN3525"><span class='Ref_To_Local'>fd</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Open a logfile segment for reading (during recovery). 
 * 
 * If source == XLOG_FROM_ARCHIVE, the segment is retrieved from archive. 
 * Otherwise, it's assumed to be already available in pg_wal. 
 */ 
</span><span class='Keyword'>static int 
</span><a name="LN3546"></a><span class='Declare_Function'>XLogFileRead</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a> <span class='Declare_Parameter'>segno</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>emode</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a> <span class='Declare_Parameter'>tli</span><span class='Delimiter'>, 
</span><a name="LN3547"></a>             <span class='Keyword'>int </span><span class='Declare_Parameter'>source</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>notfoundOk</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3549"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>xlogfname</span><span class='Delimiter'>[</span><a href="../../../include/access/xlog_internal.h.html#LN137"><span class='Ref_to_Const'>MAXFNAMELEN</span></a><span class='Delimiter'>]; 
</span><a name="LN3550"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>activitymsg</span><span class='Delimiter'>[</span><a href="../../../include/access/xlog_internal.h.html#LN137"><span class='Ref_to_Const'>MAXFNAMELEN</span></a> <span class='Operator'>+ </span><span class='Number'>16</span><span class='Delimiter'>]; 
</span><a name="LN3551"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>path</span><span class='Delimiter'>[</span><a href="../../../include/pg_config_manual.h.html#LN88"><span class='Ref_to_Const'>MAXPGPATH</span></a><span class='Delimiter'>]; 
</span><a name="LN3552"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>fd</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/access/xlog_internal.h.html#LN142"><span class='Ref_to_Macro'>XLogFileName</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3549"><span class='Ref_To_Local'>xlogfname</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN3546"><span class='Ref_to_Parameter'>tli</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN3546"><span class='Ref_to_Parameter'>segno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN3547"><span class='Ref_to_Parameter'>source</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="xlog.c.html#LN756"><span class='Ref_to_EnumConst'>XLOG_FROM_ARCHIVE</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* Report recovery progress in PS display */ 
</span>            <a href="../../../pl/plperl/plperl.h.html#LN60"><span class='Ref_to_Macro'>snprintf</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3550"><span class='Ref_To_Local'>activitymsg</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN3550"><span class='Ref_To_Local'>activitymsg</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='String'>"waiting for %s"</span><span class='Delimiter'>, 
</span>                     <a href="xlog.c.html#LN3549"><span class='Ref_To_Local'>xlogfname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/utils/ps_status.h.html#LN21"><span class='Ref_to_Proto'>set_ps_display</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3550"><span class='Ref_To_Local'>activitymsg</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="xlog.c.html#LN249"><span class='Ref_to_Global_Var'>restoredFromArchive</span></a> <span class='Operator'>= </span><a href="xlogarchive.c.html#LN49"><span class='Ref_to_Func'>RestoreArchivedFile</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3551"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN3549"><span class='Ref_To_Local'>xlogfname</span></a><span class='Delimiter'>, 
</span>                                                      <span class='String'>"RECOVERYXLOG"</span><span class='Delimiter'>, 
</span>                                                      <a href="../../../include/access/xlog_internal.h.html#LN91"><span class='Ref_to_Const'>XLogSegSize</span></a><span class='Delimiter'>, 
</span>                                                      <a href="xlog.c.html#LN832"><span class='Ref_to_Global_Var'>InRedo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN249"><span class='Ref_to_Global_Var'>restoredFromArchive</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>return</span> <span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="xlog.c.html#LN757"><span class='Ref_to_EnumConst'>XLOG_FROM_PG_WAL</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="xlog.c.html#LN758"><span class='Ref_to_EnumConst'>XLOG_FROM_STREAM</span></a><span class='Operator'>: 
</span>            <a href="../../../include/access/xlog_internal.h.html#LN172"><span class='Ref_to_Macro'>XLogFilePath</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3551"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN3546"><span class='Ref_to_Parameter'>tli</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN3546"><span class='Ref_to_Parameter'>segno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN249"><span class='Ref_to_Global_Var'>restoredFromArchive</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>default</span><span class='Operator'>: 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"invalid XLogFileRead source %d"</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN3547"><span class='Ref_to_Parameter'>source</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch source &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * If the segment was fetched from archival storage, replace the existing 
     * xlog segment (if any) with the archival version. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN3547"><span class='Ref_to_Parameter'>source</span></a> <span class='Operator'>== </span><a href="xlog.c.html#LN756"><span class='Ref_to_EnumConst'>XLOG_FROM_ARCHIVE</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/access/xlog_internal.h.html#LN311"><span class='Ref_to_Proto'>KeepFileRestoredFromArchive</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3551"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN3549"><span class='Ref_To_Local'>xlogfname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Set path to point at the new file in pg_wal. 
         */ 
</span>        <a href="../../../pl/plperl/plperl.h.html#LN60"><span class='Ref_to_Macro'>snprintf</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3551"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, </span><a href="../../../include/pg_config_manual.h.html#LN88"><span class='Ref_to_Const'>MAXPGPATH</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xlog_internal.h.html#LN130"><span class='Ref_to_Const'>XLOGDIR</span></a> <span class='String'>"/%s"</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN3549"><span class='Ref_To_Local'>xlogfname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="xlog.c.html#LN3552"><span class='Ref_To_Local'>fd</span></a> <span class='Operator'>= </span><a href="../../../include/storage/fd.h.html#LN100"><span class='Ref_to_Proto'>BasicOpenFile</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3551"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, </span>O_RDONLY <span class='Operator'>| </span><a href="../../../include/c.h.html#LN1032"><span class='Ref_to_Const'>PG_BINARY</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN3552"><span class='Ref_To_Local'>fd</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Success! */ 
</span>        <a href="xlog.c.html#LN318"><span class='Ref_to_Global_Var'>curFileTLI</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN3546"><span class='Ref_to_Parameter'>tli</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Report recovery progress in PS display */ 
</span>        <a href="../../../pl/plperl/plperl.h.html#LN60"><span class='Ref_to_Macro'>snprintf</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3550"><span class='Ref_To_Local'>activitymsg</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN3550"><span class='Ref_To_Local'>activitymsg</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='String'>"recovering %s"</span><span class='Delimiter'>, 
</span>                 <a href="xlog.c.html#LN3549"><span class='Ref_To_Local'>xlogfname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/utils/ps_status.h.html#LN21"><span class='Ref_to_Proto'>set_ps_display</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3550"><span class='Ref_To_Local'>activitymsg</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Track source of data in assorted state variables */ 
</span>        <a href="xlog.c.html#LN786"><span class='Ref_to_Global_Var'>readSource</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN3547"><span class='Ref_to_Parameter'>source</span></a><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN814"><span class='Ref_to_Global_Var'>XLogReceiptSource</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN3547"><span class='Ref_to_Parameter'>source</span></a><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* In FROM_STREAM case, caller tracks receipt time, not me */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN3547"><span class='Ref_to_Parameter'>source</span></a> <span class='Operator'>!= </span><a href="xlog.c.html#LN758"><span class='Ref_to_EnumConst'>XLOG_FROM_STREAM</span></a><span class='Parentheses'>) 
</span>            <a href="xlog.c.html#LN813"><span class='Ref_to_Global_Var'>XLogReceiptTime</span></a> <span class='Operator'>= </span><a href="../../../include/utils/timestamp.h.html#LN69"><span class='Ref_to_Proto'>GetCurrentTimestamp</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>return</span> <a href="xlog.c.html#LN3552"><span class='Ref_To_Local'>fd</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span>errno <span class='Operator'>!= </span>ENOENT <span class='Operator'>|| !</span><a href="xlog.c.html#LN3547"><span class='Ref_to_Parameter'>notfoundOk</span></a><span class='Parentheses'>) </span><span class='Comment_Single_Line'>/* unexpected failure? */ 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not open file \"%s\": %m"</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN3551"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end XLogFileRead &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Open a logfile segment for reading (during recovery). 
 * 
 * This version searches for the segment with any TLI listed in expectedTLEs. 
 */ 
</span><span class='Keyword'>static int 
</span><a name="LN3629"></a><span class='Declare_Function'>XLogFileReadAnyTLI</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a> <span class='Declare_Parameter'>segno</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>emode</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>source</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3631"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>path</span><span class='Delimiter'>[</span><a href="../../../include/pg_config_manual.h.html#LN88"><span class='Ref_to_Const'>MAXPGPATH</span></a><span class='Delimiter'>]; 
</span><a name="LN3632"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>cell</span><span class='Delimiter'>; 
</span><a name="LN3633"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>fd</span><span class='Delimiter'>; 
</span><a name="LN3634"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>tles</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Loop looking for a suitable timeline ID: we might need to read any of 
     * the timelines listed in expectedTLEs. 
     * 
     * We expect curFileTLI on entry to be the TLI of the preceding file in 
     * sequence, or 0 if there was no predecessor.  We do not allow curFileTLI 
     * to go backwards; this prevents us from picking up the wrong file when a 
     * parent timeline extends to higher segment numbers than the child we 
     * want to read. 
     * 
     * If we haven't read the timeline history file yet, read it now, so that 
     * we know which TLIs to scan.  We don't save the list in expectedTLEs, 
     * however, unless we actually find a valid segment.  That way if there is 
     * neither a timeline history file nor a WAL segment in the archive, and 
     * streaming replication is set up, we'll read the timeline history file 
     * streamed from the master when we start streaming, instead of recovering 
     * with a dummy history generated here. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN317"><span class='Ref_to_Global_Var'>expectedTLEs</span></a><span class='Parentheses'>) 
</span>        <a href="xlog.c.html#LN3634"><span class='Ref_To_Local'>tles</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN317"><span class='Ref_to_Global_Var'>expectedTLEs</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="xlog.c.html#LN3634"><span class='Ref_To_Local'>tles</span></a> <span class='Operator'>= </span><a href="../../../include/access/timeline.h.html#LN31"><span class='Ref_to_Proto'>readTimeLineHistory</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN315"><span class='Ref_to_Global_Var'>recoveryTargetTLI</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3632"><span class='Ref_To_Local'>cell</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN3634"><span class='Ref_To_Local'>tles</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3661"></a>        <a href="../../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a>  <span class='Declare_Local'>tli</span> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/access/timeline.h.html#LN24"><span class='Ref_to_Typedef'>TimeLineHistoryEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3632"><span class='Ref_To_Local'>cell</span></a><span class='Parentheses'>))</span><span class='Operator'>-&GT;</span>tli<span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN3661"><span class='Ref_To_Local'>tli</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN318"><span class='Ref_to_Global_Var'>curFileTLI</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>break</span><span class='Delimiter'>;</span>              <span class='Comment_Single_Line'>/* don't bother looking at too-old TLIs */ 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN3629"><span class='Ref_to_Parameter'>source</span></a> <span class='Operator'>== </span><a href="xlog.c.html#LN755"><span class='Ref_to_EnumConst'>XLOG_FROM_ANY</span></a> <span class='Operator'>|| </span><a href="xlog.c.html#LN3629"><span class='Ref_to_Parameter'>source</span></a> <span class='Operator'>== </span><a href="xlog.c.html#LN756"><span class='Ref_to_EnumConst'>XLOG_FROM_ARCHIVE</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="xlog.c.html#LN3633"><span class='Ref_To_Local'>fd</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN869"><span class='Ref_to_Proto'>XLogFileRead</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3629"><span class='Ref_to_Parameter'>segno</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN3629"><span class='Ref_to_Parameter'>emode</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN3661"><span class='Ref_To_Local'>tli</span></a><span class='Delimiter'>, 
</span>                              <a href="xlog.c.html#LN756"><span class='Ref_to_EnumConst'>XLOG_FROM_ARCHIVE</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN3633"><span class='Ref_To_Local'>fd</span></a> <span class='Operator'>!= -</span><span class='Number'>1</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN24"><span class='Ref_to_Const'>DEBUG1</span></a><span class='Delimiter'>, </span><span class='String'>"got WAL segment from archive"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN317"><span class='Ref_to_Global_Var'>expectedTLEs</span></a><span class='Parentheses'>) 
</span>                    <a href="xlog.c.html#LN317"><span class='Ref_to_Global_Var'>expectedTLEs</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN3634"><span class='Ref_To_Local'>tles</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>return</span> <a href="xlog.c.html#LN3633"><span class='Ref_To_Local'>fd</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN3629"><span class='Ref_to_Parameter'>source</span></a> <span class='Operator'>== </span><a href="xlog.c.html#LN755"><span class='Ref_to_EnumConst'>XLOG_FROM_ANY</span></a> <span class='Operator'>|| </span><a href="xlog.c.html#LN3629"><span class='Ref_to_Parameter'>source</span></a> <span class='Operator'>== </span><a href="xlog.c.html#LN757"><span class='Ref_to_EnumConst'>XLOG_FROM_PG_WAL</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="xlog.c.html#LN3633"><span class='Ref_To_Local'>fd</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN869"><span class='Ref_to_Proto'>XLogFileRead</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3629"><span class='Ref_to_Parameter'>segno</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN3629"><span class='Ref_to_Parameter'>emode</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN3661"><span class='Ref_To_Local'>tli</span></a><span class='Delimiter'>, 
</span>                              <a href="xlog.c.html#LN757"><span class='Ref_to_EnumConst'>XLOG_FROM_PG_WAL</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN3633"><span class='Ref_To_Local'>fd</span></a> <span class='Operator'>!= -</span><span class='Number'>1</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN317"><span class='Ref_to_Global_Var'>expectedTLEs</span></a><span class='Parentheses'>) 
</span>                    <a href="xlog.c.html#LN317"><span class='Ref_to_Global_Var'>expectedTLEs</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN3634"><span class='Ref_To_Local'>tles</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>return</span> <a href="xlog.c.html#LN3633"><span class='Ref_To_Local'>fd</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Couldn't find it.  For simplicity, complain about front timeline */ 
</span>    <a href="../../../include/access/xlog_internal.h.html#LN172"><span class='Ref_to_Macro'>XLogFilePath</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3631"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN315"><span class='Ref_to_Global_Var'>recoveryTargetTLI</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN3629"><span class='Ref_to_Parameter'>segno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    errno <span class='Operator'>= </span>ENOENT<span class='Delimiter'>; 
</span>    <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3629"><span class='Ref_to_Parameter'>emode</span></a><span class='Delimiter'>, 
</span>            <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>             <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not open file \"%s\": %m"</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN3631"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end XLogFileReadAnyTLI &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Close the current logfile segment for writing. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN3705"></a><span class='Declare_Function'>XLogFileClose</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN770"><span class='Ref_to_Global_Var'>openLogFile</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * WAL segment files will not be re-read in normal operation, so we advise 
     * the OS to release any cached pages.  But do not do so if WAL archiving 
     * or streaming is active, because archiver and walsender process could 
     * use the cache to read the WAL segment. 
     */ 
</span><span class='Directive'>#if</span> defined<span class='Parentheses'>(</span><a href="../../../include/pg_config_manual.h.html#LN136"><span class='Ref_to_Const'>USE_POSIX_FADVISE</span></a><span class='Parentheses'>) </span><span class='Operator'>&& </span>defined<span class='Parentheses'>(</span>POSIX_FADV_DONTNEED<span class='Parentheses'>) 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/xlog.h.html#LN144"><span class='Ref_to_Macro'>XLogIsNeeded</span></a><span class='Parentheses'>())</span> 
        <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span>posix_fadvise<span class='Parentheses'>(</span><a href="xlog.c.html#LN770"><span class='Ref_to_Global_Var'>openLogFile</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span>POSIX_FADV_DONTNEED<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../interfaces/libpq/win32.h.html#LN11"><span class='Ref_to_Macro'>close</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN770"><span class='Ref_to_Global_Var'>openLogFile</span></a><span class='Parentheses'>))</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not close log file %s: %m"</span><span class='Delimiter'>, 
</span>                        <a href="../../../include/access/xlog.h.html#LN254"><span class='Ref_to_Proto'>XLogFileNameP</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN771"><span class='Ref_to_Global_Var'>openLogSegNo</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN770"><span class='Ref_to_Global_Var'>openLogFile</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end XLogFileClose &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Preallocate log files beyond the specified log endpoint. 
 * 
 * XXX this is currently extremely conservative, since it forces only one 
 * future log segment to exist, and even that only if we are 75% done with 
 * the current one.  This is only appropriate for very low-WAL-volume systems. 
 * High-volume systems will be OK once they've built up a sufficient set of 
 * recycled log segments, but the startup transient is likely to include 
 * a lot of segment creations by foreground processes, which is not so good. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN3739"></a><span class='Declare_Function'>PreallocXlogFiles</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>endptr</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3741"></a>    <a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a>   <span class='Declare_Local'>_logSegNo</span><span class='Delimiter'>; 
</span><a name="LN3742"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>lf</span><span class='Delimiter'>; 
</span><a name="LN3743"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>use_existent</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/access/xlog_internal.h.html#LN108"><span class='Ref_to_Macro'>XLByteToPrevSeg</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3739"><span class='Ref_to_Parameter'>endptr</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN3741"><span class='Ref_To_Local'>_logSegNo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="xlog.c.html#LN3739"><span class='Ref_to_Parameter'>endptr</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>) </span><span class='Operator'>% </span><a href="../../../include/access/xlog_internal.h.html#LN91"><span class='Ref_to_Const'>XLogSegSize</span></a> <span class='Operator'>&GT;= </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>75</span> <span class='Operator'>* </span><a href="../../../include/access/xlog_internal.h.html#LN91"><span class='Ref_to_Const'>XLogSegSize</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="xlog.c.html#LN3741"><span class='Ref_To_Local'>_logSegNo</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN3743"><span class='Ref_To_Local'>use_existent</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN3742"><span class='Ref_To_Local'>lf</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlog.h.html#LN228"><span class='Ref_to_Proto'>XLogFileInit</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3741"><span class='Ref_To_Local'>_logSegNo</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN3743"><span class='Ref_To_Local'>use_existent</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../interfaces/libpq/win32.h.html#LN11"><span class='Ref_to_Macro'>close</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3742"><span class='Ref_To_Local'>lf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN3743"><span class='Ref_To_Local'>use_existent</span></a><span class='Parentheses'>) 
</span>            <a href="xlog.c.html#LN172"><span class='Ref_to_Global_Var'>CheckpointStats</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog.h.html#LN206"><span class='Ref_to_Member'>ckpt_segs_added</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Throws an error if the given log segment has already been removed or 
 * recycled. The caller should only pass a segment that it knows to have 
 * existed while the server has been running, as this function always 
 * succeeds if no WAL segments have been removed since startup. 
 * 'tli' is only used in the error message. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN3765"></a><span class='Declare_Function'>CheckXLogRemoved</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a> <span class='Declare_Parameter'>segno</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a> <span class='Declare_Parameter'>tli</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3767"></a>    <a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a>   <span class='Declare_Local'>lastRemovedSegNo</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN3767"><span class='Ref_To_Local'>lastRemovedSegNo</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN584"><span class='Ref_to_Member'>lastRemovedSegNo</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN3765"><span class='Ref_to_Parameter'>segno</span></a> <span class='Operator'>&LT;= </span><a href="xlog.c.html#LN3767"><span class='Ref_To_Local'>lastRemovedSegNo</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3775"></a>        <span class='Keyword'>char</span>        <span class='Declare_Local'>filename</span><span class='Delimiter'>[</span><a href="../../../include/access/xlog_internal.h.html#LN137"><span class='Ref_to_Const'>MAXFNAMELEN</span></a><span class='Delimiter'>]; 
</span> 
        <a href="../../../include/access/xlog_internal.h.html#LN142"><span class='Ref_to_Macro'>XLogFileName</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3775"><span class='Ref_To_Local'>filename</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN3765"><span class='Ref_to_Parameter'>tli</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN3765"><span class='Ref_to_Parameter'>segno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"requested WAL segment %s has already been removed"</span><span class='Delimiter'>, 
</span>                        <a href="xlog.c.html#LN3775"><span class='Ref_To_Local'>filename</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end CheckXLogRemoved &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Return the last WAL segment removed, or 0 if no segment has been removed 
 * since startup. 
 * 
 * NB: the result can be out of date arbitrarily fast, the caller has to deal 
 * with that. 
 */ 
</span><a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a> 
<a name="LN3793"></a><span class='Declare_Function'>XLogGetLastRemovedSegno</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3795"></a>    <a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a>   <span class='Declare_Local'>lastRemovedSegNo</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN3795"><span class='Ref_To_Local'>lastRemovedSegNo</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN584"><span class='Ref_to_Member'>lastRemovedSegNo</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="xlog.c.html#LN3795"><span class='Ref_To_Local'>lastRemovedSegNo</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Update the last removed segno pointer in shared memory, to reflect 
 * that the given XLOG file has been removed. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN3809"></a><span class='Declare_Function'>UpdateLastRemovedPtr</span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Declare_Parameter'>filename</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3811"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>tli</span><span class='Delimiter'>; 
</span><a name="LN3812"></a>    <a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a>   <span class='Declare_Local'>segno</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/access/xlog_internal.h.html#LN164"><span class='Ref_to_Macro'>XLogFromFileName</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3809"><span class='Ref_to_Parameter'>filename</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN3811"><span class='Ref_To_Local'>tli</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN3812"><span class='Ref_To_Local'>segno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN3812"><span class='Ref_To_Local'>segno</span></a> <span class='Operator'>&GT; </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN584"><span class='Ref_to_Member'>lastRemovedSegNo</span></a><span class='Parentheses'>) 
</span>        <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN584"><span class='Ref_to_Member'>lastRemovedSegNo</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN3812"><span class='Ref_To_Local'>segno</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Recycle or remove all log files older or equal to passed segno. 
 * 
 * endptr is current (or recent) end of xlog, and PriorRedoRecPtr is the 
 * redo pointer of the previous checkpoint. These are used to determine 
 * whether we want to recycle rather than delete no-longer-wanted log files. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN3830"></a><span class='Declare_Function'>RemoveOldXlogFiles</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a> <span class='Declare_Parameter'>segno</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>PriorRedoPtr</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>endptr</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3832"></a>    <a href="../../../port/dirent.c.html#LN24"><span class='Ref_to_Struct'>DIR</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>xldir</span><span class='Delimiter'>; 
</span><a name="LN3833"></a>    <span class='Control'>struct</span> <a href="../../../include/port/win32_msvc/dirent.h.html#LN8"><span class='Ref_to_Struct'>dirent</span></a> <span class='Operator'>*</span><span class='Declare_Local'>xlde</span><span class='Delimiter'>; 
</span><a name="LN3834"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>lastoff</span><span class='Delimiter'>[</span><a href="../../../include/access/xlog_internal.h.html#LN137"><span class='Ref_to_Const'>MAXFNAMELEN</span></a><span class='Delimiter'>]; 
</span> 
    <a href="xlog.c.html#LN3832"><span class='Ref_To_Local'>xldir</span></a> <span class='Operator'>= </span><a href="../../../include/storage/fd.h.html#LN91"><span class='Ref_to_Proto'>AllocateDir</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlog_internal.h.html#LN130"><span class='Ref_to_Const'>XLOGDIR</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN3832"><span class='Ref_To_Local'>xldir</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not open write-ahead log directory \"%s\": %m"</span><span class='Delimiter'>, 
</span>                        <a href="../../../include/access/xlog_internal.h.html#LN130"><span class='Ref_to_Const'>XLOGDIR</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Construct a filename of the last segment to be kept. The timeline ID 
     * doesn't matter, we ignore that in the comparison. (During recovery, 
     * ThisTimeLineID isn't set, so we can't use that.) 
     */ 
</span>    <a href="../../../include/access/xlog_internal.h.html#LN142"><span class='Ref_to_Macro'>XLogFileName</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3834"><span class='Ref_To_Local'>lastoff</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN3830"><span class='Ref_to_Parameter'>segno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Delimiter'>, </span><span class='String'>"attempting to remove WAL segments older than log file %s"</span><span class='Delimiter'>, 
</span>         <a href="xlog.c.html#LN3834"><span class='Ref_To_Local'>lastoff</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>while</span> <span class='Parentheses'>((</span><a href="xlog.c.html#LN3833"><span class='Ref_To_Local'>xlde</span></a> <span class='Operator'>= </span><a href="../../../include/storage/fd.h.html#LN92"><span class='Ref_to_Proto'>ReadDir</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3832"><span class='Ref_To_Local'>xldir</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xlog_internal.h.html#LN130"><span class='Ref_to_Const'>XLOGDIR</span></a><span class='Parentheses'>))</span> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Ignore files that are not XLOG segments */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/xlog_internal.h.html#LN150"><span class='Ref_to_Macro'>IsXLogFileName</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3833"><span class='Ref_To_Local'>xlde</span></a><span class='Operator'>-&GT;</span><a href="../../../include/port/win32_msvc/dirent.h.html#LN13"><span class='Ref_to_Member'>d_name</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>            <span class='Operator'>!</span><a href="../../../include/access/xlog_internal.h.html#LN159"><span class='Ref_to_Macro'>IsPartialXLogFileName</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3833"><span class='Ref_To_Local'>xlde</span></a><span class='Operator'>-&GT;</span><a href="../../../include/port/win32_msvc/dirent.h.html#LN13"><span class='Ref_to_Member'>d_name</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We ignore the timeline part of the XLOG segment identifiers in 
         * deciding whether a segment is still needed.  This ensures that we 
         * won't prematurely remove a segment from a parent timeline. We could 
         * probably be a little more proactive about removing segments of 
         * non-parent timelines, but that would be a whole lot more 
         * complicated. 
         * 
         * We use the alphanumeric sorting property of the filenames to decide 
         * which ones are earlier than the lastoff segment. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span><a href="xlog.c.html#LN3833"><span class='Ref_To_Local'>xlde</span></a><span class='Operator'>-&GT;</span><a href="../../../include/port/win32_msvc/dirent.h.html#LN13"><span class='Ref_to_Member'>d_name</span></a> <span class='Operator'>+ </span><span class='Number'>8</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN3834"><span class='Ref_To_Local'>lastoff</span></a> <span class='Operator'>+ </span><span class='Number'>8</span><span class='Parentheses'>) </span><span class='Operator'>&LT;= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/xlog_internal.h.html#LN315"><span class='Ref_to_Proto'>XLogArchiveCheckDone</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3833"><span class='Ref_To_Local'>xlde</span></a><span class='Operator'>-&GT;</span><a href="../../../include/port/win32_msvc/dirent.h.html#LN13"><span class='Ref_to_Member'>d_name</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* Update the last removed location in shared memory first */ 
</span>                <a href="xlog.c.html#LN882"><span class='Ref_to_Proto'>UpdateLastRemovedPtr</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3833"><span class='Ref_To_Local'>xlde</span></a><span class='Operator'>-&GT;</span><a href="../../../include/port/win32_msvc/dirent.h.html#LN13"><span class='Ref_to_Member'>d_name</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="xlog.c.html#LN881"><span class='Ref_to_Proto'>RemoveXlogFile</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3833"><span class='Ref_To_Local'>xlde</span></a><span class='Operator'>-&GT;</span><a href="../../../include/port/win32_msvc/dirent.h.html#LN13"><span class='Ref_to_Member'>d_name</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN3830"><span class='Ref_to_Parameter'>PriorRedoPtr</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN3830"><span class='Ref_to_Parameter'>endptr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while (xlde=ReadDir(xldir,X... &raquo; </span> 
 
    <a href="../../../include/storage/fd.h.html#LN93"><span class='Ref_to_Proto'>FreeDir</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3832"><span class='Ref_To_Local'>xldir</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end RemoveOldXlogFiles &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Remove WAL files that are not part of the given timeline's history. 
 * 
 * This is called during recovery, whenever we switch to follow a new 
 * timeline, and at the end of recovery when we create a new timeline. We 
 * wouldn't otherwise care about extra WAL files lying in pg_wal, but they 
 * might be leftover pre-allocated or recycled WAL segments on the old timeline 
 * that we haven't used yet, and contain garbage. If we just leave them in 
 * pg_wal, they will eventually be archived, and we can't let that happen. 
 * Files that belong to our timeline history are valid, because we have 
 * successfully replayed them, but from others we can't be sure. 
 * 
 * 'switchpoint' is the current point in WAL where we switch to new timeline, 
 * and 'newTLI' is the new timeline we switch to. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN3902"></a><span class='Declare_Function'>RemoveNonParentXlogFiles</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>switchpoint</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a> <span class='Declare_Parameter'>newTLI</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3904"></a>    <a href="../../../port/dirent.c.html#LN24"><span class='Ref_to_Struct'>DIR</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>xldir</span><span class='Delimiter'>; 
</span><a name="LN3905"></a>    <span class='Control'>struct</span> <a href="../../../include/port/win32_msvc/dirent.h.html#LN8"><span class='Ref_to_Struct'>dirent</span></a> <span class='Operator'>*</span><span class='Declare_Local'>xlde</span><span class='Delimiter'>; 
</span><a name="LN3906"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>switchseg</span><span class='Delimiter'>[</span><a href="../../../include/access/xlog_internal.h.html#LN137"><span class='Ref_to_Const'>MAXFNAMELEN</span></a><span class='Delimiter'>]; 
</span><a name="LN3907"></a>    <a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a>   <span class='Declare_Local'>endLogSegNo</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/access/xlog_internal.h.html#LN108"><span class='Ref_to_Macro'>XLByteToPrevSeg</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3902"><span class='Ref_to_Parameter'>switchpoint</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN3907"><span class='Ref_To_Local'>endLogSegNo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="xlog.c.html#LN3904"><span class='Ref_To_Local'>xldir</span></a> <span class='Operator'>= </span><a href="../../../include/storage/fd.h.html#LN91"><span class='Ref_to_Proto'>AllocateDir</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlog_internal.h.html#LN130"><span class='Ref_to_Const'>XLOGDIR</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN3904"><span class='Ref_To_Local'>xldir</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not open write-ahead log directory \"%s\": %m"</span><span class='Delimiter'>, 
</span>                        <a href="../../../include/access/xlog_internal.h.html#LN130"><span class='Ref_to_Const'>XLOGDIR</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Construct a filename of the last segment to be kept. 
     */ 
</span>    <a href="../../../include/access/xlog_internal.h.html#LN142"><span class='Ref_to_Macro'>XLogFileName</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3906"><span class='Ref_To_Local'>switchseg</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN3902"><span class='Ref_to_Parameter'>newTLI</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN3907"><span class='Ref_To_Local'>endLogSegNo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Delimiter'>, </span><span class='String'>"attempting to remove WAL segments newer than log file %s"</span><span class='Delimiter'>, 
</span>         <a href="xlog.c.html#LN3906"><span class='Ref_To_Local'>switchseg</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>while</span> <span class='Parentheses'>((</span><a href="xlog.c.html#LN3905"><span class='Ref_To_Local'>xlde</span></a> <span class='Operator'>= </span><a href="../../../include/storage/fd.h.html#LN92"><span class='Ref_to_Proto'>ReadDir</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3904"><span class='Ref_To_Local'>xldir</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xlog_internal.h.html#LN130"><span class='Ref_to_Const'>XLOGDIR</span></a><span class='Parentheses'>))</span> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Ignore files that are not XLOG segments */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/xlog_internal.h.html#LN150"><span class='Ref_to_Macro'>IsXLogFileName</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3905"><span class='Ref_To_Local'>xlde</span></a><span class='Operator'>-&GT;</span><a href="../../../include/port/win32_msvc/dirent.h.html#LN13"><span class='Ref_to_Member'>d_name</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Remove files that are on a timeline older than the new one we're 
         * switching to, but with a segment number &GT;= the first segment on the 
         * new timeline. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span>strncmp<span class='Parentheses'>(</span><a href="xlog.c.html#LN3905"><span class='Ref_To_Local'>xlde</span></a><span class='Operator'>-&GT;</span><a href="../../../include/port/win32_msvc/dirent.h.html#LN13"><span class='Ref_to_Member'>d_name</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN3906"><span class='Ref_To_Local'>switchseg</span></a><span class='Delimiter'>, </span><span class='Number'>8</span><span class='Parentheses'>) </span><span class='Operator'>&LT; </span><span class='Number'>0</span> <span class='Operator'>&& 
</span>            strcmp<span class='Parentheses'>(</span><a href="xlog.c.html#LN3905"><span class='Ref_To_Local'>xlde</span></a><span class='Operator'>-&GT;</span><a href="../../../include/port/win32_msvc/dirent.h.html#LN13"><span class='Ref_to_Member'>d_name</span></a> <span class='Operator'>+ </span><span class='Number'>8</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN3906"><span class='Ref_To_Local'>switchseg</span></a> <span class='Operator'>+ </span><span class='Number'>8</span><span class='Parentheses'>) </span><span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * If the file has already been marked as .ready, however, don't 
             * remove it yet. It should be OK to remove it - files that are 
             * not part of our timeline history are not required for recovery 
             * - but seems safer to let them be archived and removed later. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/xlog_internal.h.html#LN317"><span class='Ref_to_Proto'>XLogArchiveIsReady</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3905"><span class='Ref_To_Local'>xlde</span></a><span class='Operator'>-&GT;</span><a href="../../../include/port/win32_msvc/dirent.h.html#LN13"><span class='Ref_to_Member'>d_name</span></a><span class='Parentheses'>))</span> 
                <a href="xlog.c.html#LN881"><span class='Ref_to_Proto'>RemoveXlogFile</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3905"><span class='Ref_To_Local'>xlde</span></a><span class='Operator'>-&GT;</span><a href="../../../include/port/win32_msvc/dirent.h.html#LN13"><span class='Ref_to_Member'>d_name</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN3902"><span class='Ref_to_Parameter'>switchpoint</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while (xlde=ReadDir(xldir,X... &raquo; </span> 
 
    <a href="../../../include/storage/fd.h.html#LN93"><span class='Ref_to_Proto'>FreeDir</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3904"><span class='Ref_To_Local'>xldir</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end RemoveNonParentXlogFiles &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Recycle or remove a log file that's no longer needed. 
 * 
 * endptr is current (or recent) end of xlog, and PriorRedoRecPtr is the 
 * redo pointer of the previous checkpoint. These are used to determine 
 * whether we want to recycle rather than delete no-longer-wanted log files. 
 * If PriorRedoRecPtr is not known, pass invalid, and the function will 
 * recycle, somewhat arbitrarily, 10 future segments. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN3964"></a><span class='Declare_Function'>RemoveXlogFile</span><span class='Parentheses'>(</span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>segname</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>PriorRedoPtr</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>endptr</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3966"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>path</span><span class='Delimiter'>[</span><a href="../../../include/pg_config_manual.h.html#LN88"><span class='Ref_to_Const'>MAXPGPATH</span></a><span class='Delimiter'>]; 
</span><span class='Directive'>#ifdef</span> <a href="../../../include/c.h.html#LN61"><span class='Ref_to_Const'>WIN32</span></a> 
<a name="LN3968"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>newpath</span><span class='Delimiter'>[</span><a href="../../../include/pg_config_manual.h.html#LN88"><span class='Ref_to_Const'>MAXPGPATH</span></a><span class='Delimiter'>]; 
</span><span class='Directive'>#endif</span> 
<a name="LN3970"></a>    <span class='Control'>struct</span> <a href="../../../include/port.h.html#LN275"><span class='Ref_to_Macro'>stat</span></a> <span class='Declare_Local'>statbuf</span><span class='Delimiter'>; 
</span><a name="LN3971"></a>    <a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a>   <span class='Declare_Local'>endlogSegNo</span><span class='Delimiter'>; 
</span><a name="LN3972"></a>    <a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a>   <span class='Declare_Local'>recycleSegNo</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Initialize info about where to try to recycle to. 
     */ 
</span>    <a href="../../../include/access/xlog_internal.h.html#LN108"><span class='Ref_to_Macro'>XLByteToPrevSeg</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3964"><span class='Ref_to_Parameter'>endptr</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN3971"><span class='Ref_To_Local'>endlogSegNo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN3964"><span class='Ref_to_Parameter'>PriorRedoPtr</span></a> <span class='Operator'>== </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Parentheses'>) 
</span>        <a href="xlog.c.html#LN3972"><span class='Ref_To_Local'>recycleSegNo</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN3971"><span class='Ref_To_Local'>endlogSegNo</span></a> <span class='Operator'>+ </span><span class='Number'>10</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="xlog.c.html#LN3972"><span class='Ref_To_Local'>recycleSegNo</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN2250"><span class='Ref_to_Func'>XLOGfileslop</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3964"><span class='Ref_to_Parameter'>PriorRedoPtr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../pl/plperl/plperl.h.html#LN60"><span class='Ref_to_Macro'>snprintf</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3966"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, </span><a href="../../../include/pg_config_manual.h.html#LN88"><span class='Ref_to_Const'>MAXPGPATH</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xlog_internal.h.html#LN130"><span class='Ref_to_Const'>XLOGDIR</span></a> <span class='String'>"/%s"</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN3964"><span class='Ref_to_Parameter'>segname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Before deleting the file, see if it can be recycled as a future log 
     * segment. Only recycle normal files, pg_standby for example can create 
     * symbolic links pointing to a separate archive directory. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN3971"><span class='Ref_To_Local'>endlogSegNo</span></a> <span class='Operator'>&LT;= </span><a href="xlog.c.html#LN3972"><span class='Ref_To_Local'>recycleSegNo</span></a> <span class='Operator'>&& 
</span>        <a href="../../../include/port/win32.h.html#LN261"><span class='Ref_to_Macro'>lstat</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3966"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN3970"><span class='Ref_To_Local'>statbuf</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="../../../include/port/win32.h.html#LN430"><span class='Ref_to_Macro'>S_ISREG</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3970"><span class='Ref_To_Local'>statbuf</span></a><span class='Operator'>.</span>st_mode<span class='Parentheses'>) </span><span class='Operator'>&& 
</span>        <a href="xlog.c.html#LN866"><span class='Ref_to_Proto'>InstallXLogFileSegment</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN3971"><span class='Ref_To_Local'>endlogSegNo</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN3966"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, 
</span>                               <span class='Boolean'>true</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN3972"><span class='Ref_To_Local'>recycleSegNo</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"recycled write-ahead log file \"%s\""</span><span class='Delimiter'>, 
</span>                        <a href="xlog.c.html#LN3964"><span class='Ref_to_Parameter'>segname</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN172"><span class='Ref_to_Global_Var'>CheckpointStats</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog.h.html#LN208"><span class='Ref_to_Member'>ckpt_segs_recycled</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* Needn't recheck that slot on future iterations */ 
</span>        <a href="xlog.c.html#LN3971"><span class='Ref_To_Local'>endlogSegNo</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* No need for any more future segments... */ 
</span><a name="LN4005"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>rc</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"removing write-ahead log file \"%s\""</span><span class='Delimiter'>, 
</span>                        <a href="xlog.c.html#LN3964"><span class='Ref_to_Parameter'>segname</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifdef</span> <a href="../../../include/c.h.html#LN61"><span class='Ref_to_Const'>WIN32</span></a> 
 
        <span class='Comment_Multi_Line'>/* 
         * On Windows, if another process (e.g another backend) holds the file 
         * open in FILE_SHARE_DELETE mode, unlink will succeed, but the file 
         * will still show up in directory listing until the last handle is 
         * closed. To avoid confusing the lingering deleted file for a live 
         * WAL file that needs to be archived, rename it before deleting it. 
         * 
         * If another process holds the file open without FILE_SHARE_DELETE 
         * flag, rename will fail. We'll try again at the next checkpoint. 
         */ 
</span>        <a href="../../../pl/plperl/plperl.h.html#LN60"><span class='Ref_to_Macro'>snprintf</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3968"><span class='Ref_To_Local'>newpath</span></a><span class='Delimiter'>, </span><a href="../../../include/pg_config_manual.h.html#LN88"><span class='Ref_to_Const'>MAXPGPATH</span></a><span class='Delimiter'>, </span><span class='String'>"%s.deleted"</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN3966"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../port/dirmod.c.html#LN121"><span class='Ref_to_Macro'>rename</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3966"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN3968"><span class='Ref_To_Local'>newpath</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>               <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not rename old write-ahead log file \"%s\": %m"</span><span class='Delimiter'>, 
</span>                      <a href="xlog.c.html#LN3966"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <a href="xlog.c.html#LN4005"><span class='Ref_To_Local'>rc</span></a> <span class='Operator'>= </span><a href="../../../include/storage/fd.h.html#LN121"><span class='Ref_to_Proto'>durable_unlink</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3968"><span class='Ref_To_Local'>newpath</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#else</span> 
        <a href="xlog.c.html#LN4005"><span class='Ref_To_Local'>rc</span></a> <span class='Operator'>= </span><a href="../../../include/storage/fd.h.html#LN121"><span class='Ref_to_Proto'>durable_unlink</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3966"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN4005"><span class='Ref_To_Local'>rc</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Message already logged by durable_unlink() */ 
</span>            <span class='Control'>return</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <a href="xlog.c.html#LN172"><span class='Ref_to_Global_Var'>CheckpointStats</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog.h.html#LN207"><span class='Ref_to_Member'>ckpt_segs_removed</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
    <a href="../../../include/access/xlog_internal.h.html#LN319"><span class='Ref_to_Proto'>XLogArchiveCleanup</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN3964"><span class='Ref_to_Parameter'>segname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end RemoveXlogFile &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Verify whether pg_wal and pg_wal/archive_status exist. 
 * If the latter does not exist, recreate it. 
 * 
 * It is not the goal of this function to verify the contents of these 
 * directories, but to help in cases where someone has performed a cluster 
 * copy for PITR purposes but omitted pg_wal from the copy. 
 * 
 * We could also recreate pg_wal if it doesn't exist, but a deliberate 
 * policy decision was made not to.  It is fairly common for pg_wal to be 
 * a symlink, and if that was the DBA's intent then automatically making a 
 * plain directory would result in degraded performance with no notice. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN4061"></a><span class='Declare_Function'>ValidateXLOGDirectoryStructure</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4063"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>path</span><span class='Delimiter'>[</span><a href="../../../include/pg_config_manual.h.html#LN88"><span class='Ref_to_Const'>MAXPGPATH</span></a><span class='Delimiter'>]; 
</span><a name="LN4064"></a>    <span class='Control'>struct</span> <a href="../../../include/port.h.html#LN275"><span class='Ref_to_Macro'>stat</span></a> <span class='Declare_Local'>stat_buf</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Check for pg_wal; if it doesn't exist, error out */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/port.h.html#LN275"><span class='Ref_to_Macro'>stat</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlog_internal.h.html#LN130"><span class='Ref_to_Const'>XLOGDIR</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN4064"><span class='Ref_To_Local'>stat_buf</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span> <span class='Operator'>|| 
</span>        <span class='Operator'>!</span><a href="../../../include/port/win32.h.html#LN429"><span class='Ref_to_Macro'>S_ISDIR</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4064"><span class='Ref_To_Local'>stat_buf</span></a><span class='Operator'>.</span>st_mode<span class='Parentheses'>))</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"required WAL directory \"%s\" does not exist"</span><span class='Delimiter'>, 
</span>                        <a href="../../../include/access/xlog_internal.h.html#LN130"><span class='Ref_to_Const'>XLOGDIR</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Check for archive_status */ 
</span>    <a href="../../../pl/plperl/plperl.h.html#LN60"><span class='Ref_to_Macro'>snprintf</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4063"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, </span><a href="../../../include/pg_config_manual.h.html#LN88"><span class='Ref_to_Const'>MAXPGPATH</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xlog_internal.h.html#LN130"><span class='Ref_to_Const'>XLOGDIR</span></a> <span class='String'>"/archive_status"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/port.h.html#LN275"><span class='Ref_to_Macro'>stat</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4063"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN4064"><span class='Ref_To_Local'>stat_buf</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Check for weird cases where it exists but isn't a directory */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/port/win32.h.html#LN429"><span class='Ref_to_Macro'>S_ISDIR</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4064"><span class='Ref_To_Local'>stat_buf</span></a><span class='Operator'>.</span>st_mode<span class='Parentheses'>))</span> 
            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"required WAL directory \"%s\" does not exist"</span><span class='Delimiter'>, 
</span>                            <a href="xlog.c.html#LN4063"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"creating missing WAL directory \"%s\""</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN4063"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/port/win32.h.html#LN56"><span class='Ref_to_Macro'>mkdir</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4063"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, </span><a href="../../../include/port/win32.h.html#LN427"><span class='Ref_to_Const'>S_IRWXU</span></a><span class='Parentheses'>) </span><span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not create missing directory \"%s\": %m"</span><span class='Delimiter'>, 
</span>                            <a href="xlog.c.html#LN4063"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end ValidateXLOGDirectoryStructure &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Remove previous backup history files.  This also retries creation of 
 * .ready files for any backup history files for which XLogArchiveNotify 
 * failed earlier. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN4100"></a><span class='Declare_Function'>CleanupBackupHistory</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4102"></a>    <a href="../../../port/dirent.c.html#LN24"><span class='Ref_to_Struct'>DIR</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>xldir</span><span class='Delimiter'>; 
</span><a name="LN4103"></a>    <span class='Control'>struct</span> <a href="../../../include/port/win32_msvc/dirent.h.html#LN8"><span class='Ref_to_Struct'>dirent</span></a> <span class='Operator'>*</span><span class='Declare_Local'>xlde</span><span class='Delimiter'>; 
</span><a name="LN4104"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>path</span><span class='Delimiter'>[</span><a href="../../../include/pg_config_manual.h.html#LN88"><span class='Ref_to_Const'>MAXPGPATH</span></a> <span class='Operator'>+ </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/access/xlog_internal.h.html#LN130"><span class='Ref_to_Const'>XLOGDIR</span></a><span class='Parentheses'>)</span><span class='Delimiter'>]; 
</span> 
    <a href="xlog.c.html#LN4102"><span class='Ref_To_Local'>xldir</span></a> <span class='Operator'>= </span><a href="../../../include/storage/fd.h.html#LN91"><span class='Ref_to_Proto'>AllocateDir</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlog_internal.h.html#LN130"><span class='Ref_to_Const'>XLOGDIR</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN4102"><span class='Ref_To_Local'>xldir</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not open write-ahead log directory \"%s\": %m"</span><span class='Delimiter'>, 
</span>                        <a href="../../../include/access/xlog_internal.h.html#LN130"><span class='Ref_to_Const'>XLOGDIR</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>while</span> <span class='Parentheses'>((</span><a href="xlog.c.html#LN4103"><span class='Ref_To_Local'>xlde</span></a> <span class='Operator'>= </span><a href="../../../include/storage/fd.h.html#LN92"><span class='Ref_to_Proto'>ReadDir</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4102"><span class='Ref_To_Local'>xldir</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xlog_internal.h.html#LN130"><span class='Ref_to_Const'>XLOGDIR</span></a><span class='Parentheses'>))</span> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/xlog_internal.h.html#LN196"><span class='Ref_to_Macro'>IsBackupHistoryFileName</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4103"><span class='Ref_To_Local'>xlde</span></a><span class='Operator'>-&GT;</span><a href="../../../include/port/win32_msvc/dirent.h.html#LN13"><span class='Ref_to_Member'>d_name</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/xlog_internal.h.html#LN315"><span class='Ref_to_Proto'>XLogArchiveCheckDone</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4103"><span class='Ref_To_Local'>xlde</span></a><span class='Operator'>-&GT;</span><a href="../../../include/port/win32_msvc/dirent.h.html#LN13"><span class='Ref_to_Member'>d_name</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Delimiter'>, </span><span class='String'>"removing WAL backup history file \"%s\""</span><span class='Delimiter'>, 
</span>                     <a href="xlog.c.html#LN4103"><span class='Ref_To_Local'>xlde</span></a><span class='Operator'>-&GT;</span><a href="../../../include/port/win32_msvc/dirent.h.html#LN13"><span class='Ref_to_Member'>d_name</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="../../../pl/plperl/plperl.h.html#LN60"><span class='Ref_to_Macro'>snprintf</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4104"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN4104"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="../../../include/access/xlog_internal.h.html#LN130"><span class='Ref_to_Const'>XLOGDIR</span></a> <span class='String'>"/%s"</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN4103"><span class='Ref_To_Local'>xlde</span></a><span class='Operator'>-&GT;</span><a href="../../../include/port/win32_msvc/dirent.h.html#LN13"><span class='Ref_to_Member'>d_name</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="../../../timezone/private.h.html#LN59"><span class='Ref_to_Proto'>unlink</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4104"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="../../../include/access/xlog_internal.h.html#LN319"><span class='Ref_to_Proto'>XLogArchiveCleanup</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4103"><span class='Ref_To_Local'>xlde</span></a><span class='Operator'>-&GT;</span><a href="../../../include/port/win32_msvc/dirent.h.html#LN13"><span class='Ref_to_Member'>d_name</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/storage/fd.h.html#LN93"><span class='Ref_to_Proto'>FreeDir</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4102"><span class='Ref_To_Local'>xldir</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end CleanupBackupHistory &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Attempt to read an XLOG record. 
 * 
 * If RecPtr is not NULL, try to read a record at that position.  Otherwise 
 * try to read a record just after the last one previously read. 
 * 
 * If no valid record is available, returns NULL, or fails if emode is PANIC. 
 * (emode must be either PANIC, LOG). In standby mode, retries until a valid 
 * record is available. 
 * 
 * The record is copied into readRecordBuf, so that on successful return, 
 * the returned record pointer always points there. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/access/xlogrecord.h.html#LN40"><span class='Ref_to_Struct'>XLogRecord</span></a> <span class='Operator'>* 
</span><a name="LN4145"></a><span class='Declare_Function'>ReadRecord</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogreader.h.html#LN68"><span class='Ref_to_Struct'>XLogReaderState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>xlogreader</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>RecPtr</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>emode</span><span class='Delimiter'>, 
</span><a name="LN4146"></a>           <span class='Keyword'>bool </span><span class='Declare_Parameter'>fetching_ckpt</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4148"></a>    <a href="../../../include/access/xlogrecord.h.html#LN40"><span class='Ref_to_Struct'>XLogRecord</span></a> <span class='Operator'>*</span><span class='Declare_Local'>record</span><span class='Delimiter'>; 
</span><a name="LN4149"></a>    <a href="../../../bin/pg_rewind/parsexlog.c.html#LN44"><span class='Ref_to_Struct'>XLogPageReadPrivate</span></a> <span class='Operator'>*</span><span class='Declare_Local'>private</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../bin/pg_rewind/parsexlog.c.html#LN44"><span class='Ref_to_Struct'>XLogPageReadPrivate</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="xlog.c.html#LN4145"><span class='Ref_to_Parameter'>xlogreader</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogreader.h.html#LN107"><span class='Ref_to_Member'>private_data</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Pass through parameters to XLogPageRead */ 
</span>    <span class='Keyword'>private</span><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN801"><span class='Ref_to_Member'>fetching_ckpt</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN4146"><span class='Ref_to_Parameter'>fetching_ckpt</span></a><span class='Delimiter'>; 
</span>    <span class='Keyword'>private</span><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN800"><span class='Ref_to_Member'>emode</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN4145"><span class='Ref_to_Parameter'>emode</span></a><span class='Delimiter'>; 
</span>    <span class='Keyword'>private</span><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN802"><span class='Ref_to_Member'>randAccess</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="xlog.c.html#LN4145"><span class='Ref_to_Parameter'>RecPtr</span></a> <span class='Operator'>!= </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* This is the first attempt to read this page. */ 
</span>    <a href="xlog.c.html#LN796"><span class='Ref_to_Global_Var'>lastSourceFailed</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>;;</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN4161"></a>        <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>errormsg</span><span class='Delimiter'>; 
</span> 
        <a href="xlog.c.html#LN4148"><span class='Ref_To_Local'>record</span></a> <span class='Operator'>= </span><a href="xlogreader.c.html#LN191"><span class='Ref_to_Func'>XLogReadRecord</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4145"><span class='Ref_to_Parameter'>xlogreader</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN4145"><span class='Ref_to_Parameter'>RecPtr</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN4161"><span class='Ref_To_Local'>errormsg</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN817"><span class='Ref_to_Global_Var'>ReadRecPtr</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN4145"><span class='Ref_to_Parameter'>xlogreader</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogreader.h.html#LN113"><span class='Ref_to_Member'>ReadRecPtr</span></a><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN818"><span class='Ref_to_Global_Var'>EndRecPtr</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN4145"><span class='Ref_to_Parameter'>xlogreader</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogreader.h.html#LN114"><span class='Ref_to_Member'>EndRecPtr</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN4148"><span class='Ref_To_Local'>record</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN782"><span class='Ref_to_Global_Var'>readFile</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="../../../interfaces/libpq/win32.h.html#LN11"><span class='Ref_to_Macro'>close</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN782"><span class='Ref_to_Global_Var'>readFile</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="xlog.c.html#LN782"><span class='Ref_to_Global_Var'>readFile</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * We only end up here without a message when XLogPageRead() 
             * failed - in that case we already logged something. In 
             * StandbyMode that only happens if we have been triggered, so we 
             * shouldn't loop anymore in that case. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN4161"><span class='Ref_To_Local'>errormsg</span></a><span class='Parentheses'>) 
</span>                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN877"><span class='Ref_to_Proto'>emode_for_corrupt_record</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4145"><span class='Ref_to_Parameter'>emode</span></a><span class='Delimiter'>, 
</span>                                                 <a href="xlog.c.html#LN4145"><span class='Ref_to_Parameter'>RecPtr</span></a> <span class='Operator'>? </span><a href="xlog.c.html#LN4145"><span class='Ref_to_Parameter'>RecPtr</span></a> <span class='Operator'>: </span><a href="xlog.c.html#LN818"><span class='Ref_to_Global_Var'>EndRecPtr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN825"><span class='Ref_to_Func'>errmsg_internal</span></a><span class='Parentheses'>(</span><span class='String'>"%s"</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN4161"><span class='Ref_To_Local'>errormsg</span></a><span class='Parentheses'>) </span><span class='Comment_Multi_Line'>/* already translated */ </span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Check page TLI is one of the expected values. 
         */ 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/timeline.h.html#LN38"><span class='Ref_to_Proto'>tliInHistory</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4145"><span class='Ref_to_Parameter'>xlogreader</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogreader.h.html#LN159"><span class='Ref_to_Member'>latestPageTLI</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN317"><span class='Ref_to_Global_Var'>expectedTLEs</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN4191"></a>            <span class='Keyword'>char</span>        <span class='Declare_Local'>fname</span><span class='Delimiter'>[</span><a href="../../../include/access/xlog_internal.h.html#LN137"><span class='Ref_to_Const'>MAXFNAMELEN</span></a><span class='Delimiter'>]; 
</span><a name="LN4192"></a>            <a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a>   <span class='Declare_Local'>segno</span><span class='Delimiter'>; 
</span><a name="LN4193"></a>            <a href="../../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Local'>offset</span><span class='Delimiter'>; 
</span> 
            <a href="../../../include/access/xlog_internal.h.html#LN105"><span class='Ref_to_Macro'>XLByteToSeg</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4145"><span class='Ref_to_Parameter'>xlogreader</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogreader.h.html#LN158"><span class='Ref_to_Member'>latestPagePtr</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN4192"><span class='Ref_To_Local'>segno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN4193"><span class='Ref_To_Local'>offset</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN4145"><span class='Ref_to_Parameter'>xlogreader</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogreader.h.html#LN158"><span class='Ref_to_Member'>latestPagePtr</span></a> <span class='Operator'>% </span><a href="../../../include/access/xlog_internal.h.html#LN91"><span class='Ref_to_Const'>XLogSegSize</span></a><span class='Delimiter'>; 
</span>            <a href="../../../include/access/xlog_internal.h.html#LN142"><span class='Ref_to_Macro'>XLogFileName</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4191"><span class='Ref_To_Local'>fname</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN4145"><span class='Ref_to_Parameter'>xlogreader</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogreader.h.html#LN152"><span class='Ref_to_Member'>readPageTLI</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN4192"><span class='Ref_To_Local'>segno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN877"><span class='Ref_to_Proto'>emode_for_corrupt_record</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4145"><span class='Ref_to_Parameter'>emode</span></a><span class='Delimiter'>, 
</span>                                             <a href="xlog.c.html#LN4145"><span class='Ref_to_Parameter'>RecPtr</span></a> <span class='Operator'>? </span><a href="xlog.c.html#LN4145"><span class='Ref_to_Parameter'>RecPtr</span></a> <span class='Operator'>: </span><a href="xlog.c.html#LN818"><span class='Ref_to_Global_Var'>EndRecPtr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>            <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"unexpected timeline ID %u in log segment %s, offset %u"</span><span class='Delimiter'>, 
</span>                    <a href="xlog.c.html#LN4145"><span class='Ref_to_Parameter'>xlogreader</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogreader.h.html#LN159"><span class='Ref_to_Member'>latestPageTLI</span></a><span class='Delimiter'>, 
</span>                    <a href="xlog.c.html#LN4191"><span class='Ref_To_Local'>fname</span></a><span class='Delimiter'>, 
</span>                    <a href="xlog.c.html#LN4193"><span class='Ref_To_Local'>offset</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN4148"><span class='Ref_To_Local'>record</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN4148"><span class='Ref_To_Local'>record</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Great, got a record */ 
</span>            <span class='Control'>return</span> <a href="xlog.c.html#LN4148"><span class='Ref_To_Local'>record</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* No valid record available from this source */ 
</span>            <a href="xlog.c.html#LN796"><span class='Ref_to_Global_Var'>lastSourceFailed</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * If archive recovery was requested, but we were still doing 
             * crash recovery, switch to archive recovery and retry using the 
             * offline archive. We have now replayed all the valid WAL in 
             * pg_wal, so we are presumably now consistent. 
             * 
             * We require that there's at least some valid WAL present in 
             * pg_wal, however (!fetch_ckpt). We could recover using the WAL 
             * from the archive, even if pg_wal is completely empty, but we'd 
             * have no idea how far we'd have to replay to reach consistency. 
             * So err on the safe side and give up. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN246"><span class='Ref_to_Global_Var'>InArchiveRecovery</span></a> <span class='Operator'>&& </span><a href="xlog.c.html#LN245"><span class='Ref_to_Global_Var'>ArchiveRecoveryRequested</span></a> <span class='Operator'>&& 
</span>                <span class='Operator'>!</span><a href="xlog.c.html#LN4146"><span class='Ref_to_Parameter'>fetching_ckpt</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN24"><span class='Ref_to_Const'>DEBUG1</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN825"><span class='Ref_to_Func'>errmsg_internal</span></a><span class='Parentheses'>(</span><span class='String'>"reached end of WAL in pg_wal, entering archive recovery"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                <a href="xlog.c.html#LN246"><span class='Ref_to_Global_Var'>InArchiveRecovery</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN270"><span class='Ref_to_Global_Var'>StandbyModeRequested</span></a><span class='Parentheses'>) 
</span>                    <a href="xlog.c.html#LN276"><span class='Ref_to_Global_Var'>StandbyMode</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* initialize minRecoveryPoint to this record */ 
</span>                <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ControlFileLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN129"><span class='Ref_to_Member'>state</span></a> <span class='Operator'>= </span><a href="../../../include/catalog/pg_control.h.html#LN90"><span class='Ref_to_EnumConst'>DB_IN_ARCHIVE_RECOVERY</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN169"><span class='Ref_to_Member'>minRecoveryPoint</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN818"><span class='Ref_to_Global_Var'>EndRecPtr</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN169"><span class='Ref_to_Member'>minRecoveryPoint</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN818"><span class='Ref_to_Global_Var'>EndRecPtr</span></a><span class='Delimiter'>; 
</span>                    <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN170"><span class='Ref_to_Member'>minRecoveryPointTLI</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Comment_Multi_Line'>/* update local copy */ 
</span>                <a href="xlog.c.html#LN820"><span class='Ref_to_Global_Var'>minRecoveryPoint</span></a> <span class='Operator'>= </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN169"><span class='Ref_to_Member'>minRecoveryPoint</span></a><span class='Delimiter'>; 
</span>                <a href="xlog.c.html#LN822"><span class='Ref_to_Global_Var'>minRecoveryPointTLI</span></a> <span class='Operator'>= </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN170"><span class='Ref_to_Member'>minRecoveryPointTLI</span></a><span class='Delimiter'>; 
</span> 
                <a href="../../../include/access/xlog.h.html#LN256"><span class='Ref_to_Proto'>UpdateControlFile</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>                <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ControlFileLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="xlog.c.html#LN888"><span class='Ref_to_Proto'>CheckRecoveryConsistency</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * Before we retry, reset lastSourceFailed and currentSource 
                 * so that we will check the archive next. 
                 */ 
</span>                <a href="xlog.c.html#LN796"><span class='Ref_to_Global_Var'>lastSourceFailed</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                <a href="xlog.c.html#LN795"><span class='Ref_to_Global_Var'>currentSource</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>continue</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !InArchiveRecovery&&A... &raquo; </span> 
 
            <span class='Comment_Multi_Line'>/* In standby mode, loop back to retry. Otherwise, give up. */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN276"><span class='Ref_to_Global_Var'>StandbyMode</span></a> <span class='Operator'>&& !</span><a href="xlog.c.html#LN895"><span class='Ref_to_Proto'>CheckForStandbyTrigger</span></a><span class='Parentheses'>())</span> 
                <span class='Control'>continue</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for ;; &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end ReadRecord &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Scan for new timelines that might have appeared in the archive since we 
 * started recovery. 
 * 
 * If there are any, the function changes recovery target TLI to the latest 
 * one and returns 'true'. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN4282"></a><span class='Declare_Function'>rescanLatestTimeLine</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4284"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>newExpectedTLEs</span><span class='Delimiter'>; 
</span><a name="LN4285"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>found</span><span class='Delimiter'>; 
</span><a name="LN4286"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>cell</span><span class='Delimiter'>; 
</span><a name="LN4287"></a>    <a href="../../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a>  <span class='Declare_Local'>newtarget</span><span class='Delimiter'>; 
</span><a name="LN4288"></a>    <a href="../../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a>  <span class='Declare_Local'>oldtarget</span> <span class='Operator'>= </span><a href="xlog.c.html#LN315"><span class='Ref_to_Global_Var'>recoveryTargetTLI</span></a><span class='Delimiter'>; 
</span><a name="LN4289"></a>    <a href="../../../include/access/timeline.h.html#LN24"><span class='Ref_to_Typedef'>TimeLineHistoryEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>currentTle</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <a href="xlog.c.html#LN4287"><span class='Ref_To_Local'>newtarget</span></a> <span class='Operator'>= </span><a href="../../../include/access/timeline.h.html#LN33"><span class='Ref_to_Proto'>findNewestTimeLine</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN315"><span class='Ref_to_Global_Var'>recoveryTargetTLI</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN4287"><span class='Ref_To_Local'>newtarget</span></a> <span class='Operator'>== </span><a href="xlog.c.html#LN315"><span class='Ref_to_Global_Var'>recoveryTargetTLI</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* No new timelines found */ 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Determine the list of expected TLIs for the new TLI 
     */ 
</span> 
    <a href="xlog.c.html#LN4284"><span class='Ref_To_Local'>newExpectedTLEs</span></a> <span class='Operator'>= </span><a href="../../../include/access/timeline.h.html#LN31"><span class='Ref_to_Proto'>readTimeLineHistory</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4287"><span class='Ref_To_Local'>newtarget</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the current timeline is not part of the history of the new timeline, 
     * we cannot proceed to it. 
     */ 
</span>    <a href="xlog.c.html#LN4285"><span class='Ref_To_Local'>found</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4286"><span class='Ref_To_Local'>cell</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN4284"><span class='Ref_To_Local'>newExpectedTLEs</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="xlog.c.html#LN4289"><span class='Ref_To_Local'>currentTle</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/timeline.h.html#LN24"><span class='Ref_to_Typedef'>TimeLineHistoryEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4286"><span class='Ref_To_Local'>cell</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN4289"><span class='Ref_To_Local'>currentTle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/timeline.h.html#LN26"><span class='Ref_to_Member'>tli</span></a> <span class='Operator'>== </span><a href="xlog.c.html#LN315"><span class='Ref_to_Global_Var'>recoveryTargetTLI</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="xlog.c.html#LN4285"><span class='Ref_To_Local'>found</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN4285"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"new timeline %u is not a child of database system timeline %u"</span><span class='Delimiter'>, 
</span>                        <a href="xlog.c.html#LN4287"><span class='Ref_To_Local'>newtarget</span></a><span class='Delimiter'>, 
</span>                        <a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * The current timeline was found in the history file, but check that the 
     * next timeline was forked off from it *after* the current recovery 
     * location. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN4289"><span class='Ref_To_Local'>currentTle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/timeline.h.html#LN28"><span class='Ref_to_Member'>end</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN818"><span class='Ref_to_Global_Var'>EndRecPtr</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"new timeline %u forked off current database system timeline %u before current recovery point %X/%X"</span><span class='Delimiter'>, 
</span>                        <a href="xlog.c.html#LN4287"><span class='Ref_To_Local'>newtarget</span></a><span class='Delimiter'>, 
</span>                        <a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN818"><span class='Ref_to_Global_Var'>EndRecPtr</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN818"><span class='Ref_to_Global_Var'>EndRecPtr</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* The new timeline history seems valid. Switch target */ 
</span>    <a href="xlog.c.html#LN315"><span class='Ref_to_Global_Var'>recoveryTargetTLI</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN4287"><span class='Ref_To_Local'>newtarget</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN266"><span class='Ref_to_Proto'>list_free_deep</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN317"><span class='Ref_to_Global_Var'>expectedTLEs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN317"><span class='Ref_to_Global_Var'>expectedTLEs</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN4284"><span class='Ref_To_Local'>newExpectedTLEs</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * As in StartupXLOG(), try to ensure we have all the history files 
     * between the old target and new target in pg_wal. 
     */ 
</span>    <a href="../../../include/access/timeline.h.html#LN37"><span class='Ref_to_Proto'>restoreTimeLineHistoryFiles</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4288"><span class='Ref_To_Local'>oldtarget</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN4287"><span class='Ref_To_Local'>newtarget</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>            <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"new target timeline is %u"</span><span class='Delimiter'>, 
</span>                    <a href="xlog.c.html#LN315"><span class='Ref_to_Global_Var'>recoveryTargetTLI</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end rescanLatestTimeLine &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * I/O routines for pg_control 
 * 
 * *ControlFile is a buffer in shared memory that holds an image of the 
 * contents of pg_control.  WriteControlFile() initializes pg_control 
 * given a preloaded buffer, ReadControlFile() loads the buffer from 
 * the pg_control file (during postmaster or standalone-backend startup), 
 * and UpdateControlFile() rewrites pg_control after we modify xlog state. 
 * 
 * For simplicity, WriteControlFile() initializes the fields of pg_control 
 * that are related to checking backend/database compatibility, and 
 * ReadControlFile() verifies they are correct.  We could split out the 
 * I/O and compatibility-check functions, but there seems no need currently. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN4376"></a><span class='Declare_Function'>WriteControlFile</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4378"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>fd</span><span class='Delimiter'>; 
</span><a name="LN4379"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>buffer</span><span class='Delimiter'>[</span><a href="../../../include/catalog/pg_control.h.html#LN244"><span class='Ref_to_Const'>PG_CONTROL_SIZE</span></a><span class='Delimiter'>];</span>        <span class='Comment_Single_Line'>/* need not be aligned */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Initialize version and compatibility-check fields 
     */ 
</span>    <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN123"><span class='Ref_to_Member'>pg_control_version</span></a> <span class='Operator'>= </span><a href="../../../include/catalog/pg_control.h.html#LN25"><span class='Ref_to_Const'>PG_CONTROL_VERSION</span></a><span class='Delimiter'>; 
</span>    <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN124"><span class='Ref_to_Member'>catalog_version_no</span></a> <span class='Operator'>= </span><a href="../../../include/catalog/catversion.h.html#LN55"><span class='Ref_to_Const'>CATALOG_VERSION_NO</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN199"><span class='Ref_to_Member'>maxAlign</span></a> <span class='Operator'>= </span>MAXIMUM_ALIGNOF<span class='Delimiter'>; 
</span>    <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN200"><span class='Ref_to_Member'>floatFormat</span></a> <span class='Operator'>= </span><a href="../../../include/catalog/pg_control.h.html#LN201"><span class='Ref_to_Const'>FLOATFORMAT_VALUE</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN207"><span class='Ref_to_Member'>blcksz</span></a> <span class='Operator'>= </span>BLCKSZ<span class='Delimiter'>; 
</span>    <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN208"><span class='Ref_to_Member'>relseg_size</span></a> <span class='Operator'>= </span>RELSEG_SIZE<span class='Delimiter'>; 
</span>    <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN210"><span class='Ref_to_Member'>xlog_blcksz</span></a> <span class='Operator'>= </span>XLOG_BLCKSZ<span class='Delimiter'>; 
</span>    <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN211"><span class='Ref_to_Member'>xlog_seg_size</span></a> <span class='Operator'>= </span>XLOG_SEG_SIZE<span class='Delimiter'>; 
</span> 
    <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN213"><span class='Ref_to_Member'>nameDataLen</span></a> <span class='Operator'>= </span><a href="../../../interfaces/ecpg/include/sqlda-native.h.html#LN15"><span class='Ref_to_Const'>NAMEDATALEN</span></a><span class='Delimiter'>; 
</span>    <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN214"><span class='Ref_to_Member'>indexMaxKeys</span></a> <span class='Operator'>= </span><a href="../../../include/pg_config_manual.h.html#LN45"><span class='Ref_to_Const'>INDEX_MAX_KEYS</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN216"><span class='Ref_to_Member'>toast_max_chunk_size</span></a> <span class='Operator'>= </span><a href="../../../include/access/tuptoaster.h.html#LN90"><span class='Ref_to_Const'>TOAST_MAX_CHUNK_SIZE</span></a><span class='Delimiter'>; 
</span>    <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN217"><span class='Ref_to_Member'>loblksize</span></a> <span class='Operator'>= </span><a href="../../../include/storage/large_object.h.html#LN71"><span class='Ref_to_Const'>LOBLKSIZE</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN220"><span class='Ref_to_Member'>float4ByVal</span></a> <span class='Operator'>= </span>FLOAT4PASSBYVAL<span class='Delimiter'>; 
</span>    <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN221"><span class='Ref_to_Member'>float8ByVal</span></a> <span class='Operator'>= </span>FLOAT8PASSBYVAL<span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Contents are protected with a CRC */ 
</span>    <a href="../../../include/port/pg_crc32c.h.html#LN40"><span class='Ref_to_Macro'>INIT_CRC32C</span></a><span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN234"><span class='Ref_to_Member'>crc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/port/pg_crc32c.h.html#LN45"><span class='Ref_to_Macro'>COMP_CRC32C</span></a><span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN234"><span class='Ref_to_Member'>crc</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Delimiter'>, 
</span>                <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_control.h.html#LN102"><span class='Ref_to_Struct'>ControlFileData</span></a><span class='Delimiter'>, </span>crc<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/port/pg_crc32c.h.html#LN47"><span class='Ref_to_Macro'>FIN_CRC32C</span></a><span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN234"><span class='Ref_to_Member'>crc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We write out PG_CONTROL_SIZE bytes into pg_control, zero-padding the 
     * excess over sizeof(ControlFileData).  This reduces the odds of 
     * premature-EOF errors when reading pg_control.  We'll still fail when we 
     * check the contents of the file, but hopefully with a more specific 
     * error than "couldn't read pg_control". 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_control.h.html#LN102"><span class='Ref_to_Struct'>ControlFileData</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT; </span><a href="../../../include/catalog/pg_control.h.html#LN244"><span class='Ref_to_Const'>PG_CONTROL_SIZE</span></a><span class='Parentheses'>)</span> 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, </span><span class='String'>"sizeof(ControlFileData) is larger than PG_CONTROL_SIZE; fix either one"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    memset<span class='Parentheses'>(</span><a href="xlog.c.html#LN4379"><span class='Ref_To_Local'>buffer</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><a href="../../../include/catalog/pg_control.h.html#LN244"><span class='Ref_to_Const'>PG_CONTROL_SIZE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    memcpy<span class='Parentheses'>(</span><a href="xlog.c.html#LN4379"><span class='Ref_To_Local'>buffer</span></a><span class='Delimiter'>, </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_control.h.html#LN102"><span class='Ref_to_Struct'>ControlFileData</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="xlog.c.html#LN4378"><span class='Ref_To_Local'>fd</span></a> <span class='Operator'>= </span><a href="../../../include/storage/fd.h.html#LN100"><span class='Ref_to_Proto'>BasicOpenFile</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlog_internal.h.html#LN131"><span class='Ref_to_Const'>XLOG_CONTROL_FILE</span></a><span class='Delimiter'>, 
</span>                       O_RDWR <span class='Operator'>| </span>O_CREAT <span class='Operator'>| </span>O_EXCL <span class='Operator'>| </span><a href="../../../include/c.h.html#LN1032"><span class='Ref_to_Const'>PG_BINARY</span></a><span class='Delimiter'>, 
</span>                       <a href="../../../include/port/win32.h.html#LN424"><span class='Ref_to_Const'>S_IRUSR</span></a> <span class='Operator'>| </span><a href="../../../include/port/win32.h.html#LN425"><span class='Ref_to_Const'>S_IWUSR</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN4378"><span class='Ref_To_Local'>fd</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not create control file \"%s\": %m"</span><span class='Delimiter'>, 
</span>                        <a href="../../../include/access/xlog_internal.h.html#LN131"><span class='Ref_to_Const'>XLOG_CONTROL_FILE</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    errno <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="../../../include/pgstat.h.html#LN1206"><span class='Ref_to_Func'>pgstat_report_wait_start</span></a><span class='Parentheses'>(</span><a href="../../../include/pgstat.h.html#LN843"><span class='Ref_to_EnumConst'>WAIT_EVENT_CONTROL_FILE_WRITE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../interfaces/libpq/win32.h.html#LN13"><span class='Ref_to_Macro'>write</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4378"><span class='Ref_To_Local'>fd</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN4379"><span class='Ref_To_Local'>buffer</span></a><span class='Delimiter'>, </span><a href="../../../include/catalog/pg_control.h.html#LN244"><span class='Ref_to_Const'>PG_CONTROL_SIZE</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><a href="../../../include/catalog/pg_control.h.html#LN244"><span class='Ref_to_Const'>PG_CONTROL_SIZE</span></a><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* if write didn't set errno, assume problem is no disk space */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span>errno <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            errno <span class='Operator'>= </span>ENOSPC<span class='Delimiter'>; 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not write to control file: %m"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="../../../include/pgstat.h.html#LN1230"><span class='Ref_to_Func'>pgstat_report_wait_end</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/pgstat.h.html#LN1206"><span class='Ref_to_Func'>pgstat_report_wait_start</span></a><span class='Parentheses'>(</span><a href="../../../include/pgstat.h.html#LN841"><span class='Ref_to_EnumConst'>WAIT_EVENT_CONTROL_FILE_SYNC</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/fd.h.html#LN114"><span class='Ref_to_Proto'>pg_fsync</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4378"><span class='Ref_To_Local'>fd</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not fsync control file: %m"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/pgstat.h.html#LN1230"><span class='Ref_to_Func'>pgstat_report_wait_end</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../interfaces/libpq/win32.h.html#LN11"><span class='Ref_to_Macro'>close</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4378"><span class='Ref_To_Local'>fd</span></a><span class='Parentheses'>))</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not close control file: %m"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end WriteControlFile &raquo; </span> 
 
<span class='Keyword'>static void 
</span><a name="LN4460"></a><span class='Declare_Function'>ReadControlFile</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4462"></a>    <a href="../../../include/port/pg_crc32c.h.html#LN37"><span class='Ref_to_Typedef'>pg_crc32c</span></a>   <span class='Declare_Local'>crc</span><span class='Delimiter'>; 
</span><a name="LN4463"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>fd</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Read data... 
     */ 
</span>    <a href="xlog.c.html#LN4463"><span class='Ref_To_Local'>fd</span></a> <span class='Operator'>= </span><a href="../../../include/storage/fd.h.html#LN100"><span class='Ref_to_Proto'>BasicOpenFile</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlog_internal.h.html#LN131"><span class='Ref_to_Const'>XLOG_CONTROL_FILE</span></a><span class='Delimiter'>, 
</span>                       O_RDWR <span class='Operator'>| </span><a href="../../../include/c.h.html#LN1032"><span class='Ref_to_Const'>PG_BINARY</span></a><span class='Delimiter'>, 
</span>                       <a href="../../../include/port/win32.h.html#LN424"><span class='Ref_to_Const'>S_IRUSR</span></a> <span class='Operator'>| </span><a href="../../../include/port/win32.h.html#LN425"><span class='Ref_to_Const'>S_IWUSR</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN4463"><span class='Ref_To_Local'>fd</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not open control file \"%s\": %m"</span><span class='Delimiter'>, 
</span>                        <a href="../../../include/access/xlog_internal.h.html#LN131"><span class='Ref_to_Const'>XLOG_CONTROL_FILE</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/pgstat.h.html#LN1206"><span class='Ref_to_Func'>pgstat_report_wait_start</span></a><span class='Parentheses'>(</span><a href="../../../include/pgstat.h.html#LN840"><span class='Ref_to_EnumConst'>WAIT_EVENT_CONTROL_FILE_READ</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../interfaces/libpq/win32.h.html#LN12"><span class='Ref_to_Macro'>read</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4463"><span class='Ref_To_Local'>fd</span></a><span class='Delimiter'>, </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_control.h.html#LN102"><span class='Ref_to_Struct'>ControlFileData</span></a><span class='Parentheses'>))</span> <span class='Operator'>!= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_control.h.html#LN102"><span class='Ref_to_Struct'>ControlFileData</span></a><span class='Parentheses'>))</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not read from control file: %m"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/pgstat.h.html#LN1230"><span class='Ref_to_Func'>pgstat_report_wait_end</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <a href="../../../interfaces/libpq/win32.h.html#LN11"><span class='Ref_to_Macro'>close</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4463"><span class='Ref_To_Local'>fd</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Check for expected pg_control format version.  If this is wrong, the 
     * CRC check will likely fail because we'll be checking the wrong number 
     * of bytes.  Complaining about wrong version will probably be more 
     * enlightening than complaining about wrong CRC. 
     */ 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN123"><span class='Ref_to_Member'>pg_control_version</span></a> <span class='Operator'>!= </span><a href="../../../include/catalog/pg_control.h.html#LN25"><span class='Ref_to_Const'>PG_CONTROL_VERSION</span></a> <span class='Operator'>&& </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN123"><span class='Ref_to_Member'>pg_control_version</span></a> <span class='Operator'>% </span><span class='Number'>65536</span> <span class='Operator'>== </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN123"><span class='Ref_to_Member'>pg_control_version</span></a> <span class='Operator'>/ </span><span class='Number'>65536</span> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"database files are incompatible with server"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"The database cluster was initialized with PG_CONTROL_VERSION %d (0x%08x),"</span> 
         <span class='String'>" but the server was compiled with PG_CONTROL_VERSION %d (0x%08x)."</span><span class='Delimiter'>, 
</span>            <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN123"><span class='Ref_to_Member'>pg_control_version</span></a><span class='Delimiter'>, </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN123"><span class='Ref_to_Member'>pg_control_version</span></a><span class='Delimiter'>, 
</span>                           <a href="../../../include/catalog/pg_control.h.html#LN25"><span class='Ref_to_Const'>PG_CONTROL_VERSION</span></a><span class='Delimiter'>, </span><a href="../../../include/catalog/pg_control.h.html#LN25"><span class='Ref_to_Const'>PG_CONTROL_VERSION</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"This could be a problem of mismatched byte ordering.  It looks like you need to initdb."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN123"><span class='Ref_to_Member'>pg_control_version</span></a> <span class='Operator'>!= </span><a href="../../../include/catalog/pg_control.h.html#LN25"><span class='Ref_to_Const'>PG_CONTROL_VERSION</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"database files are incompatible with server"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"The database cluster was initialized with PG_CONTROL_VERSION %d,"</span> 
                  <span class='String'>" but the server was compiled with PG_CONTROL_VERSION %d."</span><span class='Delimiter'>, 
</span>                        <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN123"><span class='Ref_to_Member'>pg_control_version</span></a><span class='Delimiter'>, </span><a href="../../../include/catalog/pg_control.h.html#LN25"><span class='Ref_to_Const'>PG_CONTROL_VERSION</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"It looks like you need to initdb."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Now check the CRC. */ 
</span>    <a href="../../../include/port/pg_crc32c.h.html#LN40"><span class='Ref_to_Macro'>INIT_CRC32C</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4462"><span class='Ref_To_Local'>crc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/port/pg_crc32c.h.html#LN45"><span class='Ref_to_Macro'>COMP_CRC32C</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4462"><span class='Ref_To_Local'>crc</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Delimiter'>, 
</span>                <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_control.h.html#LN102"><span class='Ref_to_Struct'>ControlFileData</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN4462"><span class='Ref_To_Local'>crc</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/port/pg_crc32c.h.html#LN47"><span class='Ref_to_Macro'>FIN_CRC32C</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4462"><span class='Ref_To_Local'>crc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/port/pg_crc32c.h.html#LN41"><span class='Ref_to_Macro'>EQ_CRC32C</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4462"><span class='Ref_To_Local'>crc</span></a><span class='Delimiter'>, </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN234"><span class='Ref_to_Member'>crc</span></a><span class='Parentheses'>))</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"incorrect checksum in control file"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Do compatibility checking immediately.  If the database isn't 
     * compatible with the backend executable, we want to abort before we can 
     * possibly do any damage. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN124"><span class='Ref_to_Member'>catalog_version_no</span></a> <span class='Operator'>!= </span><a href="../../../include/catalog/catversion.h.html#LN55"><span class='Ref_to_Const'>CATALOG_VERSION_NO</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"database files are incompatible with server"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"The database cluster was initialized with CATALOG_VERSION_NO %d,"</span> 
                  <span class='String'>" but the server was compiled with CATALOG_VERSION_NO %d."</span><span class='Delimiter'>, 
</span>                        <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN124"><span class='Ref_to_Member'>catalog_version_no</span></a><span class='Delimiter'>, </span><a href="../../../include/catalog/catversion.h.html#LN55"><span class='Ref_to_Const'>CATALOG_VERSION_NO</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"It looks like you need to initdb."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN199"><span class='Ref_to_Member'>maxAlign</span></a> <span class='Operator'>!= </span>MAXIMUM_ALIGNOF<span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"database files are incompatible with server"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>           <a href="../../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"The database cluster was initialized with MAXALIGN %d,"</span> 
                     <span class='String'>" but the server was compiled with MAXALIGN %d."</span><span class='Delimiter'>, 
</span>                     <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN199"><span class='Ref_to_Member'>maxAlign</span></a><span class='Delimiter'>, </span>MAXIMUM_ALIGNOF<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"It looks like you need to initdb."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN200"><span class='Ref_to_Member'>floatFormat</span></a> <span class='Operator'>!= </span><a href="../../../include/catalog/pg_control.h.html#LN201"><span class='Ref_to_Const'>FLOATFORMAT_VALUE</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"database files are incompatible with server"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"The database cluster appears to use a different floating-point number format than the server executable."</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"It looks like you need to initdb."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN207"><span class='Ref_to_Member'>blcksz</span></a> <span class='Operator'>!= </span>BLCKSZ<span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"database files are incompatible with server"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>             <a href="../../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"The database cluster was initialized with BLCKSZ %d,"</span> 
                       <span class='String'>" but the server was compiled with BLCKSZ %d."</span><span class='Delimiter'>, 
</span>                       <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN207"><span class='Ref_to_Member'>blcksz</span></a><span class='Delimiter'>, </span>BLCKSZ<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"It looks like you need to recompile or initdb."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN208"><span class='Ref_to_Member'>relseg_size</span></a> <span class='Operator'>!= </span>RELSEG_SIZE<span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"database files are incompatible with server"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>        <a href="../../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"The database cluster was initialized with RELSEG_SIZE %d,"</span> 
                  <span class='String'>" but the server was compiled with RELSEG_SIZE %d."</span><span class='Delimiter'>, 
</span>                  <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN208"><span class='Ref_to_Member'>relseg_size</span></a><span class='Delimiter'>, </span>RELSEG_SIZE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"It looks like you need to recompile or initdb."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN210"><span class='Ref_to_Member'>xlog_blcksz</span></a> <span class='Operator'>!= </span>XLOG_BLCKSZ<span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"database files are incompatible with server"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>        <a href="../../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"The database cluster was initialized with XLOG_BLCKSZ %d,"</span> 
                  <span class='String'>" but the server was compiled with XLOG_BLCKSZ %d."</span><span class='Delimiter'>, 
</span>                  <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN210"><span class='Ref_to_Member'>xlog_blcksz</span></a><span class='Delimiter'>, </span>XLOG_BLCKSZ<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"It looks like you need to recompile or initdb."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN211"><span class='Ref_to_Member'>xlog_seg_size</span></a> <span class='Operator'>!= </span>XLOG_SEG_SIZE<span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"database files are incompatible with server"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"The database cluster was initialized with XLOG_SEG_SIZE %d,"</span> 
                       <span class='String'>" but the server was compiled with XLOG_SEG_SIZE %d."</span><span class='Delimiter'>, 
</span>                           <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN211"><span class='Ref_to_Member'>xlog_seg_size</span></a><span class='Delimiter'>, </span>XLOG_SEG_SIZE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"It looks like you need to recompile or initdb."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN213"><span class='Ref_to_Member'>nameDataLen</span></a> <span class='Operator'>!= </span><a href="../../../interfaces/ecpg/include/sqlda-native.h.html#LN15"><span class='Ref_to_Const'>NAMEDATALEN</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"database files are incompatible with server"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>        <a href="../../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"The database cluster was initialized with NAMEDATALEN %d,"</span> 
                  <span class='String'>" but the server was compiled with NAMEDATALEN %d."</span><span class='Delimiter'>, 
</span>                  <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN213"><span class='Ref_to_Member'>nameDataLen</span></a><span class='Delimiter'>, </span><a href="../../../interfaces/ecpg/include/sqlda-native.h.html#LN15"><span class='Ref_to_Const'>NAMEDATALEN</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"It looks like you need to recompile or initdb."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN214"><span class='Ref_to_Member'>indexMaxKeys</span></a> <span class='Operator'>!= </span><a href="../../../include/pg_config_manual.h.html#LN45"><span class='Ref_to_Const'>INDEX_MAX_KEYS</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"database files are incompatible with server"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"The database cluster was initialized with INDEX_MAX_KEYS %d,"</span> 
                      <span class='String'>" but the server was compiled with INDEX_MAX_KEYS %d."</span><span class='Delimiter'>, 
</span>                           <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN214"><span class='Ref_to_Member'>indexMaxKeys</span></a><span class='Delimiter'>, </span><a href="../../../include/pg_config_manual.h.html#LN45"><span class='Ref_to_Const'>INDEX_MAX_KEYS</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"It looks like you need to recompile or initdb."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN216"><span class='Ref_to_Member'>toast_max_chunk_size</span></a> <span class='Operator'>!= </span><a href="../../../include/access/tuptoaster.h.html#LN90"><span class='Ref_to_Const'>TOAST_MAX_CHUNK_SIZE</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"database files are incompatible with server"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"The database cluster was initialized with TOAST_MAX_CHUNK_SIZE %d,"</span> 
                <span class='String'>" but the server was compiled with TOAST_MAX_CHUNK_SIZE %d."</span><span class='Delimiter'>, 
</span>              <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN216"><span class='Ref_to_Member'>toast_max_chunk_size</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="../../../include/access/tuptoaster.h.html#LN90"><span class='Ref_to_Const'>TOAST_MAX_CHUNK_SIZE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"It looks like you need to recompile or initdb."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN217"><span class='Ref_to_Member'>loblksize</span></a> <span class='Operator'>!= </span><a href="../../../include/storage/large_object.h.html#LN71"><span class='Ref_to_Const'>LOBLKSIZE</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"database files are incompatible with server"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>          <a href="../../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"The database cluster was initialized with LOBLKSIZE %d,"</span> 
                    <span class='String'>" but the server was compiled with LOBLKSIZE %d."</span><span class='Delimiter'>, 
</span>                    <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN217"><span class='Ref_to_Member'>loblksize</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="../../../include/storage/large_object.h.html#LN71"><span class='Ref_to_Const'>LOBLKSIZE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"It looks like you need to recompile or initdb."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifdef</span> USE_FLOAT4_BYVAL 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN220"><span class='Ref_to_Member'>float4ByVal</span></a> <span class='Operator'>!= </span><span class='Boolean'>true</span><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"database files are incompatible with server"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"The database cluster was initialized without USE_FLOAT4_BYVAL"</span> 
                      <span class='String'>" but the server was compiled with USE_FLOAT4_BYVAL."</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"It looks like you need to recompile or initdb."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span><span class='Directive'>#else</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN220"><span class='Ref_to_Member'>float4ByVal</span></a> <span class='Operator'>!= </span><span class='Boolean'>false</span><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"database files are incompatible with server"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>        <a href="../../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"The database cluster was initialized with USE_FLOAT4_BYVAL"</span> 
                  <span class='String'>" but the server was compiled without USE_FLOAT4_BYVAL."</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"It looks like you need to recompile or initdb."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
<span class='Directive'>#ifdef</span> USE_FLOAT8_BYVAL 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN221"><span class='Ref_to_Member'>float8ByVal</span></a> <span class='Operator'>!= </span><span class='Boolean'>true</span><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"database files are incompatible with server"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"The database cluster was initialized without USE_FLOAT8_BYVAL"</span> 
                      <span class='String'>" but the server was compiled with USE_FLOAT8_BYVAL."</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"It looks like you need to recompile or initdb."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span><span class='Directive'>#else</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN221"><span class='Ref_to_Member'>float8ByVal</span></a> <span class='Operator'>!= </span><span class='Boolean'>false</span><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"database files are incompatible with server"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>        <a href="../../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"The database cluster was initialized with USE_FLOAT8_BYVAL"</span> 
                  <span class='String'>" but the server was compiled without USE_FLOAT8_BYVAL."</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"It looks like you need to recompile or initdb."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
    <span class='Comment_Multi_Line'>/* Make the initdb settings visible as GUC variables, too */ 
</span>    <a href="../../../include/utils/guc.h.html#LN276"><span class='Ref_to_Proto'>SetConfigOption</span></a><span class='Parentheses'>(</span><span class='String'>"data_checksums"</span><span class='Delimiter'>, </span><a href="../../../include/access/xlog.h.html#LN259"><span class='Ref_to_Proto'>DataChecksumsEnabled</span></a><span class='Parentheses'>() </span><span class='Operator'>? </span><span class='String'>"yes"</span> <span class='Operator'>: </span><span class='String'>"no"</span><span class='Delimiter'>, 
</span>                    <a href="../../../include/utils/guc.h.html#LN69"><span class='Ref_to_EnumConst'>PGC_INTERNAL</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/guc.h.html#LN116"><span class='Ref_to_EnumConst'>PGC_S_OVERRIDE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ReadControlFile &raquo; </span> 
 
<span class='Keyword'>void 
</span><a name="LN4640"></a><span class='Declare_Function'>UpdateControlFile</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4642"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>fd</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/port/pg_crc32c.h.html#LN40"><span class='Ref_to_Macro'>INIT_CRC32C</span></a><span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN234"><span class='Ref_to_Member'>crc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/port/pg_crc32c.h.html#LN45"><span class='Ref_to_Macro'>COMP_CRC32C</span></a><span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN234"><span class='Ref_to_Member'>crc</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Delimiter'>, 
</span>                <a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_control.h.html#LN102"><span class='Ref_to_Struct'>ControlFileData</span></a><span class='Delimiter'>, </span>crc<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/port/pg_crc32c.h.html#LN47"><span class='Ref_to_Macro'>FIN_CRC32C</span></a><span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN234"><span class='Ref_to_Member'>crc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="xlog.c.html#LN4642"><span class='Ref_To_Local'>fd</span></a> <span class='Operator'>= </span><a href="../../../include/storage/fd.h.html#LN100"><span class='Ref_to_Proto'>BasicOpenFile</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlog_internal.h.html#LN131"><span class='Ref_to_Const'>XLOG_CONTROL_FILE</span></a><span class='Delimiter'>, 
</span>                       O_RDWR <span class='Operator'>| </span><a href="../../../include/c.h.html#LN1032"><span class='Ref_to_Const'>PG_BINARY</span></a><span class='Delimiter'>, 
</span>                       <a href="../../../include/port/win32.h.html#LN424"><span class='Ref_to_Const'>S_IRUSR</span></a> <span class='Operator'>| </span><a href="../../../include/port/win32.h.html#LN425"><span class='Ref_to_Const'>S_IWUSR</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN4642"><span class='Ref_To_Local'>fd</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not open control file \"%s\": %m"</span><span class='Delimiter'>, 
</span>                        <a href="../../../include/access/xlog_internal.h.html#LN131"><span class='Ref_to_Const'>XLOG_CONTROL_FILE</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    errno <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="../../../include/pgstat.h.html#LN1206"><span class='Ref_to_Func'>pgstat_report_wait_start</span></a><span class='Parentheses'>(</span><a href="../../../include/pgstat.h.html#LN844"><span class='Ref_to_EnumConst'>WAIT_EVENT_CONTROL_FILE_WRITE_UPDATE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../interfaces/libpq/win32.h.html#LN13"><span class='Ref_to_Macro'>write</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4642"><span class='Ref_To_Local'>fd</span></a><span class='Delimiter'>, </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_control.h.html#LN102"><span class='Ref_to_Struct'>ControlFileData</span></a><span class='Parentheses'>))</span> <span class='Operator'>!= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_control.h.html#LN102"><span class='Ref_to_Struct'>ControlFileData</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* if write didn't set errno, assume problem is no disk space */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span>errno <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            errno <span class='Operator'>= </span>ENOSPC<span class='Delimiter'>; 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not write to control file: %m"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="../../../include/pgstat.h.html#LN1230"><span class='Ref_to_Func'>pgstat_report_wait_end</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/pgstat.h.html#LN1206"><span class='Ref_to_Func'>pgstat_report_wait_start</span></a><span class='Parentheses'>(</span><a href="../../../include/pgstat.h.html#LN842"><span class='Ref_to_EnumConst'>WAIT_EVENT_CONTROL_FILE_SYNC_UPDATE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/fd.h.html#LN114"><span class='Ref_to_Proto'>pg_fsync</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4642"><span class='Ref_To_Local'>fd</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not fsync control file: %m"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/pgstat.h.html#LN1230"><span class='Ref_to_Func'>pgstat_report_wait_end</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../interfaces/libpq/win32.h.html#LN11"><span class='Ref_to_Macro'>close</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4642"><span class='Ref_To_Local'>fd</span></a><span class='Parentheses'>))</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not close control file: %m"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end UpdateControlFile &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Returns the unique system identifier from control file. 
 */ 
</span><a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a> 
<a name="LN4689"></a><span class='Declare_Function'>GetSystemIdentifier</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN108"><span class='Ref_to_Member'>system_identifier</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Returns the random nonce from control file. 
 */ 
</span><span class='Keyword'>char </span><span class='Operator'>* 
</span><a name="LN4699"></a><span class='Declare_Function'>GetMockAuthenticationNonce</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN231"><span class='Ref_to_Member'>mock_authentication_nonce</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Are checksums enabled for data pages? 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN4709"></a><span class='Declare_Function'>DataChecksumsEnabled</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN224"><span class='Ref_to_Member'>data_checksum_version</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Returns a fake LSN for unlogged relations. 
 * 
 * Each call generates an LSN that is greater than any previous value 
 * returned. The current counter value is saved and restored across clean 
 * shutdowns, but like unlogged relations, does not survive a crash. This can 
 * be used in lieu of real LSN values returned by XLogInsert, if you need an 
 * LSN-like increasing sequence of numbers without writing any WAL. 
 */ 
</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> 
<a name="LN4725"></a><span class='Declare_Function'>GetFakeLSNForUnloggedRel</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4727"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>nextUnloggedLSN</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* increment the unloggedLSN counter, need SpinLock */ 
</span>    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN589"><span class='Ref_to_Member'>ulsn_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN4727"><span class='Ref_To_Local'>nextUnloggedLSN</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN588"><span class='Ref_to_Member'>unloggedLSN</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN589"><span class='Ref_to_Member'>ulsn_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="xlog.c.html#LN4727"><span class='Ref_To_Local'>nextUnloggedLSN</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Auto-tune the number of XLOG buffers. 
 * 
 * The preferred setting for wal_buffers is about 3% of shared_buffers, with 
 * a maximum of one XLOG segment (there is little reason to think that more 
 * is helpful, at least so long as we force an fsync when switching log files) 
 * and a minimum of 8 blocks (which was the default value prior to PostgreSQL 
 * 9.1, when auto-tuning was added). 
 * 
 * This should not be called until NBuffers has received its final value. 
 */ 
</span><span class='Keyword'>static int 
</span><a name="LN4749"></a><span class='Declare_Function'>XLOGChooseNumBuffers</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4751"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>xbuffers</span><span class='Delimiter'>; 
</span> 
    <a href="xlog.c.html#LN4751"><span class='Ref_To_Local'>xbuffers</span></a> <span class='Operator'>= </span><a href="../../utils/init/globals.c.html#LN122"><span class='Ref_to_Global_Var'>NBuffers</span></a> <span class='Operator'>/ </span><span class='Number'>32</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN4751"><span class='Ref_To_Local'>xbuffers</span></a> <span class='Operator'>&GT; </span>XLOG_SEG_SIZE <span class='Operator'>/ </span>XLOG_BLCKSZ<span class='Parentheses'>) 
</span>        <a href="xlog.c.html#LN4751"><span class='Ref_To_Local'>xbuffers</span></a> <span class='Operator'>= </span>XLOG_SEG_SIZE <span class='Operator'>/ </span>XLOG_BLCKSZ<span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN4751"><span class='Ref_To_Local'>xbuffers</span></a> <span class='Operator'>&LT; </span><span class='Number'>8</span><span class='Parentheses'>) 
</span>        <a href="xlog.c.html#LN4751"><span class='Ref_To_Local'>xbuffers</span></a> <span class='Operator'>= </span><span class='Number'>8</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="xlog.c.html#LN4751"><span class='Ref_To_Local'>xbuffers</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * GUC check_hook for wal_buffers 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN4765"></a><span class='Declare_Function'>check_wal_buffers</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Operator'>*</span><span class='Declare_Parameter'>newval</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>**</span><span class='Declare_Parameter'>extra</span><span class='Delimiter'>, </span><a href="../../../include/utils/guc.h.html#LN104"><span class='Ref_to_Typedef'>GucSource</span></a> <span class='Declare_Parameter'>source</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * -1 indicates a request for auto-tune. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="xlog.c.html#LN4765"><span class='Ref_to_Parameter'>newval</span></a> <span class='Operator'>== -</span><span class='Number'>1</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * If we haven't yet changed the boot_val default of -1, just let it 
         * be.  We'll fix it when XLOGShmemSize is called. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN91"><span class='Ref_to_Global_Var'>XLOGbuffers</span></a> <span class='Operator'>== -</span><span class='Number'>1</span><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Otherwise, substitute the auto-tune value */ 
</span>        <span class='Operator'>*</span><a href="xlog.c.html#LN4765"><span class='Ref_to_Parameter'>newval</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN4748"><span class='Ref_to_Func'>XLOGChooseNumBuffers</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We clamp manually-set values to at least 4 blocks.  Prior to PostgreSQL 
     * 9.1, a minimum of 4 was enforced by guc.c, but since that is no longer 
     * the case, we just silently treat such values as a request for the 
     * minimum.  (We could throw an error instead, but that doesn't seem very 
     * helpful.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="xlog.c.html#LN4765"><span class='Ref_to_Parameter'>newval</span></a> <span class='Operator'>&LT; </span><span class='Number'>4</span><span class='Parentheses'>) 
</span>        <span class='Operator'>*</span><a href="xlog.c.html#LN4765"><span class='Ref_to_Parameter'>newval</span></a> <span class='Operator'>= </span><span class='Number'>4</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end check_wal_buffers &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Initialization of shared memory for XLOG 
 */ 
</span><a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a> 
<a name="LN4800"></a><span class='Declare_Function'>XLOGShmemSize</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4802"></a>    <a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a>        <span class='Declare_Local'>size</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the value of wal_buffers is -1, use the preferred auto-tune value. 
     * This isn't an amazingly clean place to do this, but we must wait till 
     * NBuffers has received its final value, and must do it before using the 
     * value of XLOGbuffers to do anything important. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN91"><span class='Ref_to_Global_Var'>XLOGbuffers</span></a> <span class='Operator'>== -</span><span class='Number'>1</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN4812"></a>        <span class='Keyword'>char</span>        <span class='Declare_Local'>buf</span><span class='Delimiter'>[</span><span class='Number'>32</span><span class='Delimiter'>]; 
</span> 
        <a href="../../../pl/plperl/plperl.h.html#LN60"><span class='Ref_to_Macro'>snprintf</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4812"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN4812"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='String'>"%d"</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN4748"><span class='Ref_to_Func'>XLOGChooseNumBuffers</span></a><span class='Parentheses'>())</span><span class='Delimiter'>; 
</span>        <a href="../../../include/utils/guc.h.html#LN276"><span class='Ref_to_Proto'>SetConfigOption</span></a><span class='Parentheses'>(</span><span class='String'>"wal_buffers"</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN4812"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/guc.h.html#LN70"><span class='Ref_to_EnumConst'>PGC_POSTMASTER</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/guc.h.html#LN116"><span class='Ref_to_EnumConst'>PGC_S_OVERRIDE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN91"><span class='Ref_to_Global_Var'>XLOGbuffers</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* XLogCtl */ 
</span>    <a href="xlog.c.html#LN4802"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN572"><span class='Ref_to_Struct'>XLogCtlData</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* WAL insertion locks, plus alignment */ 
</span>    <a href="xlog.c.html#LN4802"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>= </span><a href="../../../include/storage/shmem.h.html#LN44"><span class='Ref_to_Proto'>add_size</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4802"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/shmem.h.html#LN45"><span class='Ref_to_Proto'>mul_size</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN476"><span class='Ref_to_Union'>WALInsertLockPadded</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN117"><span class='Ref_to_Const'>NUM_XLOGINSERT_LOCKS</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* xlblocks array */ 
</span>    <a href="xlog.c.html#LN4802"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>= </span><a href="../../../include/storage/shmem.h.html#LN44"><span class='Ref_to_Proto'>add_size</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4802"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/shmem.h.html#LN45"><span class='Ref_to_Proto'>mul_size</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN91"><span class='Ref_to_Global_Var'>XLOGbuffers</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* extra alignment padding for XLOG I/O buffers */ 
</span>    <a href="xlog.c.html#LN4802"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>= </span><a href="../../../include/storage/shmem.h.html#LN44"><span class='Ref_to_Proto'>add_size</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4802"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>, </span>XLOG_BLCKSZ<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* and the buffers themselves */ 
</span>    <a href="xlog.c.html#LN4802"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>= </span><a href="../../../include/storage/shmem.h.html#LN44"><span class='Ref_to_Proto'>add_size</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4802"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/shmem.h.html#LN45"><span class='Ref_to_Proto'>mul_size</span></a><span class='Parentheses'>(</span>XLOG_BLCKSZ<span class='Delimiter'>, </span><a href="xlog.c.html#LN91"><span class='Ref_to_Global_Var'>XLOGbuffers</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Note: we don't count ControlFileData, it comes out of the "slop factor" 
     * added by CreateSharedMemoryAndSemaphores.  This lets us use this 
     * routine again below to compute the actual allocation size. 
     */ 
</span> 
    <span class='Control'>return</span> <a href="xlog.c.html#LN4802"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end XLOGShmemSize &raquo; </span> 
 
<span class='Keyword'>void 
</span><a name="LN4841"></a><span class='Declare_Function'>XLOGShmemInit</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4843"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>foundCFile</span><span class='Delimiter'>, 
</span><a name="LN4844"></a>                <span class='Declare_Local'>foundXLog</span><span class='Delimiter'>; 
</span><a name="LN4845"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>allocptr</span><span class='Delimiter'>; 
</span><a name="LN4846"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifdef</span> WAL_DEBUG 
 
    <span class='Comment_Multi_Line'>/* 
     * Create a memory context for WAL debugging that's exempt from the normal 
     * "no pallocs in critical section" rule. Yes, that can lead to a PANIC if 
     * an allocation fails, but wal_debug is not for production use anyway. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN842"><span class='Ref_to_Global_Var'>walDebugCxt</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="xlog.c.html#LN842"><span class='Ref_to_Global_Var'>walDebugCxt</span></a> <span class='Operator'>= </span><a href="../../../include/utils/memutils.h.html#LN145"><span class='Ref_to_Proto'>AllocSetContextCreate</span></a><span class='Parentheses'>(</span><a href="../../utils/mmgr/mcxt.c.html#LN42"><span class='Ref_to_Global_Var'>TopMemoryContext</span></a><span class='Delimiter'>, 
</span>                                            <span class='String'>"WAL Debug"</span><span class='Delimiter'>, 
</span>                                            <a href="../../../include/utils/memutils.h.html#LN164"><span class='Ref_to_Const'>ALLOCSET_DEFAULT_SIZES</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/utils/memutils.h.html#LN85"><span class='Ref_to_Proto'>MemoryContextAllowInCriticalSection</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN842"><span class='Ref_to_Global_Var'>walDebugCxt</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span><span class='Directive'>#endif</span> 
 
    <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_control.h.html#LN102"><span class='Ref_to_Struct'>ControlFileData</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/shmem.h.html#LN43"><span class='Ref_to_Proto'>ShmemInitStruct</span></a><span class='Parentheses'>(</span><span class='String'>"Control File"</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_control.h.html#LN102"><span class='Ref_to_Struct'>ControlFileData</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN4843"><span class='Ref_To_Local'>foundCFile</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="xlog.c.html#LN572"><span class='Ref_to_Struct'>XLogCtlData</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/shmem.h.html#LN43"><span class='Ref_to_Proto'>ShmemInitStruct</span></a><span class='Parentheses'>(</span><span class='String'>"XLOG Ctl"</span><span class='Delimiter'>, </span><a href="../../../include/access/xlog.h.html#LN261"><span class='Ref_to_Proto'>XLOGShmemSize</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN4844"><span class='Ref_To_Local'>foundXLog</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN4843"><span class='Ref_To_Local'>foundCFile</span></a> <span class='Operator'>|| </span><a href="xlog.c.html#LN4844"><span class='Ref_To_Local'>foundXLog</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* both should be present or neither */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN4843"><span class='Ref_To_Local'>foundCFile</span></a> <span class='Operator'>&& </span><a href="xlog.c.html#LN4844"><span class='Ref_To_Local'>foundXLog</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Initialize local copy of WALInsertLocks and register the tranche */ 
</span>        <a href="xlog.c.html#LN708"><span class='Ref_to_Global_Var'>WALInsertLocks</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN574"><span class='Ref_to_Member'>Insert</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN566"><span class='Ref_to_Member'>WALInsertLocks</span></a><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/lwlock.h.html#LN186"><span class='Ref_to_Proto'>LWLockRegisterTranche</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN204"><span class='Ref_to_EnumConst'>LWTRANCHE_WAL_INSERT</span></a><span class='Delimiter'>, 
</span>                              <span class='String'>"wal_insert"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    memset<span class='Parentheses'>(</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN572"><span class='Ref_to_Struct'>XLogCtlData</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Since XLogCtlData contains XLogRecPtr fields, its sizeof should be a 
     * multiple of the alignment for same, so no extra alignment padding is 
     * needed here. 
     */ 
</span>    <a href="xlog.c.html#LN4845"><span class='Ref_To_Local'>allocptr</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Parentheses'>)</span> <span class='Operator'>+ </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN572"><span class='Ref_to_Struct'>XLogCtlData</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN619"><span class='Ref_to_Member'>xlblocks</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="xlog.c.html#LN4845"><span class='Ref_To_Local'>allocptr</span></a><span class='Delimiter'>; 
</span>    memset<span class='Parentheses'>(</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN619"><span class='Ref_to_Member'>xlblocks</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="xlog.c.html#LN91"><span class='Ref_to_Global_Var'>XLOGbuffers</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN4845"><span class='Ref_To_Local'>allocptr</span></a> <span class='Operator'>+= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="xlog.c.html#LN91"><span class='Ref_to_Global_Var'>XLOGbuffers</span></a><span class='Delimiter'>; 
</span> 
 
    <span class='Comment_Multi_Line'>/* WAL insertion locks. Ensure they're aligned to the full padded size */ 
</span>    <a href="xlog.c.html#LN4845"><span class='Ref_To_Local'>allocptr</span></a> <span class='Operator'>+= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN476"><span class='Ref_to_Union'>WALInsertLockPadded</span></a><span class='Parentheses'>) </span><span class='Operator'>- 
</span>        <span class='Parentheses'>((</span>uintptr_t<span class='Parentheses'>) </span><a href="xlog.c.html#LN4845"><span class='Ref_To_Local'>allocptr</span></a><span class='Parentheses'>)</span> <span class='Operator'>%</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN476"><span class='Ref_to_Union'>WALInsertLockPadded</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN708"><span class='Ref_to_Global_Var'>WALInsertLocks</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN574"><span class='Ref_to_Member'>Insert</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN566"><span class='Ref_to_Member'>WALInsertLocks</span></a> <span class='Operator'>= 
</span>        <span class='Parentheses'>(</span><a href="xlog.c.html#LN476"><span class='Ref_to_Union'>WALInsertLockPadded</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="xlog.c.html#LN4845"><span class='Ref_To_Local'>allocptr</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN4845"><span class='Ref_To_Local'>allocptr</span></a> <span class='Operator'>+= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN476"><span class='Ref_to_Union'>WALInsertLockPadded</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="xlog.c.html#LN117"><span class='Ref_to_Const'>NUM_XLOGINSERT_LOCKS</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN186"><span class='Ref_to_Proto'>LWLockRegisterTranche</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/lwlock.h.html#LN204"><span class='Ref_to_EnumConst'>LWTRANCHE_WAL_INSERT</span></a><span class='Delimiter'>, </span><span class='String'>"wal_insert"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN4846"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="xlog.c.html#LN4846"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN117"><span class='Ref_to_Const'>NUM_XLOGINSERT_LOCKS</span></a><span class='Delimiter'>; </span><a href="xlog.c.html#LN4846"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/storage/lwlock.h.html#LN187"><span class='Ref_to_Proto'>LWLockInitialize</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN708"><span class='Ref_to_Global_Var'>WALInsertLocks</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN4846"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="xlog.c.html#LN478"><span class='Ref_to_Member'>l</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN464"><span class='Ref_to_Member'>lock</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN204"><span class='Ref_to_EnumConst'>LWTRANCHE_WAL_INSERT</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN708"><span class='Ref_to_Global_Var'>WALInsertLocks</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN4846"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="xlog.c.html#LN478"><span class='Ref_to_Member'>l</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN465"><span class='Ref_to_Member'>insertingAt</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN708"><span class='Ref_to_Global_Var'>WALInsertLocks</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN4846"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="xlog.c.html#LN478"><span class='Ref_to_Member'>l</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN466"><span class='Ref_to_Member'>lastImportantAt</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Align the start of the page buffers to a full xlog block size boundary. 
     * This simplifies some calculations in XLOG insertion. It is also 
     * required for O_DIRECT. 
     */ 
</span>    <a href="xlog.c.html#LN4845"><span class='Ref_To_Local'>allocptr</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/c.h.html#LN580"><span class='Ref_to_Macro'>TYPEALIGN</span></a><span class='Parentheses'>(</span>XLOG_BLCKSZ<span class='Delimiter'>, </span><a href="xlog.c.html#LN4845"><span class='Ref_To_Local'>allocptr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN618"><span class='Ref_to_Member'>pages</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN4845"><span class='Ref_To_Local'>allocptr</span></a><span class='Delimiter'>; 
</span>    memset<span class='Parentheses'>(</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN618"><span class='Ref_to_Member'>pages</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a><span class='Parentheses'>) </span>XLOG_BLCKSZ <span class='Operator'>* </span><a href="xlog.c.html#LN91"><span class='Ref_to_Global_Var'>XLOGbuffers</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Do basic initialization of XLogCtl shared data. (StartupXLOG will fill 
     * in additional info.) 
     */ 
</span>    <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN620"><span class='Ref_to_Member'>XLogCacheBlck</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN91"><span class='Ref_to_Global_Var'>XLOGbuffers</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN641"><span class='Ref_to_Member'>SharedRecoveryInProgress</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN647"><span class='Ref_to_Member'>SharedHotStandbyActive</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN654"><span class='Ref_to_Member'>WalWriterSleeping</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/spin.h.html#LN59"><span class='Ref_to_Macro'>SpinLockInit</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN574"><span class='Ref_to_Member'>Insert</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN516"><span class='Ref_to_Member'>insertpos_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/spin.h.html#LN59"><span class='Ref_to_Macro'>SpinLockInit</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/spin.h.html#LN59"><span class='Ref_to_Macro'>SpinLockInit</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN589"><span class='Ref_to_Member'>ulsn_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/latch.h.html#LN148"><span class='Ref_to_Proto'>InitSharedLatch</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN661"><span class='Ref_to_Member'>recoveryWakeupLatch</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we are not in bootstrap mode, pg_control should already exist. Read 
     * and validate it immediately (see comments in ReadControlFile() for the 
     * reasons why). 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/miscadmin.h.html#LN369"><span class='Ref_to_Macro'>IsBootstrapProcessingMode</span></a><span class='Parentheses'>())</span> 
        <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN74"><span class='Ref_to_Proto'>ReadControlFile</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end XLOGShmemInit &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * This func must be called ONCE on system install.  It creates pg_control 
 * and the initial XLOG segment. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN4945"></a><span class='Declare_Function'>BootStrapXLOG</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4947"></a>    <a href="../../../include/catalog/pg_control.h.html#LN32"><span class='Ref_to_Struct'>CheckPoint</span></a>  <span class='Declare_Local'>checkPoint</span><span class='Delimiter'>; 
</span><a name="LN4948"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>buffer</span><span class='Delimiter'>; 
</span><a name="LN4949"></a>    <a href="../../../include/access/xlog_internal.h.html#LN56"><span class='Ref_to_Typedef'>XLogPageHeader</span></a> <span class='Declare_Local'>page</span><span class='Delimiter'>; 
</span><a name="LN4950"></a>    <a href="../../../include/access/xlog_internal.h.html#LN73"><span class='Ref_to_Typedef'>XLogLongPageHeader</span></a> <span class='Declare_Local'>longpage</span><span class='Delimiter'>; 
</span><a name="LN4951"></a>    <a href="../../../include/access/xlogrecord.h.html#LN40"><span class='Ref_to_Struct'>XLogRecord</span></a> <span class='Operator'>*</span><span class='Declare_Local'>record</span><span class='Delimiter'>; 
</span><a name="LN4952"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>recptr</span><span class='Delimiter'>; 
</span><a name="LN4953"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>use_existent</span><span class='Delimiter'>; 
</span><a name="LN4954"></a>    <a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a>      <span class='Declare_Local'>sysidentifier</span><span class='Delimiter'>; 
</span><a name="LN4955"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>mock_auth_nonce</span><span class='Delimiter'>[</span><a href="../../../include/catalog/pg_control.h.html#LN22"><span class='Ref_to_Const'>MOCK_AUTH_NONCE_LEN</span></a><span class='Delimiter'>]; 
</span><a name="LN4956"></a>    <span class='Control'>struct</span> timeval <span class='Declare_Local'>tv</span><span class='Delimiter'>; 
</span><a name="LN4957"></a>    <a href="../../../include/port/pg_crc32c.h.html#LN37"><span class='Ref_to_Typedef'>pg_crc32c</span></a>   <span class='Declare_Local'>crc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Select a hopefully-unique system identifier code for this installation. 
     * We use the result of gettimeofday(), including the fractional seconds 
     * field, as being about as unique as we can easily get.  (Think not to 
     * use random(), since it hasn't been seeded and there's no portable way 
     * to seed it other than the system clock value...)  The upper half of the 
     * uint64 value is just the tv_sec part, while the lower half contains the 
     * tv_usec part (which must fit in 20 bits), plus 12 bits from our current 
     * PID for a little extra uniqueness.  A person knowing this encoding can 
     * determine the initialization time of the installation, which could 
     * perhaps be useful sometimes. 
     */ 
</span>    <a href="../../../port/gettimeofday.c.html#LN103"><span class='Ref_to_Func'>gettimeofday</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN4956"><span class='Ref_To_Local'>tv</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN4954"><span class='Ref_To_Local'>sysidentifier</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN4956"><span class='Ref_To_Local'>tv</span></a><span class='Operator'>.</span>tv_sec<span class='Parentheses'>)</span> <span class='Operator'>&LT;&LT; </span><span class='Number'>32</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN4954"><span class='Ref_To_Local'>sysidentifier</span></a> <span class='Operator'>|= </span><span class='Parentheses'>((</span><a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN4956"><span class='Ref_To_Local'>tv</span></a><span class='Operator'>.</span>tv_usec<span class='Parentheses'>)</span> <span class='Operator'>&LT;&LT; </span><span class='Number'>12</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN4954"><span class='Ref_To_Local'>sysidentifier</span></a> <span class='Operator'>|= </span>getpid<span class='Parentheses'>() </span><span class='Operator'>& </span><span class='Number'>0xFFF</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Generate a random nonce. This is used for authentication requests that 
     * will fail because the user does not exist. The nonce is used to create 
     * a genuine-looking password challenge for the non-existent user, in lieu 
     * of an actual stored password. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/utils/backend_random.h.html#LN16"><span class='Ref_to_Proto'>pg_backend_random</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4955"><span class='Ref_To_Local'>mock_auth_nonce</span></a><span class='Delimiter'>, </span><a href="../../../include/catalog/pg_control.h.html#LN22"><span class='Ref_to_Const'>MOCK_AUTH_NONCE_LEN</span></a><span class='Parentheses'>))</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_INTERNAL_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not generate secret authorization token"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* First timeline ID is always 1 */ 
</span>    <a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* page buffer must be aligned suitably for O_DIRECT */ 
</span>    <a href="xlog.c.html#LN4948"><span class='Ref_To_Local'>buffer</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span>XLOG_BLCKSZ <span class='Operator'>+ </span>XLOG_BLCKSZ<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN4949"><span class='Ref_To_Local'>page</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/xlog_internal.h.html#LN56"><span class='Ref_to_Typedef'>XLogPageHeader</span></a><span class='Parentheses'>) </span><a href="../../../include/c.h.html#LN580"><span class='Ref_to_Macro'>TYPEALIGN</span></a><span class='Parentheses'>(</span>XLOG_BLCKSZ<span class='Delimiter'>, </span><a href="xlog.c.html#LN4948"><span class='Ref_To_Local'>buffer</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    memset<span class='Parentheses'>(</span><a href="xlog.c.html#LN4949"><span class='Ref_To_Local'>page</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span>XLOG_BLCKSZ<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Set up information for the initial checkpoint record 
     * 
     * The initial checkpoint record is written to the beginning of the WAL 
     * segment with logid=0 logseg=1. The very first WAL segment, 0/0, is not 
     * used, so that we can use 0/0 to mean "before any valid WAL segment". 
     */ 
</span>    <a href="xlog.c.html#LN4947"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN34"><span class='Ref_to_Member'>redo</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlog_internal.h.html#LN91"><span class='Ref_to_Const'>XLogSegSize</span></a> <span class='Operator'>+ </span><a href="../../../include/access/xlog_internal.h.html#LN71"><span class='Ref_to_Const'>SizeOfXLogLongPHD</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN4947"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN36"><span class='Ref_to_Member'>ThisTimeLineID</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN4947"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN37"><span class='Ref_to_Member'>PrevTimeLineID</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN4947"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN39"><span class='Ref_to_Member'>fullPageWrites</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN96"><span class='Ref_to_Global_Var'>fullPageWrites</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN4947"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN40"><span class='Ref_to_Member'>nextXidEpoch</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN4947"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN41"><span class='Ref_to_Member'>nextXid</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN33"><span class='Ref_to_Const'>FirstNormalTransactionId</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN4947"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN42"><span class='Ref_to_Member'>nextOid</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN92"><span class='Ref_to_Const'>FirstBootstrapObjectId</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN4947"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN43"><span class='Ref_to_Member'>nextMulti</span></a> <span class='Operator'>= </span><a href="../../../include/access/multixact.h.html#LN23"><span class='Ref_to_Const'>FirstMultiXactId</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN4947"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN44"><span class='Ref_to_Member'>nextMultiOffset</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN4947"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN45"><span class='Ref_to_Member'>oldestXid</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN33"><span class='Ref_to_Const'>FirstNormalTransactionId</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN4947"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN46"><span class='Ref_to_Member'>oldestXidDB</span></a> <span class='Operator'>= </span><a href="../../../include/catalog/pg_database.h.html#LN79"><span class='Ref_to_Const'>TemplateDbOid</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN4947"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN47"><span class='Ref_to_Member'>oldestMulti</span></a> <span class='Operator'>= </span><a href="../../../include/access/multixact.h.html#LN23"><span class='Ref_to_Const'>FirstMultiXactId</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN4947"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN48"><span class='Ref_to_Member'>oldestMultiDB</span></a> <span class='Operator'>= </span><a href="../../../include/catalog/pg_database.h.html#LN79"><span class='Ref_to_Const'>TemplateDbOid</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN4947"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN50"><span class='Ref_to_Member'>oldestCommitTsXid</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN4947"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN52"><span class='Ref_to_Member'>newestCommitTsXid</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN4947"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN49"><span class='Ref_to_Member'>time</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/pgtime.h.html#LN22"><span class='Ref_to_Typedef'>pg_time_t</span></a><span class='Parentheses'>) </span>time<span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN4947"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN61"><span class='Ref_to_Member'>oldestActiveXid</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>; 
</span> 
    <a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN116"><span class='Ref_to_Member'>nextXid</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN4947"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN41"><span class='Ref_to_Member'>nextXid</span></a><span class='Delimiter'>; 
</span>    <a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN110"><span class='Ref_to_Member'>nextOid</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN4947"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN42"><span class='Ref_to_Member'>nextOid</span></a><span class='Delimiter'>; 
</span>    <a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN111"><span class='Ref_to_Member'>oidCount</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="../../../include/access/multixact.h.html#LN139"><span class='Ref_to_Proto'>MultiXactSetNextMXact</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4947"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN43"><span class='Ref_to_Member'>nextMulti</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN4947"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN44"><span class='Ref_to_Member'>nextMultiOffset</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/access/transam.h.html#LN181"><span class='Ref_to_Proto'>AdvanceOldestClogXid</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4947"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN45"><span class='Ref_to_Member'>oldestXid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/access/transam.h.html#LN179"><span class='Ref_to_Proto'>SetTransactionIdLimit</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4947"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN45"><span class='Ref_to_Member'>oldestXid</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN4947"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN46"><span class='Ref_to_Member'>oldestXidDB</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/access/multixact.h.html#LN128"><span class='Ref_to_Proto'>SetMultiXactIdLimit</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4947"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN47"><span class='Ref_to_Member'>oldestMulti</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN4947"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN48"><span class='Ref_to_Member'>oldestMultiDB</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/access/commit_ts.h.html#LN43"><span class='Ref_to_Proto'>SetCommitTsLimit</span></a><span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>, </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Set up the XLOG page header */ 
</span>    <a href="xlog.c.html#LN4949"><span class='Ref_To_Local'>page</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlog_internal.h.html#LN37"><span class='Ref_to_Member'>xlp_magic</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlog_internal.h.html#LN33"><span class='Ref_to_Const'>XLOG_PAGE_MAGIC</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN4949"><span class='Ref_To_Local'>page</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlog_internal.h.html#LN38"><span class='Ref_to_Member'>xlp_info</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlog_internal.h.html#LN78"><span class='Ref_to_Const'>XLP_LONG_HEADER</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN4949"><span class='Ref_To_Local'>page</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlog_internal.h.html#LN39"><span class='Ref_to_Member'>xlp_tli</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN4949"><span class='Ref_To_Local'>page</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlog_internal.h.html#LN40"><span class='Ref_to_Member'>xlp_pageaddr</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlog_internal.h.html#LN91"><span class='Ref_to_Const'>XLogSegSize</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN4950"><span class='Ref_To_Local'>longpage</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/xlog_internal.h.html#LN73"><span class='Ref_to_Typedef'>XLogLongPageHeader</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN4949"><span class='Ref_To_Local'>page</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN4950"><span class='Ref_To_Local'>longpage</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlog_internal.h.html#LN66"><span class='Ref_to_Member'>xlp_sysid</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN4954"><span class='Ref_To_Local'>sysidentifier</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN4950"><span class='Ref_To_Local'>longpage</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlog_internal.h.html#LN67"><span class='Ref_to_Member'>xlp_seg_size</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlog_internal.h.html#LN91"><span class='Ref_to_Const'>XLogSegSize</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN4950"><span class='Ref_To_Local'>longpage</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlog_internal.h.html#LN68"><span class='Ref_to_Member'>xlp_xlog_blcksz</span></a> <span class='Operator'>= </span>XLOG_BLCKSZ<span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Insert the initial checkpoint record */ 
</span>    <a href="xlog.c.html#LN4952"><span class='Ref_To_Local'>recptr</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="xlog.c.html#LN4949"><span class='Ref_To_Local'>page</span></a> <span class='Operator'>+ </span><a href="../../../include/access/xlog_internal.h.html#LN71"><span class='Ref_to_Const'>SizeOfXLogLongPHD</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN4951"><span class='Ref_To_Local'>record</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/xlogrecord.h.html#LN40"><span class='Ref_to_Struct'>XLogRecord</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="xlog.c.html#LN4952"><span class='Ref_To_Local'>recptr</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN4951"><span class='Ref_To_Local'>record</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogrecord.h.html#LN44"><span class='Ref_to_Member'>xl_prev</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN4951"><span class='Ref_To_Local'>record</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogrecord.h.html#LN43"><span class='Ref_to_Member'>xl_xid</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN4951"><span class='Ref_To_Local'>record</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogrecord.h.html#LN42"><span class='Ref_to_Member'>xl_tot_len</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlogrecord.h.html#LN54"><span class='Ref_to_Const'>SizeOfXLogRecord</span></a> <span class='Operator'>+ </span><a href="../../../include/access/xlogrecord.h.html#LN199"><span class='Ref_to_Const'>SizeOfXLogRecordDataHeaderShort</span></a> <span class='Operator'>+ </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN4947"><span class='Ref_To_Local'>checkPoint</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN4951"><span class='Ref_To_Local'>record</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogrecord.h.html#LN45"><span class='Ref_to_Member'>xl_info</span></a> <span class='Operator'>= </span><a href="../../../include/catalog/pg_control.h.html#LN65"><span class='Ref_to_Const'>XLOG_CHECKPOINT_SHUTDOWN</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN4951"><span class='Ref_To_Local'>record</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogrecord.h.html#LN46"><span class='Ref_to_Member'>xl_rmid</span></a> <span class='Operator'>= </span>RM_XLOG_ID<span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN4952"><span class='Ref_To_Local'>recptr</span></a> <span class='Operator'>+= </span><a href="../../../include/access/xlogrecord.h.html#LN54"><span class='Ref_to_Const'>SizeOfXLogRecord</span></a><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* fill the XLogRecordDataHeaderShort struct */ 
</span>    <span class='Operator'>*</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN4952"><span class='Ref_To_Local'>recptr</span></a><span class='Operator'>++</span><span class='Parentheses'>) </span><span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>char</span><span class='Parentheses'>) </span><a href="../../../include/access/xlogrecord.h.html#LN222"><span class='Ref_to_Const'>XLR_BLOCK_ID_DATA_SHORT</span></a><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN4952"><span class='Ref_To_Local'>recptr</span></a><span class='Operator'>++</span><span class='Parentheses'>) </span><span class='Operator'>= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN4947"><span class='Ref_To_Local'>checkPoint</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    memcpy<span class='Parentheses'>(</span><a href="xlog.c.html#LN4952"><span class='Ref_To_Local'>recptr</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN4947"><span class='Ref_To_Local'>checkPoint</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN4947"><span class='Ref_To_Local'>checkPoint</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN4952"><span class='Ref_To_Local'>recptr</span></a> <span class='Operator'>+= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN4947"><span class='Ref_To_Local'>checkPoint</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN4952"><span class='Ref_To_Local'>recptr</span></a> <span class='Operator'>- </span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="xlog.c.html#LN4951"><span class='Ref_To_Local'>record</span></a> <span class='Operator'>== </span><a href="xlog.c.html#LN4951"><span class='Ref_To_Local'>record</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogrecord.h.html#LN42"><span class='Ref_to_Member'>xl_tot_len</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/port/pg_crc32c.h.html#LN40"><span class='Ref_to_Macro'>INIT_CRC32C</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4957"><span class='Ref_To_Local'>crc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/port/pg_crc32c.h.html#LN45"><span class='Ref_to_Macro'>COMP_CRC32C</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4957"><span class='Ref_To_Local'>crc</span></a><span class='Delimiter'>, </span><span class='Parentheses'>((</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="xlog.c.html#LN4951"><span class='Ref_To_Local'>record</span></a><span class='Parentheses'>)</span> <span class='Operator'>+ </span><a href="../../../include/access/xlogrecord.h.html#LN54"><span class='Ref_to_Const'>SizeOfXLogRecord</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN4951"><span class='Ref_To_Local'>record</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogrecord.h.html#LN42"><span class='Ref_to_Member'>xl_tot_len</span></a> <span class='Operator'>- </span><a href="../../../include/access/xlogrecord.h.html#LN54"><span class='Ref_to_Const'>SizeOfXLogRecord</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/port/pg_crc32c.h.html#LN45"><span class='Ref_to_Macro'>COMP_CRC32C</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4957"><span class='Ref_To_Local'>crc</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="xlog.c.html#LN4951"><span class='Ref_To_Local'>record</span></a><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlogrecord.h.html#LN40"><span class='Ref_to_Struct'>XLogRecord</span></a><span class='Delimiter'>, </span>xl_crc<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/port/pg_crc32c.h.html#LN47"><span class='Ref_to_Macro'>FIN_CRC32C</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4957"><span class='Ref_To_Local'>crc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN4951"><span class='Ref_To_Local'>record</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogrecord.h.html#LN48"><span class='Ref_to_Member'>xl_crc</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN4957"><span class='Ref_To_Local'>crc</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Create first XLOG segment file */ 
</span>    <a href="xlog.c.html#LN4953"><span class='Ref_To_Local'>use_existent</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN770"><span class='Ref_to_Global_Var'>openLogFile</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlog.h.html#LN228"><span class='Ref_to_Proto'>XLogFileInit</span></a><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN4953"><span class='Ref_To_Local'>use_existent</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Write the first page with the initial record */ 
</span>    errno <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="../../../include/pgstat.h.html#LN1206"><span class='Ref_to_Func'>pgstat_report_wait_start</span></a><span class='Parentheses'>(</span><a href="../../../include/pgstat.h.html#LN896"><span class='Ref_to_EnumConst'>WAIT_EVENT_WAL_BOOTSTRAP_WRITE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../interfaces/libpq/win32.h.html#LN13"><span class='Ref_to_Macro'>write</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN770"><span class='Ref_to_Global_Var'>openLogFile</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN4949"><span class='Ref_To_Local'>page</span></a><span class='Delimiter'>, </span>XLOG_BLCKSZ<span class='Parentheses'>) </span><span class='Operator'>!= </span>XLOG_BLCKSZ<span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* if write didn't set errno, assume problem is no disk space */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span>errno <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            errno <span class='Operator'>= </span>ENOSPC<span class='Delimiter'>; 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>              <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not write bootstrap write-ahead log file: %m"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="../../../include/pgstat.h.html#LN1230"><span class='Ref_to_Func'>pgstat_report_wait_end</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/pgstat.h.html#LN1206"><span class='Ref_to_Func'>pgstat_report_wait_start</span></a><span class='Parentheses'>(</span><a href="../../../include/pgstat.h.html#LN895"><span class='Ref_to_EnumConst'>WAIT_EVENT_WAL_BOOTSTRAP_SYNC</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/fd.h.html#LN114"><span class='Ref_to_Proto'>pg_fsync</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN770"><span class='Ref_to_Global_Var'>openLogFile</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>              <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not fsync bootstrap write-ahead log file: %m"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/pgstat.h.html#LN1230"><span class='Ref_to_Func'>pgstat_report_wait_end</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../interfaces/libpq/win32.h.html#LN11"><span class='Ref_to_Macro'>close</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN770"><span class='Ref_to_Global_Var'>openLogFile</span></a><span class='Parentheses'>))</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>              <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not close bootstrap write-ahead log file: %m"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <a href="xlog.c.html#LN770"><span class='Ref_to_Global_Var'>openLogFile</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Now create pg_control */ 
</span> 
    memset<span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_control.h.html#LN102"><span class='Ref_to_Struct'>ControlFileData</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* Initialize pg_control status fields */ 
</span>    <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN108"><span class='Ref_to_Member'>system_identifier</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN4954"><span class='Ref_To_Local'>sysidentifier</span></a><span class='Delimiter'>; 
</span>    memcpy<span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN231"><span class='Ref_to_Member'>mock_authentication_nonce</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN4955"><span class='Ref_To_Local'>mock_auth_nonce</span></a><span class='Delimiter'>, </span><a href="../../../include/catalog/pg_control.h.html#LN22"><span class='Ref_to_Const'>MOCK_AUTH_NONCE_LEN</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN129"><span class='Ref_to_Member'>state</span></a> <span class='Operator'>= </span><a href="../../../include/catalog/pg_control.h.html#LN86"><span class='Ref_to_EnumConst'>DB_SHUTDOWNED</span></a><span class='Delimiter'>; 
</span>    <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN130"><span class='Ref_to_Member'>time</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN4947"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN49"><span class='Ref_to_Member'>time</span></a><span class='Delimiter'>; 
</span>    <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN131"><span class='Ref_to_Member'>checkPoint</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN4947"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN34"><span class='Ref_to_Member'>redo</span></a><span class='Delimiter'>; 
</span>    <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN134"><span class='Ref_to_Member'>checkPointCopy</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN4947"><span class='Ref_To_Local'>checkPoint</span></a><span class='Delimiter'>; 
</span>    <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN136"><span class='Ref_to_Member'>unloggedLSN</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Set important parameter values for use when replaying WAL */ 
</span>    <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN181"><span class='Ref_to_Member'>MaxConnections</span></a> <span class='Operator'>= </span><a href="../../utils/init/globals.c.html#LN123"><span class='Ref_to_Global_Var'>MaxConnections</span></a><span class='Delimiter'>; 
</span>    <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN182"><span class='Ref_to_Member'>max_worker_processes</span></a> <span class='Operator'>= </span><a href="../../utils/init/globals.c.html#LN124"><span class='Ref_to_Global_Var'>max_worker_processes</span></a><span class='Delimiter'>; 
</span>    <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN183"><span class='Ref_to_Member'>max_prepared_xacts</span></a> <span class='Operator'>= </span><a href="twophase.c.html#LN116"><span class='Ref_to_Global_Var'>max_prepared_xacts</span></a><span class='Delimiter'>; 
</span>    <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN184"><span class='Ref_to_Member'>max_locks_per_xact</span></a> <span class='Operator'>= </span><a href="../../storage/lmgr/lock.c.html#LN53"><span class='Ref_to_Global_Var'>max_locks_per_xact</span></a><span class='Delimiter'>; 
</span>    <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN179"><span class='Ref_to_Member'>wal_level</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN103"><span class='Ref_to_Global_Var'>wal_level</span></a><span class='Delimiter'>; 
</span>    <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN180"><span class='Ref_to_Member'>wal_log_hints</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN97"><span class='Ref_to_Global_Var'>wal_log_hints</span></a><span class='Delimiter'>; 
</span>    <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN185"><span class='Ref_to_Member'>track_commit_timestamp</span></a> <span class='Operator'>= </span><a href="commit_ts.c.html#LN102"><span class='Ref_to_Global_Var'>track_commit_timestamp</span></a><span class='Delimiter'>; 
</span>    <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN224"><span class='Ref_to_Member'>data_checksum_version</span></a> <span class='Operator'>= </span><a href="../../bootstrap/bootstrap.c.html#LN48"><span class='Ref_to_Global_Var'>bootstrap_data_checksum_version</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* some additional ControlFile fields are set in WriteControlFile() */ 
</span> 
    <a href="xlog.c.html#LN892"><span class='Ref_to_Proto'>WriteControlFile</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Bootstrap the commit log, too */ 
</span>    <a href="../../../include/access/clog.h.html#LN44"><span class='Ref_to_Proto'>BootStrapCLOG</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="../../../include/access/commit_ts.h.html#LN35"><span class='Ref_to_Proto'>BootStrapCommitTs</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="../../../include/access/subtrans.h.html#LN22"><span class='Ref_to_Proto'>BootStrapSUBTRANS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="../../../include/access/multixact.h.html#LN124"><span class='Ref_to_Proto'>BootStrapMultiXact</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN4948"><span class='Ref_To_Local'>buffer</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end BootStrapXLOG &raquo; </span> 
 
<span class='Keyword'>static char </span><span class='Operator'>* 
</span><a name="LN5129"></a><span class='Declare_Function'>str_time</span><span class='Parentheses'>(</span><a href="../../../include/pgtime.h.html#LN22"><span class='Ref_to_Typedef'>pg_time_t</span></a> <span class='Declare_Parameter'>tnow</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN5131"></a>    <span class='Keyword'>static char </span><span class='Declare_Local'>buf</span><span class='Delimiter'>[</span><span class='Number'>128</span><span class='Delimiter'>]; 
</span> 
    <a href="../../../include/pgtime.h.html#LN67"><span class='Ref_to_Proto'>pg_strftime</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5131"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN5131"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                <span class='String'>"%Y-%m-%d %H:%M:%S %Z"</span><span class='Delimiter'>, 
</span>                <a href="../../../include/pgtime.h.html#LN47"><span class='Ref_to_Proto'>pg_localtime</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN5129"><span class='Ref_to_Parameter'>tnow</span></a><span class='Delimiter'>, </span><a href="../../../timezone/pgtz.c.html#LN30"><span class='Ref_to_Global_Var'>log_timezone</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="xlog.c.html#LN5131"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * See if there is a recovery command file (recovery.conf), and if so 
 * read in parameters for archive recovery and XLOG streaming. 
 * 
 * The file is parsed using the main configuration parser. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN5147"></a><span class='Declare_Function'>readRecoveryCommandFile</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN5149"></a>    FILE       <span class='Operator'>*</span><span class='Declare_Local'>fd</span><span class='Delimiter'>; 
</span><a name="LN5150"></a>    <a href="../../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a>  <span class='Declare_Local'>rtli</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN5151"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>rtliGiven</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN5152"></a>    <a href="../../../include/utils/guc.h.html#LN132"><span class='Ref_to_Struct'>ConfigVariable</span></a> <span class='Operator'>*</span><span class='Declare_Local'>item</span><span class='Delimiter'>, 
</span><a name="LN5153"></a>               <span class='Operator'>*</span><span class='Declare_Local'>head</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span><a name="LN5154"></a>               <span class='Operator'>*</span><span class='Declare_Local'>tail</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN5155"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>recoveryTargetActionSet</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
 
    <a href="xlog.c.html#LN5149"><span class='Ref_To_Local'>fd</span></a> <span class='Operator'>= </span><a href="../../../include/storage/fd.h.html#LN83"><span class='Ref_to_Proto'>AllocateFile</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN81"><span class='Ref_to_Const'>RECOVERY_COMMAND_FILE</span></a><span class='Delimiter'>, </span><span class='String'>"r"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN5149"><span class='Ref_To_Local'>fd</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span>errno <span class='Operator'>== </span>ENOENT<span class='Parentheses'>) 
</span>            <span class='Control'>return</span><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* not there, so no archive recovery */ 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not open recovery command file \"%s\": %m"</span><span class='Delimiter'>, 
</span>                        <a href="xlog.c.html#LN81"><span class='Ref_to_Const'>RECOVERY_COMMAND_FILE</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Since we're asking ParseConfigFp() to report errors as FATAL, there's 
     * no need to check the return value. 
     */ 
</span>    <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="../../../include/utils/guc.h.html#LN148"><span class='Ref_to_Proto'>ParseConfigFp</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5149"><span class='Ref_To_Local'>fd</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN81"><span class='Ref_to_Const'>RECOVERY_COMMAND_FILE</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN5153"><span class='Ref_To_Local'>head</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN5154"><span class='Ref_To_Local'>tail</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/fd.h.html#LN84"><span class='Ref_to_Proto'>FreeFile</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5149"><span class='Ref_To_Local'>fd</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN5153"><span class='Ref_To_Local'>head</span></a><span class='Delimiter'>; </span><a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Delimiter'>; </span><a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/guc.h.html#LN141"><span class='Ref_to_Member'>next</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span><a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/guc.h.html#LN134"><span class='Ref_to_Member'>name</span></a><span class='Delimiter'>, </span><span class='String'>"restore_command"</span><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <a href="xlog.c.html#LN256"><span class='Ref_to_Global_Var'>recoveryRestoreCommand</span></a> <span class='Operator'>= </span><a href="../../../include/common/fe_memutils.h.html#LN32"><span class='Ref_to_Proto'>pstrdup</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><span class='Keyword'>value</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN825"><span class='Ref_to_Func'>errmsg_internal</span></a><span class='Parentheses'>(</span><span class='String'>"restore_command = '%s'"</span><span class='Delimiter'>, 
</span>                                     <a href="xlog.c.html#LN256"><span class='Ref_to_Global_Var'>recoveryRestoreCommand</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span><a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/guc.h.html#LN134"><span class='Ref_to_Member'>name</span></a><span class='Delimiter'>, </span><span class='String'>"recovery_end_command"</span><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <a href="xlog.c.html#LN257"><span class='Ref_to_Global_Var'>recoveryEndCommand</span></a> <span class='Operator'>= </span><a href="../../../include/common/fe_memutils.h.html#LN32"><span class='Ref_to_Proto'>pstrdup</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><span class='Keyword'>value</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN825"><span class='Ref_to_Func'>errmsg_internal</span></a><span class='Parentheses'>(</span><span class='String'>"recovery_end_command = '%s'"</span><span class='Delimiter'>, 
</span>                                     <a href="xlog.c.html#LN257"><span class='Ref_to_Global_Var'>recoveryEndCommand</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span><a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/guc.h.html#LN134"><span class='Ref_to_Member'>name</span></a><span class='Delimiter'>, </span><span class='String'>"archive_cleanup_command"</span><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <a href="xlog.c.html#LN258"><span class='Ref_to_Global_Var'>archiveCleanupCommand</span></a> <span class='Operator'>= </span><a href="../../../include/common/fe_memutils.h.html#LN32"><span class='Ref_to_Proto'>pstrdup</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><span class='Keyword'>value</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN825"><span class='Ref_to_Func'>errmsg_internal</span></a><span class='Parentheses'>(</span><span class='String'>"archive_cleanup_command = '%s'"</span><span class='Delimiter'>, 
</span>                                     <a href="xlog.c.html#LN258"><span class='Ref_to_Global_Var'>archiveCleanupCommand</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span><a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/guc.h.html#LN134"><span class='Ref_to_Member'>name</span></a><span class='Delimiter'>, </span><span class='String'>"recovery_target_action"</span><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span><a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><span class='Keyword'>value</span><span class='Delimiter'>, </span><span class='String'>"pause"</span><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                <a href="xlog.c.html#LN261"><span class='Ref_to_Global_Var'>recoveryTargetAction</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlog_internal.h.html#LN252"><span class='Ref_to_EnumConst'>RECOVERY_TARGET_ACTION_PAUSE</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span><a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><span class='Keyword'>value</span><span class='Delimiter'>, </span><span class='String'>"promote"</span><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                <a href="xlog.c.html#LN261"><span class='Ref_to_Global_Var'>recoveryTargetAction</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlog_internal.h.html#LN253"><span class='Ref_to_EnumConst'>RECOVERY_TARGET_ACTION_PROMOTE</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span><a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><span class='Keyword'>value</span><span class='Delimiter'>, </span><span class='String'>"shutdown"</span><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                <a href="xlog.c.html#LN261"><span class='Ref_to_Global_Var'>recoveryTargetAction</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlog_internal.h.html#LN254"><span class='Ref_to_EnumConst'>RECOVERY_TARGET_ACTION_SHUTDOWN</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_INVALID_PARAMETER_VALUE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"invalid value for recovery parameter \"%s\": \"%s\""</span><span class='Delimiter'>, 
</span>                       <span class='String'>"recovery_target_action"</span><span class='Delimiter'>, 
</span>                       <a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><span class='Keyword'>value</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"Valid values are \"pause\", \"promote\", and \"shutdown\"."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN825"><span class='Ref_to_Func'>errmsg_internal</span></a><span class='Parentheses'>(</span><span class='String'>"recovery_target_action = '%s'"</span><span class='Delimiter'>, 
</span>                                     <a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><span class='Keyword'>value</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
            <a href="xlog.c.html#LN5155"><span class='Ref_To_Local'>recoveryTargetActionSet</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if strcmp(item-&GT;name,"re... &raquo; </span> 
        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span><a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/guc.h.html#LN134"><span class='Ref_to_Member'>name</span></a><span class='Delimiter'>, </span><span class='String'>"recovery_target_timeline"</span><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <a href="xlog.c.html#LN5151"><span class='Ref_To_Local'>rtliGiven</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span><a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><span class='Keyword'>value</span><span class='Delimiter'>, </span><span class='String'>"latest"</span><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                <a href="xlog.c.html#LN5150"><span class='Ref_To_Local'>rtli</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                errno <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>                <a href="xlog.c.html#LN5150"><span class='Ref_To_Local'>rtli</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a><span class='Parentheses'>) </span>strtoul<span class='Parentheses'>(</span><a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><span class='Keyword'>value</span><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span>errno <span class='Operator'>== </span>EINVAL <span class='Operator'>|| </span>errno <span class='Operator'>== </span>ERANGE<span class='Parentheses'>) 
</span>                    <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                            <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_INVALID_PARAMETER_VALUE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                             <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"recovery_target_timeline is not a valid number: \"%s\""</span><span class='Delimiter'>, 
</span>                                    <a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><span class='Keyword'>value</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN5150"><span class='Ref_To_Local'>rtli</span></a><span class='Parentheses'>) 
</span>                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Delimiter'>, 
</span>                   <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN825"><span class='Ref_to_Func'>errmsg_internal</span></a><span class='Parentheses'>(</span><span class='String'>"recovery_target_timeline = %u"</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN5150"><span class='Ref_To_Local'>rtli</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Delimiter'>, 
</span>                     <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN825"><span class='Ref_to_Func'>errmsg_internal</span></a><span class='Parentheses'>(</span><span class='String'>"recovery_target_timeline = latest"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if strcmp(item-&GT;name,"re... &raquo; </span> 
        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span><a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/guc.h.html#LN134"><span class='Ref_to_Member'>name</span></a><span class='Delimiter'>, </span><span class='String'>"recovery_target_xid"</span><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            errno <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN262"><span class='Ref_to_Global_Var'>recoveryTargetXid</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a><span class='Parentheses'>) </span>strtoul<span class='Parentheses'>(</span><a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><span class='Keyword'>value</span><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span>errno <span class='Operator'>== </span>EINVAL <span class='Operator'>|| </span>errno <span class='Operator'>== </span>ERANGE<span class='Parentheses'>) 
</span>                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_INVALID_PARAMETER_VALUE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                  <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"recovery_target_xid is not a valid number: \"%s\""</span><span class='Delimiter'>, 
</span>                         <a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><span class='Keyword'>value</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN825"><span class='Ref_to_Func'>errmsg_internal</span></a><span class='Parentheses'>(</span><span class='String'>"recovery_target_xid = %u"</span><span class='Delimiter'>, 
</span>                                     <a href="xlog.c.html#LN262"><span class='Ref_to_Global_Var'>recoveryTargetXid</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN259"><span class='Ref_to_Global_Var'>recoveryTarget</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlog.h.html#LN82"><span class='Ref_to_EnumConst'>RECOVERY_TARGET_XID</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span><a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/guc.h.html#LN134"><span class='Ref_to_Member'>name</span></a><span class='Delimiter'>, </span><span class='String'>"recovery_target_time"</span><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <a href="xlog.c.html#LN259"><span class='Ref_to_Global_Var'>recoveryTarget</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlog.h.html#LN83"><span class='Ref_to_EnumConst'>RECOVERY_TARGET_TIME</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Convert the time string given by the user to TimestampTz form. 
             */ 
</span>            <a href="xlog.c.html#LN263"><span class='Ref_to_Global_Var'>recoveryTargetTime</span></a> <span class='Operator'>= 
</span>                <a href="../../../include/utils/timestamp.h.html#LN27"><span class='Ref_to_Macro'>DatumGetTimestampTz</span></a><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN587"><span class='Ref_to_Macro'>DirectFunctionCall3</span></a><span class='Parentheses'>(</span><a href="../../utils/adt/timestamp.c.html#LN381"><span class='Ref_to_Func'>timestamptz_in</span></a><span class='Delimiter'>, 
</span>                                                <a href="../../../include/postgres.h.html#LN583"><span class='Ref_to_Macro'>CStringGetDatum</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><span class='Keyword'>value</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                <a href="../../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                        <a href="../../../include/postgres.h.html#LN484"><span class='Ref_to_Macro'>Int32GetDatum</span></a><span class='Parentheses'>(</span><span class='Operator'>-</span><span class='Number'>1</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN825"><span class='Ref_to_Func'>errmsg_internal</span></a><span class='Parentheses'>(</span><span class='String'>"recovery_target_time = '%s'"</span><span class='Delimiter'>, 
</span>                                   <a href="../../../bin/pg_waldump/compat.c.html#LN48"><span class='Ref_to_Func'>timestamptz_to_str</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN263"><span class='Ref_to_Global_Var'>recoveryTargetTime</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span><a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/guc.h.html#LN134"><span class='Ref_to_Member'>name</span></a><span class='Delimiter'>, </span><span class='String'>"recovery_target_name"</span><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <a href="xlog.c.html#LN259"><span class='Ref_to_Global_Var'>recoveryTarget</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlog.h.html#LN84"><span class='Ref_to_EnumConst'>RECOVERY_TARGET_NAME</span></a><span class='Delimiter'>; 
</span> 
            <a href="xlog.c.html#LN264"><span class='Ref_to_Global_Var'>recoveryTargetName</span></a> <span class='Operator'>= </span><a href="../../../include/common/fe_memutils.h.html#LN32"><span class='Ref_to_Proto'>pstrdup</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><span class='Keyword'>value</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span>strlen<span class='Parentheses'>(</span><a href="xlog.c.html#LN264"><span class='Ref_to_Global_Var'>recoveryTargetName</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT;= </span><a href="../../../include/access/xlog_internal.h.html#LN137"><span class='Ref_to_Const'>MAXFNAMELEN</span></a><span class='Parentheses'>)</span> 
                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_INVALID_PARAMETER_VALUE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"recovery_target_name is too long (maximum %d characters)"</span><span class='Delimiter'>, 
</span>                                <a href="../../../include/access/xlog_internal.h.html#LN137"><span class='Ref_to_Const'>MAXFNAMELEN</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN825"><span class='Ref_to_Func'>errmsg_internal</span></a><span class='Parentheses'>(</span><span class='String'>"recovery_target_name = '%s'"</span><span class='Delimiter'>, 
</span>                                     <a href="xlog.c.html#LN264"><span class='Ref_to_Global_Var'>recoveryTargetName</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span><a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/guc.h.html#LN134"><span class='Ref_to_Member'>name</span></a><span class='Delimiter'>, </span><span class='String'>"recovery_target_lsn"</span><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <a href="xlog.c.html#LN259"><span class='Ref_to_Global_Var'>recoveryTarget</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlog.h.html#LN85"><span class='Ref_to_EnumConst'>RECOVERY_TARGET_LSN</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Convert the LSN string given by the user to XLogRecPtr form. 
             */ 
</span>            <a href="xlog.c.html#LN265"><span class='Ref_to_Global_Var'>recoveryTargetLSN</span></a> <span class='Operator'>= 
</span>                <a href="../../../include/utils/pg_lsn.h.html#LN20"><span class='Ref_to_Macro'>DatumGetLSN</span></a><span class='Parentheses'>(</span><a href="../../../include/fmgr.h.html#LN587"><span class='Ref_to_Macro'>DirectFunctionCall3</span></a><span class='Parentheses'>(</span><a href="../../utils/adt/pg_lsn.c.html#LN28"><span class='Ref_to_Func'>pg_lsn_in</span></a><span class='Delimiter'>, 
</span>                                                <a href="../../../include/postgres.h.html#LN583"><span class='Ref_to_Macro'>CStringGetDatum</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><span class='Keyword'>value</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                <a href="../../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                <a href="../../../include/postgres.h.html#LN484"><span class='Ref_to_Macro'>Int32GetDatum</span></a><span class='Parentheses'>(</span><span class='Operator'>-</span><span class='Number'>1</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN825"><span class='Ref_to_Func'>errmsg_internal</span></a><span class='Parentheses'>(</span><span class='String'>"recovery_target_lsn = '%X/%X'"</span><span class='Delimiter'>, 
</span>                                     <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN265"><span class='Ref_to_Global_Var'>recoveryTargetLSN</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                     <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN265"><span class='Ref_to_Global_Var'>recoveryTargetLSN</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span><a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/guc.h.html#LN134"><span class='Ref_to_Member'>name</span></a><span class='Delimiter'>, </span><span class='String'>"recovery_target"</span><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span><a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><span class='Keyword'>value</span><span class='Delimiter'>, </span><span class='String'>"immediate"</span><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                <a href="xlog.c.html#LN259"><span class='Ref_to_Global_Var'>recoveryTarget</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlog.h.html#LN86"><span class='Ref_to_EnumConst'>RECOVERY_TARGET_IMMEDIATE</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_INVALID_PARAMETER_VALUE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"invalid value for recovery parameter \"%s\": \"%s\""</span><span class='Delimiter'>, 
</span>                       <span class='String'>"recovery_target"</span><span class='Delimiter'>, 
</span>                       <a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><span class='Keyword'>value</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                       <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"The only allowed value is \"immediate\"."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN825"><span class='Ref_to_Func'>errmsg_internal</span></a><span class='Parentheses'>(</span><span class='String'>"recovery_target = '%s'"</span><span class='Delimiter'>, 
</span>                                     <a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><span class='Keyword'>value</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span><a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/guc.h.html#LN134"><span class='Ref_to_Member'>name</span></a><span class='Delimiter'>, </span><span class='String'>"recovery_target_inclusive"</span><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * does nothing if a recovery_target is not also set 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/utils/builtins.h.html#LN22"><span class='Ref_to_Proto'>parse_bool</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><span class='Keyword'>value</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN260"><span class='Ref_to_Global_Var'>recoveryTargetInclusive</span></a><span class='Parentheses'>))</span> 
                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_INVALID_PARAMETER_VALUE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"parameter \"%s\" requires a Boolean value"</span><span class='Delimiter'>, 
</span>                                <span class='String'>"recovery_target_inclusive"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN825"><span class='Ref_to_Func'>errmsg_internal</span></a><span class='Parentheses'>(</span><span class='String'>"recovery_target_inclusive = %s"</span><span class='Delimiter'>, 
</span>                                     <a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><span class='Keyword'>value</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span><a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/guc.h.html#LN134"><span class='Ref_to_Member'>name</span></a><span class='Delimiter'>, </span><span class='String'>"standby_mode"</span><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/utils/builtins.h.html#LN22"><span class='Ref_to_Proto'>parse_bool</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><span class='Keyword'>value</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN270"><span class='Ref_to_Global_Var'>StandbyModeRequested</span></a><span class='Parentheses'>))</span> 
                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_INVALID_PARAMETER_VALUE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"parameter \"%s\" requires a Boolean value"</span><span class='Delimiter'>, 
</span>                                <span class='String'>"standby_mode"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN825"><span class='Ref_to_Func'>errmsg_internal</span></a><span class='Parentheses'>(</span><span class='String'>"standby_mode = '%s'"</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><span class='Keyword'>value</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span><a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/guc.h.html#LN134"><span class='Ref_to_Member'>name</span></a><span class='Delimiter'>, </span><span class='String'>"primary_conninfo"</span><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <a href="xlog.c.html#LN271"><span class='Ref_to_Global_Var'>PrimaryConnInfo</span></a> <span class='Operator'>= </span><a href="../../../include/common/fe_memutils.h.html#LN32"><span class='Ref_to_Proto'>pstrdup</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><span class='Keyword'>value</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN825"><span class='Ref_to_Func'>errmsg_internal</span></a><span class='Parentheses'>(</span><span class='String'>"primary_conninfo = '%s'"</span><span class='Delimiter'>, 
</span>                                     <a href="xlog.c.html#LN271"><span class='Ref_to_Global_Var'>PrimaryConnInfo</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span><a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/guc.h.html#LN134"><span class='Ref_to_Member'>name</span></a><span class='Delimiter'>, </span><span class='String'>"primary_slot_name"</span><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <a href="../../replication/slot.c.html#LN171"><span class='Ref_to_Func'>ReplicationSlotValidateName</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><span class='Keyword'>value</span><span class='Delimiter'>, </span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN272"><span class='Ref_to_Global_Var'>PrimarySlotName</span></a> <span class='Operator'>= </span><a href="../../../include/common/fe_memutils.h.html#LN32"><span class='Ref_to_Proto'>pstrdup</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><span class='Keyword'>value</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN825"><span class='Ref_to_Func'>errmsg_internal</span></a><span class='Parentheses'>(</span><span class='String'>"primary_slot_name = '%s'"</span><span class='Delimiter'>, 
</span>                                     <a href="xlog.c.html#LN272"><span class='Ref_to_Global_Var'>PrimarySlotName</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span><a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/guc.h.html#LN134"><span class='Ref_to_Member'>name</span></a><span class='Delimiter'>, </span><span class='String'>"trigger_file"</span><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <a href="xlog.c.html#LN273"><span class='Ref_to_Global_Var'>TriggerFile</span></a> <span class='Operator'>= </span><a href="../../../include/common/fe_memutils.h.html#LN32"><span class='Ref_to_Proto'>pstrdup</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><span class='Keyword'>value</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN825"><span class='Ref_to_Func'>errmsg_internal</span></a><span class='Parentheses'>(</span><span class='String'>"trigger_file = '%s'"</span><span class='Delimiter'>, 
</span>                                     <a href="xlog.c.html#LN273"><span class='Ref_to_Global_Var'>TriggerFile</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span><a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/guc.h.html#LN134"><span class='Ref_to_Member'>name</span></a><span class='Delimiter'>, </span><span class='String'>"recovery_min_apply_delay"</span><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span><a name="LN5369"></a>            <span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Local'>hintmsg</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/utils/guc.h.html#LN358"><span class='Ref_to_Proto'>parse_int</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><span class='Keyword'>value</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN266"><span class='Ref_to_Global_Var'>recovery_min_apply_delay</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/guc.h.html#LN223"><span class='Ref_to_Const'>GUC_UNIT_MS</span></a><span class='Delimiter'>, 
</span>                           <span class='Operator'>&</span><a href="xlog.c.html#LN5369"><span class='Ref_To_Local'>hintmsg</span></a><span class='Parentheses'>))</span> 
                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_INVALID_PARAMETER_VALUE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"parameter \"%s\" requires a temporal value"</span><span class='Delimiter'>, 
</span>                                <span class='String'>"recovery_min_apply_delay"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="xlog.c.html#LN5369"><span class='Ref_To_Local'>hintmsg</span></a> <span class='Operator'>? </span><a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"%s"</span><span class='Delimiter'>, </span>_<span class='Parentheses'>(</span><a href="xlog.c.html#LN5369"><span class='Ref_To_Local'>hintmsg</span></a><span class='Parentheses'>))</span> <span class='Operator'>: </span><span class='Number'>0</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN825"><span class='Ref_to_Func'>errmsg_internal</span></a><span class='Parentheses'>(</span><span class='String'>"recovery_min_apply_delay = '%s'"</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><span class='Keyword'>value</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_INVALID_PARAMETER_VALUE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"unrecognized recovery parameter \"%s\""</span><span class='Delimiter'>, 
</span>                            <a href="xlog.c.html#LN5152"><span class='Ref_To_Local'>item</span></a><span class='Operator'>-&GT;</span><a href="../../../include/utils/guc.h.html#LN134"><span class='Ref_to_Member'>name</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for item=head;item;item=i... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Check for compulsory parameters 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN270"><span class='Ref_to_Global_Var'>StandbyModeRequested</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN271"><span class='Ref_to_Global_Var'>PrimaryConnInfo</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>&& </span><a href="xlog.c.html#LN256"><span class='Ref_to_Global_Var'>recoveryRestoreCommand</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN39"><span class='Ref_to_Const'>WARNING</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"recovery command file \"%s\" specified neither primary_conninfo nor restore_command"</span><span class='Delimiter'>, 
</span>                            <a href="xlog.c.html#LN81"><span class='Ref_to_Const'>RECOVERY_COMMAND_FILE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"The database server will regularly poll the pg_wal subdirectory to check for files placed there."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN256"><span class='Ref_to_Global_Var'>recoveryRestoreCommand</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_INVALID_PARAMETER_VALUE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"recovery command file \"%s\" must specify restore_command when standby mode is not enabled"</span><span class='Delimiter'>, 
</span>                            <a href="xlog.c.html#LN81"><span class='Ref_to_Const'>RECOVERY_COMMAND_FILE</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Override any inconsistent requests. Not that this is a change of 
     * behaviour in 9.5; prior to this we simply ignored a request to pause if 
     * hot_standby = off, which was surprising behaviour. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN261"><span class='Ref_to_Global_Var'>recoveryTargetAction</span></a> <span class='Operator'>== </span><a href="../../../include/access/xlog_internal.h.html#LN252"><span class='Ref_to_EnumConst'>RECOVERY_TARGET_ACTION_PAUSE</span></a> <span class='Operator'>&& 
</span>        <a href="xlog.c.html#LN5155"><span class='Ref_To_Local'>recoveryTargetActionSet</span></a> <span class='Operator'>&& 
</span>        <span class='Operator'>!</span><a href="xlog.c.html#LN95"><span class='Ref_to_Global_Var'>EnableHotStandby</span></a><span class='Parentheses'>) 
</span>        <a href="xlog.c.html#LN261"><span class='Ref_to_Global_Var'>recoveryTargetAction</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlog_internal.h.html#LN254"><span class='Ref_to_EnumConst'>RECOVERY_TARGET_ACTION_SHUTDOWN</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We don't support standby_mode in standalone backends; that requires 
     * other processes such as the WAL receiver to be alive. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN270"><span class='Ref_to_Global_Var'>StandbyModeRequested</span></a> <span class='Operator'>&& !</span><a href="../../utils/init/globals.c.html#LN100"><span class='Ref_to_Global_Var'>IsUnderPostmaster</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>            <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"standby mode is not supported by single-user servers"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Enable fetching from archive recovery area */ 
</span>    <a href="xlog.c.html#LN245"><span class='Ref_to_Global_Var'>ArchiveRecoveryRequested</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If user specified recovery_target_timeline, validate it or compute the 
     * "latest" value.  We can't do this until after we've gotten the restore 
     * command and set InArchiveRecovery, because we need to fetch timeline 
     * history files from the archive. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN5151"><span class='Ref_To_Local'>rtliGiven</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN5150"><span class='Ref_To_Local'>rtli</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Timeline 1 does not have a history file, all else should */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN5150"><span class='Ref_To_Local'>rtli</span></a> <span class='Operator'>!= </span><span class='Number'>1</span> <span class='Operator'>&& !</span><a href="../../../include/access/timeline.h.html#LN32"><span class='Ref_to_Proto'>existsTimeLineHistory</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5150"><span class='Ref_To_Local'>rtli</span></a><span class='Parentheses'>))</span> 
                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_INVALID_PARAMETER_VALUE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"recovery target timeline %u does not exist"</span><span class='Delimiter'>, 
</span>                                <a href="xlog.c.html#LN5150"><span class='Ref_To_Local'>rtli</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN315"><span class='Ref_to_Global_Var'>recoveryTargetTLI</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN5150"><span class='Ref_To_Local'>rtli</span></a><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN316"><span class='Ref_to_Global_Var'>recoveryTargetIsLatest</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* We start the "latest" search from pg_control's timeline */ 
</span>            <a href="xlog.c.html#LN315"><span class='Ref_to_Global_Var'>recoveryTargetTLI</span></a> <span class='Operator'>= </span><a href="../../../include/access/timeline.h.html#LN33"><span class='Ref_to_Proto'>findNewestTimeLine</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN315"><span class='Ref_to_Global_Var'>recoveryTargetTLI</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN316"><span class='Ref_to_Global_Var'>recoveryTargetIsLatest</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if rtliGiven &raquo; </span> 
 
    <a href="../../../include/utils/guc.h.html#LN156"><span class='Ref_to_Proto'>FreeConfigVariables</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5153"><span class='Ref_To_Local'>head</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end readRecoveryCommandFile &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Exit archive-recovery state 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN5464"></a><span class='Declare_Function'>exitArchiveRecovery</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a> <span class='Declare_Parameter'>endTLI</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>endOfLog</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN5466"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>recoveryPath</span><span class='Delimiter'>[</span><a href="../../../include/pg_config_manual.h.html#LN88"><span class='Ref_to_Const'>MAXPGPATH</span></a><span class='Delimiter'>]; 
</span><a name="LN5467"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>xlogfname</span><span class='Delimiter'>[</span><a href="../../../include/access/xlog_internal.h.html#LN137"><span class='Ref_to_Const'>MAXFNAMELEN</span></a><span class='Delimiter'>]; 
</span><a name="LN5468"></a>    <a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a>   <span class='Declare_Local'>endLogSegNo</span><span class='Delimiter'>; 
</span><a name="LN5469"></a>    <a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a>   <span class='Declare_Local'>startLogSegNo</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* we always switch to a new timeline after archive recovery */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN5464"><span class='Ref_to_Parameter'>endTLI</span></a> <span class='Operator'>!= </span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We are no longer in archive recovery state. 
     */ 
</span>    <a href="xlog.c.html#LN246"><span class='Ref_to_Global_Var'>InArchiveRecovery</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Update min recovery point one last time. 
     */ 
</span>    <a href="xlog.c.html#LN885"><span class='Ref_to_Proto'>UpdateMinRecoveryPoint</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the ending log segment is still open, close it (to avoid problems on 
     * Windows with trying to rename or delete an open file). 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN782"><span class='Ref_to_Global_Var'>readFile</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../interfaces/libpq/win32.h.html#LN11"><span class='Ref_to_Macro'>close</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN782"><span class='Ref_to_Global_Var'>readFile</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN782"><span class='Ref_to_Global_Var'>readFile</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Calculate the last segment on the old timeline, and the first segment 
     * on the new timeline. If the switch happens in the middle of a segment, 
     * they are the same, but if the switch happens exactly at a segment 
     * boundary, startLogSegNo will be endLogSegNo + 1. 
     */ 
</span>    <a href="../../../include/access/xlog_internal.h.html#LN108"><span class='Ref_to_Macro'>XLByteToPrevSeg</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5464"><span class='Ref_to_Parameter'>endOfLog</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN5468"><span class='Ref_To_Local'>endLogSegNo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/access/xlog_internal.h.html#LN105"><span class='Ref_to_Macro'>XLByteToSeg</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5464"><span class='Ref_to_Parameter'>endOfLog</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN5469"><span class='Ref_To_Local'>startLogSegNo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Initialize the starting WAL segment for the new timeline. If the switch 
     * happens in the middle of a segment, copy data from the last WAL segment 
     * of the old timeline up to the switch point, to the starting WAL segment 
     * on the new timeline. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN5468"><span class='Ref_To_Local'>endLogSegNo</span></a> <span class='Operator'>== </span><a href="xlog.c.html#LN5469"><span class='Ref_To_Local'>startLogSegNo</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Make a copy of the file on the new timeline. 
         * 
         * Writing WAL isn't allowed yet, so there are no locking 
         * considerations. But we should be just as tense as XLogFileInit to 
         * avoid emplacing a bogus file. 
         */ 
</span>        <a href="xlog.c.html#LN3321"><span class='Ref_to_Func'>XLogFileCopy</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5468"><span class='Ref_To_Local'>endLogSegNo</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN5464"><span class='Ref_to_Parameter'>endTLI</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN5468"><span class='Ref_To_Local'>endLogSegNo</span></a><span class='Delimiter'>, 
</span>                     <a href="xlog.c.html#LN5464"><span class='Ref_to_Parameter'>endOfLog</span></a> <span class='Operator'>% </span>XLOG_SEG_SIZE<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * The switch happened at a segment boundary, so just create the next 
         * segment on the new timeline. 
         */ 
</span><a name="LN5527"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>use_existent</span> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span><a name="LN5528"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>fd</span><span class='Delimiter'>; 
</span> 
        <a href="xlog.c.html#LN5528"><span class='Ref_To_Local'>fd</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlog.h.html#LN228"><span class='Ref_to_Proto'>XLogFileInit</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5469"><span class='Ref_To_Local'>startLogSegNo</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN5527"><span class='Ref_To_Local'>use_existent</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../interfaces/libpq/win32.h.html#LN11"><span class='Ref_to_Macro'>close</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5528"><span class='Ref_To_Local'>fd</span></a><span class='Parentheses'>))</span> 
            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                     <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not close log file %s: %m"</span><span class='Delimiter'>, 
</span>                            <a href="../../../include/access/xlog.h.html#LN254"><span class='Ref_to_Proto'>XLogFileNameP</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN5469"><span class='Ref_To_Local'>startLogSegNo</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Let's just make real sure there are not .ready or .done flags posted 
     * for the new segment. 
     */ 
</span>    <a href="../../../include/access/xlog_internal.h.html#LN142"><span class='Ref_to_Macro'>XLogFileName</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5467"><span class='Ref_To_Local'>xlogfname</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN5469"><span class='Ref_To_Local'>startLogSegNo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/access/xlog_internal.h.html#LN319"><span class='Ref_to_Proto'>XLogArchiveCleanup</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5467"><span class='Ref_To_Local'>xlogfname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Since there might be a partial WAL segment named RECOVERYXLOG, get rid 
     * of it. 
     */ 
</span>    <a href="../../../pl/plperl/plperl.h.html#LN60"><span class='Ref_to_Macro'>snprintf</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5466"><span class='Ref_To_Local'>recoveryPath</span></a><span class='Delimiter'>, </span><a href="../../../include/pg_config_manual.h.html#LN88"><span class='Ref_to_Const'>MAXPGPATH</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xlog_internal.h.html#LN130"><span class='Ref_to_Const'>XLOGDIR</span></a> <span class='String'>"/RECOVERYXLOG"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../timezone/private.h.html#LN59"><span class='Ref_to_Proto'>unlink</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5466"><span class='Ref_To_Local'>recoveryPath</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* ignore any error */ 
</span> 
    <span class='Comment_Multi_Line'>/* Get rid of any remaining recovered timeline-history file, too */ 
</span>    <a href="../../../pl/plperl/plperl.h.html#LN60"><span class='Ref_to_Macro'>snprintf</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5466"><span class='Ref_To_Local'>recoveryPath</span></a><span class='Delimiter'>, </span><a href="../../../include/pg_config_manual.h.html#LN88"><span class='Ref_to_Const'>MAXPGPATH</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xlog_internal.h.html#LN130"><span class='Ref_to_Const'>XLOGDIR</span></a> <span class='String'>"/RECOVERYHISTORY"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../timezone/private.h.html#LN59"><span class='Ref_to_Proto'>unlink</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5466"><span class='Ref_To_Local'>recoveryPath</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* ignore any error */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Rename the config file out of the way, so that we don't accidentally 
     * re-enter archive recovery mode in a subsequent crash. 
     */ 
</span>    <a href="../../../timezone/private.h.html#LN59"><span class='Ref_to_Proto'>unlink</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN82"><span class='Ref_to_Const'>RECOVERY_COMMAND_DONE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/common/file_utils.h.html#LN22"><span class='Ref_to_Proto'>durable_rename</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN81"><span class='Ref_to_Const'>RECOVERY_COMMAND_FILE</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN82"><span class='Ref_to_Const'>RECOVERY_COMMAND_DONE</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>            <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"archive recovery complete"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end exitArchiveRecovery &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Extract timestamp from WAL record. 
 * 
 * If the record contains a timestamp, returns true, and saves the timestamp 
 * in *recordXtime. If the record type has no timestamp, returns false. 
 * Currently, only transaction commit/abort records and restore points contain 
 * timestamps. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN5577"></a><span class='Declare_Function'>getRecordTimestamp</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogreader.h.html#LN68"><span class='Ref_to_Struct'>XLogReaderState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>record</span><span class='Delimiter'>, </span><a href="../../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>recordXtime</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN5579"></a>    <a href="../../../include/c.h.html#LN265"><span class='Ref_to_Typedef'>uint8</span></a>       <span class='Declare_Local'>info</span> <span class='Operator'>= </span><a href="../../../include/access/xlogreader.h.html#LN215"><span class='Ref_to_Macro'>XLogRecGetInfo</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5577"><span class='Ref_to_Parameter'>record</span></a><span class='Parentheses'>) </span><span class='Operator'>& ~</span><a href="../../../include/access/xlogrecord.h.html#LN61"><span class='Ref_to_Const'>XLR_INFO_MASK</span></a><span class='Delimiter'>; 
</span><a name="LN5580"></a>    <a href="../../../include/c.h.html#LN265"><span class='Ref_to_Typedef'>uint8</span></a>       <span class='Declare_Local'>xact_info</span> <span class='Operator'>= </span><a href="xlog.c.html#LN5579"><span class='Ref_To_Local'>info</span></a> <span class='Operator'>& </span><a href="../../../include/access/xact.h.html#LN143"><span class='Ref_to_Const'>XLOG_XACT_OPMASK</span></a><span class='Delimiter'>; 
</span><a name="LN5581"></a>    <a href="../../../include/c.h.html#LN265"><span class='Ref_to_Typedef'>uint8</span></a>       <span class='Declare_Local'>rmid</span> <span class='Operator'>= </span><a href="../../../include/access/xlogreader.h.html#LN216"><span class='Ref_to_Macro'>XLogRecGetRmid</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5577"><span class='Ref_to_Parameter'>record</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN5581"><span class='Ref_To_Local'>rmid</span></a> <span class='Operator'>== </span>RM_XLOG_ID <span class='Operator'>&& </span><a href="xlog.c.html#LN5579"><span class='Ref_To_Local'>info</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_control.h.html#LN72"><span class='Ref_to_Const'>XLOG_RESTORE_POINT</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Operator'>*</span><a href="xlog.c.html#LN5577"><span class='Ref_to_Parameter'>recordXtime</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/access/xlog_internal.h.html#LN222"><span class='Ref_to_Struct'>xl_restore_point</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/access/xlogreader.h.html#LN219"><span class='Ref_to_Macro'>XLogRecGetData</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5577"><span class='Ref_to_Parameter'>record</span></a><span class='Parentheses'>))</span><span class='Operator'>-&GT;</span>rp_time<span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN5581"><span class='Ref_To_Local'>rmid</span></a> <span class='Operator'>== </span>RM_XACT_ID <span class='Operator'>&& </span><span class='Parentheses'>(</span><a href="xlog.c.html#LN5580"><span class='Ref_To_Local'>xact_info</span></a> <span class='Operator'>== </span><a href="../../../include/access/xact.h.html#LN133"><span class='Ref_to_Const'>XLOG_XACT_COMMIT</span></a> <span class='Operator'>|| 
</span>                               <a href="xlog.c.html#LN5580"><span class='Ref_To_Local'>xact_info</span></a> <span class='Operator'>== </span><a href="../../../include/access/xact.h.html#LN136"><span class='Ref_to_Const'>XLOG_XACT_COMMIT_PREPARED</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Operator'>*</span><a href="xlog.c.html#LN5577"><span class='Ref_to_Parameter'>recordXtime</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/access/xact.h.html#LN254"><span class='Ref_to_Struct'>xl_xact_commit</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/access/xlogreader.h.html#LN219"><span class='Ref_to_Macro'>XLogRecGetData</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5577"><span class='Ref_to_Parameter'>record</span></a><span class='Parentheses'>))</span><span class='Operator'>-&GT;</span>xact_time<span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN5581"><span class='Ref_To_Local'>rmid</span></a> <span class='Operator'>== </span>RM_XACT_ID <span class='Operator'>&& </span><span class='Parentheses'>(</span><a href="xlog.c.html#LN5580"><span class='Ref_To_Local'>xact_info</span></a> <span class='Operator'>== </span><a href="../../../include/access/xact.h.html#LN135"><span class='Ref_to_Const'>XLOG_XACT_ABORT</span></a> <span class='Operator'>|| 
</span>                               <a href="xlog.c.html#LN5580"><span class='Ref_To_Local'>xact_info</span></a> <span class='Operator'>== </span><a href="../../../include/access/xact.h.html#LN137"><span class='Ref_to_Const'>XLOG_XACT_ABORT_PREPARED</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Operator'>*</span><a href="xlog.c.html#LN5577"><span class='Ref_to_Parameter'>recordXtime</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/access/xact.h.html#LN268"><span class='Ref_to_Struct'>xl_xact_abort</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/access/xlogreader.h.html#LN219"><span class='Ref_to_Macro'>XLogRecGetData</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5577"><span class='Ref_to_Parameter'>record</span></a><span class='Parentheses'>))</span><span class='Operator'>-&GT;</span>xact_time<span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end getRecordTimestamp &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * For point-in-time recovery, this function decides whether we want to 
 * stop applying the XLOG before the current record. 
 * 
 * Returns TRUE if we are stopping, FALSE otherwise. If stopping, some 
 * information is saved in recoveryStopXid et al for use in annotating the 
 * new timeline's history file. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN5612"></a><span class='Declare_Function'>recoveryStopsBefore</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogreader.h.html#LN68"><span class='Ref_to_Struct'>XLogReaderState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>record</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN5614"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>stopsHere</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN5615"></a>    <a href="../../../include/c.h.html#LN265"><span class='Ref_to_Typedef'>uint8</span></a>       <span class='Declare_Local'>xact_info</span><span class='Delimiter'>; 
</span><a name="LN5616"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>isCommit</span><span class='Delimiter'>; 
</span><a name="LN5617"></a>    <a href="../../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <span class='Declare_Local'>recordXtime</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN5618"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>recordXid</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Check if we should stop as soon as reaching consistency */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN259"><span class='Ref_to_Global_Var'>recoveryTarget</span></a> <span class='Operator'>== </span><a href="../../../include/access/xlog.h.html#LN86"><span class='Ref_to_EnumConst'>RECOVERY_TARGET_IMMEDIATE</span></a> <span class='Operator'>&& </span><a href="xlog.c.html#LN830"><span class='Ref_to_Global_Var'>reachedConsistency</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"recovery stopping after reaching consistency"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <a href="xlog.c.html#LN289"><span class='Ref_to_Global_Var'>recoveryStopAfter</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN285"><span class='Ref_to_Global_Var'>recoveryStopXid</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN287"><span class='Ref_to_Global_Var'>recoveryStopLSN</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN286"><span class='Ref_to_Global_Var'>recoveryStopTime</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN288"><span class='Ref_to_Global_Var'>recoveryStopName</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='String'>'\0'</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Check if target LSN has been reached */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN259"><span class='Ref_to_Global_Var'>recoveryTarget</span></a> <span class='Operator'>== </span><a href="../../../include/access/xlog.h.html#LN85"><span class='Ref_to_EnumConst'>RECOVERY_TARGET_LSN</span></a> <span class='Operator'>&& 
</span>        <span class='Operator'>!</span><a href="xlog.c.html#LN260"><span class='Ref_to_Global_Var'>recoveryTargetInclusive</span></a> <span class='Operator'>&& 
</span>        <a href="xlog.c.html#LN5612"><span class='Ref_to_Parameter'>record</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogreader.h.html#LN113"><span class='Ref_to_Member'>ReadRecPtr</span></a> <span class='Operator'>&GT;= </span><a href="xlog.c.html#LN265"><span class='Ref_to_Global_Var'>recoveryTargetLSN</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="xlog.c.html#LN289"><span class='Ref_to_Global_Var'>recoveryStopAfter</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN285"><span class='Ref_to_Global_Var'>recoveryStopXid</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN287"><span class='Ref_to_Global_Var'>recoveryStopLSN</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN5612"><span class='Ref_to_Parameter'>record</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogreader.h.html#LN113"><span class='Ref_to_Member'>ReadRecPtr</span></a><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN286"><span class='Ref_to_Global_Var'>recoveryStopTime</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN288"><span class='Ref_to_Global_Var'>recoveryStopName</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='String'>'\0'</span><span class='Delimiter'>; 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>             <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"recovery stopping before WAL location (LSN) \"%X/%X\""</span><span class='Delimiter'>, 
</span>                     <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN287"><span class='Ref_to_Global_Var'>recoveryStopLSN</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN287"><span class='Ref_to_Global_Var'>recoveryStopLSN</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Otherwise we only consider stopping before COMMIT or ABORT records. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/xlogreader.h.html#LN216"><span class='Ref_to_Macro'>XLogRecGetRmid</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5612"><span class='Ref_to_Parameter'>record</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span>RM_XACT_ID<span class='Parentheses'>)</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <a href="xlog.c.html#LN5615"><span class='Ref_To_Local'>xact_info</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlogreader.h.html#LN215"><span class='Ref_to_Macro'>XLogRecGetInfo</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5612"><span class='Ref_to_Parameter'>record</span></a><span class='Parentheses'>) </span><span class='Operator'>& </span><a href="../../../include/access/xact.h.html#LN143"><span class='Ref_to_Const'>XLOG_XACT_OPMASK</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN5615"><span class='Ref_To_Local'>xact_info</span></a> <span class='Operator'>== </span><a href="../../../include/access/xact.h.html#LN133"><span class='Ref_to_Const'>XLOG_XACT_COMMIT</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="xlog.c.html#LN5616"><span class='Ref_To_Local'>isCommit</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN5618"><span class='Ref_To_Local'>recordXid</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlogreader.h.html#LN217"><span class='Ref_to_Macro'>XLogRecGetXid</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5612"><span class='Ref_to_Parameter'>record</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN5615"><span class='Ref_To_Local'>xact_info</span></a> <span class='Operator'>== </span><a href="../../../include/access/xact.h.html#LN136"><span class='Ref_to_Const'>XLOG_XACT_COMMIT_PREPARED</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN5664"></a>        <a href="../../../include/access/xact.h.html#LN254"><span class='Ref_to_Struct'>xl_xact_commit</span></a> <span class='Operator'>*</span><span class='Declare_Local'>xlrec</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/xact.h.html#LN254"><span class='Ref_to_Struct'>xl_xact_commit</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/access/xlogreader.h.html#LN219"><span class='Ref_to_Macro'>XLogRecGetData</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5612"><span class='Ref_to_Parameter'>record</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN5665"></a>        <a href="../../../include/access/xact.h.html#LN286"><span class='Ref_to_Struct'>xl_xact_parsed_commit</span></a> <span class='Declare_Local'>parsed</span><span class='Delimiter'>; 
</span> 
        <a href="xlog.c.html#LN5616"><span class='Ref_To_Local'>isCommit</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <a href="../rmgrdesc/xactdesc.c.html#LN33"><span class='Ref_to_Func'>ParseCommitRecord</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlogreader.h.html#LN215"><span class='Ref_to_Macro'>XLogRecGetInfo</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5612"><span class='Ref_to_Parameter'>record</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                          <a href="xlog.c.html#LN5664"><span class='Ref_To_Local'>xlrec</span></a><span class='Delimiter'>, 
</span>                          <span class='Operator'>&</span><a href="xlog.c.html#LN5665"><span class='Ref_To_Local'>parsed</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN5618"><span class='Ref_To_Local'>recordXid</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN5665"><span class='Ref_To_Local'>parsed</span></a><span class='Operator'>.</span><a href="../../../include/access/xact.h.html#LN304"><span class='Ref_to_Member'>twophase_xid</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN5615"><span class='Ref_To_Local'>xact_info</span></a> <span class='Operator'>== </span><a href="../../../include/access/xact.h.html#LN135"><span class='Ref_to_Const'>XLOG_XACT_ABORT</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="xlog.c.html#LN5616"><span class='Ref_To_Local'>isCommit</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN5618"><span class='Ref_To_Local'>recordXid</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlogreader.h.html#LN217"><span class='Ref_to_Macro'>XLogRecGetXid</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5612"><span class='Ref_to_Parameter'>record</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN5615"><span class='Ref_To_Local'>xact_info</span></a> <span class='Operator'>== </span><a href="../../../include/access/xact.h.html#LN137"><span class='Ref_to_Const'>XLOG_XACT_ABORT_PREPARED</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN5680"></a>        <a href="../../../include/access/xact.h.html#LN268"><span class='Ref_to_Struct'>xl_xact_abort</span></a> <span class='Operator'>*</span><span class='Declare_Local'>xlrec</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/xact.h.html#LN268"><span class='Ref_to_Struct'>xl_xact_abort</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/access/xlogreader.h.html#LN219"><span class='Ref_to_Macro'>XLogRecGetData</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5612"><span class='Ref_to_Parameter'>record</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN5681"></a>        <a href="../../../include/access/xact.h.html#LN310"><span class='Ref_to_Struct'>xl_xact_parsed_abort</span></a> <span class='Declare_Local'>parsed</span><span class='Delimiter'>; 
</span> 
        <a href="xlog.c.html#LN5616"><span class='Ref_To_Local'>isCommit</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <a href="../rmgrdesc/xactdesc.c.html#LN120"><span class='Ref_to_Func'>ParseAbortRecord</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlogreader.h.html#LN215"><span class='Ref_to_Macro'>XLogRecGetInfo</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5612"><span class='Ref_to_Parameter'>record</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="xlog.c.html#LN5680"><span class='Ref_To_Local'>xlrec</span></a><span class='Delimiter'>, 
</span>                         <span class='Operator'>&</span><a href="xlog.c.html#LN5681"><span class='Ref_To_Local'>parsed</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN5618"><span class='Ref_To_Local'>recordXid</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN5681"><span class='Ref_To_Local'>parsed</span></a><span class='Operator'>.</span><a href="../../../include/access/xact.h.html#LN321"><span class='Ref_to_Member'>twophase_xid</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN259"><span class='Ref_to_Global_Var'>recoveryTarget</span></a> <span class='Operator'>== </span><a href="../../../include/access/xlog.h.html#LN82"><span class='Ref_to_EnumConst'>RECOVERY_TARGET_XID</span></a> <span class='Operator'>&& !</span><a href="xlog.c.html#LN260"><span class='Ref_to_Global_Var'>recoveryTargetInclusive</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * There can be only one transaction end record with this exact 
         * transactionid 
         * 
         * when testing for an xid, we MUST test for equality only, since 
         * transactions are numbered in the order they start, not the order 
         * they complete. A higher numbered xid will complete before you about 
         * 50% of the time... 
         */ 
</span>        <a href="xlog.c.html#LN5614"><span class='Ref_To_Local'>stopsHere</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="xlog.c.html#LN5618"><span class='Ref_To_Local'>recordXid</span></a> <span class='Operator'>== </span><a href="xlog.c.html#LN262"><span class='Ref_to_Global_Var'>recoveryTargetXid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN259"><span class='Ref_to_Global_Var'>recoveryTarget</span></a> <span class='Operator'>== </span><a href="../../../include/access/xlog.h.html#LN83"><span class='Ref_to_EnumConst'>RECOVERY_TARGET_TIME</span></a> <span class='Operator'>&& 
</span>        <a href="xlog.c.html#LN5576"><span class='Ref_to_Func'>getRecordTimestamp</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5612"><span class='Ref_to_Parameter'>record</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN5617"><span class='Ref_To_Local'>recordXtime</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * There can be many transactions that share the same commit time, so 
         * we stop after the last one, if we are inclusive, or stop at the 
         * first one if we are exclusive 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN260"><span class='Ref_to_Global_Var'>recoveryTargetInclusive</span></a><span class='Parentheses'>) 
</span>            <a href="xlog.c.html#LN5614"><span class='Ref_To_Local'>stopsHere</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="xlog.c.html#LN5617"><span class='Ref_To_Local'>recordXtime</span></a> <span class='Operator'>&GT; </span><a href="xlog.c.html#LN263"><span class='Ref_to_Global_Var'>recoveryTargetTime</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="xlog.c.html#LN5614"><span class='Ref_To_Local'>stopsHere</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="xlog.c.html#LN5617"><span class='Ref_To_Local'>recordXtime</span></a> <span class='Operator'>&GT;= </span><a href="xlog.c.html#LN263"><span class='Ref_to_Global_Var'>recoveryTargetTime</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN5614"><span class='Ref_To_Local'>stopsHere</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="xlog.c.html#LN289"><span class='Ref_to_Global_Var'>recoveryStopAfter</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN285"><span class='Ref_to_Global_Var'>recoveryStopXid</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN5618"><span class='Ref_To_Local'>recordXid</span></a><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN286"><span class='Ref_to_Global_Var'>recoveryStopTime</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN5617"><span class='Ref_To_Local'>recordXtime</span></a><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN287"><span class='Ref_to_Global_Var'>recoveryStopLSN</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN288"><span class='Ref_to_Global_Var'>recoveryStopName</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='String'>'\0'</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN5616"><span class='Ref_To_Local'>isCommit</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"recovery stopping before commit of transaction %u, time %s"</span><span class='Delimiter'>, 
</span>                            <a href="xlog.c.html#LN285"><span class='Ref_to_Global_Var'>recoveryStopXid</span></a><span class='Delimiter'>, 
</span>                            <a href="../../../bin/pg_waldump/compat.c.html#LN48"><span class='Ref_to_Func'>timestamptz_to_str</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN286"><span class='Ref_to_Global_Var'>recoveryStopTime</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"recovery stopping before abort of transaction %u, time %s"</span><span class='Delimiter'>, 
</span>                            <a href="xlog.c.html#LN285"><span class='Ref_to_Global_Var'>recoveryStopXid</span></a><span class='Delimiter'>, 
</span>                            <a href="../../../bin/pg_waldump/compat.c.html#LN48"><span class='Ref_to_Func'>timestamptz_to_str</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN286"><span class='Ref_to_Global_Var'>recoveryStopTime</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if stopsHere &raquo; </span> 
 
    <span class='Control'>return</span> <a href="xlog.c.html#LN5614"><span class='Ref_To_Local'>stopsHere</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end recoveryStopsBefore &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Same as recoveryStopsBefore, but called after applying the record. 
 * 
 * We also track the timestamp of the latest applied COMMIT/ABORT 
 * record in XLogCtl-&GT;recoveryLastXTime. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN5754"></a><span class='Declare_Function'>recoveryStopsAfter</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogreader.h.html#LN68"><span class='Ref_to_Struct'>XLogReaderState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>record</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN5756"></a>    <a href="../../../include/c.h.html#LN265"><span class='Ref_to_Typedef'>uint8</span></a>       <span class='Declare_Local'>info</span><span class='Delimiter'>; 
</span><a name="LN5757"></a>    <a href="../../../include/c.h.html#LN265"><span class='Ref_to_Typedef'>uint8</span></a>       <span class='Declare_Local'>xact_info</span><span class='Delimiter'>; 
</span><a name="LN5758"></a>    <a href="../../../include/c.h.html#LN265"><span class='Ref_to_Typedef'>uint8</span></a>       <span class='Declare_Local'>rmid</span><span class='Delimiter'>; 
</span><a name="LN5759"></a>    <a href="../../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <span class='Declare_Local'>recordXtime</span><span class='Delimiter'>; 
</span> 
    <a href="xlog.c.html#LN5756"><span class='Ref_To_Local'>info</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlogreader.h.html#LN215"><span class='Ref_to_Macro'>XLogRecGetInfo</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5754"><span class='Ref_to_Parameter'>record</span></a><span class='Parentheses'>) </span><span class='Operator'>& ~</span><a href="../../../include/access/xlogrecord.h.html#LN61"><span class='Ref_to_Const'>XLR_INFO_MASK</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN5758"><span class='Ref_To_Local'>rmid</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlogreader.h.html#LN216"><span class='Ref_to_Macro'>XLogRecGetRmid</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5754"><span class='Ref_to_Parameter'>record</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * There can be many restore points that share the same name; we stop at 
     * the first one. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN259"><span class='Ref_to_Global_Var'>recoveryTarget</span></a> <span class='Operator'>== </span><a href="../../../include/access/xlog.h.html#LN84"><span class='Ref_to_EnumConst'>RECOVERY_TARGET_NAME</span></a> <span class='Operator'>&& 
</span>        <a href="xlog.c.html#LN5758"><span class='Ref_To_Local'>rmid</span></a> <span class='Operator'>== </span>RM_XLOG_ID <span class='Operator'>&& </span><a href="xlog.c.html#LN5756"><span class='Ref_To_Local'>info</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_control.h.html#LN72"><span class='Ref_to_Const'>XLOG_RESTORE_POINT</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN5771"></a>        <a href="../../../include/access/xlog_internal.h.html#LN222"><span class='Ref_to_Struct'>xl_restore_point</span></a> <span class='Operator'>*</span><span class='Declare_Local'>recordRestorePointData</span><span class='Delimiter'>; 
</span> 
        <a href="xlog.c.html#LN5771"><span class='Ref_To_Local'>recordRestorePointData</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/xlog_internal.h.html#LN222"><span class='Ref_to_Struct'>xl_restore_point</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/access/xlogreader.h.html#LN219"><span class='Ref_to_Macro'>XLogRecGetData</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5754"><span class='Ref_to_Parameter'>record</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span><a href="xlog.c.html#LN5771"><span class='Ref_To_Local'>recordRestorePointData</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlog_internal.h.html#LN225"><span class='Ref_to_Member'>rp_name</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN264"><span class='Ref_to_Global_Var'>recoveryTargetName</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <a href="xlog.c.html#LN289"><span class='Ref_to_Global_Var'>recoveryStopAfter</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN285"><span class='Ref_to_Global_Var'>recoveryStopXid</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN287"><span class='Ref_to_Global_Var'>recoveryStopLSN</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>; 
</span>            <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="xlog.c.html#LN5576"><span class='Ref_to_Func'>getRecordTimestamp</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5754"><span class='Ref_to_Parameter'>record</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN286"><span class='Ref_to_Global_Var'>recoveryStopTime</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../port/strlcpy.c.html#LN43"><span class='Ref_to_Func'>strlcpy</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN288"><span class='Ref_to_Global_Var'>recoveryStopName</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN5771"><span class='Ref_To_Local'>recordRestorePointData</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlog_internal.h.html#LN225"><span class='Ref_to_Member'>rp_name</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xlog_internal.h.html#LN137"><span class='Ref_to_Const'>MAXFNAMELEN</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"recovery stopping at restore point \"%s\", time %s"</span><span class='Delimiter'>, 
</span>                        <a href="xlog.c.html#LN288"><span class='Ref_to_Global_Var'>recoveryStopName</span></a><span class='Delimiter'>, 
</span>                        <a href="../../../bin/pg_waldump/compat.c.html#LN48"><span class='Ref_to_Func'>timestamptz_to_str</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN286"><span class='Ref_to_Global_Var'>recoveryStopTime</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if recoveryTarget==RECOV... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* Check if the target LSN has been reached */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN259"><span class='Ref_to_Global_Var'>recoveryTarget</span></a> <span class='Operator'>== </span><a href="../../../include/access/xlog.h.html#LN85"><span class='Ref_to_EnumConst'>RECOVERY_TARGET_LSN</span></a> <span class='Operator'>&& 
</span>        <a href="xlog.c.html#LN260"><span class='Ref_to_Global_Var'>recoveryTargetInclusive</span></a> <span class='Operator'>&& 
</span>        <a href="xlog.c.html#LN5754"><span class='Ref_to_Parameter'>record</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogreader.h.html#LN113"><span class='Ref_to_Member'>ReadRecPtr</span></a> <span class='Operator'>&GT;= </span><a href="xlog.c.html#LN265"><span class='Ref_to_Global_Var'>recoveryTargetLSN</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="xlog.c.html#LN289"><span class='Ref_to_Global_Var'>recoveryStopAfter</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN285"><span class='Ref_to_Global_Var'>recoveryStopXid</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN287"><span class='Ref_to_Global_Var'>recoveryStopLSN</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN5754"><span class='Ref_to_Parameter'>record</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogreader.h.html#LN113"><span class='Ref_to_Member'>ReadRecPtr</span></a><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN286"><span class='Ref_to_Global_Var'>recoveryStopTime</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN288"><span class='Ref_to_Global_Var'>recoveryStopName</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='String'>'\0'</span><span class='Delimiter'>; 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>              <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"recovery stopping after WAL location (LSN) \"%X/%X\""</span><span class='Delimiter'>, 
</span>                      <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN287"><span class='Ref_to_Global_Var'>recoveryStopLSN</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                      <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN287"><span class='Ref_to_Global_Var'>recoveryStopLSN</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN5758"><span class='Ref_To_Local'>rmid</span></a> <span class='Operator'>!= </span>RM_XACT_ID<span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <a href="xlog.c.html#LN5757"><span class='Ref_To_Local'>xact_info</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN5756"><span class='Ref_To_Local'>info</span></a> <span class='Operator'>& </span><a href="../../../include/access/xact.h.html#LN143"><span class='Ref_to_Const'>XLOG_XACT_OPMASK</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN5757"><span class='Ref_To_Local'>xact_info</span></a> <span class='Operator'>== </span><a href="../../../include/access/xact.h.html#LN133"><span class='Ref_to_Const'>XLOG_XACT_COMMIT</span></a> <span class='Operator'>|| 
</span>        <a href="xlog.c.html#LN5757"><span class='Ref_To_Local'>xact_info</span></a> <span class='Operator'>== </span><a href="../../../include/access/xact.h.html#LN136"><span class='Ref_to_Const'>XLOG_XACT_COMMIT_PREPARED</span></a> <span class='Operator'>|| 
</span>        <a href="xlog.c.html#LN5757"><span class='Ref_To_Local'>xact_info</span></a> <span class='Operator'>== </span><a href="../../../include/access/xact.h.html#LN135"><span class='Ref_to_Const'>XLOG_XACT_ABORT</span></a> <span class='Operator'>|| 
</span>        <a href="xlog.c.html#LN5757"><span class='Ref_To_Local'>xact_info</span></a> <span class='Operator'>== </span><a href="../../../include/access/xact.h.html#LN137"><span class='Ref_to_Const'>XLOG_XACT_ABORT_PREPARED</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN5818"></a>        <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>recordXid</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Update the last applied transaction timestamp */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN5576"><span class='Ref_to_Func'>getRecordTimestamp</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5754"><span class='Ref_to_Parameter'>record</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN5759"><span class='Ref_To_Local'>recordXtime</span></a><span class='Parentheses'>))</span> 
            <a href="xlog.c.html#LN851"><span class='Ref_to_Proto'>SetLatestXTime</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5759"><span class='Ref_To_Local'>recordXtime</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Extract the XID of the committed/aborted transaction */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN5757"><span class='Ref_To_Local'>xact_info</span></a> <span class='Operator'>== </span><a href="../../../include/access/xact.h.html#LN136"><span class='Ref_to_Const'>XLOG_XACT_COMMIT_PREPARED</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN5827"></a>            <a href="../../../include/access/xact.h.html#LN254"><span class='Ref_to_Struct'>xl_xact_commit</span></a> <span class='Operator'>*</span><span class='Declare_Local'>xlrec</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/xact.h.html#LN254"><span class='Ref_to_Struct'>xl_xact_commit</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/access/xlogreader.h.html#LN219"><span class='Ref_to_Macro'>XLogRecGetData</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5754"><span class='Ref_to_Parameter'>record</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN5828"></a>            <a href="../../../include/access/xact.h.html#LN286"><span class='Ref_to_Struct'>xl_xact_parsed_commit</span></a> <span class='Declare_Local'>parsed</span><span class='Delimiter'>; 
</span> 
            <a href="../rmgrdesc/xactdesc.c.html#LN33"><span class='Ref_to_Func'>ParseCommitRecord</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlogreader.h.html#LN215"><span class='Ref_to_Macro'>XLogRecGetInfo</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5754"><span class='Ref_to_Parameter'>record</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                              <a href="xlog.c.html#LN5827"><span class='Ref_To_Local'>xlrec</span></a><span class='Delimiter'>, 
</span>                              <span class='Operator'>&</span><a href="xlog.c.html#LN5828"><span class='Ref_To_Local'>parsed</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN5818"><span class='Ref_To_Local'>recordXid</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN5828"><span class='Ref_To_Local'>parsed</span></a><span class='Operator'>.</span><a href="../../../include/access/xact.h.html#LN304"><span class='Ref_to_Member'>twophase_xid</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN5757"><span class='Ref_To_Local'>xact_info</span></a> <span class='Operator'>== </span><a href="../../../include/access/xact.h.html#LN137"><span class='Ref_to_Const'>XLOG_XACT_ABORT_PREPARED</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN5837"></a>            <a href="../../../include/access/xact.h.html#LN268"><span class='Ref_to_Struct'>xl_xact_abort</span></a> <span class='Operator'>*</span><span class='Declare_Local'>xlrec</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/xact.h.html#LN268"><span class='Ref_to_Struct'>xl_xact_abort</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/access/xlogreader.h.html#LN219"><span class='Ref_to_Macro'>XLogRecGetData</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5754"><span class='Ref_to_Parameter'>record</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN5838"></a>            <a href="../../../include/access/xact.h.html#LN310"><span class='Ref_to_Struct'>xl_xact_parsed_abort</span></a> <span class='Declare_Local'>parsed</span><span class='Delimiter'>; 
</span> 
            <a href="../rmgrdesc/xactdesc.c.html#LN120"><span class='Ref_to_Func'>ParseAbortRecord</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlogreader.h.html#LN215"><span class='Ref_to_Macro'>XLogRecGetInfo</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5754"><span class='Ref_to_Parameter'>record</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                             <a href="xlog.c.html#LN5837"><span class='Ref_To_Local'>xlrec</span></a><span class='Delimiter'>, 
</span>                             <span class='Operator'>&</span><a href="xlog.c.html#LN5838"><span class='Ref_To_Local'>parsed</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN5818"><span class='Ref_To_Local'>recordXid</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN5838"><span class='Ref_To_Local'>parsed</span></a><span class='Operator'>.</span><a href="../../../include/access/xact.h.html#LN321"><span class='Ref_to_Member'>twophase_xid</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
            <a href="xlog.c.html#LN5818"><span class='Ref_To_Local'>recordXid</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlogreader.h.html#LN217"><span class='Ref_to_Macro'>XLogRecGetXid</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5754"><span class='Ref_to_Parameter'>record</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * There can be only one transaction end record with this exact 
         * transactionid 
         * 
         * when testing for an xid, we MUST test for equality only, since 
         * transactions are numbered in the order they start, not the order 
         * they complete. A higher numbered xid will complete before you about 
         * 50% of the time... 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN259"><span class='Ref_to_Global_Var'>recoveryTarget</span></a> <span class='Operator'>== </span><a href="../../../include/access/xlog.h.html#LN82"><span class='Ref_to_EnumConst'>RECOVERY_TARGET_XID</span></a> <span class='Operator'>&& </span><a href="xlog.c.html#LN260"><span class='Ref_to_Global_Var'>recoveryTargetInclusive</span></a> <span class='Operator'>&& 
</span>            <a href="xlog.c.html#LN5818"><span class='Ref_To_Local'>recordXid</span></a> <span class='Operator'>== </span><a href="xlog.c.html#LN262"><span class='Ref_to_Global_Var'>recoveryTargetXid</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="xlog.c.html#LN289"><span class='Ref_to_Global_Var'>recoveryStopAfter</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN285"><span class='Ref_to_Global_Var'>recoveryStopXid</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN5818"><span class='Ref_To_Local'>recordXid</span></a><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN286"><span class='Ref_to_Global_Var'>recoveryStopTime</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN5759"><span class='Ref_To_Local'>recordXtime</span></a><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN287"><span class='Ref_to_Global_Var'>recoveryStopLSN</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN288"><span class='Ref_to_Global_Var'>recoveryStopName</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='String'>'\0'</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN5757"><span class='Ref_To_Local'>xact_info</span></a> <span class='Operator'>== </span><a href="../../../include/access/xact.h.html#LN133"><span class='Ref_to_Const'>XLOG_XACT_COMMIT</span></a> <span class='Operator'>|| 
</span>                <a href="xlog.c.html#LN5757"><span class='Ref_To_Local'>xact_info</span></a> <span class='Operator'>== </span><a href="../../../include/access/xact.h.html#LN136"><span class='Ref_to_Const'>XLOG_XACT_COMMIT_PREPARED</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"recovery stopping after commit of transaction %u, time %s"</span><span class='Delimiter'>, 
</span>                                <a href="xlog.c.html#LN285"><span class='Ref_to_Global_Var'>recoveryStopXid</span></a><span class='Delimiter'>, 
</span>                                <a href="../../../bin/pg_waldump/compat.c.html#LN48"><span class='Ref_to_Func'>timestamptz_to_str</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN286"><span class='Ref_to_Global_Var'>recoveryStopTime</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN5757"><span class='Ref_To_Local'>xact_info</span></a> <span class='Operator'>== </span><a href="../../../include/access/xact.h.html#LN135"><span class='Ref_to_Const'>XLOG_XACT_ABORT</span></a> <span class='Operator'>|| 
</span>                     <a href="xlog.c.html#LN5757"><span class='Ref_To_Local'>xact_info</span></a> <span class='Operator'>== </span><a href="../../../include/access/xact.h.html#LN137"><span class='Ref_to_Const'>XLOG_XACT_ABORT_PREPARED</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"recovery stopping after abort of transaction %u, time %s"</span><span class='Delimiter'>, 
</span>                                <a href="xlog.c.html#LN285"><span class='Ref_to_Global_Var'>recoveryStopXid</span></a><span class='Delimiter'>, 
</span>                                <a href="../../../bin/pg_waldump/compat.c.html#LN48"><span class='Ref_to_Func'>timestamptz_to_str</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN286"><span class='Ref_to_Global_Var'>recoveryStopTime</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if recoveryTarget==RECOV... &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if xact_info==XLOG_XACT_... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* Check if we should stop as soon as reaching consistency */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN259"><span class='Ref_to_Global_Var'>recoveryTarget</span></a> <span class='Operator'>== </span><a href="../../../include/access/xlog.h.html#LN86"><span class='Ref_to_EnumConst'>RECOVERY_TARGET_IMMEDIATE</span></a> <span class='Operator'>&& </span><a href="xlog.c.html#LN830"><span class='Ref_to_Global_Var'>reachedConsistency</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"recovery stopping after reaching consistency"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <a href="xlog.c.html#LN289"><span class='Ref_to_Global_Var'>recoveryStopAfter</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN285"><span class='Ref_to_Global_Var'>recoveryStopXid</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN286"><span class='Ref_to_Global_Var'>recoveryStopTime</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN287"><span class='Ref_to_Global_Var'>recoveryStopLSN</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN288"><span class='Ref_to_Global_Var'>recoveryStopName</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='String'>'\0'</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end recoveryStopsAfter &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Wait until shared recoveryPause flag is cleared. 
 * 
 * XXX Could also be done with shared latch, avoiding the pg_usleep loop. 
 * Probably not worth the trouble though.  This state shouldn't be one that 
 * anyone cares about server power consumption in. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN5911"></a><span class='Declare_Function'>recoveryPausesHere</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* Don't pause unless users can connect! */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN220"><span class='Ref_to_Global_Var'>LocalHotStandbyActive</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>            <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"recovery has paused"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>             <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"Execute pg_wal_replay_resume() to continue."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN250"><span class='Ref_to_Proto'>RecoveryIsPaused</span></a><span class='Parentheses'>())</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../port/pgsleep.c.html#LN45"><span class='Ref_to_Func'>pg_usleep</span></a><span class='Parentheses'>(</span><span class='Number'>1000000L</span><span class='Parentheses'>)</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* 1000 ms */ 
</span>        <a href="../../../include/postmaster/startup.h.html#LN14"><span class='Ref_to_Proto'>HandleStartupProcInterrupts</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
} 
</span> 
<span class='Keyword'>bool 
</span><a name="LN5929"></a><span class='Declare_Function'>RecoveryIsPaused</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN5931"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>recoveryPause</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN5931"><span class='Ref_To_Local'>recoveryPause</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN694"><span class='Ref_to_Member'>recoveryPause</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="xlog.c.html#LN5931"><span class='Ref_To_Local'>recoveryPause</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Keyword'>void 
</span><a name="LN5941"></a><span class='Declare_Function'>SetRecoveryPause</span><span class='Parentheses'>(</span><span class='Keyword'>bool </span><span class='Declare_Parameter'>recoveryPause</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN694"><span class='Ref_to_Member'>recoveryPause</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN5941"><span class='Ref_to_Parameter'>recoveryPause</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * When recovery_min_apply_delay is set, we wait long enough to make sure 
 * certain record types are applied at least that interval behind the master. 
 * 
 * Returns true if we waited. 
 * 
 * Note that the delay is calculated between the WAL record log time and 
 * the current time on standby. We would prefer to keep track of when this 
 * standby received each WAL record, which would allow a more consistent 
 * approach and one not affected by time synchronisation issues, but that 
 * is significantly more effort and complexity for little actual gain in 
 * usability. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN5962"></a><span class='Declare_Function'>recoveryApplyDelay</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogreader.h.html#LN68"><span class='Ref_to_Struct'>XLogReaderState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>record</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN5964"></a>    <a href="../../../include/c.h.html#LN265"><span class='Ref_to_Typedef'>uint8</span></a>       <span class='Declare_Local'>xact_info</span><span class='Delimiter'>; 
</span><a name="LN5965"></a>    <a href="../../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <span class='Declare_Local'>xtime</span><span class='Delimiter'>; 
</span><a name="LN5966"></a>    <span class='Keyword'>long</span>        <span class='Declare_Local'>secs</span><span class='Delimiter'>; 
</span><a name="LN5967"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>microsecs</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* nothing to do if no delay configured */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN266"><span class='Ref_to_Global_Var'>recovery_min_apply_delay</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* no delay is applied on a database not yet consistent */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN830"><span class='Ref_to_Global_Var'>reachedConsistency</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Is it a COMMIT record? 
     * 
     * We deliberately choose not to delay aborts since they have no effect on 
     * MVCC. We already allow replay of records that don't have a timestamp, 
     * so there is already opportunity for issues caused by early conflicts on 
     * standbys. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/xlogreader.h.html#LN216"><span class='Ref_to_Macro'>XLogRecGetRmid</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5962"><span class='Ref_to_Parameter'>record</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span>RM_XACT_ID<span class='Parentheses'>)</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <a href="xlog.c.html#LN5964"><span class='Ref_To_Local'>xact_info</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlogreader.h.html#LN215"><span class='Ref_to_Macro'>XLogRecGetInfo</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5962"><span class='Ref_to_Parameter'>record</span></a><span class='Parentheses'>) </span><span class='Operator'>& </span><a href="../../../include/access/xact.h.html#LN143"><span class='Ref_to_Const'>XLOG_XACT_OPMASK</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN5964"><span class='Ref_To_Local'>xact_info</span></a> <span class='Operator'>!= </span><a href="../../../include/access/xact.h.html#LN133"><span class='Ref_to_Const'>XLOG_XACT_COMMIT</span></a> <span class='Operator'>&& 
</span>        <a href="xlog.c.html#LN5964"><span class='Ref_To_Local'>xact_info</span></a> <span class='Operator'>!= </span><a href="../../../include/access/xact.h.html#LN136"><span class='Ref_to_Const'>XLOG_XACT_COMMIT_PREPARED</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN5576"><span class='Ref_to_Func'>getRecordTimestamp</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5962"><span class='Ref_to_Parameter'>record</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN5965"><span class='Ref_To_Local'>xtime</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <a href="xlog.c.html#LN267"><span class='Ref_to_Global_Var'>recoveryDelayUntilTime</span></a> <span class='Operator'>= 
</span>        <a href="../../../include/utils/timestamp.h.html#LN55"><span class='Ref_to_Macro'>TimestampTzPlusMilliseconds</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN5965"><span class='Ref_To_Local'>xtime</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN266"><span class='Ref_to_Global_Var'>recovery_min_apply_delay</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Exit without arming the latch if it's already past time to apply this 
     * record 
     */ 
</span>    <a href="../../../include/utils/timestamp.h.html#LN72"><span class='Ref_to_Proto'>TimestampDifference</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/timestamp.h.html#LN69"><span class='Ref_to_Proto'>GetCurrentTimestamp</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN267"><span class='Ref_to_Global_Var'>recoveryDelayUntilTime</span></a><span class='Delimiter'>, 
</span>                        <span class='Operator'>&</span><a href="xlog.c.html#LN5966"><span class='Ref_To_Local'>secs</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN5967"><span class='Ref_To_Local'>microsecs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN5966"><span class='Ref_To_Local'>secs</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="xlog.c.html#LN5967"><span class='Ref_To_Local'>microsecs</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>while</span> <span class='Parentheses'>(</span><span class='Boolean'>true</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/storage/latch.h.html#LN152"><span class='Ref_to_Proto'>ResetLatch</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN661"><span class='Ref_to_Member'>recoveryWakeupLatch</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* might change the trigger file's location */ 
</span>        <a href="../../../include/postmaster/startup.h.html#LN14"><span class='Ref_to_Proto'>HandleStartupProcInterrupts</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN895"><span class='Ref_to_Proto'>CheckForStandbyTrigger</span></a><span class='Parentheses'>())</span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Wait for difference between GetCurrentTimestamp() and 
         * recoveryDelayUntilTime 
         */ 
</span>        <a href="../../../include/utils/timestamp.h.html#LN72"><span class='Ref_to_Proto'>TimestampDifference</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/timestamp.h.html#LN69"><span class='Ref_to_Proto'>GetCurrentTimestamp</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN267"><span class='Ref_to_Global_Var'>recoveryDelayUntilTime</span></a><span class='Delimiter'>, 
</span>                            <span class='Operator'>&</span><a href="xlog.c.html#LN5966"><span class='Ref_To_Local'>secs</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN5967"><span class='Ref_To_Local'>microsecs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* NB: We're ignoring waits below min_apply_delay's resolution. */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN5966"><span class='Ref_To_Local'>secs</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="xlog.c.html#LN5967"><span class='Ref_To_Local'>microsecs</span></a> <span class='Operator'>/ </span><span class='Number'>1000</span> <span class='Operator'>&LT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Delimiter'>, </span><span class='String'>"recovery apply delay %ld seconds, %d milliseconds"</span><span class='Delimiter'>, 
</span>             <a href="xlog.c.html#LN5966"><span class='Ref_To_Local'>secs</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN5967"><span class='Ref_To_Local'>microsecs</span></a> <span class='Operator'>/ </span><span class='Number'>1000</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/storage/latch.h.html#LN163"><span class='Ref_to_Proto'>WaitLatch</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN661"><span class='Ref_to_Member'>recoveryWakeupLatch</span></a><span class='Delimiter'>, 
</span>                  <a href="../../../include/storage/latch.h.html#LN123"><span class='Ref_to_Const'>WL_LATCH_SET</span></a> <span class='Operator'>| </span><a href="../../../include/storage/latch.h.html#LN126"><span class='Ref_to_Const'>WL_TIMEOUT</span></a> <span class='Operator'>| </span><a href="../../../include/storage/latch.h.html#LN127"><span class='Ref_to_Const'>WL_POSTMASTER_DEATH</span></a><span class='Delimiter'>, 
</span>                  <a href="xlog.c.html#LN5966"><span class='Ref_To_Local'>secs</span></a> <span class='Operator'>* </span><span class='Number'>1000L</span> <span class='Operator'>+ </span><a href="xlog.c.html#LN5967"><span class='Ref_To_Local'>microsecs</span></a> <span class='Operator'>/ </span><span class='Number'>1000</span><span class='Delimiter'>, 
</span>                  <a href="../../../include/pgstat.h.html#LN827"><span class='Ref_to_EnumConst'>WAIT_EVENT_RECOVERY_APPLY_DELAY</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while true &raquo; </span> 
    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end recoveryApplyDelay &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Save timestamp of latest processed commit/abort record. 
 * 
 * We keep this in XLogCtl, not a simple static variable, so that it can be 
 * seen by processes other than the startup process.  Note in particular 
 * that CreateRestartPoint is executed in the checkpointer. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN6049"></a><span class='Declare_Function'>SetLatestXTime</span><span class='Parentheses'>(</span><a href="../../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <span class='Declare_Parameter'>xtime</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN686"><span class='Ref_to_Member'>recoveryLastXTime</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN6049"><span class='Ref_to_Parameter'>xtime</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Fetch timestamp of latest processed commit/abort record. 
 */ 
</span><a href="../../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> 
<a name="LN6060"></a><span class='Declare_Function'>GetLatestXTime</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN6062"></a>    <a href="../../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <span class='Declare_Local'>xtime</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN6062"><span class='Ref_To_Local'>xtime</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN686"><span class='Ref_to_Member'>recoveryLastXTime</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="xlog.c.html#LN6062"><span class='Ref_To_Local'>xtime</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Save timestamp of the next chunk of WAL records to apply. 
 * 
 * We keep this in XLogCtl, not a simple static variable, so that it can be 
 * seen by all backends. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN6078"></a><span class='Declare_Function'>SetCurrentChunkStartTime</span><span class='Parentheses'>(</span><a href="../../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <span class='Declare_Parameter'>xtime</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN692"><span class='Ref_to_Member'>currentChunkStartTime</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN6078"><span class='Ref_to_Parameter'>xtime</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Fetch timestamp of latest processed commit/abort record. 
 * Startup process maintains an accurate local copy in XLogReceiptTime 
 */ 
</span><a href="../../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> 
<a name="LN6090"></a><span class='Declare_Function'>GetCurrentChunkReplayStartTime</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN6092"></a>    <a href="../../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <span class='Declare_Local'>xtime</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN6092"><span class='Ref_To_Local'>xtime</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN692"><span class='Ref_to_Member'>currentChunkStartTime</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="xlog.c.html#LN6092"><span class='Ref_To_Local'>xtime</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Returns time of receipt of current chunk of XLOG data, as well as 
 * whether it was received from streaming replication or from archives. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN6106"></a><span class='Declare_Function'>GetXLogReceiptTime</span><span class='Parentheses'>(</span><a href="../../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rtime</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>fromStream</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * This must be executed in the startup process, since we don't export the 
     * relevant state to shared memory. 
     */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN191"><span class='Ref_to_Global_Var'>InRecovery</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Operator'>*</span><a href="xlog.c.html#LN6106"><span class='Ref_to_Parameter'>rtime</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN813"><span class='Ref_to_Global_Var'>XLogReceiptTime</span></a><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="xlog.c.html#LN6106"><span class='Ref_to_Parameter'>fromStream</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="xlog.c.html#LN814"><span class='Ref_to_Global_Var'>XLogReceiptSource</span></a> <span class='Operator'>== </span><a href="xlog.c.html#LN758"><span class='Ref_to_EnumConst'>XLOG_FROM_STREAM</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Note that text field supplied is a parameter name and does not require 
 * translation 
 */ 
</span><a name="LN6122"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>RecoveryRequiresIntParameter</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>param_name</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>currValue</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>minValue</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span><span class='Control'>do</span> <span class='Delimiter'>{ </span><span class='Operator'>\ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="xlog.c.html#LN6122"><span class='Ref_to_Parameter'>currValue</span></a><span class='Parentheses'>) </span><span class='Operator'>&LT; </span><span class='Parentheses'>(</span><a href="xlog.c.html#LN6122"><span class='Ref_to_Parameter'>minValue</span></a><span class='Parentheses'>))</span> <span class='Operator'>\ 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='Operator'>\ 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_INVALID_PARAMETER_VALUE<span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Operator'>\ 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"hot standby is not possible because "</span> <span class='Operator'>\ 
</span>                        <span class='String'>"%s = %d is a lower setting than on the master server "</span> <span class='Operator'>\ 
</span>                        <span class='String'>"(its value was %d)"</span><span class='Delimiter'>, </span><span class='Operator'>\ 
</span>                        <a href="xlog.c.html#LN6122"><span class='Ref_to_Parameter'>param_name</span></a><span class='Delimiter'>, </span><span class='Operator'>\ 
</span>                        <a href="xlog.c.html#LN6122"><span class='Ref_to_Parameter'>currValue</span></a><span class='Delimiter'>, </span><span class='Operator'>\ 
</span>                        <a href="xlog.c.html#LN6122"><span class='Ref_to_Parameter'>minValue</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; </span><span class='Operator'>\ 
</span><span class='Delimiter'>} </span><span class='Control'>while</span><span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>) 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Check to see if required parameters are set high enough on this server 
 * for various aspects of recovery operation. 
 * 
 * Note that all the parameters which this function tests need to be 
 * listed in Administrator's Overview section in high-availability.sgml. 
 * If you change them, don't forget to update the list. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN6144"></a><span class='Declare_Function'>CheckRequiredParameterValues</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * For archive recovery, the WAL must be generated with at least 'replica' 
     * wal_level. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN245"><span class='Ref_to_Global_Var'>ArchiveRecoveryRequested</span></a> <span class='Operator'>&& </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN179"><span class='Ref_to_Member'>wal_level</span></a> <span class='Operator'>== </span><a href="../../../include/access/xlog.h.html#LN125"><span class='Ref_to_EnumConst'>WAL_LEVEL_MINIMAL</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN39"><span class='Ref_to_Const'>WARNING</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"WAL was generated with wal_level=minimal, data may be missing"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"This happens if you temporarily set wal_level=minimal without taking a new base backup."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * For Hot Standby, the WAL must be generated with 'replica' mode, and we 
     * must have at least as many backend slots as the primary. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN245"><span class='Ref_to_Global_Var'>ArchiveRecoveryRequested</span></a> <span class='Operator'>&& </span><a href="xlog.c.html#LN95"><span class='Ref_to_Global_Var'>EnableHotStandby</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN179"><span class='Ref_to_Member'>wal_level</span></a> <span class='Operator'>&LT; </span><a href="../../../include/access/xlog.h.html#LN126"><span class='Ref_to_EnumConst'>WAL_LEVEL_REPLICA</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"hot standby is not possible because wal_level was not set to \"replica\" or higher on the master server"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"Either set wal_level to \"replica\" on the master, or turn off hot_standby here."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* We ignore autovacuum_max_workers when we make this test. */ 
</span>        <a href="xlog.c.html#LN6122"><span class='Ref_to_Macro'>RecoveryRequiresIntParameter</span></a><span class='Parentheses'>(</span><span class='String'>"max_connections"</span><span class='Delimiter'>, 
</span>                                     <a href="../../utils/init/globals.c.html#LN123"><span class='Ref_to_Global_Var'>MaxConnections</span></a><span class='Delimiter'>, 
</span>                                     <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN181"><span class='Ref_to_Member'>MaxConnections</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN6122"><span class='Ref_to_Macro'>RecoveryRequiresIntParameter</span></a><span class='Parentheses'>(</span><span class='String'>"max_worker_processes"</span><span class='Delimiter'>, 
</span>                                     <a href="../../utils/init/globals.c.html#LN124"><span class='Ref_to_Global_Var'>max_worker_processes</span></a><span class='Delimiter'>, 
</span>                                     <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN182"><span class='Ref_to_Member'>max_worker_processes</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN6122"><span class='Ref_to_Macro'>RecoveryRequiresIntParameter</span></a><span class='Parentheses'>(</span><span class='String'>"max_prepared_transactions"</span><span class='Delimiter'>, 
</span>                                     <a href="twophase.c.html#LN116"><span class='Ref_to_Global_Var'>max_prepared_xacts</span></a><span class='Delimiter'>, 
</span>                                     <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN183"><span class='Ref_to_Member'>max_prepared_xacts</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN6122"><span class='Ref_to_Macro'>RecoveryRequiresIntParameter</span></a><span class='Parentheses'>(</span><span class='String'>"max_locks_per_transaction"</span><span class='Delimiter'>, 
</span>                                     <a href="../../storage/lmgr/lock.c.html#LN53"><span class='Ref_to_Global_Var'>max_locks_per_xact</span></a><span class='Delimiter'>, 
</span>                                     <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN184"><span class='Ref_to_Member'>max_locks_per_xact</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if ArchiveRecoveryReques... &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end CheckRequiredParameterValues &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * This must be called ONCE during postmaster or standalone-backend startup 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN6188"></a><span class='Declare_Function'>StartupXLOG</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN6190"></a>    <a href="xlog.c.html#LN514"><span class='Ref_to_Struct'>XLogCtlInsert</span></a> <span class='Operator'>*</span><span class='Declare_Local'>Insert</span><span class='Delimiter'>; 
</span><a name="LN6191"></a>    <a href="../../../include/catalog/pg_control.h.html#LN32"><span class='Ref_to_Struct'>CheckPoint</span></a>  <span class='Declare_Local'>checkPoint</span><span class='Delimiter'>; 
</span><a name="LN6192"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>wasShutdown</span><span class='Delimiter'>; 
</span><a name="LN6193"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>reachedStopPoint</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN6194"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>haveBackupLabel</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN6195"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>haveTblspcMap</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN6196"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>RecPtr</span><span class='Delimiter'>, 
</span><a name="LN6197"></a>                <span class='Declare_Local'>checkPointLoc</span><span class='Delimiter'>, 
</span><a name="LN6198"></a>                <span class='Declare_Local'>EndOfLog</span><span class='Delimiter'>; 
</span><a name="LN6199"></a>    <a href="../../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a>  <span class='Declare_Local'>EndOfLogTLI</span><span class='Delimiter'>; 
</span><a name="LN6200"></a>    <a href="../../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a>  <span class='Declare_Local'>PrevTimeLineID</span><span class='Delimiter'>; 
</span><a name="LN6201"></a>    <a href="../../../include/access/xlogrecord.h.html#LN40"><span class='Ref_to_Struct'>XLogRecord</span></a> <span class='Operator'>*</span><span class='Declare_Local'>record</span><span class='Delimiter'>; 
</span><a name="LN6202"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>oldestActiveXID</span><span class='Delimiter'>; 
</span><a name="LN6203"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>backupEndRequired</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN6204"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>backupFromStandby</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN6205"></a>    <a href="../../../include/catalog/pg_control.h.html#LN83"><span class='Ref_to_Enum'>DBState</span></a>     <span class='Declare_Local'>dbstate_at_startup</span><span class='Delimiter'>; 
</span><a name="LN6206"></a>    <a href="../../../include/access/xlogreader.h.html#LN68"><span class='Ref_to_Struct'>XLogReaderState</span></a> <span class='Operator'>*</span><span class='Declare_Local'>xlogreader</span><span class='Delimiter'>; 
</span><a name="LN6207"></a>    <a href="../../../bin/pg_rewind/parsexlog.c.html#LN44"><span class='Ref_to_Struct'>XLogPageReadPrivate</span></a> <span class='Declare_Local'>private</span><span class='Delimiter'>; 
</span><a name="LN6208"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>fast_promoted</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN6209"></a>    <span class='Control'>struct</span> <a href="../../../include/port.h.html#LN275"><span class='Ref_to_Macro'>stat</span></a> <span class='Declare_Local'>st</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Read control file and check XLOG status looks valid. 
     * 
     * Note: in most control paths, *ControlFile is already valid and we need 
     * not do ReadControlFile() here, but might as well do it to be sure. 
     */ 
</span>    <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN74"><span class='Ref_to_Proto'>ReadControlFile</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN129"><span class='Ref_to_Member'>state</span></a> <span class='Operator'>&LT; </span><a href="../../../include/catalog/pg_control.h.html#LN86"><span class='Ref_to_EnumConst'>DB_SHUTDOWNED</span></a> <span class='Operator'>|| 
</span>        <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN129"><span class='Ref_to_Member'>state</span></a> <span class='Operator'>&GT; </span><a href="../../../include/catalog/pg_control.h.html#LN91"><span class='Ref_to_EnumConst'>DB_IN_PRODUCTION</span></a> <span class='Operator'>|| 
</span>        <span class='Operator'>!</span><a href="../../../include/access/xlog_internal.h.html#LN124"><span class='Ref_to_Macro'>XRecOffIsValid</span></a><span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN131"><span class='Ref_to_Member'>checkPoint</span></a><span class='Parentheses'>))</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"control file contains invalid data"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN129"><span class='Ref_to_Member'>state</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_control.h.html#LN86"><span class='Ref_to_EnumConst'>DB_SHUTDOWNED</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* This is the expected case, so don't be chatty in standalone mode */ 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../utils/init/globals.c.html#LN99"><span class='Ref_to_Global_Var'>IsPostmasterEnvironment</span></a> <span class='Operator'>? </span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a> <span class='Operator'>: </span><a href="../../../include/utils/elog.h.html#LN36"><span class='Ref_to_Const'>NOTICE</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"database system was shut down at %s"</span><span class='Delimiter'>, 
</span>                        <a href="xlog.c.html#LN894"><span class='Ref_to_Proto'>str_time</span></a><span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN130"><span class='Ref_to_Member'>time</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN129"><span class='Ref_to_Member'>state</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_control.h.html#LN87"><span class='Ref_to_EnumConst'>DB_SHUTDOWNED_IN_RECOVERY</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"database system was shut down in recovery at %s"</span><span class='Delimiter'>, 
</span>                        <a href="xlog.c.html#LN894"><span class='Ref_to_Proto'>str_time</span></a><span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN130"><span class='Ref_to_Member'>time</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN129"><span class='Ref_to_Member'>state</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_control.h.html#LN88"><span class='Ref_to_EnumConst'>DB_SHUTDOWNING</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"database system shutdown was interrupted; last known up at %s"</span><span class='Delimiter'>, 
</span>                        <a href="xlog.c.html#LN894"><span class='Ref_to_Proto'>str_time</span></a><span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN130"><span class='Ref_to_Member'>time</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN129"><span class='Ref_to_Member'>state</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_control.h.html#LN89"><span class='Ref_to_EnumConst'>DB_IN_CRASH_RECOVERY</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>           <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"database system was interrupted while in recovery at %s"</span><span class='Delimiter'>, 
</span>                   <a href="xlog.c.html#LN894"><span class='Ref_to_Proto'>str_time</span></a><span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN130"><span class='Ref_to_Member'>time</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>            <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"This probably means that some data is corrupted and"</span> 
                    <span class='String'>" you will have to use the last backup for recovery."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN129"><span class='Ref_to_Member'>state</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_control.h.html#LN90"><span class='Ref_to_EnumConst'>DB_IN_ARCHIVE_RECOVERY</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"database system was interrupted while in recovery at log time %s"</span><span class='Delimiter'>, 
</span>                        <a href="xlog.c.html#LN894"><span class='Ref_to_Proto'>str_time</span></a><span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN134"><span class='Ref_to_Member'>checkPointCopy</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN49"><span class='Ref_to_Member'>time</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"If this has occurred more than once some data might be corrupted"</span> 
              <span class='String'>" and you might need to choose an earlier recovery target."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN129"><span class='Ref_to_Member'>state</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_control.h.html#LN91"><span class='Ref_to_EnumConst'>DB_IN_PRODUCTION</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>              <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"database system was interrupted; last known up at %s"</span><span class='Delimiter'>, 
</span>                      <a href="xlog.c.html#LN894"><span class='Ref_to_Proto'>str_time</span></a><span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN130"><span class='Ref_to_Member'>time</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* This is just to allow attaching to startup process with a debugger */ 
</span><span class='Directive'>#ifdef</span> XLOG_REPLAY_DELAY 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN129"><span class='Ref_to_Member'>state</span></a> <span class='Operator'>!= </span><a href="../../../include/catalog/pg_control.h.html#LN86"><span class='Ref_to_EnumConst'>DB_SHUTDOWNED</span></a><span class='Parentheses'>) 
</span>        <a href="../../../port/pgsleep.c.html#LN45"><span class='Ref_to_Func'>pg_usleep</span></a><span class='Parentheses'>(</span><span class='Number'>60000000L</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Verify that pg_wal and pg_wal/archive_status exist.  In cases where 
     * someone has performed a copy for PITR, these directories may have been 
     * excluded and need to be re-created. 
     */ 
</span>    <a href="xlog.c.html#LN883"><span class='Ref_to_Proto'>ValidateXLOGDirectoryStructure</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we previously crashed, there might be data which we had written, 
     * intending to fsync it, but which we had not actually fsync'd yet. 
     * Therefore, a power failure in the near future might cause earlier 
     * unflushed writes to be lost, even though more recent data written to 
     * disk from here on would be persisted.  To avoid that, fsync the entire 
     * data directory. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN129"><span class='Ref_to_Member'>state</span></a> <span class='Operator'>!= </span><a href="../../../include/catalog/pg_control.h.html#LN86"><span class='Ref_to_EnumConst'>DB_SHUTDOWNED</span></a> <span class='Operator'>&& 
</span>        <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN129"><span class='Ref_to_Member'>state</span></a> <span class='Operator'>!= </span><a href="../../../include/catalog/pg_control.h.html#LN87"><span class='Ref_to_EnumConst'>DB_SHUTDOWNED_IN_RECOVERY</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/fd.h.html#LN123"><span class='Ref_to_Proto'>SyncDataDirectory</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Initialize on the assumption we want to recover to the latest timeline 
     * that's active according to pg_control. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN170"><span class='Ref_to_Member'>minRecoveryPointTLI</span></a> <span class='Operator'>&GT; 
</span>        <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN134"><span class='Ref_to_Member'>checkPointCopy</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN36"><span class='Ref_to_Member'>ThisTimeLineID</span></a><span class='Parentheses'>) 
</span>        <a href="xlog.c.html#LN315"><span class='Ref_to_Global_Var'>recoveryTargetTLI</span></a> <span class='Operator'>= </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN170"><span class='Ref_to_Member'>minRecoveryPointTLI</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="xlog.c.html#LN315"><span class='Ref_to_Global_Var'>recoveryTargetTLI</span></a> <span class='Operator'>= </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN134"><span class='Ref_to_Member'>checkPointCopy</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN36"><span class='Ref_to_Member'>ThisTimeLineID</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Check for recovery control file, and if so set up state for offline 
     * recovery 
     */ 
</span>    <a href="xlog.c.html#LN845"><span class='Ref_to_Proto'>readRecoveryCommandFile</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Save archive_cleanup_command in shared memory so that other processes 
     * can see it. 
     */ 
</span>    <a href="../../../port/strlcpy.c.html#LN43"><span class='Ref_to_Func'>strlcpy</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN635"><span class='Ref_to_Member'>archiveCleanupCommand</span></a><span class='Delimiter'>, 
</span>            <a href="xlog.c.html#LN258"><span class='Ref_to_Global_Var'>archiveCleanupCommand</span></a> <span class='Operator'>? </span><a href="xlog.c.html#LN258"><span class='Ref_to_Global_Var'>archiveCleanupCommand</span></a> <span class='Operator'>: </span><span class='String'>""</span><span class='Delimiter'>, 
</span>            <span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN635"><span class='Ref_to_Member'>archiveCleanupCommand</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN245"><span class='Ref_to_Global_Var'>ArchiveRecoveryRequested</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN270"><span class='Ref_to_Global_Var'>StandbyModeRequested</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"entering standby mode"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN259"><span class='Ref_to_Global_Var'>recoveryTarget</span></a> <span class='Operator'>== </span><a href="../../../include/access/xlog.h.html#LN82"><span class='Ref_to_EnumConst'>RECOVERY_TARGET_XID</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"starting point-in-time recovery to XID %u"</span><span class='Delimiter'>, 
</span>                            <a href="xlog.c.html#LN262"><span class='Ref_to_Global_Var'>recoveryTargetXid</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN259"><span class='Ref_to_Global_Var'>recoveryTarget</span></a> <span class='Operator'>== </span><a href="../../../include/access/xlog.h.html#LN83"><span class='Ref_to_EnumConst'>RECOVERY_TARGET_TIME</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"starting point-in-time recovery to %s"</span><span class='Delimiter'>, 
</span>                            <a href="../../../bin/pg_waldump/compat.c.html#LN48"><span class='Ref_to_Func'>timestamptz_to_str</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN263"><span class='Ref_to_Global_Var'>recoveryTargetTime</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN259"><span class='Ref_to_Global_Var'>recoveryTarget</span></a> <span class='Operator'>== </span><a href="../../../include/access/xlog.h.html#LN84"><span class='Ref_to_EnumConst'>RECOVERY_TARGET_NAME</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"starting point-in-time recovery to \"%s\""</span><span class='Delimiter'>, 
</span>                            <a href="xlog.c.html#LN264"><span class='Ref_to_Global_Var'>recoveryTargetName</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN259"><span class='Ref_to_Global_Var'>recoveryTarget</span></a> <span class='Operator'>== </span><a href="../../../include/access/xlog.h.html#LN85"><span class='Ref_to_EnumConst'>RECOVERY_TARGET_LSN</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"starting point-in-time recovery to WAL location (LSN) \"%X/%X\""</span><span class='Delimiter'>, 
</span>                            <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN265"><span class='Ref_to_Global_Var'>recoveryTargetLSN</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                            <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN265"><span class='Ref_to_Global_Var'>recoveryTargetLSN</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN259"><span class='Ref_to_Global_Var'>recoveryTarget</span></a> <span class='Operator'>== </span><a href="../../../include/access/xlog.h.html#LN86"><span class='Ref_to_EnumConst'>RECOVERY_TARGET_IMMEDIATE</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"starting point-in-time recovery to earliest consistent point"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"starting archive recovery"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if ArchiveRecoveryReques... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Take ownership of the wakeup latch if we're going to sleep during 
     * recovery. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN270"><span class='Ref_to_Global_Var'>StandbyModeRequested</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/latch.h.html#LN149"><span class='Ref_to_Proto'>OwnLatch</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN661"><span class='Ref_to_Member'>recoveryWakeupLatch</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Set up XLOG reader facility */ 
</span>    <a href="../../../include/c.h.html#LN856"><span class='Ref_to_Macro'>MemSet</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Keyword'>private</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../bin/pg_rewind/parsexlog.c.html#LN44"><span class='Ref_to_Struct'>XLogPageReadPrivate</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN6206"><span class='Ref_To_Local'>xlogreader</span></a> <span class='Operator'>= </span><a href="xlogreader.c.html#LN65"><span class='Ref_to_Func'>XLogReaderAllocate</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN872"><span class='Ref_to_Proto'>XLogPageRead</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><span class='Keyword'>private</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN6206"><span class='Ref_To_Local'>xlogreader</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_OUT_OF_MEMORY<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"out of memory"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>             <a href="../../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"Failed while allocating a WAL reading processor."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN6206"><span class='Ref_To_Local'>xlogreader</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogreader.h.html#LN102"><span class='Ref_to_Member'>system_identifier</span></a> <span class='Operator'>= </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN108"><span class='Ref_to_Member'>system_identifier</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Allocate pages dedicated to WAL consistency checks, those had better be 
     * aligned. 
     */ 
</span>    <a href="xlog.c.html#LN252"><span class='Ref_to_Global_Var'>replay_image_masked</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span>BLCKSZ<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN253"><span class='Ref_to_Global_Var'>master_image_masked</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span>BLCKSZ<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN903"><span class='Ref_to_Proto'>read_backup_label</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN6197"><span class='Ref_To_Local'>checkPointLoc</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN6203"><span class='Ref_To_Local'>backupEndRequired</span></a><span class='Delimiter'>, 
</span>                          <span class='Operator'>&</span><a href="xlog.c.html#LN6204"><span class='Ref_To_Local'>backupFromStandby</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN6363"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>tablespaces</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Archive recovery was requested, and thanks to the backup label 
         * file, we know how far we need to replay to reach consistency. Enter 
         * archive recovery directly. 
         */ 
</span>        <a href="xlog.c.html#LN246"><span class='Ref_to_Global_Var'>InArchiveRecovery</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN270"><span class='Ref_to_Global_Var'>StandbyModeRequested</span></a><span class='Parentheses'>) 
</span>            <a href="xlog.c.html#LN276"><span class='Ref_to_Global_Var'>StandbyMode</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * When a backup_label file is present, we want to roll forward from 
         * the checkpoint it identifies, rather than using pg_control. 
         */ 
</span>        <a href="xlog.c.html#LN6201"><span class='Ref_To_Local'>record</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN889"><span class='Ref_to_Proto'>ReadCheckpointRecord</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN6206"><span class='Ref_To_Local'>xlogreader</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN6197"><span class='Ref_To_Local'>checkPointLoc</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN6201"><span class='Ref_To_Local'>record</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            memcpy<span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xlogreader.h.html#LN219"><span class='Ref_to_Macro'>XLogRecGetData</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN6206"><span class='Ref_To_Local'>xlogreader</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_control.h.html#LN32"><span class='Ref_to_Struct'>CheckPoint</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN6192"><span class='Ref_To_Local'>wasShutdown</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="xlog.c.html#LN6201"><span class='Ref_To_Local'>record</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogrecord.h.html#LN45"><span class='Ref_to_Member'>xl_info</span></a> <span class='Operator'>& ~</span><a href="../../../include/access/xlogrecord.h.html#LN61"><span class='Ref_to_Const'>XLR_INFO_MASK</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="../../../include/catalog/pg_control.h.html#LN65"><span class='Ref_to_Const'>XLOG_CHECKPOINT_SHUTDOWN</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN24"><span class='Ref_to_Const'>DEBUG1</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"checkpoint record is at %X/%X"</span><span class='Delimiter'>, 
</span>                   <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN6197"><span class='Ref_To_Local'>checkPointLoc</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN6197"><span class='Ref_To_Local'>checkPointLoc</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN191"><span class='Ref_to_Global_Var'>InRecovery</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* force recovery even if SHUTDOWNED */ 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Make sure that REDO location exists. This may not be the case 
             * if there was a crash during an online backup, which left a 
             * backup_label around that references a WAL segment that's 
             * already been archived. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN34"><span class='Ref_to_Member'>redo</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN6197"><span class='Ref_To_Local'>checkPointLoc</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN886"><span class='Ref_to_Proto'>ReadRecord</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN6206"><span class='Ref_To_Local'>xlogreader</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN34"><span class='Ref_to_Member'>redo</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>))</span> 
                    <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                            <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not find redo location referenced by checkpoint record"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                             <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"If you are not restoring from a backup, try removing the file \"%s/backup_label\"."</span><span class='Delimiter'>, </span><a href="../../utils/init/globals.c.html#LN59"><span class='Ref_to_Global_Var'>DataDir</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if record!=NULL &raquo; </span> 
        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not locate required checkpoint record"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"If you are not restoring from a backup, try removing the file \"%s/backup_label\"."</span><span class='Delimiter'>, </span><a href="../../utils/init/globals.c.html#LN59"><span class='Ref_to_Global_Var'>DataDir</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN6192"><span class='Ref_To_Local'>wasShutdown</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* keep compiler quiet */ 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* read the tablespace_map file if present and create symlinks. */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN905"><span class='Ref_to_Proto'>read_tablespace_map</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN6363"><span class='Ref_To_Local'>tablespaces</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN6413"></a>            <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
            <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN6413"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN6363"><span class='Ref_To_Local'>tablespaces</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN6417"></a>                <a href="../../../include/replication/basebackup.h.html#LN23"><span class='Ref_to_Typedef'>tablespaceinfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>ti</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN6413"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN6418"></a>                <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>linkloc</span><span class='Delimiter'>; 
</span> 
                <a href="xlog.c.html#LN6418"><span class='Ref_To_Local'>linkloc</span></a> <span class='Operator'>= </span><a href="../../../common/psprintf.c.html#LN44"><span class='Ref_to_Func'>psprintf</span></a><span class='Parentheses'>(</span><span class='String'>"pg_tblspc/%s"</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN6417"><span class='Ref_To_Local'>ti</span></a><span class='Operator'>-&GT;</span><a href="../../../include/replication/basebackup.h.html#LN25"><span class='Ref_to_Member'>oid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * Remove the existing symlink if any and Create the symlink 
                 * under PGDATA. 
                 */ 
</span>                <a href="../../../include/commands/tablespace.h.html#LN59"><span class='Ref_to_Proto'>remove_tablespace_symlink</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN6418"><span class='Ref_To_Local'>linkloc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/port.h.html#LN255"><span class='Ref_to_Macro'>symlink</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN6417"><span class='Ref_To_Local'>ti</span></a><span class='Operator'>-&GT;</span><a href="../../../include/replication/basebackup.h.html#LN26"><span class='Ref_to_Member'>path</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN6418"><span class='Ref_To_Local'>linkloc</span></a><span class='Parentheses'>) </span><span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                    <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                            <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                          <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not create symbolic link \"%s\": %m"</span><span class='Delimiter'>, 
</span>                                 <a href="xlog.c.html#LN6418"><span class='Ref_To_Local'>linkloc</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
                <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN6417"><span class='Ref_To_Local'>ti</span></a><span class='Operator'>-&GT;</span><a href="../../../include/replication/basebackup.h.html#LN25"><span class='Ref_to_Member'>oid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN6417"><span class='Ref_To_Local'>ti</span></a><span class='Operator'>-&GT;</span><a href="../../../include/replication/basebackup.h.html#LN26"><span class='Ref_to_Member'>path</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN6417"><span class='Ref_To_Local'>ti</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* set flag to delete it later */ 
</span>            <a href="xlog.c.html#LN6195"><span class='Ref_To_Local'>haveTblspcMap</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if read_tablespace_map(&... &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* set flag to delete it later */ 
</span>        <a href="xlog.c.html#LN6194"><span class='Ref_To_Local'>haveBackupLabel</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if read_backup_label(&ch... &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * If tablespace_map file is present without backup_label file, there 
         * is no use of such file.  There is no harm in retaining it, but it 
         * is better to get rid of the map file so that we don't have any 
         * redundant file in data directory and it will avoid any sort of 
         * confusion.  It seems prudent though to just rename the file out of 
         * the way rather than delete it completely, also we ignore any error 
         * that occurs in rename operation as even if map file is present 
         * without backup_label file, it is harmless. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/port.h.html#LN275"><span class='Ref_to_Macro'>stat</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN323"><span class='Ref_to_Const'>TABLESPACE_MAP</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN6209"><span class='Ref_To_Local'>st</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <a href="../../../timezone/private.h.html#LN59"><span class='Ref_to_Proto'>unlink</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN324"><span class='Ref_to_Const'>TABLESPACE_MAP_OLD</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/common/file_utils.h.html#LN22"><span class='Ref_to_Proto'>durable_rename</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN323"><span class='Ref_to_Const'>TABLESPACE_MAP</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xlog.h.html#LN324"><span class='Ref_to_Const'>TABLESPACE_MAP_OLD</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/elog.h.html#LN24"><span class='Ref_to_Const'>DEBUG1</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"ignoring file \"%s\" because no file \"%s\" exists"</span><span class='Delimiter'>, 
</span>                        <a href="../../../include/access/xlog.h.html#LN323"><span class='Ref_to_Const'>TABLESPACE_MAP</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xlog.h.html#LN320"><span class='Ref_to_Const'>BACKUP_LABEL_FILE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"File \"%s\" was renamed to \"%s\"."</span><span class='Delimiter'>, 
</span>                           <a href="../../../include/access/xlog.h.html#LN323"><span class='Ref_to_Const'>TABLESPACE_MAP</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xlog.h.html#LN324"><span class='Ref_to_Const'>TABLESPACE_MAP_OLD</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"ignoring file \"%s\" because no file \"%s\" exists"</span><span class='Delimiter'>, 
</span>                        <a href="../../../include/access/xlog.h.html#LN323"><span class='Ref_to_Const'>TABLESPACE_MAP</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xlog.h.html#LN320"><span class='Ref_to_Const'>BACKUP_LABEL_FILE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"Could not rename file \"%s\" to \"%s\": %m."</span><span class='Delimiter'>, 
</span>                           <a href="../../../include/access/xlog.h.html#LN323"><span class='Ref_to_Const'>TABLESPACE_MAP</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xlog.h.html#LN324"><span class='Ref_to_Const'>TABLESPACE_MAP_OLD</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * It's possible that archive recovery was requested, but we don't 
         * know how far we need to replay the WAL before we reach consistency. 
         * This can happen for example if a base backup is taken from a 
         * running server using an atomic filesystem snapshot, without calling 
         * pg_start/stop_backup. Or if you just kill a running master server 
         * and put it into archive recovery by creating a recovery.conf file. 
         * 
         * Our strategy in that case is to perform crash recovery first, 
         * replaying all the WAL present in pg_wal, and only enter archive 
         * recovery after that. 
         * 
         * But usually we already know how far we need to replay the WAL (up 
         * to minRecoveryPoint, up to backupEndPoint, or until we see an 
         * end-of-backup record), and we can enter archive recovery directly. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN245"><span class='Ref_to_Global_Var'>ArchiveRecoveryRequested</span></a> <span class='Operator'>&& 
</span>            <span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN169"><span class='Ref_to_Member'>minRecoveryPoint</span></a> <span class='Operator'>!= </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a> <span class='Operator'>|| 
</span>             <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN173"><span class='Ref_to_Member'>backupEndRequired</span></a> <span class='Operator'>|| 
</span>             <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN172"><span class='Ref_to_Member'>backupEndPoint</span></a> <span class='Operator'>!= </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a> <span class='Operator'>|| 
</span>             <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN129"><span class='Ref_to_Member'>state</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_control.h.html#LN86"><span class='Ref_to_EnumConst'>DB_SHUTDOWNED</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="xlog.c.html#LN246"><span class='Ref_to_Global_Var'>InArchiveRecovery</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN270"><span class='Ref_to_Global_Var'>StandbyModeRequested</span></a><span class='Parentheses'>) 
</span>                <a href="xlog.c.html#LN276"><span class='Ref_to_Global_Var'>StandbyMode</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Get the last valid checkpoint record.  If the latest one according 
         * to pg_control is broken, try the next-to-last one. 
         */ 
</span>        <a href="xlog.c.html#LN6197"><span class='Ref_To_Local'>checkPointLoc</span></a> <span class='Operator'>= </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN131"><span class='Ref_to_Member'>checkPoint</span></a><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN371"><span class='Ref_to_Global_Var'>RedoStartLSN</span></a> <span class='Operator'>= </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN134"><span class='Ref_to_Member'>checkPointCopy</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN34"><span class='Ref_to_Member'>redo</span></a><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN6201"><span class='Ref_To_Local'>record</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN889"><span class='Ref_to_Proto'>ReadCheckpointRecord</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN6206"><span class='Ref_To_Local'>xlogreader</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN6197"><span class='Ref_To_Local'>checkPointLoc</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN6201"><span class='Ref_To_Local'>record</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN24"><span class='Ref_to_Const'>DEBUG1</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"checkpoint record is at %X/%X"</span><span class='Delimiter'>, 
</span>                   <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN6197"><span class='Ref_To_Local'>checkPointLoc</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN6197"><span class='Ref_To_Local'>checkPointLoc</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN276"><span class='Ref_to_Global_Var'>StandbyMode</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * The last valid checkpoint record required for a streaming 
             * recovery exists in neither standby nor the primary. 
             */ 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not locate a valid checkpoint record"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <a href="xlog.c.html#LN6197"><span class='Ref_To_Local'>checkPointLoc</span></a> <span class='Operator'>= </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN132"><span class='Ref_to_Member'>prevCheckPoint</span></a><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN6201"><span class='Ref_To_Local'>record</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN889"><span class='Ref_to_Proto'>ReadCheckpointRecord</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN6206"><span class='Ref_To_Local'>xlogreader</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN6197"><span class='Ref_To_Local'>checkPointLoc</span></a><span class='Delimiter'>, </span><span class='Number'>2</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN6201"><span class='Ref_To_Local'>record</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"using previous checkpoint record at %X/%X"</span><span class='Delimiter'>, 
</span>                   <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN6197"><span class='Ref_To_Local'>checkPointLoc</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN6197"><span class='Ref_To_Local'>checkPointLoc</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                <a href="xlog.c.html#LN191"><span class='Ref_to_Global_Var'>InRecovery</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* force recovery even if SHUTDOWNED */ 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>                     <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not locate a valid checkpoint record"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        memcpy<span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xlogreader.h.html#LN219"><span class='Ref_to_Macro'>XLogRecGetData</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN6206"><span class='Ref_To_Local'>xlogreader</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_control.h.html#LN32"><span class='Ref_to_Struct'>CheckPoint</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN6192"><span class='Ref_To_Local'>wasShutdown</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="xlog.c.html#LN6201"><span class='Ref_To_Local'>record</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogrecord.h.html#LN45"><span class='Ref_to_Member'>xl_info</span></a> <span class='Operator'>& ~</span><a href="../../../include/access/xlogrecord.h.html#LN61"><span class='Ref_to_Const'>XLR_INFO_MASK</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="../../../include/catalog/pg_control.h.html#LN65"><span class='Ref_to_Const'>XLOG_CHECKPOINT_SHUTDOWN</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Clear out any old relcache cache files.  This is *necessary* if we do 
     * any WAL replay, since that would probably result in the cache files 
     * being out of sync with database reality.  In theory we could leave them 
     * in place if the database had been cleanly shut down, but it seems 
     * safest to just remove them always and let them be rebuilt during the 
     * first backend startup.  These files needs to be removed from all 
     * directories including pg_tblspc, however the symlinks are created only 
     * after reading tablespace_map file in case of archive recovery from 
     * backup, so needs to clear old relcache files here after creating 
     * symlinks. 
     */ 
</span>    <a href="../../../include/utils/relcache.h.html#LN129"><span class='Ref_to_Proto'>RelationCacheInitFileRemove</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the location of the checkpoint record is not on the expected 
     * timeline in the history of the requested timeline, we cannot proceed: 
     * the backup is not part of the history of the requested timeline. 
     */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN317"><span class='Ref_to_Global_Var'>expectedTLEs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>       <span class='Comment_Multi_Line'>/* was initialized by reading checkpoint 
                                 * record */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/timeline.h.html#LN39"><span class='Ref_to_Proto'>tliOfPointInHistory</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN6197"><span class='Ref_To_Local'>checkPointLoc</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN317"><span class='Ref_to_Global_Var'>expectedTLEs</span></a><span class='Parentheses'>) </span><span class='Operator'>!= 
</span>        <a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN36"><span class='Ref_to_Member'>ThisTimeLineID</span></a><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span><a name="LN6567"></a>        <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>switchpoint</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * tliSwitchPoint will throw an error if the checkpoint's timeline is 
         * not in expectedTLEs at all. 
         */ 
</span>        <a href="xlog.c.html#LN6567"><span class='Ref_To_Local'>switchpoint</span></a> <span class='Operator'>= </span><a href="../../../include/access/timeline.h.html#LN40"><span class='Ref_to_Proto'>tliSwitchPoint</span></a><span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN134"><span class='Ref_to_Member'>checkPointCopy</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN36"><span class='Ref_to_Member'>ThisTimeLineID</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN317"><span class='Ref_to_Global_Var'>expectedTLEs</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"requested timeline %u is not a child of this server's history"</span><span class='Delimiter'>, 
</span>                        <a href="xlog.c.html#LN315"><span class='Ref_to_Global_Var'>recoveryTargetTLI</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"Latest checkpoint is at %X/%X on timeline %u, but in the history of the requested timeline, the server forked off from that timeline at %X/%X."</span><span class='Delimiter'>, 
</span>                           <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN131"><span class='Ref_to_Member'>checkPoint</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                           <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN131"><span class='Ref_to_Member'>checkPoint</span></a><span class='Delimiter'>, 
</span>                           <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN134"><span class='Ref_to_Member'>checkPointCopy</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN36"><span class='Ref_to_Member'>ThisTimeLineID</span></a><span class='Delimiter'>, 
</span>                           <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN6567"><span class='Ref_To_Local'>switchpoint</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                           <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN6567"><span class='Ref_To_Local'>switchpoint</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if tliOfPointInHistory(c... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * The min recovery point should be part of the requested timeline's 
     * history, too. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/xlogdefs.h.html#LN28"><span class='Ref_to_Macro'>XLogRecPtrIsInvalid</span></a><span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN169"><span class='Ref_to_Member'>minRecoveryPoint</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>      <a href="../../../include/access/timeline.h.html#LN39"><span class='Ref_to_Proto'>tliOfPointInHistory</span></a><span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN169"><span class='Ref_to_Member'>minRecoveryPoint</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN317"><span class='Ref_to_Global_Var'>expectedTLEs</span></a><span class='Parentheses'>) </span><span class='Operator'>!= 
</span>        <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN170"><span class='Ref_to_Member'>minRecoveryPointTLI</span></a><span class='Parentheses'>)</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"requested timeline %u does not contain minimum recovery point %X/%X on timeline %u"</span><span class='Delimiter'>, 
</span>                        <a href="xlog.c.html#LN315"><span class='Ref_to_Global_Var'>recoveryTargetTLI</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN169"><span class='Ref_to_Member'>minRecoveryPoint</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN169"><span class='Ref_to_Member'>minRecoveryPoint</span></a><span class='Delimiter'>, 
</span>                        <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN170"><span class='Ref_to_Member'>minRecoveryPointTLI</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <a href="xlog.c.html#LN196"><span class='Ref_to_Global_Var'>LastRec</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN6196"><span class='Ref_To_Local'>RecPtr</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN6197"><span class='Ref_To_Local'>checkPointLoc</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN24"><span class='Ref_to_Const'>DEBUG1</span></a><span class='Delimiter'>, 
</span>            <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN825"><span class='Ref_to_Func'>errmsg_internal</span></a><span class='Parentheses'>(</span><span class='String'>"redo record is at %X/%X; shutdown %s"</span><span class='Delimiter'>, 
</span>                  <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN34"><span class='Ref_to_Member'>redo</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN34"><span class='Ref_to_Member'>redo</span></a><span class='Delimiter'>, 
</span>                             <a href="xlog.c.html#LN6192"><span class='Ref_To_Local'>wasShutdown</span></a> <span class='Operator'>? </span><span class='String'>"TRUE"</span> <span class='Operator'>: </span><span class='String'>"FALSE"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN24"><span class='Ref_to_Const'>DEBUG1</span></a><span class='Delimiter'>, 
</span>            <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN825"><span class='Ref_to_Func'>errmsg_internal</span></a><span class='Parentheses'>(</span><span class='String'>"next transaction ID: %u:%u; next OID: %u"</span><span class='Delimiter'>, 
</span>                             <a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN40"><span class='Ref_to_Member'>nextXidEpoch</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN41"><span class='Ref_to_Member'>nextXid</span></a><span class='Delimiter'>, 
</span>                             <a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN42"><span class='Ref_to_Member'>nextOid</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN24"><span class='Ref_to_Const'>DEBUG1</span></a><span class='Delimiter'>, 
</span>            <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN825"><span class='Ref_to_Func'>errmsg_internal</span></a><span class='Parentheses'>(</span><span class='String'>"next MultiXactId: %u; next MultiXactOffset: %u"</span><span class='Delimiter'>, 
</span>                         <a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN43"><span class='Ref_to_Member'>nextMulti</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN44"><span class='Ref_to_Member'>nextMultiOffset</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN24"><span class='Ref_to_Const'>DEBUG1</span></a><span class='Delimiter'>, 
</span>       <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN825"><span class='Ref_to_Func'>errmsg_internal</span></a><span class='Parentheses'>(</span><span class='String'>"oldest unfrozen transaction ID: %u, in database %u"</span><span class='Delimiter'>, 
</span>                        <a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN45"><span class='Ref_to_Member'>oldestXid</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN46"><span class='Ref_to_Member'>oldestXidDB</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN24"><span class='Ref_to_Const'>DEBUG1</span></a><span class='Delimiter'>, 
</span>            <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN825"><span class='Ref_to_Func'>errmsg_internal</span></a><span class='Parentheses'>(</span><span class='String'>"oldest MultiXactId: %u, in database %u"</span><span class='Delimiter'>, 
</span>                         <a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN47"><span class='Ref_to_Member'>oldestMulti</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN48"><span class='Ref_to_Member'>oldestMultiDB</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN24"><span class='Ref_to_Const'>DEBUG1</span></a><span class='Delimiter'>, 
</span>            <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN825"><span class='Ref_to_Func'>errmsg_internal</span></a><span class='Parentheses'>(</span><span class='String'>"commit timestamp Xid oldest/newest: %u/%u"</span><span class='Delimiter'>, 
</span>                             <a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN50"><span class='Ref_to_Member'>oldestCommitTsXid</span></a><span class='Delimiter'>, 
</span>                             <a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN52"><span class='Ref_to_Member'>newestCommitTsXid</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN41"><span class='Ref_to_Member'>nextXid</span></a><span class='Parentheses'>))</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"invalid next transaction ID"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* initialize shared memory variables from the checkpoint record */ 
</span>    <a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN116"><span class='Ref_to_Member'>nextXid</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN41"><span class='Ref_to_Member'>nextXid</span></a><span class='Delimiter'>; 
</span>    <a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN110"><span class='Ref_to_Member'>nextOid</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN42"><span class='Ref_to_Member'>nextOid</span></a><span class='Delimiter'>; 
</span>    <a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN111"><span class='Ref_to_Member'>oidCount</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="../../../include/access/multixact.h.html#LN139"><span class='Ref_to_Proto'>MultiXactSetNextMXact</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN43"><span class='Ref_to_Member'>nextMulti</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN44"><span class='Ref_to_Member'>nextMultiOffset</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/access/transam.h.html#LN181"><span class='Ref_to_Proto'>AdvanceOldestClogXid</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN45"><span class='Ref_to_Member'>oldestXid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/access/transam.h.html#LN179"><span class='Ref_to_Proto'>SetTransactionIdLimit</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN45"><span class='Ref_to_Member'>oldestXid</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN46"><span class='Ref_to_Member'>oldestXidDB</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/access/multixact.h.html#LN128"><span class='Ref_to_Proto'>SetMultiXactIdLimit</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN47"><span class='Ref_to_Member'>oldestMulti</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN48"><span class='Ref_to_Member'>oldestMultiDB</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/access/commit_ts.h.html#LN43"><span class='Ref_to_Proto'>SetCommitTsLimit</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN50"><span class='Ref_to_Member'>oldestCommitTsXid</span></a><span class='Delimiter'>, 
</span>                     <a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN52"><span class='Ref_to_Member'>newestCommitTsXid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN579"><span class='Ref_to_Member'>ckptXidEpoch</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN40"><span class='Ref_to_Member'>nextXidEpoch</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN580"><span class='Ref_to_Member'>ckptXid</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN41"><span class='Ref_to_Member'>nextXid</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Initialize replication slots, before there's a chance to remove 
     * required resources. 
     */ 
</span>    <a href="../../../include/replication/slot.h.html#LN181"><span class='Ref_to_Proto'>StartupReplicationSlots</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Startup logical state, needs to be setup now so we have proper data 
     * during crash recovery. 
     */ 
</span>    <a href="../../../include/replication/reorderbuffer.h.html#LN402"><span class='Ref_to_Proto'>StartupReorderBuffer</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Startup MultiXact. We need to do this early to be able to replay 
     * truncations. 
     */ 
</span>    <a href="../../../include/access/multixact.h.html#LN125"><span class='Ref_to_Proto'>StartupMultiXact</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Ditto commit timestamps.  In a standby, we do it if setting is enabled 
     * in ControlFile; in a master we base the decision on the GUC itself. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN245"><span class='Ref_to_Global_Var'>ArchiveRecoveryRequested</span></a> <span class='Operator'>? 
</span>        <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN185"><span class='Ref_to_Member'>track_commit_timestamp</span></a> <span class='Operator'>: </span><a href="commit_ts.c.html#LN102"><span class='Ref_to_Global_Var'>track_commit_timestamp</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/access/commit_ts.h.html#LN36"><span class='Ref_to_Proto'>StartupCommitTs</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Recover knowledge about replay progress of known replication partners. 
     */ 
</span>    <a href="../../../include/replication/origin.h.html#LN62"><span class='Ref_to_Proto'>StartupReplicationOrigin</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Initialize unlogged LSN. On a clean shutdown, it's restored from the 
     * control file. On recovery, all unlogged relations are blown away, so 
     * the unlogged LSN counter can be reset too. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN129"><span class='Ref_to_Member'>state</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_control.h.html#LN86"><span class='Ref_to_EnumConst'>DB_SHUTDOWNED</span></a><span class='Parentheses'>) 
</span>        <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN588"><span class='Ref_to_Member'>unloggedLSN</span></a> <span class='Operator'>= </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN136"><span class='Ref_to_Member'>unloggedLSN</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN588"><span class='Ref_to_Member'>unloggedLSN</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We must replay WAL entries using the same TimeLineID they were created 
     * under, so temporarily adopt the TLI indicated by the checkpoint (see 
     * also xlog_redo()). 
     */ 
</span>    <a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN36"><span class='Ref_to_Member'>ThisTimeLineID</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Copy any missing timeline history files between 'now' and the recovery 
     * target timeline from archive to pg_wal. While we don't need those files 
     * ourselves - the history file of the recovery target timeline covers all 
     * the previous timelines in the history too - a cascading standby server 
     * might be interested in them. Or, if you archive the WAL from this 
     * server to a different archive than the master, it'd be good for all the 
     * history files to get archived there after failover, so that you can use 
     * one of the old timelines as a PITR target. Timeline history files are 
     * small, so it's better to copy them unnecessarily than not copy them and 
     * regret later. 
     */ 
</span>    <a href="../../../include/access/timeline.h.html#LN37"><span class='Ref_to_Proto'>restoreTimeLineHistoryFiles</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN315"><span class='Ref_to_Global_Var'>recoveryTargetTLI</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Before running in recovery, scan pg_twophase and fill in its status to 
     * be able to work on entries generated by redo.  Doing a scan before 
     * taking any recovery action has the merit to discard any 2PC files that 
     * are newer than the first record to replay, saving from any conflicts at 
     * replay.  This avoids as well any subsequent scans when doing recovery 
     * of the on-disk two-phase data. 
     */ 
</span>    <a href="../../../include/access/twophase.h.html#LN58"><span class='Ref_to_Proto'>restoreTwoPhaseData</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <a href="xlog.c.html#LN208"><span class='Ref_to_Global_Var'>lastFullPageWrites</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN39"><span class='Ref_to_Member'>fullPageWrites</span></a><span class='Delimiter'>; 
</span> 
    <a href="xlog.c.html#LN349"><span class='Ref_to_Global_Var'>RedoRecPtr</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN578"><span class='Ref_to_Member'>RedoRecPtr</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN574"><span class='Ref_to_Member'>Insert</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN547"><span class='Ref_to_Member'>RedoRecPtr</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN34"><span class='Ref_to_Member'>redo</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN356"><span class='Ref_to_Global_Var'>doPageWrites</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN208"><span class='Ref_to_Global_Var'>lastFullPageWrites</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN6196"><span class='Ref_To_Local'>RecPtr</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN34"><span class='Ref_to_Member'>redo</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"invalid redo in checkpoint record"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Check whether we need to force recovery from WAL.  If it appears to 
     * have been a clean shutdown and we did not have a recovery.conf file, 
     * then assume no recovery needed. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN34"><span class='Ref_to_Member'>redo</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN6196"><span class='Ref_To_Local'>RecPtr</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN6192"><span class='Ref_To_Local'>wasShutdown</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"invalid redo record in shutdown checkpoint"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN191"><span class='Ref_to_Global_Var'>InRecovery</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN129"><span class='Ref_to_Member'>state</span></a> <span class='Operator'>!= </span><a href="../../../include/catalog/pg_control.h.html#LN86"><span class='Ref_to_EnumConst'>DB_SHUTDOWNED</span></a><span class='Parentheses'>) 
</span>        <a href="xlog.c.html#LN191"><span class='Ref_to_Global_Var'>InRecovery</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN245"><span class='Ref_to_Global_Var'>ArchiveRecoveryRequested</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* force recovery due to presence of recovery.conf */ 
</span>        <a href="xlog.c.html#LN191"><span class='Ref_to_Global_Var'>InRecovery</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* REDO */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN191"><span class='Ref_to_Global_Var'>InRecovery</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN6743"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>rmid</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Update pg_control to show that we are recovering and to show the 
         * selected checkpoint as the place we are starting from. We also mark 
         * pg_control with any minimum recovery stop point obtained from a 
         * backup history file. 
         */ 
</span>        <a href="xlog.c.html#LN6205"><span class='Ref_To_Local'>dbstate_at_startup</span></a> <span class='Operator'>= </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN129"><span class='Ref_to_Member'>state</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN246"><span class='Ref_to_Global_Var'>InArchiveRecovery</span></a><span class='Parentheses'>) 
</span>            <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN129"><span class='Ref_to_Member'>state</span></a> <span class='Operator'>= </span><a href="../../../include/catalog/pg_control.h.html#LN90"><span class='Ref_to_EnumConst'>DB_IN_ARCHIVE_RECOVERY</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"database system was not properly shut down; "</span> 
                            <span class='String'>"automatic recovery in progress"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN315"><span class='Ref_to_Global_Var'>recoveryTargetTLI</span></a> <span class='Operator'>&GT; </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN134"><span class='Ref_to_Member'>checkPointCopy</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN36"><span class='Ref_to_Member'>ThisTimeLineID</span></a><span class='Parentheses'>) 
</span>                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"crash recovery starts in timeline %u "</span> 
                                <span class='String'>"and has target timeline %u"</span><span class='Delimiter'>, 
</span>                                <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN134"><span class='Ref_to_Member'>checkPointCopy</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN36"><span class='Ref_to_Member'>ThisTimeLineID</span></a><span class='Delimiter'>, 
</span>                                <a href="xlog.c.html#LN315"><span class='Ref_to_Global_Var'>recoveryTargetTLI</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN129"><span class='Ref_to_Member'>state</span></a> <span class='Operator'>= </span><a href="../../../include/catalog/pg_control.h.html#LN89"><span class='Ref_to_EnumConst'>DB_IN_CRASH_RECOVERY</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN132"><span class='Ref_to_Member'>prevCheckPoint</span></a> <span class='Operator'>= </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN131"><span class='Ref_to_Member'>checkPoint</span></a><span class='Delimiter'>; 
</span>        <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN131"><span class='Ref_to_Member'>checkPoint</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN6197"><span class='Ref_To_Local'>checkPointLoc</span></a><span class='Delimiter'>; 
</span>        <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN134"><span class='Ref_to_Member'>checkPointCopy</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN246"><span class='Ref_to_Global_Var'>InArchiveRecovery</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* initialize minRecoveryPoint if not set yet */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN169"><span class='Ref_to_Member'>minRecoveryPoint</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN34"><span class='Ref_to_Member'>redo</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN169"><span class='Ref_to_Member'>minRecoveryPoint</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN34"><span class='Ref_to_Member'>redo</span></a><span class='Delimiter'>; 
</span>                <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN170"><span class='Ref_to_Member'>minRecoveryPointTLI</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN36"><span class='Ref_to_Member'>ThisTimeLineID</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Set backupStartPoint if we're starting recovery from a base backup. 
         * 
         * Also set backupEndPoint and use minRecoveryPoint as the backup end 
         * location if we're starting recovery from a base backup which was 
         * taken from a standby. In this case, the database system status in 
         * pg_control must indicate that the database was already in recovery. 
         * Usually that will be DB_IN_ARCHIVE_RECOVERY but also can be 
         * DB_SHUTDOWNED_IN_RECOVERY if recovery previously was interrupted 
         * before reaching this point; e.g. because restore_command or 
         * primary_conninfo were faulty. 
         * 
         * Any other state indicates that the backup somehow became corrupted 
         * and we can't sensibly continue with recovery. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN6194"><span class='Ref_To_Local'>haveBackupLabel</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN171"><span class='Ref_to_Member'>backupStartPoint</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN34"><span class='Ref_to_Member'>redo</span></a><span class='Delimiter'>; 
</span>            <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN173"><span class='Ref_to_Member'>backupEndRequired</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN6203"><span class='Ref_To_Local'>backupEndRequired</span></a><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN6204"><span class='Ref_To_Local'>backupFromStandby</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN6205"><span class='Ref_To_Local'>dbstate_at_startup</span></a> <span class='Operator'>!= </span><a href="../../../include/catalog/pg_control.h.html#LN90"><span class='Ref_to_EnumConst'>DB_IN_ARCHIVE_RECOVERY</span></a> <span class='Operator'>&& 
</span>                    <a href="xlog.c.html#LN6205"><span class='Ref_To_Local'>dbstate_at_startup</span></a> <span class='Operator'>!= </span><a href="../../../include/catalog/pg_control.h.html#LN87"><span class='Ref_to_EnumConst'>DB_SHUTDOWNED_IN_RECOVERY</span></a><span class='Parentheses'>) 
</span>                    <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                            <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"backup_label contains data inconsistent with control file"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                             <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"This means that the backup is corrupted and you will "</span> 
                               <span class='String'>"have to use another backup for recovery."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN172"><span class='Ref_to_Member'>backupEndPoint</span></a> <span class='Operator'>= </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN169"><span class='Ref_to_Member'>minRecoveryPoint</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>        <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN130"><span class='Ref_to_Member'>time</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/pgtime.h.html#LN22"><span class='Ref_to_Typedef'>pg_time_t</span></a><span class='Parentheses'>) </span>time<span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* No need to hold ControlFileLock yet, we aren't up far enough */ 
</span>        <a href="../../../include/access/xlog.h.html#LN256"><span class='Ref_to_Proto'>UpdateControlFile</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* initialize our local copy of minRecoveryPoint */ 
</span>        <a href="xlog.c.html#LN820"><span class='Ref_to_Global_Var'>minRecoveryPoint</span></a> <span class='Operator'>= </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN169"><span class='Ref_to_Member'>minRecoveryPoint</span></a><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN822"><span class='Ref_to_Global_Var'>minRecoveryPointTLI</span></a> <span class='Operator'>= </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN170"><span class='Ref_to_Member'>minRecoveryPointTLI</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Reset pgstat data, because it may be invalid after recovery. 
         */ 
</span>        <a href="../../postmaster/pgstat.c.html#LN683"><span class='Ref_to_Func'>pgstat_reset_all</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If there was a backup label file, it's done its job and the info 
         * has now been propagated into pg_control.  We must get rid of the 
         * label file so that if we crash during recovery, we'll pick up at 
         * the latest recovery restartpoint instead of going all the way back 
         * to the backup start point.  It seems prudent though to just rename 
         * the file out of the way rather than delete it completely. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN6194"><span class='Ref_To_Local'>haveBackupLabel</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../../timezone/private.h.html#LN59"><span class='Ref_to_Proto'>unlink</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN321"><span class='Ref_to_Const'>BACKUP_LABEL_OLD</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/common/file_utils.h.html#LN22"><span class='Ref_to_Proto'>durable_rename</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN320"><span class='Ref_to_Const'>BACKUP_LABEL_FILE</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xlog.h.html#LN321"><span class='Ref_to_Const'>BACKUP_LABEL_OLD</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If there was a tablespace_map file, it's done its job and the 
         * symlinks have been created.  We must get rid of the map file so 
         * that if we crash during recovery, we don't create symlinks again. 
         * It seems prudent though to just rename the file out of the way 
         * rather than delete it completely. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN6195"><span class='Ref_To_Local'>haveTblspcMap</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../../timezone/private.h.html#LN59"><span class='Ref_to_Proto'>unlink</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN324"><span class='Ref_to_Const'>TABLESPACE_MAP_OLD</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/common/file_utils.h.html#LN22"><span class='Ref_to_Proto'>durable_rename</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN323"><span class='Ref_to_Const'>TABLESPACE_MAP</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xlog.h.html#LN324"><span class='Ref_to_Const'>TABLESPACE_MAP_OLD</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* Check that the GUCs used to generate the WAL allow recovery */ 
</span>        <a href="xlog.c.html#LN853"><span class='Ref_to_Proto'>CheckRequiredParameterValues</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We're in recovery, so unlogged relations may be trashed and must be 
         * reset.  This should be done BEFORE allowing Hot Standby 
         * connections, so that read-only backends don't try to read whatever 
         * garbage is left over from before. 
         */ 
</span>        <a href="../../../include/storage/reinit.h.html#LN17"><span class='Ref_to_Proto'>ResetUnloggedRelations</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/reinit.h.html#LN19"><span class='Ref_to_Const'>UNLOGGED_RELATION_CLEANUP</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Likewise, delete any saved transaction snapshot files that got left 
         * behind by crashed backends. 
         */ 
</span>        <a href="../../../include/utils/snapmgr.h.html#LN91"><span class='Ref_to_Proto'>DeleteAllExportedSnapshotFiles</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Initialize for Hot Standby, if enabled. We won't let backends in 
         * yet, not until we've reached the min recovery point specified in 
         * control file and we've established a recovery snapshot from a 
         * running-xacts WAL record. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN245"><span class='Ref_to_Global_Var'>ArchiveRecoveryRequested</span></a> <span class='Operator'>&& </span><a href="xlog.c.html#LN95"><span class='Ref_to_Global_Var'>EnableHotStandby</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN6876"></a>            <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Operator'>*</span><span class='Declare_Local'>xids</span><span class='Delimiter'>; 
</span><a name="LN6877"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>nxids</span><span class='Delimiter'>; 
</span> 
            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN24"><span class='Ref_to_Const'>DEBUG1</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"initializing for hot standby"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
            <a href="../../../include/storage/standby.h.html#LN26"><span class='Ref_to_Proto'>InitRecoveryTransactionEnvironment</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN6192"><span class='Ref_To_Local'>wasShutdown</span></a><span class='Parentheses'>) 
</span>                <a href="xlog.c.html#LN6202"><span class='Ref_To_Local'>oldestActiveXID</span></a> <span class='Operator'>= </span><a href="../../../include/access/twophase.h.html#LN46"><span class='Ref_to_Proto'>PrescanPreparedTransactions</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN6876"><span class='Ref_To_Local'>xids</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN6877"><span class='Ref_To_Local'>nxids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="xlog.c.html#LN6202"><span class='Ref_To_Local'>oldestActiveXID</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN61"><span class='Ref_to_Member'>oldestActiveXid</span></a><span class='Delimiter'>; 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN6202"><span class='Ref_To_Local'>oldestActiveXID</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Tell procarray about the range of xids it has to deal with */ 
</span>            <a href="../../../include/storage/procarray.h.html#LN66"><span class='Ref_to_Proto'>ProcArrayInitRecovery</span></a><span class='Parentheses'>(</span><a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN116"><span class='Ref_to_Member'>nextXid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Startup commit log and subtrans only.  MultiXact and commit 
             * timestamp have already been started up and other SLRUs are not 
             * maintained during recovery and need not be started yet. 
             */ 
</span>            <a href="../../../include/access/clog.h.html#LN45"><span class='Ref_to_Proto'>StartupCLOG</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>            <a href="../../../include/access/subtrans.h.html#LN23"><span class='Ref_to_Proto'>StartupSUBTRANS</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN6202"><span class='Ref_To_Local'>oldestActiveXID</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * If we're beginning at a shutdown checkpoint, we know that 
             * nothing was running on the master at this point. So fake-up an 
             * empty running-xacts record and use that here and now. Recover 
             * additional standby state for prepared transactions. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN6192"><span class='Ref_To_Local'>wasShutdown</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN6909"></a>                <a href="../../../include/storage/standby.h.html#LN69"><span class='Ref_to_Struct'>RunningTransactionsData</span></a> <span class='Declare_Local'>running</span><span class='Delimiter'>; 
</span><a name="LN6910"></a>                <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>latestCompletedXid</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * Construct a RunningTransactions snapshot representing a 
                 * shut down server, with only prepared transactions still 
                 * alive. We're never overflowed at this point because all 
                 * subxids are listed with their parent prepared transactions. 
                 */ 
</span>                <a href="xlog.c.html#LN6909"><span class='Ref_To_Local'>running</span></a><span class='Operator'>.</span><a href="../../../include/storage/standby.h.html#LN71"><span class='Ref_to_Member'>xcnt</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN6877"><span class='Ref_To_Local'>nxids</span></a><span class='Delimiter'>; 
</span>                <a href="xlog.c.html#LN6909"><span class='Ref_To_Local'>running</span></a><span class='Operator'>.</span><a href="../../../include/storage/standby.h.html#LN72"><span class='Ref_to_Member'>subxcnt</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>                <a href="xlog.c.html#LN6909"><span class='Ref_To_Local'>running</span></a><span class='Operator'>.</span><a href="../../../include/storage/standby.h.html#LN73"><span class='Ref_to_Member'>subxid_overflow</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                <a href="xlog.c.html#LN6909"><span class='Ref_To_Local'>running</span></a><span class='Operator'>.</span><a href="../../../include/storage/standby.h.html#LN74"><span class='Ref_to_Member'>nextXid</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN41"><span class='Ref_to_Member'>nextXid</span></a><span class='Delimiter'>; 
</span>                <a href="xlog.c.html#LN6909"><span class='Ref_To_Local'>running</span></a><span class='Operator'>.</span><a href="../../../include/storage/standby.h.html#LN75"><span class='Ref_to_Member'>oldestRunningXid</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN6202"><span class='Ref_To_Local'>oldestActiveXID</span></a><span class='Delimiter'>; 
</span>                <a href="xlog.c.html#LN6910"><span class='Ref_To_Local'>latestCompletedXid</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN41"><span class='Ref_to_Member'>nextXid</span></a><span class='Delimiter'>; 
</span>                <a href="../../../include/access/transam.h.html#LN55"><span class='Ref_to_Macro'>TransactionIdRetreat</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN6910"><span class='Ref_To_Local'>latestCompletedXid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN6910"><span class='Ref_To_Local'>latestCompletedXid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <a href="xlog.c.html#LN6909"><span class='Ref_To_Local'>running</span></a><span class='Operator'>.</span><a href="../../../include/storage/standby.h.html#LN76"><span class='Ref_to_Member'>latestCompletedXid</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN6910"><span class='Ref_To_Local'>latestCompletedXid</span></a><span class='Delimiter'>; 
</span>                <a href="xlog.c.html#LN6909"><span class='Ref_To_Local'>running</span></a><span class='Operator'>.</span><a href="../../../include/storage/standby.h.html#LN78"><span class='Ref_to_Member'>xids</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN6876"><span class='Ref_To_Local'>xids</span></a><span class='Delimiter'>; 
</span> 
                <a href="../../../include/storage/procarray.h.html#LN67"><span class='Ref_to_Proto'>ProcArrayApplyRecoveryInfo</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN6909"><span class='Ref_To_Local'>running</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="../../../include/access/twophase.h.html#LN48"><span class='Ref_to_Proto'>StandbyRecoverPreparedTransactions</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if wasShutdown &raquo; </span> 
        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if ArchiveRecoveryReques... &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* Initialize resource managers */ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN6743"><span class='Ref_To_Local'>rmid</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="xlog.c.html#LN6743"><span class='Ref_To_Local'>rmid</span></a> <span class='Operator'>&LT;= </span><a href="../../../include/access/rmgr.h.html#LN32"><span class='Ref_to_Const'>RM_MAX_ID</span></a><span class='Delimiter'>; </span><a href="xlog.c.html#LN6743"><span class='Ref_To_Local'>rmid</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="rmgr.c.html#LN35"><span class='Ref_to_Global_Var'>RmgrTable</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN6743"><span class='Ref_To_Local'>rmid</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/access/xlog_internal.h.html#LN279"><span class='Ref_to_Member'>rm_startup</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>                <a href="rmgr.c.html#LN35"><span class='Ref_to_Global_Var'>RmgrTable</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN6743"><span class='Ref_To_Local'>rmid</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/access/xlog_internal.h.html#LN279"><span class='Ref_to_Member'>rm_startup</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Initialize shared variables for tracking progress of WAL replay, as 
         * if we had just replayed the record before the REDO location (or the 
         * checkpoint record itself, if it's a shutdown checkpoint). 
         */ 
</span>        <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN34"><span class='Ref_to_Member'>redo</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN6196"><span class='Ref_To_Local'>RecPtr</span></a><span class='Parentheses'>) 
</span>            <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN683"><span class='Ref_to_Member'>replayEndRecPtr</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN34"><span class='Ref_to_Member'>redo</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN683"><span class='Ref_to_Member'>replayEndRecPtr</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN818"><span class='Ref_to_Global_Var'>EndRecPtr</span></a><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN684"><span class='Ref_to_Member'>replayEndTLI</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN681"><span class='Ref_to_Member'>lastReplayedEndRecPtr</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN683"><span class='Ref_to_Member'>replayEndRecPtr</span></a><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN682"><span class='Ref_to_Member'>lastReplayedTLI</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN684"><span class='Ref_to_Member'>replayEndTLI</span></a><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN686"><span class='Ref_to_Member'>recoveryLastXTime</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN692"><span class='Ref_to_Member'>currentChunkStartTime</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN694"><span class='Ref_to_Member'>recoveryPause</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Also ensure XLogReceiptTime has a sane value */ 
</span>        <a href="xlog.c.html#LN813"><span class='Ref_to_Global_Var'>XLogReceiptTime</span></a> <span class='Operator'>= </span><a href="../../../include/utils/timestamp.h.html#LN69"><span class='Ref_to_Proto'>GetCurrentTimestamp</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Let postmaster know we've started redo now, so that it can launch 
         * checkpointer to perform restartpoints.  We don't bother during 
         * crash recovery as restartpoints can only be performed during 
         * archive recovery.  And we'd like to keep crash recovery simple, to 
         * avoid introducing bugs that could affect you when recovering after 
         * crash. 
         * 
         * After this point, we can no longer assume that we're the only 
         * process in addition to postmaster!  Also, fsync requests are 
         * subsequently to be handled by the checkpointer, not locally. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN245"><span class='Ref_to_Global_Var'>ArchiveRecoveryRequested</span></a> <span class='Operator'>&& </span><a href="../../utils/init/globals.c.html#LN100"><span class='Ref_to_Global_Var'>IsUnderPostmaster</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../../include/storage/proc.h.html#LN292"><span class='Ref_to_Proto'>PublishStartupProcessInformation</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>            <a href="../../../include/storage/smgr.h.html#LN140"><span class='Ref_to_Proto'>SetForwardFsyncRequests</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>            <a href="../../../include/storage/pmsignal.h.html#LN45"><span class='Ref_to_Proto'>SendPostmasterSignal</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/pmsignal.h.html#LN24"><span class='Ref_to_EnumConst'>PMSIGNAL_RECOVERY_STARTED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN835"><span class='Ref_to_Global_Var'>bgwriterLaunched</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Allow read-only connections immediately if we're consistent 
         * already. 
         */ 
</span>        <a href="xlog.c.html#LN888"><span class='Ref_to_Proto'>CheckRecoveryConsistency</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Find the first record that logically follows the checkpoint --- it 
         * might physically precede it, though. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN34"><span class='Ref_to_Member'>redo</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN6196"><span class='Ref_To_Local'>RecPtr</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* back up to find the record */ 
</span>            <a href="xlog.c.html#LN6201"><span class='Ref_To_Local'>record</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN886"><span class='Ref_to_Proto'>ReadRecord</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN6206"><span class='Ref_To_Local'>xlogreader</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN6191"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN34"><span class='Ref_to_Member'>redo</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* just have to read next record after CheckPoint */ 
</span>            <a href="xlog.c.html#LN6201"><span class='Ref_To_Local'>record</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN886"><span class='Ref_to_Proto'>ReadRecord</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN6206"><span class='Ref_To_Local'>xlogreader</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN6201"><span class='Ref_To_Local'>record</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN7006"></a>            ErrorContextCallback <span class='Declare_Local'>errcallback</span><span class='Delimiter'>; 
</span><a name="LN7007"></a>            <a href="../../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <span class='Declare_Local'>xtime</span><span class='Delimiter'>; 
</span> 
            <a href="xlog.c.html#LN832"><span class='Ref_to_Global_Var'>InRedo</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"redo starts at %X/%X"</span><span class='Delimiter'>, 
</span>                         <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN817"><span class='Ref_to_Global_Var'>ReadRecPtr</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN817"><span class='Ref_to_Global_Var'>ReadRecPtr</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * main redo apply loop 
             */ 
</span>            <span class='Control'>do</span> 
            <span class='Delimiter'>{ 
</span><a name="LN7020"></a>                <span class='Keyword'>bool</span>        <span class='Declare_Local'>switchedTLI</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifdef</span> WAL_DEBUG 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN109"><span class='Ref_to_Global_Var'>XLOG_DEBUG</span></a> <span class='Operator'>|| 
</span>                 <span class='Parentheses'>(</span><a href="xlog.c.html#LN6743"><span class='Ref_To_Local'>rmid</span></a> <span class='Operator'>== </span>RM_XACT_ID <span class='Operator'>&& </span><a href="../../utils/misc/guc.c.html#LN454"><span class='Ref_to_Global_Var'>trace_recovery_messages</span></a> <span class='Operator'>&LT;= </span><a href="../../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>                    <span class='Parentheses'>(</span><a href="xlog.c.html#LN6743"><span class='Ref_To_Local'>rmid</span></a> <span class='Operator'>!= </span>RM_XACT_ID <span class='Operator'>&& </span><a href="../../utils/misc/guc.c.html#LN454"><span class='Ref_to_Global_Var'>trace_recovery_messages</span></a> <span class='Operator'>&LT;= </span><a href="../../../include/utils/elog.h.html#LN22"><span class='Ref_to_Const'>DEBUG3</span></a><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span><a name="LN7027"></a>                    <a href="../../../include/lib/stringinfo.h.html#LN34"><span class='Ref_to_Struct'>StringInfoData</span></a> <span class='Declare_Local'>buf</span><span class='Delimiter'>; 
</span> 
                    <a href="../../lib/stringinfo.c.html#LN44"><span class='Ref_to_Func'>initStringInfo</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN7027"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="../../../bin/pg_waldump/compat.c.html#LN69"><span class='Ref_to_Func'>appendStringInfo</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN7027"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><span class='String'>"REDO @ %X/%X; LSN %X/%X: "</span><span class='Delimiter'>, 
</span>                            <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN817"><span class='Ref_to_Global_Var'>ReadRecPtr</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN817"><span class='Ref_to_Global_Var'>ReadRecPtr</span></a><span class='Delimiter'>, 
</span>                             <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN818"><span class='Ref_to_Global_Var'>EndRecPtr</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN818"><span class='Ref_to_Global_Var'>EndRecPtr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="xlog.c.html#LN898"><span class='Ref_to_Proto'>xlog_outrec</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN7027"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN6206"><span class='Ref_To_Local'>xlogreader</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="../../../bin/pg_waldump/compat.c.html#LN79"><span class='Ref_to_Func'>appendStringInfoString</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN7027"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><span class='String'>" - "</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="xlog.c.html#LN900"><span class='Ref_to_Proto'>xlog_outdesc</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN7027"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN6206"><span class='Ref_To_Local'>xlogreader</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, </span><span class='String'>"%s"</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN7027"><span class='Ref_To_Local'>buf</span></a><span class='Operator'>.</span><a href="../../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN7027"><span class='Ref_To_Local'>buf</span></a><span class='Operator'>.</span><a href="../../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span><span class='Directive'>#endif</span> 
 
                <span class='Comment_Multi_Line'>/* Handle interrupt signals of startup process */ 
</span>                <a href="../../../include/postmaster/startup.h.html#LN14"><span class='Ref_to_Proto'>HandleStartupProcInterrupts</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * Pause WAL replay, if requested by a hot-standby session via 
                 * SetRecoveryPause(). 
                 * 
                 * Note that we intentionally don't take the info_lck spinlock 
                 * here.  We might therefore read a slightly stale value of 
                 * the recoveryPause flag, but it can't be very stale (no 
                 * worse than the last spinlock we did acquire).  Since a 
                 * pause request is a pretty asynchronous thing anyway, 
                 * possibly responding to it one WAL record later than we 
                 * otherwise would is a minor issue, so it doesn't seem worth 
                 * adding another spinlock cycle to prevent that. 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(((</span><span class='Keyword'>volatile </span><a href="xlog.c.html#LN572"><span class='Ref_to_Struct'>XLogCtlData</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN694"><span class='Ref_to_Member'>recoveryPause</span></a><span class='Parentheses'>)</span> 
                    <a href="xlog.c.html#LN849"><span class='Ref_to_Proto'>recoveryPausesHere</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * Have we reached our recovery target? 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN847"><span class='Ref_to_Proto'>recoveryStopsBefore</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN6206"><span class='Ref_To_Local'>xlogreader</span></a><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span>                    <a href="xlog.c.html#LN6193"><span class='Ref_To_Local'>reachedStopPoint</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* see below */ 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * If we've been asked to lag the master, wait on latch until 
                 * enough time has passed. 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN850"><span class='Ref_to_Proto'>recoveryApplyDelay</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN6206"><span class='Ref_To_Local'>xlogreader</span></a><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* 
                     * We test for paused recovery again here. If user sets 
                     * delayed apply, it may be because they expect to pause 
                     * recovery in case of problems, so we must test again 
                     * here otherwise pausing during the delay-wait wouldn't 
                     * work. 
                     */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(((</span><span class='Keyword'>volatile </span><a href="xlog.c.html#LN572"><span class='Ref_to_Struct'>XLogCtlData</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN694"><span class='Ref_to_Member'>recoveryPause</span></a><span class='Parentheses'>)</span> 
                        <a href="xlog.c.html#LN849"><span class='Ref_to_Proto'>recoveryPausesHere</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
                <span class='Comment_Multi_Line'>/* Setup error traceback support for ereport() */ 
</span>                <a href="xlog.c.html#LN7006"><span class='Ref_To_Local'>errcallback</span></a><span class='Operator'>.</span>callback <span class='Operator'>= </span><a href="xlog.c.html#LN907"><span class='Ref_to_Proto'>rm_redo_error_callback</span></a><span class='Delimiter'>; 
</span>                <a href="xlog.c.html#LN7006"><span class='Ref_To_Local'>errcallback</span></a><span class='Operator'>.</span>arg <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="xlog.c.html#LN6206"><span class='Ref_To_Local'>xlogreader</span></a><span class='Delimiter'>; 
</span>                <a href="xlog.c.html#LN7006"><span class='Ref_To_Local'>errcallback</span></a><span class='Operator'>.</span>previous <span class='Operator'>= </span><a href="../../utils/error/elog.c.html#LN87"><span class='Ref_to_Global_Var'>error_context_stack</span></a><span class='Delimiter'>; 
</span>                <a href="../../utils/error/elog.c.html#LN87"><span class='Ref_to_Global_Var'>error_context_stack</span></a> <span class='Operator'>= &</span><a href="xlog.c.html#LN7006"><span class='Ref_To_Local'>errcallback</span></a><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * ShmemVariableCache-&GT;nextXid must be beyond record's xid. 
                 * 
                 * We don't expect anyone else to modify nextXid, hence we 
                 * don't need to hold a lock while examining it.  We still 
                 * acquire the lock to modify it, though. 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN171"><span class='Ref_to_Proto'>TransactionIdFollowsOrEquals</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN6201"><span class='Ref_To_Local'>record</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogrecord.h.html#LN43"><span class='Ref_to_Member'>xl_xid</span></a><span class='Delimiter'>, 
</span>                                                 <a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN116"><span class='Ref_to_Member'>nextXid</span></a><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span>                    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>XidGenLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN116"><span class='Ref_to_Member'>nextXid</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN6201"><span class='Ref_To_Local'>record</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogrecord.h.html#LN43"><span class='Ref_to_Member'>xl_xid</span></a><span class='Delimiter'>; 
</span>                    <a href="../../../include/access/transam.h.html#LN47"><span class='Ref_to_Macro'>TransactionIdAdvance</span></a><span class='Parentheses'>(</span><a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN116"><span class='Ref_to_Member'>nextXid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>XidGenLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * Before replaying this record, check if this record causes 
                 * the current timeline to change. The record is already 
                 * considered to be part of the new timeline, so we update 
                 * ThisTimeLineID before replaying it. That's important so 
                 * that replayEndTLI, which is recorded as the minimum 
                 * recovery point's TLI if recovery stops after this record, 
                 * is set correctly. 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN6201"><span class='Ref_To_Local'>record</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogrecord.h.html#LN46"><span class='Ref_to_Member'>xl_rmid</span></a> <span class='Operator'>== </span>RM_XLOG_ID<span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span><a name="LN7119"></a>                    <a href="../../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a>  <span class='Declare_Local'>newTLI</span> <span class='Operator'>= </span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Delimiter'>; 
</span><a name="LN7120"></a>                    <a href="../../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a>  <span class='Declare_Local'>prevTLI</span> <span class='Operator'>= </span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Delimiter'>; 
</span><a name="LN7121"></a>                    <a href="../../../include/c.h.html#LN265"><span class='Ref_to_Typedef'>uint8</span></a>       <span class='Declare_Local'>info</span> <span class='Operator'>= </span><a href="xlog.c.html#LN6201"><span class='Ref_To_Local'>record</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogrecord.h.html#LN45"><span class='Ref_to_Member'>xl_info</span></a> <span class='Operator'>& ~</span><a href="../../../include/access/xlogrecord.h.html#LN61"><span class='Ref_to_Const'>XLR_INFO_MASK</span></a><span class='Delimiter'>; 
</span> 
                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN7121"><span class='Ref_To_Local'>info</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_control.h.html#LN65"><span class='Ref_to_Const'>XLOG_CHECKPOINT_SHUTDOWN</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span><a name="LN7125"></a>                        <a href="../../../include/catalog/pg_control.h.html#LN32"><span class='Ref_to_Struct'>CheckPoint</span></a>  <span class='Declare_Local'>checkPoint</span><span class='Delimiter'>; 
</span> 
                        memcpy<span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN7125"><span class='Ref_To_Local'>checkPoint</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xlogreader.h.html#LN219"><span class='Ref_to_Macro'>XLogRecGetData</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN6206"><span class='Ref_To_Local'>xlogreader</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_control.h.html#LN32"><span class='Ref_to_Struct'>CheckPoint</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                        <a href="xlog.c.html#LN7119"><span class='Ref_To_Local'>newTLI</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN7125"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN36"><span class='Ref_to_Member'>ThisTimeLineID</span></a><span class='Delimiter'>; 
</span>                        <a href="xlog.c.html#LN7120"><span class='Ref_To_Local'>prevTLI</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN7125"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN37"><span class='Ref_to_Member'>PrevTimeLineID</span></a><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN7121"><span class='Ref_To_Local'>info</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_control.h.html#LN74"><span class='Ref_to_Const'>XLOG_END_OF_RECOVERY</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span><a name="LN7133"></a>                        <a href="../../../include/access/xlog_internal.h.html#LN229"><span class='Ref_to_Struct'>xl_end_of_recovery</span></a> <span class='Declare_Local'>xlrec</span><span class='Delimiter'>; 
</span> 
                        memcpy<span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN7133"><span class='Ref_To_Local'>xlrec</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xlogreader.h.html#LN219"><span class='Ref_to_Macro'>XLogRecGetData</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN6206"><span class='Ref_To_Local'>xlogreader</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/access/xlog_internal.h.html#LN229"><span class='Ref_to_Struct'>xl_end_of_recovery</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                        <a href="xlog.c.html#LN7119"><span class='Ref_To_Local'>newTLI</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN7133"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog_internal.h.html#LN232"><span class='Ref_to_Member'>ThisTimeLineID</span></a><span class='Delimiter'>; 
</span>                        <a href="xlog.c.html#LN7120"><span class='Ref_To_Local'>prevTLI</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN7133"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog_internal.h.html#LN233"><span class='Ref_to_Member'>PrevTimeLineID</span></a><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span> 
                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN7119"><span class='Ref_To_Local'>newTLI</span></a> <span class='Operator'>!= </span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <span class='Comment_Multi_Line'>/* Check that it's OK to switch to this TLI */ 
</span>                        <a href="xlog.c.html#LN855"><span class='Ref_to_Proto'>checkTimeLineSwitch</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN818"><span class='Ref_to_Global_Var'>EndRecPtr</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN7119"><span class='Ref_To_Local'>newTLI</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN7120"><span class='Ref_To_Local'>prevTLI</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                        <span class='Comment_Multi_Line'>/* Following WAL records should be run with new TLI */ 
</span>                        <a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN7119"><span class='Ref_To_Local'>newTLI</span></a><span class='Delimiter'>; 
</span>                        <a href="xlog.c.html#LN7020"><span class='Ref_To_Local'>switchedTLI</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if record-&GT;xl_rmid==RM_X... &raquo; </span> 
 
                <span class='Comment_Multi_Line'>/* 
                 * Update shared replayEndRecPtr before replaying this record, 
                 * so that XLogFlush will update minRecoveryPoint correctly. 
                 */ 
</span>                <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN683"><span class='Ref_to_Member'>replayEndRecPtr</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN818"><span class='Ref_to_Global_Var'>EndRecPtr</span></a><span class='Delimiter'>; 
</span>                <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN684"><span class='Ref_to_Member'>replayEndTLI</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Delimiter'>; 
</span>                <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * If we are attempting to enter Hot Standby mode, process 
                 * XIDs we see 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN194"><span class='Ref_to_Global_Var'>standbyState</span></a> <span class='Operator'>&GT;= </span><a href="../../../include/access/xlog.h.html#LN66"><span class='Ref_to_EnumConst'>STANDBY_INITIALIZED</span></a> <span class='Operator'>&& 
</span>                    <a href="../../../include/access/transam.h.html#LN40"><span class='Ref_to_Macro'>TransactionIdIsValid</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN6201"><span class='Ref_To_Local'>record</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogrecord.h.html#LN43"><span class='Ref_to_Member'>xl_xid</span></a><span class='Parentheses'>))</span> 
                    <a href="../../../include/storage/procarray.h.html#LN71"><span class='Ref_to_Proto'>RecordKnownAssignedTransactionIds</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN6201"><span class='Ref_To_Local'>record</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogrecord.h.html#LN43"><span class='Ref_to_Member'>xl_xid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* Now apply the WAL record itself */ 
</span>                <a href="rmgr.c.html#LN35"><span class='Ref_to_Global_Var'>RmgrTable</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN6201"><span class='Ref_To_Local'>record</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogrecord.h.html#LN46"><span class='Ref_to_Member'>xl_rmid</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/access/xlog_internal.h.html#LN276"><span class='Ref_to_Member'>rm_redo</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN6206"><span class='Ref_To_Local'>xlogreader</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * After redo, check whether the backup pages associated with 
                 * the WAL record are consistent with the existing pages. This 
                 * check is done only if consistency check is enabled for this 
                 * record. 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="xlog.c.html#LN6201"><span class='Ref_To_Local'>record</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogrecord.h.html#LN45"><span class='Ref_to_Member'>xl_info</span></a> <span class='Operator'>& </span><a href="../../../include/access/xlogrecord.h.html#LN79"><span class='Ref_to_Const'>XLR_CHECK_CONSISTENCY</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                    <a href="xlog.c.html#LN922"><span class='Ref_to_Proto'>checkXLogConsistency</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN6206"><span class='Ref_To_Local'>xlogreader</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* Pop the error context stack */ 
</span>                <a href="../../utils/error/elog.c.html#LN87"><span class='Ref_to_Global_Var'>error_context_stack</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN7006"><span class='Ref_To_Local'>errcallback</span></a><span class='Operator'>.</span>previous<span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * Update lastReplayedEndRecPtr after this record has been 
                 * successfully replayed. 
                 */ 
</span>                <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN681"><span class='Ref_to_Member'>lastReplayedEndRecPtr</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN818"><span class='Ref_to_Global_Var'>EndRecPtr</span></a><span class='Delimiter'>; 
</span>                <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN682"><span class='Ref_to_Member'>lastReplayedTLI</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Delimiter'>; 
</span>                <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * If rm_redo called XLogRequestWalReceiverReply, then we wake 
                 * up the receiver so that it notices the updated 
                 * lastReplayedEndRecPtr and sends a reply to the master. 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN359"><span class='Ref_to_Global_Var'>doRequestWalReceiverReply</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <a href="xlog.c.html#LN359"><span class='Ref_to_Global_Var'>doRequestWalReceiverReply</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                    <a href="../../../include/replication/walreceiver.h.html#LN298"><span class='Ref_to_Proto'>WalRcvForceReply</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
                <span class='Comment_Multi_Line'>/* Remember this record as the last-applied one */ 
</span>                <a href="xlog.c.html#LN196"><span class='Ref_to_Global_Var'>LastRec</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN817"><span class='Ref_to_Global_Var'>ReadRecPtr</span></a><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* Allow read-only connections if we're consistent now */ 
</span>                <a href="xlog.c.html#LN888"><span class='Ref_to_Proto'>CheckRecoveryConsistency</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* Is this a timeline switch? */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN7020"><span class='Ref_To_Local'>switchedTLI</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* 
                     * Before we continue on the new timeline, clean up any 
                     * (possibly bogus) future WAL segments on the old 
                     * timeline. 
                     */ 
</span>                    <a href="xlog.c.html#LN3901"><span class='Ref_to_Func'>RemoveNonParentXlogFiles</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN818"><span class='Ref_to_Global_Var'>EndRecPtr</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * Wake up any walsenders to notice that we are on a new 
                     * timeline. 
                     */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN7020"><span class='Ref_To_Local'>switchedTLI</span></a> <span class='Operator'>&& </span><a href="../../../include/replication/walreceiver.h.html#LN37"><span class='Ref_to_Macro'>AllowCascadeReplication</span></a><span class='Parentheses'>())</span> 
                        <a href="../../../include/replication/walsender.h.html#LN45"><span class='Ref_to_Proto'>WalSndWakeup</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
                <span class='Comment_Multi_Line'>/* Exit loop if we reached inclusive recovery target */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN848"><span class='Ref_to_Proto'>recoveryStopsAfter</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN6206"><span class='Ref_To_Local'>xlogreader</span></a><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span>                    <a href="xlog.c.html#LN6193"><span class='Ref_To_Local'>reachedStopPoint</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
                <span class='Comment_Multi_Line'>/* Else, try to fetch the next WAL record */ 
</span>                <a href="xlog.c.html#LN6201"><span class='Ref_To_Local'>record</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN886"><span class='Ref_to_Proto'>ReadRecord</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN6206"><span class='Ref_To_Local'>xlogreader</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end do &raquo; </span> <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN6201"><span class='Ref_To_Local'>record</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * end of main redo apply loop 
             */ 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN6193"><span class='Ref_To_Local'>reachedStopPoint</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN830"><span class='Ref_to_Global_Var'>reachedConsistency</span></a><span class='Parentheses'>) 
</span>                    <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                            <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"requested recovery stop point is before consistent recovery point"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * This is the last point where we can restart recovery with a 
                 * new recovery target, if we shutdown and begin again. After 
                 * this, Resource Managers may choose to do permanent 
                 * corrective actions at end of recovery. 
                 */ 
</span>                <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN261"><span class='Ref_to_Global_Var'>recoveryTargetAction</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <span class='Control'>case</span> <a href="../../../include/access/xlog_internal.h.html#LN254"><span class='Ref_to_EnumConst'>RECOVERY_TARGET_ACTION_SHUTDOWN</span></a><span class='Operator'>: 
</span> 
                        <span class='Comment_Multi_Line'>/* 
                         * exit with special return code to request shutdown 
                         * of postmaster.  Log messages issued from 
                         * postmaster. 
                         */ 
</span>                        <a href="../../storage/ipc/ipc.c.html#LN97"><span class='Ref_to_Func'>proc_exit</span></a><span class='Parentheses'>(</span><span class='Number'>3</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                    <span class='Control'>case</span> <a href="../../../include/access/xlog_internal.h.html#LN252"><span class='Ref_to_EnumConst'>RECOVERY_TARGET_ACTION_PAUSE</span></a><span class='Operator'>: 
</span>                        <a href="../../../include/access/xlog.h.html#LN251"><span class='Ref_to_Proto'>SetRecoveryPause</span></a><span class='Parentheses'>(</span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                        <a href="xlog.c.html#LN849"><span class='Ref_to_Proto'>recoveryPausesHere</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
                        <span class='Comment_Multi_Line'>/* drop into promote */ 
</span> 
                    <span class='Control'>case</span> <a href="../../../include/access/xlog_internal.h.html#LN253"><span class='Ref_to_EnumConst'>RECOVERY_TARGET_ACTION_PROMOTE</span></a><span class='Operator'>: 
</span>                        <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch recoveryTargetAction &raquo; </span> 
            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if reachedStopPoint &raquo; </span> 
 
            <span class='Comment_Multi_Line'>/* Allow resource managers to do any required cleanup. */ 
</span>            <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN6743"><span class='Ref_To_Local'>rmid</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="xlog.c.html#LN6743"><span class='Ref_To_Local'>rmid</span></a> <span class='Operator'>&LT;= </span><a href="../../../include/access/rmgr.h.html#LN32"><span class='Ref_to_Const'>RM_MAX_ID</span></a><span class='Delimiter'>; </span><a href="xlog.c.html#LN6743"><span class='Ref_To_Local'>rmid</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="rmgr.c.html#LN35"><span class='Ref_to_Global_Var'>RmgrTable</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN6743"><span class='Ref_To_Local'>rmid</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/access/xlog_internal.h.html#LN280"><span class='Ref_to_Member'>rm_cleanup</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>                    <a href="rmgr.c.html#LN35"><span class='Ref_to_Global_Var'>RmgrTable</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN6743"><span class='Ref_To_Local'>rmid</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/access/xlog_internal.h.html#LN280"><span class='Ref_to_Member'>rm_cleanup</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"redo done at %X/%X"</span><span class='Delimiter'>, 
</span>                         <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN817"><span class='Ref_to_Global_Var'>ReadRecPtr</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN817"><span class='Ref_to_Global_Var'>ReadRecPtr</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN7007"><span class='Ref_To_Local'>xtime</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlog.h.html#LN252"><span class='Ref_to_Proto'>GetLatestXTime</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN7007"><span class='Ref_To_Local'>xtime</span></a><span class='Parentheses'>) 
</span>                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                     <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"last completed transaction was at log time %s"</span><span class='Delimiter'>, 
</span>                             <a href="../../../bin/pg_waldump/compat.c.html#LN48"><span class='Ref_to_Func'>timestamptz_to_str</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN7007"><span class='Ref_To_Local'>xtime</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span> 
            <a href="xlog.c.html#LN832"><span class='Ref_to_Global_Var'>InRedo</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if record!=NULL &raquo; </span> 
        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* there are no WAL records following the checkpoint */ 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"redo is not required"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if InRecovery &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Kill WAL receiver, if it's still running, before we continue to write 
     * the startup checkpoint record. It will trump over the checkpoint and 
     * subsequent records if it's still alive when we start writing WAL. 
     */ 
</span>    <a href="../../replication/walreceiverfuncs.c.html#LN161"><span class='Ref_to_Func'>ShutdownWalRcv</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Reset unlogged relations to the contents of their INIT fork. This is 
     * done AFTER recovery is complete so as to include any unlogged relations 
     * created during recovery, but BEFORE recovery is marked as having 
     * completed successfully. Otherwise we'd not retry if any of the post 
     * end-of-recovery steps fail. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN191"><span class='Ref_to_Global_Var'>InRecovery</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/reinit.h.html#LN17"><span class='Ref_to_Proto'>ResetUnloggedRelations</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/reinit.h.html#LN20"><span class='Ref_to_Const'>UNLOGGED_RELATION_INIT</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We don't need the latch anymore. It's not strictly necessary to disown 
     * it, but let's do it for the sake of tidiness. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN270"><span class='Ref_to_Global_Var'>StandbyModeRequested</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/latch.h.html#LN150"><span class='Ref_to_Proto'>DisownLatch</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN661"><span class='Ref_to_Member'>recoveryWakeupLatch</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We are now done reading the xlog from stream. Turn off streaming 
     * recovery to force fetching the files (which would be required at end of 
     * recovery, e.g., timeline history file) from archive or pg_wal. 
     */ 
</span>    <a href="xlog.c.html#LN276"><span class='Ref_to_Global_Var'>StandbyMode</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Re-fetch the last valid or last applied record, so we can identify the 
     * exact endpoint of what we consider the valid portion of WAL. 
     */ 
</span>    <a href="xlog.c.html#LN6201"><span class='Ref_To_Local'>record</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN886"><span class='Ref_to_Proto'>ReadRecord</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN6206"><span class='Ref_To_Local'>xlogreader</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN196"><span class='Ref_to_Global_Var'>LastRec</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN6198"><span class='Ref_To_Local'>EndOfLog</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN818"><span class='Ref_to_Global_Var'>EndRecPtr</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * EndOfLogTLI is the TLI in the filename of the XLOG segment containing 
     * the end-of-log. It could be different from the timeline that EndOfLog 
     * nominally belongs to, if there was a timeline switch in that segment, 
     * and we were reading the old WAL from a segment belonging to a higher 
     * timeline. 
     */ 
</span>    <a href="xlog.c.html#LN6199"><span class='Ref_To_Local'>EndOfLogTLI</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN6206"><span class='Ref_To_Local'>xlogreader</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogreader.h.html#LN152"><span class='Ref_to_Member'>readPageTLI</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Complain if we did not roll forward far enough to render the backup 
     * dump consistent.  Note: it is indeed okay to look at the local variable 
     * minRecoveryPoint here, even though ControlFile-&GT;minRecoveryPoint might 
     * be further ahead --- ControlFile-&GT;minRecoveryPoint cannot have been 
     * advanced beyond the WAL we processed. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN191"><span class='Ref_to_Global_Var'>InRecovery</span></a> <span class='Operator'>&& 
</span>        <span class='Parentheses'>(</span><a href="xlog.c.html#LN6198"><span class='Ref_To_Local'>EndOfLog</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN820"><span class='Ref_to_Global_Var'>minRecoveryPoint</span></a> <span class='Operator'>|| 
</span>         <span class='Operator'>!</span><a href="../../../include/access/xlogdefs.h.html#LN28"><span class='Ref_to_Macro'>XLogRecPtrIsInvalid</span></a><span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN171"><span class='Ref_to_Member'>backupStartPoint</span></a><span class='Parentheses'>)))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Ran off end of WAL before reaching end-of-backup WAL record, or 
         * minRecoveryPoint. That's usually a bad sign, indicating that you 
         * tried to recover from an online backup but never called 
         * pg_stop_backup(), or you didn't archive all the WAL up to that 
         * point. However, this also happens in crash recovery, if the system 
         * crashes while an online backup is in progress. We must not treat 
         * that as an error, or the database will refuse to start up. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN245"><span class='Ref_to_Global_Var'>ArchiveRecoveryRequested</span></a> <span class='Operator'>|| </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN173"><span class='Ref_to_Member'>backupEndRequired</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN173"><span class='Ref_to_Member'>backupEndRequired</span></a><span class='Parentheses'>) 
</span>                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"WAL ends before end of online backup"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"All WAL generated while online backup was taken must be available at recovery."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/xlogdefs.h.html#LN28"><span class='Ref_to_Macro'>XLogRecPtrIsInvalid</span></a><span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN171"><span class='Ref_to_Member'>backupStartPoint</span></a><span class='Parentheses'>))</span> 
                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"WAL ends before end of online backup"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"Online backup started with pg_start_backup() must be ended with pg_stop_backup(), and all WAL up to that point must be available at recovery."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                      <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"WAL ends before consistent recovery point"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if InRecovery&&(EndOfLog... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Consider whether we need to assign a new timeline ID. 
     * 
     * If we are doing an archive recovery, we always assign a new ID.  This 
     * handles a couple of issues.  If we stopped short of the end of WAL 
     * during recovery, then we are clearly generating a new timeline and must 
     * assign it a unique new ID.  Even if we ran to the end, modifying the 
     * current last segment is problematic because it may result in trying to 
     * overwrite an already-archived copy of that segment, and we encourage 
     * DBAs to make their archive_commands reject that.  We can dodge the 
     * problem by making the new active segment have a new timeline ID. 
     * 
     * In a normal crash recovery, we can just extend the timeline we were in. 
     */ 
</span>    <a href="xlog.c.html#LN6200"><span class='Ref_To_Local'>PrevTimeLineID</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN245"><span class='Ref_to_Global_Var'>ArchiveRecoveryRequested</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN7402"></a>        <span class='Keyword'>char</span>        <span class='Declare_Local'>reason</span><span class='Delimiter'>[</span><span class='Number'>200</span><span class='Delimiter'>]; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN246"><span class='Ref_to_Global_Var'>InArchiveRecovery</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a> <span class='Operator'>= </span><a href="../../../include/access/timeline.h.html#LN33"><span class='Ref_to_Proto'>findNewestTimeLine</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN315"><span class='Ref_to_Global_Var'>recoveryTargetTLI</span></a><span class='Parentheses'>) </span><span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"selected new timeline ID: %u"</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Create a comment for the history file to explain why and where 
         * timeline changed. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN259"><span class='Ref_to_Global_Var'>recoveryTarget</span></a> <span class='Operator'>== </span><a href="../../../include/access/xlog.h.html#LN82"><span class='Ref_to_EnumConst'>RECOVERY_TARGET_XID</span></a><span class='Parentheses'>) 
</span>            <a href="../../../pl/plperl/plperl.h.html#LN60"><span class='Ref_to_Macro'>snprintf</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN7402"><span class='Ref_To_Local'>reason</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN7402"><span class='Ref_To_Local'>reason</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <span class='String'>"%s transaction %u"</span><span class='Delimiter'>, 
</span>                     <a href="xlog.c.html#LN289"><span class='Ref_to_Global_Var'>recoveryStopAfter</span></a> <span class='Operator'>? </span><span class='String'>"after"</span> <span class='Operator'>: </span><span class='String'>"before"</span><span class='Delimiter'>, 
</span>                     <a href="xlog.c.html#LN285"><span class='Ref_to_Global_Var'>recoveryStopXid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN259"><span class='Ref_to_Global_Var'>recoveryTarget</span></a> <span class='Operator'>== </span><a href="../../../include/access/xlog.h.html#LN83"><span class='Ref_to_EnumConst'>RECOVERY_TARGET_TIME</span></a><span class='Parentheses'>) 
</span>            <a href="../../../pl/plperl/plperl.h.html#LN60"><span class='Ref_to_Macro'>snprintf</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN7402"><span class='Ref_To_Local'>reason</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN7402"><span class='Ref_To_Local'>reason</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <span class='String'>"%s %s\n"</span><span class='Delimiter'>, 
</span>                     <a href="xlog.c.html#LN289"><span class='Ref_to_Global_Var'>recoveryStopAfter</span></a> <span class='Operator'>? </span><span class='String'>"after"</span> <span class='Operator'>: </span><span class='String'>"before"</span><span class='Delimiter'>, 
</span>                     <a href="../../../bin/pg_waldump/compat.c.html#LN48"><span class='Ref_to_Func'>timestamptz_to_str</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN286"><span class='Ref_to_Global_Var'>recoveryStopTime</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN259"><span class='Ref_to_Global_Var'>recoveryTarget</span></a> <span class='Operator'>== </span><a href="../../../include/access/xlog.h.html#LN85"><span class='Ref_to_EnumConst'>RECOVERY_TARGET_LSN</span></a><span class='Parentheses'>) 
</span>            <a href="../../../pl/plperl/plperl.h.html#LN60"><span class='Ref_to_Macro'>snprintf</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN7402"><span class='Ref_To_Local'>reason</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN7402"><span class='Ref_To_Local'>reason</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <span class='String'>"%s LSN %X/%X\n"</span><span class='Delimiter'>, 
</span>                     <a href="xlog.c.html#LN289"><span class='Ref_to_Global_Var'>recoveryStopAfter</span></a> <span class='Operator'>? </span><span class='String'>"after"</span> <span class='Operator'>: </span><span class='String'>"before"</span><span class='Delimiter'>, 
</span>                     <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN287"><span class='Ref_to_Global_Var'>recoveryStopLSN</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN287"><span class='Ref_to_Global_Var'>recoveryStopLSN</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN259"><span class='Ref_to_Global_Var'>recoveryTarget</span></a> <span class='Operator'>== </span><a href="../../../include/access/xlog.h.html#LN84"><span class='Ref_to_EnumConst'>RECOVERY_TARGET_NAME</span></a><span class='Parentheses'>) 
</span>            <a href="../../../pl/plperl/plperl.h.html#LN60"><span class='Ref_to_Macro'>snprintf</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN7402"><span class='Ref_To_Local'>reason</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN7402"><span class='Ref_To_Local'>reason</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <span class='String'>"at restore point \"%s\""</span><span class='Delimiter'>, 
</span>                     <a href="xlog.c.html#LN288"><span class='Ref_to_Global_Var'>recoveryStopName</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN259"><span class='Ref_to_Global_Var'>recoveryTarget</span></a> <span class='Operator'>== </span><a href="../../../include/access/xlog.h.html#LN86"><span class='Ref_to_EnumConst'>RECOVERY_TARGET_IMMEDIATE</span></a><span class='Parentheses'>) 
</span>            <a href="../../../pl/plperl/plperl.h.html#LN60"><span class='Ref_to_Macro'>snprintf</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN7402"><span class='Ref_To_Local'>reason</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN7402"><span class='Ref_To_Local'>reason</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='String'>"reached consistency"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="../../../pl/plperl/plperl.h.html#LN60"><span class='Ref_to_Macro'>snprintf</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN7402"><span class='Ref_To_Local'>reason</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN7402"><span class='Ref_To_Local'>reason</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='String'>"no recovery target specified"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/access/timeline.h.html#LN34"><span class='Ref_to_Proto'>writeTimeLineHistory</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN315"><span class='Ref_to_Global_Var'>recoveryTargetTLI</span></a><span class='Delimiter'>, 
</span>                             <a href="xlog.c.html#LN818"><span class='Ref_to_Global_Var'>EndRecPtr</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN7402"><span class='Ref_To_Local'>reason</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if ArchiveRecoveryReques... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* Save the selected TimeLineID in shared memory, too */ 
</span>    <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN628"><span class='Ref_to_Member'>ThisTimeLineID</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN629"><span class='Ref_to_Member'>PrevTimeLineID</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN6200"><span class='Ref_To_Local'>PrevTimeLineID</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We are now done reading the old WAL.  Turn off archive fetching if it 
     * was active, and make a writable copy of the last WAL segment. (Note 
     * that we also have a copy of the last block of the old WAL in readBuf; 
     * we will use that below.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN245"><span class='Ref_to_Global_Var'>ArchiveRecoveryRequested</span></a><span class='Parentheses'>) 
</span>        <a href="xlog.c.html#LN846"><span class='Ref_to_Proto'>exitArchiveRecovery</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN6199"><span class='Ref_To_Local'>EndOfLogTLI</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN6198"><span class='Ref_To_Local'>EndOfLog</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Prepare to write WAL starting at EndOfLog location, and init xlog 
     * buffer cache using the block containing the last record from the 
     * previous incarnation. 
     */ 
</span>    <a href="xlog.c.html#LN6190"><span class='Ref_To_Local'>Insert</span></a> <span class='Operator'>= &</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN574"><span class='Ref_to_Member'>Insert</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN6190"><span class='Ref_To_Local'>Insert</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN526"><span class='Ref_to_Member'>PrevBytePos</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN921"><span class='Ref_to_Proto'>XLogRecPtrToBytePos</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN196"><span class='Ref_to_Global_Var'>LastRec</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN6190"><span class='Ref_To_Local'>Insert</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN525"><span class='Ref_to_Member'>CurrBytePos</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN921"><span class='Ref_to_Proto'>XLogRecPtrToBytePos</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN6198"><span class='Ref_To_Local'>EndOfLog</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Tricky point here: readBuf contains the *last* block that the LastRec 
     * record spans, not the one it starts in.  The last block is indeed the 
     * one we want to use. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN6198"><span class='Ref_To_Local'>EndOfLog</span></a> <span class='Operator'>% </span>XLOG_BLCKSZ <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN7472"></a>        <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>page</span><span class='Delimiter'>; 
</span><a name="LN7473"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>len</span><span class='Delimiter'>; 
</span><a name="LN7474"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>firstIdx</span><span class='Delimiter'>; 
</span><a name="LN7475"></a>        <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>pageBeginPtr</span><span class='Delimiter'>; 
</span> 
        <a href="xlog.c.html#LN7475"><span class='Ref_To_Local'>pageBeginPtr</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN6198"><span class='Ref_To_Local'>EndOfLog</span></a> <span class='Operator'>- </span><span class='Parentheses'>(</span><a href="xlog.c.html#LN6198"><span class='Ref_To_Local'>EndOfLog</span></a> <span class='Operator'>% </span>XLOG_BLCKSZ<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN784"><span class='Ref_to_Global_Var'>readOff</span></a> <span class='Operator'>== </span><a href="xlog.c.html#LN7475"><span class='Ref_To_Local'>pageBeginPtr</span></a> <span class='Operator'>% </span><a href="../../../include/access/xlog_internal.h.html#LN91"><span class='Ref_to_Const'>XLogSegSize</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="xlog.c.html#LN7474"><span class='Ref_To_Local'>firstIdx</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN730"><span class='Ref_to_Macro'>XLogRecPtrToBufIdx</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN6198"><span class='Ref_To_Local'>EndOfLog</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Copy the valid part of the last block, and zero the rest */ 
</span>        <a href="xlog.c.html#LN7472"><span class='Ref_To_Local'>page</span></a> <span class='Operator'>= &</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN618"><span class='Ref_to_Member'>pages</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN7474"><span class='Ref_To_Local'>firstIdx</span></a> <span class='Operator'>* </span>XLOG_BLCKSZ<span class='Delimiter'>]; 
</span>        <a href="xlog.c.html#LN7473"><span class='Ref_To_Local'>len</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN6198"><span class='Ref_To_Local'>EndOfLog</span></a> <span class='Operator'>% </span>XLOG_BLCKSZ<span class='Delimiter'>; 
</span>        memcpy<span class='Parentheses'>(</span><a href="xlog.c.html#LN7472"><span class='Ref_To_Local'>page</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN6206"><span class='Ref_To_Local'>xlogreader</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogreader.h.html#LN146"><span class='Ref_to_Member'>readBuf</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN7473"><span class='Ref_To_Local'>len</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        memset<span class='Parentheses'>(</span><a href="xlog.c.html#LN7472"><span class='Ref_To_Local'>page</span></a> <span class='Operator'>+ </span><a href="xlog.c.html#LN7473"><span class='Ref_To_Local'>len</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span>XLOG_BLCKSZ <span class='Operator'>- </span><a href="xlog.c.html#LN7473"><span class='Ref_To_Local'>len</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN619"><span class='Ref_to_Member'>xlblocks</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN7474"><span class='Ref_To_Local'>firstIdx</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="xlog.c.html#LN7475"><span class='Ref_To_Local'>pageBeginPtr</span></a> <span class='Operator'>+ </span>XLOG_BLCKSZ<span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN611"><span class='Ref_to_Member'>InitializedUpTo</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN7475"><span class='Ref_To_Local'>pageBeginPtr</span></a> <span class='Operator'>+ </span>XLOG_BLCKSZ<span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if EndOfLog%XLOG_BLCKSZ!... &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * There is no partial block to copy. Just set InitializedUpTo, and 
         * let the first attempt to insert a log record to initialize the next 
         * buffer. 
         */ 
</span>        <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN611"><span class='Ref_to_Member'>InitializedUpTo</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN6198"><span class='Ref_To_Local'>EndOfLog</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN422"><span class='Ref_to_Member'>Write</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN423"><span class='Ref_to_Member'>Flush</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN6198"><span class='Ref_To_Local'>EndOfLog</span></a><span class='Delimiter'>; 
</span> 
    <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN599"><span class='Ref_to_Member'>LogwrtResult</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Delimiter'>; 
</span> 
    <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN577"><span class='Ref_to_Member'>LogwrtRqst</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN416"><span class='Ref_to_Member'>Write</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN6198"><span class='Ref_To_Local'>EndOfLog</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN577"><span class='Ref_to_Member'>LogwrtRqst</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN417"><span class='Ref_to_Member'>Flush</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN6198"><span class='Ref_To_Local'>EndOfLog</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Pre-scan prepared transactions to find out the range of XIDs present */ 
</span>    <a href="xlog.c.html#LN6202"><span class='Ref_To_Local'>oldestActiveXID</span></a> <span class='Operator'>= </span><a href="../../../include/access/twophase.h.html#LN46"><span class='Ref_to_Proto'>PrescanPreparedTransactions</span></a><span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Update full_page_writes in shared memory and write an XLOG_FPW_CHANGE 
     * record before resource manager writes cleanup WAL records or checkpoint 
     * record is written. 
     */ 
</span>    <a href="xlog.c.html#LN6190"><span class='Ref_To_Local'>Insert</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN549"><span class='Ref_to_Member'>fullPageWrites</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN208"><span class='Ref_to_Global_Var'>lastFullPageWrites</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN857"><span class='Ref_to_Proto'>LocalSetXLogInsertAllowed</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="../../../include/access/xlog.h.html#LN271"><span class='Ref_to_Proto'>UpdateFullPageWrites</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN232"><span class='Ref_to_Global_Var'>LocalXLogInsertAllowed</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN191"><span class='Ref_to_Global_Var'>InRecovery</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Perform a checkpoint to update all our recovery activity to disk. 
         * 
         * Note that we write a shutdown checkpoint rather than an on-line 
         * one. This is not particularly critical, but since we may be 
         * assigning a new TLI, using a shutdown checkpoint allows us to have 
         * the rule that TLI only changes in shutdown checkpoints, which 
         * allows some extra error checking in xlog_redo. 
         * 
         * In fast promotion, only create a lightweight end-of-recovery record 
         * instead of a full checkpoint. A checkpoint is requested later, 
         * after we're fully out of recovery mode and already accepting 
         * queries. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN835"><span class='Ref_to_Global_Var'>bgwriterLaunched</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN279"><span class='Ref_to_Global_Var'>fast_promote</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="xlog.c.html#LN6197"><span class='Ref_To_Local'>checkPointLoc</span></a> <span class='Operator'>= </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN132"><span class='Ref_to_Member'>prevCheckPoint</span></a><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * Confirm the last checkpoint is available for us to recover 
                 * from if we fail. Note that we don't check for the secondary 
                 * checkpoint since that isn't available in most base backups. 
                 */ 
</span>                <a href="xlog.c.html#LN6201"><span class='Ref_To_Local'>record</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN889"><span class='Ref_to_Proto'>ReadCheckpointRecord</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN6206"><span class='Ref_To_Local'>xlogreader</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN6197"><span class='Ref_To_Local'>checkPointLoc</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN6201"><span class='Ref_To_Local'>record</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <a href="xlog.c.html#LN6208"><span class='Ref_To_Local'>fast_promoted</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * Insert a special WAL record to mark the end of 
                     * recovery, since we aren't doing a checkpoint. That 
                     * means that the checkpointer process may likely be in 
                     * the middle of a time-smoothed restartpoint and could 
                     * continue to be for minutes after this. That sounds 
                     * strange, but the effect is roughly the same and it 
                     * would be stranger to try to come out of the 
                     * restartpoint and then checkpoint. We request a 
                     * checkpoint later anyway, just for safety. 
                     */ 
</span>                    <a href="xlog.c.html#LN858"><span class='Ref_to_Proto'>CreateEndOfRecoveryRecord</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if fast_promote &raquo; </span> 
 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN6208"><span class='Ref_To_Local'>fast_promoted</span></a><span class='Parentheses'>) 
</span>                <a href="../../../include/postmaster/bgwriter.h.html#LN30"><span class='Ref_to_Proto'>RequestCheckpoint</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN175"><span class='Ref_to_Const'>CHECKPOINT_END_OF_RECOVERY</span></a> <span class='Operator'>| 
</span>                                  <a href="../../../include/access/xlog.h.html#LN178"><span class='Ref_to_Const'>CHECKPOINT_IMMEDIATE</span></a> <span class='Operator'>| 
</span>                                  <a href="../../../include/access/xlog.h.html#LN183"><span class='Ref_to_Const'>CHECKPOINT_WAIT</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if bgwriterLaunched &raquo; </span> 
        <span class='Control'>else</span> 
            <a href="../../../include/access/xlog.h.html#LN267"><span class='Ref_to_Proto'>CreateCheckPoint</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN175"><span class='Ref_to_Const'>CHECKPOINT_END_OF_RECOVERY</span></a> <span class='Operator'>| </span><a href="../../../include/access/xlog.h.html#LN178"><span class='Ref_to_Const'>CHECKPOINT_IMMEDIATE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * And finally, execute the recovery_end_command, if any. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN257"><span class='Ref_to_Global_Var'>recoveryEndCommand</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/access/xlog_internal.h.html#LN309"><span class='Ref_to_Proto'>ExecuteRecoveryCommand</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN257"><span class='Ref_to_Global_Var'>recoveryEndCommand</span></a><span class='Delimiter'>, 
</span>                                   <span class='String'>"recovery_end_command"</span><span class='Delimiter'>, 
</span>                                   <span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if InRecovery &raquo; </span> 
 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN245"><span class='Ref_to_Global_Var'>ArchiveRecoveryRequested</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * We switched to a new timeline. Clean up segments on the old 
         * timeline. 
         * 
         * If there are any higher-numbered segments on the old timeline, 
         * remove them. They might contain valid WAL, but they might also be 
         * pre-allocated files containing garbage. In any case, they are not 
         * part of the new timeline's history so we don't need them. 
         */ 
</span>        <a href="xlog.c.html#LN3901"><span class='Ref_to_Func'>RemoveNonParentXlogFiles</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN6198"><span class='Ref_To_Local'>EndOfLog</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If the switch happened in the middle of a segment, what to do with 
         * the last, partial segment on the old timeline? If we don't archive 
         * it, and the server that created the WAL never archives it either 
         * (e.g. because it was hit by a meteor), it will never make it to the 
         * archive. That's OK from our point of view, because the new segment 
         * that we created with the new TLI contains all the WAL from the old 
         * timeline up to the switch point. But if you later try to do PITR to 
         * the "missing" WAL on the old timeline, recovery won't find it in 
         * the archive. It's physically present in the new file with new TLI, 
         * but recovery won't look there when it's recovering to the older 
         * timeline. On the other hand, if we archive the partial segment, and 
         * the original server on that timeline is still running and archives 
         * the completed version of the same segment later, it will fail. (We 
         * used to do that in 9.4 and below, and it caused such problems). 
         * 
         * As a compromise, we rename the last segment with the .partial 
         * suffix, and archive it. Archive recovery will never try to read 
         * .partial segments, so they will normally go unused. But in the odd 
         * PITR case, the administrator can copy them manually to the pg_wal 
         * directory (removing the suffix). They can be useful in debugging, 
         * too. 
         * 
         * If a .done or .ready file already exists for the old timeline, 
         * however, we had already determined that the segment is complete, so 
         * we can let it be archived normally. (In particular, if it was 
         * restored from the archive to begin with, it's expected to have a 
         * .done file). 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN6198"><span class='Ref_To_Local'>EndOfLog</span></a> <span class='Operator'>% </span>XLOG_SEG_SIZE <span class='Operator'>!= </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="../../../include/access/xlog.h.html#LN133"><span class='Ref_to_Macro'>XLogArchivingActive</span></a><span class='Parentheses'>())</span> 
        <span class='Delimiter'>{ 
</span><a name="LN7629"></a>            <span class='Keyword'>char</span>        <span class='Declare_Local'>origfname</span><span class='Delimiter'>[</span><a href="../../../include/access/xlog_internal.h.html#LN137"><span class='Ref_to_Const'>MAXFNAMELEN</span></a><span class='Delimiter'>]; 
</span><a name="LN7630"></a>            <a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a>   <span class='Declare_Local'>endLogSegNo</span><span class='Delimiter'>; 
</span> 
            <a href="../../../include/access/xlog_internal.h.html#LN108"><span class='Ref_to_Macro'>XLByteToPrevSeg</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN6198"><span class='Ref_To_Local'>EndOfLog</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN7630"><span class='Ref_To_Local'>endLogSegNo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/access/xlog_internal.h.html#LN142"><span class='Ref_to_Macro'>XLogFileName</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN7629"><span class='Ref_To_Local'>origfname</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN6199"><span class='Ref_To_Local'>EndOfLogTLI</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN7630"><span class='Ref_To_Local'>endLogSegNo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/xlog_internal.h.html#LN318"><span class='Ref_to_Proto'>XLogArchiveIsReadyOrDone</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN7629"><span class='Ref_To_Local'>origfname</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span><a name="LN7637"></a>                <span class='Keyword'>char</span>        <span class='Declare_Local'>origpath</span><span class='Delimiter'>[</span><a href="../../../include/pg_config_manual.h.html#LN88"><span class='Ref_to_Const'>MAXPGPATH</span></a><span class='Delimiter'>]; 
</span><a name="LN7638"></a>                <span class='Keyword'>char</span>        <span class='Declare_Local'>partialfname</span><span class='Delimiter'>[</span><a href="../../../include/access/xlog_internal.h.html#LN137"><span class='Ref_to_Const'>MAXFNAMELEN</span></a><span class='Delimiter'>]; 
</span><a name="LN7639"></a>                <span class='Keyword'>char</span>        <span class='Declare_Local'>partialpath</span><span class='Delimiter'>[</span><a href="../../../include/pg_config_manual.h.html#LN88"><span class='Ref_to_Const'>MAXPGPATH</span></a><span class='Delimiter'>]; 
</span> 
                <a href="../../../include/access/xlog_internal.h.html#LN172"><span class='Ref_to_Macro'>XLogFilePath</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN7637"><span class='Ref_To_Local'>origpath</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN6199"><span class='Ref_To_Local'>EndOfLogTLI</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN7630"><span class='Ref_To_Local'>endLogSegNo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="../../../pl/plperl/plperl.h.html#LN60"><span class='Ref_to_Macro'>snprintf</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN7638"><span class='Ref_To_Local'>partialfname</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xlog_internal.h.html#LN137"><span class='Ref_to_Const'>MAXFNAMELEN</span></a><span class='Delimiter'>, </span><span class='String'>"%s.partial"</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN7629"><span class='Ref_To_Local'>origfname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="../../../pl/plperl/plperl.h.html#LN60"><span class='Ref_to_Macro'>snprintf</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN7639"><span class='Ref_To_Local'>partialpath</span></a><span class='Delimiter'>, </span><a href="../../../include/pg_config_manual.h.html#LN88"><span class='Ref_to_Const'>MAXPGPATH</span></a><span class='Delimiter'>, </span><span class='String'>"%s.partial"</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN7637"><span class='Ref_To_Local'>origpath</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * Make sure there's no .done or .ready file for the .partial 
                 * file. 
                 */ 
</span>                <a href="../../../include/access/xlog_internal.h.html#LN319"><span class='Ref_to_Proto'>XLogArchiveCleanup</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN7638"><span class='Ref_To_Local'>partialfname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="../../../include/common/file_utils.h.html#LN22"><span class='Ref_to_Proto'>durable_rename</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN7637"><span class='Ref_To_Local'>origpath</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN7639"><span class='Ref_To_Local'>partialpath</span></a><span class='Delimiter'>, </span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="../../../include/access/xlog_internal.h.html#LN312"><span class='Ref_to_Proto'>XLogArchiveNotify</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN7638"><span class='Ref_To_Local'>partialfname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if EndOfLog%XLOG_SEG_SIZ... &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if ArchiveRecoveryReques... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Preallocate additional log files, if wanted. 
     */ 
</span>    <a href="xlog.c.html#LN879"><span class='Ref_to_Proto'>PreallocXlogFiles</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN6198"><span class='Ref_To_Local'>EndOfLog</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Okay, we're officially UP. 
     */ 
</span>    <a href="xlog.c.html#LN191"><span class='Ref_to_Global_Var'>InRecovery</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* start the archive_timeout timer and LSN running */ 
</span>    <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN592"><span class='Ref_to_Member'>lastSegSwitchTime</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/pgtime.h.html#LN22"><span class='Ref_to_Typedef'>pg_time_t</span></a><span class='Parentheses'>) </span>time<span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN593"><span class='Ref_to_Member'>lastSegSwitchLSN</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN6198"><span class='Ref_To_Local'>EndOfLog</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* also initialize latestCompletedXid, to nextXid - 1 */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN134"><span class='Ref_to_Member'>latestCompletedXid</span></a> <span class='Operator'>= </span><a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN116"><span class='Ref_to_Member'>nextXid</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/access/transam.h.html#LN55"><span class='Ref_to_Macro'>TransactionIdRetreat</span></a><span class='Parentheses'>(</span><a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN134"><span class='Ref_to_Member'>latestCompletedXid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Start up the commit log and subtrans, if not already done for hot 
     * standby.  (commit timestamps are started below, if necessary.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN194"><span class='Ref_to_Global_Var'>standbyState</span></a> <span class='Operator'>== </span><a href="../../../include/access/xlog.h.html#LN65"><span class='Ref_to_EnumConst'>STANDBY_DISABLED</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/access/clog.h.html#LN45"><span class='Ref_to_Proto'>StartupCLOG</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <a href="../../../include/access/subtrans.h.html#LN23"><span class='Ref_to_Proto'>StartupSUBTRANS</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN6202"><span class='Ref_To_Local'>oldestActiveXID</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Perform end of recovery actions for any SLRUs that need it. 
     */ 
</span>    <a href="../../../include/access/clog.h.html#LN46"><span class='Ref_to_Proto'>TrimCLOG</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="../../../include/access/multixact.h.html#LN126"><span class='Ref_to_Proto'>TrimMultiXact</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Reload shared-memory state for prepared transactions */ 
</span>    <a href="../../../include/access/twophase.h.html#LN49"><span class='Ref_to_Proto'>RecoverPreparedTransactions</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Shutdown the recovery environment. This must occur after 
     * RecoverPreparedTransactions(), see notes for lock_twophase_recover() 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN194"><span class='Ref_to_Global_Var'>standbyState</span></a> <span class='Operator'>!= </span><a href="../../../include/access/xlog.h.html#LN65"><span class='Ref_to_EnumConst'>STANDBY_DISABLED</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/storage/standby.h.html#LN27"><span class='Ref_to_Proto'>ShutdownRecoveryTransactionEnvironment</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Shut down xlogreader */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN782"><span class='Ref_to_Global_Var'>readFile</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../interfaces/libpq/win32.h.html#LN11"><span class='Ref_to_Macro'>close</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN782"><span class='Ref_to_Global_Var'>readFile</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN782"><span class='Ref_to_Global_Var'>readFile</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="xlogreader.c.html#LN123"><span class='Ref_to_Func'>XLogReaderFree</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN6206"><span class='Ref_To_Local'>xlogreader</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If any of the critical GUCs have changed, log them before we allow 
     * backends to write WAL. 
     */ 
</span>    <a href="xlog.c.html#LN857"><span class='Ref_to_Proto'>LocalSetXLogInsertAllowed</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN854"><span class='Ref_to_Proto'>XLogReportParameters</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Local WAL inserts enabled, so it's time to finish initialization of 
     * commit timestamp. 
     */ 
</span>    <a href="../../../include/access/commit_ts.h.html#LN38"><span class='Ref_to_Proto'>CompleteCommitTsInitialization</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * All done with end-of-recovery actions. 
     * 
     * Now allow backends to write WAL and update the control file status in 
     * consequence.  The boolean flag allowing backends to write WAL is 
     * updated while holding ControlFileLock to prevent other backends to look 
     * at an inconsistent state of the control file in shared memory.  There 
     * is still a small window during which backends can write WAL and the 
     * control file is still referring to a system not in DB_IN_PRODUCTION 
     * state while looking at the on-disk control file. 
     * 
     * Also, although the boolean flag to allow WAL is probably atomic in 
     * itself, we use the info_lck here to ensure that there are no race 
     * conditions concerning visibility of other recent updates to shared 
     * memory. 
     */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ControlFileLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN129"><span class='Ref_to_Member'>state</span></a> <span class='Operator'>= </span><a href="../../../include/catalog/pg_control.h.html#LN91"><span class='Ref_to_EnumConst'>DB_IN_PRODUCTION</span></a><span class='Delimiter'>; 
</span>    <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN130"><span class='Ref_to_Member'>time</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/pgtime.h.html#LN22"><span class='Ref_to_Typedef'>pg_time_t</span></a><span class='Parentheses'>) </span>time<span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN641"><span class='Ref_to_Member'>SharedRecoveryInProgress</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/access/xlog.h.html#LN256"><span class='Ref_to_Proto'>UpdateControlFile</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ControlFileLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If there were cascading standby servers connected to us, nudge any wal 
     * sender processes to notice that we've been promoted. 
     */ 
</span>    <a href="../../../include/replication/walsender.h.html#LN45"><span class='Ref_to_Proto'>WalSndWakeup</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If this was a fast promotion, request an (online) checkpoint now. This 
     * isn't required for consistency, but the last restartpoint might be far 
     * back, and in case of a crash, recovering from it might take a longer 
     * than is appropriate now that we're not in standby mode anymore. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN6208"><span class='Ref_To_Local'>fast_promoted</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/postmaster/bgwriter.h.html#LN30"><span class='Ref_to_Proto'>RequestCheckpoint</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN179"><span class='Ref_to_Const'>CHECKPOINT_FORCE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end StartupXLOG &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Checks if recovery has reached a consistent state. When consistency is 
 * reached and we have a valid starting standby snapshot, tell postmaster 
 * that it can start accepting read-only connections. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN7773"></a><span class='Declare_Function'>CheckRecoveryConsistency</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN7775"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>lastReplayedEndRecPtr</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * During crash recovery, we don't reach a consistent state until we've 
     * replayed all the WAL. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN28"><span class='Ref_to_Macro'>XLogRecPtrIsInvalid</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN820"><span class='Ref_to_Global_Var'>minRecoveryPoint</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * assume that we are called in the startup process, and hence don't need 
     * a lock to read lastReplayedEndRecPtr 
     */ 
</span>    <a href="xlog.c.html#LN7775"><span class='Ref_To_Local'>lastReplayedEndRecPtr</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN681"><span class='Ref_to_Member'>lastReplayedEndRecPtr</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Have we reached the point where our base backup was completed? 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/xlogdefs.h.html#LN28"><span class='Ref_to_Macro'>XLogRecPtrIsInvalid</span></a><span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN172"><span class='Ref_to_Member'>backupEndPoint</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>        <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN172"><span class='Ref_to_Member'>backupEndPoint</span></a> <span class='Operator'>&LT;= </span><a href="xlog.c.html#LN7775"><span class='Ref_To_Local'>lastReplayedEndRecPtr</span></a><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * We have reached the end of base backup, as indicated by pg_control. 
         * The data on disk is now consistent. Reset backupStartPoint and 
         * backupEndPoint, and update minRecoveryPoint to make sure we don't 
         * allow starting up at an earlier point even if recovery is stopped 
         * and restarted soon after this. 
         */ 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN24"><span class='Ref_to_Const'>DEBUG1</span></a><span class='Delimiter'>, </span><span class='String'>"end of backup reached"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ControlFileLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN169"><span class='Ref_to_Member'>minRecoveryPoint</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN7775"><span class='Ref_To_Local'>lastReplayedEndRecPtr</span></a><span class='Parentheses'>) 
</span>            <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN169"><span class='Ref_to_Member'>minRecoveryPoint</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN7775"><span class='Ref_To_Local'>lastReplayedEndRecPtr</span></a><span class='Delimiter'>; 
</span> 
        <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN171"><span class='Ref_to_Member'>backupStartPoint</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>; 
</span>        <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN172"><span class='Ref_to_Member'>backupEndPoint</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>; 
</span>        <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN173"><span class='Ref_to_Member'>backupEndRequired</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <a href="../../../include/access/xlog.h.html#LN256"><span class='Ref_to_Proto'>UpdateControlFile</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ControlFileLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !XLogRecPtrIsInvalid(... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Have we passed our safe starting point? Note that minRecoveryPoint is 
     * known to be incorrectly set if ControlFile-&GT;backupEndRequired, until 
     * the XLOG_BACKUP_RECORD arrives to advise us of the correct 
     * minRecoveryPoint. All we know prior to that is that we're not 
     * consistent yet. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN830"><span class='Ref_to_Global_Var'>reachedConsistency</span></a> <span class='Operator'>&& !</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN173"><span class='Ref_to_Member'>backupEndRequired</span></a> <span class='Operator'>&& 
</span>        <a href="xlog.c.html#LN820"><span class='Ref_to_Global_Var'>minRecoveryPoint</span></a> <span class='Operator'>&LT;= </span><a href="xlog.c.html#LN7775"><span class='Ref_To_Local'>lastReplayedEndRecPtr</span></a> <span class='Operator'>&& 
</span>        <a href="../../../include/access/xlogdefs.h.html#LN28"><span class='Ref_to_Macro'>XLogRecPtrIsInvalid</span></a><span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN171"><span class='Ref_to_Member'>backupStartPoint</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Check to see if the XLOG sequence contained any unresolved 
         * references to uninitialized pages. 
         */ 
</span>        <a href="../../../include/access/xlogutils.h.html#LN18"><span class='Ref_to_Proto'>XLogCheckInvalidPages</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <a href="xlog.c.html#LN830"><span class='Ref_to_Global_Var'>reachedConsistency</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"consistent recovery state reached at %X/%X"</span><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN7775"><span class='Ref_To_Local'>lastReplayedEndRecPtr</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN7775"><span class='Ref_To_Local'>lastReplayedEndRecPtr</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Have we got a valid starting snapshot that will allow queries to be 
     * run? If so, we can tell postmaster that the database is consistent now, 
     * enabling connections. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN194"><span class='Ref_to_Global_Var'>standbyState</span></a> <span class='Operator'>== </span><a href="../../../include/access/xlog.h.html#LN68"><span class='Ref_to_EnumConst'>STANDBY_SNAPSHOT_READY</span></a> <span class='Operator'>&& 
</span>        <span class='Operator'>!</span><a href="xlog.c.html#LN220"><span class='Ref_to_Global_Var'>LocalHotStandbyActive</span></a> <span class='Operator'>&& 
</span>        <a href="xlog.c.html#LN830"><span class='Ref_to_Global_Var'>reachedConsistency</span></a> <span class='Operator'>&& 
</span>        <a href="../../utils/init/globals.c.html#LN100"><span class='Ref_to_Global_Var'>IsUnderPostmaster</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN647"><span class='Ref_to_Member'>SharedHotStandbyActive</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="xlog.c.html#LN220"><span class='Ref_to_Global_Var'>LocalHotStandbyActive</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/storage/pmsignal.h.html#LN45"><span class='Ref_to_Proto'>SendPostmasterSignal</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/pmsignal.h.html#LN25"><span class='Ref_to_EnumConst'>PMSIGNAL_BEGIN_HOT_STANDBY</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end CheckRecoveryConsistency &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Is the system still in recovery? 
 * 
 * Unlike testing InRecovery, this works in any process that's connected to 
 * shared memory. 
 * 
 * As a side-effect, we initialize the local TimeLineID and RedoRecPtr 
 * variables the first time we see that recovery is finished. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN7872"></a><span class='Declare_Function'>RecoveryInProgress</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * We check shared state each time only until we leave recovery mode. We 
     * can't re-enter recovery, so there's no need to keep checking after the 
     * shared variable has once been seen false. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN214"><span class='Ref_to_Global_Var'>LocalRecoveryInProgress</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * use volatile pointer to make sure we make a fresh read of the 
         * shared variable. 
         */ 
</span><a name="LN7887"></a>        <span class='Keyword'>volatile </span><a href="xlog.c.html#LN572"><span class='Ref_to_Struct'>XLogCtlData</span></a> <span class='Operator'>*</span><span class='Declare_Local'>xlogctl</span> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Delimiter'>; 
</span> 
        <a href="xlog.c.html#LN214"><span class='Ref_to_Global_Var'>LocalRecoveryInProgress</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN7887"><span class='Ref_To_Local'>xlogctl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN641"><span class='Ref_to_Member'>SharedRecoveryInProgress</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Initialize TimeLineID and RedoRecPtr when we discover that recovery 
         * is finished. InitPostgres() relies upon this behaviour to ensure 
         * that InitXLOGAccess() is called at backend startup.  (If you change 
         * this, see also LocalSetXLogInsertAllowed.) 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN214"><span class='Ref_to_Global_Var'>LocalRecoveryInProgress</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * If we just exited recovery, make sure we read TimeLineID and 
             * RedoRecPtr after SharedRecoveryInProgress (for machines with 
             * weak memory ordering). 
             */ 
</span>            <a href="../../../include/port/atomics.h.html#LN147"><span class='Ref_to_Macro'>pg_memory_barrier</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>            <a href="../../../include/access/xlog.h.html#LN266"><span class='Ref_to_Proto'>InitXLOGAccess</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Note: We don't need a memory barrier when we're still in recovery. 
         * We might exit recovery immediately after return, so the caller 
         * can't rely on 'true' meaning that we're still in recovery anyway. 
         */ 
</span> 
        <span class='Control'>return</span> <a href="xlog.c.html#LN214"><span class='Ref_to_Global_Var'>LocalRecoveryInProgress</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end RecoveryInProgress &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Is HotStandby active yet? This is only important in special backends 
 * since normal backends won't ever be able to connect until this returns 
 * true. Postmaster knows this by way of signal, not via shared memory. 
 * 
 * Unlike testing standbyState, this works in any process that's connected to 
 * shared memory.  (And note that standbyState alone doesn't tell the truth 
 * anyway.) 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN7928"></a><span class='Declare_Function'>HotStandbyActive</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * We check shared state each time only until Hot Standby is active. We 
     * can't de-activate Hot Standby, so there's no need to keep checking 
     * after the shared variable has once been seen true. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN220"><span class='Ref_to_Global_Var'>LocalHotStandbyActive</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* spinlock is essential on machines with weak memory ordering! */ 
</span>        <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN220"><span class='Ref_to_Global_Var'>LocalHotStandbyActive</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN647"><span class='Ref_to_Member'>SharedHotStandbyActive</span></a><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>return</span> <a href="xlog.c.html#LN220"><span class='Ref_to_Global_Var'>LocalHotStandbyActive</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end HotStandbyActive &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Like HotStandbyActive(), but to be used only in WAL replay code, 
 * where we don't need to ask any other process what the state is. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN7953"></a><span class='Declare_Function'>HotStandbyActiveInReplay</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/miscadmin.h.html#LN407"><span class='Ref_to_Macro'>AmStartupProcess</span></a><span class='Parentheses'>() </span><span class='Operator'>|| !</span><a href="../../utils/init/globals.c.html#LN99"><span class='Ref_to_Global_Var'>IsPostmasterEnvironment</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="xlog.c.html#LN220"><span class='Ref_to_Global_Var'>LocalHotStandbyActive</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Is this process allowed to insert new WAL records? 
 * 
 * Ordinarily this is essentially equivalent to !RecoveryInProgress(). 
 * But we also have provisions for forcing the result "true" or "false" 
 * within specific processes regardless of the global state. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN7967"></a><span class='Declare_Function'>XLogInsertAllowed</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * If value is "unconditionally true" or "unconditionally false", just 
     * return it.  This provides the normal fast path once recovery is known 
     * done. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN232"><span class='Ref_to_Global_Var'>LocalXLogInsertAllowed</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Parentheses'>(</span><span class='Keyword'>bool</span><span class='Parentheses'>) </span><a href="xlog.c.html#LN232"><span class='Ref_to_Global_Var'>LocalXLogInsertAllowed</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Else, must check to see if we're still in recovery. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN242"><span class='Ref_to_Proto'>RecoveryInProgress</span></a><span class='Parentheses'>())</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * On exit from recovery, reset to "unconditionally true", since there is 
     * no need to keep checking. 
     */ 
</span>    <a href="xlog.c.html#LN232"><span class='Ref_to_Global_Var'>LocalXLogInsertAllowed</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end XLogInsertAllowed &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Make XLogInsertAllowed() return true in the current process only. 
 * 
 * Note: it is allowed to switch LocalXLogInsertAllowed back to -1 later, 
 * and even call LocalSetXLogInsertAllowed() again after that. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN7998"></a><span class='Declare_Function'>LocalSetXLogInsertAllowed</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN232"><span class='Ref_to_Global_Var'>LocalXLogInsertAllowed</span></a> <span class='Operator'>== -</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN232"><span class='Ref_to_Global_Var'>LocalXLogInsertAllowed</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Initialize as RecoveryInProgress() would do when switching state */ 
</span>    <a href="../../../include/access/xlog.h.html#LN266"><span class='Ref_to_Proto'>InitXLOGAccess</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Subroutine to try to fetch and validate a prior checkpoint record. 
 * 
 * whichChkpt identifies the checkpoint (merely for reporting purposes). 
 * 1 for "primary", 2 for "secondary", 0 for "other" (backup_label) 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/access/xlogrecord.h.html#LN40"><span class='Ref_to_Struct'>XLogRecord</span></a> <span class='Operator'>* 
</span><a name="LN8014"></a><span class='Declare_Function'>ReadCheckpointRecord</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogreader.h.html#LN68"><span class='Ref_to_Struct'>XLogReaderState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>xlogreader</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>RecPtr</span><span class='Delimiter'>, 
</span><a name="LN8015"></a>                     <span class='Keyword'>int </span><span class='Declare_Parameter'>whichChkpt</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>report</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN8017"></a>    <a href="../../../include/access/xlogrecord.h.html#LN40"><span class='Ref_to_Struct'>XLogRecord</span></a> <span class='Operator'>*</span><span class='Declare_Local'>record</span><span class='Delimiter'>; 
</span><a name="LN8018"></a>    <a href="../../../include/c.h.html#LN265"><span class='Ref_to_Typedef'>uint8</span></a>       <span class='Declare_Local'>info</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/xlog_internal.h.html#LN124"><span class='Ref_to_Macro'>XRecOffIsValid</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN8014"><span class='Ref_to_Parameter'>RecPtr</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN8015"><span class='Ref_to_Parameter'>report</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN8015"><span class='Ref_to_Parameter'>whichChkpt</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>case</span> <span class='Number'>1</span><span class='Operator'>: 
</span>                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"invalid primary checkpoint link in control file"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <span class='Number'>2</span><span class='Operator'>: 
</span>                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"invalid secondary checkpoint link in control file"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>default</span><span class='Operator'>: 
</span>                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                   <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"invalid checkpoint link in backup_label file"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !XRecOffIsValid(RecPt... &raquo; </span> 
 
    <a href="xlog.c.html#LN8017"><span class='Ref_To_Local'>record</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN886"><span class='Ref_to_Proto'>ReadRecord</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN8014"><span class='Ref_to_Parameter'>xlogreader</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN8014"><span class='Ref_to_Parameter'>RecPtr</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN8017"><span class='Ref_To_Local'>record</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN8015"><span class='Ref_to_Parameter'>report</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN8015"><span class='Ref_to_Parameter'>whichChkpt</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>case</span> <span class='Number'>1</span><span class='Operator'>: 
</span>                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"invalid primary checkpoint record"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <span class='Number'>2</span><span class='Operator'>: 
</span>                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"invalid secondary checkpoint record"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>default</span><span class='Operator'>: 
</span>                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"invalid checkpoint record"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if record==NULL &raquo; </span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN8017"><span class='Ref_To_Local'>record</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogrecord.h.html#LN46"><span class='Ref_to_Member'>xl_rmid</span></a> <span class='Operator'>!= </span>RM_XLOG_ID<span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN8015"><span class='Ref_to_Parameter'>whichChkpt</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>case</span> <span class='Number'>1</span><span class='Operator'>: 
</span>                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"invalid resource manager ID in primary checkpoint record"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <span class='Number'>2</span><span class='Operator'>: 
</span>                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"invalid resource manager ID in secondary checkpoint record"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>default</span><span class='Operator'>: 
</span>                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"invalid resource manager ID in checkpoint record"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="xlog.c.html#LN8018"><span class='Ref_To_Local'>info</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN8017"><span class='Ref_To_Local'>record</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogrecord.h.html#LN45"><span class='Ref_to_Member'>xl_info</span></a> <span class='Operator'>& ~</span><a href="../../../include/access/xlogrecord.h.html#LN61"><span class='Ref_to_Const'>XLR_INFO_MASK</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN8018"><span class='Ref_To_Local'>info</span></a> <span class='Operator'>!= </span><a href="../../../include/catalog/pg_control.h.html#LN65"><span class='Ref_to_Const'>XLOG_CHECKPOINT_SHUTDOWN</span></a> <span class='Operator'>&& 
</span>        <a href="xlog.c.html#LN8018"><span class='Ref_To_Local'>info</span></a> <span class='Operator'>!= </span><a href="../../../include/catalog/pg_control.h.html#LN66"><span class='Ref_to_Const'>XLOG_CHECKPOINT_ONLINE</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN8015"><span class='Ref_to_Parameter'>whichChkpt</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>case</span> <span class='Number'>1</span><span class='Operator'>: 
</span>                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                   <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"invalid xl_info in primary checkpoint record"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <span class='Number'>2</span><span class='Operator'>: 
</span>                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                 <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"invalid xl_info in secondary checkpoint record"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>default</span><span class='Operator'>: 
</span>                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"invalid xl_info in checkpoint record"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if info!=XLOG_CHECKPOINT... &raquo; </span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN8017"><span class='Ref_To_Local'>record</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogrecord.h.html#LN42"><span class='Ref_to_Member'>xl_tot_len</span></a> <span class='Operator'>!= </span><a href="../../../include/access/xlogrecord.h.html#LN54"><span class='Ref_to_Const'>SizeOfXLogRecord</span></a> <span class='Operator'>+ </span><a href="../../../include/access/xlogrecord.h.html#LN199"><span class='Ref_to_Const'>SizeOfXLogRecordDataHeaderShort</span></a> <span class='Operator'>+ </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_control.h.html#LN32"><span class='Ref_to_Struct'>CheckPoint</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN8015"><span class='Ref_to_Parameter'>whichChkpt</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>case</span> <span class='Number'>1</span><span class='Operator'>: 
</span>                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"invalid length of primary checkpoint record"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <span class='Number'>2</span><span class='Operator'>: 
</span>                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                  <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"invalid length of secondary checkpoint record"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>default</span><span class='Operator'>: 
</span>                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"invalid length of checkpoint record"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <a href="xlog.c.html#LN8017"><span class='Ref_To_Local'>record</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ReadCheckpointRecord &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * This must be called in a backend process before creating WAL records 
 * (except in a standalone backend, which does StartupXLOG instead).  We need 
 * to initialize the local copies of ThisTimeLineID and RedoRecPtr. 
 * 
 * Note: before Postgres 8.0, we went to some effort to keep the postmaster 
 * process's copies of ThisTimeLineID and RedoRecPtr valid too.  This was 
 * unnecessary however, since the postmaster itself never touches XLOG anyway. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN8139"></a><span class='Declare_Function'>InitXLOGAccess</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN8141"></a>    <a href="xlog.c.html#LN514"><span class='Ref_to_Struct'>XLogCtlInsert</span></a> <span class='Operator'>*</span><span class='Declare_Local'>Insert</span> <span class='Operator'>= &</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN574"><span class='Ref_to_Member'>Insert</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* ThisTimeLineID doesn't change so we need no lock to copy it */ 
</span>    <a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN628"><span class='Ref_to_Member'>ThisTimeLineID</span></a><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a> <span class='Operator'>!= </span><span class='Number'>0</span> <span class='Operator'>|| </span><a href="../../../include/miscadmin.h.html#LN369"><span class='Ref_to_Macro'>IsBootstrapProcessingMode</span></a><span class='Parentheses'>())</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Use GetRedoRecPtr to copy the RedoRecPtr safely */ 
</span>    <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="../../../include/access/xlog.h.html#LN273"><span class='Ref_to_Proto'>GetRedoRecPtr</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* Also update our copy of doPageWrites. */ 
</span>    <a href="xlog.c.html#LN356"><span class='Ref_to_Global_Var'>doPageWrites</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="xlog.c.html#LN8141"><span class='Ref_To_Local'>Insert</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN549"><span class='Ref_to_Member'>fullPageWrites</span></a> <span class='Operator'>|| </span><a href="xlog.c.html#LN8141"><span class='Ref_To_Local'>Insert</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN548"><span class='Ref_to_Member'>forcePageWrites</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Also initialize the working areas for constructing WAL records */ 
</span>    <a href="../../../include/access/xloginsert.h.html#LN59"><span class='Ref_to_Proto'>InitXLogInsert</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Return the current Redo pointer from shared memory. 
 * 
 * As a side-effect, the local RedoRecPtr copy is updated. 
 */ 
</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> 
<a name="LN8162"></a><span class='Declare_Function'>GetRedoRecPtr</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN8164"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>ptr</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * The possibly not up-to-date copy in XlogCtl is enough. Even if we 
     * grabbed a WAL insertion lock to read the master copy, someone might 
     * update it just after we've released the lock. 
     */ 
</span>    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN8164"><span class='Ref_To_Local'>ptr</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN578"><span class='Ref_to_Member'>RedoRecPtr</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN349"><span class='Ref_to_Global_Var'>RedoRecPtr</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN8164"><span class='Ref_To_Local'>ptr</span></a><span class='Parentheses'>) 
</span>        <a href="xlog.c.html#LN349"><span class='Ref_to_Global_Var'>RedoRecPtr</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN8164"><span class='Ref_To_Local'>ptr</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="xlog.c.html#LN349"><span class='Ref_to_Global_Var'>RedoRecPtr</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Return information needed to decide whether a modified block needs a 
 * full-page image to be included in the WAL record. 
 * 
 * The returned values are cached copies from backend-private memory, and 
 * possibly out-of-date.  XLogInsertRecord will re-check them against 
 * up-to-date values, while holding the WAL insert lock. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN8190"></a><span class='Declare_Function'>GetFullPageWriteInfo</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>RedoRecPtr_p</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>doPageWrites_p</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Operator'>*</span><a href="xlog.c.html#LN8190"><span class='Ref_to_Parameter'>RedoRecPtr_p</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN349"><span class='Ref_to_Global_Var'>RedoRecPtr</span></a><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="xlog.c.html#LN8190"><span class='Ref_to_Parameter'>doPageWrites_p</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN356"><span class='Ref_to_Global_Var'>doPageWrites</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * GetInsertRecPtr -- Returns the current insert position. 
 * 
 * NOTE: The value *actually* returned is the position of the last full 
 * xlog page. It lags behind the real insert position by at most 1 page. 
 * For that, we don't need to scan through WAL insertion locks, and an 
 * approximation is enough for the current usage of this function. 
 */ 
</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> 
<a name="LN8205"></a><span class='Declare_Function'>GetInsertRecPtr</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN8207"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>recptr</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN8207"><span class='Ref_To_Local'>recptr</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN577"><span class='Ref_to_Member'>LogwrtRqst</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN416"><span class='Ref_to_Member'>Write</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="xlog.c.html#LN8207"><span class='Ref_To_Local'>recptr</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * GetFlushRecPtr -- Returns the current flush position, ie, the last WAL 
 * position known to be fsync'd to disk. 
 */ 
</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> 
<a name="LN8221"></a><span class='Declare_Function'>GetFlushRecPtr</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN599"><span class='Ref_to_Member'>LogwrtResult</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN423"><span class='Ref_to_Member'>Flush</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * GetLastImportantRecPtr -- Returns the LSN of the last important record 
 * inserted. All records not explicitly marked as unimportant are considered 
 * important. 
 * 
 * The LSN is determined by computing the maximum of 
 * WALInsertLocks[i].lastImportantAt. 
 */ 
</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> 
<a name="LN8239"></a><span class='Declare_Function'>GetLastImportantRecPtr</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN8241"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>res</span> <span class='Operator'>= </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>; 
</span><a name="LN8242"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN8242"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="xlog.c.html#LN8242"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN117"><span class='Ref_to_Const'>NUM_XLOGINSERT_LOCKS</span></a><span class='Delimiter'>; </span><a href="xlog.c.html#LN8242"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN8246"></a>        <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>last_important</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Need to take a lock to prevent torn reads of the LSN, which are 
         * possible on some of the supported platforms. WAL insert locks only 
         * support exclusive mode, so we have to use that. 
         */ 
</span>        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN708"><span class='Ref_to_Global_Var'>WALInsertLocks</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN8242"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="xlog.c.html#LN478"><span class='Ref_to_Member'>l</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN464"><span class='Ref_to_Member'>lock</span></a><span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN8246"><span class='Ref_To_Local'>last_important</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN708"><span class='Ref_to_Global_Var'>WALInsertLocks</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN8242"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="xlog.c.html#LN478"><span class='Ref_to_Member'>l</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN466"><span class='Ref_to_Member'>lastImportantAt</span></a><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN708"><span class='Ref_to_Global_Var'>WALInsertLocks</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN8242"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="xlog.c.html#LN478"><span class='Ref_to_Member'>l</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN464"><span class='Ref_to_Member'>lock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN8241"><span class='Ref_To_Local'>res</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN8246"><span class='Ref_To_Local'>last_important</span></a><span class='Parentheses'>) 
</span>            <a href="xlog.c.html#LN8241"><span class='Ref_To_Local'>res</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN8246"><span class='Ref_To_Local'>last_important</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="xlog.c.html#LN8241"><span class='Ref_To_Local'>res</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end GetLastImportantRecPtr &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Get the time and LSN of the last xlog segment switch 
 */ 
</span><a href="../../../include/pgtime.h.html#LN22"><span class='Ref_to_Typedef'>pg_time_t</span></a> 
<a name="LN8268"></a><span class='Declare_Function'>GetLastSegSwitchData</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>lastSwitchLSN</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN8270"></a>    <a href="../../../include/pgtime.h.html#LN22"><span class='Ref_to_Typedef'>pg_time_t</span></a>   <span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Need WALWriteLock, but shared lock is sufficient */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>WALWriteLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN8270"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN592"><span class='Ref_to_Member'>lastSegSwitchTime</span></a><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="xlog.c.html#LN8268"><span class='Ref_to_Parameter'>lastSwitchLSN</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN593"><span class='Ref_to_Member'>lastSegSwitchLSN</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>WALWriteLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="xlog.c.html#LN8270"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * GetNextXidAndEpoch - get the current nextXid value and associated epoch 
 * 
 * This is exported for use by code that would like to have 64-bit XIDs. 
 * We don't really support such things, but all XIDs within the system 
 * can be presumed "close to" the result, and thus the epoch associated 
 * with them can be determined. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN8290"></a><span class='Declare_Function'>GetNextXidAndEpoch</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>xid</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>epoch</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN8292"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>ckptXidEpoch</span><span class='Delimiter'>; 
</span><a name="LN8293"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>ckptXid</span><span class='Delimiter'>; 
</span><a name="LN8294"></a>    <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>nextXid</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Must read checkpoint info first, else have race condition */ 
</span>    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN8292"><span class='Ref_To_Local'>ckptXidEpoch</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN579"><span class='Ref_to_Member'>ckptXidEpoch</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN8293"><span class='Ref_To_Local'>ckptXid</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN580"><span class='Ref_to_Member'>ckptXid</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Now fetch current nextXid */ 
</span>    <a href="xlog.c.html#LN8294"><span class='Ref_To_Local'>nextXid</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN178"><span class='Ref_to_Proto'>ReadNewTransactionId</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * nextXid is certainly logically later than ckptXid.  So if it's 
     * numerically less, it must have wrapped into the next epoch. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN8294"><span class='Ref_To_Local'>nextXid</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN8293"><span class='Ref_To_Local'>ckptXid</span></a><span class='Parentheses'>) 
</span>        <a href="xlog.c.html#LN8292"><span class='Ref_To_Local'>ckptXidEpoch</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span> 
    <span class='Operator'>*</span><a href="xlog.c.html#LN8290"><span class='Ref_to_Parameter'>xid</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN8294"><span class='Ref_To_Local'>nextXid</span></a><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="xlog.c.html#LN8290"><span class='Ref_to_Parameter'>epoch</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN8292"><span class='Ref_To_Local'>ckptXidEpoch</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end GetNextXidAndEpoch &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * This must be called ONCE during postmaster or standalone-backend shutdown 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN8320"></a><span class='Declare_Function'>ShutdownXLOG</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>code</span><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>arg</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* Don't be chatty in standalone mode */ 
</span>    <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../utils/init/globals.c.html#LN99"><span class='Ref_to_Global_Var'>IsPostmasterEnvironment</span></a> <span class='Operator'>? </span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a> <span class='Operator'>: </span><a href="../../../include/utils/elog.h.html#LN36"><span class='Ref_to_Const'>NOTICE</span></a><span class='Delimiter'>, 
</span>            <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"shutting down"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Signal walsenders to move to stopping state. 
     */ 
</span>    <a href="../../../include/replication/walsender.h.html#LN46"><span class='Ref_to_Proto'>WalSndInitStopping</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Wait for WAL senders to be in stopping state.  This prevents commands 
     * from writing new WAL. 
     */ 
</span>    <a href="../../../include/replication/walsender.h.html#LN47"><span class='Ref_to_Proto'>WalSndWaitStopping</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN242"><span class='Ref_to_Proto'>RecoveryInProgress</span></a><span class='Parentheses'>())</span> 
        <a href="../../../include/access/xlog.h.html#LN268"><span class='Ref_to_Proto'>CreateRestartPoint</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN174"><span class='Ref_to_Const'>CHECKPOINT_IS_SHUTDOWN</span></a> <span class='Operator'>| </span><a href="../../../include/access/xlog.h.html#LN178"><span class='Ref_to_Const'>CHECKPOINT_IMMEDIATE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * If archiving is enabled, rotate the last XLOG file so that all the 
         * remaining records are archived (postmaster wakes up the archiver 
         * process one more time at the end of shutdown). The checkpoint 
         * record will go to the next XLOG file and won't be archived (yet). 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN133"><span class='Ref_to_Macro'>XLogArchivingActive</span></a><span class='Parentheses'>() </span><span class='Operator'>&& </span><a href="../../../include/access/xlog.h.html#LN138"><span class='Ref_to_Macro'>XLogArchiveCommandSet</span></a><span class='Parentheses'>())</span> 
            <a href="../../../include/access/xlog_internal.h.html#LN290"><span class='Ref_to_Proto'>RequestXLogSwitch</span></a><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/access/xlog.h.html#LN267"><span class='Ref_to_Proto'>CreateCheckPoint</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN174"><span class='Ref_to_Const'>CHECKPOINT_IS_SHUTDOWN</span></a> <span class='Operator'>| </span><a href="../../../include/access/xlog.h.html#LN178"><span class='Ref_to_Const'>CHECKPOINT_IMMEDIATE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="../../../include/access/clog.h.html#LN47"><span class='Ref_to_Proto'>ShutdownCLOG</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="../../../include/access/commit_ts.h.html#LN39"><span class='Ref_to_Proto'>ShutdownCommitTs</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="../../../include/access/subtrans.h.html#LN24"><span class='Ref_to_Proto'>ShutdownSUBTRANS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="../../../include/access/multixact.h.html#LN127"><span class='Ref_to_Proto'>ShutdownMultiXact</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ShutdownXLOG &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Log start of a checkpoint. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN8362"></a><span class='Declare_Function'>LogCheckpointStart</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>flags</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>restartpoint</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, </span><span class='String'>"%s starting:%s%s%s%s%s%s%s%s"</span><span class='Delimiter'>, 
</span>         <a href="xlog.c.html#LN8362"><span class='Ref_to_Parameter'>restartpoint</span></a> <span class='Operator'>? </span><span class='String'>"restartpoint"</span> <span class='Operator'>: </span><span class='String'>"checkpoint"</span><span class='Delimiter'>, 
</span>         <span class='Parentheses'>(</span><a href="xlog.c.html#LN8362"><span class='Ref_to_Parameter'>flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/xlog.h.html#LN174"><span class='Ref_to_Const'>CHECKPOINT_IS_SHUTDOWN</span></a><span class='Parentheses'>) </span><span class='Operator'>? </span><span class='String'>" shutdown"</span> <span class='Operator'>: </span><span class='String'>""</span><span class='Delimiter'>, 
</span>         <span class='Parentheses'>(</span><a href="xlog.c.html#LN8362"><span class='Ref_to_Parameter'>flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/xlog.h.html#LN175"><span class='Ref_to_Const'>CHECKPOINT_END_OF_RECOVERY</span></a><span class='Parentheses'>) </span><span class='Operator'>? </span><span class='String'>" end-of-recovery"</span> <span class='Operator'>: </span><span class='String'>""</span><span class='Delimiter'>, 
</span>         <span class='Parentheses'>(</span><a href="xlog.c.html#LN8362"><span class='Ref_to_Parameter'>flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/xlog.h.html#LN178"><span class='Ref_to_Const'>CHECKPOINT_IMMEDIATE</span></a><span class='Parentheses'>) </span><span class='Operator'>? </span><span class='String'>" immediate"</span> <span class='Operator'>: </span><span class='String'>""</span><span class='Delimiter'>, 
</span>         <span class='Parentheses'>(</span><a href="xlog.c.html#LN8362"><span class='Ref_to_Parameter'>flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/xlog.h.html#LN179"><span class='Ref_to_Const'>CHECKPOINT_FORCE</span></a><span class='Parentheses'>) </span><span class='Operator'>? </span><span class='String'>" force"</span> <span class='Operator'>: </span><span class='String'>""</span><span class='Delimiter'>, 
</span>         <span class='Parentheses'>(</span><a href="xlog.c.html#LN8362"><span class='Ref_to_Parameter'>flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/xlog.h.html#LN183"><span class='Ref_to_Const'>CHECKPOINT_WAIT</span></a><span class='Parentheses'>) </span><span class='Operator'>? </span><span class='String'>" wait"</span> <span class='Operator'>: </span><span class='String'>""</span><span class='Delimiter'>, 
</span>         <span class='Parentheses'>(</span><a href="xlog.c.html#LN8362"><span class='Ref_to_Parameter'>flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/xlog.h.html#LN185"><span class='Ref_to_Const'>CHECKPOINT_CAUSE_XLOG</span></a><span class='Parentheses'>) </span><span class='Operator'>? </span><span class='String'>" xlog"</span> <span class='Operator'>: </span><span class='String'>""</span><span class='Delimiter'>, 
</span>         <span class='Parentheses'>(</span><a href="xlog.c.html#LN8362"><span class='Ref_to_Parameter'>flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/xlog.h.html#LN186"><span class='Ref_to_Const'>CHECKPOINT_CAUSE_TIME</span></a><span class='Parentheses'>) </span><span class='Operator'>? </span><span class='String'>" time"</span> <span class='Operator'>: </span><span class='String'>""</span><span class='Delimiter'>, 
</span>         <span class='Parentheses'>(</span><a href="xlog.c.html#LN8362"><span class='Ref_to_Parameter'>flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/xlog.h.html#LN180"><span class='Ref_to_Const'>CHECKPOINT_FLUSH_ALL</span></a><span class='Parentheses'>) </span><span class='Operator'>? </span><span class='String'>" flush-all"</span> <span class='Operator'>: </span><span class='String'>""</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Log end of a checkpoint. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN8380"></a><span class='Declare_Function'>LogCheckpointEnd</span><span class='Parentheses'>(</span><span class='Keyword'>bool </span><span class='Declare_Parameter'>restartpoint</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN8382"></a>    <span class='Keyword'>long</span>        <span class='Declare_Local'>write_secs</span><span class='Delimiter'>, 
</span><a name="LN8383"></a>                <span class='Declare_Local'>sync_secs</span><span class='Delimiter'>, 
</span><a name="LN8384"></a>                <span class='Declare_Local'>total_secs</span><span class='Delimiter'>, 
</span><a name="LN8385"></a>                <span class='Declare_Local'>longest_secs</span><span class='Delimiter'>, 
</span><a name="LN8386"></a>                <span class='Declare_Local'>average_secs</span><span class='Delimiter'>; 
</span><a name="LN8387"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>write_usecs</span><span class='Delimiter'>, 
</span><a name="LN8388"></a>                <span class='Declare_Local'>sync_usecs</span><span class='Delimiter'>, 
</span><a name="LN8389"></a>                <span class='Declare_Local'>total_usecs</span><span class='Delimiter'>, 
</span><a name="LN8390"></a>                <span class='Declare_Local'>longest_usecs</span><span class='Delimiter'>, 
</span><a name="LN8391"></a>                <span class='Declare_Local'>average_usecs</span><span class='Delimiter'>; 
</span><a name="LN8392"></a>    <a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a>      <span class='Declare_Local'>average_sync_time</span><span class='Delimiter'>; 
</span> 
    <a href="xlog.c.html#LN172"><span class='Ref_to_Global_Var'>CheckpointStats</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog.h.html#LN202"><span class='Ref_to_Member'>ckpt_end_t</span></a> <span class='Operator'>= </span><a href="../../../include/utils/timestamp.h.html#LN69"><span class='Ref_to_Proto'>GetCurrentTimestamp</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/timestamp.h.html#LN72"><span class='Ref_to_Proto'>TimestampDifference</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN172"><span class='Ref_to_Global_Var'>CheckpointStats</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog.h.html#LN199"><span class='Ref_to_Member'>ckpt_write_t</span></a><span class='Delimiter'>, 
</span>                        <a href="xlog.c.html#LN172"><span class='Ref_to_Global_Var'>CheckpointStats</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog.h.html#LN200"><span class='Ref_to_Member'>ckpt_sync_t</span></a><span class='Delimiter'>, 
</span>                        <span class='Operator'>&</span><a href="xlog.c.html#LN8382"><span class='Ref_To_Local'>write_secs</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN8387"><span class='Ref_To_Local'>write_usecs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/timestamp.h.html#LN72"><span class='Ref_to_Proto'>TimestampDifference</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN172"><span class='Ref_to_Global_Var'>CheckpointStats</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog.h.html#LN200"><span class='Ref_to_Member'>ckpt_sync_t</span></a><span class='Delimiter'>, 
</span>                        <a href="xlog.c.html#LN172"><span class='Ref_to_Global_Var'>CheckpointStats</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog.h.html#LN201"><span class='Ref_to_Member'>ckpt_sync_end_t</span></a><span class='Delimiter'>, 
</span>                        <span class='Operator'>&</span><a href="xlog.c.html#LN8383"><span class='Ref_To_Local'>sync_secs</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN8388"><span class='Ref_To_Local'>sync_usecs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Accumulate checkpoint timing summary data, in milliseconds. */ 
</span>    <a href="../../postmaster/pgstat.c.html#LN142"><span class='Ref_to_Global_Var'>BgWriterStats</span></a><span class='Operator'>.</span><a href="../../../include/pgstat.h.html#LN420"><span class='Ref_to_Member'>m_checkpoint_write_time</span></a> <span class='Operator'>+= 
</span>        <a href="xlog.c.html#LN8382"><span class='Ref_To_Local'>write_secs</span></a> <span class='Operator'>* </span><span class='Number'>1000</span> <span class='Operator'>+ </span><a href="xlog.c.html#LN8387"><span class='Ref_To_Local'>write_usecs</span></a> <span class='Operator'>/ </span><span class='Number'>1000</span><span class='Delimiter'>; 
</span>    <a href="../../postmaster/pgstat.c.html#LN142"><span class='Ref_to_Global_Var'>BgWriterStats</span></a><span class='Operator'>.</span><a href="../../../include/pgstat.h.html#LN421"><span class='Ref_to_Member'>m_checkpoint_sync_time</span></a> <span class='Operator'>+= 
</span>        <a href="xlog.c.html#LN8383"><span class='Ref_To_Local'>sync_secs</span></a> <span class='Operator'>* </span><span class='Number'>1000</span> <span class='Operator'>+ </span><a href="xlog.c.html#LN8388"><span class='Ref_To_Local'>sync_usecs</span></a> <span class='Operator'>/ </span><span class='Number'>1000</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * All of the published timing statistics are accounted for.  Only 
     * continue if a log message is to be written. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN101"><span class='Ref_to_Global_Var'>log_checkpoints</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/timestamp.h.html#LN72"><span class='Ref_to_Proto'>TimestampDifference</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN172"><span class='Ref_to_Global_Var'>CheckpointStats</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog.h.html#LN198"><span class='Ref_to_Member'>ckpt_start_t</span></a><span class='Delimiter'>, 
</span>                        <a href="xlog.c.html#LN172"><span class='Ref_to_Global_Var'>CheckpointStats</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog.h.html#LN202"><span class='Ref_to_Member'>ckpt_end_t</span></a><span class='Delimiter'>, 
</span>                        <span class='Operator'>&</span><a href="xlog.c.html#LN8384"><span class='Ref_To_Local'>total_secs</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN8389"><span class='Ref_To_Local'>total_usecs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Timing values returned from CheckpointStats are in microseconds. 
     * Convert to the second plus microsecond form that TimestampDifference 
     * returns for homogeneous printing. 
     */ 
</span>    <a href="xlog.c.html#LN8385"><span class='Ref_To_Local'>longest_secs</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>long</span><span class='Parentheses'>) (</span><a href="xlog.c.html#LN172"><span class='Ref_to_Global_Var'>CheckpointStats</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog.h.html#LN211"><span class='Ref_to_Member'>ckpt_longest_sync</span></a> <span class='Operator'>/ </span><span class='Number'>1000000</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN8390"><span class='Ref_To_Local'>longest_usecs</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN172"><span class='Ref_to_Global_Var'>CheckpointStats</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog.h.html#LN211"><span class='Ref_to_Member'>ckpt_longest_sync</span></a> <span class='Operator'>- 
</span>        <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN8385"><span class='Ref_To_Local'>longest_secs</span></a> <span class='Operator'>*</span><span class='Number'>1000000</span><span class='Delimiter'>; 
</span> 
    <a href="xlog.c.html#LN8392"><span class='Ref_To_Local'>average_sync_time</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN172"><span class='Ref_to_Global_Var'>CheckpointStats</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog.h.html#LN210"><span class='Ref_to_Member'>ckpt_sync_rels</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="xlog.c.html#LN8392"><span class='Ref_To_Local'>average_sync_time</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN172"><span class='Ref_to_Global_Var'>CheckpointStats</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog.h.html#LN212"><span class='Ref_to_Member'>ckpt_agg_sync_time</span></a> <span class='Operator'>/ 
</span>            <a href="xlog.c.html#LN172"><span class='Ref_to_Global_Var'>CheckpointStats</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog.h.html#LN210"><span class='Ref_to_Member'>ckpt_sync_rels</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN8386"><span class='Ref_To_Local'>average_secs</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>long</span><span class='Parentheses'>) (</span><a href="xlog.c.html#LN8392"><span class='Ref_To_Local'>average_sync_time</span></a> <span class='Operator'>/ </span><span class='Number'>1000000</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN8391"><span class='Ref_To_Local'>average_usecs</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN8392"><span class='Ref_To_Local'>average_sync_time</span></a> <span class='Operator'>- </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN8386"><span class='Ref_To_Local'>average_secs</span></a> <span class='Operator'>*</span><span class='Number'>1000000</span><span class='Delimiter'>; 
</span> 
    <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, </span><span class='String'>"%s complete: wrote %d buffers (%.1f%%); "</span> 
         <span class='String'>"%d WAL file(s) added, %d removed, %d recycled; "</span> 
         <span class='String'>"write=%ld.%03d s, sync=%ld.%03d s, total=%ld.%03d s; "</span> 
         <span class='String'>"sync files=%d, longest=%ld.%03d s, average=%ld.%03d s; "</span> 
         <span class='String'>"distance=%d kB, estimate=%d kB"</span><span class='Delimiter'>, 
</span>         <a href="xlog.c.html#LN8380"><span class='Ref_to_Parameter'>restartpoint</span></a> <span class='Operator'>? </span><span class='String'>"restartpoint"</span> <span class='Operator'>: </span><span class='String'>"checkpoint"</span><span class='Delimiter'>, 
</span>         <a href="xlog.c.html#LN172"><span class='Ref_to_Global_Var'>CheckpointStats</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog.h.html#LN204"><span class='Ref_to_Member'>ckpt_bufs_written</span></a><span class='Delimiter'>, 
</span>         <span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="xlog.c.html#LN172"><span class='Ref_to_Global_Var'>CheckpointStats</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog.h.html#LN204"><span class='Ref_to_Member'>ckpt_bufs_written</span></a> <span class='Operator'>* </span><span class='Number'>100</span> <span class='Operator'>/ </span><a href="../../utils/init/globals.c.html#LN122"><span class='Ref_to_Global_Var'>NBuffers</span></a><span class='Delimiter'>, 
</span>         <a href="xlog.c.html#LN172"><span class='Ref_to_Global_Var'>CheckpointStats</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog.h.html#LN206"><span class='Ref_to_Member'>ckpt_segs_added</span></a><span class='Delimiter'>, 
</span>         <a href="xlog.c.html#LN172"><span class='Ref_to_Global_Var'>CheckpointStats</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog.h.html#LN207"><span class='Ref_to_Member'>ckpt_segs_removed</span></a><span class='Delimiter'>, 
</span>         <a href="xlog.c.html#LN172"><span class='Ref_to_Global_Var'>CheckpointStats</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog.h.html#LN208"><span class='Ref_to_Member'>ckpt_segs_recycled</span></a><span class='Delimiter'>, 
</span>         <a href="xlog.c.html#LN8382"><span class='Ref_To_Local'>write_secs</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN8387"><span class='Ref_To_Local'>write_usecs</span></a> <span class='Operator'>/ </span><span class='Number'>1000</span><span class='Delimiter'>, 
</span>         <a href="xlog.c.html#LN8383"><span class='Ref_To_Local'>sync_secs</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN8388"><span class='Ref_To_Local'>sync_usecs</span></a> <span class='Operator'>/ </span><span class='Number'>1000</span><span class='Delimiter'>, 
</span>         <a href="xlog.c.html#LN8384"><span class='Ref_To_Local'>total_secs</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN8389"><span class='Ref_To_Local'>total_usecs</span></a> <span class='Operator'>/ </span><span class='Number'>1000</span><span class='Delimiter'>, 
</span>         <a href="xlog.c.html#LN172"><span class='Ref_to_Global_Var'>CheckpointStats</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog.h.html#LN210"><span class='Ref_to_Member'>ckpt_sync_rels</span></a><span class='Delimiter'>, 
</span>         <a href="xlog.c.html#LN8385"><span class='Ref_To_Local'>longest_secs</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN8390"><span class='Ref_To_Local'>longest_usecs</span></a> <span class='Operator'>/ </span><span class='Number'>1000</span><span class='Delimiter'>, 
</span>         <a href="xlog.c.html#LN8386"><span class='Ref_To_Local'>average_secs</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN8391"><span class='Ref_To_Local'>average_usecs</span></a> <span class='Operator'>/ </span><span class='Number'>1000</span><span class='Delimiter'>, 
</span>         <span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) (</span><a href="xlog.c.html#LN127"><span class='Ref_to_Global_Var'>PrevCheckPointDistance</span></a> <span class='Operator'>/ </span><span class='Number'>1024</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>         <span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) (</span><a href="xlog.c.html#LN126"><span class='Ref_to_Global_Var'>CheckPointDistanceEstimate</span></a> <span class='Operator'>/ </span><span class='Number'>1024</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end LogCheckpointEnd &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Update the estimate of distance between checkpoints. 
 * 
 * The estimate is used to calculate the number of WAL segments to keep 
 * preallocated, see XLOGFileSlop(). 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN8465"></a><span class='Declare_Function'>UpdateCheckPointDistanceEstimate</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a> <span class='Declare_Parameter'>nbytes</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * To estimate the number of segments consumed between checkpoints, keep a 
     * moving average of the amount of WAL generated in previous checkpoint 
     * cycles. However, if the load is bursty, with quiet periods and busy 
     * periods, we want to cater for the peak load. So instead of a plain 
     * moving average, let the average decline slowly if the previous cycle 
     * used less WAL than estimated, but bump it up immediately if it used 
     * more. 
     * 
     * When checkpoints are triggered by max_wal_size, this should converge to 
     * CheckpointSegments * XLOG_SEG_SIZE, 
     * 
     * Note: This doesn't pay any attention to what caused the checkpoint. 
     * Checkpoints triggered manually with CHECKPOINT command, or by e.g. 
     * starting a base backup, are counted the same as those created 
     * automatically. The slow-decline will largely mask them out, if they are 
     * not frequent. If they are frequent, it seems reasonable to count them 
     * in as any others; if you issue a manual checkpoint every 5 minutes and 
     * never let a timed checkpoint happen, it makes sense to base the 
     * preallocation on that 5 minute interval rather than whatever 
     * checkpoint_timeout is set to. 
     */ 
</span>    <a href="xlog.c.html#LN127"><span class='Ref_to_Global_Var'>PrevCheckPointDistance</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN8465"><span class='Ref_to_Parameter'>nbytes</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN126"><span class='Ref_to_Global_Var'>CheckPointDistanceEstimate</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN8465"><span class='Ref_to_Parameter'>nbytes</span></a><span class='Parentheses'>) 
</span>        <a href="xlog.c.html#LN126"><span class='Ref_to_Global_Var'>CheckPointDistanceEstimate</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN8465"><span class='Ref_to_Parameter'>nbytes</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="xlog.c.html#LN126"><span class='Ref_to_Global_Var'>CheckPointDistanceEstimate</span></a> <span class='Operator'>= 
</span>            <span class='Parentheses'>(</span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>90</span> <span class='Operator'>* </span><a href="xlog.c.html#LN126"><span class='Ref_to_Global_Var'>CheckPointDistanceEstimate</span></a> <span class='Operator'>+ </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>10</span> <span class='Operator'>* </span><span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="xlog.c.html#LN8465"><span class='Ref_to_Parameter'>nbytes</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end UpdateCheckPointDistanceEstimate &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Perform a checkpoint --- either during shutdown, or on-the-fly 
 * 
 * flags is a bitwise OR of the following: 
 *  CHECKPOINT_IS_SHUTDOWN: checkpoint is for database shutdown. 
 *  CHECKPOINT_END_OF_RECOVERY: checkpoint is for end of WAL recovery. 
 *  CHECKPOINT_IMMEDIATE: finish the checkpoint ASAP, 
 *      ignoring checkpoint_completion_target parameter. 
 *  CHECKPOINT_FORCE: force a checkpoint even if no XLOG activity has occurred 
 *      since the last one (implied by CHECKPOINT_IS_SHUTDOWN or 
 *      CHECKPOINT_END_OF_RECOVERY). 
 *  CHECKPOINT_FLUSH_ALL: also flush buffers of unlogged tables. 
 * 
 * Note: flags contains other bits, of interest here only for logging purposes. 
 * In particular note that this routine is synchronous and does not pay 
 * attention to CHECKPOINT_WAIT. 
 * 
 * If !shutdown then we are writing an online checkpoint. This is a very special 
 * kind of operation and WAL record because the checkpoint action occurs over 
 * a period of time yet logically occurs at just a single LSN. The logical 
 * position of the WAL record (redo ptr) is the same or earlier than the 
 * physical position. When we replay WAL we locate the checkpoint via its 
 * physical position then read the redo ptr and actually start replay at the 
 * earlier logical position. Note that we don't write *anything* to WAL at 
 * the logical position, so that location could be any other kind of WAL record. 
 * All of this mechanism allows us to continue working while we checkpoint. 
 * As a result, timing of actions is critical here and be careful to note that 
 * this function will likely take minutes to execute on a busy system. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN8527"></a><span class='Declare_Function'>CreateCheckPoint</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>flags</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN8529"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>shutdown</span><span class='Delimiter'>; 
</span><a name="LN8530"></a>    <a href="../../../include/catalog/pg_control.h.html#LN32"><span class='Ref_to_Struct'>CheckPoint</span></a>  <span class='Declare_Local'>checkPoint</span><span class='Delimiter'>; 
</span><a name="LN8531"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>recptr</span><span class='Delimiter'>; 
</span><a name="LN8532"></a>    <a href="xlog.c.html#LN514"><span class='Ref_to_Struct'>XLogCtlInsert</span></a> <span class='Operator'>*</span><span class='Declare_Local'>Insert</span> <span class='Operator'>= &</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN574"><span class='Ref_to_Member'>Insert</span></a><span class='Delimiter'>; 
</span><a name="LN8533"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>freespace</span><span class='Delimiter'>; 
</span><a name="LN8534"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>PriorRedoPtr</span><span class='Delimiter'>; 
</span><a name="LN8535"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>curInsert</span><span class='Delimiter'>; 
</span><a name="LN8536"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>last_important_lsn</span><span class='Delimiter'>; 
</span><a name="LN8537"></a>    <a href="../../../include/storage/lock.h.html#LN62"><span class='Ref_to_Typedef'>VirtualTransactionId</span></a> <span class='Operator'>*</span><span class='Declare_Local'>vxids</span><span class='Delimiter'>; 
</span><a name="LN8538"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>nvxids</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * An end-of-recovery checkpoint is really a shutdown checkpoint, just 
     * issued at a different time. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN8527"><span class='Ref_to_Parameter'>flags</span></a> <span class='Operator'>& </span><span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN174"><span class='Ref_to_Const'>CHECKPOINT_IS_SHUTDOWN</span></a> <span class='Operator'>| </span><a href="../../../include/access/xlog.h.html#LN175"><span class='Ref_to_Const'>CHECKPOINT_END_OF_RECOVERY</span></a><span class='Parentheses'>))</span> 
        <a href="xlog.c.html#LN8529"><span class='Ref_To_Local'>shutdown</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="xlog.c.html#LN8529"><span class='Ref_To_Local'>shutdown</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* sanity check */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN242"><span class='Ref_to_Proto'>RecoveryInProgress</span></a><span class='Parentheses'>() </span><span class='Operator'>&& </span><span class='Parentheses'>(</span><a href="xlog.c.html#LN8527"><span class='Ref_to_Parameter'>flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/xlog.h.html#LN175"><span class='Ref_to_Const'>CHECKPOINT_END_OF_RECOVERY</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"can't create a checkpoint during recovery"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Initialize InitXLogInsert working areas before entering the critical 
     * section.  Normally, this is done by the first call to 
     * RecoveryInProgress() or LocalSetXLogInsertAllowed(), but when creating 
     * an end-of-recovery checkpoint, the LocalSetXLogInsertAllowed call is 
     * done below in a critical section, and InitXLogInsert cannot be called 
     * in a critical section. 
     */ 
</span>    <a href="../../../include/access/xloginsert.h.html#LN59"><span class='Ref_to_Proto'>InitXLogInsert</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Acquire CheckpointLock to ensure only one checkpoint happens at a time. 
     * (This is just pro forma, since in the present system structure there is 
     * only one process that is allowed to issue checkpoints at any given 
     * time.) 
     */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>CheckpointLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Prepare to accumulate statistics. 
     * 
     * Note: because it is possible for log_checkpoints to change while a 
     * checkpoint proceeds, we always accumulate stats, even if 
     * log_checkpoints is currently off. 
     */ 
</span>    <a href="../../../include/c.h.html#LN856"><span class='Ref_to_Macro'>MemSet</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN172"><span class='Ref_to_Global_Var'>CheckpointStats</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN172"><span class='Ref_to_Global_Var'>CheckpointStats</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN172"><span class='Ref_to_Global_Var'>CheckpointStats</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog.h.html#LN198"><span class='Ref_to_Member'>ckpt_start_t</span></a> <span class='Operator'>= </span><a href="../../../include/utils/timestamp.h.html#LN69"><span class='Ref_to_Proto'>GetCurrentTimestamp</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Use a critical section to force system panic if we have trouble. 
     */ 
</span>    <a href="../../../include/miscadmin.h.html#LN132"><span class='Ref_to_Macro'>START_CRIT_SECTION</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN8529"><span class='Ref_To_Local'>shutdown</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ControlFileLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN129"><span class='Ref_to_Member'>state</span></a> <span class='Operator'>= </span><a href="../../../include/catalog/pg_control.h.html#LN88"><span class='Ref_to_EnumConst'>DB_SHUTDOWNING</span></a><span class='Delimiter'>; 
</span>        <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN130"><span class='Ref_to_Member'>time</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/pgtime.h.html#LN22"><span class='Ref_to_Typedef'>pg_time_t</span></a><span class='Parentheses'>) </span>time<span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/access/xlog.h.html#LN256"><span class='Ref_to_Proto'>UpdateControlFile</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ControlFileLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Let smgr prepare for checkpoint; this has to happen before we determine 
     * the REDO pointer.  Note that smgr must not do anything that'd have to 
     * be undone if we decide no checkpoint is needed. 
     */ 
</span>    <a href="../../../include/storage/smgr.h.html#LN108"><span class='Ref_to_Proto'>smgrpreckpt</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Begin filling in the checkpoint WAL record */ 
</span>    <a href="../../../include/c.h.html#LN856"><span class='Ref_to_Macro'>MemSet</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN8530"><span class='Ref_To_Local'>checkPoint</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN8530"><span class='Ref_To_Local'>checkPoint</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN8530"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN49"><span class='Ref_to_Member'>time</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/pgtime.h.html#LN22"><span class='Ref_to_Typedef'>pg_time_t</span></a><span class='Parentheses'>) </span>time<span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * For Hot Standby, derive the oldestActiveXid before we fix the redo 
     * pointer. This allows us to begin accumulating changes to assemble our 
     * starting snapshot of locks and transactions. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN8529"><span class='Ref_To_Local'>shutdown</span></a> <span class='Operator'>&& </span><a href="../../../include/access/xlog.h.html#LN158"><span class='Ref_to_Macro'>XLogStandbyInfoActive</span></a><span class='Parentheses'>())</span> 
        <a href="xlog.c.html#LN8530"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN61"><span class='Ref_to_Member'>oldestActiveXid</span></a> <span class='Operator'>= </span><a href="../../../include/storage/procarray.h.html#LN92"><span class='Ref_to_Proto'>GetOldestActiveTransactionId</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="xlog.c.html#LN8530"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN61"><span class='Ref_to_Member'>oldestActiveXid</span></a> <span class='Operator'>= </span><a href="../../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Get location of last important record before acquiring insert locks (as 
     * GetLastImportantRecPtr() also locks WAL locks). 
     */ 
</span>    <a href="xlog.c.html#LN8536"><span class='Ref_To_Local'>last_important_lsn</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlog.h.html#LN276"><span class='Ref_to_Proto'>GetLastImportantRecPtr</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We must block concurrent insertions while examining insert state to 
     * determine the checkpoint REDO pointer. 
     */ 
</span>    <a href="xlog.c.html#LN925"><span class='Ref_to_Proto'>WALInsertLockAcquireExclusive</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN8535"><span class='Ref_To_Local'>curInsert</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN919"><span class='Ref_to_Proto'>XLogBytePosToRecPtr</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN8532"><span class='Ref_To_Local'>Insert</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN525"><span class='Ref_to_Member'>CurrBytePos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If this isn't a shutdown or forced checkpoint, and if there has been no 
     * WAL activity requiring a checkpoint, skip it.  The idea here is to 
     * avoid inserting duplicate checkpoints when the system is idle. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="xlog.c.html#LN8527"><span class='Ref_to_Parameter'>flags</span></a> <span class='Operator'>& </span><span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN174"><span class='Ref_to_Const'>CHECKPOINT_IS_SHUTDOWN</span></a> <span class='Operator'>| </span><a href="../../../include/access/xlog.h.html#LN175"><span class='Ref_to_Const'>CHECKPOINT_END_OF_RECOVERY</span></a> <span class='Operator'>| 
</span>                  <a href="../../../include/access/xlog.h.html#LN179"><span class='Ref_to_Const'>CHECKPOINT_FORCE</span></a><span class='Parentheses'>))</span> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN8536"><span class='Ref_To_Local'>last_important_lsn</span></a> <span class='Operator'>== </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN131"><span class='Ref_to_Member'>checkPoint</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="xlog.c.html#LN926"><span class='Ref_to_Proto'>WALInsertLockRelease</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>            <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>CheckpointLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/miscadmin.h.html#LN134"><span class='Ref_to_Macro'>END_CRIT_SECTION</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN24"><span class='Ref_to_Const'>DEBUG1</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"checkpoint skipped due to an idle system"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * An end-of-recovery checkpoint is created before anyone is allowed to 
     * write WAL. To allow us to write the checkpoint record, temporarily 
     * enable XLogInsertAllowed.  (This also ensures ThisTimeLineID is 
     * initialized, which we need here and in AdvanceXLInsertBuffer.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN8527"><span class='Ref_to_Parameter'>flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/xlog.h.html#LN175"><span class='Ref_to_Const'>CHECKPOINT_END_OF_RECOVERY</span></a><span class='Parentheses'>) 
</span>        <a href="xlog.c.html#LN857"><span class='Ref_to_Proto'>LocalSetXLogInsertAllowed</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <a href="xlog.c.html#LN8530"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN36"><span class='Ref_to_Member'>ThisTimeLineID</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN8527"><span class='Ref_to_Parameter'>flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/xlog.h.html#LN175"><span class='Ref_to_Const'>CHECKPOINT_END_OF_RECOVERY</span></a><span class='Parentheses'>) 
</span>        <a href="xlog.c.html#LN8530"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN37"><span class='Ref_to_Member'>PrevTimeLineID</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN629"><span class='Ref_to_Member'>PrevTimeLineID</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="xlog.c.html#LN8530"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN37"><span class='Ref_to_Member'>PrevTimeLineID</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Delimiter'>; 
</span> 
    <a href="xlog.c.html#LN8530"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN39"><span class='Ref_to_Member'>fullPageWrites</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN8532"><span class='Ref_To_Local'>Insert</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN549"><span class='Ref_to_Member'>fullPageWrites</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Compute new REDO record ptr = location of next XLOG record. 
     * 
     * NB: this is NOT necessarily where the checkpoint record itself will be, 
     * since other backends may insert more XLOG records while we're off doing 
     * the buffer flush work.  Those XLOG records are logically after the 
     * checkpoint, even though physically before it.  Got that? 
     */ 
</span>    <a href="xlog.c.html#LN8533"><span class='Ref_To_Local'>freespace</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN719"><span class='Ref_to_Macro'>INSERT_FREESPACE</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN8535"><span class='Ref_To_Local'>curInsert</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN8533"><span class='Ref_To_Local'>freespace</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN8535"><span class='Ref_To_Local'>curInsert</span></a> <span class='Operator'>% </span><a href="../../../include/access/xlog_internal.h.html#LN91"><span class='Ref_to_Const'>XLogSegSize</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <a href="xlog.c.html#LN8535"><span class='Ref_To_Local'>curInsert</span></a> <span class='Operator'>+= </span><a href="../../../include/access/xlog_internal.h.html#LN71"><span class='Ref_to_Const'>SizeOfXLogLongPHD</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="xlog.c.html#LN8535"><span class='Ref_To_Local'>curInsert</span></a> <span class='Operator'>+= </span><a href="../../../include/access/xlog_internal.h.html#LN54"><span class='Ref_to_Const'>SizeOfXLogShortPHD</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="xlog.c.html#LN8530"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN34"><span class='Ref_to_Member'>redo</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN8535"><span class='Ref_To_Local'>curInsert</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Here we update the shared RedoRecPtr for future XLogInsert calls; this 
     * must be done while holding all the insertion locks. 
     * 
     * Note: if we fail to complete the checkpoint, RedoRecPtr will be left 
     * pointing past where it really needs to point.  This is okay; the only 
     * consequence is that XLogInsert might back up whole buffers that it 
     * didn't really need to.  We can't postpone advancing RedoRecPtr because 
     * XLogInserts that happen while we are dumping buffers must assume that 
     * their buffer changes are not included in the checkpoint. 
     */ 
</span>    <a href="xlog.c.html#LN349"><span class='Ref_to_Global_Var'>RedoRecPtr</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN574"><span class='Ref_to_Member'>Insert</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN547"><span class='Ref_to_Member'>RedoRecPtr</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN8530"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN34"><span class='Ref_to_Member'>redo</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now we can release the WAL insertion locks, allowing other xacts to 
     * proceed while we are flushing disk buffers. 
     */ 
</span>    <a href="xlog.c.html#LN926"><span class='Ref_to_Proto'>WALInsertLockRelease</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Update the info_lck-protected copy of RedoRecPtr as well */ 
</span>    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN578"><span class='Ref_to_Member'>RedoRecPtr</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN8530"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN34"><span class='Ref_to_Member'>redo</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If enabled, log checkpoint start.  We postpone this until now so as not 
     * to log anything if we decided to skip the checkpoint. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN101"><span class='Ref_to_Global_Var'>log_checkpoints</span></a><span class='Parentheses'>) 
</span>        <a href="xlog.c.html#LN8361"><span class='Ref_to_Func'>LogCheckpointStart</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN8527"><span class='Ref_to_Parameter'>flags</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    TRACE_POSTGRESQL_CHECKPOINT_START<span class='Parentheses'>(</span><a href="xlog.c.html#LN8527"><span class='Ref_to_Parameter'>flags</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Get the other info we need for the checkpoint record. 
     * 
     * We don't need to save oldestClogXid in the checkpoint, it only matters 
     * for the short period in which clog is being truncated, and if we crash 
     * during that we'll redo the clog truncation and fix up oldestClogXid 
     * there. 
     */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>XidGenLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN8530"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN41"><span class='Ref_to_Member'>nextXid</span></a> <span class='Operator'>= </span><a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN116"><span class='Ref_to_Member'>nextXid</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN8530"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN45"><span class='Ref_to_Member'>oldestXid</span></a> <span class='Operator'>= </span><a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN118"><span class='Ref_to_Member'>oldestXid</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN8530"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN46"><span class='Ref_to_Member'>oldestXidDB</span></a> <span class='Operator'>= </span><a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN123"><span class='Ref_to_Member'>oldestXidDB</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>XidGenLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>CommitTsLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN8530"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN50"><span class='Ref_to_Member'>oldestCommitTsXid</span></a> <span class='Operator'>= </span><a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN128"><span class='Ref_to_Member'>oldestCommitTsXid</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN8530"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN52"><span class='Ref_to_Member'>newestCommitTsXid</span></a> <span class='Operator'>= </span><a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN129"><span class='Ref_to_Member'>newestCommitTsXid</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>CommitTsLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Increase XID epoch if we've wrapped around since last checkpoint */ 
</span>    <a href="xlog.c.html#LN8530"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN40"><span class='Ref_to_Member'>nextXidEpoch</span></a> <span class='Operator'>= </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN134"><span class='Ref_to_Member'>checkPointCopy</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN40"><span class='Ref_to_Member'>nextXidEpoch</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN8530"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN41"><span class='Ref_to_Member'>nextXid</span></a> <span class='Operator'>&LT; </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN134"><span class='Ref_to_Member'>checkPointCopy</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN41"><span class='Ref_to_Member'>nextXid</span></a><span class='Parentheses'>) 
</span>        <a href="xlog.c.html#LN8530"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN40"><span class='Ref_to_Member'>nextXidEpoch</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>OidGenLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN8530"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN42"><span class='Ref_to_Member'>nextOid</span></a> <span class='Operator'>= </span><a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN110"><span class='Ref_to_Member'>nextOid</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN8529"><span class='Ref_To_Local'>shutdown</span></a><span class='Parentheses'>) 
</span>        <a href="xlog.c.html#LN8530"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN42"><span class='Ref_to_Member'>nextOid</span></a> <span class='Operator'>+= </span><a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN111"><span class='Ref_to_Member'>oidCount</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>OidGenLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/access/multixact.h.html#LN131"><span class='Ref_to_Proto'>MultiXactGetCheckptMulti</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN8529"><span class='Ref_To_Local'>shutdown</span></a><span class='Delimiter'>, 
</span>                             <span class='Operator'>&</span><a href="xlog.c.html#LN8530"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN43"><span class='Ref_to_Member'>nextMulti</span></a><span class='Delimiter'>, 
</span>                             <span class='Operator'>&</span><a href="xlog.c.html#LN8530"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN44"><span class='Ref_to_Member'>nextMultiOffset</span></a><span class='Delimiter'>, 
</span>                             <span class='Operator'>&</span><a href="xlog.c.html#LN8530"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN47"><span class='Ref_to_Member'>oldestMulti</span></a><span class='Delimiter'>, 
</span>                             <span class='Operator'>&</span><a href="xlog.c.html#LN8530"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN48"><span class='Ref_to_Member'>oldestMultiDB</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Having constructed the checkpoint record, ensure all shmem disk buffers 
     * and commit-log buffers are flushed to disk. 
     * 
     * This I/O could fail for various reasons.  If so, we will fail to 
     * complete the checkpoint, but there is no reason to force a system 
     * panic. Accordingly, exit critical section while doing it. 
     */ 
</span>    <a href="../../../include/miscadmin.h.html#LN134"><span class='Ref_to_Macro'>END_CRIT_SECTION</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * In some cases there are groups of actions that must all occur on one 
     * side or the other of a checkpoint record. Before flushing the 
     * checkpoint record we must explicitly wait for any backend currently 
     * performing those groups of actions. 
     * 
     * One example is end of transaction, so we must wait for any transactions 
     * that are currently in commit critical sections.  If an xact inserted 
     * its commit record into XLOG just before the REDO point, then a crash 
     * restart from the REDO point would not replay that record, which means 
     * that our flushing had better include the xact's update of pg_xact.  So 
     * we wait till he's out of his commit critical section before proceeding. 
     * See notes in RecordTransactionCommit(). 
     * 
     * Because we've already released the insertion locks, this test is a bit 
     * fuzzy: it is possible that we will wait for xacts we didn't really need 
     * to wait for.  But the delay should be short and it seems better to make 
     * checkpoint take a bit longer than to hold off insertions longer than 
     * necessary. (In fact, the whole reason we have this issue is that xact.c 
     * does commit record XLOG insertion and clog update as two separate steps 
     * protected by different locks, but again that seems best on grounds of 
     * minimizing lock contention.) 
     * 
     * A transaction that has not yet set delayChkpt when we look cannot be at 
     * risk, since he's not inserted his commit record yet; and one that's 
     * already cleared it is not at risk either, since he's done fixing clog 
     * and we will correctly flush the update below.  So we cannot miss any 
     * xacts we need to wait for. 
     */ 
</span>    <a href="xlog.c.html#LN8537"><span class='Ref_To_Local'>vxids</span></a> <span class='Operator'>= </span><a href="../../../include/storage/procarray.h.html#LN95"><span class='Ref_to_Proto'>GetVirtualXIDsDelayingChkpt</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN8538"><span class='Ref_To_Local'>nvxids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN8538"><span class='Ref_To_Local'>nvxids</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>do</span> 
        <span class='Delimiter'>{ 
</span>            <a href="../../../port/pgsleep.c.html#LN45"><span class='Ref_to_Func'>pg_usleep</span></a><span class='Parentheses'>(</span><span class='Number'>10000L</span><span class='Parentheses'>)</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* wait for 10 msec */ 
</span>        <span class='Delimiter'>} </span><span class='Control'>while</span> <span class='Parentheses'>(</span><a href="../../../include/storage/procarray.h.html#LN96"><span class='Ref_to_Proto'>HaveVirtualXIDsDelayingChkpt</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN8537"><span class='Ref_To_Local'>vxids</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN8538"><span class='Ref_To_Local'>nvxids</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN8537"><span class='Ref_To_Local'>vxids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="xlog.c.html#LN859"><span class='Ref_to_Proto'>CheckPointGuts</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN8530"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN34"><span class='Ref_to_Member'>redo</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN8527"><span class='Ref_to_Parameter'>flags</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Take a snapshot of running transactions and write this to WAL. This 
     * allows us to reconstruct the state of running transactions during 
     * archive recovery, if required. Skip, if this info disabled. 
     * 
     * If we are shutting down, or Startup process is completing crash 
     * recovery we don't need to write running xact data. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN8529"><span class='Ref_To_Local'>shutdown</span></a> <span class='Operator'>&& </span><a href="../../../include/access/xlog.h.html#LN158"><span class='Ref_to_Macro'>XLogStandbyInfoActive</span></a><span class='Parentheses'>())</span> 
        <a href="../../../include/storage/standby.h.html#LN86"><span class='Ref_to_Proto'>LogStandbySnapshot</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/miscadmin.h.html#LN132"><span class='Ref_to_Macro'>START_CRIT_SECTION</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now insert the checkpoint record into XLOG. 
     */ 
</span>    <a href="../../../include/access/xloginsert.h.html#LN41"><span class='Ref_to_Proto'>XLogBeginInsert</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="../../../include/access/xloginsert.h.html#LN45"><span class='Ref_to_Proto'>XLogRegisterData</span></a><span class='Parentheses'>((</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) (</span><span class='Operator'>&</span><a href="xlog.c.html#LN8530"><span class='Ref_To_Local'>checkPoint</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN8530"><span class='Ref_To_Local'>checkPoint</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN8531"><span class='Ref_To_Local'>recptr</span></a> <span class='Operator'>= </span><a href="../../../include/access/xloginsert.h.html#LN43"><span class='Ref_to_Proto'>XLogInsert</span></a><span class='Parentheses'>(</span>RM_XLOG_ID<span class='Delimiter'>, 
</span>                        <a href="xlog.c.html#LN8529"><span class='Ref_To_Local'>shutdown</span></a> <span class='Operator'>? </span><a href="../../../include/catalog/pg_control.h.html#LN65"><span class='Ref_to_Const'>XLOG_CHECKPOINT_SHUTDOWN</span></a> <span class='Operator'>: 
</span>                        <a href="../../../include/catalog/pg_control.h.html#LN66"><span class='Ref_to_Const'>XLOG_CHECKPOINT_ONLINE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/access/xlog.h.html#LN225"><span class='Ref_to_Proto'>XLogFlush</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN8531"><span class='Ref_To_Local'>recptr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We mustn't write any new WAL after a shutdown checkpoint, or it will be 
     * overwritten at next startup.  No-one should even try, this just allows 
     * sanity-checking.  In the case of an end-of-recovery checkpoint, we want 
     * to just temporarily disable writing until the system has exited 
     * recovery. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN8529"><span class='Ref_To_Local'>shutdown</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN8527"><span class='Ref_to_Parameter'>flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/xlog.h.html#LN175"><span class='Ref_to_Const'>CHECKPOINT_END_OF_RECOVERY</span></a><span class='Parentheses'>) 
</span>            <a href="xlog.c.html#LN232"><span class='Ref_to_Global_Var'>LocalXLogInsertAllowed</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* return to "check" state */ 
</span>        <span class='Control'>else</span> 
            <a href="xlog.c.html#LN232"><span class='Ref_to_Global_Var'>LocalXLogInsertAllowed</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* never again write WAL */ 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We now have ProcLastRecPtr = start of actual checkpoint record, recptr 
     * = end of actual checkpoint record. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN8529"><span class='Ref_To_Local'>shutdown</span></a> <span class='Operator'>&& </span><a href="xlog.c.html#LN8530"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN34"><span class='Ref_to_Member'>redo</span></a> <span class='Operator'>!= </span><a href="xlog.c.html#LN335"><span class='Ref_to_Global_Var'>ProcLastRecPtr</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"concurrent write-ahead log activity while database system is shutting down"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Remember the prior checkpoint's redo pointer, used later to determine 
     * the point where the log can be truncated. 
     */ 
</span>    <a href="xlog.c.html#LN8534"><span class='Ref_To_Local'>PriorRedoPtr</span></a> <span class='Operator'>= </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN134"><span class='Ref_to_Member'>checkPointCopy</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN34"><span class='Ref_to_Member'>redo</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Update the control file. 
     */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ControlFileLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN8529"><span class='Ref_To_Local'>shutdown</span></a><span class='Parentheses'>) 
</span>        <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN129"><span class='Ref_to_Member'>state</span></a> <span class='Operator'>= </span><a href="../../../include/catalog/pg_control.h.html#LN86"><span class='Ref_to_EnumConst'>DB_SHUTDOWNED</span></a><span class='Delimiter'>; 
</span>    <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN132"><span class='Ref_to_Member'>prevCheckPoint</span></a> <span class='Operator'>= </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN131"><span class='Ref_to_Member'>checkPoint</span></a><span class='Delimiter'>; 
</span>    <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN131"><span class='Ref_to_Member'>checkPoint</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN335"><span class='Ref_to_Global_Var'>ProcLastRecPtr</span></a><span class='Delimiter'>; 
</span>    <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN134"><span class='Ref_to_Member'>checkPointCopy</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN8530"><span class='Ref_To_Local'>checkPoint</span></a><span class='Delimiter'>; 
</span>    <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN130"><span class='Ref_to_Member'>time</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/pgtime.h.html#LN22"><span class='Ref_to_Typedef'>pg_time_t</span></a><span class='Parentheses'>) </span>time<span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* crash recovery should always recover to the end of WAL */ 
</span>    <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN169"><span class='Ref_to_Member'>minRecoveryPoint</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>; 
</span>    <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN170"><span class='Ref_to_Member'>minRecoveryPointTLI</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Persist unloggedLSN value. It's reset on crash recovery, so this goes 
     * unused on non-shutdown checkpoints, but seems useful to store it always 
     * for debugging purposes. 
     */ 
</span>    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN589"><span class='Ref_to_Member'>ulsn_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN136"><span class='Ref_to_Member'>unloggedLSN</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN588"><span class='Ref_to_Member'>unloggedLSN</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN589"><span class='Ref_to_Member'>ulsn_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/access/xlog.h.html#LN256"><span class='Ref_to_Proto'>UpdateControlFile</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ControlFileLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Update shared-memory copy of checkpoint XID/epoch */ 
</span>    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN579"><span class='Ref_to_Member'>ckptXidEpoch</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN8530"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN40"><span class='Ref_to_Member'>nextXidEpoch</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN580"><span class='Ref_to_Member'>ckptXid</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN8530"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN41"><span class='Ref_to_Member'>nextXid</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We are now done with critical updates; no need for system panic if we 
     * have trouble while fooling with old log segments. 
     */ 
</span>    <a href="../../../include/miscadmin.h.html#LN134"><span class='Ref_to_Macro'>END_CRIT_SECTION</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Let smgr do post-checkpoint cleanup (eg, deleting old files). 
     */ 
</span>    <a href="../../../include/storage/smgr.h.html#LN110"><span class='Ref_to_Proto'>smgrpostckpt</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Delete old log files (those no longer needed even for previous 
     * checkpoint or the standbys in XLOG streaming). 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN8534"><span class='Ref_To_Local'>PriorRedoPtr</span></a> <span class='Operator'>!= </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN8905"></a>        <a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a>   <span class='Declare_Local'>_logSegNo</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Update the average distance between checkpoints. */ 
</span>        <a href="xlog.c.html#LN8464"><span class='Ref_to_Func'>UpdateCheckPointDistanceEstimate</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN349"><span class='Ref_to_Global_Var'>RedoRecPtr</span></a> <span class='Operator'>- </span><a href="xlog.c.html#LN8534"><span class='Ref_To_Local'>PriorRedoPtr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/access/xlog_internal.h.html#LN105"><span class='Ref_to_Macro'>XLByteToSeg</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN8534"><span class='Ref_To_Local'>PriorRedoPtr</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN8905"><span class='Ref_To_Local'>_logSegNo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN860"><span class='Ref_to_Proto'>KeepLogSeg</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN8531"><span class='Ref_To_Local'>recptr</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN8905"><span class='Ref_To_Local'>_logSegNo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN8905"><span class='Ref_To_Local'>_logSegNo</span></a><span class='Operator'>--</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN880"><span class='Ref_to_Proto'>RemoveOldXlogFiles</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN8905"><span class='Ref_To_Local'>_logSegNo</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN8534"><span class='Ref_To_Local'>PriorRedoPtr</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN8531"><span class='Ref_To_Local'>recptr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Make more log segments if needed.  (Do this after recycling old log 
     * segments, since that may supply some of the needed files.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN8529"><span class='Ref_To_Local'>shutdown</span></a><span class='Parentheses'>) 
</span>        <a href="xlog.c.html#LN879"><span class='Ref_to_Proto'>PreallocXlogFiles</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN8531"><span class='Ref_To_Local'>recptr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Truncate pg_subtrans if possible.  We can throw away all data before 
     * the oldest XMIN of any running transaction.  No future transaction will 
     * attempt to reference any pg_subtrans entry older than that (see Asserts 
     * in subtrans.c).  During recovery, though, we mustn't do this because 
     * StartupSUBTRANS hasn't been called yet. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/xlog.h.html#LN242"><span class='Ref_to_Proto'>RecoveryInProgress</span></a><span class='Parentheses'>())</span> 
        <a href="../../../include/access/subtrans.h.html#LN27"><span class='Ref_to_Proto'>TruncateSUBTRANS</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/procarray.h.html#LN91"><span class='Ref_to_Proto'>GetOldestXmin</span></a><span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><a href="../../../include/storage/procarray.h.html#LN50"><span class='Ref_to_Const'>PROCARRAY_FLAGS_DEFAULT</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Real work is done, but log and update stats before releasing lock. */ 
</span>    <a href="xlog.c.html#LN8379"><span class='Ref_to_Func'>LogCheckpointEnd</span></a><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    TRACE_POSTGRESQL_CHECKPOINT_DONE<span class='Parentheses'>(</span><a href="xlog.c.html#LN172"><span class='Ref_to_Global_Var'>CheckpointStats</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog.h.html#LN204"><span class='Ref_to_Member'>ckpt_bufs_written</span></a><span class='Delimiter'>, 
</span>                                     <a href="../../utils/init/globals.c.html#LN122"><span class='Ref_to_Global_Var'>NBuffers</span></a><span class='Delimiter'>, 
</span>                                     <a href="xlog.c.html#LN172"><span class='Ref_to_Global_Var'>CheckpointStats</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog.h.html#LN206"><span class='Ref_to_Member'>ckpt_segs_added</span></a><span class='Delimiter'>, 
</span>                                     <a href="xlog.c.html#LN172"><span class='Ref_to_Global_Var'>CheckpointStats</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog.h.html#LN207"><span class='Ref_to_Member'>ckpt_segs_removed</span></a><span class='Delimiter'>, 
</span>                                     <a href="xlog.c.html#LN172"><span class='Ref_to_Global_Var'>CheckpointStats</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog.h.html#LN208"><span class='Ref_to_Member'>ckpt_segs_recycled</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>CheckpointLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end CreateCheckPoint &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Mark the end of recovery in WAL though without running a full checkpoint. 
 * We can expect that a restartpoint is likely to be in progress as we 
 * do this, though we are unwilling to wait for it to complete. So be 
 * careful to avoid taking the CheckpointLock anywhere here. 
 * 
 * CreateRestartPoint() allows for the case where recovery may end before 
 * the restartpoint completes so there is no concern of concurrent behaviour. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN8955"></a><span class='Declare_Function'>CreateEndOfRecoveryRecord</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN8957"></a>    <a href="../../../include/access/xlog_internal.h.html#LN229"><span class='Ref_to_Struct'>xl_end_of_recovery</span></a> <span class='Declare_Local'>xlrec</span><span class='Delimiter'>; 
</span><a name="LN8958"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>recptr</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* sanity check */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/xlog.h.html#LN242"><span class='Ref_to_Proto'>RecoveryInProgress</span></a><span class='Parentheses'>())</span> 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"can only be used to end recovery"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="xlog.c.html#LN8957"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog_internal.h.html#LN231"><span class='Ref_to_Member'>end_time</span></a> <span class='Operator'>= </span><a href="../../../include/utils/timestamp.h.html#LN69"><span class='Ref_to_Proto'>GetCurrentTimestamp</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <a href="xlog.c.html#LN925"><span class='Ref_to_Proto'>WALInsertLockAcquireExclusive</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN8957"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog_internal.h.html#LN232"><span class='Ref_to_Member'>ThisTimeLineID</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN8957"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog_internal.h.html#LN233"><span class='Ref_to_Member'>PrevTimeLineID</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN629"><span class='Ref_to_Member'>PrevTimeLineID</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN926"><span class='Ref_to_Proto'>WALInsertLockRelease</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <a href="xlog.c.html#LN857"><span class='Ref_to_Proto'>LocalSetXLogInsertAllowed</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/miscadmin.h.html#LN132"><span class='Ref_to_Macro'>START_CRIT_SECTION</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/access/xloginsert.h.html#LN41"><span class='Ref_to_Proto'>XLogBeginInsert</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="../../../include/access/xloginsert.h.html#LN45"><span class='Ref_to_Proto'>XLogRegisterData</span></a><span class='Parentheses'>((</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><a href="xlog.c.html#LN8957"><span class='Ref_To_Local'>xlrec</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/access/xlog_internal.h.html#LN229"><span class='Ref_to_Struct'>xl_end_of_recovery</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN8958"><span class='Ref_To_Local'>recptr</span></a> <span class='Operator'>= </span><a href="../../../include/access/xloginsert.h.html#LN43"><span class='Ref_to_Proto'>XLogInsert</span></a><span class='Parentheses'>(</span>RM_XLOG_ID<span class='Delimiter'>, </span><a href="../../../include/catalog/pg_control.h.html#LN74"><span class='Ref_to_Const'>XLOG_END_OF_RECOVERY</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/access/xlog.h.html#LN225"><span class='Ref_to_Proto'>XLogFlush</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN8958"><span class='Ref_To_Local'>recptr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Update the control file so that crash recovery can follow the timeline 
     * changes to this point. 
     */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ControlFileLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN130"><span class='Ref_to_Member'>time</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/pgtime.h.html#LN22"><span class='Ref_to_Typedef'>pg_time_t</span></a><span class='Parentheses'>) </span>time<span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN169"><span class='Ref_to_Member'>minRecoveryPoint</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN8958"><span class='Ref_To_Local'>recptr</span></a><span class='Delimiter'>; 
</span>    <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN170"><span class='Ref_to_Member'>minRecoveryPointTLI</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/access/xlog.h.html#LN256"><span class='Ref_to_Proto'>UpdateControlFile</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ControlFileLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/miscadmin.h.html#LN134"><span class='Ref_to_Macro'>END_CRIT_SECTION</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <a href="xlog.c.html#LN232"><span class='Ref_to_Global_Var'>LocalXLogInsertAllowed</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* return to "check" state */ 
</span><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end CreateEndOfRecoveryRecord &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Flush all data in shared memory to disk, and fsync 
 * 
 * This is the common code shared between regular checkpoints and 
 * recovery restartpoints. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN9004"></a><span class='Declare_Function'>CheckPointGuts</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>checkPointRedo</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>flags</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/access/clog.h.html#LN48"><span class='Ref_to_Proto'>CheckPointCLOG</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="../../../include/access/commit_ts.h.html#LN40"><span class='Ref_to_Proto'>CheckPointCommitTs</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="../../../include/access/subtrans.h.html#LN25"><span class='Ref_to_Proto'>CheckPointSUBTRANS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="../../../include/access/multixact.h.html#LN136"><span class='Ref_to_Proto'>CheckPointMultiXact</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/predicate.h.html#LN40"><span class='Ref_to_Proto'>CheckPointPredicate</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="../../../include/utils/relmapper.h.html#LN53"><span class='Ref_to_Proto'>CheckPointRelationMap</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="../../../include/replication/slot.h.html#LN182"><span class='Ref_to_Proto'>CheckPointReplicationSlots</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="../../../include/replication/snapbuild.h.html#LN59"><span class='Ref_to_Proto'>CheckPointSnapBuild</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="../../../include/access/rewriteheap.h.html#LN54"><span class='Ref_to_Proto'>CheckPointLogicalRewriteHeap</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/bufmgr.h.html#LN186"><span class='Ref_to_Proto'>CheckPointBuffers</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9004"><span class='Ref_to_Parameter'>flags</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* performs all required fsyncs */ 
</span>    <a href="../../../include/replication/origin.h.html#LN61"><span class='Ref_to_Proto'>CheckPointReplicationOrigin</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* We deliberately delay 2PC checkpointing as long as possible */ 
</span>    <a href="../../../include/access/twophase.h.html#LN51"><span class='Ref_to_Proto'>CheckPointTwoPhase</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9004"><span class='Ref_to_Parameter'>checkPointRedo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Save a checkpoint for recovery restart if appropriate 
 * 
 * This function is called each time a checkpoint record is read from XLOG. 
 * It must determine whether the checkpoint represents a safe restartpoint or 
 * not.  If so, the checkpoint record is stashed in shared memory so that 
 * CreateRestartPoint can consult it.  (Note that the latter function is 
 * executed by the checkpointer, while this one will be executed by the 
 * startup process.) 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN9032"></a><span class='Declare_Function'>RecoveryRestartPoint</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../../include/catalog/pg_control.h.html#LN32"><span class='Ref_to_Struct'>CheckPoint</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>checkPoint</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * Also refrain from creating a restartpoint if we have seen any 
     * references to non-existent pages. Restarting recovery from the 
     * restartpoint would not see the references, so we would lose the 
     * cross-check that the pages belonged to a relation that was dropped 
     * later. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/xlogutils.h.html#LN17"><span class='Ref_to_Proto'>XLogHaveInvalidPages</span></a><span class='Parentheses'>())</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/miscadmin.h.html#LN287"><span class='Ref_to_Proto'>trace_recovery</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>             <span class='String'>"could not record restart point at %X/%X because there "</span> 
             <span class='String'>"are unresolved references to invalid pages"</span><span class='Delimiter'>, 
</span>             <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN9032"><span class='Ref_to_Parameter'>checkPoint</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN34"><span class='Ref_to_Member'>redo</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>             <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN9032"><span class='Ref_to_Parameter'>checkPoint</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN34"><span class='Ref_to_Member'>redo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Copy the checkpoint record to shared memory, so that checkpointer can 
     * work out the next time it wants to perform a restartpoint. 
     */ 
</span>    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN671"><span class='Ref_to_Member'>lastCheckPointRecPtr</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN817"><span class='Ref_to_Global_Var'>ReadRecPtr</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN672"><span class='Ref_to_Member'>lastCheckPointEndPtr</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN818"><span class='Ref_to_Global_Var'>EndRecPtr</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN673"><span class='Ref_to_Member'>lastCheckPoint</span></a> <span class='Operator'>= *</span><a href="xlog.c.html#LN9032"><span class='Ref_to_Parameter'>checkPoint</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end RecoveryRestartPoint &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Establish a restartpoint if possible. 
 * 
 * This is similar to CreateCheckPoint, but is used during WAL recovery 
 * to establish a point from which recovery can roll forward without 
 * replaying the entire recovery log. 
 * 
 * Returns true if a new restartpoint was established. We can only establish 
 * a restartpoint if we have replayed a safe checkpoint record since last 
 * restartpoint. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN9074"></a><span class='Declare_Function'>CreateRestartPoint</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>flags</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN9076"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>lastCheckPointRecPtr</span><span class='Delimiter'>; 
</span><a name="LN9077"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>lastCheckPointEndPtr</span><span class='Delimiter'>; 
</span><a name="LN9078"></a>    <a href="../../../include/catalog/pg_control.h.html#LN32"><span class='Ref_to_Struct'>CheckPoint</span></a>  <span class='Declare_Local'>lastCheckPoint</span><span class='Delimiter'>; 
</span><a name="LN9079"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>PriorRedoPtr</span><span class='Delimiter'>; 
</span><a name="LN9080"></a>    <a href="../../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <span class='Declare_Local'>xtime</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Acquire CheckpointLock to ensure only one restartpoint or checkpoint 
     * happens at a time. 
     */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>CheckpointLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Get a local copy of the last safe checkpoint record. */ 
</span>    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN9076"><span class='Ref_To_Local'>lastCheckPointRecPtr</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN671"><span class='Ref_to_Member'>lastCheckPointRecPtr</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN9077"><span class='Ref_To_Local'>lastCheckPointEndPtr</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN672"><span class='Ref_to_Member'>lastCheckPointEndPtr</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN9078"><span class='Ref_To_Local'>lastCheckPoint</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN673"><span class='Ref_to_Member'>lastCheckPoint</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Check that we're still in recovery mode. It's ok if we exit recovery 
     * mode after this check, the restart point is valid anyway. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/xlog.h.html#LN242"><span class='Ref_to_Proto'>RecoveryInProgress</span></a><span class='Parentheses'>())</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Delimiter'>, 
</span>              <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"skipping restartpoint, recovery has already ended"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>CheckpointLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the last checkpoint record we've replayed is already our last 
     * restartpoint, we can't perform a new restart point. We still update 
     * minRecoveryPoint in that case, so that if this is a shutdown restart 
     * point, we won't start up earlier than before. That's not strictly 
     * necessary, but when hot standby is enabled, it would be rather weird if 
     * the database opened up for read-only connections at a point-in-time 
     * before the last shutdown. Such time travel is still possible in case of 
     * immediate shutdown, though. 
     * 
     * We don't explicitly advance minRecoveryPoint when we do create a 
     * restartpoint. It's assumed that flushing the buffers will do that as a 
     * side-effect. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN28"><span class='Ref_to_Macro'>XLogRecPtrIsInvalid</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9076"><span class='Ref_To_Local'>lastCheckPointRecPtr</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>        <a href="xlog.c.html#LN9078"><span class='Ref_To_Local'>lastCheckPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN34"><span class='Ref_to_Member'>redo</span></a> <span class='Operator'>&LT;= </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN134"><span class='Ref_to_Member'>checkPointCopy</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN34"><span class='Ref_to_Member'>redo</span></a><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"skipping restartpoint, already performed at %X/%X"</span><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN9078"><span class='Ref_To_Local'>lastCheckPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN34"><span class='Ref_to_Member'>redo</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN9078"><span class='Ref_To_Local'>lastCheckPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN34"><span class='Ref_to_Member'>redo</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <a href="xlog.c.html#LN885"><span class='Ref_to_Proto'>UpdateMinRecoveryPoint</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN9074"><span class='Ref_to_Parameter'>flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/xlog.h.html#LN174"><span class='Ref_to_Const'>CHECKPOINT_IS_SHUTDOWN</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ControlFileLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN129"><span class='Ref_to_Member'>state</span></a> <span class='Operator'>= </span><a href="../../../include/catalog/pg_control.h.html#LN87"><span class='Ref_to_EnumConst'>DB_SHUTDOWNED_IN_RECOVERY</span></a><span class='Delimiter'>; 
</span>            <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN130"><span class='Ref_to_Member'>time</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/pgtime.h.html#LN22"><span class='Ref_to_Typedef'>pg_time_t</span></a><span class='Parentheses'>) </span>time<span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/access/xlog.h.html#LN256"><span class='Ref_to_Proto'>UpdateControlFile</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>            <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ControlFileLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>CheckpointLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if XLogRecPtrIsInvalid(l... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Update the shared RedoRecPtr so that the startup process can calculate 
     * the number of segments replayed since last restartpoint, and request a 
     * restartpoint if it exceeds CheckPointSegments. 
     * 
     * Like in CreateCheckPoint(), hold off insertions to update it, although 
     * during recovery this is just pro forma, because no WAL insertions are 
     * happening. 
     */ 
</span>    <a href="xlog.c.html#LN925"><span class='Ref_to_Proto'>WALInsertLockAcquireExclusive</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN349"><span class='Ref_to_Global_Var'>RedoRecPtr</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN574"><span class='Ref_to_Member'>Insert</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN547"><span class='Ref_to_Member'>RedoRecPtr</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN9078"><span class='Ref_To_Local'>lastCheckPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN34"><span class='Ref_to_Member'>redo</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN926"><span class='Ref_to_Proto'>WALInsertLockRelease</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Also update the info_lck-protected copy */ 
</span>    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN578"><span class='Ref_to_Member'>RedoRecPtr</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN9078"><span class='Ref_To_Local'>lastCheckPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN34"><span class='Ref_to_Member'>redo</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Prepare to accumulate statistics. 
     * 
     * Note: because it is possible for log_checkpoints to change while a 
     * checkpoint proceeds, we always accumulate stats, even if 
     * log_checkpoints is currently off. 
     */ 
</span>    <a href="../../../include/c.h.html#LN856"><span class='Ref_to_Macro'>MemSet</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN172"><span class='Ref_to_Global_Var'>CheckpointStats</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN172"><span class='Ref_to_Global_Var'>CheckpointStats</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN172"><span class='Ref_to_Global_Var'>CheckpointStats</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog.h.html#LN198"><span class='Ref_to_Member'>ckpt_start_t</span></a> <span class='Operator'>= </span><a href="../../../include/utils/timestamp.h.html#LN69"><span class='Ref_to_Proto'>GetCurrentTimestamp</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN101"><span class='Ref_to_Global_Var'>log_checkpoints</span></a><span class='Parentheses'>) 
</span>        <a href="xlog.c.html#LN8361"><span class='Ref_to_Func'>LogCheckpointStart</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9074"><span class='Ref_to_Parameter'>flags</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="xlog.c.html#LN859"><span class='Ref_to_Proto'>CheckPointGuts</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9078"><span class='Ref_To_Local'>lastCheckPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN34"><span class='Ref_to_Member'>redo</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN9074"><span class='Ref_to_Parameter'>flags</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Remember the prior checkpoint's redo pointer, used later to determine 
     * the point at which we can truncate the log. 
     */ 
</span>    <a href="xlog.c.html#LN9079"><span class='Ref_To_Local'>PriorRedoPtr</span></a> <span class='Operator'>= </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN134"><span class='Ref_to_Member'>checkPointCopy</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN34"><span class='Ref_to_Member'>redo</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Update pg_control, using current time.  Check that it still shows 
     * IN_ARCHIVE_RECOVERY state and an older checkpoint, else do nothing; 
     * this is a quick hack to make sure nothing really bad happens if somehow 
     * we get here after the end-of-recovery checkpoint. 
     */ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ControlFileLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN129"><span class='Ref_to_Member'>state</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_control.h.html#LN90"><span class='Ref_to_EnumConst'>DB_IN_ARCHIVE_RECOVERY</span></a> <span class='Operator'>&& 
</span>        <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN134"><span class='Ref_to_Member'>checkPointCopy</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN34"><span class='Ref_to_Member'>redo</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN9078"><span class='Ref_To_Local'>lastCheckPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN34"><span class='Ref_to_Member'>redo</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN132"><span class='Ref_to_Member'>prevCheckPoint</span></a> <span class='Operator'>= </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN131"><span class='Ref_to_Member'>checkPoint</span></a><span class='Delimiter'>; 
</span>        <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN131"><span class='Ref_to_Member'>checkPoint</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN9076"><span class='Ref_To_Local'>lastCheckPointRecPtr</span></a><span class='Delimiter'>; 
</span>        <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN134"><span class='Ref_to_Member'>checkPointCopy</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN9078"><span class='Ref_To_Local'>lastCheckPoint</span></a><span class='Delimiter'>; 
</span>        <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN130"><span class='Ref_to_Member'>time</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/pgtime.h.html#LN22"><span class='Ref_to_Typedef'>pg_time_t</span></a><span class='Parentheses'>) </span>time<span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Ensure minRecoveryPoint is past the checkpoint record.  Normally, 
         * this will have happened already while writing out dirty buffers, 
         * but not necessarily - e.g. because no buffers were dirtied.  We do 
         * this because a non-exclusive base backup uses minRecoveryPoint to 
         * determine which WAL files must be included in the backup, and the 
         * file (or files) containing the checkpoint record must be included, 
         * at a minimum. Note that for an ordinary restart of recovery there's 
         * no value in having the minimum recovery point any earlier than this 
         * anyway, because redo will begin just after the checkpoint record. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN169"><span class='Ref_to_Member'>minRecoveryPoint</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN9077"><span class='Ref_To_Local'>lastCheckPointEndPtr</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN169"><span class='Ref_to_Member'>minRecoveryPoint</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN9077"><span class='Ref_To_Local'>lastCheckPointEndPtr</span></a><span class='Delimiter'>; 
</span>            <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN170"><span class='Ref_to_Member'>minRecoveryPointTLI</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN9078"><span class='Ref_To_Local'>lastCheckPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN36"><span class='Ref_to_Member'>ThisTimeLineID</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* update local copy */ 
</span>            <a href="xlog.c.html#LN820"><span class='Ref_to_Global_Var'>minRecoveryPoint</span></a> <span class='Operator'>= </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN169"><span class='Ref_to_Member'>minRecoveryPoint</span></a><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN822"><span class='Ref_to_Global_Var'>minRecoveryPointTLI</span></a> <span class='Operator'>= </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN170"><span class='Ref_to_Member'>minRecoveryPointTLI</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN9074"><span class='Ref_to_Parameter'>flags</span></a> <span class='Operator'>& </span><a href="../../../include/access/xlog.h.html#LN174"><span class='Ref_to_Const'>CHECKPOINT_IS_SHUTDOWN</span></a><span class='Parentheses'>) 
</span>            <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN129"><span class='Ref_to_Member'>state</span></a> <span class='Operator'>= </span><a href="../../../include/catalog/pg_control.h.html#LN87"><span class='Ref_to_EnumConst'>DB_SHUTDOWNED_IN_RECOVERY</span></a><span class='Delimiter'>; 
</span>        <a href="../../../include/access/xlog.h.html#LN256"><span class='Ref_to_Proto'>UpdateControlFile</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if ControlFile-&GT;state==D... &raquo; </span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ControlFileLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Delete old log files (those no longer needed even for previous 
     * checkpoint/restartpoint) to prevent the disk holding the xlog from 
     * growing full. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN9079"><span class='Ref_To_Local'>PriorRedoPtr</span></a> <span class='Operator'>!= </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN9229"></a>        <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>receivePtr</span><span class='Delimiter'>; 
</span><a name="LN9230"></a>        <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>replayPtr</span><span class='Delimiter'>; 
</span><a name="LN9231"></a>        <a href="../../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a>  <span class='Declare_Local'>replayTLI</span><span class='Delimiter'>; 
</span><a name="LN9232"></a>        <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>endptr</span><span class='Delimiter'>; 
</span><a name="LN9233"></a>        <a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a>   <span class='Declare_Local'>_logSegNo</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Update the average distance between checkpoints/restartpoints. */ 
</span>        <a href="xlog.c.html#LN8464"><span class='Ref_to_Func'>UpdateCheckPointDistanceEstimate</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN349"><span class='Ref_to_Global_Var'>RedoRecPtr</span></a> <span class='Operator'>- </span><a href="xlog.c.html#LN9079"><span class='Ref_To_Local'>PriorRedoPtr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/access/xlog_internal.h.html#LN105"><span class='Ref_to_Macro'>XLByteToSeg</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9079"><span class='Ref_To_Local'>PriorRedoPtr</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN9233"><span class='Ref_To_Local'>_logSegNo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Get the current end of xlog replayed or received, whichever is 
         * later. 
         */ 
</span>        <a href="xlog.c.html#LN9229"><span class='Ref_To_Local'>receivePtr</span></a> <span class='Operator'>= </span><a href="../../replication/walreceiverfuncs.c.html#LN292"><span class='Ref_to_Func'>GetWalRcvWriteRecPtr</span></a><span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN9230"><span class='Ref_To_Local'>replayPtr</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlog.h.html#LN247"><span class='Ref_to_Proto'>GetXLogReplayRecPtr</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN9231"><span class='Ref_To_Local'>replayTLI</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN9232"><span class='Ref_To_Local'>endptr</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="xlog.c.html#LN9229"><span class='Ref_To_Local'>receivePtr</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN9230"><span class='Ref_To_Local'>replayPtr</span></a><span class='Parentheses'>) </span><span class='Operator'>? </span><a href="xlog.c.html#LN9230"><span class='Ref_To_Local'>replayPtr</span></a> <span class='Operator'>: </span><a href="xlog.c.html#LN9229"><span class='Ref_To_Local'>receivePtr</span></a><span class='Delimiter'>; 
</span> 
        <a href="xlog.c.html#LN860"><span class='Ref_to_Proto'>KeepLogSeg</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9232"><span class='Ref_To_Local'>endptr</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN9233"><span class='Ref_To_Local'>_logSegNo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN9233"><span class='Ref_To_Local'>_logSegNo</span></a><span class='Operator'>--</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Try to recycle segments on a useful timeline. If we've been 
         * promoted since the beginning of this restartpoint, use the new 
         * timeline chosen at end of recovery (RecoveryInProgress() sets 
         * ThisTimeLineID in that case). If we're still in recovery, use the 
         * timeline we're currently replaying. 
         * 
         * There is no guarantee that the WAL segments will be useful on the 
         * current timeline; if recovery proceeds to a new timeline right 
         * after this, the pre-allocated WAL segments on this timeline will 
         * not be used, and will go wasted until recycled on the next 
         * restartpoint. We'll live with that. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN242"><span class='Ref_to_Proto'>RecoveryInProgress</span></a><span class='Parentheses'>())</span> 
            <a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN9231"><span class='Ref_To_Local'>replayTLI</span></a><span class='Delimiter'>; 
</span> 
        <a href="xlog.c.html#LN880"><span class='Ref_to_Proto'>RemoveOldXlogFiles</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9233"><span class='Ref_To_Local'>_logSegNo</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN9079"><span class='Ref_To_Local'>PriorRedoPtr</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN9232"><span class='Ref_To_Local'>endptr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Make more log segments if needed.  (Do this after recycling old log 
         * segments, since that may supply some of the needed files.) 
         */ 
</span>        <a href="xlog.c.html#LN879"><span class='Ref_to_Proto'>PreallocXlogFiles</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9232"><span class='Ref_To_Local'>endptr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * ThisTimeLineID is normally not set when we're still in recovery. 
         * However, recycling/preallocating segments above needed 
         * ThisTimeLineID to determine which timeline to install the segments 
         * on. Reset it now, to restore the normal state of affairs for 
         * debugging purposes. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN242"><span class='Ref_to_Proto'>RecoveryInProgress</span></a><span class='Parentheses'>())</span> 
            <a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if PriorRedoPtr!=Invalid... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Truncate pg_subtrans if possible.  We can throw away all data before 
     * the oldest XMIN of any running transaction.  No future transaction will 
     * attempt to reference any pg_subtrans entry older than that (see Asserts 
     * in subtrans.c).  When hot standby is disabled, though, we mustn't do 
     * this because StartupSUBTRANS hasn't been called yet. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN95"><span class='Ref_to_Global_Var'>EnableHotStandby</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/access/subtrans.h.html#LN27"><span class='Ref_to_Proto'>TruncateSUBTRANS</span></a><span class='Parentheses'>(</span><a href="../../../include/storage/procarray.h.html#LN91"><span class='Ref_to_Proto'>GetOldestXmin</span></a><span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><a href="../../../include/storage/procarray.h.html#LN50"><span class='Ref_to_Const'>PROCARRAY_FLAGS_DEFAULT</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Real work is done, but log and update before releasing lock. */ 
</span>    <a href="xlog.c.html#LN8379"><span class='Ref_to_Func'>LogCheckpointEnd</span></a><span class='Parentheses'>(</span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="xlog.c.html#LN9080"><span class='Ref_To_Local'>xtime</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlog.h.html#LN252"><span class='Ref_to_Proto'>GetLatestXTime</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>((</span><a href="xlog.c.html#LN101"><span class='Ref_to_Global_Var'>log_checkpoints</span></a> <span class='Operator'>? </span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a> <span class='Operator'>: </span><a href="../../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>            <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"recovery restart point at %X/%X"</span><span class='Delimiter'>, 
</span>         <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN9078"><span class='Ref_To_Local'>lastCheckPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN34"><span class='Ref_to_Member'>redo</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN9078"><span class='Ref_To_Local'>lastCheckPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN34"><span class='Ref_to_Member'>redo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>           <a href="xlog.c.html#LN9080"><span class='Ref_To_Local'>xtime</span></a> <span class='Operator'>? </span><a href="../../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"last completed transaction was at log time %s"</span><span class='Delimiter'>, 
</span>                             <a href="../../../bin/pg_waldump/compat.c.html#LN48"><span class='Ref_to_Func'>timestamptz_to_str</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9080"><span class='Ref_To_Local'>xtime</span></a><span class='Parentheses'>))</span> <span class='Operator'>: </span><span class='Number'>0</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>CheckpointLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Finally, execute archive_cleanup_command, if any. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN635"><span class='Ref_to_Member'>archiveCleanupCommand</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>        <a href="../../../include/access/xlog_internal.h.html#LN309"><span class='Ref_to_Proto'>ExecuteRecoveryCommand</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN635"><span class='Ref_to_Member'>archiveCleanupCommand</span></a><span class='Delimiter'>, 
</span>                               <span class='String'>"archive_cleanup_command"</span><span class='Delimiter'>, 
</span>                               <span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end CreateRestartPoint &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Retreat *logSegNo to the last segment that we need to retain because of 
 * either wal_keep_segments or replication slots. 
 * 
 * This is calculated by subtracting wal_keep_segments from the given xlog 
 * location, recptr and by making sure that that result is below the 
 * requirement of replication slots. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN9328"></a><span class='Declare_Function'>KeepLogSeg</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>recptr</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>logSegNo</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN9330"></a>    <a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a>   <span class='Declare_Local'>segno</span><span class='Delimiter'>; 
</span><a name="LN9331"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>keep</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/access/xlog_internal.h.html#LN105"><span class='Ref_to_Macro'>XLByteToSeg</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9328"><span class='Ref_to_Parameter'>recptr</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN9330"><span class='Ref_To_Local'>segno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN9331"><span class='Ref_To_Local'>keep</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN861"><span class='Ref_to_Proto'>XLogGetReplicationSlotMinimumLSN</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* compute limit for wal_keep_segments first */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN90"><span class='Ref_to_Global_Var'>wal_keep_segments</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* avoid underflow, don't go below 1 */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN9330"><span class='Ref_To_Local'>segno</span></a> <span class='Operator'>&LT;= </span><a href="xlog.c.html#LN90"><span class='Ref_to_Global_Var'>wal_keep_segments</span></a><span class='Parentheses'>) 
</span>            <a href="xlog.c.html#LN9330"><span class='Ref_To_Local'>segno</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="xlog.c.html#LN9330"><span class='Ref_To_Local'>segno</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN9330"><span class='Ref_To_Local'>segno</span></a> <span class='Operator'>- </span><a href="xlog.c.html#LN90"><span class='Ref_to_Global_Var'>wal_keep_segments</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* then check whether slots limit removal further */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../replication/slot.c.html#LN98"><span class='Ref_to_Global_Var'>max_replication_slots</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="xlog.c.html#LN9331"><span class='Ref_To_Local'>keep</span></a> <span class='Operator'>!= </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN9349"></a>        <a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a>   <span class='Declare_Local'>slotSegNo</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/access/xlog_internal.h.html#LN105"><span class='Ref_to_Macro'>XLByteToSeg</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9331"><span class='Ref_To_Local'>keep</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN9349"><span class='Ref_To_Local'>slotSegNo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN9349"><span class='Ref_To_Local'>slotSegNo</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <a href="xlog.c.html#LN9330"><span class='Ref_To_Local'>segno</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN9349"><span class='Ref_To_Local'>slotSegNo</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN9330"><span class='Ref_To_Local'>segno</span></a><span class='Parentheses'>) 
</span>            <a href="xlog.c.html#LN9330"><span class='Ref_To_Local'>segno</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN9349"><span class='Ref_To_Local'>slotSegNo</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* don't delete WAL segments newer than the calculated segment */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN9330"><span class='Ref_To_Local'>segno</span></a> <span class='Operator'>&LT; *</span><a href="xlog.c.html#LN9328"><span class='Ref_to_Parameter'>logSegNo</span></a><span class='Parentheses'>) 
</span>        <span class='Operator'>*</span><a href="xlog.c.html#LN9328"><span class='Ref_to_Parameter'>logSegNo</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN9330"><span class='Ref_To_Local'>segno</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end KeepLogSeg &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Write a NEXTOID log record 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN9368"></a><span class='Declare_Function'>XLogPutNextOid</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>nextOid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/access/xloginsert.h.html#LN41"><span class='Ref_to_Proto'>XLogBeginInsert</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="../../../include/access/xloginsert.h.html#LN45"><span class='Ref_to_Proto'>XLogRegisterData</span></a><span class='Parentheses'>((</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) (</span><span class='Operator'>&</span><a href="xlog.c.html#LN9368"><span class='Ref_to_Parameter'>nextOid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="../../../include/access/xloginsert.h.html#LN43"><span class='Ref_to_Proto'>XLogInsert</span></a><span class='Parentheses'>(</span>RM_XLOG_ID<span class='Delimiter'>, </span><a href="../../../include/catalog/pg_control.h.html#LN68"><span class='Ref_to_Const'>XLOG_NEXTOID</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We need not flush the NEXTOID record immediately, because any of the 
     * just-allocated OIDs could only reach disk as part of a tuple insert or 
     * update that would have its own XLOG record that must follow the NEXTOID 
     * record.  Therefore, the standard buffer LSN interlock applied to those 
     * records will ensure no such OID reaches disk before the NEXTOID record 
     * does. 
     * 
     * Note, however, that the above statement only covers state "within" the 
     * database.  When we use a generated OID as a file or directory name, we 
     * are in a sense violating the basic WAL rule, because that filesystem 
     * change may reach disk before the NEXTOID WAL record does.  The impact 
     * of this is that if a database crash occurs immediately afterward, we 
     * might after restart re-generate the same OID and find that it conflicts 
     * with the leftover file or directory.  But since for safety's sake we 
     * always loop until finding a nonconflicting filename, this poses no real 
     * problem in practice. See pgsql-hackers discussion 27-Sep-2006. 
     */ 
</span><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end XLogPutNextOid &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Write an XLOG SWITCH record. 
 * 
 * Here we just blindly issue an XLogInsert request for the record. 
 * All the magic happens inside XLogInsert. 
 * 
 * The return value is either the end+1 address of the switch record, 
 * or the end+1 address of the prior segment if we did not need to 
 * write a switch record because we are already at segment start. 
 */ 
</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> 
<a name="LN9405"></a><span class='Declare_Function'>RequestXLogSwitch</span><span class='Parentheses'>(</span><span class='Keyword'>bool </span><span class='Declare_Parameter'>mark_unimportant</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN9407"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>RecPtr</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* XLOG SWITCH has no data */ 
</span>    <a href="../../../include/access/xloginsert.h.html#LN41"><span class='Ref_to_Proto'>XLogBeginInsert</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN9405"><span class='Ref_to_Parameter'>mark_unimportant</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/access/xloginsert.h.html#LN42"><span class='Ref_to_Proto'>XLogSetRecordFlags</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN192"><span class='Ref_to_Const'>XLOG_MARK_UNIMPORTANT</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN9407"><span class='Ref_To_Local'>RecPtr</span></a> <span class='Operator'>= </span><a href="../../../include/access/xloginsert.h.html#LN43"><span class='Ref_to_Proto'>XLogInsert</span></a><span class='Parentheses'>(</span>RM_XLOG_ID<span class='Delimiter'>, </span><a href="../../../include/catalog/pg_control.h.html#LN69"><span class='Ref_to_Const'>XLOG_SWITCH</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="xlog.c.html#LN9407"><span class='Ref_To_Local'>RecPtr</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Write a RESTORE POINT record 
 */ 
</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> 
<a name="LN9423"></a><span class='Declare_Function'>XLogRestorePoint</span><span class='Parentheses'>(</span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>rpName</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN9425"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>RecPtr</span><span class='Delimiter'>; 
</span><a name="LN9426"></a>    <a href="../../../include/access/xlog_internal.h.html#LN222"><span class='Ref_to_Struct'>xl_restore_point</span></a> <span class='Declare_Local'>xlrec</span><span class='Delimiter'>; 
</span> 
    <a href="xlog.c.html#LN9426"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog_internal.h.html#LN224"><span class='Ref_to_Member'>rp_time</span></a> <span class='Operator'>= </span><a href="../../../include/utils/timestamp.h.html#LN69"><span class='Ref_to_Proto'>GetCurrentTimestamp</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="../../../port/strlcpy.c.html#LN43"><span class='Ref_to_Func'>strlcpy</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9426"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog_internal.h.html#LN225"><span class='Ref_to_Member'>rp_name</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN9423"><span class='Ref_to_Parameter'>rpName</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xlog_internal.h.html#LN137"><span class='Ref_to_Const'>MAXFNAMELEN</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/access/xloginsert.h.html#LN41"><span class='Ref_to_Proto'>XLogBeginInsert</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="../../../include/access/xloginsert.h.html#LN45"><span class='Ref_to_Proto'>XLogRegisterData</span></a><span class='Parentheses'>((</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><a href="xlog.c.html#LN9426"><span class='Ref_To_Local'>xlrec</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/access/xlog_internal.h.html#LN222"><span class='Ref_to_Struct'>xl_restore_point</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="xlog.c.html#LN9425"><span class='Ref_To_Local'>RecPtr</span></a> <span class='Operator'>= </span><a href="../../../include/access/xloginsert.h.html#LN43"><span class='Ref_to_Proto'>XLogInsert</span></a><span class='Parentheses'>(</span>RM_XLOG_ID<span class='Delimiter'>, </span><a href="../../../include/catalog/pg_control.h.html#LN72"><span class='Ref_to_Const'>XLOG_RESTORE_POINT</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>            <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"restore point \"%s\" created at %X/%X"</span><span class='Delimiter'>, 
</span>                    <a href="xlog.c.html#LN9423"><span class='Ref_to_Parameter'>rpName</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN9425"><span class='Ref_To_Local'>RecPtr</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN9425"><span class='Ref_To_Local'>RecPtr</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="xlog.c.html#LN9425"><span class='Ref_To_Local'>RecPtr</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end XLogRestorePoint &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Check if any of the GUC parameters that are critical for hot standby 
 * have changed, and update the value in pg_control file if necessary. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN9448"></a><span class='Declare_Function'>XLogReportParameters</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN103"><span class='Ref_to_Global_Var'>wal_level</span></a> <span class='Operator'>!= </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN179"><span class='Ref_to_Member'>wal_level</span></a> <span class='Operator'>|| 
</span>        <a href="xlog.c.html#LN97"><span class='Ref_to_Global_Var'>wal_log_hints</span></a> <span class='Operator'>!= </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN180"><span class='Ref_to_Member'>wal_log_hints</span></a> <span class='Operator'>|| 
</span>        <a href="../../utils/init/globals.c.html#LN123"><span class='Ref_to_Global_Var'>MaxConnections</span></a> <span class='Operator'>!= </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN181"><span class='Ref_to_Member'>MaxConnections</span></a> <span class='Operator'>|| 
</span>        <a href="../../utils/init/globals.c.html#LN124"><span class='Ref_to_Global_Var'>max_worker_processes</span></a> <span class='Operator'>!= </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN182"><span class='Ref_to_Member'>max_worker_processes</span></a> <span class='Operator'>|| 
</span>        <a href="twophase.c.html#LN116"><span class='Ref_to_Global_Var'>max_prepared_xacts</span></a> <span class='Operator'>!= </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN183"><span class='Ref_to_Member'>max_prepared_xacts</span></a> <span class='Operator'>|| 
</span>        <a href="../../storage/lmgr/lock.c.html#LN53"><span class='Ref_to_Global_Var'>max_locks_per_xact</span></a> <span class='Operator'>!= </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN184"><span class='Ref_to_Member'>max_locks_per_xact</span></a> <span class='Operator'>|| 
</span>        <a href="commit_ts.c.html#LN102"><span class='Ref_to_Global_Var'>track_commit_timestamp</span></a> <span class='Operator'>!= </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN185"><span class='Ref_to_Member'>track_commit_timestamp</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * The change in number of backend slots doesn't need to be WAL-logged 
         * if archiving is not enabled, as you can't start archive recovery 
         * with wal_level=minimal anyway. We don't really care about the 
         * values in pg_control either if wal_level=minimal, but seems better 
         * to keep them up-to-date to avoid confusion. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN103"><span class='Ref_to_Global_Var'>wal_level</span></a> <span class='Operator'>!= </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN179"><span class='Ref_to_Member'>wal_level</span></a> <span class='Operator'>|| </span><a href="../../../include/access/xlog.h.html#LN144"><span class='Ref_to_Macro'>XLogIsNeeded</span></a><span class='Parentheses'>())</span> 
        <span class='Delimiter'>{ 
</span><a name="LN9467"></a>            <a href="../../../include/access/xlog_internal.h.html#LN210"><span class='Ref_to_Struct'>xl_parameter_change</span></a> <span class='Declare_Local'>xlrec</span><span class='Delimiter'>; 
</span><a name="LN9468"></a>            <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>recptr</span><span class='Delimiter'>; 
</span> 
            <a href="xlog.c.html#LN9467"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog_internal.h.html#LN212"><span class='Ref_to_Member'>MaxConnections</span></a> <span class='Operator'>= </span><a href="../../utils/init/globals.c.html#LN123"><span class='Ref_to_Global_Var'>MaxConnections</span></a><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN9467"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog_internal.h.html#LN213"><span class='Ref_to_Member'>max_worker_processes</span></a> <span class='Operator'>= </span><a href="../../utils/init/globals.c.html#LN124"><span class='Ref_to_Global_Var'>max_worker_processes</span></a><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN9467"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog_internal.h.html#LN214"><span class='Ref_to_Member'>max_prepared_xacts</span></a> <span class='Operator'>= </span><a href="twophase.c.html#LN116"><span class='Ref_to_Global_Var'>max_prepared_xacts</span></a><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN9467"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog_internal.h.html#LN215"><span class='Ref_to_Member'>max_locks_per_xact</span></a> <span class='Operator'>= </span><a href="../../storage/lmgr/lock.c.html#LN53"><span class='Ref_to_Global_Var'>max_locks_per_xact</span></a><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN9467"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog_internal.h.html#LN216"><span class='Ref_to_Member'>wal_level</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN103"><span class='Ref_to_Global_Var'>wal_level</span></a><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN9467"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog_internal.h.html#LN217"><span class='Ref_to_Member'>wal_log_hints</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN97"><span class='Ref_to_Global_Var'>wal_log_hints</span></a><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN9467"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog_internal.h.html#LN218"><span class='Ref_to_Member'>track_commit_timestamp</span></a> <span class='Operator'>= </span><a href="commit_ts.c.html#LN102"><span class='Ref_to_Global_Var'>track_commit_timestamp</span></a><span class='Delimiter'>; 
</span> 
            <a href="../../../include/access/xloginsert.h.html#LN41"><span class='Ref_to_Proto'>XLogBeginInsert</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>            <a href="../../../include/access/xloginsert.h.html#LN45"><span class='Ref_to_Proto'>XLogRegisterData</span></a><span class='Parentheses'>((</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><a href="xlog.c.html#LN9467"><span class='Ref_To_Local'>xlrec</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN9467"><span class='Ref_To_Local'>xlrec</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
            <a href="xlog.c.html#LN9468"><span class='Ref_To_Local'>recptr</span></a> <span class='Operator'>= </span><a href="../../../include/access/xloginsert.h.html#LN43"><span class='Ref_to_Proto'>XLogInsert</span></a><span class='Parentheses'>(</span>RM_XLOG_ID<span class='Delimiter'>, </span><a href="../../../include/catalog/pg_control.h.html#LN71"><span class='Ref_to_Const'>XLOG_PARAMETER_CHANGE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/access/xlog.h.html#LN225"><span class='Ref_to_Proto'>XLogFlush</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9468"><span class='Ref_To_Local'>recptr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN181"><span class='Ref_to_Member'>MaxConnections</span></a> <span class='Operator'>= </span><a href="../../utils/init/globals.c.html#LN123"><span class='Ref_to_Global_Var'>MaxConnections</span></a><span class='Delimiter'>; 
</span>        <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN182"><span class='Ref_to_Member'>max_worker_processes</span></a> <span class='Operator'>= </span><a href="../../utils/init/globals.c.html#LN124"><span class='Ref_to_Global_Var'>max_worker_processes</span></a><span class='Delimiter'>; 
</span>        <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN183"><span class='Ref_to_Member'>max_prepared_xacts</span></a> <span class='Operator'>= </span><a href="twophase.c.html#LN116"><span class='Ref_to_Global_Var'>max_prepared_xacts</span></a><span class='Delimiter'>; 
</span>        <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN184"><span class='Ref_to_Member'>max_locks_per_xact</span></a> <span class='Operator'>= </span><a href="../../storage/lmgr/lock.c.html#LN53"><span class='Ref_to_Global_Var'>max_locks_per_xact</span></a><span class='Delimiter'>; 
</span>        <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN179"><span class='Ref_to_Member'>wal_level</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN103"><span class='Ref_to_Global_Var'>wal_level</span></a><span class='Delimiter'>; 
</span>        <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN180"><span class='Ref_to_Member'>wal_log_hints</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN97"><span class='Ref_to_Global_Var'>wal_log_hints</span></a><span class='Delimiter'>; 
</span>        <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN185"><span class='Ref_to_Member'>track_commit_timestamp</span></a> <span class='Operator'>= </span><a href="commit_ts.c.html#LN102"><span class='Ref_to_Global_Var'>track_commit_timestamp</span></a><span class='Delimiter'>; 
</span>        <a href="../../../include/access/xlog.h.html#LN256"><span class='Ref_to_Proto'>UpdateControlFile</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if wal_level!=ControlFil... &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end XLogReportParameters &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Update full_page_writes in shared memory, and write an 
 * XLOG_FPW_CHANGE record if necessary. 
 * 
 * Note: this function assumes there is no other process running 
 * concurrently that could update it. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN9504"></a><span class='Declare_Function'>UpdateFullPageWrites</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN9506"></a>    <a href="xlog.c.html#LN514"><span class='Ref_to_Struct'>XLogCtlInsert</span></a> <span class='Operator'>*</span><span class='Declare_Local'>Insert</span> <span class='Operator'>= &</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN574"><span class='Ref_to_Member'>Insert</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Do nothing if full_page_writes has not been changed. 
     * 
     * It's safe to check the shared full_page_writes without the lock, 
     * because we assume that there is no concurrently running process which 
     * can update it. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN96"><span class='Ref_to_Global_Var'>fullPageWrites</span></a> <span class='Operator'>== </span><a href="xlog.c.html#LN9506"><span class='Ref_To_Local'>Insert</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN549"><span class='Ref_to_Member'>fullPageWrites</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/miscadmin.h.html#LN132"><span class='Ref_to_Macro'>START_CRIT_SECTION</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * It's always safe to take full page images, even when not strictly 
     * required, but not the other round. So if we're setting full_page_writes 
     * to true, first set it true and then write the WAL record. If we're 
     * setting it to false, first write the WAL record and then set the global 
     * flag. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN96"><span class='Ref_to_Global_Var'>fullPageWrites</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="xlog.c.html#LN925"><span class='Ref_to_Proto'>WALInsertLockAcquireExclusive</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN9506"><span class='Ref_To_Local'>Insert</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN549"><span class='Ref_to_Member'>fullPageWrites</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN926"><span class='Ref_to_Proto'>WALInsertLockRelease</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Write an XLOG_FPW_CHANGE record. This allows us to keep track of 
     * full_page_writes during archive recovery, if required. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN158"><span class='Ref_to_Macro'>XLogStandbyInfoActive</span></a><span class='Parentheses'>() </span><span class='Operator'>&& !</span><a href="../../../include/access/xlog.h.html#LN242"><span class='Ref_to_Proto'>RecoveryInProgress</span></a><span class='Parentheses'>())</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../include/access/xloginsert.h.html#LN41"><span class='Ref_to_Proto'>XLogBeginInsert</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <a href="../../../include/access/xloginsert.h.html#LN45"><span class='Ref_to_Proto'>XLogRegisterData</span></a><span class='Parentheses'>((</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) (</span><span class='Operator'>&</span><a href="xlog.c.html#LN96"><span class='Ref_to_Global_Var'>fullPageWrites</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>bool</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/access/xloginsert.h.html#LN43"><span class='Ref_to_Proto'>XLogInsert</span></a><span class='Parentheses'>(</span>RM_XLOG_ID<span class='Delimiter'>, </span><a href="../../../include/catalog/pg_control.h.html#LN73"><span class='Ref_to_Const'>XLOG_FPW_CHANGE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN96"><span class='Ref_to_Global_Var'>fullPageWrites</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="xlog.c.html#LN925"><span class='Ref_to_Proto'>WALInsertLockAcquireExclusive</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN9506"><span class='Ref_To_Local'>Insert</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN549"><span class='Ref_to_Member'>fullPageWrites</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN926"><span class='Ref_to_Proto'>WALInsertLockRelease</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="../../../include/miscadmin.h.html#LN134"><span class='Ref_to_Macro'>END_CRIT_SECTION</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end UpdateFullPageWrites &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Check that it's OK to switch to new timeline during recovery. 
 * 
 * 'lsn' is the address of the shutdown checkpoint record we're about to 
 * replay. (Currently, timeline can only change at a shutdown checkpoint). 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN9562"></a><span class='Declare_Function'>checkTimeLineSwitch</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>lsn</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a> <span class='Declare_Parameter'>newTLI</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a> <span class='Declare_Parameter'>prevTLI</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* Check that the record agrees on what the current (old) timeline is */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN9562"><span class='Ref_to_Parameter'>prevTLI</span></a> <span class='Operator'>!= </span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"unexpected previous timeline ID %u (current timeline ID %u) in checkpoint record"</span><span class='Delimiter'>, 
</span>                        <a href="xlog.c.html#LN9562"><span class='Ref_to_Parameter'>prevTLI</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * The new timeline better be in the list of timelines we expect to see, 
     * according to the timeline history. It should also not decrease. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN9562"><span class='Ref_to_Parameter'>newTLI</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a> <span class='Operator'>|| !</span><a href="../../../include/access/timeline.h.html#LN38"><span class='Ref_to_Proto'>tliInHistory</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9562"><span class='Ref_to_Parameter'>newTLI</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN317"><span class='Ref_to_Global_Var'>expectedTLEs</span></a><span class='Parentheses'>))</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>         <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"unexpected timeline ID %u (after %u) in checkpoint record"</span><span class='Delimiter'>, 
</span>                 <a href="xlog.c.html#LN9562"><span class='Ref_to_Parameter'>newTLI</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we have not yet reached min recovery point, and we're about to 
     * switch to a timeline greater than the timeline of the min recovery 
     * point: trouble. After switching to the new timeline, we could not 
     * possibly visit the min recovery point on the correct timeline anymore. 
     * This can happen if there is a newer timeline in the archive that 
     * branched before the timeline the min recovery point is on, and you 
     * attempt to do PITR to the new timeline. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/xlogdefs.h.html#LN28"><span class='Ref_to_Macro'>XLogRecPtrIsInvalid</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN820"><span class='Ref_to_Global_Var'>minRecoveryPoint</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>        <a href="xlog.c.html#LN9562"><span class='Ref_to_Parameter'>lsn</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN820"><span class='Ref_to_Global_Var'>minRecoveryPoint</span></a> <span class='Operator'>&& 
</span>        <a href="xlog.c.html#LN9562"><span class='Ref_to_Parameter'>newTLI</span></a> <span class='Operator'>&GT; </span><a href="xlog.c.html#LN822"><span class='Ref_to_Global_Var'>minRecoveryPointTLI</span></a><span class='Parentheses'>)</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"unexpected timeline ID %u in checkpoint record, before reaching minimum recovery point %X/%X on timeline %u"</span><span class='Delimiter'>, 
</span>                        <a href="xlog.c.html#LN9562"><span class='Ref_to_Parameter'>newTLI</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN820"><span class='Ref_to_Global_Var'>minRecoveryPoint</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN820"><span class='Ref_to_Global_Var'>minRecoveryPoint</span></a><span class='Delimiter'>, 
</span>                        <a href="xlog.c.html#LN822"><span class='Ref_to_Global_Var'>minRecoveryPointTLI</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Looks good */ 
</span><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end checkTimeLineSwitch &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * XLOG resource manager's routines 
 * 
 * Definitions of info values are in include/catalog/pg_control.h, though 
 * not all record types are related to control file updates. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN9608"></a><span class='Declare_Function'>xlog_redo</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogreader.h.html#LN68"><span class='Ref_to_Struct'>XLogReaderState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>record</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN9610"></a>    <a href="../../../include/c.h.html#LN265"><span class='Ref_to_Typedef'>uint8</span></a>       <span class='Declare_Local'>info</span> <span class='Operator'>= </span><a href="../../../include/access/xlogreader.h.html#LN215"><span class='Ref_to_Macro'>XLogRecGetInfo</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9608"><span class='Ref_to_Parameter'>record</span></a><span class='Parentheses'>) </span><span class='Operator'>& ~</span><a href="../../../include/access/xlogrecord.h.html#LN61"><span class='Ref_to_Const'>XLR_INFO_MASK</span></a><span class='Delimiter'>; 
</span><a name="LN9611"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>lsn</span> <span class='Operator'>= </span><a href="xlog.c.html#LN9608"><span class='Ref_to_Parameter'>record</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogreader.h.html#LN114"><span class='Ref_to_Member'>EndRecPtr</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* in XLOG rmgr, backup blocks are only used by XLOG_FPI records */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN9610"><span class='Ref_To_Local'>info</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_control.h.html#LN76"><span class='Ref_to_Const'>XLOG_FPI</span></a> <span class='Operator'>|| </span><a href="xlog.c.html#LN9610"><span class='Ref_To_Local'>info</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_control.h.html#LN75"><span class='Ref_to_Const'>XLOG_FPI_FOR_HINT</span></a> <span class='Operator'>|| 
</span>           <span class='Operator'>!</span><a href="../../../include/access/xlogreader.h.html#LN221"><span class='Ref_to_Macro'>XLogRecHasAnyBlockRefs</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9608"><span class='Ref_to_Parameter'>record</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN9610"><span class='Ref_To_Local'>info</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_control.h.html#LN68"><span class='Ref_to_Const'>XLOG_NEXTOID</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN9619"></a>        <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>nextOid</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We used to try to take the maximum of ShmemVariableCache-&GT;nextOid 
         * and the recorded nextOid, but that fails if the OID counter wraps 
         * around.  Since no OID allocation should be happening during replay 
         * anyway, better to just believe the record exactly.  We still take 
         * OidGenLock while setting the variable, just in case. 
         */ 
</span>        memcpy<span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN9619"><span class='Ref_To_Local'>nextOid</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xlogreader.h.html#LN219"><span class='Ref_to_Macro'>XLogRecGetData</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9608"><span class='Ref_to_Parameter'>record</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>OidGenLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN110"><span class='Ref_to_Member'>nextOid</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN9619"><span class='Ref_To_Local'>nextOid</span></a><span class='Delimiter'>; 
</span>        <a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN111"><span class='Ref_to_Member'>oidCount</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>OidGenLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN9610"><span class='Ref_To_Local'>info</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_control.h.html#LN65"><span class='Ref_to_Const'>XLOG_CHECKPOINT_SHUTDOWN</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN9636"></a>        <a href="../../../include/catalog/pg_control.h.html#LN32"><span class='Ref_to_Struct'>CheckPoint</span></a>  <span class='Declare_Local'>checkPoint</span><span class='Delimiter'>; 
</span> 
        memcpy<span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN9636"><span class='Ref_To_Local'>checkPoint</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xlogreader.h.html#LN219"><span class='Ref_to_Macro'>XLogRecGetData</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9608"><span class='Ref_to_Parameter'>record</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_control.h.html#LN32"><span class='Ref_to_Struct'>CheckPoint</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* In a SHUTDOWN checkpoint, believe the counters exactly */ 
</span>        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>XidGenLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN116"><span class='Ref_to_Member'>nextXid</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN9636"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN41"><span class='Ref_to_Member'>nextXid</span></a><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>XidGenLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>OidGenLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN110"><span class='Ref_to_Member'>nextOid</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN9636"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN42"><span class='Ref_to_Member'>nextOid</span></a><span class='Delimiter'>; 
</span>        <a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN111"><span class='Ref_to_Member'>oidCount</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>OidGenLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/access/multixact.h.html#LN139"><span class='Ref_to_Proto'>MultiXactSetNextMXact</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9636"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN43"><span class='Ref_to_Member'>nextMulti</span></a><span class='Delimiter'>, 
</span>                              <a href="xlog.c.html#LN9636"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN44"><span class='Ref_to_Member'>nextMultiOffset</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/access/multixact.h.html#LN143"><span class='Ref_to_Proto'>MultiXactAdvanceOldest</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9636"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN47"><span class='Ref_to_Member'>oldestMulti</span></a><span class='Delimiter'>, 
</span>                               <a href="xlog.c.html#LN9636"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN48"><span class='Ref_to_Member'>oldestMultiDB</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * No need to set oldestClogXid here as well; it'll be set when we 
         * redo an xl_clog_truncate if it changed since initialization. 
         */ 
</span>        <a href="../../../include/access/transam.h.html#LN179"><span class='Ref_to_Proto'>SetTransactionIdLimit</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9636"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN45"><span class='Ref_to_Member'>oldestXid</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN9636"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN46"><span class='Ref_to_Member'>oldestXidDB</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If we see a shutdown checkpoint while waiting for an end-of-backup 
         * record, the backup was canceled and the end-of-backup record will 
         * never arrive. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN245"><span class='Ref_to_Global_Var'>ArchiveRecoveryRequested</span></a> <span class='Operator'>&& 
</span>            <span class='Operator'>!</span><a href="../../../include/access/xlogdefs.h.html#LN28"><span class='Ref_to_Macro'>XLogRecPtrIsInvalid</span></a><span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN171"><span class='Ref_to_Member'>backupStartPoint</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>            <a href="../../../include/access/xlogdefs.h.html#LN28"><span class='Ref_to_Macro'>XLogRecPtrIsInvalid</span></a><span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN172"><span class='Ref_to_Member'>backupEndPoint</span></a><span class='Parentheses'>))</span> 
            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>            <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"online backup was canceled, recovery cannot continue"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If we see a shutdown checkpoint, we know that nothing was running 
         * on the master at this point. So fake-up an empty running-xacts 
         * record and use that here and now. Recover additional standby state 
         * for prepared transactions. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN194"><span class='Ref_to_Global_Var'>standbyState</span></a> <span class='Operator'>&GT;= </span><a href="../../../include/access/xlog.h.html#LN66"><span class='Ref_to_EnumConst'>STANDBY_INITIALIZED</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN9678"></a>            <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Operator'>*</span><span class='Declare_Local'>xids</span><span class='Delimiter'>; 
</span><a name="LN9679"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>nxids</span><span class='Delimiter'>; 
</span><a name="LN9680"></a>            <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>oldestActiveXID</span><span class='Delimiter'>; 
</span><a name="LN9681"></a>            <a href="../../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>latestCompletedXid</span><span class='Delimiter'>; 
</span><a name="LN9682"></a>            <a href="../../../include/storage/standby.h.html#LN69"><span class='Ref_to_Struct'>RunningTransactionsData</span></a> <span class='Declare_Local'>running</span><span class='Delimiter'>; 
</span> 
            <a href="xlog.c.html#LN9680"><span class='Ref_To_Local'>oldestActiveXID</span></a> <span class='Operator'>= </span><a href="../../../include/access/twophase.h.html#LN46"><span class='Ref_to_Proto'>PrescanPreparedTransactions</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN9678"><span class='Ref_To_Local'>xids</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN9679"><span class='Ref_To_Local'>nxids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Construct a RunningTransactions snapshot representing a shut 
             * down server, with only prepared transactions still alive. We're 
             * never overflowed at this point because all subxids are listed 
             * with their parent prepared transactions. 
             */ 
</span>            <a href="xlog.c.html#LN9682"><span class='Ref_To_Local'>running</span></a><span class='Operator'>.</span><a href="../../../include/storage/standby.h.html#LN71"><span class='Ref_to_Member'>xcnt</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN9679"><span class='Ref_To_Local'>nxids</span></a><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN9682"><span class='Ref_To_Local'>running</span></a><span class='Operator'>.</span><a href="../../../include/storage/standby.h.html#LN72"><span class='Ref_to_Member'>subxcnt</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN9682"><span class='Ref_To_Local'>running</span></a><span class='Operator'>.</span><a href="../../../include/storage/standby.h.html#LN73"><span class='Ref_to_Member'>subxid_overflow</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN9682"><span class='Ref_To_Local'>running</span></a><span class='Operator'>.</span><a href="../../../include/storage/standby.h.html#LN74"><span class='Ref_to_Member'>nextXid</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN9636"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN41"><span class='Ref_to_Member'>nextXid</span></a><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN9682"><span class='Ref_To_Local'>running</span></a><span class='Operator'>.</span><a href="../../../include/storage/standby.h.html#LN75"><span class='Ref_to_Member'>oldestRunningXid</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN9680"><span class='Ref_To_Local'>oldestActiveXID</span></a><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN9681"><span class='Ref_To_Local'>latestCompletedXid</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN9636"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN41"><span class='Ref_to_Member'>nextXid</span></a><span class='Delimiter'>; 
</span>            <a href="../../../include/access/transam.h.html#LN55"><span class='Ref_to_Macro'>TransactionIdRetreat</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9681"><span class='Ref_To_Local'>latestCompletedXid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9681"><span class='Ref_To_Local'>latestCompletedXid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN9682"><span class='Ref_To_Local'>running</span></a><span class='Operator'>.</span><a href="../../../include/storage/standby.h.html#LN76"><span class='Ref_to_Member'>latestCompletedXid</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN9681"><span class='Ref_To_Local'>latestCompletedXid</span></a><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN9682"><span class='Ref_To_Local'>running</span></a><span class='Operator'>.</span><a href="../../../include/storage/standby.h.html#LN78"><span class='Ref_to_Member'>xids</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN9678"><span class='Ref_To_Local'>xids</span></a><span class='Delimiter'>; 
</span> 
            <a href="../../../include/storage/procarray.h.html#LN67"><span class='Ref_to_Proto'>ProcArrayApplyRecoveryInfo</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN9682"><span class='Ref_To_Local'>running</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="../../../include/access/twophase.h.html#LN48"><span class='Ref_to_Proto'>StandbyRecoverPreparedTransactions</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if standbyState&GT;=STANDBY... &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* ControlFile-&GT;checkPointCopy always tracks the latest ckpt XID */ 
</span>        <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN134"><span class='Ref_to_Member'>checkPointCopy</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN40"><span class='Ref_to_Member'>nextXidEpoch</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN9636"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN40"><span class='Ref_to_Member'>nextXidEpoch</span></a><span class='Delimiter'>; 
</span>        <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN134"><span class='Ref_to_Member'>checkPointCopy</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN41"><span class='Ref_to_Member'>nextXid</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN9636"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN41"><span class='Ref_to_Member'>nextXid</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Update shared-memory copy of checkpoint XID/epoch */ 
</span>        <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN579"><span class='Ref_to_Member'>ckptXidEpoch</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN9636"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN40"><span class='Ref_to_Member'>nextXidEpoch</span></a><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN580"><span class='Ref_to_Member'>ckptXid</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN9636"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN41"><span class='Ref_to_Member'>nextXid</span></a><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We should've already switched to the new TLI before replaying this 
         * record. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN9636"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN36"><span class='Ref_to_Member'>ThisTimeLineID</span></a> <span class='Operator'>!= </span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"unexpected timeline ID %u (should be %u) in checkpoint record"</span><span class='Delimiter'>, 
</span>                            <a href="xlog.c.html#LN9636"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN36"><span class='Ref_to_Member'>ThisTimeLineID</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <a href="xlog.c.html#LN9031"><span class='Ref_to_Func'>RecoveryRestartPoint</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN9636"><span class='Ref_To_Local'>checkPoint</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if info==XLOG_CHECKPOINT... &raquo; </span> 
    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN9610"><span class='Ref_To_Local'>info</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_control.h.html#LN66"><span class='Ref_to_Const'>XLOG_CHECKPOINT_ONLINE</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN9731"></a>        <a href="../../../include/catalog/pg_control.h.html#LN32"><span class='Ref_to_Struct'>CheckPoint</span></a>  <span class='Declare_Local'>checkPoint</span><span class='Delimiter'>; 
</span> 
        memcpy<span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN9731"><span class='Ref_To_Local'>checkPoint</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xlogreader.h.html#LN219"><span class='Ref_to_Macro'>XLogRecGetData</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9608"><span class='Ref_to_Parameter'>record</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_control.h.html#LN32"><span class='Ref_to_Struct'>CheckPoint</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* In an ONLINE checkpoint, treat the XID counter as a minimum */ 
</span>        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>XidGenLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN116"><span class='Ref_to_Member'>nextXid</span></a><span class='Delimiter'>, 
</span>                                  <a href="xlog.c.html#LN9731"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN41"><span class='Ref_to_Member'>nextXid</span></a><span class='Parentheses'>))</span> 
            <a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN116"><span class='Ref_to_Member'>nextXid</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN9731"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN41"><span class='Ref_to_Member'>nextXid</span></a><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>XidGenLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* ... but still treat OID counter as exact */ 
</span>        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>OidGenLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN110"><span class='Ref_to_Member'>nextOid</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN9731"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN42"><span class='Ref_to_Member'>nextOid</span></a><span class='Delimiter'>; 
</span>        <a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN111"><span class='Ref_to_Member'>oidCount</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>OidGenLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/access/multixact.h.html#LN141"><span class='Ref_to_Proto'>MultiXactAdvanceNextMXact</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9731"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN43"><span class='Ref_to_Member'>nextMulti</span></a><span class='Delimiter'>, 
</span>                                  <a href="xlog.c.html#LN9731"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN44"><span class='Ref_to_Member'>nextMultiOffset</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * NB: This may perform multixact truncation when replaying WAL 
         * generated by an older primary. 
         */ 
</span>        <a href="../../../include/access/multixact.h.html#LN143"><span class='Ref_to_Proto'>MultiXactAdvanceOldest</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9731"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN47"><span class='Ref_to_Member'>oldestMulti</span></a><span class='Delimiter'>, 
</span>                               <a href="xlog.c.html#LN9731"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN48"><span class='Ref_to_Member'>oldestMultiDB</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="varsup.c.html#LN33"><span class='Ref_to_Global_Var'>ShmemVariableCache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/transam.h.html#LN118"><span class='Ref_to_Member'>oldestXid</span></a><span class='Delimiter'>, 
</span>                                  <a href="xlog.c.html#LN9731"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN45"><span class='Ref_to_Member'>oldestXid</span></a><span class='Parentheses'>))</span> 
            <a href="../../../include/access/transam.h.html#LN179"><span class='Ref_to_Proto'>SetTransactionIdLimit</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9731"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN45"><span class='Ref_to_Member'>oldestXid</span></a><span class='Delimiter'>, 
</span>                                  <a href="xlog.c.html#LN9731"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN46"><span class='Ref_to_Member'>oldestXidDB</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* ControlFile-&GT;checkPointCopy always tracks the latest ckpt XID */ 
</span>        <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN134"><span class='Ref_to_Member'>checkPointCopy</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN40"><span class='Ref_to_Member'>nextXidEpoch</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN9731"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN40"><span class='Ref_to_Member'>nextXidEpoch</span></a><span class='Delimiter'>; 
</span>        <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN134"><span class='Ref_to_Member'>checkPointCopy</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN41"><span class='Ref_to_Member'>nextXid</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN9731"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN41"><span class='Ref_to_Member'>nextXid</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Update shared-memory copy of checkpoint XID/epoch */ 
</span>        <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN579"><span class='Ref_to_Member'>ckptXidEpoch</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN9731"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN40"><span class='Ref_to_Member'>nextXidEpoch</span></a><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN580"><span class='Ref_to_Member'>ckptXid</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN9731"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN41"><span class='Ref_to_Member'>nextXid</span></a><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* TLI should not change in an on-line checkpoint */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN9731"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN36"><span class='Ref_to_Member'>ThisTimeLineID</span></a> <span class='Operator'>!= </span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"unexpected timeline ID %u (should be %u) in checkpoint record"</span><span class='Delimiter'>, 
</span>                            <a href="xlog.c.html#LN9731"><span class='Ref_To_Local'>checkPoint</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN36"><span class='Ref_to_Member'>ThisTimeLineID</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <a href="xlog.c.html#LN9031"><span class='Ref_to_Func'>RecoveryRestartPoint</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN9731"><span class='Ref_To_Local'>checkPoint</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if info==XLOG_CHECKPOINT... &raquo; </span> 
    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN9610"><span class='Ref_To_Local'>info</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_control.h.html#LN74"><span class='Ref_to_Const'>XLOG_END_OF_RECOVERY</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN9778"></a>        <a href="../../../include/access/xlog_internal.h.html#LN229"><span class='Ref_to_Struct'>xl_end_of_recovery</span></a> <span class='Declare_Local'>xlrec</span><span class='Delimiter'>; 
</span> 
        memcpy<span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN9778"><span class='Ref_To_Local'>xlrec</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xlogreader.h.html#LN219"><span class='Ref_to_Macro'>XLogRecGetData</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9608"><span class='Ref_to_Parameter'>record</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/access/xlog_internal.h.html#LN229"><span class='Ref_to_Struct'>xl_end_of_recovery</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * For Hot Standby, we could treat this like a Shutdown Checkpoint, 
         * but this case is rarer and harder to test, so the benefit doesn't 
         * outweigh the potential extra cost of maintenance. 
         */ 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We should've already switched to the new TLI before replaying this 
         * record. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN9778"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog_internal.h.html#LN232"><span class='Ref_to_Member'>ThisTimeLineID</span></a> <span class='Operator'>!= </span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"unexpected timeline ID %u (should be %u) in checkpoint record"</span><span class='Delimiter'>, 
</span>                            <a href="xlog.c.html#LN9778"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog_internal.h.html#LN232"><span class='Ref_to_Member'>ThisTimeLineID</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if info==XLOG_END_OF_REC... &raquo; </span> 
    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN9610"><span class='Ref_To_Local'>info</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_control.h.html#LN67"><span class='Ref_to_Const'>XLOG_NOOP</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* nothing to do here */ 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN9610"><span class='Ref_To_Local'>info</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_control.h.html#LN69"><span class='Ref_to_Const'>XLOG_SWITCH</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* nothing to do here */ 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN9610"><span class='Ref_To_Local'>info</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_control.h.html#LN72"><span class='Ref_to_Const'>XLOG_RESTORE_POINT</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* nothing to do here */ 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN9610"><span class='Ref_To_Local'>info</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_control.h.html#LN76"><span class='Ref_to_Const'>XLOG_FPI</span></a> <span class='Operator'>|| </span><a href="xlog.c.html#LN9610"><span class='Ref_To_Local'>info</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_control.h.html#LN75"><span class='Ref_to_Const'>XLOG_FPI_FOR_HINT</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN9811"></a>        <a href="../../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a>      <span class='Declare_Local'>buffer</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Full-page image (FPI) records contain nothing else but a backup 
         * block. The block reference must include a full-page image - 
         * otherwise there would be no point in this record. 
         * 
         * No recovery conflicts are generated by these generic records - if a 
         * resource manager needs to generate conflicts, it has to define a 
         * separate WAL record type and redo routine. 
         * 
         * XLOG_FPI_FOR_HINT records are generated when a page needs to be 
         * WAL- logged because of a hint bit update. They are only generated 
         * when checksums are enabled. There is no difference in handling 
         * XLOG_FPI and XLOG_FPI_FOR_HINT records, they use a different info 
         * code just to distinguish them for statistics purposes. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/xlogutils.h.html#LN35"><span class='Ref_to_Proto'>XLogReadBufferForRedo</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9608"><span class='Ref_to_Parameter'>record</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN9811"><span class='Ref_To_Local'>buffer</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><a href="../../../include/access/xlogutils.h.html#LN30"><span class='Ref_to_EnumConst'>BLK_RESTORED</span></a><span class='Parentheses'>)</span> 
            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unexpected XLogReadBufferForRedo result when restoring backup block"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/bufmgr.h.html#LN175"><span class='Ref_to_Proto'>UnlockReleaseBuffer</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9811"><span class='Ref_To_Local'>buffer</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if info==XLOG_FPI||info=... &raquo; </span> 
    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN9610"><span class='Ref_To_Local'>info</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_control.h.html#LN70"><span class='Ref_to_Const'>XLOG_BACKUP_END</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN9834"></a>        <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>startpoint</span><span class='Delimiter'>; 
</span> 
        memcpy<span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN9834"><span class='Ref_To_Local'>startpoint</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xlogreader.h.html#LN219"><span class='Ref_to_Macro'>XLogRecGetData</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9608"><span class='Ref_to_Parameter'>record</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN9834"><span class='Ref_To_Local'>startpoint</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN171"><span class='Ref_to_Member'>backupStartPoint</span></a> <span class='Operator'>== </span><a href="xlog.c.html#LN9834"><span class='Ref_To_Local'>startpoint</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * We have reached the end of base backup, the point where 
             * pg_stop_backup() was done. The data on disk is now consistent. 
             * Reset backupStartPoint, and update minRecoveryPoint to make 
             * sure we don't allow starting up at an earlier point even if 
             * recovery is stopped and restarted soon after this. 
             */ 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN24"><span class='Ref_to_Const'>DEBUG1</span></a><span class='Delimiter'>, </span><span class='String'>"end of backup reached"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ControlFileLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN169"><span class='Ref_to_Member'>minRecoveryPoint</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN9611"><span class='Ref_To_Local'>lsn</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN169"><span class='Ref_to_Member'>minRecoveryPoint</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN9611"><span class='Ref_To_Local'>lsn</span></a><span class='Delimiter'>; 
</span>                <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN170"><span class='Ref_to_Member'>minRecoveryPointTLI</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN171"><span class='Ref_to_Member'>backupStartPoint</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlogdefs.h.html#LN27"><span class='Ref_to_Const'>InvalidXLogRecPtr</span></a><span class='Delimiter'>; 
</span>            <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN173"><span class='Ref_to_Member'>backupEndRequired</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="../../../include/access/xlog.h.html#LN256"><span class='Ref_to_Proto'>UpdateControlFile</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
            <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ControlFileLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if ControlFile-&GT;backupSt... &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if info==XLOG_BACKUP_END &raquo; </span> 
    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN9610"><span class='Ref_To_Local'>info</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_control.h.html#LN71"><span class='Ref_to_Const'>XLOG_PARAMETER_CHANGE</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN9865"></a>        <a href="../../../include/access/xlog_internal.h.html#LN210"><span class='Ref_to_Struct'>xl_parameter_change</span></a> <span class='Declare_Local'>xlrec</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Update our copy of the parameters in pg_control */ 
</span>        memcpy<span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN9865"><span class='Ref_To_Local'>xlrec</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xlogreader.h.html#LN219"><span class='Ref_to_Macro'>XLogRecGetData</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9608"><span class='Ref_to_Parameter'>record</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/access/xlog_internal.h.html#LN210"><span class='Ref_to_Struct'>xl_parameter_change</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ControlFileLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN181"><span class='Ref_to_Member'>MaxConnections</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN9865"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog_internal.h.html#LN212"><span class='Ref_to_Member'>MaxConnections</span></a><span class='Delimiter'>; 
</span>        <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN182"><span class='Ref_to_Member'>max_worker_processes</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN9865"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog_internal.h.html#LN213"><span class='Ref_to_Member'>max_worker_processes</span></a><span class='Delimiter'>; 
</span>        <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN183"><span class='Ref_to_Member'>max_prepared_xacts</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN9865"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog_internal.h.html#LN214"><span class='Ref_to_Member'>max_prepared_xacts</span></a><span class='Delimiter'>; 
</span>        <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN184"><span class='Ref_to_Member'>max_locks_per_xact</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN9865"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog_internal.h.html#LN215"><span class='Ref_to_Member'>max_locks_per_xact</span></a><span class='Delimiter'>; 
</span>        <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN179"><span class='Ref_to_Member'>wal_level</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN9865"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog_internal.h.html#LN216"><span class='Ref_to_Member'>wal_level</span></a><span class='Delimiter'>; 
</span>        <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN180"><span class='Ref_to_Member'>wal_log_hints</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN9865"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog_internal.h.html#LN217"><span class='Ref_to_Member'>wal_log_hints</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Update minRecoveryPoint to ensure that if recovery is aborted, we 
         * recover back up to this point before allowing hot standby again. 
         * This is important if the max_* settings are decreased, to ensure 
         * you don't run queries against the WAL preceding the change. 
         */ 
</span>        <a href="xlog.c.html#LN820"><span class='Ref_to_Global_Var'>minRecoveryPoint</span></a> <span class='Operator'>= </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN169"><span class='Ref_to_Member'>minRecoveryPoint</span></a><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN822"><span class='Ref_to_Global_Var'>minRecoveryPointTLI</span></a> <span class='Operator'>= </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN170"><span class='Ref_to_Member'>minRecoveryPointTLI</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN820"><span class='Ref_to_Global_Var'>minRecoveryPoint</span></a> <span class='Operator'>!= </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="xlog.c.html#LN820"><span class='Ref_to_Global_Var'>minRecoveryPoint</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN9611"><span class='Ref_To_Local'>lsn</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN169"><span class='Ref_to_Member'>minRecoveryPoint</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN9611"><span class='Ref_To_Local'>lsn</span></a><span class='Delimiter'>; 
</span>            <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN170"><span class='Ref_to_Member'>minRecoveryPointTLI</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="../../../include/access/commit_ts.h.html#LN37"><span class='Ref_to_Proto'>CommitTsParameterChange</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9865"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog_internal.h.html#LN218"><span class='Ref_to_Member'>track_commit_timestamp</span></a><span class='Delimiter'>, 
</span>                                <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN185"><span class='Ref_to_Member'>track_commit_timestamp</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN185"><span class='Ref_to_Member'>track_commit_timestamp</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN9865"><span class='Ref_To_Local'>xlrec</span></a><span class='Operator'>.</span><a href="../../../include/access/xlog_internal.h.html#LN218"><span class='Ref_to_Member'>track_commit_timestamp</span></a><span class='Delimiter'>; 
</span> 
        <a href="../../../include/access/xlog.h.html#LN256"><span class='Ref_to_Proto'>UpdateControlFile</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ControlFileLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Check to see if any changes to max_connections give problems */ 
</span>        <a href="xlog.c.html#LN853"><span class='Ref_to_Proto'>CheckRequiredParameterValues</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if info==XLOG_PARAMETER_... &raquo; </span> 
    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN9610"><span class='Ref_To_Local'>info</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_control.h.html#LN73"><span class='Ref_to_Const'>XLOG_FPW_CHANGE</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN9904"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>fpw</span><span class='Delimiter'>; 
</span> 
        memcpy<span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN9904"><span class='Ref_To_Local'>fpw</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xlogreader.h.html#LN219"><span class='Ref_to_Macro'>XLogRecGetData</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9608"><span class='Ref_to_Parameter'>record</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>bool</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Update the LSN of the last replayed XLOG_FPW_CHANGE record so that 
         * do_pg_start_backup() and do_pg_stop_backup() can check whether 
         * full_page_writes has been disabled during online backup. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN9904"><span class='Ref_To_Local'>fpw</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN700"><span class='Ref_to_Member'>lastFpwDisableRecPtr</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN817"><span class='Ref_to_Global_Var'>ReadRecPtr</span></a><span class='Parentheses'>) 
</span>                <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN700"><span class='Ref_to_Member'>lastFpwDisableRecPtr</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN817"><span class='Ref_to_Global_Var'>ReadRecPtr</span></a><span class='Delimiter'>; 
</span>            <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* Keep track of full_page_writes */ 
</span>        <a href="xlog.c.html#LN208"><span class='Ref_to_Global_Var'>lastFullPageWrites</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN9904"><span class='Ref_To_Local'>fpw</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if info==XLOG_FPW_CHANGE &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end xlog_redo &raquo; </span> 
 
<span class='Directive'>#ifdef</span> WAL_DEBUG 
 
<span class='Keyword'>static void 
</span><a name="LN9929"></a><span class='Declare_Function'>xlog_outrec</span><span class='Parentheses'>(</span><a href="../../../include/lib/stringinfo.h.html#LN42"><span class='Ref_to_Typedef'>StringInfo</span></a> <span class='Declare_Parameter'>buf</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogreader.h.html#LN68"><span class='Ref_to_Struct'>XLogReaderState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>record</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN9931"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>block_id</span><span class='Delimiter'>; 
</span> 
    <a href="../../../bin/pg_waldump/compat.c.html#LN69"><span class='Ref_to_Func'>appendStringInfo</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9929"><span class='Ref_to_Parameter'>buf</span></a><span class='Delimiter'>, </span><span class='String'>"prev %X/%X; xid %u"</span><span class='Delimiter'>, 
</span>                     <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>)</span> <span class='Parentheses'>(</span><a href="../../../include/access/xlogreader.h.html#LN214"><span class='Ref_to_Macro'>XLogRecGetPrev</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9929"><span class='Ref_to_Parameter'>record</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>)</span> <a href="../../../include/access/xlogreader.h.html#LN214"><span class='Ref_to_Macro'>XLogRecGetPrev</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9929"><span class='Ref_to_Parameter'>record</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../../include/access/xlogreader.h.html#LN217"><span class='Ref_to_Macro'>XLogRecGetXid</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9929"><span class='Ref_to_Parameter'>record</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="../../../bin/pg_waldump/compat.c.html#LN69"><span class='Ref_to_Func'>appendStringInfo</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9929"><span class='Ref_to_Parameter'>buf</span></a><span class='Delimiter'>, </span><span class='String'>"; len %u"</span><span class='Delimiter'>, 
</span>                     <a href="../../../include/access/xlogreader.h.html#LN220"><span class='Ref_to_Macro'>XLogRecGetDataLen</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9929"><span class='Ref_to_Parameter'>record</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* decode block references */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN9931"><span class='Ref_To_Local'>block_id</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="xlog.c.html#LN9931"><span class='Ref_To_Local'>block_id</span></a> <span class='Operator'>&LT;= </span><a href="xlog.c.html#LN9929"><span class='Ref_to_Parameter'>record</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogreader.h.html#LN135"><span class='Ref_to_Member'>max_block_id</span></a><span class='Delimiter'>; </span><a href="xlog.c.html#LN9931"><span class='Ref_To_Local'>block_id</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN9944"></a>        <a href="../../../include/storage/relfilenode.h.html#LN56"><span class='Ref_to_Struct'>RelFileNode</span></a> <span class='Declare_Local'>rnode</span><span class='Delimiter'>; 
</span><a name="LN9945"></a>        <a href="../../../include/common/relpath.h.html#LN23"><span class='Ref_to_Enum'>ForkNumber</span></a>  <span class='Declare_Local'>forknum</span><span class='Delimiter'>; 
</span><a name="LN9946"></a>        <a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Local'>blk</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/xlogreader.h.html#LN222"><span class='Ref_to_Macro'>XLogRecHasBlockRef</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9929"><span class='Ref_to_Parameter'>record</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN9931"><span class='Ref_To_Local'>block_id</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/access/xlogreader.h.html#LN231"><span class='Ref_to_Proto'>XLogRecGetBlockTag</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9929"><span class='Ref_to_Parameter'>record</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN9931"><span class='Ref_To_Local'>block_id</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN9944"><span class='Ref_To_Local'>rnode</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN9945"><span class='Ref_To_Local'>forknum</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN9946"><span class='Ref_To_Local'>blk</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN9945"><span class='Ref_To_Local'>forknum</span></a> <span class='Operator'>!= </span><a href="../../../include/common/relpath.h.html#LN26"><span class='Ref_to_EnumConst'>MAIN_FORKNUM</span></a><span class='Parentheses'>) 
</span>            <a href="../../../bin/pg_waldump/compat.c.html#LN69"><span class='Ref_to_Func'>appendStringInfo</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9929"><span class='Ref_to_Parameter'>buf</span></a><span class='Delimiter'>, </span><span class='String'>"; blkref #%u: rel %u/%u/%u, fork %u, blk %u"</span><span class='Delimiter'>, 
</span>                             <a href="xlog.c.html#LN9931"><span class='Ref_To_Local'>block_id</span></a><span class='Delimiter'>, 
</span>                             <a href="xlog.c.html#LN9944"><span class='Ref_To_Local'>rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN58"><span class='Ref_to_Member'>spcNode</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN9944"><span class='Ref_To_Local'>rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN59"><span class='Ref_to_Member'>dbNode</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN9944"><span class='Ref_To_Local'>rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN60"><span class='Ref_to_Member'>relNode</span></a><span class='Delimiter'>, 
</span>                             <a href="xlog.c.html#LN9945"><span class='Ref_To_Local'>forknum</span></a><span class='Delimiter'>, 
</span>                             <a href="xlog.c.html#LN9946"><span class='Ref_To_Local'>blk</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="../../../bin/pg_waldump/compat.c.html#LN69"><span class='Ref_to_Func'>appendStringInfo</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9929"><span class='Ref_to_Parameter'>buf</span></a><span class='Delimiter'>, </span><span class='String'>"; blkref #%u: rel %u/%u/%u, blk %u"</span><span class='Delimiter'>, 
</span>                             <a href="xlog.c.html#LN9931"><span class='Ref_To_Local'>block_id</span></a><span class='Delimiter'>, 
</span>                             <a href="xlog.c.html#LN9944"><span class='Ref_To_Local'>rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN58"><span class='Ref_to_Member'>spcNode</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN9944"><span class='Ref_To_Local'>rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN59"><span class='Ref_to_Member'>dbNode</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN9944"><span class='Ref_To_Local'>rnode</span></a><span class='Operator'>.</span><a href="../../../include/storage/relfilenode.h.html#LN60"><span class='Ref_to_Member'>relNode</span></a><span class='Delimiter'>, 
</span>                             <a href="xlog.c.html#LN9946"><span class='Ref_To_Local'>blk</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/access/xlogreader.h.html#LN224"><span class='Ref_to_Macro'>XLogRecHasBlockImage</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9929"><span class='Ref_to_Parameter'>record</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN9931"><span class='Ref_To_Local'>block_id</span></a><span class='Parentheses'>))</span> 
            <a href="../../../bin/pg_waldump/compat.c.html#LN79"><span class='Ref_to_Func'>appendStringInfoString</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9929"><span class='Ref_to_Parameter'>buf</span></a><span class='Delimiter'>, </span><span class='String'>" FPW"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for block_id=0;block_id&LT;=... &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end xlog_outrec &raquo; </span> 
<span class='Directive'>#endif</span>   <span class='Comment_Single_Line'>/* WAL_DEBUG */ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Returns a string describing an XLogRecord, consisting of its identity 
 * optionally followed by a colon, a space, and a further description. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN9974"></a><span class='Declare_Function'>xlog_outdesc</span><span class='Parentheses'>(</span><a href="../../../include/lib/stringinfo.h.html#LN42"><span class='Ref_to_Typedef'>StringInfo</span></a> <span class='Declare_Parameter'>buf</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogreader.h.html#LN68"><span class='Ref_to_Struct'>XLogReaderState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>record</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN9976"></a>    <a href="../../../include/access/rmgr.h.html#LN10"><span class='Ref_to_Typedef'>RmgrId</span></a>      <span class='Declare_Local'>rmid</span> <span class='Operator'>= </span><a href="../../../include/access/xlogreader.h.html#LN216"><span class='Ref_to_Macro'>XLogRecGetRmid</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9974"><span class='Ref_to_Parameter'>record</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN9977"></a>    <a href="../../../include/c.h.html#LN265"><span class='Ref_to_Typedef'>uint8</span></a>       <span class='Declare_Local'>info</span> <span class='Operator'>= </span><a href="../../../include/access/xlogreader.h.html#LN215"><span class='Ref_to_Macro'>XLogRecGetInfo</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9974"><span class='Ref_to_Parameter'>record</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN9978"></a>    <span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Local'>id</span><span class='Delimiter'>; 
</span> 
    <a href="../../../bin/pg_waldump/compat.c.html#LN79"><span class='Ref_to_Func'>appendStringInfoString</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9974"><span class='Ref_to_Parameter'>buf</span></a><span class='Delimiter'>, </span><a href="rmgr.c.html#LN35"><span class='Ref_to_Global_Var'>RmgrTable</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN9976"><span class='Ref_To_Local'>rmid</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/access/xlog_internal.h.html#LN275"><span class='Ref_to_Member'>rm_name</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../replication/syncrep_scanner.l.html#LN76"><span class='Ref_to_Proto'>appendStringInfoChar</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9974"><span class='Ref_to_Parameter'>buf</span></a><span class='Delimiter'>, </span><span class='String'>'/'</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="xlog.c.html#LN9978"><span class='Ref_To_Local'>id</span></a> <span class='Operator'>= </span><a href="rmgr.c.html#LN35"><span class='Ref_to_Global_Var'>RmgrTable</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN9976"><span class='Ref_To_Local'>rmid</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span>rm_identify<span class='Parentheses'>(</span><a href="xlog.c.html#LN9977"><span class='Ref_To_Local'>info</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN9978"><span class='Ref_To_Local'>id</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="../../../bin/pg_waldump/compat.c.html#LN69"><span class='Ref_to_Func'>appendStringInfo</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9974"><span class='Ref_to_Parameter'>buf</span></a><span class='Delimiter'>, </span><span class='String'>"UNKNOWN (%X): "</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN9977"><span class='Ref_To_Local'>info</span></a> <span class='Operator'>& ~</span><a href="../../../include/access/xlogrecord.h.html#LN61"><span class='Ref_to_Const'>XLR_INFO_MASK</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="../../../bin/pg_waldump/compat.c.html#LN69"><span class='Ref_to_Func'>appendStringInfo</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9974"><span class='Ref_to_Parameter'>buf</span></a><span class='Delimiter'>, </span><span class='String'>"%s: "</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN9978"><span class='Ref_To_Local'>id</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="rmgr.c.html#LN35"><span class='Ref_to_Global_Var'>RmgrTable</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN9976"><span class='Ref_To_Local'>rmid</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../../include/access/xlog_internal.h.html#LN277"><span class='Ref_to_Member'>rm_desc</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN9974"><span class='Ref_to_Parameter'>buf</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN9974"><span class='Ref_to_Parameter'>record</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Return the (possible) sync flag used for opening a file, depending on the 
 * value of the GUC wal_sync_method. 
 */ 
</span><span class='Keyword'>static int 
</span><a name="LN9998"></a><span class='Declare_Function'>get_sync_bit</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>method</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN10000"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>o_direct_flag</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* If fsync is disabled, never open in sync mode */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../utils/init/globals.c.html#LN110"><span class='Ref_to_Global_Var'>enableFsync</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Optimize writes by bypassing kernel cache with O_DIRECT when using 
     * O_SYNC/O_FSYNC and O_DSYNC.  But only if archiving and streaming are 
     * disabled, otherwise the archive command or walsender process will read 
     * the WAL soon after writing it, which is guaranteed to cause a physical 
     * read if we bypassed the kernel cache. We also skip the 
     * posix_fadvise(POSIX_FADV_DONTNEED) call in XLogFileClose() for the same 
     * reason. 
     * 
     * Never use O_DIRECT in walreceiver process for similar reasons; the WAL 
     * written by walreceiver is normally read by the startup process soon 
     * after its written. Also, walreceiver performs unaligned writes, which 
     * don't work with O_DIRECT, so it is required for correctness too. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/xlog.h.html#LN144"><span class='Ref_to_Macro'>XLogIsNeeded</span></a><span class='Parentheses'>() </span><span class='Operator'>&& !</span><a href="../../../include/miscadmin.h.html#LN411"><span class='Ref_to_Macro'>AmWalReceiverProcess</span></a><span class='Parentheses'>())</span> 
        <a href="xlog.c.html#LN10000"><span class='Ref_To_Local'>o_direct_flag</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlogdefs.h.html#LN62"><span class='Ref_to_Const'>PG_O_DIRECT</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN9998"><span class='Ref_to_Parameter'>method</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * enum values for all sync options are defined even if they are 
             * not supported on the current platform.  But if not, they are 
             * not included in the enum option array, and therefore will never 
             * be seen here. 
             */ 
</span>        <span class='Control'>case</span> <a href="../../../include/access/xlog.h.html#LN24"><span class='Ref_to_Const'>SYNC_METHOD_FSYNC</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../include/access/xlog.h.html#LN27"><span class='Ref_to_Const'>SYNC_METHOD_FSYNC_WRITETHROUGH</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../include/access/xlog.h.html#LN25"><span class='Ref_to_Const'>SYNC_METHOD_FDATASYNC</span></a><span class='Operator'>: 
</span>            <span class='Control'>return</span> <span class='Number'>0</span><span class='Delimiter'>; 
</span><span class='Directive'>#ifdef</span> <a href="../../../include/access/xlogdefs.h.html#LN74"><span class='Ref_to_Const'>OPEN_SYNC_FLAG</span></a> 
        <span class='Control'>case</span> <a href="../../../include/access/xlog.h.html#LN26"><span class='Ref_to_Const'>SYNC_METHOD_OPEN</span></a><span class='Operator'>: 
</span>            <span class='Control'>return</span> <a href="../../../include/access/xlogdefs.h.html#LN74"><span class='Ref_to_Const'>OPEN_SYNC_FLAG</span></a> <span class='Operator'>| </span><a href="xlog.c.html#LN10000"><span class='Ref_To_Local'>o_direct_flag</span></a><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
<span class='Directive'>#ifdef</span> <a href="../../../include/access/xlogdefs.h.html#LN83"><span class='Ref_to_Const'>OPEN_DATASYNC_FLAG</span></a> 
        <span class='Control'>case</span> <a href="../../../include/access/xlog.h.html#LN28"><span class='Ref_to_Const'>SYNC_METHOD_OPEN_DSYNC</span></a><span class='Operator'>: 
</span>            <span class='Control'>return</span> <a href="../../../include/access/xlogdefs.h.html#LN83"><span class='Ref_to_Const'>OPEN_DATASYNC_FLAG</span></a> <span class='Operator'>| </span><a href="xlog.c.html#LN10000"><span class='Ref_To_Local'>o_direct_flag</span></a><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
        <span class='Control'>default</span><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* can't happen (unless we are out of sync with option array) */ 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized wal_sync_method: %d"</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN9998"><span class='Ref_to_Parameter'>method</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span> <span class='Number'>0</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* silence warning */ 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch method &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end get_sync_bit &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * GUC support 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN10054"></a><span class='Declare_Function'>assign_xlog_sync_method</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>new_sync_method</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>extra</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN102"><span class='Ref_to_Global_Var'>sync_method</span></a> <span class='Operator'>!= </span><a href="xlog.c.html#LN10054"><span class='Ref_to_Parameter'>new_sync_method</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * To ensure that no blocks escape unsynced, force an fsync on the 
         * currently open log segment (if any).  Also, if the open flag is 
         * changing, close the log file so it will be reopened (with new flag 
         * bit) at next use. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN770"><span class='Ref_to_Global_Var'>openLogFile</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../../include/pgstat.h.html#LN1206"><span class='Ref_to_Func'>pgstat_report_wait_start</span></a><span class='Parentheses'>(</span><a href="../../../include/pgstat.h.html#LN903"><span class='Ref_to_EnumConst'>WAIT_EVENT_WAL_SYNC_METHOD_ASSIGN</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/fd.h.html#LN114"><span class='Ref_to_Proto'>pg_fsync</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN770"><span class='Ref_to_Global_Var'>openLogFile</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                         <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not fsync log segment %s: %m"</span><span class='Delimiter'>, 
</span>                              <a href="../../../include/access/xlog.h.html#LN254"><span class='Ref_to_Proto'>XLogFileNameP</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN771"><span class='Ref_to_Global_Var'>openLogSegNo</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>            <a href="../../../include/pgstat.h.html#LN1230"><span class='Ref_to_Func'>pgstat_report_wait_end</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN908"><span class='Ref_to_Proto'>get_sync_bit</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN102"><span class='Ref_to_Global_Var'>sync_method</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><a href="xlog.c.html#LN908"><span class='Ref_to_Proto'>get_sync_bit</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10054"><span class='Ref_to_Parameter'>new_sync_method</span></a><span class='Parentheses'>))</span> 
                <a href="xlog.c.html#LN878"><span class='Ref_to_Proto'>XLogFileClose</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if sync_method!=new_sync... &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end assign_xlog_sync_method &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * Issue appropriate kind of fsync (if any) for an XLOG output file. 
 * 
 * 'fd' is a file descriptor for the XLOG file to be fsync'd. 
 * 'log' and 'seg' are for error reporting purposes. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN10087"></a><span class='Declare_Function'>issue_xlog_fsync</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>fd</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a> <span class='Declare_Parameter'>segno</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN102"><span class='Ref_to_Global_Var'>sync_method</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../../include/access/xlog.h.html#LN24"><span class='Ref_to_Const'>SYNC_METHOD_FSYNC</span></a><span class='Operator'>: 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/fd.h.html#LN115"><span class='Ref_to_Proto'>pg_fsync_no_writethrough</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10087"><span class='Ref_to_Parameter'>fd</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                         <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not fsync log file %s: %m"</span><span class='Delimiter'>, 
</span>                                <a href="../../../include/access/xlog.h.html#LN254"><span class='Ref_to_Proto'>XLogFileNameP</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN10087"><span class='Ref_to_Parameter'>segno</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span><span class='Directive'>#ifdef</span> <a href="../../../include/port/darwin.h.html#LN5"><span class='Ref_to_Const'>HAVE_FSYNC_WRITETHROUGH</span></a> 
        <span class='Control'>case</span> <a href="../../../include/access/xlog.h.html#LN27"><span class='Ref_to_Const'>SYNC_METHOD_FSYNC_WRITETHROUGH</span></a><span class='Operator'>: 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../bin/pg_test_fsync/pg_test_fsync.c.html#LN90"><span class='Ref_to_Proto'>pg_fsync_writethrough</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10087"><span class='Ref_to_Parameter'>fd</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                      <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not fsync write-through log file %s: %m"</span><span class='Delimiter'>, 
</span>                             <a href="../../../include/access/xlog.h.html#LN254"><span class='Ref_to_Proto'>XLogFileNameP</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN10087"><span class='Ref_to_Parameter'>segno</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
<span class='Directive'>#ifdef</span> HAVE_FDATASYNC 
        <span class='Control'>case</span> <a href="../../../include/access/xlog.h.html#LN25"><span class='Ref_to_Const'>SYNC_METHOD_FDATASYNC</span></a><span class='Operator'>: 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/storage/fd.h.html#LN117"><span class='Ref_to_Proto'>pg_fdatasync</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10087"><span class='Ref_to_Parameter'>fd</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                         <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not fdatasync log file %s: %m"</span><span class='Delimiter'>, 
</span>                                <a href="../../../include/access/xlog.h.html#LN254"><span class='Ref_to_Proto'>XLogFileNameP</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN10087"><span class='Ref_to_Parameter'>segno</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
        <span class='Control'>case</span> <a href="../../../include/access/xlog.h.html#LN26"><span class='Ref_to_Const'>SYNC_METHOD_OPEN</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../include/access/xlog.h.html#LN28"><span class='Ref_to_Const'>SYNC_METHOD_OPEN_DSYNC</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* write synced it already */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>default</span><span class='Operator'>: 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized wal_sync_method: %d"</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN102"><span class='Ref_to_Global_Var'>sync_method</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch sync_method &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end issue_xlog_fsync &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Return the filename of given log segment, as a palloc'd string. 
 */ 
</span><span class='Keyword'>char </span><span class='Operator'>* 
</span><a name="LN10130"></a><span class='Declare_Function'>XLogFileNameP</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a> <span class='Declare_Parameter'>tli</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a> <span class='Declare_Parameter'>segno</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN10132"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>result</span> <span class='Operator'>= </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlog_internal.h.html#LN137"><span class='Ref_to_Const'>MAXFNAMELEN</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/access/xlog_internal.h.html#LN142"><span class='Ref_to_Macro'>XLogFileName</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10132"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN10130"><span class='Ref_to_Parameter'>tli</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN10130"><span class='Ref_to_Parameter'>segno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="xlog.c.html#LN10132"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * do_pg_start_backup is the workhorse of the user-visible pg_start_backup() 
 * function. It creates the necessary starting checkpoint and constructs the 
 * backup label file. 
 * 
 * There are two kind of backups: exclusive and non-exclusive. An exclusive 
 * backup is started with pg_start_backup(), and there can be only one active 
 * at a time. The backup and tablespace map files of an exclusive backup are 
 * written to $PGDATA/backup_label and $PGDATA/tablespace_map, and they are 
 * removed by pg_stop_backup(). 
 * 
 * A non-exclusive backup is used for the streaming base backups (see 
 * src/backend/replication/basebackup.c). The difference to exclusive backups 
 * is that the backup label and tablespace map files are not written to disk. 
 * Instead, their would-be contents are returned in *labelfile and *tblspcmapfile, 
 * and the caller is responsible for including them in the backup archive as 
 * 'backup_label' and 'tablespace_map'. There can be many non-exclusive backups 
 * active at the same time, and they don't conflict with an exclusive backup 
 * either. 
 * 
 * tblspcmapfile is required mainly for tar format in windows as native windows 
 * utilities are not able to create symlinks while extracting files from tar. 
 * However for consistency, the same is used for all platforms. 
 * 
 * needtblspcmapfile is true for the cases (exclusive backup and for 
 * non-exclusive backup only when tar format is used for taking backup) 
 * when backup needs to generate tablespace_map file, it is used to 
 * embed escape character before newline character in tablespace path. 
 * 
 * Returns the minimum WAL location that must be present to restore from this 
 * backup, and the corresponding timeline ID in *starttli_p. 
 * 
 * Every successfully started non-exclusive backup must be stopped by calling 
 * do_pg_stop_backup() or do_pg_abort_backup(). 
 * 
 * It is the responsibility of the caller of this function to verify the 
 * permissions of the calling user! 
 */ 
</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> 
<a name="LN10177"></a><span class='Declare_Function'>do_pg_start_backup</span><span class='Parentheses'>(</span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>backupidstr</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>fast</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>starttli_p</span><span class='Delimiter'>, 
</span><a name="LN10178"></a>                   <a href="../../../include/lib/stringinfo.h.html#LN42"><span class='Ref_to_Typedef'>StringInfo</span></a> <span class='Declare_Parameter'>labelfile</span><span class='Delimiter'>, </span><a href="../../../port/dirent.c.html#LN24"><span class='Ref_to_Struct'>DIR</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>tblspcdir</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>tablespaces</span><span class='Delimiter'>, 
</span><a name="LN10179"></a>                   <a href="../../../include/lib/stringinfo.h.html#LN42"><span class='Ref_to_Typedef'>StringInfo</span></a> <span class='Declare_Parameter'>tblspcmapfile</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>infotbssize</span><span class='Delimiter'>, 
</span><a name="LN10180"></a>                   <span class='Keyword'>bool </span><span class='Declare_Parameter'>needtblspcmapfile</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN10182"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>exclusive</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="xlog.c.html#LN10178"><span class='Ref_to_Parameter'>labelfile</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN10183"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>backup_started_in_recovery</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN10184"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>checkpointloc</span><span class='Delimiter'>; 
</span><a name="LN10185"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>startpoint</span><span class='Delimiter'>; 
</span><a name="LN10186"></a>    <a href="../../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a>  <span class='Declare_Local'>starttli</span><span class='Delimiter'>; 
</span><a name="LN10187"></a>    <a href="../../../include/pgtime.h.html#LN22"><span class='Ref_to_Typedef'>pg_time_t</span></a>   <span class='Declare_Local'>stamp_time</span><span class='Delimiter'>; 
</span><a name="LN10188"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>strfbuf</span><span class='Delimiter'>[</span><span class='Number'>128</span><span class='Delimiter'>]; 
</span><a name="LN10189"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>xlogfilename</span><span class='Delimiter'>[</span><a href="../../../include/access/xlog_internal.h.html#LN137"><span class='Ref_to_Const'>MAXFNAMELEN</span></a><span class='Delimiter'>]; 
</span><a name="LN10190"></a>    <a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a>   <span class='Declare_Local'>_logSegNo</span><span class='Delimiter'>; 
</span><a name="LN10191"></a>    <span class='Control'>struct</span> <a href="../../../include/port.h.html#LN275"><span class='Ref_to_Macro'>stat</span></a> <span class='Declare_Local'>stat_buf</span><span class='Delimiter'>; 
</span><a name="LN10192"></a>    FILE       <span class='Operator'>*</span><span class='Declare_Local'>fp</span><span class='Delimiter'>; 
</span> 
    <a href="xlog.c.html#LN10183"><span class='Ref_To_Local'>backup_started_in_recovery</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlog.h.html#LN242"><span class='Ref_to_Proto'>RecoveryInProgress</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Currently only non-exclusive backup can be taken during recovery. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN10183"><span class='Ref_To_Local'>backup_started_in_recovery</span></a> <span class='Operator'>&& </span><a href="xlog.c.html#LN10182"><span class='Ref_To_Local'>exclusive</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"recovery is in progress"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"WAL control functions cannot be executed during recovery."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * During recovery, we don't need to check WAL level. Because, if WAL 
     * level is not sufficient, it's impossible to get here during recovery. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN10183"><span class='Ref_To_Local'>backup_started_in_recovery</span></a> <span class='Operator'>&& !</span><a href="../../../include/access/xlog.h.html#LN144"><span class='Ref_to_Macro'>XLogIsNeeded</span></a><span class='Parentheses'>())</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>              <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"WAL level not sufficient for making an online backup"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"wal_level must be set to \"replica\" or \"logical\" at server start."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span>strlen<span class='Parentheses'>(</span><a href="xlog.c.html#LN10177"><span class='Ref_to_Parameter'>backupidstr</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT; </span><a href="../../../include/pg_config_manual.h.html#LN88"><span class='Ref_to_Const'>MAXPGPATH</span></a><span class='Parentheses'>)</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_INVALID_PARAMETER_VALUE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"backup label too long (max %d bytes)"</span><span class='Delimiter'>, 
</span>                        <a href="../../../include/pg_config_manual.h.html#LN88"><span class='Ref_to_Const'>MAXPGPATH</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Mark backup active in shared memory.  We must do full-page WAL writes 
     * during an on-line backup even if not doing so at other times, because 
     * it's quite possible for the backup dump to obtain a "torn" (partially 
     * written) copy of a database page if it reads the page concurrently with 
     * our write to the same page.  This can be fixed as long as the first 
     * write to the page in the WAL sequence is a full-page write. Hence, we 
     * turn on forcePageWrites and then force a CHECKPOINT, to ensure there 
     * are no dirty pages in shared memory that might get dumped while the 
     * backup is in progress without having a corresponding WAL record.  (Once 
     * the backup is complete, we need not force full-page writes anymore, 
     * since we expect that any pages not modified during the backup interval 
     * must have been correctly captured by the backup.) 
     * 
     * Note that forcePageWrites has no effect during an online backup from 
     * the standby. 
     * 
     * We must hold all the insertion locks to change the value of 
     * forcePageWrites, to ensure adequate interlocking against 
     * XLogInsertRecord(). 
     */ 
</span>    <a href="xlog.c.html#LN925"><span class='Ref_to_Proto'>WALInsertLockAcquireExclusive</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN10182"><span class='Ref_To_Local'>exclusive</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * At first, mark that we're now starting an exclusive backup, to 
         * ensure that there are no other sessions currently running 
         * pg_start_backup() or pg_stop_backup(). 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN574"><span class='Ref_to_Member'>Insert</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN559"><span class='Ref_to_Member'>exclusiveBackupState</span></a> <span class='Operator'>!= </span><a href="xlog.c.html#LN499"><span class='Ref_to_EnumConst'>EXCLUSIVE_BACKUP_NONE</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="xlog.c.html#LN926"><span class='Ref_to_Proto'>WALInsertLockRelease</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"a backup is already in progress"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"Run pg_stop_backup() and try again."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN574"><span class='Ref_to_Member'>Insert</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN559"><span class='Ref_to_Member'>exclusiveBackupState</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN500"><span class='Ref_to_EnumConst'>EXCLUSIVE_BACKUP_STARTING</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
        <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN574"><span class='Ref_to_Member'>Insert</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN560"><span class='Ref_to_Member'>nonExclusiveBackups</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN574"><span class='Ref_to_Member'>Insert</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN548"><span class='Ref_to_Member'>forcePageWrites</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN926"><span class='Ref_to_Proto'>WALInsertLockRelease</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Ensure we release forcePageWrites if fail below */ 
</span>    <a href="../../../include/storage/ipc.h.html#LN46"><span class='Ref_to_Macro'>PG_ENSURE_ERROR_CLEANUP</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN901"><span class='Ref_to_Proto'>pg_start_backup_callback</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>) </span><a href="../../../include/postgres.h.html#LN407"><span class='Ref_to_Macro'>BoolGetDatum</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10182"><span class='Ref_To_Local'>exclusive</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>{ 
</span><a name="LN10268"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>gotUniqueStartpoint</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN10269"></a>        <span class='Control'>struct</span> <a href="../../../include/port/win32_msvc/dirent.h.html#LN8"><span class='Ref_to_Struct'>dirent</span></a> <span class='Operator'>*</span><span class='Declare_Local'>de</span><span class='Delimiter'>; 
</span><a name="LN10270"></a>        <a href="../../../include/replication/basebackup.h.html#LN23"><span class='Ref_to_Typedef'>tablespaceinfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>ti</span><span class='Delimiter'>; 
</span><a name="LN10271"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>datadirpathlen</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Force an XLOG file switch before the checkpoint, to ensure that the 
         * WAL segment the checkpoint is written to doesn't contain pages with 
         * old timeline IDs.  That would otherwise happen if you called 
         * pg_start_backup() right after restoring from a PITR archive: the 
         * first WAL segment containing the startup checkpoint has pages in 
         * the beginning with the old timeline ID.  That can cause trouble at 
         * recovery: we won't have a history file covering the old timeline if 
         * pg_wal directory was not included in the base backup and the WAL 
         * archive was cleared too before starting the backup. 
         * 
         * This also ensures that we have emitted a WAL page header that has 
         * XLP_BKP_REMOVABLE off before we emit the checkpoint record. 
         * Therefore, if a WAL archiver (such as pglesslog) is trying to 
         * compress out removable backup blocks, it won't remove any that 
         * occur after this point. 
         * 
         * During recovery, we skip forcing XLOG file switch, which means that 
         * the backup taken during recovery is not available for the special 
         * recovery case described above. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN10183"><span class='Ref_To_Local'>backup_started_in_recovery</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/access/xlog_internal.h.html#LN290"><span class='Ref_to_Proto'>RequestXLogSwitch</span></a><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>do</span> 
        <span class='Delimiter'>{ 
</span><a name="LN10299"></a>            <span class='Keyword'>bool</span>        <span class='Declare_Local'>checkpointfpw</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Force a CHECKPOINT.  Aside from being necessary to prevent torn 
             * page problems, this guarantees that two successive backup runs 
             * will have different checkpoint positions and hence different 
             * history file names, even if nothing happened in between. 
             * 
             * During recovery, establish a restartpoint if possible. We use 
             * the last restartpoint as the backup starting checkpoint. This 
             * means that two successive backup runs can have same checkpoint 
             * positions. 
             * 
             * Since the fact that we are executing do_pg_start_backup() 
             * during recovery means that checkpointer is running, we can use 
             * RequestCheckpoint() to establish a restartpoint. 
             * 
             * We use CHECKPOINT_IMMEDIATE only if requested by user (via 
             * passing fast = true).  Otherwise this can take awhile. 
             */ 
</span>            <a href="../../../include/postmaster/bgwriter.h.html#LN30"><span class='Ref_to_Proto'>RequestCheckpoint</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN179"><span class='Ref_to_Const'>CHECKPOINT_FORCE</span></a> <span class='Operator'>| </span><a href="../../../include/access/xlog.h.html#LN183"><span class='Ref_to_Const'>CHECKPOINT_WAIT</span></a> <span class='Operator'>| 
</span>                              <span class='Parentheses'>(</span><a href="xlog.c.html#LN10177"><span class='Ref_to_Parameter'>fast</span></a> <span class='Operator'>? </span><a href="../../../include/access/xlog.h.html#LN178"><span class='Ref_to_Const'>CHECKPOINT_IMMEDIATE</span></a> <span class='Operator'>: </span><span class='Number'>0</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Now we need to fetch the checkpoint record location, and also 
             * its REDO pointer.  The oldest point in WAL that would be needed 
             * to restore starting from the checkpoint is precisely the REDO 
             * pointer. 
             */ 
</span>            <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ControlFileLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN10184"><span class='Ref_To_Local'>checkpointloc</span></a> <span class='Operator'>= </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN131"><span class='Ref_to_Member'>checkPoint</span></a><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN10185"><span class='Ref_To_Local'>startpoint</span></a> <span class='Operator'>= </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN134"><span class='Ref_to_Member'>checkPointCopy</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN34"><span class='Ref_to_Member'>redo</span></a><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN10186"><span class='Ref_To_Local'>starttli</span></a> <span class='Operator'>= </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN134"><span class='Ref_to_Member'>checkPointCopy</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN36"><span class='Ref_to_Member'>ThisTimeLineID</span></a><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN10299"><span class='Ref_To_Local'>checkpointfpw</span></a> <span class='Operator'>= </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN134"><span class='Ref_to_Member'>checkPointCopy</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN39"><span class='Ref_to_Member'>fullPageWrites</span></a><span class='Delimiter'>; 
</span>            <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ControlFileLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN10183"><span class='Ref_To_Local'>backup_started_in_recovery</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN10337"></a>                <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>recptr</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * Check to see if all WAL replayed during online backup 
                 * (i.e., since last restartpoint used as backup starting 
                 * checkpoint) contain full-page writes. 
                 */ 
</span>                <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="xlog.c.html#LN10337"><span class='Ref_To_Local'>recptr</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN700"><span class='Ref_to_Member'>lastFpwDisableRecPtr</span></a><span class='Delimiter'>; 
</span>                <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN10299"><span class='Ref_To_Local'>checkpointfpw</span></a> <span class='Operator'>|| </span><a href="xlog.c.html#LN10185"><span class='Ref_To_Local'>startpoint</span></a> <span class='Operator'>&LT;= </span><a href="xlog.c.html#LN10337"><span class='Ref_To_Local'>recptr</span></a><span class='Parentheses'>) 
</span>                    <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                          <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                           <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"WAL generated with full_page_writes=off was replayed "</span> 
                                  <span class='String'>"since last restartpoint"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                           <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"This means that the backup being taken on the standby "</span> 
                                   <span class='String'>"is corrupt and should not be used. "</span> 
                                   <span class='String'>"Enable full_page_writes and run CHECKPOINT on the master, "</span> 
                                   <span class='String'>"and then try an online backup again."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * During recovery, since we don't use the end-of-backup WAL 
                 * record and don't write the backup history file, the 
                 * starting WAL location doesn't need to be unique. This means 
                 * that two base backups started at the same time might use 
                 * the same checkpoint as starting locations. 
                 */ 
</span>                <a href="xlog.c.html#LN10268"><span class='Ref_To_Local'>gotUniqueStartpoint</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if backup_started_in_rec... &raquo; </span> 
 
            <span class='Comment_Multi_Line'>/* 
             * If two base backups are started at the same time (in WAL sender 
             * processes), we need to make sure that they use different 
             * checkpoints as starting locations, because we use the starting 
             * WAL location as a unique identifier for the base backup in the 
             * end-of-backup WAL record and when we write the backup history 
             * file. Perhaps it would be better generate a separate unique ID 
             * for each backup instead of forcing another checkpoint, but 
             * taking a checkpoint right after another is not that expensive 
             * either because only few buffers have been dirtied yet. 
             */ 
</span>            <a href="xlog.c.html#LN925"><span class='Ref_to_Proto'>WALInsertLockAcquireExclusive</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN574"><span class='Ref_to_Member'>Insert</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN561"><span class='Ref_to_Member'>lastBackupStart</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN10185"><span class='Ref_To_Local'>startpoint</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN574"><span class='Ref_to_Member'>Insert</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN561"><span class='Ref_to_Member'>lastBackupStart</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN10185"><span class='Ref_To_Local'>startpoint</span></a><span class='Delimiter'>; 
</span>                <a href="xlog.c.html#LN10268"><span class='Ref_To_Local'>gotUniqueStartpoint</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <a href="xlog.c.html#LN926"><span class='Ref_to_Proto'>WALInsertLockRelease</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end do &raquo; </span> <span class='Control'>while</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN10268"><span class='Ref_To_Local'>gotUniqueStartpoint</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/access/xlog_internal.h.html#LN105"><span class='Ref_to_Macro'>XLByteToSeg</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10185"><span class='Ref_To_Local'>startpoint</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN10190"><span class='Ref_To_Local'>_logSegNo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/access/xlog_internal.h.html#LN142"><span class='Ref_to_Macro'>XLogFileName</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10189"><span class='Ref_To_Local'>xlogfilename</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN10186"><span class='Ref_To_Local'>starttli</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN10190"><span class='Ref_To_Local'>_logSegNo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Construct tablespace_map file 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN10182"><span class='Ref_To_Local'>exclusive</span></a><span class='Parentheses'>) 
</span>            <a href="xlog.c.html#LN10179"><span class='Ref_to_Parameter'>tblspcmapfile</span></a> <span class='Operator'>= </span><a href="../../lib/stringinfo.c.html#LN26"><span class='Ref_to_Func'>makeStringInfo</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <a href="xlog.c.html#LN10271"><span class='Ref_To_Local'>datadirpathlen</span></a> <span class='Operator'>= </span>strlen<span class='Parentheses'>(</span><a href="../../utils/init/globals.c.html#LN59"><span class='Ref_to_Global_Var'>DataDir</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Collect information about all tablespaces */ 
</span>        <span class='Control'>while</span> <span class='Parentheses'>((</span><a href="xlog.c.html#LN10269"><span class='Ref_To_Local'>de</span></a> <span class='Operator'>= </span><a href="../../../include/storage/fd.h.html#LN92"><span class='Ref_to_Proto'>ReadDir</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10178"><span class='Ref_to_Parameter'>tblspcdir</span></a><span class='Delimiter'>, </span><span class='String'>"pg_tblspc"</span><span class='Parentheses'>))</span> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span><a name="LN10402"></a>            <span class='Keyword'>char</span>        <span class='Declare_Local'>fullpath</span><span class='Delimiter'>[</span><a href="../../../include/pg_config_manual.h.html#LN88"><span class='Ref_to_Const'>MAXPGPATH</span></a> <span class='Operator'>+ </span><span class='Number'>10</span><span class='Delimiter'>]; 
</span><a name="LN10403"></a>            <span class='Keyword'>char</span>        <span class='Declare_Local'>linkpath</span><span class='Delimiter'>[</span><a href="../../../include/pg_config_manual.h.html#LN88"><span class='Ref_to_Const'>MAXPGPATH</span></a><span class='Delimiter'>]; 
</span><a name="LN10404"></a>            <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>relpath</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN10405"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>rllen</span><span class='Delimiter'>; 
</span><a name="LN10406"></a>            <a href="../../../include/lib/stringinfo.h.html#LN34"><span class='Ref_to_Struct'>StringInfoData</span></a> <span class='Declare_Local'>buflinkpath</span><span class='Delimiter'>; 
</span><a name="LN10407"></a>            <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>s</span> <span class='Operator'>= </span><a href="xlog.c.html#LN10403"><span class='Ref_To_Local'>linkpath</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Skip special stuff */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span><a href="xlog.c.html#LN10269"><span class='Ref_To_Local'>de</span></a><span class='Operator'>-&GT;</span><a href="../../../include/port/win32_msvc/dirent.h.html#LN13"><span class='Ref_to_Member'>d_name</span></a><span class='Delimiter'>, </span><span class='String'>"."</span><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span> <span class='Operator'>|| </span>strcmp<span class='Parentheses'>(</span><a href="xlog.c.html#LN10269"><span class='Ref_To_Local'>de</span></a><span class='Operator'>-&GT;</span><a href="../../../include/port/win32_msvc/dirent.h.html#LN13"><span class='Ref_to_Member'>d_name</span></a><span class='Delimiter'>, </span><span class='String'>".."</span><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
            <a href="../../../pl/plperl/plperl.h.html#LN60"><span class='Ref_to_Macro'>snprintf</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10402"><span class='Ref_To_Local'>fullpath</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN10402"><span class='Ref_To_Local'>fullpath</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='String'>"pg_tblspc/%s"</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN10269"><span class='Ref_To_Local'>de</span></a><span class='Operator'>-&GT;</span><a href="../../../include/port/win32_msvc/dirent.h.html#LN13"><span class='Ref_to_Member'>d_name</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#if</span> defined<span class='Parentheses'>(</span>HAVE_READLINK<span class='Parentheses'>) </span><span class='Operator'>|| </span>defined<span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN61"><span class='Ref_to_Const'>WIN32</span></a><span class='Parentheses'>) 
</span>            <a href="xlog.c.html#LN10405"><span class='Ref_To_Local'>rllen</span></a> <span class='Operator'>= </span><a href="../../../include/port.h.html#LN256"><span class='Ref_to_Macro'>readlink</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10402"><span class='Ref_To_Local'>fullpath</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN10403"><span class='Ref_To_Local'>linkpath</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN10403"><span class='Ref_To_Local'>linkpath</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN10405"><span class='Ref_To_Local'>rllen</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN39"><span class='Ref_to_Const'>WARNING</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not read symbolic link \"%s\": %m"</span><span class='Delimiter'>, 
</span>                                <a href="xlog.c.html#LN10402"><span class='Ref_To_Local'>fullpath</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                <span class='Control'>continue</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN10405"><span class='Ref_To_Local'>rllen</span></a> <span class='Operator'>&GT;= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN10403"><span class='Ref_To_Local'>linkpath</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN39"><span class='Ref_to_Const'>WARNING</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"symbolic link \"%s\" target is too long"</span><span class='Delimiter'>, 
</span>                                <a href="xlog.c.html#LN10402"><span class='Ref_To_Local'>fullpath</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                <span class='Control'>continue</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <a href="xlog.c.html#LN10403"><span class='Ref_To_Local'>linkpath</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN10405"><span class='Ref_To_Local'>rllen</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='String'>'\0'</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Add the escape character '\\' before newline in a string to 
             * ensure that we can distinguish between the newline in the 
             * tablespace path and end of line while reading tablespace_map 
             * file during archive recovery. 
             */ 
</span>            <a href="../../lib/stringinfo.c.html#LN44"><span class='Ref_to_Func'>initStringInfo</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN10406"><span class='Ref_To_Local'>buflinkpath</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>while</span> <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="xlog.c.html#LN10407"><span class='Ref_To_Local'>s</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>((</span><span class='Operator'>*</span><a href="xlog.c.html#LN10407"><span class='Ref_To_Local'>s</span></a> <span class='Operator'>== </span><span class='String'>'\n'</span> <span class='Operator'>|| *</span><a href="xlog.c.html#LN10407"><span class='Ref_To_Local'>s</span></a> <span class='Operator'>== </span><span class='String'>'\r'</span><span class='Parentheses'>) </span><span class='Operator'>&& </span><a href="xlog.c.html#LN10180"><span class='Ref_to_Parameter'>needtblspcmapfile</span></a><span class='Parentheses'>)</span> 
                    <a href="../../replication/syncrep_scanner.l.html#LN76"><span class='Ref_to_Proto'>appendStringInfoChar</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN10406"><span class='Ref_To_Local'>buflinkpath</span></a><span class='Delimiter'>, </span><span class='String'>'\\'</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="../../replication/syncrep_scanner.l.html#LN76"><span class='Ref_to_Proto'>appendStringInfoChar</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN10406"><span class='Ref_To_Local'>buflinkpath</span></a><span class='Delimiter'>, </span><span class='Operator'>*</span><a href="xlog.c.html#LN10407"><span class='Ref_To_Local'>s</span></a><span class='Operator'>++</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
 
            <span class='Comment_Multi_Line'>/* 
             * Relpath holds the relative path of the tablespace directory 
             * when it's located within PGDATA, or NULL if it's located 
             * elsewhere. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN10405"><span class='Ref_To_Local'>rllen</span></a> <span class='Operator'>&GT; </span><a href="xlog.c.html#LN10271"><span class='Ref_To_Local'>datadirpathlen</span></a> <span class='Operator'>&& 
</span>                strncmp<span class='Parentheses'>(</span><a href="xlog.c.html#LN10403"><span class='Ref_To_Local'>linkpath</span></a><span class='Delimiter'>, </span><a href="../../utils/init/globals.c.html#LN59"><span class='Ref_to_Global_Var'>DataDir</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN10271"><span class='Ref_To_Local'>datadirpathlen</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span> <span class='Operator'>&& 
</span>                <a href="../../../include/port.h.html#LN74"><span class='Ref_to_Macro'>IS_DIR_SEP</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10403"><span class='Ref_To_Local'>linkpath</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN10271"><span class='Ref_To_Local'>datadirpathlen</span></a><span class='Delimiter'>]</span><span class='Parentheses'>))</span> 
                <a href="xlog.c.html#LN10404"><span class='Ref_To_Local'>relpath</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN10403"><span class='Ref_To_Local'>linkpath</span></a> <span class='Operator'>+ </span><a href="xlog.c.html#LN10271"><span class='Ref_To_Local'>datadirpathlen</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
            <a href="xlog.c.html#LN10270"><span class='Ref_To_Local'>ti</span></a> <span class='Operator'>= </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/replication/basebackup.h.html#LN23"><span class='Ref_to_Typedef'>tablespaceinfo</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN10270"><span class='Ref_To_Local'>ti</span></a><span class='Operator'>-&GT;</span><a href="../../../include/replication/basebackup.h.html#LN25"><span class='Ref_to_Member'>oid</span></a> <span class='Operator'>= </span><a href="../../../include/common/fe_memutils.h.html#LN32"><span class='Ref_to_Proto'>pstrdup</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10269"><span class='Ref_To_Local'>de</span></a><span class='Operator'>-&GT;</span><a href="../../../include/port/win32_msvc/dirent.h.html#LN13"><span class='Ref_to_Member'>d_name</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN10270"><span class='Ref_To_Local'>ti</span></a><span class='Operator'>-&GT;</span><a href="../../../include/replication/basebackup.h.html#LN26"><span class='Ref_to_Member'>path</span></a> <span class='Operator'>= </span><a href="../../../include/common/fe_memutils.h.html#LN32"><span class='Ref_to_Proto'>pstrdup</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10406"><span class='Ref_To_Local'>buflinkpath</span></a><span class='Operator'>.</span><a href="../../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN10270"><span class='Ref_To_Local'>ti</span></a><span class='Operator'>-&GT;</span><a href="../../../include/replication/basebackup.h.html#LN27"><span class='Ref_to_Member'>rpath</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN10404"><span class='Ref_To_Local'>relpath</span></a> <span class='Operator'>? </span><a href="../../../include/common/fe_memutils.h.html#LN32"><span class='Ref_to_Proto'>pstrdup</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10404"><span class='Ref_To_Local'>relpath</span></a><span class='Parentheses'>) </span><span class='Operator'>: </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN10270"><span class='Ref_To_Local'>ti</span></a><span class='Operator'>-&GT;</span><a href="../../../include/replication/basebackup.h.html#LN28"><span class='Ref_to_Member'>size</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN10179"><span class='Ref_to_Parameter'>infotbssize</span></a> <span class='Operator'>? </span><a href="../../../include/replication/basebackup.h.html#LN33"><span class='Ref_to_Proto'>sendTablespace</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10402"><span class='Ref_To_Local'>fullpath</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>) </span><span class='Operator'>: -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN10178"><span class='Ref_to_Parameter'>tablespaces</span></a><span class='Parentheses'>) 
</span>                <span class='Operator'>*</span><a href="xlog.c.html#LN10178"><span class='Ref_to_Parameter'>tablespaces</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="xlog.c.html#LN10178"><span class='Ref_to_Parameter'>tablespaces</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN10270"><span class='Ref_To_Local'>ti</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="../../../bin/pg_waldump/compat.c.html#LN69"><span class='Ref_to_Func'>appendStringInfo</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10179"><span class='Ref_to_Parameter'>tblspcmapfile</span></a><span class='Delimiter'>, </span><span class='String'>"%s %s\n"</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN10270"><span class='Ref_To_Local'>ti</span></a><span class='Operator'>-&GT;</span><a href="../../../include/replication/basebackup.h.html#LN25"><span class='Ref_to_Member'>oid</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN10270"><span class='Ref_To_Local'>ti</span></a><span class='Operator'>-&GT;</span><a href="../../../include/replication/basebackup.h.html#LN26"><span class='Ref_to_Member'>path</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10406"><span class='Ref_To_Local'>buflinkpath</span></a><span class='Operator'>.</span><a href="../../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#else</span> 
 
            <span class='Comment_Multi_Line'>/* 
             * If the platform does not have symbolic links, it should not be 
             * possible to have tablespaces - clearly somebody else created 
             * them. Warn about it and ignore. 
             */ 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN39"><span class='Ref_to_Const'>WARNING</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                  <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"tablespaces are not supported on this platform"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while (de=ReadDir(tblspcdir... &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* 
         * Construct backup label file 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN10182"><span class='Ref_To_Local'>exclusive</span></a><span class='Parentheses'>) 
</span>            <a href="xlog.c.html#LN10178"><span class='Ref_to_Parameter'>labelfile</span></a> <span class='Operator'>= </span><a href="../../lib/stringinfo.c.html#LN26"><span class='Ref_to_Func'>makeStringInfo</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Use the log timezone here, not the session timezone */ 
</span>        <a href="xlog.c.html#LN10187"><span class='Ref_To_Local'>stamp_time</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/pgtime.h.html#LN22"><span class='Ref_to_Typedef'>pg_time_t</span></a><span class='Parentheses'>) </span>time<span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/pgtime.h.html#LN67"><span class='Ref_to_Proto'>pg_strftime</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10188"><span class='Ref_To_Local'>strfbuf</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN10188"><span class='Ref_To_Local'>strfbuf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                    <span class='String'>"%Y-%m-%d %H:%M:%S %Z"</span><span class='Delimiter'>, 
</span>                    <a href="../../../include/pgtime.h.html#LN47"><span class='Ref_to_Proto'>pg_localtime</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN10187"><span class='Ref_To_Local'>stamp_time</span></a><span class='Delimiter'>, </span><a href="../../../timezone/pgtz.c.html#LN30"><span class='Ref_to_Global_Var'>log_timezone</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="../../../bin/pg_waldump/compat.c.html#LN69"><span class='Ref_to_Func'>appendStringInfo</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10178"><span class='Ref_to_Parameter'>labelfile</span></a><span class='Delimiter'>, </span><span class='String'>"START WAL LOCATION: %X/%X (file %s)\n"</span><span class='Delimiter'>, 
</span>             <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN10185"><span class='Ref_To_Local'>startpoint</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN10185"><span class='Ref_To_Local'>startpoint</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN10189"><span class='Ref_To_Local'>xlogfilename</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../bin/pg_waldump/compat.c.html#LN69"><span class='Ref_to_Func'>appendStringInfo</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10178"><span class='Ref_to_Parameter'>labelfile</span></a><span class='Delimiter'>, </span><span class='String'>"CHECKPOINT LOCATION: %X/%X\n"</span><span class='Delimiter'>, 
</span>                     <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN10184"><span class='Ref_To_Local'>checkpointloc</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN10184"><span class='Ref_To_Local'>checkpointloc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../bin/pg_waldump/compat.c.html#LN69"><span class='Ref_to_Func'>appendStringInfo</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10178"><span class='Ref_to_Parameter'>labelfile</span></a><span class='Delimiter'>, </span><span class='String'>"BACKUP METHOD: %s\n"</span><span class='Delimiter'>, 
</span>                         <a href="xlog.c.html#LN10182"><span class='Ref_To_Local'>exclusive</span></a> <span class='Operator'>? </span><span class='String'>"pg_start_backup"</span> <span class='Operator'>: </span><span class='String'>"streamed"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../bin/pg_waldump/compat.c.html#LN69"><span class='Ref_to_Func'>appendStringInfo</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10178"><span class='Ref_to_Parameter'>labelfile</span></a><span class='Delimiter'>, </span><span class='String'>"BACKUP FROM: %s\n"</span><span class='Delimiter'>, 
</span>                         <a href="xlog.c.html#LN10183"><span class='Ref_To_Local'>backup_started_in_recovery</span></a> <span class='Operator'>? </span><span class='String'>"standby"</span> <span class='Operator'>: </span><span class='String'>"master"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../bin/pg_waldump/compat.c.html#LN69"><span class='Ref_to_Func'>appendStringInfo</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10178"><span class='Ref_to_Parameter'>labelfile</span></a><span class='Delimiter'>, </span><span class='String'>"START TIME: %s\n"</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN10188"><span class='Ref_To_Local'>strfbuf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../bin/pg_waldump/compat.c.html#LN69"><span class='Ref_to_Func'>appendStringInfo</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10178"><span class='Ref_to_Parameter'>labelfile</span></a><span class='Delimiter'>, </span><span class='String'>"LABEL: %s\n"</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN10177"><span class='Ref_to_Parameter'>backupidstr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Okay, write the file, or return its contents to caller. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN10182"><span class='Ref_To_Local'>exclusive</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Check for existing backup label --- implies a backup is already 
             * running.  (XXX given that we checked exclusiveBackupState 
             * above, maybe it would be OK to just unlink any such label 
             * file?) 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/port.h.html#LN275"><span class='Ref_to_Macro'>stat</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN320"><span class='Ref_to_Const'>BACKUP_LABEL_FILE</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN10191"><span class='Ref_To_Local'>stat_buf</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span>errno <span class='Operator'>!= </span>ENOENT<span class='Parentheses'>) 
</span>                    <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                            <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                             <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not stat file \"%s\": %m"</span><span class='Delimiter'>, 
</span>                                    <a href="../../../include/access/xlog.h.html#LN320"><span class='Ref_to_Const'>BACKUP_LABEL_FILE</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"a backup is already in progress"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"If you're sure there is no backup in progress, remove file \"%s\" and try again."</span><span class='Delimiter'>, 
</span>                                 <a href="../../../include/access/xlog.h.html#LN320"><span class='Ref_to_Const'>BACKUP_LABEL_FILE</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
            <a href="xlog.c.html#LN10192"><span class='Ref_To_Local'>fp</span></a> <span class='Operator'>= </span><a href="../../../include/storage/fd.h.html#LN83"><span class='Ref_to_Proto'>AllocateFile</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN320"><span class='Ref_to_Const'>BACKUP_LABEL_FILE</span></a><span class='Delimiter'>, </span><span class='String'>"w"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN10192"><span class='Ref_To_Local'>fp</span></a><span class='Parentheses'>) 
</span>                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                         <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not create file \"%s\": %m"</span><span class='Delimiter'>, 
</span>                                <a href="../../../include/access/xlog.h.html#LN320"><span class='Ref_to_Const'>BACKUP_LABEL_FILE</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span>fwrite<span class='Parentheses'>(</span><a href="xlog.c.html#LN10178"><span class='Ref_to_Parameter'>labelfile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN10178"><span class='Ref_to_Parameter'>labelfile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/lib/stringinfo.h.html#LN37"><span class='Ref_to_Member'>len</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN10192"><span class='Ref_To_Local'>fp</span></a><span class='Parentheses'>)</span> <span class='Operator'>!= </span><span class='Number'>1</span> <span class='Operator'>|| 
</span>                fflush<span class='Parentheses'>(</span><a href="xlog.c.html#LN10192"><span class='Ref_To_Local'>fp</span></a><span class='Parentheses'>)</span> <span class='Operator'>!= </span><span class='Number'>0</span> <span class='Operator'>|| 
</span>                <a href="../../../include/storage/fd.h.html#LN114"><span class='Ref_to_Proto'>pg_fsync</span></a><span class='Parentheses'>(</span>fileno<span class='Parentheses'>(</span><a href="xlog.c.html#LN10192"><span class='Ref_To_Local'>fp</span></a><span class='Parentheses'>))</span> <span class='Operator'>!= </span><span class='Number'>0</span> <span class='Operator'>|| 
</span>                ferror<span class='Parentheses'>(</span><a href="xlog.c.html#LN10192"><span class='Ref_To_Local'>fp</span></a><span class='Parentheses'>)</span> <span class='Operator'>|| 
</span>                <a href="../../../include/storage/fd.h.html#LN84"><span class='Ref_to_Proto'>FreeFile</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10192"><span class='Ref_To_Local'>fp</span></a><span class='Parentheses'>))</span> 
                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                         <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not write file \"%s\": %m"</span><span class='Delimiter'>, 
</span>                                <a href="../../../include/access/xlog.h.html#LN320"><span class='Ref_to_Const'>BACKUP_LABEL_FILE</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* Allocated locally for exclusive backups, so free separately */ 
</span>            <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10178"><span class='Ref_to_Parameter'>labelfile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10178"><span class='Ref_to_Parameter'>labelfile</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Write backup tablespace_map file. */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN10179"><span class='Ref_to_Parameter'>tblspcmapfile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/lib/stringinfo.h.html#LN37"><span class='Ref_to_Member'>len</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/port.h.html#LN275"><span class='Ref_to_Macro'>stat</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN323"><span class='Ref_to_Const'>TABLESPACE_MAP</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN10191"><span class='Ref_To_Local'>stat_buf</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span>errno <span class='Operator'>!= </span>ENOENT<span class='Parentheses'>) 
</span>                        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not stat file \"%s\": %m"</span><span class='Delimiter'>, 
</span>                                        <a href="../../../include/access/xlog.h.html#LN323"><span class='Ref_to_Const'>TABLESPACE_MAP</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>else</span> 
                    <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                          <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                           <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"a backup is already in progress"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                           <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"If you're sure there is no backup in progress, remove file \"%s\" and try again."</span><span class='Delimiter'>, 
</span>                                   <a href="../../../include/access/xlog.h.html#LN323"><span class='Ref_to_Const'>TABLESPACE_MAP</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
                <a href="xlog.c.html#LN10192"><span class='Ref_To_Local'>fp</span></a> <span class='Operator'>= </span><a href="../../../include/storage/fd.h.html#LN83"><span class='Ref_to_Proto'>AllocateFile</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN323"><span class='Ref_to_Const'>TABLESPACE_MAP</span></a><span class='Delimiter'>, </span><span class='String'>"w"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN10192"><span class='Ref_To_Local'>fp</span></a><span class='Parentheses'>) 
</span>                    <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                            <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                             <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not create file \"%s\": %m"</span><span class='Delimiter'>, 
</span>                                    <a href="../../../include/access/xlog.h.html#LN323"><span class='Ref_to_Const'>TABLESPACE_MAP</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span>fwrite<span class='Parentheses'>(</span><a href="xlog.c.html#LN10179"><span class='Ref_to_Parameter'>tblspcmapfile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN10179"><span class='Ref_to_Parameter'>tblspcmapfile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/lib/stringinfo.h.html#LN37"><span class='Ref_to_Member'>len</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN10192"><span class='Ref_To_Local'>fp</span></a><span class='Parentheses'>)</span> <span class='Operator'>!= </span><span class='Number'>1</span> <span class='Operator'>|| 
</span>                    fflush<span class='Parentheses'>(</span><a href="xlog.c.html#LN10192"><span class='Ref_To_Local'>fp</span></a><span class='Parentheses'>)</span> <span class='Operator'>!= </span><span class='Number'>0</span> <span class='Operator'>|| 
</span>                    <a href="../../../include/storage/fd.h.html#LN114"><span class='Ref_to_Proto'>pg_fsync</span></a><span class='Parentheses'>(</span>fileno<span class='Parentheses'>(</span><a href="xlog.c.html#LN10192"><span class='Ref_To_Local'>fp</span></a><span class='Parentheses'>))</span> <span class='Operator'>!= </span><span class='Number'>0</span> <span class='Operator'>|| 
</span>                    ferror<span class='Parentheses'>(</span><a href="xlog.c.html#LN10192"><span class='Ref_To_Local'>fp</span></a><span class='Parentheses'>)</span> <span class='Operator'>|| 
</span>                    <a href="../../../include/storage/fd.h.html#LN84"><span class='Ref_to_Proto'>FreeFile</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10192"><span class='Ref_To_Local'>fp</span></a><span class='Parentheses'>))</span> 
                    <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                            <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                             <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not write file \"%s\": %m"</span><span class='Delimiter'>, 
</span>                                    <a href="../../../include/access/xlog.h.html#LN323"><span class='Ref_to_Const'>TABLESPACE_MAP</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if tblspcmapfile-&GT;len&GT;0 &raquo; </span> 
 
            <span class='Comment_Multi_Line'>/* Allocated locally for exclusive backups, so free separately */ 
</span>            <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10179"><span class='Ref_to_Parameter'>tblspcmapfile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10179"><span class='Ref_to_Parameter'>tblspcmapfile</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if exclusive &raquo; </span> 
    <span class='Delimiter'>} 
</span>    <a href="../../../include/storage/ipc.h.html#LN51"><span class='Ref_to_Macro'>PG_END_ENSURE_ERROR_CLEANUP</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN901"><span class='Ref_to_Proto'>pg_start_backup_callback</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>) </span><a href="../../../include/postgres.h.html#LN407"><span class='Ref_to_Macro'>BoolGetDatum</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10182"><span class='Ref_To_Local'>exclusive</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Mark that start phase has correctly finished for an exclusive backup. 
     * Session-level locks are updated as well to reflect that state. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN10182"><span class='Ref_To_Local'>exclusive</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="xlog.c.html#LN925"><span class='Ref_to_Proto'>WALInsertLockAcquireExclusive</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN574"><span class='Ref_to_Member'>Insert</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN559"><span class='Ref_to_Member'>exclusiveBackupState</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN501"><span class='Ref_to_EnumConst'>EXCLUSIVE_BACKUP_IN_PROGRESS</span></a><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN926"><span class='Ref_to_Proto'>WALInsertLockRelease</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN509"><span class='Ref_to_Global_Var'>sessionBackupState</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlog.h.html#LN306"><span class='Ref_to_EnumConst'>SESSION_BACKUP_EXCLUSIVE</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
        <a href="xlog.c.html#LN509"><span class='Ref_to_Global_Var'>sessionBackupState</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlog.h.html#LN307"><span class='Ref_to_EnumConst'>SESSION_BACKUP_NON_EXCLUSIVE</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We're done.  As a convenience, return the starting WAL location. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN10177"><span class='Ref_to_Parameter'>starttli_p</span></a><span class='Parentheses'>) 
</span>        <span class='Operator'>*</span><a href="xlog.c.html#LN10177"><span class='Ref_to_Parameter'>starttli_p</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN10186"><span class='Ref_To_Local'>starttli</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="xlog.c.html#LN10185"><span class='Ref_To_Local'>startpoint</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end do_pg_start_backup &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* Error cleanup callback for pg_start_backup */ 
</span><span class='Keyword'>static void 
</span><a name="LN10619"></a><span class='Declare_Function'>pg_start_backup_callback</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>code</span><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>arg</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN10621"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>exclusive</span> <span class='Operator'>= </span><a href="../../../include/postgres.h.html#LN398"><span class='Ref_to_Macro'>DatumGetBool</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10619"><span class='Ref_to_Parameter'>arg</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Update backup counters and forcePageWrites on failure */ 
</span>    <a href="xlog.c.html#LN925"><span class='Ref_to_Proto'>WALInsertLockAcquireExclusive</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN10621"><span class='Ref_To_Local'>exclusive</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN574"><span class='Ref_to_Member'>Insert</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN559"><span class='Ref_to_Member'>exclusiveBackupState</span></a> <span class='Operator'>== </span><a href="xlog.c.html#LN500"><span class='Ref_to_EnumConst'>EXCLUSIVE_BACKUP_STARTING</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN574"><span class='Ref_to_Member'>Insert</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN559"><span class='Ref_to_Member'>exclusiveBackupState</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN499"><span class='Ref_to_EnumConst'>EXCLUSIVE_BACKUP_NONE</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN574"><span class='Ref_to_Member'>Insert</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN560"><span class='Ref_to_Member'>nonExclusiveBackups</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN574"><span class='Ref_to_Member'>Insert</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN560"><span class='Ref_to_Member'>nonExclusiveBackups</span></a><span class='Operator'>--</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN574"><span class='Ref_to_Member'>Insert</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN559"><span class='Ref_to_Member'>exclusiveBackupState</span></a> <span class='Operator'>== </span><a href="xlog.c.html#LN499"><span class='Ref_to_EnumConst'>EXCLUSIVE_BACKUP_NONE</span></a> <span class='Operator'>&& 
</span>        <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN574"><span class='Ref_to_Member'>Insert</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN560"><span class='Ref_to_Member'>nonExclusiveBackups</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN574"><span class='Ref_to_Member'>Insert</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN548"><span class='Ref_to_Member'>forcePageWrites</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="xlog.c.html#LN926"><span class='Ref_to_Proto'>WALInsertLockRelease</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end pg_start_backup_callback &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Error cleanup callback for pg_stop_backup 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN10648"></a><span class='Declare_Function'>pg_stop_backup_callback</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>code</span><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>arg</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN10650"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>exclusive</span> <span class='Operator'>= </span><a href="../../../include/postgres.h.html#LN398"><span class='Ref_to_Macro'>DatumGetBool</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10648"><span class='Ref_to_Parameter'>arg</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Update backup status on failure */ 
</span>    <a href="xlog.c.html#LN925"><span class='Ref_to_Proto'>WALInsertLockAcquireExclusive</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN10650"><span class='Ref_To_Local'>exclusive</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN574"><span class='Ref_to_Member'>Insert</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN559"><span class='Ref_to_Member'>exclusiveBackupState</span></a> <span class='Operator'>== </span><a href="xlog.c.html#LN502"><span class='Ref_to_EnumConst'>EXCLUSIVE_BACKUP_STOPPING</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN574"><span class='Ref_to_Member'>Insert</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN559"><span class='Ref_to_Member'>exclusiveBackupState</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN501"><span class='Ref_to_EnumConst'>EXCLUSIVE_BACKUP_IN_PROGRESS</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="xlog.c.html#LN926"><span class='Ref_to_Proto'>WALInsertLockRelease</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Utility routine to fetch the session-level status of a backup running. 
 */ 
</span><a href="../../../include/access/xlog.h.html#LN303"><span class='Ref_to_Enum'>SessionBackupState</span></a> 
<a name="LN10666"></a><span class='Declare_Function'>get_backup_status</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <a href="xlog.c.html#LN509"><span class='Ref_to_Global_Var'>sessionBackupState</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * do_pg_stop_backup is the workhorse of the user-visible pg_stop_backup() 
 * function. 
 * 
 * If labelfile is NULL, this stops an exclusive backup. Otherwise this stops 
 * the non-exclusive backup specified by 'labelfile'. 
 * 
 * Returns the last WAL location that must be present to restore from this 
 * backup, and the corresponding timeline ID in *stoptli_p. 
 * 
 * It is the responsibility of the caller of this function to verify the 
 * permissions of the calling user! 
 */ 
</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> 
<a name="LN10685"></a><span class='Declare_Function'>do_pg_stop_backup</span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Declare_Parameter'>labelfile</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>waitforarchive</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stoptli_p</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN10687"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>exclusive</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="xlog.c.html#LN10685"><span class='Ref_to_Parameter'>labelfile</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN10688"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>backup_started_in_recovery</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN10689"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>startpoint</span><span class='Delimiter'>; 
</span><a name="LN10690"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>stoppoint</span><span class='Delimiter'>; 
</span><a name="LN10691"></a>    <a href="../../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a>  <span class='Declare_Local'>stoptli</span><span class='Delimiter'>; 
</span><a name="LN10692"></a>    <a href="../../../include/pgtime.h.html#LN22"><span class='Ref_to_Typedef'>pg_time_t</span></a>   <span class='Declare_Local'>stamp_time</span><span class='Delimiter'>; 
</span><a name="LN10693"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>strfbuf</span><span class='Delimiter'>[</span><span class='Number'>128</span><span class='Delimiter'>]; 
</span><a name="LN10694"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>histfilepath</span><span class='Delimiter'>[</span><a href="../../../include/pg_config_manual.h.html#LN88"><span class='Ref_to_Const'>MAXPGPATH</span></a><span class='Delimiter'>]; 
</span><a name="LN10695"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>startxlogfilename</span><span class='Delimiter'>[</span><a href="../../../include/access/xlog_internal.h.html#LN137"><span class='Ref_to_Const'>MAXFNAMELEN</span></a><span class='Delimiter'>]; 
</span><a name="LN10696"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>stopxlogfilename</span><span class='Delimiter'>[</span><a href="../../../include/access/xlog_internal.h.html#LN137"><span class='Ref_to_Const'>MAXFNAMELEN</span></a><span class='Delimiter'>]; 
</span><a name="LN10697"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>lastxlogfilename</span><span class='Delimiter'>[</span><a href="../../../include/access/xlog_internal.h.html#LN137"><span class='Ref_to_Const'>MAXFNAMELEN</span></a><span class='Delimiter'>]; 
</span><a name="LN10698"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>histfilename</span><span class='Delimiter'>[</span><a href="../../../include/access/xlog_internal.h.html#LN137"><span class='Ref_to_Const'>MAXFNAMELEN</span></a><span class='Delimiter'>]; 
</span><a name="LN10699"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>backupfrom</span><span class='Delimiter'>[</span><span class='Number'>20</span><span class='Delimiter'>]; 
</span><a name="LN10700"></a>    <a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a>   <span class='Declare_Local'>_logSegNo</span><span class='Delimiter'>; 
</span><a name="LN10701"></a>    FILE       <span class='Operator'>*</span><span class='Declare_Local'>lfp</span><span class='Delimiter'>; 
</span><a name="LN10702"></a>    FILE       <span class='Operator'>*</span><span class='Declare_Local'>fp</span><span class='Delimiter'>; 
</span><a name="LN10703"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>ch</span><span class='Delimiter'>; 
</span><a name="LN10704"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>seconds_before_warning</span><span class='Delimiter'>; 
</span><a name="LN10705"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>waits</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN10706"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>reported_waiting</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN10707"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>remaining</span><span class='Delimiter'>; 
</span><a name="LN10708"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>ptr</span><span class='Delimiter'>; 
</span><a name="LN10709"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>hi</span><span class='Delimiter'>, 
</span><a name="LN10710"></a>                <span class='Declare_Local'>lo</span><span class='Delimiter'>; 
</span> 
    <a href="xlog.c.html#LN10688"><span class='Ref_To_Local'>backup_started_in_recovery</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlog.h.html#LN242"><span class='Ref_to_Proto'>RecoveryInProgress</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Currently only non-exclusive backup can be taken during recovery. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN10688"><span class='Ref_To_Local'>backup_started_in_recovery</span></a> <span class='Operator'>&& </span><a href="xlog.c.html#LN10687"><span class='Ref_To_Local'>exclusive</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"recovery is in progress"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"WAL control functions cannot be executed during recovery."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * During recovery, we don't need to check WAL level. Because, if WAL 
     * level is not sufficient, it's impossible to get here during recovery. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN10688"><span class='Ref_To_Local'>backup_started_in_recovery</span></a> <span class='Operator'>&& !</span><a href="../../../include/access/xlog.h.html#LN144"><span class='Ref_to_Macro'>XLogIsNeeded</span></a><span class='Parentheses'>())</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>              <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"WAL level not sufficient for making an online backup"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"wal_level must be set to \"replica\" or \"logical\" at server start."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN10687"><span class='Ref_To_Local'>exclusive</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * At first, mark that we're now stopping an exclusive backup, to 
         * ensure that there are no other sessions currently running 
         * pg_start_backup() or pg_stop_backup(). 
         */ 
</span>        <a href="xlog.c.html#LN925"><span class='Ref_to_Proto'>WALInsertLockAcquireExclusive</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN574"><span class='Ref_to_Member'>Insert</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN559"><span class='Ref_to_Member'>exclusiveBackupState</span></a> <span class='Operator'>!= </span><a href="xlog.c.html#LN501"><span class='Ref_to_EnumConst'>EXCLUSIVE_BACKUP_IN_PROGRESS</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="xlog.c.html#LN926"><span class='Ref_to_Proto'>WALInsertLockRelease</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"exclusive backup not in progress"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN574"><span class='Ref_to_Member'>Insert</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN559"><span class='Ref_to_Member'>exclusiveBackupState</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN502"><span class='Ref_to_EnumConst'>EXCLUSIVE_BACKUP_STOPPING</span></a><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN926"><span class='Ref_to_Proto'>WALInsertLockRelease</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Remove backup_label. In case of failure, the state for an exclusive 
         * backup is switched back to in-progress. 
         */ 
</span>        <a href="../../../include/storage/ipc.h.html#LN46"><span class='Ref_to_Macro'>PG_ENSURE_ERROR_CLEANUP</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN902"><span class='Ref_to_Proto'>pg_stop_backup_callback</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>) </span><a href="../../../include/postgres.h.html#LN407"><span class='Ref_to_Macro'>BoolGetDatum</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10687"><span class='Ref_To_Local'>exclusive</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Read the existing label file into memory. 
             */ 
</span><a name="LN10760"></a>            <span class='Control'>struct</span> <a href="../../../include/port.h.html#LN275"><span class='Ref_to_Macro'>stat</span></a> <span class='Declare_Local'>statbuf</span><span class='Delimiter'>; 
</span><a name="LN10761"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>r</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/port.h.html#LN275"><span class='Ref_to_Macro'>stat</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN320"><span class='Ref_to_Const'>BACKUP_LABEL_FILE</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN10760"><span class='Ref_To_Local'>statbuf</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* should not happen per the upper checks */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span>errno <span class='Operator'>!= </span>ENOENT<span class='Parentheses'>) 
</span>                    <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                            <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                             <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not stat file \"%s\": %m"</span><span class='Delimiter'>, 
</span>                                    <a href="../../../include/access/xlog.h.html#LN320"><span class='Ref_to_Const'>BACKUP_LABEL_FILE</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"a backup is not in progress"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <a href="xlog.c.html#LN10701"><span class='Ref_To_Local'>lfp</span></a> <span class='Operator'>= </span><a href="../../../include/storage/fd.h.html#LN83"><span class='Ref_to_Proto'>AllocateFile</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN320"><span class='Ref_to_Const'>BACKUP_LABEL_FILE</span></a><span class='Delimiter'>, </span><span class='String'>"r"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN10701"><span class='Ref_To_Local'>lfp</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                         <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not read file \"%s\": %m"</span><span class='Delimiter'>, 
</span>                                <a href="../../../include/access/xlog.h.html#LN320"><span class='Ref_to_Const'>BACKUP_LABEL_FILE</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <a href="xlog.c.html#LN10685"><span class='Ref_to_Parameter'>labelfile</span></a> <span class='Operator'>= </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10760"><span class='Ref_To_Local'>statbuf</span></a><span class='Operator'>.</span>st_size <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN10761"><span class='Ref_To_Local'>r</span></a> <span class='Operator'>= </span>fread<span class='Parentheses'>(</span><a href="xlog.c.html#LN10685"><span class='Ref_to_Parameter'>labelfile</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN10760"><span class='Ref_To_Local'>statbuf</span></a><span class='Operator'>.</span>st_size<span class='Delimiter'>, </span><span class='Number'>1</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN10701"><span class='Ref_To_Local'>lfp</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN10685"><span class='Ref_to_Parameter'>labelfile</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN10760"><span class='Ref_To_Local'>statbuf</span></a><span class='Operator'>.</span>st_size<span class='Delimiter'>] </span><span class='Operator'>= </span><span class='String'>'\0'</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Close and remove the backup label file 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN10761"><span class='Ref_To_Local'>r</span></a> <span class='Operator'>!= </span><span class='Number'>1</span> <span class='Operator'>|| </span>ferror<span class='Parentheses'>(</span><a href="xlog.c.html#LN10701"><span class='Ref_To_Local'>lfp</span></a><span class='Parentheses'>) </span><span class='Operator'>|| </span><a href="../../../include/storage/fd.h.html#LN84"><span class='Ref_to_Proto'>FreeFile</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10701"><span class='Ref_To_Local'>lfp</span></a><span class='Parentheses'>))</span> 
                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                         <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not read file \"%s\": %m"</span><span class='Delimiter'>, 
</span>                                <a href="../../../include/access/xlog.h.html#LN320"><span class='Ref_to_Const'>BACKUP_LABEL_FILE</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <a href="../../../include/storage/fd.h.html#LN121"><span class='Ref_to_Proto'>durable_unlink</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN320"><span class='Ref_to_Const'>BACKUP_LABEL_FILE</span></a><span class='Delimiter'>, </span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Remove tablespace_map file if present, it is created only if 
             * there are tablespaces. 
             */ 
</span>            <a href="../../../include/storage/fd.h.html#LN121"><span class='Ref_to_Proto'>durable_unlink</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN323"><span class='Ref_to_Const'>TABLESPACE_MAP</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/elog.h.html#LN24"><span class='Ref_to_Const'>DEBUG1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <a href="../../../include/storage/ipc.h.html#LN51"><span class='Ref_to_Macro'>PG_END_ENSURE_ERROR_CLEANUP</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN902"><span class='Ref_to_Proto'>pg_stop_backup_callback</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>) </span><a href="../../../include/postgres.h.html#LN407"><span class='Ref_to_Macro'>BoolGetDatum</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10687"><span class='Ref_To_Local'>exclusive</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if exclusive &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * OK to update backup counters and forcePageWrites 
     */ 
</span>    <a href="xlog.c.html#LN925"><span class='Ref_to_Proto'>WALInsertLockAcquireExclusive</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN10687"><span class='Ref_To_Local'>exclusive</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN574"><span class='Ref_to_Member'>Insert</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN559"><span class='Ref_to_Member'>exclusiveBackupState</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN499"><span class='Ref_to_EnumConst'>EXCLUSIVE_BACKUP_NONE</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * The user-visible pg_start/stop_backup() functions that operate on 
         * exclusive backups can be called at any time, but for non-exclusive 
         * backups, it is expected that each do_pg_start_backup() call is 
         * matched by exactly one do_pg_stop_backup() call. 
         */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN574"><span class='Ref_to_Member'>Insert</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN560"><span class='Ref_to_Member'>nonExclusiveBackups</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN574"><span class='Ref_to_Member'>Insert</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN560"><span class='Ref_to_Member'>nonExclusiveBackups</span></a><span class='Operator'>--</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN574"><span class='Ref_to_Member'>Insert</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN559"><span class='Ref_to_Member'>exclusiveBackupState</span></a> <span class='Operator'>== </span><a href="xlog.c.html#LN499"><span class='Ref_to_EnumConst'>EXCLUSIVE_BACKUP_NONE</span></a> <span class='Operator'>&& 
</span>        <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN574"><span class='Ref_to_Member'>Insert</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN560"><span class='Ref_to_Member'>nonExclusiveBackups</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN574"><span class='Ref_to_Member'>Insert</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN548"><span class='Ref_to_Member'>forcePageWrites</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="xlog.c.html#LN926"><span class='Ref_to_Proto'>WALInsertLockRelease</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Clean up session-level lock */ 
</span>    <a href="xlog.c.html#LN509"><span class='Ref_to_Global_Var'>sessionBackupState</span></a> <span class='Operator'>= </span><a href="../../../include/access/xlog.h.html#LN305"><span class='Ref_to_EnumConst'>SESSION_BACKUP_NONE</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Read and parse the START WAL LOCATION line (this code is pretty crude, 
     * but we are not expecting any variability in the file format). 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span>sscanf<span class='Parentheses'>(</span><a href="xlog.c.html#LN10685"><span class='Ref_to_Parameter'>labelfile</span></a><span class='Delimiter'>, </span><span class='String'>"START WAL LOCATION: %X/%X (file %24s)%c"</span><span class='Delimiter'>, 
</span>               <span class='Operator'>&</span><a href="xlog.c.html#LN10709"><span class='Ref_To_Local'>hi</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN10710"><span class='Ref_To_Local'>lo</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN10695"><span class='Ref_To_Local'>startxlogfilename</span></a><span class='Delimiter'>, 
</span>               <span class='Operator'>&</span><a href="xlog.c.html#LN10703"><span class='Ref_To_Local'>ch</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>4</span> <span class='Operator'>|| </span><a href="xlog.c.html#LN10703"><span class='Ref_To_Local'>ch</span></a> <span class='Operator'>!= </span><span class='String'>'\n'</span><span class='Parentheses'>)</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"invalid data in file \"%s\""</span><span class='Delimiter'>, </span><a href="../../../include/access/xlog.h.html#LN320"><span class='Ref_to_Const'>BACKUP_LABEL_FILE</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN10689"><span class='Ref_To_Local'>startpoint</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN10709"><span class='Ref_To_Local'>hi</span></a><span class='Parentheses'>)</span> <span class='Operator'>&LT;&LT; </span><span class='Number'>32</span> <span class='Operator'>| </span><a href="xlog.c.html#LN10710"><span class='Ref_To_Local'>lo</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN10707"><span class='Ref_To_Local'>remaining</span></a> <span class='Operator'>= </span>strchr<span class='Parentheses'>(</span><a href="xlog.c.html#LN10685"><span class='Ref_to_Parameter'>labelfile</span></a><span class='Delimiter'>, </span><span class='String'>'\n'</span><span class='Parentheses'>) </span><span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* %n is not portable enough */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Parse the BACKUP FROM line. If we are taking an online backup from the 
     * standby, we confirm that the standby has not been promoted during the 
     * backup. 
     */ 
</span>    <a href="xlog.c.html#LN10708"><span class='Ref_To_Local'>ptr</span></a> <span class='Operator'>= </span>strstr<span class='Parentheses'>(</span><a href="xlog.c.html#LN10707"><span class='Ref_To_Local'>remaining</span></a><span class='Delimiter'>, </span><span class='String'>"BACKUP FROM:"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN10708"><span class='Ref_To_Local'>ptr</span></a> <span class='Operator'>|| </span>sscanf<span class='Parentheses'>(</span><a href="xlog.c.html#LN10708"><span class='Ref_To_Local'>ptr</span></a><span class='Delimiter'>, </span><span class='String'>"BACKUP FROM: %19s\n"</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN10699"><span class='Ref_To_Local'>backupfrom</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"invalid data in file \"%s\""</span><span class='Delimiter'>, </span><a href="../../../include/access/xlog.h.html#LN320"><span class='Ref_to_Const'>BACKUP_LABEL_FILE</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span><a href="xlog.c.html#LN10699"><span class='Ref_To_Local'>backupfrom</span></a><span class='Delimiter'>, </span><span class='String'>"standby"</span><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span> <span class='Operator'>&& !</span><a href="xlog.c.html#LN10688"><span class='Ref_To_Local'>backup_started_in_recovery</span></a><span class='Parentheses'>)</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"the standby was promoted during online backup"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"This means that the backup being taken is corrupt "</span> 
                         <span class='String'>"and should not be used. "</span> 
                         <span class='String'>"Try taking another online backup."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * During recovery, we don't write an end-of-backup record. We assume that 
     * pg_control was backed up last and its minimum recovery point can be 
     * available as the backup end location. Since we don't have an 
     * end-of-backup record, we use the pg_control value to check whether 
     * we've reached the end of backup when starting recovery from this 
     * backup. We have no way of checking if pg_control wasn't backed up last 
     * however. 
     * 
     * We don't force a switch to new WAL file and wait for all the required 
     * files to be archived. This is okay if we use the backup to start the 
     * standby. But, if it's for an archive recovery, to ensure all the 
     * required files are available, a user should wait for them to be 
     * archived, or include them into the backup. 
     * 
     * We return the current minimum recovery point as the backup end 
     * location. Note that it can be greater than the exact backup end 
     * location if the minimum recovery point is updated after the backup of 
     * pg_control. This is harmless for current uses. 
     * 
     * XXX currently a backup history file is for informational and debug 
     * purposes only. It's not essential for an online backup. Furthermore, 
     * even if it's created, it will not be archived during recovery because 
     * an archiver is not invoked. So it doesn't seem worthwhile to write a 
     * backup history file during recovery. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN10688"><span class='Ref_To_Local'>backup_started_in_recovery</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN10896"></a>        <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>recptr</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Check to see if all WAL replayed during online backup contain 
         * full-page writes. 
         */ 
</span>        <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN10896"><span class='Ref_To_Local'>recptr</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN700"><span class='Ref_to_Member'>lastFpwDisableRecPtr</span></a><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN10689"><span class='Ref_To_Local'>startpoint</span></a> <span class='Operator'>&LT;= </span><a href="xlog.c.html#LN10896"><span class='Ref_To_Local'>recptr</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>               <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"WAL generated with full_page_writes=off was replayed "</span> 
                      <span class='String'>"during online backup"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>             <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"This means that the backup being taken on the standby "</span> 
                     <span class='String'>"is corrupt and should not be used. "</span> 
                 <span class='String'>"Enable full_page_writes and run CHECKPOINT on the master, "</span> 
                     <span class='String'>"and then try an online backup again."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
 
        <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ControlFileLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN10690"><span class='Ref_To_Local'>stoppoint</span></a> <span class='Operator'>= </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN169"><span class='Ref_to_Member'>minRecoveryPoint</span></a><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN10691"><span class='Ref_To_Local'>stoptli</span></a> <span class='Operator'>= </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN170"><span class='Ref_to_Member'>minRecoveryPointTLI</span></a><span class='Delimiter'>; 
</span>        <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ControlFileLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN10685"><span class='Ref_to_Parameter'>stoptli_p</span></a><span class='Parentheses'>) 
</span>            <span class='Operator'>*</span><a href="xlog.c.html#LN10685"><span class='Ref_to_Parameter'>stoptli_p</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN10691"><span class='Ref_To_Local'>stoptli</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <a href="xlog.c.html#LN10690"><span class='Ref_To_Local'>stoppoint</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if backup_started_in_rec... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Write the backup-end xlog record 
     */ 
</span>    <a href="../../../include/access/xloginsert.h.html#LN41"><span class='Ref_to_Proto'>XLogBeginInsert</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="../../../include/access/xloginsert.h.html#LN45"><span class='Ref_to_Proto'>XLogRegisterData</span></a><span class='Parentheses'>((</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) (</span><span class='Operator'>&</span><a href="xlog.c.html#LN10689"><span class='Ref_To_Local'>startpoint</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN10689"><span class='Ref_To_Local'>startpoint</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN10690"><span class='Ref_To_Local'>stoppoint</span></a> <span class='Operator'>= </span><a href="../../../include/access/xloginsert.h.html#LN43"><span class='Ref_to_Proto'>XLogInsert</span></a><span class='Parentheses'>(</span>RM_XLOG_ID<span class='Delimiter'>, </span><a href="../../../include/catalog/pg_control.h.html#LN70"><span class='Ref_to_Const'>XLOG_BACKUP_END</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN10691"><span class='Ref_To_Local'>stoptli</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Force a switch to a new xlog segment file, so that the backup is valid 
     * as soon as archiver moves out the current segment file. 
     */ 
</span>    <a href="../../../include/access/xlog_internal.h.html#LN290"><span class='Ref_to_Proto'>RequestXLogSwitch</span></a><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/access/xlog_internal.h.html#LN108"><span class='Ref_to_Macro'>XLByteToPrevSeg</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10690"><span class='Ref_To_Local'>stoppoint</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN10700"><span class='Ref_To_Local'>_logSegNo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/access/xlog_internal.h.html#LN142"><span class='Ref_to_Macro'>XLogFileName</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10696"><span class='Ref_To_Local'>stopxlogfilename</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN10700"><span class='Ref_To_Local'>_logSegNo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Use the log timezone here, not the session timezone */ 
</span>    <a href="xlog.c.html#LN10692"><span class='Ref_To_Local'>stamp_time</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/pgtime.h.html#LN22"><span class='Ref_to_Typedef'>pg_time_t</span></a><span class='Parentheses'>) </span>time<span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/pgtime.h.html#LN67"><span class='Ref_to_Proto'>pg_strftime</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10693"><span class='Ref_To_Local'>strfbuf</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN10693"><span class='Ref_To_Local'>strfbuf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                <span class='String'>"%Y-%m-%d %H:%M:%S %Z"</span><span class='Delimiter'>, 
</span>                <a href="../../../include/pgtime.h.html#LN47"><span class='Ref_to_Proto'>pg_localtime</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN10692"><span class='Ref_To_Local'>stamp_time</span></a><span class='Delimiter'>, </span><a href="../../../timezone/pgtz.c.html#LN30"><span class='Ref_to_Global_Var'>log_timezone</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Write the backup history file 
     */ 
</span>    <a href="../../../include/access/xlog_internal.h.html#LN105"><span class='Ref_to_Macro'>XLByteToSeg</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10689"><span class='Ref_To_Local'>startpoint</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN10700"><span class='Ref_To_Local'>_logSegNo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/access/xlog_internal.h.html#LN201"><span class='Ref_to_Macro'>BackupHistoryFilePath</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10694"><span class='Ref_To_Local'>histfilepath</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN10700"><span class='Ref_To_Local'>_logSegNo</span></a><span class='Delimiter'>, 
</span>                          <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN10689"><span class='Ref_To_Local'>startpoint</span></a> <span class='Operator'>% </span><a href="../../../include/access/xlog_internal.h.html#LN91"><span class='Ref_to_Const'>XLogSegSize</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN10702"><span class='Ref_To_Local'>fp</span></a> <span class='Operator'>= </span><a href="../../../include/storage/fd.h.html#LN83"><span class='Ref_to_Proto'>AllocateFile</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10694"><span class='Ref_To_Local'>histfilepath</span></a><span class='Delimiter'>, </span><span class='String'>"w"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN10702"><span class='Ref_To_Local'>fp</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not create file \"%s\": %m"</span><span class='Delimiter'>, 
</span>                        <a href="xlog.c.html#LN10694"><span class='Ref_To_Local'>histfilepath</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <a href="../../../../contrib/seg/segscan.l.html#LN10"><span class='Ref_to_Macro'>fprintf</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10702"><span class='Ref_To_Local'>fp</span></a><span class='Delimiter'>, </span><span class='String'>"START WAL LOCATION: %X/%X (file %s)\n"</span><span class='Delimiter'>, 
</span>        <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN10689"><span class='Ref_To_Local'>startpoint</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN10689"><span class='Ref_To_Local'>startpoint</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN10695"><span class='Ref_To_Local'>startxlogfilename</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../../contrib/seg/segscan.l.html#LN10"><span class='Ref_to_Macro'>fprintf</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10702"><span class='Ref_To_Local'>fp</span></a><span class='Delimiter'>, </span><span class='String'>"STOP WAL LOCATION: %X/%X (file %s)\n"</span><span class='Delimiter'>, 
</span>            <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN10690"><span class='Ref_To_Local'>stoppoint</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN10690"><span class='Ref_To_Local'>stoppoint</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN10696"><span class='Ref_To_Local'>stopxlogfilename</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* transfer remaining lines from label to history file */ 
</span>    <a href="../../../../contrib/seg/segscan.l.html#LN10"><span class='Ref_to_Macro'>fprintf</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10702"><span class='Ref_To_Local'>fp</span></a><span class='Delimiter'>, </span><span class='String'>"%s"</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN10707"><span class='Ref_To_Local'>remaining</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../../contrib/seg/segscan.l.html#LN10"><span class='Ref_to_Macro'>fprintf</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10702"><span class='Ref_To_Local'>fp</span></a><span class='Delimiter'>, </span><span class='String'>"STOP TIME: %s\n"</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN10693"><span class='Ref_To_Local'>strfbuf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span>fflush<span class='Parentheses'>(</span><a href="xlog.c.html#LN10702"><span class='Ref_To_Local'>fp</span></a><span class='Parentheses'>) </span><span class='Operator'>|| </span>ferror<span class='Parentheses'>(</span><a href="xlog.c.html#LN10702"><span class='Ref_To_Local'>fp</span></a><span class='Parentheses'>) </span><span class='Operator'>|| </span><a href="../../../include/storage/fd.h.html#LN84"><span class='Ref_to_Proto'>FreeFile</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10702"><span class='Ref_To_Local'>fp</span></a><span class='Parentheses'>))</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not write file \"%s\": %m"</span><span class='Delimiter'>, 
</span>                        <a href="xlog.c.html#LN10694"><span class='Ref_To_Local'>histfilepath</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Clean out any no-longer-needed history files.  As a side effect, this 
     * will post a .ready file for the newly created history file, notifying 
     * the archiver that history file may be archived immediately. 
     */ 
</span>    <a href="xlog.c.html#LN884"><span class='Ref_to_Proto'>CleanupBackupHistory</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If archiving is enabled, wait for all the required WAL files to be 
     * archived before returning. If archiving isn't enabled, the required WAL 
     * needs to be transported via streaming replication (hopefully with 
     * wal_keep_segments set high enough), or some more exotic mechanism like 
     * polling and copying files from pg_wal with script. We have no knowledge 
     * of those mechanisms, so it's up to the user to ensure that he gets all 
     * the required WAL. 
     * 
     * We wait until both the last WAL file filled during backup and the 
     * history file have been archived, and assume that the alphabetic sorting 
     * property of the WAL files ensures any earlier WAL files are safely 
     * archived as well. 
     * 
     * We wait forever, since archive_command is supposed to work and we 
     * assume the admin wanted his backup to work completely. If you don't 
     * wish to wait, then either waitforarchive should be passed in as false, 
     * or you can set statement_timeout.  Also, some notices are issued to 
     * clue in anyone who might be doing this interactively. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN10685"><span class='Ref_to_Parameter'>waitforarchive</span></a> <span class='Operator'>&& </span><a href="../../../include/access/xlog.h.html#LN133"><span class='Ref_to_Macro'>XLogArchivingActive</span></a><span class='Parentheses'>())</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../include/access/xlog_internal.h.html#LN108"><span class='Ref_to_Macro'>XLByteToPrevSeg</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10690"><span class='Ref_To_Local'>stoppoint</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN10700"><span class='Ref_To_Local'>_logSegNo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/access/xlog_internal.h.html#LN142"><span class='Ref_to_Macro'>XLogFileName</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10697"><span class='Ref_To_Local'>lastxlogfilename</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN10700"><span class='Ref_To_Local'>_logSegNo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/access/xlog_internal.h.html#LN105"><span class='Ref_to_Macro'>XLByteToSeg</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10689"><span class='Ref_To_Local'>startpoint</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN10700"><span class='Ref_To_Local'>_logSegNo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/access/xlog_internal.h.html#LN191"><span class='Ref_to_Macro'>BackupHistoryFileName</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10698"><span class='Ref_To_Local'>histfilename</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN178"><span class='Ref_to_Global_Var'>ThisTimeLineID</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN10700"><span class='Ref_To_Local'>_logSegNo</span></a><span class='Delimiter'>, 
</span>                              <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN10689"><span class='Ref_To_Local'>startpoint</span></a> <span class='Operator'>% </span><a href="../../../include/access/xlog_internal.h.html#LN91"><span class='Ref_to_Const'>XLogSegSize</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <a href="xlog.c.html#LN10704"><span class='Ref_To_Local'>seconds_before_warning</span></a> <span class='Operator'>= </span><span class='Number'>60</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN10705"><span class='Ref_To_Local'>waits</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="../../../include/access/xlog_internal.h.html#LN316"><span class='Ref_to_Proto'>XLogArchiveIsBusy</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10697"><span class='Ref_To_Local'>lastxlogfilename</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>               <a href="../../../include/access/xlog_internal.h.html#LN316"><span class='Ref_to_Proto'>XLogArchiveIsBusy</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN10698"><span class='Ref_To_Local'>histfilename</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="../../../include/miscadmin.h.html#LN99"><span class='Ref_to_Macro'>CHECK_FOR_INTERRUPTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN10706"><span class='Ref_To_Local'>reported_waiting</span></a> <span class='Operator'>&& </span><a href="xlog.c.html#LN10705"><span class='Ref_To_Local'>waits</span></a> <span class='Operator'>&GT; </span><span class='Number'>5</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN36"><span class='Ref_to_Const'>NOTICE</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"pg_stop_backup cleanup done, waiting for required WAL segments to be archived"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                <a href="xlog.c.html#LN10706"><span class='Ref_To_Local'>reported_waiting</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <a href="../../../port/pgsleep.c.html#LN45"><span class='Ref_to_Func'>pg_usleep</span></a><span class='Parentheses'>(</span><span class='Number'>1000000L</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>++</span><a href="xlog.c.html#LN10705"><span class='Ref_To_Local'>waits</span></a> <span class='Operator'>&GT;= </span><a href="xlog.c.html#LN10704"><span class='Ref_To_Local'>seconds_before_warning</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="xlog.c.html#LN10704"><span class='Ref_To_Local'>seconds_before_warning</span></a> <span class='Operator'>*= </span><span class='Number'>2</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* This wraps in &GT;10 years... */ 
</span>                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN39"><span class='Ref_to_Const'>WARNING</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"pg_stop_backup still waiting for all required WAL segments to be archived (%d seconds elapsed)"</span><span class='Delimiter'>, 
</span>                                <a href="xlog.c.html#LN10705"><span class='Ref_To_Local'>waits</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"Check that your archive_command is executing properly.  "</span> 
                                 <span class='String'>"pg_stop_backup can be canceled safely, "</span> 
                                 <span class='String'>"but the database backup will not be usable without all the WAL segments."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while XLogArchiveIsBusy(las... &raquo; </span> 
 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN36"><span class='Ref_to_Const'>NOTICE</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"pg_stop_backup complete, all required WAL segments have been archived"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if waitforarchive&&XLogA... &raquo; </span> 
    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN10685"><span class='Ref_to_Parameter'>waitforarchive</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN36"><span class='Ref_to_Const'>NOTICE</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"WAL archiving is not enabled; you must ensure that all required WAL segments are copied through other means to complete the backup"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We're done.  As a convenience, return the ending WAL location. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN10685"><span class='Ref_to_Parameter'>stoptli_p</span></a><span class='Parentheses'>) 
</span>        <span class='Operator'>*</span><a href="xlog.c.html#LN10685"><span class='Ref_to_Parameter'>stoptli_p</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN10691"><span class='Ref_To_Local'>stoptli</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="xlog.c.html#LN10690"><span class='Ref_To_Local'>stoppoint</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end do_pg_stop_backup &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * do_pg_abort_backup: abort a running backup 
 * 
 * This does just the most basic steps of do_pg_stop_backup(), by taking the 
 * system out of backup mode, thus making it a lot more safe to call from 
 * an error handler. 
 * 
 * NB: This is only for aborting a non-exclusive backup that doesn't write 
 * backup_label. A backup started with pg_start_backup() needs to be finished 
 * with pg_stop_backup(). 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN11068"></a><span class='Declare_Function'>do_pg_abort_backup</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="xlog.c.html#LN925"><span class='Ref_to_Proto'>WALInsertLockAcquireExclusive</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN574"><span class='Ref_to_Member'>Insert</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN560"><span class='Ref_to_Member'>nonExclusiveBackups</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN574"><span class='Ref_to_Member'>Insert</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN560"><span class='Ref_to_Member'>nonExclusiveBackups</span></a><span class='Operator'>--</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN574"><span class='Ref_to_Member'>Insert</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN559"><span class='Ref_to_Member'>exclusiveBackupState</span></a> <span class='Operator'>== </span><a href="xlog.c.html#LN499"><span class='Ref_to_EnumConst'>EXCLUSIVE_BACKUP_NONE</span></a> <span class='Operator'>&& 
</span>        <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN574"><span class='Ref_to_Member'>Insert</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN560"><span class='Ref_to_Member'>nonExclusiveBackups</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN574"><span class='Ref_to_Member'>Insert</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN548"><span class='Ref_to_Member'>forcePageWrites</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="xlog.c.html#LN926"><span class='Ref_to_Proto'>WALInsertLockRelease</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Get latest redo apply position. 
 * 
 * Exported to allow WALReceiver to read the pointer directly. 
 */ 
</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> 
<a name="LN11088"></a><span class='Declare_Function'>GetXLogReplayRecPtr</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>replayTLI</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN11090"></a>    <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>recptr</span><span class='Delimiter'>; 
</span><a name="LN11091"></a>    <a href="../../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a>  <span class='Declare_Local'>tli</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN11090"><span class='Ref_To_Local'>recptr</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN681"><span class='Ref_to_Member'>lastReplayedEndRecPtr</span></a><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN11091"><span class='Ref_To_Local'>tli</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN682"><span class='Ref_to_Member'>lastReplayedTLI</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN11088"><span class='Ref_to_Parameter'>replayTLI</span></a><span class='Parentheses'>) 
</span>        <span class='Operator'>*</span><a href="xlog.c.html#LN11088"><span class='Ref_to_Parameter'>replayTLI</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN11091"><span class='Ref_To_Local'>tli</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="xlog.c.html#LN11090"><span class='Ref_To_Local'>recptr</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Get latest WAL insert pointer 
 */ 
</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> 
<a name="LN11107"></a><span class='Declare_Function'>GetXLogInsertRecPtr</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN11109"></a>    <a href="xlog.c.html#LN514"><span class='Ref_to_Struct'>XLogCtlInsert</span></a> <span class='Operator'>*</span><span class='Declare_Local'>Insert</span> <span class='Operator'>= &</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN574"><span class='Ref_to_Member'>Insert</span></a><span class='Delimiter'>; 
</span><a name="LN11110"></a>    <a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a>      <span class='Declare_Local'>current_bytepos</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN11109"><span class='Ref_To_Local'>Insert</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN516"><span class='Ref_to_Member'>insertpos_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN11110"><span class='Ref_To_Local'>current_bytepos</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN11109"><span class='Ref_To_Local'>Insert</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN525"><span class='Ref_to_Member'>CurrBytePos</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN11109"><span class='Ref_To_Local'>Insert</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN516"><span class='Ref_to_Member'>insertpos_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="xlog.c.html#LN919"><span class='Ref_to_Proto'>XLogBytePosToRecPtr</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN11110"><span class='Ref_To_Local'>current_bytepos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Get latest WAL write pointer 
 */ 
</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> 
<a name="LN11123"></a><span class='Declare_Function'>GetXLogWriteRecPtr</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN599"><span class='Ref_to_Member'>LogwrtResult</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="xlog.c.html#LN747"><span class='Ref_to_Global_Var'>LogwrtResult</span></a><span class='Operator'>.</span><a href="xlog.c.html#LN422"><span class='Ref_to_Member'>Write</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Returns the redo pointer of the last checkpoint or restartpoint. This is 
 * the oldest point in WAL that we still need, if we have to restart recovery. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN11137"></a><span class='Declare_Function'>GetOldestRestartPoint</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>oldrecptr</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>oldtli</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ControlFileLock<span class='Delimiter'>, </span><a href="../../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="xlog.c.html#LN11137"><span class='Ref_to_Parameter'>oldrecptr</span></a> <span class='Operator'>= </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN134"><span class='Ref_to_Member'>checkPointCopy</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN34"><span class='Ref_to_Member'>redo</span></a><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="xlog.c.html#LN11137"><span class='Ref_to_Parameter'>oldtli</span></a> <span class='Operator'>= </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN134"><span class='Ref_to_Member'>checkPointCopy</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN36"><span class='Ref_to_Member'>ThisTimeLineID</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ControlFileLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * read_backup_label: check to see if a backup_label file is present 
 * 
 * If we see a backup_label during recovery, we assume that we are recovering 
 * from a backup dump file, and we therefore roll forward from the checkpoint 
 * identified by the label file, NOT what pg_control says.  This avoids the 
 * problem that pg_control might have been archived one or more checkpoints 
 * later than the start of the dump, and so if we rely on it as the start 
 * point, we will fail to restore a consistent database state. 
 * 
 * Returns TRUE if a backup_label was found (and fills the checkpoint 
 * location and its REDO location into *checkPointLoc and RedoStartLSN, 
 * respectively); returns FALSE if not. If this backup_label came from a 
 * streamed backup, *backupEndRequired is set to TRUE. If this backup_label 
 * was created during recovery, *backupFromStandby is set to TRUE. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN11162"></a><span class='Declare_Function'>read_backup_label</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>checkPointLoc</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>backupEndRequired</span><span class='Delimiter'>, 
</span><a name="LN11163"></a>                  <span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>backupFromStandby</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN11165"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>startxlogfilename</span><span class='Delimiter'>[</span><a href="../../../include/access/xlog_internal.h.html#LN137"><span class='Ref_to_Const'>MAXFNAMELEN</span></a><span class='Delimiter'>]; 
</span><a name="LN11166"></a>    <a href="../../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a>  <span class='Declare_Local'>tli</span><span class='Delimiter'>; 
</span><a name="LN11167"></a>    FILE       <span class='Operator'>*</span><span class='Declare_Local'>lfp</span><span class='Delimiter'>; 
</span><a name="LN11168"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>ch</span><span class='Delimiter'>; 
</span><a name="LN11169"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>backuptype</span><span class='Delimiter'>[</span><span class='Number'>20</span><span class='Delimiter'>]; 
</span><a name="LN11170"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>backupfrom</span><span class='Delimiter'>[</span><span class='Number'>20</span><span class='Delimiter'>]; 
</span><a name="LN11171"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>hi</span><span class='Delimiter'>, 
</span><a name="LN11172"></a>                <span class='Declare_Local'>lo</span><span class='Delimiter'>; 
</span> 
    <span class='Operator'>*</span><a href="xlog.c.html#LN11162"><span class='Ref_to_Parameter'>backupEndRequired</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="xlog.c.html#LN11163"><span class='Ref_to_Parameter'>backupFromStandby</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * See if label file is present 
     */ 
</span>    <a href="xlog.c.html#LN11167"><span class='Ref_To_Local'>lfp</span></a> <span class='Operator'>= </span><a href="../../../include/storage/fd.h.html#LN83"><span class='Ref_to_Proto'>AllocateFile</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN320"><span class='Ref_to_Const'>BACKUP_LABEL_FILE</span></a><span class='Delimiter'>, </span><span class='String'>"r"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN11167"><span class='Ref_To_Local'>lfp</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span>errno <span class='Operator'>!= </span>ENOENT<span class='Parentheses'>) 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                     <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not read file \"%s\": %m"</span><span class='Delimiter'>, 
</span>                            <a href="../../../include/access/xlog.h.html#LN320"><span class='Ref_to_Const'>BACKUP_LABEL_FILE</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* it's not there, all is fine */ 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Read and parse the START WAL LOCATION and CHECKPOINT lines (this code 
     * is pretty crude, but we are not expecting any variability in the file 
     * format). 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span>fscanf<span class='Parentheses'>(</span><a href="xlog.c.html#LN11167"><span class='Ref_To_Local'>lfp</span></a><span class='Delimiter'>, </span><span class='String'>"START WAL LOCATION: %X/%X (file %08X%16s)%c"</span><span class='Delimiter'>, 
</span>               <span class='Operator'>&</span><a href="xlog.c.html#LN11171"><span class='Ref_To_Local'>hi</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN11172"><span class='Ref_To_Local'>lo</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN11166"><span class='Ref_To_Local'>tli</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN11165"><span class='Ref_To_Local'>startxlogfilename</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN11168"><span class='Ref_To_Local'>ch</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>5</span> <span class='Operator'>|| </span><a href="xlog.c.html#LN11168"><span class='Ref_To_Local'>ch</span></a> <span class='Operator'>!= </span><span class='String'>'\n'</span><span class='Parentheses'>)</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"invalid data in file \"%s\""</span><span class='Delimiter'>, </span><a href="../../../include/access/xlog.h.html#LN320"><span class='Ref_to_Const'>BACKUP_LABEL_FILE</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN371"><span class='Ref_to_Global_Var'>RedoStartLSN</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN11171"><span class='Ref_To_Local'>hi</span></a><span class='Parentheses'>)</span> <span class='Operator'>&LT;&LT; </span><span class='Number'>32</span> <span class='Operator'>| </span><a href="xlog.c.html#LN11172"><span class='Ref_To_Local'>lo</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span>fscanf<span class='Parentheses'>(</span><a href="xlog.c.html#LN11167"><span class='Ref_To_Local'>lfp</span></a><span class='Delimiter'>, </span><span class='String'>"CHECKPOINT LOCATION: %X/%X%c"</span><span class='Delimiter'>, 
</span>               <span class='Operator'>&</span><a href="xlog.c.html#LN11171"><span class='Ref_To_Local'>hi</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN11172"><span class='Ref_To_Local'>lo</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN11168"><span class='Ref_To_Local'>ch</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>3</span> <span class='Operator'>|| </span><a href="xlog.c.html#LN11168"><span class='Ref_To_Local'>ch</span></a> <span class='Operator'>!= </span><span class='String'>'\n'</span><span class='Parentheses'>)</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"invalid data in file \"%s\""</span><span class='Delimiter'>, </span><a href="../../../include/access/xlog.h.html#LN320"><span class='Ref_to_Const'>BACKUP_LABEL_FILE</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="xlog.c.html#LN11162"><span class='Ref_to_Parameter'>checkPointLoc</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN11171"><span class='Ref_To_Local'>hi</span></a><span class='Parentheses'>)</span> <span class='Operator'>&LT;&LT; </span><span class='Number'>32</span> <span class='Operator'>| </span><a href="xlog.c.html#LN11172"><span class='Ref_To_Local'>lo</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * BACKUP METHOD and BACKUP FROM lines are new in 9.2. We can't restore 
     * from an older backup anyway, but since the information on it is not 
     * strictly required, don't error out if it's missing for some reason. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span>fscanf<span class='Parentheses'>(</span><a href="xlog.c.html#LN11167"><span class='Ref_To_Local'>lfp</span></a><span class='Delimiter'>, </span><span class='String'>"BACKUP METHOD: %19s\n"</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN11169"><span class='Ref_To_Local'>backuptype</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span><a href="xlog.c.html#LN11169"><span class='Ref_To_Local'>backuptype</span></a><span class='Delimiter'>, </span><span class='String'>"streamed"</span><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
            <span class='Operator'>*</span><a href="xlog.c.html#LN11162"><span class='Ref_to_Parameter'>backupEndRequired</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span>fscanf<span class='Parentheses'>(</span><a href="xlog.c.html#LN11167"><span class='Ref_To_Local'>lfp</span></a><span class='Delimiter'>, </span><span class='String'>"BACKUP FROM: %19s\n"</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN11170"><span class='Ref_To_Local'>backupfrom</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span><a href="xlog.c.html#LN11170"><span class='Ref_To_Local'>backupfrom</span></a><span class='Delimiter'>, </span><span class='String'>"standby"</span><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
            <span class='Operator'>*</span><a href="xlog.c.html#LN11163"><span class='Ref_to_Parameter'>backupFromStandby</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span>ferror<span class='Parentheses'>(</span><a href="xlog.c.html#LN11167"><span class='Ref_To_Local'>lfp</span></a><span class='Parentheses'>) </span><span class='Operator'>|| </span><a href="../../../include/storage/fd.h.html#LN84"><span class='Ref_to_Proto'>FreeFile</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN11167"><span class='Ref_To_Local'>lfp</span></a><span class='Parentheses'>))</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not read file \"%s\": %m"</span><span class='Delimiter'>, 
</span>                        <a href="../../../include/access/xlog.h.html#LN320"><span class='Ref_to_Const'>BACKUP_LABEL_FILE</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end read_backup_label &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * read_tablespace_map: check to see if a tablespace_map file is present 
 * 
 * If we see a tablespace_map file during recovery, we assume that we are 
 * recovering from a backup dump file, and we therefore need to create symlinks 
 * as per the information present in tablespace_map file. 
 * 
 * Returns TRUE if a tablespace_map file was found (and fills the link 
 * information for all the tablespace links present in file); returns FALSE 
 * if not. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN11247"></a><span class='Declare_Function'>read_tablespace_map</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>tablespaces</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN11249"></a>    <a href="../../../include/replication/basebackup.h.html#LN23"><span class='Ref_to_Typedef'>tablespaceinfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>ti</span><span class='Delimiter'>; 
</span><a name="LN11250"></a>    FILE       <span class='Operator'>*</span><span class='Declare_Local'>lfp</span><span class='Delimiter'>; 
</span><a name="LN11251"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>tbsoid</span><span class='Delimiter'>[</span><a href="../../../include/pg_config_manual.h.html#LN88"><span class='Ref_to_Const'>MAXPGPATH</span></a><span class='Delimiter'>]; 
</span><a name="LN11252"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>tbslinkpath</span><span class='Delimiter'>; 
</span><a name="LN11253"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>str</span><span class='Delimiter'>[</span><a href="../../../include/pg_config_manual.h.html#LN88"><span class='Ref_to_Const'>MAXPGPATH</span></a><span class='Delimiter'>]; 
</span><a name="LN11254"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>ch</span><span class='Delimiter'>, 
</span><a name="LN11255"></a>                <span class='Declare_Local'>prev_ch</span> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>, 
</span><a name="LN11256"></a>                <span class='Declare_Local'>i</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>, 
</span><a name="LN11257"></a>                <span class='Declare_Local'>n</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * See if tablespace_map file is present 
     */ 
</span>    <a href="xlog.c.html#LN11250"><span class='Ref_To_Local'>lfp</span></a> <span class='Operator'>= </span><a href="../../../include/storage/fd.h.html#LN83"><span class='Ref_to_Proto'>AllocateFile</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN323"><span class='Ref_to_Const'>TABLESPACE_MAP</span></a><span class='Delimiter'>, </span><span class='String'>"r"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN11250"><span class='Ref_To_Local'>lfp</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span>errno <span class='Operator'>!= </span>ENOENT<span class='Parentheses'>) 
</span>            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                     <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not read file \"%s\": %m"</span><span class='Delimiter'>, 
</span>                            <a href="../../../include/access/xlog.h.html#LN323"><span class='Ref_to_Const'>TABLESPACE_MAP</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* it's not there, all is fine */ 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Read and parse the link name and path lines from tablespace_map file 
     * (this code is pretty crude, but we are not expecting any variability in 
     * the file format).  While taking backup we embed escape character '\\' 
     * before newline in tablespace path, so that during reading of 
     * tablespace_map file, we could distinguish newline in tablespace path 
     * and end of line.  Now while reading tablespace_map file, remove the 
     * escape character that has been added in tablespace path during backup. 
     */ 
</span>    <span class='Control'>while</span> <span class='Parentheses'>((</span><a href="xlog.c.html#LN11254"><span class='Ref_To_Local'>ch</span></a> <span class='Operator'>= </span>fgetc<span class='Parentheses'>(</span><a href="xlog.c.html#LN11250"><span class='Ref_To_Local'>lfp</span></a><span class='Parentheses'>))</span> <span class='Operator'>!= </span>EOF<span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="xlog.c.html#LN11254"><span class='Ref_To_Local'>ch</span></a> <span class='Operator'>== </span><span class='String'>'\n'</span> <span class='Operator'>|| </span><a href="xlog.c.html#LN11254"><span class='Ref_To_Local'>ch</span></a> <span class='Operator'>== </span><span class='String'>'\r'</span><span class='Parentheses'>) </span><span class='Operator'>&& </span><a href="xlog.c.html#LN11255"><span class='Ref_To_Local'>prev_ch</span></a> <span class='Operator'>!= </span><span class='String'>'\\'</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <a href="xlog.c.html#LN11253"><span class='Ref_To_Local'>str</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN11256"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='String'>'\0'</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span>sscanf<span class='Parentheses'>(</span><a href="xlog.c.html#LN11253"><span class='Ref_To_Local'>str</span></a><span class='Delimiter'>, </span><span class='String'>"%s %n"</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN11251"><span class='Ref_To_Local'>tbsoid</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN11257"><span class='Ref_To_Local'>n</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"invalid data in file \"%s\""</span><span class='Delimiter'>, </span><a href="../../../include/access/xlog.h.html#LN323"><span class='Ref_to_Const'>TABLESPACE_MAP</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN11252"><span class='Ref_To_Local'>tbslinkpath</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN11253"><span class='Ref_To_Local'>str</span></a> <span class='Operator'>+ </span><a href="xlog.c.html#LN11257"><span class='Ref_To_Local'>n</span></a><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN11256"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
            <a href="xlog.c.html#LN11249"><span class='Ref_To_Local'>ti</span></a> <span class='Operator'>= </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/replication/basebackup.h.html#LN23"><span class='Ref_to_Typedef'>tablespaceinfo</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN11249"><span class='Ref_To_Local'>ti</span></a><span class='Operator'>-&GT;</span><a href="../../../include/replication/basebackup.h.html#LN25"><span class='Ref_to_Member'>oid</span></a> <span class='Operator'>= </span><a href="../../../include/common/fe_memutils.h.html#LN32"><span class='Ref_to_Proto'>pstrdup</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN11251"><span class='Ref_To_Local'>tbsoid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN11249"><span class='Ref_To_Local'>ti</span></a><span class='Operator'>-&GT;</span><a href="../../../include/replication/basebackup.h.html#LN26"><span class='Ref_to_Member'>path</span></a> <span class='Operator'>= </span><a href="../../../include/common/fe_memutils.h.html#LN32"><span class='Ref_to_Proto'>pstrdup</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN11252"><span class='Ref_To_Local'>tbslinkpath</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Operator'>*</span><a href="xlog.c.html#LN11247"><span class='Ref_to_Parameter'>tablespaces</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="xlog.c.html#LN11247"><span class='Ref_to_Parameter'>tablespaces</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN11249"><span class='Ref_To_Local'>ti</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="xlog.c.html#LN11254"><span class='Ref_To_Local'>ch</span></a> <span class='Operator'>== </span><span class='String'>'\n'</span> <span class='Operator'>|| </span><a href="xlog.c.html#LN11254"><span class='Ref_To_Local'>ch</span></a> <span class='Operator'>== </span><span class='String'>'\r'</span><span class='Parentheses'>) </span><span class='Operator'>&& </span><a href="xlog.c.html#LN11255"><span class='Ref_To_Local'>prev_ch</span></a> <span class='Operator'>== </span><span class='String'>'\\'</span><span class='Parentheses'>)</span> 
            <a href="xlog.c.html#LN11253"><span class='Ref_To_Local'>str</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN11256"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="xlog.c.html#LN11254"><span class='Ref_To_Local'>ch</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="xlog.c.html#LN11253"><span class='Ref_To_Local'>str</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN11256"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="xlog.c.html#LN11254"><span class='Ref_To_Local'>ch</span></a><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN11255"><span class='Ref_To_Local'>prev_ch</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN11254"><span class='Ref_To_Local'>ch</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while (ch=fgetc(lfp))!=EOF &raquo; </span> 
 
    <span class='Control'>if</span> <span class='Parentheses'>(</span>ferror<span class='Parentheses'>(</span><a href="xlog.c.html#LN11250"><span class='Ref_To_Local'>lfp</span></a><span class='Parentheses'>) </span><span class='Operator'>|| </span><a href="../../../include/storage/fd.h.html#LN84"><span class='Ref_to_Proto'>FreeFile</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN11250"><span class='Ref_To_Local'>lfp</span></a><span class='Parentheses'>))</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN51"><span class='Ref_to_Const'>FATAL</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not read file \"%s\": %m"</span><span class='Delimiter'>, 
</span>                        <a href="../../../include/access/xlog.h.html#LN323"><span class='Ref_to_Const'>TABLESPACE_MAP</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end read_tablespace_map &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Error context callback for errors occurring during rm_redo(). 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN11321"></a><span class='Declare_Function'>rm_redo_error_callback</span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>arg</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN11323"></a>    <a href="../../../include/access/xlogreader.h.html#LN68"><span class='Ref_to_Struct'>XLogReaderState</span></a> <span class='Operator'>*</span><span class='Declare_Local'>record</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/xlogreader.h.html#LN68"><span class='Ref_to_Struct'>XLogReaderState</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="xlog.c.html#LN11321"><span class='Ref_to_Parameter'>arg</span></a><span class='Delimiter'>; 
</span><a name="LN11324"></a>    <a href="../../../include/lib/stringinfo.h.html#LN34"><span class='Ref_to_Struct'>StringInfoData</span></a> <span class='Declare_Local'>buf</span><span class='Delimiter'>; 
</span> 
    <a href="../../lib/stringinfo.c.html#LN44"><span class='Ref_to_Func'>initStringInfo</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN11324"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN900"><span class='Ref_to_Proto'>xlog_outdesc</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN11324"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN11323"><span class='Ref_To_Local'>record</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* translator: %s is a WAL record description */ 
</span>    errcontext<span class='Parentheses'>(</span><span class='String'>"WAL redo at %X/%X for %s"</span><span class='Delimiter'>, 
</span>               <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN11323"><span class='Ref_To_Local'>record</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogreader.h.html#LN113"><span class='Ref_to_Member'>ReadRecPtr</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>               <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN11323"><span class='Ref_To_Local'>record</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogreader.h.html#LN113"><span class='Ref_to_Member'>ReadRecPtr</span></a><span class='Delimiter'>, 
</span>               <a href="xlog.c.html#LN11324"><span class='Ref_To_Local'>buf</span></a><span class='Operator'>.</span><a href="../../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN11324"><span class='Ref_To_Local'>buf</span></a><span class='Operator'>.</span><a href="../../../include/lib/stringinfo.h.html#LN36"><span class='Ref_to_Member'>data</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * BackupInProgress: check if online backup mode is active 
 * 
 * This is done by checking for existence of the "backup_label" file. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN11344"></a><span class='Declare_Function'>BackupInProgress</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN11346"></a>    <span class='Control'>struct</span> <a href="../../../include/port.h.html#LN275"><span class='Ref_to_Macro'>stat</span></a> <span class='Declare_Local'>stat_buf</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/port.h.html#LN275"><span class='Ref_to_Macro'>stat</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN320"><span class='Ref_to_Const'>BACKUP_LABEL_FILE</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN11346"><span class='Ref_To_Local'>stat_buf</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * CancelBackup: rename the "backup_label" and "tablespace_map" 
 *               files to cancel backup mode 
 * 
 * If the "backup_label" file exists, it will be renamed to "backup_label.old". 
 * Similarly, if the "tablespace_map" file exists, it will be renamed to 
 * "tablespace_map.old". 
 * 
 * Note that this will render an online backup in progress 
 * useless. To correctly finish an online backup, pg_stop_backup must be 
 * called. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN11364"></a><span class='Declare_Function'>CancelBackup</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN11366"></a>    <span class='Control'>struct</span> <a href="../../../include/port.h.html#LN275"><span class='Ref_to_Macro'>stat</span></a> <span class='Declare_Local'>stat_buf</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* if the backup_label file is not there, return */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/port.h.html#LN275"><span class='Ref_to_Macro'>stat</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN320"><span class='Ref_to_Const'>BACKUP_LABEL_FILE</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN11366"><span class='Ref_To_Local'>stat_buf</span></a><span class='Parentheses'>) </span><span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* remove leftover file from previously canceled backup if it exists */ 
</span>    <a href="../../../timezone/private.h.html#LN59"><span class='Ref_to_Proto'>unlink</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN321"><span class='Ref_to_Const'>BACKUP_LABEL_OLD</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/common/file_utils.h.html#LN22"><span class='Ref_to_Proto'>durable_rename</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN320"><span class='Ref_to_Const'>BACKUP_LABEL_FILE</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xlog.h.html#LN321"><span class='Ref_to_Const'>BACKUP_LABEL_OLD</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/elog.h.html#LN24"><span class='Ref_to_Const'>DEBUG1</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN39"><span class='Ref_to_Const'>WARNING</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"online backup mode was not canceled"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"File \"%s\" could not be renamed to \"%s\": %m."</span><span class='Delimiter'>, 
</span>                           <a href="../../../include/access/xlog.h.html#LN320"><span class='Ref_to_Const'>BACKUP_LABEL_FILE</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xlog.h.html#LN321"><span class='Ref_to_Const'>BACKUP_LABEL_OLD</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* if the tablespace_map file is not there, return */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/port.h.html#LN275"><span class='Ref_to_Macro'>stat</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN323"><span class='Ref_to_Const'>TABLESPACE_MAP</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN11366"><span class='Ref_To_Local'>stat_buf</span></a><span class='Parentheses'>) </span><span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"online backup mode canceled"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"File \"%s\" was renamed to \"%s\"."</span><span class='Delimiter'>, 
</span>                           <a href="../../../include/access/xlog.h.html#LN320"><span class='Ref_to_Const'>BACKUP_LABEL_FILE</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xlog.h.html#LN321"><span class='Ref_to_Const'>BACKUP_LABEL_OLD</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* remove leftover file from previously canceled backup if it exists */ 
</span>    <a href="../../../timezone/private.h.html#LN59"><span class='Ref_to_Proto'>unlink</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN324"><span class='Ref_to_Const'>TABLESPACE_MAP_OLD</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/common/file_utils.h.html#LN22"><span class='Ref_to_Proto'>durable_rename</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN323"><span class='Ref_to_Const'>TABLESPACE_MAP</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xlog.h.html#LN324"><span class='Ref_to_Const'>TABLESPACE_MAP_OLD</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/elog.h.html#LN24"><span class='Ref_to_Const'>DEBUG1</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"online backup mode canceled"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"Files \"%s\" and \"%s\" were renamed to "</span> 
                           <span class='String'>"\"%s\" and \"%s\", respectively."</span><span class='Delimiter'>, 
</span>                           <a href="../../../include/access/xlog.h.html#LN320"><span class='Ref_to_Const'>BACKUP_LABEL_FILE</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xlog.h.html#LN323"><span class='Ref_to_Const'>TABLESPACE_MAP</span></a><span class='Delimiter'>, 
</span>                           <a href="../../../include/access/xlog.h.html#LN321"><span class='Ref_to_Const'>BACKUP_LABEL_OLD</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xlog.h.html#LN324"><span class='Ref_to_Const'>TABLESPACE_MAP_OLD</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN39"><span class='Ref_to_Const'>WARNING</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"online backup mode canceled"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"File \"%s\" was renamed to \"%s\", but "</span> 
                           <span class='String'>"file \"%s\" could not be renamed to \"%s\": %m."</span><span class='Delimiter'>, 
</span>                           <a href="../../../include/access/xlog.h.html#LN320"><span class='Ref_to_Const'>BACKUP_LABEL_FILE</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xlog.h.html#LN321"><span class='Ref_to_Const'>BACKUP_LABEL_OLD</span></a><span class='Delimiter'>, 
</span>                           <a href="../../../include/access/xlog.h.html#LN323"><span class='Ref_to_Const'>TABLESPACE_MAP</span></a><span class='Delimiter'>, </span><a href="../../../include/access/xlog.h.html#LN324"><span class='Ref_to_Const'>TABLESPACE_MAP_OLD</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end CancelBackup &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Read the XLOG page containing RecPtr into readBuf (if not read already). 
 * Returns number of bytes read, if the page is read successfully, or -1 
 * in case of errors.  When errors occur, they are ereport'ed, but only 
 * if they have not been previously reported. 
 * 
 * This is responsible for restoring files from archive as needed, as well 
 * as for waiting for the requested WAL record to arrive in standby mode. 
 * 
 * 'emode' specifies the log level used for reporting "file not found" or 
 * "end of WAL" situations in archive recovery, or in standby mode when a 
 * trigger file is found. If set to WARNING or below, XLogPageRead() returns 
 * false in those situations, on higher log levels the ereport() won't 
 * return. 
 * 
 * In standby mode, if after a successful return of XLogPageRead() the 
 * caller finds the record it's interested in to be broken, it should 
 * ereport the error with the level determined by 
 * emode_for_corrupt_record(), and then set lastSourceFailed 
 * and call XLogPageRead() again with the same arguments. This lets 
 * XLogPageRead() to try fetching the record from another source, or to 
 * sleep and retry. 
 */ 
</span><span class='Keyword'>static int 
</span><a name="LN11443"></a><span class='Declare_Function'>XLogPageRead</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogreader.h.html#LN68"><span class='Ref_to_Struct'>XLogReaderState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>xlogreader</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>targetPagePtr</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>reqLen</span><span class='Delimiter'>, 
</span><a name="LN11444"></a>             <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>targetRecPtr</span><span class='Delimiter'>, </span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Declare_Parameter'>readBuf</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>readTLI</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN11446"></a>    <a href="../../../bin/pg_rewind/parsexlog.c.html#LN44"><span class='Ref_to_Struct'>XLogPageReadPrivate</span></a> <span class='Operator'>*</span><span class='Declare_Local'>private</span> <span class='Operator'>= 
</span>    <span class='Parentheses'>(</span><a href="../../../bin/pg_rewind/parsexlog.c.html#LN44"><span class='Ref_to_Struct'>XLogPageReadPrivate</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="xlog.c.html#LN11443"><span class='Ref_to_Parameter'>xlogreader</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/xlogreader.h.html#LN107"><span class='Ref_to_Member'>private_data</span></a><span class='Delimiter'>; 
</span><a name="LN11448"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>emode</span> <span class='Operator'>= </span><span class='Keyword'>private</span><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN800"><span class='Ref_to_Member'>emode</span></a><span class='Delimiter'>; 
</span><a name="LN11449"></a>    <a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>targetPageOff</span><span class='Delimiter'>; 
</span><a name="LN11450"></a>    <a href="../../../include/access/xlogdefs.h.html#LN33"><span class='Ref_to_Typedef'>XLogSegNo</span></a> targetSegNo <span class='Declare_Local'>PG_USED_FOR_ASSERTS_ONLY</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/access/xlog_internal.h.html#LN105"><span class='Ref_to_Macro'>XLByteToSeg</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN11443"><span class='Ref_to_Parameter'>targetPagePtr</span></a><span class='Delimiter'>, </span>targetSegNo<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN11449"><span class='Ref_To_Local'>targetPageOff</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN11443"><span class='Ref_to_Parameter'>targetPagePtr</span></a> <span class='Operator'>% </span><a href="../../../include/access/xlog_internal.h.html#LN91"><span class='Ref_to_Const'>XLogSegSize</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * See if we need to switch to a new segment because the requested record 
     * is not in the currently open one. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN782"><span class='Ref_to_Global_Var'>readFile</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span> <span class='Operator'>&& !</span><a href="../../../include/access/xlog_internal.h.html#LN117"><span class='Ref_to_Macro'>XLByteInSeg</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN11443"><span class='Ref_to_Parameter'>targetPagePtr</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN783"><span class='Ref_to_Global_Var'>readSegNo</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Request a restartpoint if we've replayed too much xlog since the 
         * last one. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN835"><span class='Ref_to_Global_Var'>bgwriterLaunched</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN864"><span class='Ref_to_Proto'>XLogCheckpointNeeded</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN783"><span class='Ref_to_Global_Var'>readSegNo</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="../../../include/access/xlog.h.html#LN273"><span class='Ref_to_Proto'>GetRedoRecPtr</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN864"><span class='Ref_to_Proto'>XLogCheckpointNeeded</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN783"><span class='Ref_to_Global_Var'>readSegNo</span></a><span class='Parentheses'>))</span> 
                    <a href="../../../include/postmaster/bgwriter.h.html#LN30"><span class='Ref_to_Proto'>RequestCheckpoint</span></a><span class='Parentheses'>(</span><a href="../../../include/access/xlog.h.html#LN185"><span class='Ref_to_Const'>CHECKPOINT_CAUSE_XLOG</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="../../../interfaces/libpq/win32.h.html#LN11"><span class='Ref_to_Macro'>close</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN782"><span class='Ref_to_Global_Var'>readFile</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN782"><span class='Ref_to_Global_Var'>readFile</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN786"><span class='Ref_to_Global_Var'>readSource</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if readFile&GT;=0&&!XLByteI... &raquo; </span> 
 
    <a href="../../../include/access/xlog_internal.h.html#LN105"><span class='Ref_to_Macro'>XLByteToSeg</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN11443"><span class='Ref_to_Parameter'>targetPagePtr</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN783"><span class='Ref_to_Global_Var'>readSegNo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<a name="LN11482"></a><span class='Label'>retry</span><span class='Operator'>: 
</span>    <span class='Comment_Multi_Line'>/* See if we need to retrieve more data */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN782"><span class='Ref_to_Global_Var'>readFile</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span> <span class='Operator'>|| 
</span>        <span class='Parentheses'>(</span><a href="xlog.c.html#LN786"><span class='Ref_to_Global_Var'>readSource</span></a> <span class='Operator'>== </span><a href="xlog.c.html#LN758"><span class='Ref_to_EnumConst'>XLOG_FROM_STREAM</span></a> <span class='Operator'>&& 
</span>         <a href="xlog.c.html#LN199"><span class='Ref_to_Global_Var'>receivedUpto</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN11443"><span class='Ref_to_Parameter'>targetPagePtr</span></a> <span class='Operator'>+ </span><a href="xlog.c.html#LN11443"><span class='Ref_to_Parameter'>reqLen</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN875"><span class='Ref_to_Proto'>WaitForWALToBecomeAvailable</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN11443"><span class='Ref_to_Parameter'>targetPagePtr</span></a> <span class='Operator'>+ </span><a href="xlog.c.html#LN11443"><span class='Ref_to_Parameter'>reqLen</span></a><span class='Delimiter'>, 
</span>                                         <span class='Keyword'>private</span><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN802"><span class='Ref_to_Member'>randAccess</span></a><span class='Delimiter'>, 
</span>                                         <span class='Keyword'>private</span><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN801"><span class='Ref_to_Member'>fetching_ckpt</span></a><span class='Delimiter'>, 
</span>                                         <a href="xlog.c.html#LN11444"><span class='Ref_to_Parameter'>targetRecPtr</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN782"><span class='Ref_to_Global_Var'>readFile</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <a href="../../../interfaces/libpq/win32.h.html#LN11"><span class='Ref_to_Macro'>close</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN782"><span class='Ref_to_Global_Var'>readFile</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN782"><span class='Ref_to_Global_Var'>readFile</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN785"><span class='Ref_to_Global_Var'>readLen</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN786"><span class='Ref_to_Global_Var'>readSource</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>return</span> <span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * At this point, we have the right segment open and if we're streaming we 
     * know the requested record is in it. 
     */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN782"><span class='Ref_to_Global_Var'>readFile</span></a> <span class='Operator'>!= -</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the current segment is being streamed from master, calculate how 
     * much of the current page we have received already. We know the 
     * requested record has been received, but this is for the benefit of 
     * future calls, to allow quick exit at the top of this function. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN786"><span class='Ref_to_Global_Var'>readSource</span></a> <span class='Operator'>== </span><a href="xlog.c.html#LN758"><span class='Ref_to_EnumConst'>XLOG_FROM_STREAM</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(((</span><a href="xlog.c.html#LN11443"><span class='Ref_to_Parameter'>targetPagePtr</span></a><span class='Parentheses'>) </span><span class='Operator'>/ </span>XLOG_BLCKSZ<span class='Parentheses'>)</span> <span class='Operator'>!= </span><span class='Parentheses'>(</span><a href="xlog.c.html#LN199"><span class='Ref_to_Global_Var'>receivedUpto</span></a> <span class='Operator'>/ </span>XLOG_BLCKSZ<span class='Parentheses'>))</span> 
            <a href="xlog.c.html#LN785"><span class='Ref_to_Global_Var'>readLen</span></a> <span class='Operator'>= </span>XLOG_BLCKSZ<span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="xlog.c.html#LN785"><span class='Ref_to_Global_Var'>readLen</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN199"><span class='Ref_to_Global_Var'>receivedUpto</span></a> <span class='Operator'>% </span><a href="../../../include/access/xlog_internal.h.html#LN91"><span class='Ref_to_Const'>XLogSegSize</span></a> <span class='Operator'>- </span><a href="xlog.c.html#LN11449"><span class='Ref_To_Local'>targetPageOff</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
        <a href="xlog.c.html#LN785"><span class='Ref_to_Global_Var'>readLen</span></a> <span class='Operator'>= </span>XLOG_BLCKSZ<span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Read the requested page */ 
</span>    <a href="xlog.c.html#LN784"><span class='Ref_to_Global_Var'>readOff</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN11449"><span class='Ref_To_Local'>targetPageOff</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span>lseek<span class='Parentheses'>(</span><a href="xlog.c.html#LN782"><span class='Ref_to_Global_Var'>readFile</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span>off_t<span class='Parentheses'>) </span><a href="xlog.c.html#LN784"><span class='Ref_to_Global_Var'>readOff</span></a><span class='Delimiter'>, </span>SEEK_SET<span class='Parentheses'>)</span> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span><a name="LN11529"></a>        <span class='Keyword'>char</span>        <span class='Declare_Local'>fname</span><span class='Delimiter'>[</span><a href="../../../include/access/xlog_internal.h.html#LN137"><span class='Ref_to_Const'>MAXFNAMELEN</span></a><span class='Delimiter'>]; 
</span> 
        <a href="../../../include/access/xlog_internal.h.html#LN142"><span class='Ref_to_Macro'>XLogFileName</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN11529"><span class='Ref_To_Local'>fname</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN318"><span class='Ref_to_Global_Var'>curFileTLI</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN783"><span class='Ref_to_Global_Var'>readSegNo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN877"><span class='Ref_to_Proto'>emode_for_corrupt_record</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN11448"><span class='Ref_To_Local'>emode</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN11443"><span class='Ref_to_Parameter'>targetPagePtr</span></a> <span class='Operator'>+ </span><a href="xlog.c.html#LN11443"><span class='Ref_to_Parameter'>reqLen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not seek in log segment %s to offset %u: %m"</span><span class='Delimiter'>, 
</span>                        <a href="xlog.c.html#LN11529"><span class='Ref_To_Local'>fname</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN784"><span class='Ref_to_Global_Var'>readOff</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Control'>goto</span> <span class='Symbol_Characters'>&darr;</span><a href="xlog.c.html#LN11561"><span class='Ref_to_Label'>next_record_is_invalid</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/pgstat.h.html#LN1206"><span class='Ref_to_Func'>pgstat_report_wait_start</span></a><span class='Parentheses'>(</span><a href="../../../include/pgstat.h.html#LN902"><span class='Ref_to_EnumConst'>WAIT_EVENT_WAL_READ</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../interfaces/libpq/win32.h.html#LN12"><span class='Ref_to_Macro'>read</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN782"><span class='Ref_to_Global_Var'>readFile</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN11444"><span class='Ref_to_Parameter'>readBuf</span></a><span class='Delimiter'>, </span>XLOG_BLCKSZ<span class='Parentheses'>) </span><span class='Operator'>!= </span>XLOG_BLCKSZ<span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span><a name="LN11542"></a>        <span class='Keyword'>char</span>        <span class='Declare_Local'>fname</span><span class='Delimiter'>[</span><a href="../../../include/access/xlog_internal.h.html#LN137"><span class='Ref_to_Const'>MAXFNAMELEN</span></a><span class='Delimiter'>]; 
</span> 
        <a href="../../../include/pgstat.h.html#LN1230"><span class='Ref_to_Func'>pgstat_report_wait_end</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <a href="../../../include/access/xlog_internal.h.html#LN142"><span class='Ref_to_Macro'>XLogFileName</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN11542"><span class='Ref_To_Local'>fname</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN318"><span class='Ref_to_Global_Var'>curFileTLI</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN783"><span class='Ref_to_Global_Var'>readSegNo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN877"><span class='Ref_to_Proto'>emode_for_corrupt_record</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN11448"><span class='Ref_To_Local'>emode</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN11443"><span class='Ref_to_Parameter'>targetPagePtr</span></a> <span class='Operator'>+ </span><a href="xlog.c.html#LN11443"><span class='Ref_to_Parameter'>reqLen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not read from log segment %s, offset %u: %m"</span><span class='Delimiter'>, 
</span>                        <a href="xlog.c.html#LN11542"><span class='Ref_To_Local'>fname</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN784"><span class='Ref_to_Global_Var'>readOff</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Control'>goto</span> <span class='Symbol_Characters'>&darr;</span><a href="xlog.c.html#LN11561"><span class='Ref_to_Label'>next_record_is_invalid</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="../../../include/pgstat.h.html#LN1230"><span class='Ref_to_Func'>pgstat_report_wait_end</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span>targetSegNo <span class='Operator'>== </span><a href="xlog.c.html#LN783"><span class='Ref_to_Global_Var'>readSegNo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN11449"><span class='Ref_To_Local'>targetPageOff</span></a> <span class='Operator'>== </span><a href="xlog.c.html#LN784"><span class='Ref_to_Global_Var'>readOff</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN11443"><span class='Ref_to_Parameter'>reqLen</span></a> <span class='Operator'>&LT;= </span><a href="xlog.c.html#LN785"><span class='Ref_to_Global_Var'>readLen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Operator'>*</span><a href="xlog.c.html#LN11444"><span class='Ref_to_Parameter'>readTLI</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN318"><span class='Ref_to_Global_Var'>curFileTLI</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="xlog.c.html#LN785"><span class='Ref_to_Global_Var'>readLen</span></a><span class='Delimiter'>; 
</span> 
<a name="LN11561"></a><span class='Label'>next_record_is_invalid</span><span class='Operator'>: 
</span>    <a href="xlog.c.html#LN796"><span class='Ref_to_Global_Var'>lastSourceFailed</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN782"><span class='Ref_to_Global_Var'>readFile</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="../../../interfaces/libpq/win32.h.html#LN11"><span class='Ref_to_Macro'>close</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN782"><span class='Ref_to_Global_Var'>readFile</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN782"><span class='Ref_to_Global_Var'>readFile</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN785"><span class='Ref_to_Global_Var'>readLen</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN786"><span class='Ref_to_Global_Var'>readSource</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* In standby-mode, keep trying */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN276"><span class='Ref_to_Global_Var'>StandbyMode</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>goto</span> <span class='Symbol_Characters'>&uarr;</span><a href="xlog.c.html#LN11482"><span class='Ref_to_Label'>retry</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <span class='Control'>return</span> <span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end XLogPageRead &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Open the WAL segment containing WAL location 'RecPtr'. 
 * 
 * The segment can be fetched via restore_command, or via walreceiver having 
 * streamed the record, or it can already be present in pg_wal. Checking 
 * pg_wal is mainly for crash recovery, but it will be polled in standby mode 
 * too, in case someone copies a new segment directly to pg_wal. That is not 
 * documented or recommended, though. 
 * 
 * If 'fetching_ckpt' is true, we're fetching a checkpoint record, and should 
 * prepare to read WAL starting from RedoStartLSN after this. 
 * 
 * 'RecPtr' might not point to the beginning of the record we're interested 
 * in, it might also point to the page or segment header. In that case, 
 * 'tliRecPtr' is the position of the WAL record we're interested in. It is 
 * used to decide which timeline to stream the requested WAL from. 
 * 
 * If the record is not immediately available, the function returns false 
 * if we're not in standby mode. In standby mode, waits for it to become 
 * available. 
 * 
 * When the requested record becomes available, the function opens the file 
 * containing it (if not open already), and returns true. When end of standby 
 * mode is triggered by the user, and there is no more WAL available, returns 
 * false. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN11604"></a><span class='Declare_Function'>WaitForWALToBecomeAvailable</span><span class='Parentheses'>(</span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>RecPtr</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>randAccess</span><span class='Delimiter'>, 
</span><a name="LN11605"></a>                            <span class='Keyword'>bool </span><span class='Declare_Parameter'>fetching_ckpt</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>tliRecPtr</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN11607"></a>    <span class='Keyword'>static </span><a href="../../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <span class='Declare_Local'>last_fail_time</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN11608"></a>    <a href="../../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <span class='Declare_Local'>now</span><span class='Delimiter'>; 
</span><a name="LN11609"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>streaming_reply_sent</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/*------- 
     * Standby mode is implemented by a state machine: 
     * 
     * 1. Read from either archive or pg_wal (XLOG_FROM_ARCHIVE), or just 
     *    pg_wal (XLOG_FROM_PG_WAL) 
     * 2. Check trigger file 
     * 3. Read from primary server via walreceiver (XLOG_FROM_STREAM) 
     * 4. Rescan timelines 
     * 5. Sleep wal_retrieve_retry_interval milliseconds, and loop back to 1. 
     * 
     * Failure to read from the current source advances the state machine to 
     * the next state. 
     * 
     * 'currentSource' indicates the current state. There are no currentSource 
     * values for "check trigger", "rescan timelines", and "sleep" states, 
     * those actions are taken when reading from the previous source fails, as 
     * part of advancing to the next state. 
     *------- 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN246"><span class='Ref_to_Global_Var'>InArchiveRecovery</span></a><span class='Parentheses'>) 
</span>        <a href="xlog.c.html#LN795"><span class='Ref_to_Global_Var'>currentSource</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN757"><span class='Ref_to_EnumConst'>XLOG_FROM_PG_WAL</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN795"><span class='Ref_to_Global_Var'>currentSource</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="xlog.c.html#LN795"><span class='Ref_to_Global_Var'>currentSource</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN756"><span class='Ref_to_EnumConst'>XLOG_FROM_ARCHIVE</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>;;</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN11637"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>oldSource</span> <span class='Operator'>= </span><a href="xlog.c.html#LN795"><span class='Ref_to_Global_Var'>currentSource</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * First check if we failed to read from the current source, and 
         * advance the state machine if so. The failure to read might've 
         * happened outside this function, e.g when a CRC check fails on a 
         * record, or within this loop. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN796"><span class='Ref_to_Global_Var'>lastSourceFailed</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN795"><span class='Ref_to_Global_Var'>currentSource</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>case</span> <a href="xlog.c.html#LN756"><span class='Ref_to_EnumConst'>XLOG_FROM_ARCHIVE</span></a><span class='Operator'>: 
</span>                <span class='Control'>case</span> <a href="xlog.c.html#LN757"><span class='Ref_to_EnumConst'>XLOG_FROM_PG_WAL</span></a><span class='Operator'>: 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * Check to see if the trigger file exists. Note that we 
                     * do this only after failure, so when you create the 
                     * trigger file, we still finish replaying as much as we 
                     * can from archive and pg_wal before failover. 
                     */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN276"><span class='Ref_to_Global_Var'>StandbyMode</span></a> <span class='Operator'>&& </span><a href="xlog.c.html#LN895"><span class='Ref_to_Proto'>CheckForStandbyTrigger</span></a><span class='Parentheses'>())</span> 
                    <span class='Delimiter'>{ 
</span>                        <a href="../../replication/walreceiverfuncs.c.html#LN161"><span class='Ref_to_Func'>ShutdownWalRcv</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>                        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * Not in standby mode, and we've now tried the archive 
                     * and pg_wal. 
                     */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN276"><span class='Ref_to_Global_Var'>StandbyMode</span></a><span class='Parentheses'>) 
</span>                        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * If primary_conninfo is set, launch walreceiver to try 
                     * to stream the missing WAL. 
                     * 
                     * If fetching_ckpt is TRUE, RecPtr points to the initial 
                     * checkpoint location. In that case, we use RedoStartLSN 
                     * as the streaming start position instead of RecPtr, so 
                     * that when we later jump backwards to start redo at 
                     * RedoStartLSN, we will have the logs streamed already. 
                     */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN271"><span class='Ref_to_Global_Var'>PrimaryConnInfo</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span><a name="LN11683"></a>                        <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>ptr</span><span class='Delimiter'>; 
</span><a name="LN11684"></a>                        <a href="../../../include/access/xlogdefs.h.html#LN44"><span class='Ref_to_Typedef'>TimeLineID</span></a>  <span class='Declare_Local'>tli</span><span class='Delimiter'>; 
</span> 
                        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN11605"><span class='Ref_to_Parameter'>fetching_ckpt</span></a><span class='Parentheses'>) 
</span>                        <span class='Delimiter'>{ 
</span>                            <a href="xlog.c.html#LN11683"><span class='Ref_To_Local'>ptr</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN371"><span class='Ref_to_Global_Var'>RedoStartLSN</span></a><span class='Delimiter'>; 
</span>                            <a href="xlog.c.html#LN11684"><span class='Ref_To_Local'>tli</span></a> <span class='Operator'>= </span><a href="../../../bin/pg_resetwal/pg_resetwal.c.html#LN59"><span class='Ref_to_Global_Var'>ControlFile</span></a><span class='Operator'>-&GT;</span><a href="../../../include/catalog/pg_control.h.html#LN134"><span class='Ref_to_Member'>checkPointCopy</span></a><span class='Operator'>.</span><a href="../../../include/catalog/pg_control.h.html#LN36"><span class='Ref_to_Member'>ThisTimeLineID</span></a><span class='Delimiter'>; 
</span>                        <span class='Delimiter'>} 
</span>                        <span class='Control'>else</span> 
                        <span class='Delimiter'>{ 
</span>                            <a href="xlog.c.html#LN11683"><span class='Ref_To_Local'>ptr</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN11605"><span class='Ref_to_Parameter'>tliRecPtr</span></a><span class='Delimiter'>; 
</span>                            <a href="xlog.c.html#LN11684"><span class='Ref_To_Local'>tli</span></a> <span class='Operator'>= </span><a href="../../../include/access/timeline.h.html#LN39"><span class='Ref_to_Proto'>tliOfPointInHistory</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN11605"><span class='Ref_to_Parameter'>tliRecPtr</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN317"><span class='Ref_to_Global_Var'>expectedTLEs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN318"><span class='Ref_to_Global_Var'>curFileTLI</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="xlog.c.html#LN11684"><span class='Ref_To_Local'>tli</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN318"><span class='Ref_to_Global_Var'>curFileTLI</span></a><span class='Parentheses'>) 
</span>                                <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"according to history file, WAL location %X/%X belongs to timeline %u, but previous recovered WAL file came from timeline %u"</span><span class='Delimiter'>, 
</span>                                     <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) (</span><a href="xlog.c.html#LN11683"><span class='Ref_To_Local'>ptr</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>32</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a><span class='Parentheses'>) </span><a href="xlog.c.html#LN11683"><span class='Ref_To_Local'>ptr</span></a><span class='Delimiter'>, 
</span>                                     <a href="xlog.c.html#LN11684"><span class='Ref_To_Local'>tli</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN318"><span class='Ref_to_Global_Var'>curFileTLI</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                        <span class='Delimiter'>} 
</span>                        <a href="xlog.c.html#LN318"><span class='Ref_to_Global_Var'>curFileTLI</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN11684"><span class='Ref_To_Local'>tli</span></a><span class='Delimiter'>; 
</span>                        <a href="../../replication/walreceiverfuncs.c.html#LN221"><span class='Ref_to_Func'>RequestXLogStreaming</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN11684"><span class='Ref_To_Local'>tli</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN11683"><span class='Ref_To_Local'>ptr</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN271"><span class='Ref_to_Global_Var'>PrimaryConnInfo</span></a><span class='Delimiter'>, 
</span>                                             <a href="xlog.c.html#LN272"><span class='Ref_to_Global_Var'>PrimarySlotName</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                        <a href="xlog.c.html#LN199"><span class='Ref_to_Global_Var'>receivedUpto</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if PrimaryConnInfo &raquo; </span> 
 
                    <span class='Comment_Multi_Line'>/* 
                     * Move to XLOG_FROM_STREAM state in either case. We'll 
                     * get immediate failure if we didn't launch walreceiver, 
                     * and move on to the next state. 
                     */ 
</span>                    <a href="xlog.c.html#LN795"><span class='Ref_to_Global_Var'>currentSource</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN758"><span class='Ref_to_EnumConst'>XLOG_FROM_STREAM</span></a><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>case</span> <a href="xlog.c.html#LN758"><span class='Ref_to_EnumConst'>XLOG_FROM_STREAM</span></a><span class='Operator'>: 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * Failure while streaming. Most likely, we got here 
                     * because streaming replication was terminated, or 
                     * promotion was triggered. But we also get here if we 
                     * find an invalid record in the WAL streamed from master, 
                     * in which case something is seriously wrong. There's 
                     * little chance that the problem will just go away, but 
                     * PANIC is not good for availability either, especially 
                     * in hot standby mode. So, we treat that the same as 
                     * disconnection, and retry from archive/pg_wal again. The 
                     * WAL in the archive should be identical to what was 
                     * streamed, so it's unlikely that it helps, but one can 
                     * hope... 
                     */ 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * Before we leave XLOG_FROM_STREAM state, make sure that 
                     * walreceiver is not active, so that it won't overwrite 
                     * WAL that we restore from archive. 
                     */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../replication/walreceiverfuncs.c.html#LN115"><span class='Ref_to_Func'>WalRcvStreaming</span></a><span class='Parentheses'>())</span> 
                        <a href="../../replication/walreceiverfuncs.c.html#LN161"><span class='Ref_to_Func'>ShutdownWalRcv</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * Before we sleep, re-scan for possible new timelines if 
                     * we were requested to recover to the latest timeline. 
                     */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN316"><span class='Ref_to_Global_Var'>recoveryTargetIsLatest</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN891"><span class='Ref_to_Proto'>rescanLatestTimeLine</span></a><span class='Parentheses'>())</span> 
                        <span class='Delimiter'>{ 
</span>                            <a href="xlog.c.html#LN795"><span class='Ref_to_Global_Var'>currentSource</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN756"><span class='Ref_to_EnumConst'>XLOG_FROM_ARCHIVE</span></a><span class='Delimiter'>; 
</span>                            <span class='Control'>break</span><span class='Delimiter'>; 
</span>                        <span class='Delimiter'>} 
</span>                    <span class='Delimiter'>} 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * XLOG_FROM_STREAM is the last state in our state 
                     * machine, so we've exhausted all the options for 
                     * obtaining the requested WAL. We're going to loop back 
                     * and retry from the archive, but if it hasn't been long 
                     * since last attempt, sleep wal_retrieve_retry_interval 
                     * milliseconds to avoid busy-waiting. 
                     */ 
</span>                    <a href="xlog.c.html#LN11608"><span class='Ref_To_Local'>now</span></a> <span class='Operator'>= </span><a href="../../../include/utils/timestamp.h.html#LN69"><span class='Ref_to_Proto'>GetCurrentTimestamp</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/utils/timestamp.h.html#LN74"><span class='Ref_to_Proto'>TimestampDifferenceExceeds</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN11607"><span class='Ref_To_Local'>last_fail_time</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN11608"><span class='Ref_To_Local'>now</span></a><span class='Delimiter'>, 
</span>                                                <a href="xlog.c.html#LN106"><span class='Ref_to_Global_Var'>wal_retrieve_retry_interval</span></a><span class='Parentheses'>))</span> 
                    <span class='Delimiter'>{ 
</span><a name="LN11765"></a>                        <span class='Keyword'>long</span>        <span class='Declare_Local'>secs</span><span class='Delimiter'>, 
</span><a name="LN11766"></a>                                    <span class='Declare_Local'>wait_time</span><span class='Delimiter'>; 
</span><a name="LN11767"></a>                        <span class='Keyword'>int</span>         <span class='Declare_Local'>usecs</span><span class='Delimiter'>; 
</span> 
                        <a href="../../../include/utils/timestamp.h.html#LN72"><span class='Ref_to_Proto'>TimestampDifference</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN11607"><span class='Ref_To_Local'>last_fail_time</span></a><span class='Delimiter'>, </span><a href="xlog.c.html#LN11608"><span class='Ref_To_Local'>now</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN11765"><span class='Ref_To_Local'>secs</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN11767"><span class='Ref_To_Local'>usecs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                        <a href="xlog.c.html#LN11766"><span class='Ref_To_Local'>wait_time</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN106"><span class='Ref_to_Global_Var'>wal_retrieve_retry_interval</span></a> <span class='Operator'>- 
</span>                            <span class='Parentheses'>(</span><a href="xlog.c.html#LN11765"><span class='Ref_To_Local'>secs</span></a> <span class='Operator'>* </span><span class='Number'>1000</span> <span class='Operator'>+ </span><a href="xlog.c.html#LN11767"><span class='Ref_To_Local'>usecs</span></a> <span class='Operator'>/ </span><span class='Number'>1000</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                        <a href="../../../include/storage/latch.h.html#LN163"><span class='Ref_to_Proto'>WaitLatch</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN661"><span class='Ref_to_Member'>recoveryWakeupLatch</span></a><span class='Delimiter'>, 
</span>                             <a href="../../../include/storage/latch.h.html#LN123"><span class='Ref_to_Const'>WL_LATCH_SET</span></a> <span class='Operator'>| </span><a href="../../../include/storage/latch.h.html#LN126"><span class='Ref_to_Const'>WL_TIMEOUT</span></a> <span class='Operator'>| </span><a href="../../../include/storage/latch.h.html#LN127"><span class='Ref_to_Const'>WL_POSTMASTER_DEATH</span></a><span class='Delimiter'>, 
</span>                                  <a href="xlog.c.html#LN11766"><span class='Ref_To_Local'>wait_time</span></a><span class='Delimiter'>, </span><a href="../../../include/pgstat.h.html#LN763"><span class='Ref_to_EnumConst'>WAIT_EVENT_RECOVERY_WAL_STREAM</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                        <a href="../../../include/storage/latch.h.html#LN152"><span class='Ref_to_Proto'>ResetLatch</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN661"><span class='Ref_to_Member'>recoveryWakeupLatch</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                        <a href="xlog.c.html#LN11608"><span class='Ref_To_Local'>now</span></a> <span class='Operator'>= </span><a href="../../../include/utils/timestamp.h.html#LN69"><span class='Ref_to_Proto'>GetCurrentTimestamp</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                    <a href="xlog.c.html#LN11607"><span class='Ref_To_Local'>last_fail_time</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN11608"><span class='Ref_To_Local'>now</span></a><span class='Delimiter'>; 
</span>                    <a href="xlog.c.html#LN795"><span class='Ref_to_Global_Var'>currentSource</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN756"><span class='Ref_to_EnumConst'>XLOG_FROM_ARCHIVE</span></a><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>default</span><span class='Operator'>: 
</span>                    <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unexpected WAL source %d"</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN795"><span class='Ref_to_Global_Var'>currentSource</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch currentSource &raquo; </span> 
        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if lastSourceFailed &raquo; </span> 
        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN795"><span class='Ref_to_Global_Var'>currentSource</span></a> <span class='Operator'>== </span><a href="xlog.c.html#LN757"><span class='Ref_to_EnumConst'>XLOG_FROM_PG_WAL</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * We just successfully read a file in pg_wal. We prefer files in 
             * the archive over ones in pg_wal, so try the next file again 
             * from the archive first. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN246"><span class='Ref_to_Global_Var'>InArchiveRecovery</span></a><span class='Parentheses'>) 
</span>                <a href="xlog.c.html#LN795"><span class='Ref_to_Global_Var'>currentSource</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN756"><span class='Ref_to_EnumConst'>XLOG_FROM_ARCHIVE</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN795"><span class='Ref_to_Global_Var'>currentSource</span></a> <span class='Operator'>!= </span><a href="xlog.c.html#LN11637"><span class='Ref_To_Local'>oldSource</span></a><span class='Parentheses'>) 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Delimiter'>, </span><span class='String'>"switched WAL source from %s to %s after %s"</span><span class='Delimiter'>, 
</span>                 <a href="xlog.c.html#LN762"><span class='Ref_to_Global_Var'>xlogSourceNames</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN11637"><span class='Ref_To_Local'>oldSource</span></a><span class='Delimiter'>], </span><a href="xlog.c.html#LN762"><span class='Ref_to_Global_Var'>xlogSourceNames</span></a><span class='Delimiter'>[</span><a href="xlog.c.html#LN795"><span class='Ref_to_Global_Var'>currentSource</span></a><span class='Delimiter'>], 
</span>                 <a href="xlog.c.html#LN796"><span class='Ref_to_Global_Var'>lastSourceFailed</span></a> <span class='Operator'>? </span><span class='String'>"failure"</span> <span class='Operator'>: </span><span class='String'>"success"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We've now handled possible failure. Try to read from the chosen 
         * source. 
         */ 
</span>        <a href="xlog.c.html#LN796"><span class='Ref_to_Global_Var'>lastSourceFailed</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN795"><span class='Ref_to_Global_Var'>currentSource</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>case</span> <a href="xlog.c.html#LN756"><span class='Ref_to_EnumConst'>XLOG_FROM_ARCHIVE</span></a><span class='Operator'>: 
</span>            <span class='Control'>case</span> <a href="xlog.c.html#LN757"><span class='Ref_to_EnumConst'>XLOG_FROM_PG_WAL</span></a><span class='Operator'>: 
</span>                <span class='Comment_Multi_Line'>/* Close any old file we might have open. */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN782"><span class='Ref_to_Global_Var'>readFile</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <a href="../../../interfaces/libpq/win32.h.html#LN11"><span class='Ref_to_Macro'>close</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN782"><span class='Ref_to_Global_Var'>readFile</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="xlog.c.html#LN782"><span class='Ref_to_Global_Var'>readFile</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Comment_Multi_Line'>/* Reset curFileTLI if random fetch. */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN11604"><span class='Ref_to_Parameter'>randAccess</span></a><span class='Parentheses'>) 
</span>                    <a href="xlog.c.html#LN318"><span class='Ref_to_Global_Var'>curFileTLI</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * Try to restore the file from archive, or read an existing 
                 * file from pg_wal. 
                 */ 
</span>                <a href="xlog.c.html#LN782"><span class='Ref_to_Global_Var'>readFile</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN871"><span class='Ref_to_Proto'>XLogFileReadAnyTLI</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN783"><span class='Ref_to_Global_Var'>readSegNo</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Delimiter'>, 
</span>                         <a href="xlog.c.html#LN795"><span class='Ref_to_Global_Var'>currentSource</span></a> <span class='Operator'>== </span><a href="xlog.c.html#LN756"><span class='Ref_to_EnumConst'>XLOG_FROM_ARCHIVE</span></a> <span class='Operator'>? </span><a href="xlog.c.html#LN755"><span class='Ref_to_EnumConst'>XLOG_FROM_ANY</span></a> <span class='Operator'>: 
</span>                                              <a href="xlog.c.html#LN795"><span class='Ref_to_Global_Var'>currentSource</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN782"><span class='Ref_to_Global_Var'>readFile</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* success! */ 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * Nope, not found in archive or pg_wal. 
                 */ 
</span>                <a href="xlog.c.html#LN796"><span class='Ref_to_Global_Var'>lastSourceFailed</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>case</span> <a href="xlog.c.html#LN758"><span class='Ref_to_EnumConst'>XLOG_FROM_STREAM</span></a><span class='Operator'>: 
</span>                <span class='Delimiter'>{ 
</span><a name="LN11841"></a>                    <span class='Keyword'>bool</span>        <span class='Declare_Local'>havedata</span><span class='Delimiter'>; 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * Check if WAL receiver is still active. 
                     */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../replication/walreceiverfuncs.c.html#LN115"><span class='Ref_to_Func'>WalRcvStreaming</span></a><span class='Parentheses'>())</span> 
                    <span class='Delimiter'>{ 
</span>                        <a href="xlog.c.html#LN796"><span class='Ref_to_Global_Var'>lastSourceFailed</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                        <span class='Control'>break</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * Walreceiver is active, so see if new data has arrived. 
                     * 
                     * We only advance XLogReceiptTime when we obtain fresh 
                     * WAL from walreceiver and observe that we had already 
                     * processed everything before the most recent "chunk" 
                     * that it flushed to disk.  In steady state where we are 
                     * keeping up with the incoming data, XLogReceiptTime will 
                     * be updated on each cycle. When we are behind, 
                     * XLogReceiptTime will not advance, so the grace time 
                     * allotted to conflicting queries will decrease. 
                     */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN11604"><span class='Ref_to_Parameter'>RecPtr</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN199"><span class='Ref_to_Global_Var'>receivedUpto</span></a><span class='Parentheses'>) 
</span>                        <a href="xlog.c.html#LN11841"><span class='Ref_To_Local'>havedata</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                    <span class='Control'>else</span> 
                    <span class='Delimiter'>{ 
</span><a name="LN11868"></a>                        <a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a>  <span class='Declare_Local'>latestChunkStart</span><span class='Delimiter'>; 
</span> 
                        <a href="xlog.c.html#LN199"><span class='Ref_to_Global_Var'>receivedUpto</span></a> <span class='Operator'>= </span><a href="../../replication/walreceiverfuncs.c.html#LN292"><span class='Ref_to_Func'>GetWalRcvWriteRecPtr</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN11868"><span class='Ref_To_Local'>latestChunkStart</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN200"><span class='Ref_to_Global_Var'>receiveTLI</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN11604"><span class='Ref_to_Parameter'>RecPtr</span></a> <span class='Operator'>&LT; </span><a href="xlog.c.html#LN199"><span class='Ref_to_Global_Var'>receivedUpto</span></a> <span class='Operator'>&& </span><a href="xlog.c.html#LN200"><span class='Ref_to_Global_Var'>receiveTLI</span></a> <span class='Operator'>== </span><a href="xlog.c.html#LN318"><span class='Ref_to_Global_Var'>curFileTLI</span></a><span class='Parentheses'>) 
</span>                        <span class='Delimiter'>{ 
</span>                            <a href="xlog.c.html#LN11841"><span class='Ref_To_Local'>havedata</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN11868"><span class='Ref_To_Local'>latestChunkStart</span></a> <span class='Operator'>&LT;= </span><a href="xlog.c.html#LN11604"><span class='Ref_to_Parameter'>RecPtr</span></a><span class='Parentheses'>) 
</span>                            <span class='Delimiter'>{ 
</span>                                <a href="xlog.c.html#LN813"><span class='Ref_to_Global_Var'>XLogReceiptTime</span></a> <span class='Operator'>= </span><a href="../../../include/utils/timestamp.h.html#LN69"><span class='Ref_to_Proto'>GetCurrentTimestamp</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>                                <a href="xlog.c.html#LN852"><span class='Ref_to_Proto'>SetCurrentChunkStartTime</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN813"><span class='Ref_to_Global_Var'>XLogReceiptTime</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                            <span class='Delimiter'>} 
</span>                        <span class='Delimiter'>} 
</span>                        <span class='Control'>else</span> 
                            <a href="xlog.c.html#LN11841"><span class='Ref_To_Local'>havedata</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN11841"><span class='Ref_To_Local'>havedata</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <span class='Comment_Multi_Line'>/* 
                         * Great, streamed far enough.  Open the file if it's 
                         * not open already.  Also read the timeline history 
                         * file if we haven't initialized timeline history 
                         * yet; it should be streamed over and present in 
                         * pg_wal by now.  Use XLOG_FROM_STREAM so that source 
                         * info is set correctly and XLogReceiptTime isn't 
                         * changed. 
                         */ 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN782"><span class='Ref_to_Global_Var'>readFile</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                        <span class='Delimiter'>{ 
</span>                            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN317"><span class='Ref_to_Global_Var'>expectedTLEs</span></a><span class='Parentheses'>) 
</span>                                <a href="xlog.c.html#LN317"><span class='Ref_to_Global_Var'>expectedTLEs</span></a> <span class='Operator'>= </span><a href="../../../include/access/timeline.h.html#LN31"><span class='Ref_to_Proto'>readTimeLineHistory</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN200"><span class='Ref_to_Global_Var'>receiveTLI</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                            <a href="xlog.c.html#LN782"><span class='Ref_to_Global_Var'>readFile</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN869"><span class='Ref_to_Proto'>XLogFileRead</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN783"><span class='Ref_to_Global_Var'>readSegNo</span></a><span class='Delimiter'>, </span><a href="../../../include/utils/elog.h.html#LN52"><span class='Ref_to_Const'>PANIC</span></a><span class='Delimiter'>, 
</span>                                                    <a href="xlog.c.html#LN200"><span class='Ref_to_Global_Var'>receiveTLI</span></a><span class='Delimiter'>, 
</span>                                                    <a href="xlog.c.html#LN758"><span class='Ref_to_EnumConst'>XLOG_FROM_STREAM</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="xlog.c.html#LN782"><span class='Ref_to_Global_Var'>readFile</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                        <span class='Delimiter'>} 
</span>                        <span class='Control'>else</span> 
                        <span class='Delimiter'>{ 
</span>                            <span class='Comment_Multi_Line'>/* just make sure source info is correct... */ 
</span>                            <a href="xlog.c.html#LN786"><span class='Ref_to_Global_Var'>readSource</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN758"><span class='Ref_to_EnumConst'>XLOG_FROM_STREAM</span></a><span class='Delimiter'>; 
</span>                            <a href="xlog.c.html#LN814"><span class='Ref_to_Global_Var'>XLogReceiptSource</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN758"><span class='Ref_to_EnumConst'>XLOG_FROM_STREAM</span></a><span class='Delimiter'>; 
</span>                            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                        <span class='Delimiter'>} 
</span>                        <span class='Control'>break</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if havedata &raquo; </span> 
 
                    <span class='Comment_Multi_Line'>/* 
                     * Data not here yet. Check for trigger, then wait for 
                     * walreceiver to wake us up when new WAL arrives. 
                     */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN895"><span class='Ref_to_Proto'>CheckForStandbyTrigger</span></a><span class='Parentheses'>())</span> 
                    <span class='Delimiter'>{ 
</span>                        <span class='Comment_Multi_Line'>/* 
                         * Note that we don't "return false" immediately here. 
                         * After being triggered, we still want to replay all 
                         * the WAL that was already streamed. It's in pg_wal 
                         * now, so we just treat this as a failure, and the 
                         * state machine will move on to replay the streamed 
                         * WAL from pg_wal, and then recheck the trigger and 
                         * exit replay. 
                         */ 
</span>                        <a href="xlog.c.html#LN796"><span class='Ref_to_Global_Var'>lastSourceFailed</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                        <span class='Control'>break</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * Since we have replayed everything we have received so 
                     * far and are about to start waiting for more WAL, let's 
                     * tell the upstream server our replay location now so 
                     * that pg_stat_replication doesn't show stale 
                     * information. 
                     */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="xlog.c.html#LN11609"><span class='Ref_To_Local'>streaming_reply_sent</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <a href="../../../include/replication/walreceiver.h.html#LN298"><span class='Ref_to_Proto'>WalRcvForceReply</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>                        <a href="xlog.c.html#LN11609"><span class='Ref_To_Local'>streaming_reply_sent</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * Wait for more WAL to arrive. Time out after 5 seconds 
                     * to react to a trigger file promptly. 
                     */ 
</span>                    <a href="../../../include/storage/latch.h.html#LN163"><span class='Ref_to_Proto'>WaitLatch</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN661"><span class='Ref_to_Member'>recoveryWakeupLatch</span></a><span class='Delimiter'>, 
</span>                              <a href="../../../include/storage/latch.h.html#LN123"><span class='Ref_to_Const'>WL_LATCH_SET</span></a> <span class='Operator'>| </span><a href="../../../include/storage/latch.h.html#LN126"><span class='Ref_to_Const'>WL_TIMEOUT</span></a> <span class='Operator'>| </span><a href="../../../include/storage/latch.h.html#LN127"><span class='Ref_to_Const'>WL_POSTMASTER_DEATH</span></a><span class='Delimiter'>, 
</span>                              <span class='Number'>5000L</span><span class='Delimiter'>, </span><a href="../../../include/pgstat.h.html#LN762"><span class='Ref_to_EnumConst'>WAIT_EVENT_RECOVERY_WAL_ALL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="../../../include/storage/latch.h.html#LN152"><span class='Ref_to_Proto'>ResetLatch</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN661"><span class='Ref_to_Member'>recoveryWakeupLatch</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
            <span class='Control'>default</span><span class='Operator'>: 
</span>                <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unexpected WAL source %d"</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN795"><span class='Ref_to_Global_Var'>currentSource</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch currentSource &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* 
         * This possibly-long loop needs to handle interrupts of startup 
         * process. 
         */ 
</span>        <a href="../../../include/postmaster/startup.h.html#LN14"><span class='Ref_to_Proto'>HandleStartupProcInterrupts</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for ;; &raquo; </span> 
 
    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>               <span class='Comment_Single_Line'>/* not reached */ 
</span><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end WaitForWALToBecomeAvailable &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Determine what log level should be used to report a corrupt WAL record 
 * in the current WAL page, previously read by XLogPageRead(). 
 * 
 * 'emode' is the error mode that would be used to report a file-not-found 
 * or legitimate end-of-WAL situation.   Generally, we use it as-is, but if 
 * we're retrying the exact same record that we've tried previously, only 
 * complain the first time to keep the noise down.  However, we only do when 
 * reading from pg_wal, because we don't expect any invalid records in archive 
 * or in records streamed from master. Files in the archive should be complete, 
 * and we should never hit the end of WAL because we stop and wait for more WAL 
 * to arrive before replaying it. 
 * 
 * NOTE: This function remembers the RecPtr value it was last called with, 
 * to suppress repeated messages about the same record. Only call this when 
 * you are about to ereport(), or you might cause a later message to be 
 * erroneously suppressed. 
 */ 
</span><span class='Keyword'>static int 
</span><a name="LN11989"></a><span class='Declare_Function'>emode_for_corrupt_record</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>emode</span><span class='Delimiter'>, </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Parameter'>RecPtr</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN11991"></a>    <span class='Keyword'>static </span><a href="../../../include/access/xlogdefs.h.html#LN20"><span class='Ref_to_Typedef'>XLogRecPtr</span></a> <span class='Declare_Local'>lastComplaint</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN786"><span class='Ref_to_Global_Var'>readSource</span></a> <span class='Operator'>== </span><a href="xlog.c.html#LN757"><span class='Ref_to_EnumConst'>XLOG_FROM_PG_WAL</span></a> <span class='Operator'>&& </span><a href="xlog.c.html#LN11989"><span class='Ref_to_Parameter'>emode</span></a> <span class='Operator'>== </span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN11989"><span class='Ref_to_Parameter'>RecPtr</span></a> <span class='Operator'>== </span><a href="xlog.c.html#LN11991"><span class='Ref_To_Local'>lastComplaint</span></a><span class='Parentheses'>) 
</span>            <a href="xlog.c.html#LN11989"><span class='Ref_to_Parameter'>emode</span></a> <span class='Operator'>= </span><a href="../../../include/utils/elog.h.html#LN24"><span class='Ref_to_Const'>DEBUG1</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="xlog.c.html#LN11991"><span class='Ref_To_Local'>lastComplaint</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN11989"><span class='Ref_to_Parameter'>RecPtr</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <a href="xlog.c.html#LN11989"><span class='Ref_to_Parameter'>emode</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Check to see whether the user-specified trigger file exists and whether a 
 * promote request has arrived.  If either condition holds, return true. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN12008"></a><span class='Declare_Function'>CheckForStandbyTrigger</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN12010"></a>    <span class='Control'>struct</span> <a href="../../../include/port.h.html#LN275"><span class='Ref_to_Macro'>stat</span></a> <span class='Declare_Local'>stat_buf</span><span class='Delimiter'>; 
</span><a name="LN12011"></a>    <span class='Keyword'>static bool </span><span class='Declare_Local'>triggered</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN12011"><span class='Ref_To_Local'>triggered</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/postmaster/startup.h.html#LN18"><span class='Ref_to_Proto'>IsPromoteTriggered</span></a><span class='Parentheses'>())</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * In 9.1 and 9.2 the postmaster unlinked the promote file inside the 
         * signal handler. It now leaves the file in place and lets the 
         * Startup process do the unlink. This allows Startup to know whether 
         * it should create a full checkpoint before starting up (fallback 
         * mode). Fast promotion takes precedence. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/port.h.html#LN275"><span class='Ref_to_Macro'>stat</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN83"><span class='Ref_to_Const'>PROMOTE_SIGNAL_FILE</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN12010"><span class='Ref_To_Local'>stat_buf</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <a href="../../../timezone/private.h.html#LN59"><span class='Ref_to_Proto'>unlink</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN83"><span class='Ref_to_Const'>PROMOTE_SIGNAL_FILE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../timezone/private.h.html#LN59"><span class='Ref_to_Proto'>unlink</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN84"><span class='Ref_to_Const'>FALLBACK_PROMOTE_SIGNAL_FILE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN279"><span class='Ref_to_Global_Var'>fast_promote</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/port.h.html#LN275"><span class='Ref_to_Macro'>stat</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN84"><span class='Ref_to_Const'>FALLBACK_PROMOTE_SIGNAL_FILE</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN12010"><span class='Ref_To_Local'>stat_buf</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <a href="../../../timezone/private.h.html#LN59"><span class='Ref_to_Proto'>unlink</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN84"><span class='Ref_to_Const'>FALLBACK_PROMOTE_SIGNAL_FILE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="xlog.c.html#LN279"><span class='Ref_to_Global_Var'>fast_promote</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"received promote request"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/postmaster/startup.h.html#LN19"><span class='Ref_to_Proto'>ResetPromoteTriggered</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN12011"><span class='Ref_To_Local'>triggered</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if IsPromoteTriggered() &raquo; </span> 
 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="xlog.c.html#LN273"><span class='Ref_to_Global_Var'>TriggerFile</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/port.h.html#LN275"><span class='Ref_to_Macro'>stat</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN273"><span class='Ref_to_Global_Var'>TriggerFile</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN12010"><span class='Ref_To_Local'>stat_buf</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"trigger file found: %s"</span><span class='Delimiter'>, </span><a href="xlog.c.html#LN273"><span class='Ref_to_Global_Var'>TriggerFile</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <a href="../../../timezone/private.h.html#LN59"><span class='Ref_to_Proto'>unlink</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN273"><span class='Ref_to_Global_Var'>TriggerFile</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN12011"><span class='Ref_To_Local'>triggered</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <a href="xlog.c.html#LN279"><span class='Ref_to_Global_Var'>fast_promote</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span>errno <span class='Operator'>!= </span>ENOENT<span class='Parentheses'>) 
</span>        <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN132"><span class='Ref_to_Proto'>errcode_for_file_access</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                 <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not stat trigger file \"%s\": %m"</span><span class='Delimiter'>, 
</span>                        <a href="xlog.c.html#LN273"><span class='Ref_to_Global_Var'>TriggerFile</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end CheckForStandbyTrigger &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Remove the files signaling a standby promotion request. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN12069"></a><span class='Declare_Function'>RemovePromoteSignalFiles</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../timezone/private.h.html#LN59"><span class='Ref_to_Proto'>unlink</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN83"><span class='Ref_to_Const'>PROMOTE_SIGNAL_FILE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../timezone/private.h.html#LN59"><span class='Ref_to_Proto'>unlink</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN84"><span class='Ref_to_Const'>FALLBACK_PROMOTE_SIGNAL_FILE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Check to see if a promote request has arrived. Should be 
 * called by postmaster after receiving SIGUSR1. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN12080"></a><span class='Declare_Function'>CheckPromoteSignal</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN12082"></a>    <span class='Control'>struct</span> <a href="../../../include/port.h.html#LN275"><span class='Ref_to_Macro'>stat</span></a> <span class='Declare_Local'>stat_buf</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/port.h.html#LN275"><span class='Ref_to_Macro'>stat</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN83"><span class='Ref_to_Const'>PROMOTE_SIGNAL_FILE</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN12082"><span class='Ref_To_Local'>stat_buf</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span> <span class='Operator'>|| 
</span>        <a href="../../../include/port.h.html#LN275"><span class='Ref_to_Macro'>stat</span></a><span class='Parentheses'>(</span><a href="xlog.c.html#LN84"><span class='Ref_to_Const'>FALLBACK_PROMOTE_SIGNAL_FILE</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="xlog.c.html#LN12082"><span class='Ref_To_Local'>stat_buf</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Wake up startup process to replay newly arrived WAL, or to notice that 
 * failover has been requested. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN12096"></a><span class='Declare_Function'>WakeupRecovery</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/storage/latch.h.html#LN151"><span class='Ref_to_Proto'>SetLatch</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN661"><span class='Ref_to_Member'>recoveryWakeupLatch</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Update the WalWriterSleeping flag. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN12105"></a><span class='Declare_Function'>SetWalWriterSleeping</span><span class='Parentheses'>(</span><span class='Keyword'>bool </span><span class='Declare_Parameter'>sleeping</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../../include/storage/spin.h.html#LN61"><span class='Ref_to_Macro'>SpinLockAcquire</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN654"><span class='Ref_to_Member'>WalWriterSleeping</span></a> <span class='Operator'>= </span><a href="xlog.c.html#LN12105"><span class='Ref_to_Parameter'>sleeping</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/storage/spin.h.html#LN63"><span class='Ref_to_Macro'>SpinLockRelease</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="xlog.c.html#LN705"><span class='Ref_to_Global_Var'>XLogCtl</span></a><span class='Operator'>-&GT;</span><a href="xlog.c.html#LN702"><span class='Ref_to_Member'>info_lck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Schedule a walreceiver wakeup in the main recovery loop. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN12116"></a><span class='Declare_Function'>XLogRequestWalReceiverReply</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="xlog.c.html#LN359"><span class='Ref_to_Global_Var'>doRequestWalReceiverReply</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
} 
</span></pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>