<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\catalog\catalog.c</title>
<LINK REL=StyleSheet HREF="../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\catalog\catalog.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:31 2017
</td></tr>
<tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * catalog.c 
 *      routines concerned with catalog naming conventions and other 
 *      bits of hard-wired knowledge 
 * 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * 
 * IDENTIFICATION 
 *    src/backend/catalog/catalog.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span> 
<span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>&LT;fcntl.h&GT;</span> 
<span class='Keyword'>#include </span><span class='String'>&LT;unistd.h&GT;</span> 
 
<span class='Keyword'>#include </span><span class='String'>"access/genam.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/sysattr.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/transam.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/catalog.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/indexing.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/namespace.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_auth_members.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_authid.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_database.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_namespace.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_pltemplate.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_db_role_setting.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_replication_origin.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_shdepend.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_shdescription.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_shseclabel.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_subscription.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_tablespace.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_type.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/toasting.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"miscadmin.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/fd.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/fmgroids.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/rel.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/tqual.h"</span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * IsSystemRelation 
 *      True iff the relation is either a system catalog or toast table. 
 *      By a system catalog, we mean one that created in the pg_catalog schema 
 *      during initdb.  User-created relations in pg_catalog don't count as 
 *      system catalogs. 
 * 
 *      NB: TOAST relations are considered system relations by this test 
 *      for compatibility with the old IsSystemRelationName function. 
 *      This is appropriate in many places but not all.  Where it's not, 
 *      also check IsToastRelation or use IsCatalogRelation(). 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN62"></a><span class='Declare_Function'>IsSystemRelation</span><span class='Parentheses'>(</span><a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>relation</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <a href="../../include/catalog/catalog.h.html#LN33"><span class='Ref_to_Proto'>IsSystemClass</span></a><span class='Parentheses'>(</span><a href="../../include/utils/rel.h.html#LN416"><span class='Ref_to_Macro'>RelationGetRelid</span></a><span class='Parentheses'>(</span><a href="catalog.c.html#LN62"><span class='Ref_to_Parameter'>relation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="catalog.c.html#LN62"><span class='Ref_to_Parameter'>relation</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * IsSystemClass 
 *      Like the above, but takes a Form_pg_class as argument. 
 *      Used when we do not want to open the relation and have to 
 *      search pg_class directly. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN74"></a><span class='Declare_Function'>IsSystemClass</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>relid</span><span class='Delimiter'>, </span><a href="../../include/catalog/pg_class.h.html#LN94"><span class='Ref_to_Typedef'>Form_pg_class</span></a> <span class='Declare_Parameter'>reltuple</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <a href="../../include/catalog/catalog.h.html#LN34"><span class='Ref_to_Proto'>IsToastClass</span></a><span class='Parentheses'>(</span><a href="catalog.c.html#LN74"><span class='Ref_to_Parameter'>reltuple</span></a><span class='Parentheses'>) </span><span class='Operator'>|| </span><a href="../../include/catalog/catalog.h.html#LN35"><span class='Ref_to_Proto'>IsCatalogClass</span></a><span class='Parentheses'>(</span><a href="catalog.c.html#LN74"><span class='Ref_to_Parameter'>relid</span></a><span class='Delimiter'>, </span><a href="catalog.c.html#LN74"><span class='Ref_to_Parameter'>reltuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * IsCatalogRelation 
 *      True iff the relation is a system catalog, or the toast table for 
 *      a system catalog.  By a system catalog, we mean one that created 
 *      in the pg_catalog schema during initdb.  As with IsSystemRelation(), 
 *      user-created relations in pg_catalog don't count as system catalogs. 
 * 
 *      Note that IsSystemRelation() returns true for ALL toast relations, 
 *      but this function returns true only for toast relations of system 
 *      catalogs. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN91"></a><span class='Declare_Function'>IsCatalogRelation</span><span class='Parentheses'>(</span><a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>relation</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <a href="../../include/catalog/catalog.h.html#LN35"><span class='Ref_to_Proto'>IsCatalogClass</span></a><span class='Parentheses'>(</span><a href="../../include/utils/rel.h.html#LN416"><span class='Ref_to_Macro'>RelationGetRelid</span></a><span class='Parentheses'>(</span><a href="catalog.c.html#LN91"><span class='Ref_to_Parameter'>relation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="catalog.c.html#LN91"><span class='Ref_to_Parameter'>relation</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * IsCatalogClass 
 *      True iff the relation is a system catalog relation. 
 * 
 * Check IsCatalogRelation() for details. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN103"></a><span class='Declare_Function'>IsCatalogClass</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>relid</span><span class='Delimiter'>, </span><a href="../../include/catalog/pg_class.h.html#LN94"><span class='Ref_to_Typedef'>Form_pg_class</span></a> <span class='Declare_Parameter'>reltuple</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN105"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>relnamespace</span> <span class='Operator'>= </span><a href="catalog.c.html#LN103"><span class='Ref_to_Parameter'>reltuple</span></a><span class='Operator'>-&GT;</span>relnamespace<span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Never consider relations outside pg_catalog/pg_toast to be catalog 
     * relations. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/catalog/catalog.h.html#LN37"><span class='Ref_to_Proto'>IsSystemNamespace</span></a><span class='Parentheses'>(</span><a href="catalog.c.html#LN105"><span class='Ref_To_Local'>relnamespace</span></a><span class='Parentheses'>) </span><span class='Operator'>&& !</span><a href="../../include/catalog/catalog.h.html#LN38"><span class='Ref_to_Proto'>IsToastNamespace</span></a><span class='Parentheses'>(</span><a href="catalog.c.html#LN105"><span class='Ref_To_Local'>relnamespace</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* ---- 
     * Check whether the oid was assigned during initdb, when creating the 
     * initial template database. Minus the relations in information_schema 
     * excluded above, these are integral part of the system. 
     * We could instead check whether the relation is pinned in pg_depend, but 
     * this is noticeably cheaper and doesn't require catalog access. 
     * 
     * This test is safe since even an oid wraparound will preserve this 
     * property (c.f. GetNewObjectId()) and it has the advantage that it works 
     * correctly even if a user decides to create a relation in the pg_catalog 
     * namespace. 
     * ---- 
     */ 
</span>    <span class='Control'>return</span> <a href="catalog.c.html#LN103"><span class='Ref_to_Parameter'>relid</span></a> <span class='Operator'>&LT; </span><a href="../../include/access/transam.h.html#LN93"><span class='Ref_to_Const'>FirstNormalObjectId</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end IsCatalogClass &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * IsToastRelation 
 *      True iff relation is a TOAST support relation (or index). 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN135"></a><span class='Declare_Function'>IsToastRelation</span><span class='Parentheses'>(</span><a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>relation</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <a href="../../include/catalog/catalog.h.html#LN38"><span class='Ref_to_Proto'>IsToastNamespace</span></a><span class='Parentheses'>(</span><a href="../../include/utils/rel.h.html#LN443"><span class='Ref_to_Macro'>RelationGetNamespace</span></a><span class='Parentheses'>(</span><a href="catalog.c.html#LN135"><span class='Ref_to_Parameter'>relation</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * IsToastClass 
 *      Like the above, but takes a Form_pg_class as argument. 
 *      Used when we do not want to open the relation and have to 
 *      search pg_class directly. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN147"></a><span class='Declare_Function'>IsToastClass</span><span class='Parentheses'>(</span><a href="../../include/catalog/pg_class.h.html#LN94"><span class='Ref_to_Typedef'>Form_pg_class</span></a> <span class='Declare_Parameter'>reltuple</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN149"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>relnamespace</span> <span class='Operator'>= </span><a href="catalog.c.html#LN147"><span class='Ref_to_Parameter'>reltuple</span></a><span class='Operator'>-&GT;</span>relnamespace<span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="../../include/catalog/catalog.h.html#LN38"><span class='Ref_to_Proto'>IsToastNamespace</span></a><span class='Parentheses'>(</span><a href="catalog.c.html#LN149"><span class='Ref_To_Local'>relnamespace</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * IsSystemNamespace 
 *      True iff namespace is pg_catalog. 
 * 
 * NOTE: the reason this isn't a macro is to avoid having to include 
 * catalog/pg_namespace.h in a lot of places. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN162"></a><span class='Declare_Function'>IsSystemNamespace</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>namespaceId</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <a href="catalog.c.html#LN162"><span class='Ref_to_Parameter'>namespaceId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_namespace.h.html#LN70"><span class='Ref_to_Const'>PG_CATALOG_NAMESPACE</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * IsToastNamespace 
 *      True iff namespace is pg_toast or my temporary-toast-table namespace. 
 * 
 * Note: this will return false for temporary-toast-table namespaces belonging 
 * to other backends.  Those are treated the same as other backends' regular 
 * temp table namespaces, and access is prevented where appropriate. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN176"></a><span class='Declare_Function'>IsToastNamespace</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>namespaceId</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="catalog.c.html#LN176"><span class='Ref_to_Parameter'>namespaceId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_namespace.h.html#LN73"><span class='Ref_to_Const'>PG_TOAST_NAMESPACE</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>        <a href="../../include/catalog/namespace.h.html#LN124"><span class='Ref_to_Proto'>isTempToastNamespace</span></a><span class='Parentheses'>(</span><a href="catalog.c.html#LN176"><span class='Ref_to_Parameter'>namespaceId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * IsReservedName 
 *      True iff name starts with the pg_ prefix. 
 * 
 *      For some classes of objects, the prefix pg_ is reserved for 
 *      system objects only.  As of 8.0, this was only true for 
 *      schema and tablespace names.  With 9.6, this is also true 
 *      for roles. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN193"></a><span class='Declare_Function'>IsReservedName</span><span class='Parentheses'>(</span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>name</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* ugly coding for speed */ 
</span>    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="catalog.c.html#LN193"><span class='Ref_to_Parameter'>name</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>== </span><span class='String'>'p'</span> <span class='Operator'>&& 
</span>            <a href="catalog.c.html#LN193"><span class='Ref_to_Parameter'>name</span></a><span class='Delimiter'>[</span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>== </span><span class='String'>'g'</span> <span class='Operator'>&& 
</span>            <a href="catalog.c.html#LN193"><span class='Ref_to_Parameter'>name</span></a><span class='Delimiter'>[</span><span class='Number'>2</span><span class='Delimiter'>] </span><span class='Operator'>== </span><span class='String'>'_'</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * IsSharedRelation 
 *      Given the OID of a relation, determine whether it's supposed to be 
 *      shared across an entire database cluster. 
 * 
 * In older releases, this had to be hard-wired so that we could compute the 
 * locktag for a relation and lock it before examining its catalog entry. 
 * Since we now have MVCC catalog access, the race conditions that made that 
 * a hard requirement are gone, so we could look at relaxing this restriction. 
 * However, if we scanned the pg_class entry to find relisshared, and only 
 * then locked the relation, pg_class could get updated in the meantime, 
 * forcing us to scan the relation again, which would definitely be complex 
 * and might have undesirable performance consequences.  Fortunately, the set 
 * of shared relations is fairly static, so a hand-maintained list of their 
 * OIDs isn't completely impractical. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN219"></a><span class='Declare_Function'>IsSharedRelation</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>relationId</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* These are the shared catalogs (look for BKI_SHARED_RELATION) */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="catalog.c.html#LN219"><span class='Ref_to_Parameter'>relationId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_authid.h.html#LN41"><span class='Ref_to_Const'>AuthIdRelationId</span></a> <span class='Operator'>|| 
</span>        <a href="catalog.c.html#LN219"><span class='Ref_to_Parameter'>relationId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_auth_members.h.html#LN28"><span class='Ref_to_Const'>AuthMemRelationId</span></a> <span class='Operator'>|| 
</span>        <a href="catalog.c.html#LN219"><span class='Ref_to_Parameter'>relationId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_database.h.html#LN28"><span class='Ref_to_Const'>DatabaseRelationId</span></a> <span class='Operator'>|| 
</span>        <a href="catalog.c.html#LN219"><span class='Ref_to_Parameter'>relationId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_pltemplate.h.html#LN28"><span class='Ref_to_Const'>PLTemplateRelationId</span></a> <span class='Operator'>|| 
</span>        <a href="catalog.c.html#LN219"><span class='Ref_to_Parameter'>relationId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_shdescription.h.html#LN38"><span class='Ref_to_Const'>SharedDescriptionRelationId</span></a> <span class='Operator'>|| 
</span>        <a href="catalog.c.html#LN219"><span class='Ref_to_Parameter'>relationId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_shdepend.h.html#LN28"><span class='Ref_to_Const'>SharedDependRelationId</span></a> <span class='Operator'>|| 
</span>        <a href="catalog.c.html#LN219"><span class='Ref_to_Parameter'>relationId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_shseclabel.h.html#LN20"><span class='Ref_to_Const'>SharedSecLabelRelationId</span></a> <span class='Operator'>|| 
</span>        <a href="catalog.c.html#LN219"><span class='Ref_to_Parameter'>relationId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_tablespace.h.html#LN28"><span class='Ref_to_Const'>TableSpaceRelationId</span></a> <span class='Operator'>|| 
</span>        <a href="catalog.c.html#LN219"><span class='Ref_to_Parameter'>relationId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_db_role_setting.h.html#LN32"><span class='Ref_to_Const'>DbRoleSettingRelationId</span></a> <span class='Operator'>|| 
</span>        <a href="catalog.c.html#LN219"><span class='Ref_to_Parameter'>relationId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_replication_origin.h.html#LN27"><span class='Ref_to_Const'>ReplicationOriginRelationId</span></a> <span class='Operator'>|| 
</span>        <a href="catalog.c.html#LN219"><span class='Ref_to_Parameter'>relationId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_subscription.h.html#LN21"><span class='Ref_to_Const'>SubscriptionRelationId</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* These are their indexes (see indexing.h) */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="catalog.c.html#LN219"><span class='Ref_to_Parameter'>relationId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/indexing.h.html#LN96"><span class='Ref_to_Const'>AuthIdRolnameIndexId</span></a> <span class='Operator'>|| 
</span>        <a href="catalog.c.html#LN219"><span class='Ref_to_Parameter'>relationId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/indexing.h.html#LN98"><span class='Ref_to_Const'>AuthIdOidIndexId</span></a> <span class='Operator'>|| 
</span>        <a href="catalog.c.html#LN219"><span class='Ref_to_Parameter'>relationId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/indexing.h.html#LN101"><span class='Ref_to_Const'>AuthMemRoleMemIndexId</span></a> <span class='Operator'>|| 
</span>        <a href="catalog.c.html#LN219"><span class='Ref_to_Parameter'>relationId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/indexing.h.html#LN103"><span class='Ref_to_Const'>AuthMemMemRoleIndexId</span></a> <span class='Operator'>|| 
</span>        <a href="catalog.c.html#LN219"><span class='Ref_to_Parameter'>relationId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/indexing.h.html#LN139"><span class='Ref_to_Const'>DatabaseNameIndexId</span></a> <span class='Operator'>|| 
</span>        <a href="catalog.c.html#LN219"><span class='Ref_to_Parameter'>relationId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/indexing.h.html#LN141"><span class='Ref_to_Const'>DatabaseOidIndexId</span></a> <span class='Operator'>|| 
</span>        <a href="catalog.c.html#LN219"><span class='Ref_to_Parameter'>relationId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/indexing.h.html#LN212"><span class='Ref_to_Const'>PLTemplateNameIndexId</span></a> <span class='Operator'>|| 
</span>        <a href="catalog.c.html#LN219"><span class='Ref_to_Parameter'>relationId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/indexing.h.html#LN151"><span class='Ref_to_Const'>SharedDescriptionObjIndexId</span></a> <span class='Operator'>|| 
</span>        <a href="catalog.c.html#LN219"><span class='Ref_to_Parameter'>relationId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/indexing.h.html#LN228"><span class='Ref_to_Const'>SharedDependDependerIndexId</span></a> <span class='Operator'>|| 
</span>        <a href="catalog.c.html#LN219"><span class='Ref_to_Parameter'>relationId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/indexing.h.html#LN230"><span class='Ref_to_Const'>SharedDependReferenceIndexId</span></a> <span class='Operator'>|| 
</span>        <a href="catalog.c.html#LN219"><span class='Ref_to_Parameter'>relationId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/indexing.h.html#LN315"><span class='Ref_to_Const'>SharedSecLabelObjectIndexId</span></a> <span class='Operator'>|| 
</span>        <a href="catalog.c.html#LN219"><span class='Ref_to_Parameter'>relationId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/indexing.h.html#LN236"><span class='Ref_to_Const'>TablespaceOidIndexId</span></a> <span class='Operator'>|| 
</span>        <a href="catalog.c.html#LN219"><span class='Ref_to_Parameter'>relationId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/indexing.h.html#LN238"><span class='Ref_to_Const'>TablespaceNameIndexId</span></a> <span class='Operator'>|| 
</span>        <a href="catalog.c.html#LN219"><span class='Ref_to_Parameter'>relationId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/indexing.h.html#LN309"><span class='Ref_to_Const'>DbRoleSettingDatidRolidIndexId</span></a> <span class='Operator'>|| 
</span>        <a href="catalog.c.html#LN219"><span class='Ref_to_Parameter'>relationId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/indexing.h.html#LN332"><span class='Ref_to_Const'>ReplicationOriginIdentIndex</span></a> <span class='Operator'>|| 
</span>        <a href="catalog.c.html#LN219"><span class='Ref_to_Parameter'>relationId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/indexing.h.html#LN335"><span class='Ref_to_Const'>ReplicationOriginNameIndex</span></a> <span class='Operator'>|| 
</span>        <a href="catalog.c.html#LN219"><span class='Ref_to_Parameter'>relationId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/indexing.h.html#LN353"><span class='Ref_to_Const'>SubscriptionObjectIndexId</span></a> <span class='Operator'>|| 
</span>        <a href="catalog.c.html#LN219"><span class='Ref_to_Parameter'>relationId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/indexing.h.html#LN356"><span class='Ref_to_Const'>SubscriptionNameIndexId</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* These are their toast tables and toast indexes (see toasting.h) */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="catalog.c.html#LN219"><span class='Ref_to_Parameter'>relationId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/toasting.h.html#LN60"><span class='Ref_to_Const'>PgShdescriptionToastTable</span></a> <span class='Operator'>|| 
</span>        <a href="catalog.c.html#LN219"><span class='Ref_to_Parameter'>relationId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/toasting.h.html#LN61"><span class='Ref_to_Const'>PgShdescriptionToastIndex</span></a> <span class='Operator'>|| 
</span>        <a href="catalog.c.html#LN219"><span class='Ref_to_Parameter'>relationId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/toasting.h.html#LN63"><span class='Ref_to_Const'>PgDbRoleSettingToastTable</span></a> <span class='Operator'>|| 
</span>        <a href="catalog.c.html#LN219"><span class='Ref_to_Parameter'>relationId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/toasting.h.html#LN64"><span class='Ref_to_Const'>PgDbRoleSettingToastIndex</span></a> <span class='Operator'>|| 
</span>        <a href="catalog.c.html#LN219"><span class='Ref_to_Parameter'>relationId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/toasting.h.html#LN66"><span class='Ref_to_Const'>PgShseclabelToastTable</span></a> <span class='Operator'>|| 
</span>        <a href="catalog.c.html#LN219"><span class='Ref_to_Parameter'>relationId</span></a> <span class='Operator'>== </span><a href="../../include/catalog/toasting.h.html#LN67"><span class='Ref_to_Const'>PgShseclabelToastIndex</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end IsSharedRelation &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * GetNewOid 
 *      Generate a new OID that is unique within the given relation. 
 * 
 * Caller must have a suitable lock on the relation. 
 * 
 * Uniqueness is promised only if the relation has a unique index on OID. 
 * This is true for all system catalogs that have OIDs, but might not be 
 * true for user tables.  Note that we are effectively assuming that the 
 * table has a relatively small number of entries (much less than 2^32) 
 * and there aren't very long runs of consecutive existing OIDs.  Again, 
 * this is reasonable for system catalogs but less so for user tables. 
 * 
 * Since the OID is not immediately inserted into the table, there is a 
 * race condition here; but a problem could occur only if someone else 
 * managed to cycle through 2^32 OIDs and generate the same OID before we 
 * finish inserting our row.  This seems unlikely to be a problem.  Note 
 * that if we had to *commit* the row to end the race condition, the risk 
 * would be rather higher; therefore we use SnapshotDirty in the test, 
 * so that we will see uncommitted rows. 
 */ 
</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> 
<a name="LN288"></a><span class='Declare_Function'>GetNewOid</span><span class='Parentheses'>(</span><a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>relation</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN290"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>oidIndex</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* If relation doesn't have OIDs at all, caller is confused */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="catalog.c.html#LN288"><span class='Ref_to_Parameter'>relation</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relhasoids<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* In bootstrap mode, we don't have any indexes to use */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/miscadmin.h.html#LN369"><span class='Ref_to_Macro'>IsBootstrapProcessingMode</span></a><span class='Parentheses'>())</span> 
        <span class='Control'>return</span> <a href="../../include/access/transam.h.html#LN183"><span class='Ref_to_Proto'>GetNewObjectId</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* The relcache will cache the identity of the OID index for us */ 
</span>    <a href="catalog.c.html#LN290"><span class='Ref_To_Local'>oidIndex</span></a> <span class='Operator'>= </span><a href="../../include/utils/relcache.h.html#LN42"><span class='Ref_to_Proto'>RelationGetOidIndex</span></a><span class='Parentheses'>(</span><a href="catalog.c.html#LN288"><span class='Ref_to_Parameter'>relation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* If no OID index, just hand back the next OID counter value */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="catalog.c.html#LN290"><span class='Ref_To_Local'>oidIndex</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * System catalogs that have OIDs should *always* have a unique OID 
         * index; we should only take this path for user tables. Give a 
         * warning if it looks like somebody forgot an index. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/catalog/catalog.h.html#LN29"><span class='Ref_to_Proto'>IsSystemRelation</span></a><span class='Parentheses'>(</span><a href="catalog.c.html#LN288"><span class='Ref_to_Parameter'>relation</span></a><span class='Parentheses'>))</span> 
            <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN39"><span class='Ref_to_Const'>WARNING</span></a><span class='Delimiter'>, </span><span class='String'>"generating possibly-non-unique OID for \"%s\""</span><span class='Delimiter'>, 
</span>                 <a href="../../include/utils/rel.h.html#LN436"><span class='Ref_to_Macro'>RelationGetRelationName</span></a><span class='Parentheses'>(</span><a href="catalog.c.html#LN288"><span class='Ref_to_Parameter'>relation</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>return</span> <a href="../../include/access/transam.h.html#LN183"><span class='Ref_to_Proto'>GetNewObjectId</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Otherwise, use the index to find a nonconflicting OID */ 
</span>    <span class='Control'>return</span> <a href="../../include/catalog/catalog.h.html#LN45"><span class='Ref_to_Proto'>GetNewOidWithIndex</span></a><span class='Parentheses'>(</span><a href="catalog.c.html#LN288"><span class='Ref_to_Parameter'>relation</span></a><span class='Delimiter'>, </span><a href="catalog.c.html#LN290"><span class='Ref_To_Local'>oidIndex</span></a><span class='Delimiter'>, </span><a href="../../include/access/sysattr.h.html#LN21"><span class='Ref_to_Const'>ObjectIdAttributeNumber</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end GetNewOid &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * GetNewOidWithIndex 
 *      Guts of GetNewOid: use the supplied index 
 * 
 * This is exported separately because there are cases where we want to use 
 * an index that will not be recognized by RelationGetOidIndex: TOAST tables 
 * have indexes that are usable, but have multiple columns and are on 
 * ordinary columns rather than a true OID column.  This code will work 
 * anyway, so long as the OID is the index's first column.  The caller must 
 * pass in the actual heap attnum of the OID column, however. 
 * 
 * Caller must have a suitable lock on the relation. 
 */ 
</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> 
<a name="LN335"></a><span class='Declare_Function'>GetNewOidWithIndex</span><span class='Parentheses'>(</span><a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>relation</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>indexId</span><span class='Delimiter'>, </span><a href="../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a> <span class='Declare_Parameter'>oidcolumn</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN337"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>newOid</span><span class='Delimiter'>; 
</span><a name="LN338"></a>    <a href="../../include/utils/snapshot.h.html#LN51"><span class='Ref_to_Struct'>SnapshotData</span></a> <span class='Declare_Local'>SnapshotDirty</span><span class='Delimiter'>; 
</span><a name="LN339"></a>    <a href="../../include/access/genam.h.html#LN86"><span class='Ref_to_Typedef'>SysScanDesc</span></a> <span class='Declare_Local'>scan</span><span class='Delimiter'>; 
</span><a name="LN340"></a>    <a href="../../include/access/skey.h.html#LN63"><span class='Ref_to_Struct'>ScanKeyData</span></a> <span class='Declare_Local'>key</span><span class='Delimiter'>; 
</span><a name="LN341"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>collides</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We should never be asked to generate a new pg_type OID during 
     * pg_upgrade; doing so would risk collisions with the OIDs it wants to 
     * assign.  Hitting this assert means there's some path where we failed to 
     * ensure that a type OID is determined by commands in the dump script. 
     */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../utils/init/globals.c.html#LN101"><span class='Ref_to_Global_Var'>IsBinaryUpgrade</span></a> <span class='Operator'>|| </span><a href="../../include/utils/rel.h.html#LN416"><span class='Ref_to_Macro'>RelationGetRelid</span></a><span class='Parentheses'>(</span><a href="catalog.c.html#LN335"><span class='Ref_to_Parameter'>relation</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><a href="../../include/catalog/pg_type.h.html#LN33"><span class='Ref_to_Const'>TypeRelationId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/utils/tqual.h.html#LN99"><span class='Ref_to_Macro'>InitDirtySnapshot</span></a><span class='Parentheses'>(</span><a href="catalog.c.html#LN338"><span class='Ref_To_Local'>SnapshotDirty</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Generate new OIDs until we find one not in the table */ 
</span>    <span class='Control'>do</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../include/miscadmin.h.html#LN99"><span class='Ref_to_Macro'>CHECK_FOR_INTERRUPTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <a href="catalog.c.html#LN337"><span class='Ref_To_Local'>newOid</span></a> <span class='Operator'>= </span><a href="../../include/access/transam.h.html#LN183"><span class='Ref_to_Proto'>GetNewObjectId</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <a href="../access/common/scankey.c.html#LN74"><span class='Ref_to_Func'>ScanKeyInit</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="catalog.c.html#LN340"><span class='Ref_To_Local'>key</span></a><span class='Delimiter'>, 
</span>                    <a href="catalog.c.html#LN335"><span class='Ref_to_Parameter'>oidcolumn</span></a><span class='Delimiter'>, 
</span>                    <a href="../../include/access/stratnum.h.html#LN30"><span class='Ref_to_Const'>BTEqualStrategyNumber</span></a><span class='Delimiter'>, </span>F_OIDEQ<span class='Delimiter'>, 
</span>                    <a href="../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="catalog.c.html#LN337"><span class='Ref_To_Local'>newOid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* see notes above about using SnapshotDirty */ 
</span>        <a href="catalog.c.html#LN339"><span class='Ref_To_Local'>scan</span></a> <span class='Operator'>= </span><a href="../../include/access/genam.h.html#LN189"><span class='Ref_to_Proto'>systable_beginscan</span></a><span class='Parentheses'>(</span><a href="catalog.c.html#LN335"><span class='Ref_to_Parameter'>relation</span></a><span class='Delimiter'>, </span><a href="catalog.c.html#LN335"><span class='Ref_to_Parameter'>indexId</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, 
</span>                                  <span class='Operator'>&</span><a href="catalog.c.html#LN338"><span class='Ref_To_Local'>SnapshotDirty</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="catalog.c.html#LN340"><span class='Ref_To_Local'>key</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="catalog.c.html#LN341"><span class='Ref_To_Local'>collides</span></a> <span class='Operator'>= </span><a href="../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="../../include/access/genam.h.html#LN194"><span class='Ref_to_Proto'>systable_getnext</span></a><span class='Parentheses'>(</span><a href="catalog.c.html#LN339"><span class='Ref_To_Local'>scan</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/access/genam.h.html#LN196"><span class='Ref_to_Proto'>systable_endscan</span></a><span class='Parentheses'>(</span><a href="catalog.c.html#LN339"><span class='Ref_To_Local'>scan</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} </span><span class='Control'>while</span> <span class='Parentheses'>(</span><a href="catalog.c.html#LN341"><span class='Ref_To_Local'>collides</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="catalog.c.html#LN337"><span class='Ref_To_Local'>newOid</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end GetNewOidWithIndex &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * GetNewRelFileNode 
 *      Generate a new relfilenode number that is unique within the 
 *      database of the given tablespace. 
 * 
 * If the relfilenode will also be used as the relation's OID, pass the 
 * opened pg_class catalog, and this routine will guarantee that the result 
 * is also an unused OID within pg_class.  If the result is to be used only 
 * as a relfilenode for an existing relation, pass NULL for pg_class. 
 * 
 * As with GetNewOid, there is some theoretical risk of a race condition, 
 * but it doesn't seem worth worrying about. 
 * 
 * Note: we don't support using this in bootstrap mode.  All relations 
 * created by bootstrap have preassigned OIDs, so there's no need. 
 */ 
</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> 
<a name="LN394"></a><span class='Declare_Function'>GetNewRelFileNode</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>reltablespace</span><span class='Delimiter'>, </span><a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>pg_class</span><span class='Delimiter'>, </span><span class='Keyword'>char </span><span class='Declare_Parameter'>relpersistence</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN396"></a>    <a href="../../include/storage/relfilenode.h.html#LN71"><span class='Ref_to_Struct'>RelFileNodeBackend</span></a> <span class='Declare_Local'>rnode</span><span class='Delimiter'>; 
</span><a name="LN397"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>rpath</span><span class='Delimiter'>; 
</span><a name="LN398"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>fd</span><span class='Delimiter'>; 
</span><a name="LN399"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>collides</span><span class='Delimiter'>; 
</span><a name="LN400"></a>    <a href="../../include/storage/backendid.h.html#LN20"><span class='Ref_to_Typedef'>BackendId</span></a>   <span class='Declare_Local'>backend</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we ever get here during pg_upgrade, there's something wrong; all 
     * relfilenode assignments during a binary-upgrade run should be 
     * determined by commands in the dump script. 
     */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../utils/init/globals.c.html#LN101"><span class='Ref_to_Global_Var'>IsBinaryUpgrade</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="catalog.c.html#LN394"><span class='Ref_to_Parameter'>relpersistence</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../include/catalog/pg_class.h.html#LN171"><span class='Ref_to_Const'>RELPERSISTENCE_TEMP</span></a><span class='Operator'>: 
</span>            <a href="catalog.c.html#LN400"><span class='Ref_To_Local'>backend</span></a> <span class='Operator'>= </span><a href="../../include/storage/backendid.h.html#LN33"><span class='Ref_to_Macro'>BackendIdForTempRelations</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/catalog/pg_class.h.html#LN170"><span class='Ref_to_Const'>RELPERSISTENCE_UNLOGGED</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/catalog/pg_class.h.html#LN169"><span class='Ref_to_Const'>RELPERSISTENCE_PERMANENT</span></a><span class='Operator'>: 
</span>            <a href="catalog.c.html#LN400"><span class='Ref_To_Local'>backend</span></a> <span class='Operator'>= </span><a href="../../include/storage/backendid.h.html#LN22"><span class='Ref_to_Const'>InvalidBackendId</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>default</span><span class='Operator'>: 
</span>            <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"invalid relpersistence: %c"</span><span class='Delimiter'>, </span><a href="catalog.c.html#LN394"><span class='Ref_to_Parameter'>relpersistence</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span> <a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* placate compiler */ 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* This logic should match RelationInitPhysicalAddr */ 
</span>    <a href="catalog.c.html#LN396"><span class='Ref_To_Local'>rnode</span></a><span class='Operator'>.</span><a href="../../include/storage/relfilenode.h.html#LN73"><span class='Ref_to_Member'>node</span></a><span class='Operator'>.</span><a href="../../include/storage/relfilenode.h.html#LN58"><span class='Ref_to_Member'>spcNode</span></a> <span class='Operator'>= </span><a href="catalog.c.html#LN394"><span class='Ref_to_Parameter'>reltablespace</span></a> <span class='Operator'>? </span><a href="catalog.c.html#LN394"><span class='Ref_to_Parameter'>reltablespace</span></a> <span class='Operator'>: </span><a href="../utils/init/globals.c.html#LN78"><span class='Ref_to_Global_Var'>MyDatabaseTableSpace</span></a><span class='Delimiter'>; 
</span>    <a href="catalog.c.html#LN396"><span class='Ref_To_Local'>rnode</span></a><span class='Operator'>.</span><a href="../../include/storage/relfilenode.h.html#LN73"><span class='Ref_to_Member'>node</span></a><span class='Operator'>.</span><a href="../../include/storage/relfilenode.h.html#LN59"><span class='Ref_to_Member'>dbNode</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="catalog.c.html#LN396"><span class='Ref_To_Local'>rnode</span></a><span class='Operator'>.</span><a href="../../include/storage/relfilenode.h.html#LN73"><span class='Ref_to_Member'>node</span></a><span class='Operator'>.</span><a href="../../include/storage/relfilenode.h.html#LN58"><span class='Ref_to_Member'>spcNode</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_tablespace.h.html#LN63"><span class='Ref_to_Const'>GLOBALTABLESPACE_OID</span></a><span class='Parentheses'>) </span><span class='Operator'>? </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a> <span class='Operator'>: </span><a href="../utils/init/globals.c.html#LN76"><span class='Ref_to_Global_Var'>MyDatabaseId</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * The relpath will vary based on the backend ID, so we must initialize 
     * that properly here to make sure that any collisions based on filename 
     * are properly detected. 
     */ 
</span>    <a href="catalog.c.html#LN396"><span class='Ref_To_Local'>rnode</span></a><span class='Operator'>.</span><a href="../../include/storage/relfilenode.h.html#LN74"><span class='Ref_to_Member'>backend</span></a> <span class='Operator'>= </span><a href="catalog.c.html#LN400"><span class='Ref_To_Local'>backend</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>do</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../include/miscadmin.h.html#LN99"><span class='Ref_to_Macro'>CHECK_FOR_INTERRUPTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Generate the OID */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="catalog.c.html#LN394"><span class='Ref_to_Parameter'>pg_class</span></a><span class='Parentheses'>) 
</span>            <a href="catalog.c.html#LN396"><span class='Ref_To_Local'>rnode</span></a><span class='Operator'>.</span><a href="../../include/storage/relfilenode.h.html#LN73"><span class='Ref_to_Member'>node</span></a><span class='Operator'>.</span><a href="../../include/storage/relfilenode.h.html#LN60"><span class='Ref_to_Member'>relNode</span></a> <span class='Operator'>= </span><a href="../../include/catalog/catalog.h.html#LN44"><span class='Ref_to_Proto'>GetNewOid</span></a><span class='Parentheses'>(</span><a href="catalog.c.html#LN394"><span class='Ref_to_Parameter'>pg_class</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="catalog.c.html#LN396"><span class='Ref_To_Local'>rnode</span></a><span class='Operator'>.</span><a href="../../include/storage/relfilenode.h.html#LN73"><span class='Ref_to_Member'>node</span></a><span class='Operator'>.</span><a href="../../include/storage/relfilenode.h.html#LN60"><span class='Ref_to_Member'>relNode</span></a> <span class='Operator'>= </span><a href="../../include/access/transam.h.html#LN183"><span class='Ref_to_Proto'>GetNewObjectId</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Check for existing file of same name */ 
</span>        <a href="catalog.c.html#LN397"><span class='Ref_To_Local'>rpath</span></a> <span class='Operator'>= </span><a href="../../include/common/relpath.h.html#LN70"><span class='Ref_to_Macro'>relpath</span></a><span class='Parentheses'>(</span><a href="catalog.c.html#LN396"><span class='Ref_To_Local'>rnode</span></a><span class='Delimiter'>, </span><a href="../../include/common/relpath.h.html#LN26"><span class='Ref_to_EnumConst'>MAIN_FORKNUM</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="catalog.c.html#LN398"><span class='Ref_To_Local'>fd</span></a> <span class='Operator'>= </span><a href="../../include/storage/fd.h.html#LN100"><span class='Ref_to_Proto'>BasicOpenFile</span></a><span class='Parentheses'>(</span><a href="catalog.c.html#LN397"><span class='Ref_To_Local'>rpath</span></a><span class='Delimiter'>, </span>O_RDONLY <span class='Operator'>| </span><a href="../../include/c.h.html#LN1032"><span class='Ref_to_Const'>PG_BINARY</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="catalog.c.html#LN398"><span class='Ref_To_Local'>fd</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* definite collision */ 
</span>            <a href="../../interfaces/libpq/win32.h.html#LN11"><span class='Ref_to_Macro'>close</span></a><span class='Parentheses'>(</span><a href="catalog.c.html#LN398"><span class='Ref_To_Local'>fd</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="catalog.c.html#LN399"><span class='Ref_To_Local'>collides</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Here we have a little bit of a dilemma: if errno is something 
             * other than ENOENT, should we declare a collision and loop? In 
             * particular one might think this advisable for, say, EPERM. 
             * However there really shouldn't be any unreadable files in a 
             * tablespace directory, and if the EPERM is actually complaining 
             * that we can't read the directory itself, we'd be in an infinite 
             * loop.  In practice it seems best to go ahead regardless of the 
             * errno.  If there is a colliding file we will get an smgr 
             * failure when we attempt to create the new relation file. 
             */ 
</span>            <a href="catalog.c.html#LN399"><span class='Ref_To_Local'>collides</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="catalog.c.html#LN397"><span class='Ref_To_Local'>rpath</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end do &raquo; </span> <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="catalog.c.html#LN399"><span class='Ref_To_Local'>collides</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="catalog.c.html#LN396"><span class='Ref_To_Local'>rnode</span></a><span class='Operator'>.</span><a href="../../include/storage/relfilenode.h.html#LN73"><span class='Ref_to_Member'>node</span></a><span class='Operator'>.</span><a href="../../include/storage/relfilenode.h.html#LN60"><span class='Ref_to_Member'>relNode</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end GetNewRelFileNode &raquo; </span> 
</pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>