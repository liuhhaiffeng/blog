<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\catalog\index.c</title>
<LINK REL=StyleSheet HREF="../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\catalog\index.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:32 2017
</td></tr>
<tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * index.c 
 *    code to create and destroy POSTGRES index relations 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * 
 * IDENTIFICATION 
 *    src/backend/catalog/index.c 
 * 
 * 
 * INTERFACE ROUTINES 
 *      index_create()          - Create a cataloged index relation 
 *      index_drop()            - Removes index relation from catalogs 
 *      BuildIndexInfo()        - Prepare to insert index tuples 
 *      FormIndexDatum()        - Construct datum vector for one index tuple 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>&LT;unistd.h&GT;</span> 
 
<span class='Keyword'>#include </span><span class='String'>"access/amapi.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/multixact.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/relscan.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/sysattr.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/transam.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/visibilitymap.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/xact.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"bootstrap/bootstrap.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/binary_upgrade.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/catalog.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/dependency.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/heap.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/index.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/objectaccess.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_am.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_collation.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_constraint.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_constraint_fn.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_operator.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_opclass.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_tablespace.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_trigger.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_type.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/storage.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"commands/tablecmds.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"commands/trigger.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"executor/executor.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"miscadmin.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/makefuncs.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/nodeFuncs.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/clauses.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parser.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/bufmgr.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/lmgr.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/predicate.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/procarray.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/smgr.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/builtins.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/fmgroids.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/guc.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/inval.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/lsyscache.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/memutils.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/pg_rusage.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/syscache.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/tuplesort.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/snapmgr.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/tqual.h"</span> 
 
 
<span class='Comment_Multi_Line'>/* Potentially set by pg_upgrade_support functions */ 
</span><a name="LN76"></a><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Var'>binary_upgrade_next_index_pg_class_oid</span> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* state info for validate_index bulkdelete callback */ 
</span><span class='Control'>typedef</span> <span class='Control'>struct</span> 
<span class='Delimiter'>{ 
</span><a name="LN81"></a>    <a href="../utils/sort/tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Member'>tuplesort</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* for sorting the index TIDs */ 
</span>    <span class='Comment_Multi_Line'>/* statistics (for debug purposes only): */ 
</span><a name="LN83"></a>    <span class='Keyword'>double</span>      <span class='Declare_Member'>htups</span><span class='Delimiter'>, 
</span><a name="LN84"></a>                <span class='Declare_Member'>itups</span><span class='Delimiter'>, 
</span><a name="LN85"></a>                <span class='Declare_Member'>tups_inserted</span><span class='Delimiter'>; 
</span><a name="LN86"></a>} <span class='Declare_Typedef'>v_i_state</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* non-export function prototypes */ 
</span><a name="LN89"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>relationHasPrimaryKey</span><span class='Parentheses'>(</span><a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>rel</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN90"></a><span class='Keyword'>static </span><a href="../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a> <span class='Declare_Prototype'>ConstructTupleDescriptor</span><span class='Parentheses'>(</span><a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>heapRelation</span><span class='Delimiter'>, 
</span><a name="LN91"></a>                         <a href="../../include/nodes/execnodes.h.html#LN130"><span class='Ref_to_Struct'>IndexInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>indexInfo</span><span class='Delimiter'>, 
</span><a name="LN92"></a>                         <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>indexColNames</span><span class='Delimiter'>, 
</span><a name="LN93"></a>                         <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>accessMethodObjectId</span><span class='Delimiter'>, 
</span><a name="LN94"></a>                         <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>collationObjectId</span><span class='Delimiter'>, 
</span><a name="LN95"></a>                         <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>classObjectId</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN96"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>InitializeAttributeOids</span><span class='Parentheses'>(</span><a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>indexRelation</span><span class='Delimiter'>, 
</span><a name="LN97"></a>                        <span class='Keyword'>int </span><span class='Declare_Parameter'>numatts</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>indexoid</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN98"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>AppendAttributeTuples</span><span class='Parentheses'>(</span><a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>indexRelation</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>numatts</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN99"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>UpdateIndexRelation</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>indexoid</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>heapoid</span><span class='Delimiter'>, 
</span><a name="LN100"></a>                    <a href="../../include/nodes/execnodes.h.html#LN130"><span class='Ref_to_Struct'>IndexInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>indexInfo</span><span class='Delimiter'>, 
</span><a name="LN101"></a>                    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>collationOids</span><span class='Delimiter'>, 
</span><a name="LN102"></a>                    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>classOids</span><span class='Delimiter'>, 
</span><a name="LN103"></a>                    <a href="../../include/c.h.html#LN254"><span class='Ref_to_Typedef'>int16</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>coloptions</span><span class='Delimiter'>, 
</span><a name="LN104"></a>                    <span class='Keyword'>bool </span><span class='Declare_Parameter'>primary</span><span class='Delimiter'>, 
</span><a name="LN105"></a>                    <span class='Keyword'>bool </span><span class='Declare_Parameter'>isexclusion</span><span class='Delimiter'>, 
</span><a name="LN106"></a>                    <span class='Keyword'>bool </span><span class='Declare_Parameter'>immediate</span><span class='Delimiter'>, 
</span><a name="LN107"></a>                    <span class='Keyword'>bool </span><span class='Declare_Parameter'>isvalid</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN108"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>index_update_stats</span><span class='Parentheses'>(</span><a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>rel</span><span class='Delimiter'>, 
</span><a name="LN109"></a>                   <span class='Keyword'>bool </span><span class='Declare_Parameter'>hasindex</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>isprimary</span><span class='Delimiter'>, 
</span><a name="LN110"></a>                   <span class='Keyword'>double </span><span class='Declare_Parameter'>reltuples</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN111"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>IndexCheckExclusion</span><span class='Parentheses'>(</span><a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>heapRelation</span><span class='Delimiter'>, 
</span><a name="LN112"></a>                    <a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>indexRelation</span><span class='Delimiter'>, 
</span><a name="LN113"></a>                    <a href="../../include/nodes/execnodes.h.html#LN130"><span class='Ref_to_Struct'>IndexInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>indexInfo</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN114"></a><span class='Keyword'>static inline </span><a href="../../include/c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a> <span class='Declare_Prototype'>itemptr_encode</span><span class='Parentheses'>(</span><a href="../../include/storage/itemptr.h.html#LN47"><span class='Ref_to_Typedef'>ItemPointer</span></a> <span class='Declare_Parameter'>itemptr</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN115"></a><span class='Keyword'>static inline void </span><span class='Declare_Prototype'>itemptr_decode</span><span class='Parentheses'>(</span><a href="../../include/storage/itemptr.h.html#LN47"><span class='Ref_to_Typedef'>ItemPointer</span></a> <span class='Declare_Parameter'>itemptr</span><span class='Delimiter'>, </span><a href="../../include/c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a> <span class='Declare_Parameter'>encoded</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN116"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>validate_index_callback</span><span class='Parentheses'>(</span><a href="../../include/storage/itemptr.h.html#LN47"><span class='Ref_to_Typedef'>ItemPointer</span></a> <span class='Declare_Parameter'>itemptr</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>opaque</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN117"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>validate_index_heapscan</span><span class='Parentheses'>(</span><a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>heapRelation</span><span class='Delimiter'>, 
</span><a name="LN118"></a>                        <a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>indexRelation</span><span class='Delimiter'>, 
</span><a name="LN119"></a>                        <a href="../../include/nodes/execnodes.h.html#LN130"><span class='Ref_to_Struct'>IndexInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>indexInfo</span><span class='Delimiter'>, 
</span><a name="LN120"></a>                        <a href="../../include/utils/snapshot.h.html#LN22"><span class='Ref_to_Typedef'>Snapshot</span></a> <span class='Declare_Parameter'>snapshot</span><span class='Delimiter'>, 
</span><a name="LN121"></a>                        <a href="index.c.html#LN79"><span class='Ref_to_Typedef'>v_i_state</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN122"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>ReindexIsCurrentlyProcessingIndex</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>indexOid</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN123"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>SetReindexProcessing</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>heapOid</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>indexOid</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN124"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>ResetReindexProcessing</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN125"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>SetReindexPending</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>indexes</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN126"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>RemoveReindexPending</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>indexOid</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN127"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>ResetReindexPending</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * relationHasPrimaryKey 
 *      See whether an existing relation has a primary key. 
 * 
 * Caller must have suitable lock on the relation. 
 * 
 * Note: we intentionally do not check IndexIsValid here; that's because this 
 * is used to enforce the rule that there can be only one indisprimary index, 
 * and we want that to be true even if said index is invalid. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN141"></a><span class='Declare_Function'>relationHasPrimaryKey</span><span class='Parentheses'>(</span><a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>rel</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN143"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>result</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN144"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>indexoidlist</span><span class='Delimiter'>; 
</span><a name="LN145"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>indexoidscan</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Get the list of index OIDs for the table from the relcache, and look up 
     * each one in the pg_index syscache until we find one marked primary key 
     * (hopefully there isn't more than one such). 
     */ 
</span>    <a href="index.c.html#LN144"><span class='Ref_To_Local'>indexoidlist</span></a> <span class='Operator'>= </span><a href="../../include/utils/relcache.h.html#LN40"><span class='Ref_to_Proto'>RelationGetIndexList</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN141"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN145"><span class='Ref_To_Local'>indexoidscan</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN144"><span class='Ref_To_Local'>indexoidlist</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN156"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>indexoid</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN107"><span class='Ref_to_Macro'>lfirst_oid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN145"><span class='Ref_To_Local'>indexoidscan</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN157"></a>        <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>indexTuple</span><span class='Delimiter'>; 
</span> 
        <a href="index.c.html#LN157"><span class='Ref_To_Local'>indexTuple</span></a> <span class='Operator'>= </span><a href="../../include/utils/syscache.h.html#LN155"><span class='Ref_to_Macro'>SearchSysCache1</span></a><span class='Parentheses'>(</span><a href="../../include/utils/syscache.h.html#LN65"><span class='Ref_to_EnumConst'>INDEXRELID</span></a><span class='Delimiter'>, </span><a href="../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN156"><span class='Ref_To_Local'>indexoid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN157"><span class='Ref_To_Local'>indexTuple</span></a><span class='Parentheses'>))</span>      <span class='Comment_Single_Line'>/* should not happen */ 
</span>            <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cache lookup failed for index %u"</span><span class='Delimiter'>, </span><a href="index.c.html#LN156"><span class='Ref_To_Local'>indexoid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="index.c.html#LN143"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../include/catalog/pg_index.h.html#LN66"><span class='Ref_to_Typedef'>Form_pg_index</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN157"><span class='Ref_To_Local'>indexTuple</span></a><span class='Parentheses'>))</span><span class='Operator'>-&GT;</span>indisprimary<span class='Delimiter'>; 
</span>        <a href="../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN157"><span class='Ref_To_Local'>indexTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN143"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN265"><span class='Ref_to_Proto'>list_free</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN144"><span class='Ref_To_Local'>indexoidlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="index.c.html#LN143"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end relationHasPrimaryKey &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * index_check_primary_key 
 *      Apply special checks needed before creating a PRIMARY KEY index 
 * 
 * This processing used to be in DefineIndex(), but has been split out 
 * so that it can be applied during ALTER TABLE ADD PRIMARY KEY USING INDEX. 
 * 
 * We check for a pre-existing primary key, and that all columns of the index 
 * are simple column references (not expressions), and that all those 
 * columns are marked NOT NULL.  If they aren't (which can only happen during 
 * ALTER TABLE ADD CONSTRAINT, since the parser forces such columns to be 
 * created NOT NULL during CREATE TABLE), do an ALTER SET NOT NULL to mark 
 * them so --- or fail if they are not in fact nonnull. 
 * 
 * Caller had better have at least ShareLock on the table, else the not-null 
 * checking isn't trustworthy. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN191"></a><span class='Declare_Function'>index_check_primary_key</span><span class='Parentheses'>(</span><a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>heapRel</span><span class='Delimiter'>, 
</span><a name="LN192"></a>                        <a href="../../include/nodes/execnodes.h.html#LN130"><span class='Ref_to_Struct'>IndexInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>indexInfo</span><span class='Delimiter'>, 
</span><a name="LN193"></a>                        <span class='Keyword'>bool </span><span class='Declare_Parameter'>is_alter_table</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN195"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>cmds</span><span class='Delimiter'>; 
</span><a name="LN196"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If ALTER TABLE, check that there isn't already a PRIMARY KEY. In CREATE 
     * TABLE, we have faith that the parser rejected multiple pkey clauses; 
     * and CREATE INDEX doesn't have a way to say PRIMARY KEY, so it's no 
     * problem either. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN193"><span class='Ref_to_Parameter'>is_alter_table</span></a> <span class='Operator'>&& 
</span>        <a href="index.c.html#LN89"><span class='Ref_to_Proto'>relationHasPrimaryKey</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN191"><span class='Ref_to_Parameter'>heapRel</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_INVALID_TABLE_DEFINITION<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>             <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"multiple primary keys for table \"%s\" are not allowed"</span><span class='Delimiter'>, 
</span>                    <a href="../../include/utils/rel.h.html#LN436"><span class='Ref_to_Macro'>RelationGetRelationName</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN191"><span class='Ref_to_Parameter'>heapRel</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Check that all of the attributes in a primary key are marked as not 
     * null, otherwise attempt to ALTER TABLE .. SET NOT NULL 
     */ 
</span>    <a href="index.c.html#LN195"><span class='Ref_To_Local'>cmds</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="index.c.html#LN196"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="index.c.html#LN196"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="index.c.html#LN192"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN133"><span class='Ref_to_Member'>ii_NumIndexAttrs</span></a><span class='Delimiter'>; </span><a href="index.c.html#LN196"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN220"></a>        <a href="../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a>  <span class='Declare_Local'>attnum</span> <span class='Operator'>= </span><a href="index.c.html#LN192"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN134"><span class='Ref_to_Member'>ii_KeyAttrNumbers</span></a><span class='Delimiter'>[</span><a href="index.c.html#LN196"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span><a name="LN221"></a>        <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>atttuple</span><span class='Delimiter'>; 
</span><a name="LN222"></a>        <a href="../../include/catalog/pg_attribute.h.html#LN186"><span class='Ref_to_Typedef'>Form_pg_attribute</span></a> <span class='Declare_Local'>attform</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN220"><span class='Ref_To_Local'>attnum</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"primary keys cannot be expressions"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* System attributes are never null, so no need to check */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN220"><span class='Ref_To_Local'>attnum</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <a href="index.c.html#LN221"><span class='Ref_To_Local'>atttuple</span></a> <span class='Operator'>= </span><a href="../../include/utils/syscache.h.html#LN157"><span class='Ref_to_Macro'>SearchSysCache2</span></a><span class='Parentheses'>(</span><a href="../../include/utils/syscache.h.html#LN40"><span class='Ref_to_EnumConst'>ATTNUM</span></a><span class='Delimiter'>, 
</span>                                 <a href="../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="../../include/utils/rel.h.html#LN416"><span class='Ref_to_Macro'>RelationGetRelid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN191"><span class='Ref_to_Parameter'>heapRel</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                                   <a href="../../include/postgres.h.html#LN456"><span class='Ref_to_Macro'>Int16GetDatum</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN220"><span class='Ref_To_Local'>attnum</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN221"><span class='Ref_To_Local'>atttuple</span></a><span class='Parentheses'>))</span> 
            <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cache lookup failed for attribute %d of relation %u"</span><span class='Delimiter'>, 
</span>                 <a href="index.c.html#LN220"><span class='Ref_To_Local'>attnum</span></a><span class='Delimiter'>, </span><a href="../../include/utils/rel.h.html#LN416"><span class='Ref_to_Macro'>RelationGetRelid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN191"><span class='Ref_to_Parameter'>heapRel</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="index.c.html#LN222"><span class='Ref_To_Local'>attform</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/catalog/pg_attribute.h.html#LN186"><span class='Ref_to_Typedef'>Form_pg_attribute</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN221"><span class='Ref_To_Local'>atttuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="index.c.html#LN222"><span class='Ref_To_Local'>attform</span></a><span class='Operator'>-&GT;</span>attnotnull<span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Add a subcommand to make this one NOT NULL */ 
</span><a name="LN244"></a>            <a href="../../include/nodes/parsenodes.h.html#LN1749"><span class='Ref_to_Struct'>AlterTableCmd</span></a> <span class='Operator'>*</span><span class='Declare_Local'>cmd</span> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN1749"><span class='Ref_to_Struct'>AlterTableCmd</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="index.c.html#LN244"><span class='Ref_To_Local'>cmd</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1752"><span class='Ref_to_Member'>subtype</span></a> <span class='Operator'>= </span><a href="../../include/nodes/parsenodes.h.html#LN1678"><span class='Ref_to_EnumConst'>AT_SetNotNull</span></a><span class='Delimiter'>; 
</span>            <a href="index.c.html#LN244"><span class='Ref_To_Local'>cmd</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1753"><span class='Ref_to_Member'>name</span></a> <span class='Operator'>= </span><a href="../../include/common/fe_memutils.h.html#LN32"><span class='Ref_to_Proto'>pstrdup</span></a><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN498"><span class='Ref_to_Macro'>NameStr</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN222"><span class='Ref_To_Local'>attform</span></a><span class='Operator'>-&GT;</span>attname<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="index.c.html#LN195"><span class='Ref_To_Local'>cmds</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN195"><span class='Ref_To_Local'>cmds</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN244"><span class='Ref_To_Local'>cmd</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN221"><span class='Ref_To_Local'>atttuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;indexInfo-&GT;ii_N... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * XXX: Shouldn't the ALTER TABLE .. SET NOT NULL cascade to child tables? 
     * Currently, since the PRIMARY KEY itself doesn't cascade, we don't 
     * cascade the notnull constraint(s) either; but this is pretty debatable. 
     * 
     * XXX: possible future improvement: when being called from ALTER TABLE, 
     * it would be more efficient to merge this with the outer ALTER TABLE, so 
     * as to avoid two scans.  But that seems to complicate DefineIndex's API 
     * unduly. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN195"><span class='Ref_To_Local'>cmds</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/commands/tablecmds.h.html#LN37"><span class='Ref_to_Proto'>AlterTableInternal</span></a><span class='Parentheses'>(</span><a href="../../include/utils/rel.h.html#LN416"><span class='Ref_to_Macro'>RelationGetRelid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN191"><span class='Ref_to_Parameter'>heapRel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="index.c.html#LN195"><span class='Ref_To_Local'>cmds</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end index_check_primary_key &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 *      ConstructTupleDescriptor 
 * 
 * Build an index tuple descriptor for a new index 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a> 
<a name="LN274"></a><span class='Declare_Function'>ConstructTupleDescriptor</span><span class='Parentheses'>(</span><a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>heapRelation</span><span class='Delimiter'>, 
</span><a name="LN275"></a>                         <a href="../../include/nodes/execnodes.h.html#LN130"><span class='Ref_to_Struct'>IndexInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>indexInfo</span><span class='Delimiter'>, 
</span><a name="LN276"></a>                         <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>indexColNames</span><span class='Delimiter'>, 
</span><a name="LN277"></a>                         <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>accessMethodObjectId</span><span class='Delimiter'>, 
</span><a name="LN278"></a>                         <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>collationObjectId</span><span class='Delimiter'>, 
</span><a name="LN279"></a>                         <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>classObjectId</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN281"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numatts</span> <span class='Operator'>= </span><a href="index.c.html#LN275"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN133"><span class='Ref_to_Member'>ii_NumIndexAttrs</span></a><span class='Delimiter'>; 
</span><a name="LN282"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>colnames_item</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN276"><span class='Ref_to_Parameter'>indexColNames</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN283"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>indexpr_item</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN275"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN135"><span class='Ref_to_Member'>ii_Expressions</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN284"></a>    <a href="../../include/access/amapi.h.html#LN158"><span class='Ref_to_Struct'>IndexAmRoutine</span></a> <span class='Operator'>*</span><span class='Declare_Local'>amroutine</span><span class='Delimiter'>; 
</span><a name="LN285"></a>    <a href="../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a>   <span class='Declare_Local'>heapTupDesc</span><span class='Delimiter'>; 
</span><a name="LN286"></a>    <a href="../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a>   <span class='Declare_Local'>indexTupDesc</span><span class='Delimiter'>; 
</span><a name="LN287"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>natts</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* #atts in heap rel --- for error checks */ 
</span><a name="LN288"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* We need access to the index AM's API struct */ 
</span>    <a href="index.c.html#LN284"><span class='Ref_To_Local'>amroutine</span></a> <span class='Operator'>= </span><a href="../access/index/amapi.c.html#LN54"><span class='Ref_to_Func'>GetIndexAmRoutineByAmId</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN277"><span class='Ref_to_Parameter'>accessMethodObjectId</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* ... and to the table's tuple descriptor */ 
</span>    <a href="index.c.html#LN285"><span class='Ref_To_Local'>heapTupDesc</span></a> <span class='Operator'>= </span><a href="../../include/utils/rel.h.html#LN428"><span class='Ref_to_Macro'>RelationGetDescr</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN274"><span class='Ref_to_Parameter'>heapRelation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN287"><span class='Ref_To_Local'>natts</span></a> <span class='Operator'>= </span><a href="../../include/utils/rel.h.html#LN410"><span class='Ref_to_Macro'>RelationGetForm</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN274"><span class='Ref_to_Parameter'>heapRelation</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>relnatts<span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * allocate the new tuple descriptor 
     */ 
</span>    <a href="index.c.html#LN286"><span class='Ref_To_Local'>indexTupDesc</span></a> <span class='Operator'>= </span><a href="../access/common/tupdesc.c.html#LN39"><span class='Ref_to_Func'>CreateTemplateTupleDesc</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN281"><span class='Ref_To_Local'>numatts</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * For simple index columns, we copy the pg_attribute row from the parent 
     * relation and modify it as necessary.  For expressions we have to cons 
     * up a pg_attribute row the hard way. 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="index.c.html#LN288"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="index.c.html#LN288"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="index.c.html#LN281"><span class='Ref_To_Local'>numatts</span></a><span class='Delimiter'>; </span><a href="index.c.html#LN288"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN309"></a>        <a href="../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a>  <span class='Declare_Local'>atnum</span> <span class='Operator'>= </span><a href="index.c.html#LN275"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN134"><span class='Ref_to_Member'>ii_KeyAttrNumbers</span></a><span class='Delimiter'>[</span><a href="index.c.html#LN288"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span><a name="LN310"></a>        <a href="../../include/catalog/pg_attribute.h.html#LN186"><span class='Ref_to_Typedef'>Form_pg_attribute</span></a> <span class='Declare_Local'>to</span> <span class='Operator'>= </span><a href="index.c.html#LN286"><span class='Ref_To_Local'>indexTupDesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/tupdesc.h.html#LN73"><span class='Ref_to_Member'>attrs</span></a><span class='Delimiter'>[</span><a href="index.c.html#LN288"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span><a name="LN311"></a>        <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>tuple</span><span class='Delimiter'>; 
</span><a name="LN312"></a>        <a href="../../include/catalog/pg_type.h.html#LN232"><span class='Ref_to_Typedef'>Form_pg_type</span></a> <span class='Declare_Local'>typeTup</span><span class='Delimiter'>; 
</span><a name="LN313"></a>        <a href="../../include/catalog/pg_opclass.h.html#LN67"><span class='Ref_to_Typedef'>Form_pg_opclass</span></a> <span class='Declare_Local'>opclassTup</span><span class='Delimiter'>; 
</span><a name="LN314"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>keyType</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN309"><span class='Ref_To_Local'>atnum</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Simple index column */ 
</span><a name="LN319"></a>            <a href="../../include/catalog/pg_attribute.h.html#LN186"><span class='Ref_to_Typedef'>Form_pg_attribute</span></a> <span class='Declare_Local'>from</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN309"><span class='Ref_To_Local'>atnum</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * here we are indexing on a system attribute (-1...-n) 
                 */ 
</span>                <a href="index.c.html#LN319"><span class='Ref_To_Local'>from</span></a> <span class='Operator'>= </span><a href="../../include/catalog/heap.h.html#LN122"><span class='Ref_to_Proto'>SystemAttributeDefinition</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN309"><span class='Ref_To_Local'>atnum</span></a><span class='Delimiter'>, 
</span>                                           <a href="index.c.html#LN274"><span class='Ref_to_Parameter'>heapRelation</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relhasoids<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * here we are indexing on a normal attribute (1...n) 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN309"><span class='Ref_To_Local'>atnum</span></a> <span class='Operator'>&GT; </span><a href="index.c.html#LN287"><span class='Ref_To_Local'>natts</span></a><span class='Parentheses'>)</span>      <span class='Comment_Single_Line'>/* safety check */ 
</span>                    <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"invalid column number %d"</span><span class='Delimiter'>, </span><a href="index.c.html#LN309"><span class='Ref_To_Local'>atnum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="index.c.html#LN319"><span class='Ref_To_Local'>from</span></a> <span class='Operator'>= </span><a href="index.c.html#LN285"><span class='Ref_To_Local'>heapTupDesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/tupdesc.h.html#LN73"><span class='Ref_to_Member'>attrs</span></a><span class='Delimiter'>[</span><a href="../../include/access/attnum.h.html#LN50"><span class='Ref_to_Macro'>AttrNumberGetAttrOffset</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN309"><span class='Ref_To_Local'>atnum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>]; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * now that we've determined the "from", let's copy the tuple desc 
             * data... 
             */ 
</span>            memcpy<span class='Parentheses'>(</span><a href="index.c.html#LN310"><span class='Ref_To_Local'>to</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN319"><span class='Ref_To_Local'>from</span></a><span class='Delimiter'>, </span><a href="../../include/catalog/pg_attribute.h.html#LN178"><span class='Ref_to_Const'>ATTRIBUTE_FIXED_PART_SIZE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Fix the stuff that should not be the same as the underlying 
             * attr 
             */ 
</span>            <a href="index.c.html#LN310"><span class='Ref_To_Local'>to</span></a><span class='Operator'>-&GT;</span>attnum <span class='Operator'>= </span><a href="index.c.html#LN288"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
            <a href="index.c.html#LN310"><span class='Ref_To_Local'>to</span></a><span class='Operator'>-&GT;</span>attstattarget <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>            <a href="index.c.html#LN310"><span class='Ref_To_Local'>to</span></a><span class='Operator'>-&GT;</span>attcacheoff <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>            <a href="index.c.html#LN310"><span class='Ref_To_Local'>to</span></a><span class='Operator'>-&GT;</span>attnotnull <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="index.c.html#LN310"><span class='Ref_To_Local'>to</span></a><span class='Operator'>-&GT;</span>atthasdef <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="index.c.html#LN310"><span class='Ref_To_Local'>to</span></a><span class='Operator'>-&GT;</span>attidentity <span class='Operator'>= </span><span class='String'>'\0'</span><span class='Delimiter'>; 
</span>            <a href="index.c.html#LN310"><span class='Ref_To_Local'>to</span></a><span class='Operator'>-&GT;</span>attislocal <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <a href="index.c.html#LN310"><span class='Ref_To_Local'>to</span></a><span class='Operator'>-&GT;</span>attinhcount <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <a href="index.c.html#LN310"><span class='Ref_To_Local'>to</span></a><span class='Operator'>-&GT;</span>attcollation <span class='Operator'>= </span><a href="index.c.html#LN278"><span class='Ref_to_Parameter'>collationObjectId</span></a><span class='Delimiter'>[</span><a href="index.c.html#LN288"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if atnum!=0 &raquo; </span> 
        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Expressional index */ 
</span><a name="LN363"></a>            <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>indexkey</span><span class='Delimiter'>; 
</span> 
            <a href="../../include/c.h.html#LN856"><span class='Ref_to_Macro'>MemSet</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN310"><span class='Ref_To_Local'>to</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><a href="../../include/catalog/pg_attribute.h.html#LN178"><span class='Ref_to_Const'>ATTRIBUTE_FIXED_PART_SIZE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN283"><span class='Ref_To_Local'>indexpr_item</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span>   <span class='Comment_Single_Line'>/* shouldn't happen */ 
</span>                <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"too few entries in indexprs list"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="index.c.html#LN363"><span class='Ref_To_Local'>indexkey</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN283"><span class='Ref_To_Local'>indexpr_item</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="index.c.html#LN283"><span class='Ref_To_Local'>indexpr_item</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN283"><span class='Ref_To_Local'>indexpr_item</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Lookup the expression type in pg_type for the type length etc. 
             */ 
</span>            <a href="index.c.html#LN314"><span class='Ref_To_Local'>keyType</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN363"><span class='Ref_To_Local'>indexkey</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="index.c.html#LN311"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>= </span><a href="../../include/utils/syscache.h.html#LN155"><span class='Ref_to_Macro'>SearchSysCache1</span></a><span class='Parentheses'>(</span><a href="../../include/utils/syscache.h.html#LN107"><span class='Ref_to_EnumConst'>TYPEOID</span></a><span class='Delimiter'>, </span><a href="../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN314"><span class='Ref_To_Local'>keyType</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN311"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>))</span> 
                <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cache lookup failed for type %u"</span><span class='Delimiter'>, </span><a href="index.c.html#LN314"><span class='Ref_To_Local'>keyType</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="index.c.html#LN312"><span class='Ref_To_Local'>typeTup</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/catalog/pg_type.h.html#LN232"><span class='Ref_to_Typedef'>Form_pg_type</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN311"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Assign some of the attributes values. Leave the rest as 0. 
             */ 
</span>            <a href="index.c.html#LN310"><span class='Ref_To_Local'>to</span></a><span class='Operator'>-&GT;</span>attnum <span class='Operator'>= </span><a href="index.c.html#LN288"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>            <a href="index.c.html#LN310"><span class='Ref_To_Local'>to</span></a><span class='Operator'>-&GT;</span>atttypid <span class='Operator'>= </span><a href="index.c.html#LN314"><span class='Ref_To_Local'>keyType</span></a><span class='Delimiter'>; 
</span>            <a href="index.c.html#LN310"><span class='Ref_To_Local'>to</span></a><span class='Operator'>-&GT;</span>attlen <span class='Operator'>= </span><a href="index.c.html#LN312"><span class='Ref_To_Local'>typeTup</span></a><span class='Operator'>-&GT;</span>typlen<span class='Delimiter'>; 
</span>            <a href="index.c.html#LN310"><span class='Ref_To_Local'>to</span></a><span class='Operator'>-&GT;</span>attbyval <span class='Operator'>= </span><a href="index.c.html#LN312"><span class='Ref_To_Local'>typeTup</span></a><span class='Operator'>-&GT;</span>typbyval<span class='Delimiter'>; 
</span>            <a href="index.c.html#LN310"><span class='Ref_To_Local'>to</span></a><span class='Operator'>-&GT;</span>attstorage <span class='Operator'>= </span><a href="index.c.html#LN312"><span class='Ref_To_Local'>typeTup</span></a><span class='Operator'>-&GT;</span>typstorage<span class='Delimiter'>; 
</span>            <a href="index.c.html#LN310"><span class='Ref_To_Local'>to</span></a><span class='Operator'>-&GT;</span>attalign <span class='Operator'>= </span><a href="index.c.html#LN312"><span class='Ref_To_Local'>typeTup</span></a><span class='Operator'>-&GT;</span>typalign<span class='Delimiter'>; 
</span>            <a href="index.c.html#LN310"><span class='Ref_To_Local'>to</span></a><span class='Operator'>-&GT;</span>attstattarget <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>            <a href="index.c.html#LN310"><span class='Ref_To_Local'>to</span></a><span class='Operator'>-&GT;</span>attcacheoff <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>            <a href="index.c.html#LN310"><span class='Ref_To_Local'>to</span></a><span class='Operator'>-&GT;</span>atttypmod <span class='Operator'>= </span><a href="../../include/nodes/nodeFuncs.h.html#LN32"><span class='Ref_to_Proto'>exprTypmod</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN363"><span class='Ref_To_Local'>indexkey</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="index.c.html#LN310"><span class='Ref_To_Local'>to</span></a><span class='Operator'>-&GT;</span>attislocal <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <a href="index.c.html#LN310"><span class='Ref_To_Local'>to</span></a><span class='Operator'>-&GT;</span>attcollation <span class='Operator'>= </span><a href="index.c.html#LN278"><span class='Ref_to_Parameter'>collationObjectId</span></a><span class='Delimiter'>[</span><a href="index.c.html#LN288"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
            <a href="../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN311"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Make sure the expression yields a type that's safe to store in 
             * an index.  We need this defense because we have index opclasses 
             * for pseudo-types such as "record", and the actually stored type 
             * had better be safe; eg, a named composite type is okay, an 
             * anonymous record type is not.  The test is the same as for 
             * whether a table column is of a safe type (which is why we 
             * needn't check for the non-expression case). 
             */ 
</span>            <a href="../../include/catalog/heap.h.html#LN131"><span class='Ref_to_Proto'>CheckAttributeType</span></a><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN498"><span class='Ref_to_Macro'>NameStr</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN310"><span class='Ref_To_Local'>to</span></a><span class='Operator'>-&GT;</span>attname<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                               <a href="index.c.html#LN310"><span class='Ref_To_Local'>to</span></a><span class='Operator'>-&GT;</span>atttypid<span class='Delimiter'>, </span><a href="index.c.html#LN310"><span class='Ref_To_Local'>to</span></a><span class='Operator'>-&GT;</span>attcollation<span class='Delimiter'>, 
</span>                               <a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* 
         * We do not yet have the correct relation OID for the index, so just 
         * set it invalid for now.  InitializeAttributeOids() will fix it 
         * later. 
         */ 
</span>        <a href="index.c.html#LN310"><span class='Ref_To_Local'>to</span></a><span class='Operator'>-&GT;</span>attrelid <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Set the attribute name as specified by caller. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN282"><span class='Ref_To_Local'>colnames_item</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span>      <span class='Comment_Single_Line'>/* shouldn't happen */ 
</span>            <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"too few entries in colnames list"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/utils/builtins.h.html#LN40"><span class='Ref_to_Proto'>namestrcpy</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="index.c.html#LN310"><span class='Ref_To_Local'>to</span></a><span class='Operator'>-&GT;</span>attname<span class='Delimiter'>, </span><span class='Parentheses'>(</span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN282"><span class='Ref_To_Local'>colnames_item</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="index.c.html#LN282"><span class='Ref_To_Local'>colnames_item</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN282"><span class='Ref_To_Local'>colnames_item</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Check the opclass and index AM to see if either provides a keytype 
         * (overriding the attribute type).  Opclass takes precedence. 
         */ 
</span>        <a href="index.c.html#LN311"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>= </span><a href="../../include/utils/syscache.h.html#LN155"><span class='Ref_to_Macro'>SearchSysCache1</span></a><span class='Parentheses'>(</span><a href="../../include/utils/syscache.h.html#LN47"><span class='Ref_to_EnumConst'>CLAOID</span></a><span class='Delimiter'>, </span><a href="../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN279"><span class='Ref_to_Parameter'>classObjectId</span></a><span class='Delimiter'>[</span><a href="index.c.html#LN288"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN311"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>))</span> 
            <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cache lookup failed for opclass %u"</span><span class='Delimiter'>, 
</span>                 <a href="index.c.html#LN279"><span class='Ref_to_Parameter'>classObjectId</span></a><span class='Delimiter'>[</span><a href="index.c.html#LN288"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="index.c.html#LN313"><span class='Ref_To_Local'>opclassTup</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/catalog/pg_opclass.h.html#LN67"><span class='Ref_to_Typedef'>Form_pg_opclass</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN311"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN313"><span class='Ref_To_Local'>opclassTup</span></a><span class='Operator'>-&GT;</span>opckeytype<span class='Parentheses'>))</span> 
            <a href="index.c.html#LN314"><span class='Ref_To_Local'>keyType</span></a> <span class='Operator'>= </span><a href="index.c.html#LN313"><span class='Ref_To_Local'>opclassTup</span></a><span class='Operator'>-&GT;</span>opckeytype<span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="index.c.html#LN314"><span class='Ref_To_Local'>keyType</span></a> <span class='Operator'>= </span><a href="index.c.html#LN284"><span class='Ref_To_Local'>amroutine</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/amapi.h.html#LN194"><span class='Ref_to_Member'>amkeytype</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If keytype is specified as ANYELEMENT, and opcintype is ANYARRAY, 
         * then the attribute type must be an array (else it'd not have 
         * matched this opclass); use its element type. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN314"><span class='Ref_To_Local'>keyType</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN701"><span class='Ref_to_Const'>ANYELEMENTOID</span></a> <span class='Operator'>&& </span><a href="index.c.html#LN313"><span class='Ref_To_Local'>opclassTup</span></a><span class='Operator'>-&GT;</span>opcintype <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN687"><span class='Ref_to_Const'>ANYARRAYOID</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="index.c.html#LN314"><span class='Ref_To_Local'>keyType</span></a> <span class='Operator'>= </span><a href="../../include/utils/lsyscache.h.html#LN160"><span class='Ref_to_Proto'>get_base_element_type</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN310"><span class='Ref_To_Local'>to</span></a><span class='Operator'>-&GT;</span>atttypid<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN314"><span class='Ref_To_Local'>keyType</span></a><span class='Parentheses'>))</span> 
                <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"could not get element type of array type %u"</span><span class='Delimiter'>, 
</span>                     <a href="index.c.html#LN310"><span class='Ref_To_Local'>to</span></a><span class='Operator'>-&GT;</span>atttypid<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN311"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If a key type different from the heap value is specified, update 
         * the type-related fields in the index tupdesc. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN314"><span class='Ref_To_Local'>keyType</span></a><span class='Parentheses'>) </span><span class='Operator'>&& </span><a href="index.c.html#LN314"><span class='Ref_To_Local'>keyType</span></a> <span class='Operator'>!= </span><a href="index.c.html#LN310"><span class='Ref_To_Local'>to</span></a><span class='Operator'>-&GT;</span>atttypid<span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <a href="index.c.html#LN311"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>= </span><a href="../../include/utils/syscache.h.html#LN155"><span class='Ref_to_Macro'>SearchSysCache1</span></a><span class='Parentheses'>(</span><a href="../../include/utils/syscache.h.html#LN107"><span class='Ref_to_EnumConst'>TYPEOID</span></a><span class='Delimiter'>, </span><a href="../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN314"><span class='Ref_To_Local'>keyType</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN311"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>))</span> 
                <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cache lookup failed for type %u"</span><span class='Delimiter'>, </span><a href="index.c.html#LN314"><span class='Ref_To_Local'>keyType</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="index.c.html#LN312"><span class='Ref_To_Local'>typeTup</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/catalog/pg_type.h.html#LN232"><span class='Ref_to_Typedef'>Form_pg_type</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN311"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="index.c.html#LN310"><span class='Ref_To_Local'>to</span></a><span class='Operator'>-&GT;</span>atttypid <span class='Operator'>= </span><a href="index.c.html#LN314"><span class='Ref_To_Local'>keyType</span></a><span class='Delimiter'>; 
</span>            <a href="index.c.html#LN310"><span class='Ref_To_Local'>to</span></a><span class='Operator'>-&GT;</span>atttypmod <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>            <a href="index.c.html#LN310"><span class='Ref_To_Local'>to</span></a><span class='Operator'>-&GT;</span>attlen <span class='Operator'>= </span><a href="index.c.html#LN312"><span class='Ref_To_Local'>typeTup</span></a><span class='Operator'>-&GT;</span>typlen<span class='Delimiter'>; 
</span>            <a href="index.c.html#LN310"><span class='Ref_To_Local'>to</span></a><span class='Operator'>-&GT;</span>attbyval <span class='Operator'>= </span><a href="index.c.html#LN312"><span class='Ref_To_Local'>typeTup</span></a><span class='Operator'>-&GT;</span>typbyval<span class='Delimiter'>; 
</span>            <a href="index.c.html#LN310"><span class='Ref_To_Local'>to</span></a><span class='Operator'>-&GT;</span>attalign <span class='Operator'>= </span><a href="index.c.html#LN312"><span class='Ref_To_Local'>typeTup</span></a><span class='Operator'>-&GT;</span>typalign<span class='Delimiter'>; 
</span>            <a href="index.c.html#LN310"><span class='Ref_To_Local'>to</span></a><span class='Operator'>-&GT;</span>attstorage <span class='Operator'>= </span><a href="index.c.html#LN312"><span class='Ref_To_Local'>typeTup</span></a><span class='Operator'>-&GT;</span>typstorage<span class='Delimiter'>; 
</span> 
            <a href="../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN311"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;numatts;i++ &raquo; </span> 
 
    <a href="../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN284"><span class='Ref_To_Local'>amroutine</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="index.c.html#LN286"><span class='Ref_To_Local'>indexTupDesc</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ConstructTupleDescriptor &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *      InitializeAttributeOids 
 * ---------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN488"></a><span class='Declare_Function'>InitializeAttributeOids</span><span class='Parentheses'>(</span><a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>indexRelation</span><span class='Delimiter'>, 
</span><a name="LN489"></a>                        <span class='Keyword'>int </span><span class='Declare_Parameter'>numatts</span><span class='Delimiter'>, 
</span><a name="LN490"></a>                        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>indexoid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN492"></a>    <a href="../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a>   <span class='Declare_Local'>tupleDescriptor</span><span class='Delimiter'>; 
</span><a name="LN493"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <a href="index.c.html#LN492"><span class='Ref_To_Local'>tupleDescriptor</span></a> <span class='Operator'>= </span><a href="../../include/utils/rel.h.html#LN428"><span class='Ref_to_Macro'>RelationGetDescr</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN488"><span class='Ref_to_Parameter'>indexRelation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="index.c.html#LN493"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="index.c.html#LN493"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="index.c.html#LN489"><span class='Ref_to_Parameter'>numatts</span></a><span class='Delimiter'>; </span><a href="index.c.html#LN493"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>+= </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>        <a href="index.c.html#LN492"><span class='Ref_To_Local'>tupleDescriptor</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/tupdesc.h.html#LN73"><span class='Ref_to_Member'>attrs</span></a><span class='Delimiter'>[</span><a href="index.c.html#LN493"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>-&GT;</span>attrelid <span class='Operator'>= </span><a href="index.c.html#LN490"><span class='Ref_to_Parameter'>indexoid</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *      AppendAttributeTuples 
 * ---------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN506"></a><span class='Declare_Function'>AppendAttributeTuples</span><span class='Parentheses'>(</span><a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>indexRelation</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>numatts</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN508"></a>    <a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>pg_attribute</span><span class='Delimiter'>; 
</span><a name="LN509"></a>    <a href="../../include/catalog/indexing.h.html#LN25"><span class='Ref_to_Typedef'>CatalogIndexState</span></a> <span class='Declare_Local'>indstate</span><span class='Delimiter'>; 
</span><a name="LN510"></a>    <a href="../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a>   <span class='Declare_Local'>indexTupDesc</span><span class='Delimiter'>; 
</span><a name="LN511"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * open the attribute relation and its indexes 
     */ 
</span>    <a href="index.c.html#LN508"><span class='Ref_To_Local'>pg_attribute</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN91"><span class='Ref_to_Proto'>heap_open</span></a><span class='Parentheses'>(</span><a href="../../include/catalog/pg_attribute.h.html#LN32"><span class='Ref_to_Const'>AttributeRelationId</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN37"><span class='Ref_to_Const'>RowExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="index.c.html#LN509"><span class='Ref_To_Local'>indstate</span></a> <span class='Operator'>= </span><a href="../../include/catalog/indexing.h.html#LN30"><span class='Ref_to_Proto'>CatalogOpenIndexes</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN508"><span class='Ref_To_Local'>pg_attribute</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * insert data from new index's tupdesc into pg_attribute 
     */ 
</span>    <a href="index.c.html#LN510"><span class='Ref_To_Local'>indexTupDesc</span></a> <span class='Operator'>= </span><a href="../../include/utils/rel.h.html#LN428"><span class='Ref_to_Macro'>RelationGetDescr</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN506"><span class='Ref_to_Parameter'>indexRelation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="index.c.html#LN511"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="index.c.html#LN511"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="index.c.html#LN506"><span class='Ref_to_Parameter'>numatts</span></a><span class='Delimiter'>; </span><a href="index.c.html#LN511"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * There used to be very grotty code here to set these fields, but I 
         * think it's unnecessary.  They should be set already. 
         */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="index.c.html#LN510"><span class='Ref_To_Local'>indexTupDesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/tupdesc.h.html#LN73"><span class='Ref_to_Member'>attrs</span></a><span class='Delimiter'>[</span><a href="index.c.html#LN511"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>-&GT;</span>attnum <span class='Operator'>== </span><a href="index.c.html#LN511"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="index.c.html#LN510"><span class='Ref_To_Local'>indexTupDesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/tupdesc.h.html#LN73"><span class='Ref_to_Member'>attrs</span></a><span class='Delimiter'>[</span><a href="index.c.html#LN511"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>-&GT;</span>attcacheoff <span class='Operator'>== -</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/catalog/heap.h.html#LN87"><span class='Ref_to_Proto'>InsertPgAttributeTuple</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN508"><span class='Ref_To_Local'>pg_attribute</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN510"><span class='Ref_To_Local'>indexTupDesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/tupdesc.h.html#LN73"><span class='Ref_to_Member'>attrs</span></a><span class='Delimiter'>[</span><a href="index.c.html#LN511"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], </span><a href="index.c.html#LN509"><span class='Ref_To_Local'>indstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../include/catalog/indexing.h.html#LN31"><span class='Ref_to_Proto'>CatalogCloseIndexes</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN509"><span class='Ref_To_Local'>indstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/access/heapam.h.html#LN96"><span class='Ref_to_Macro'>heap_close</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN508"><span class='Ref_To_Local'>pg_attribute</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN37"><span class='Ref_to_Const'>RowExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end AppendAttributeTuples &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *      UpdateIndexRelation 
 * 
 * Construct and insert a new entry in the pg_index catalog 
 * ---------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN549"></a><span class='Declare_Function'>UpdateIndexRelation</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>indexoid</span><span class='Delimiter'>, 
</span><a name="LN550"></a>                    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>heapoid</span><span class='Delimiter'>, 
</span><a name="LN551"></a>                    <a href="../../include/nodes/execnodes.h.html#LN130"><span class='Ref_to_Struct'>IndexInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>indexInfo</span><span class='Delimiter'>, 
</span><a name="LN552"></a>                    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>collationOids</span><span class='Delimiter'>, 
</span><a name="LN553"></a>                    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>classOids</span><span class='Delimiter'>, 
</span><a name="LN554"></a>                    <a href="../../include/c.h.html#LN254"><span class='Ref_to_Typedef'>int16</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>coloptions</span><span class='Delimiter'>, 
</span><a name="LN555"></a>                    <span class='Keyword'>bool </span><span class='Declare_Parameter'>primary</span><span class='Delimiter'>, 
</span><a name="LN556"></a>                    <span class='Keyword'>bool </span><span class='Declare_Parameter'>isexclusion</span><span class='Delimiter'>, 
</span><a name="LN557"></a>                    <span class='Keyword'>bool </span><span class='Declare_Parameter'>immediate</span><span class='Delimiter'>, 
</span><a name="LN558"></a>                    <span class='Keyword'>bool </span><span class='Declare_Parameter'>isvalid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN560"></a>    <a href="../../include/c.h.html#LN466"><span class='Ref_to_Typedef'>int2vector</span></a> <span class='Operator'>*</span><span class='Declare_Local'>indkey</span><span class='Delimiter'>; 
</span><a name="LN561"></a>    <a href="../../include/c.h.html#LN477"><span class='Ref_to_Typedef'>oidvector</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>indcollation</span><span class='Delimiter'>; 
</span><a name="LN562"></a>    <a href="../../include/c.h.html#LN477"><span class='Ref_to_Typedef'>oidvector</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>indclass</span><span class='Delimiter'>; 
</span><a name="LN563"></a>    <a href="../../include/c.h.html#LN466"><span class='Ref_to_Typedef'>int2vector</span></a> <span class='Operator'>*</span><span class='Declare_Local'>indoption</span><span class='Delimiter'>; 
</span><a name="LN564"></a>    <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>exprsDatum</span><span class='Delimiter'>; 
</span><a name="LN565"></a>    <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>predDatum</span><span class='Delimiter'>; 
</span><a name="LN566"></a>    <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>values</span><span class='Delimiter'>[</span><a href="../../include/catalog/pg_index.h.html#LN72"><span class='Ref_to_Const'>Natts_pg_index</span></a><span class='Delimiter'>]; 
</span><a name="LN567"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>nulls</span><span class='Delimiter'>[</span><a href="../../include/catalog/pg_index.h.html#LN72"><span class='Ref_to_Const'>Natts_pg_index</span></a><span class='Delimiter'>]; 
</span><a name="LN568"></a>    <a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>pg_index</span><span class='Delimiter'>; 
</span><a name="LN569"></a>    <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>tuple</span><span class='Delimiter'>; 
</span><a name="LN570"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Copy the index key, opclass, and indoption info into arrays (should we 
     * make the caller pass them like this to start with?) 
     */ 
</span>    <a href="index.c.html#LN560"><span class='Ref_To_Local'>indkey</span></a> <span class='Operator'>= </span><a href="../../include/utils/builtins.h.html#LN36"><span class='Ref_to_Proto'>buildint2vector</span></a><span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><a href="index.c.html#LN551"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN133"><span class='Ref_to_Member'>ii_NumIndexAttrs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="index.c.html#LN570"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="index.c.html#LN570"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="index.c.html#LN551"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN133"><span class='Ref_to_Member'>ii_NumIndexAttrs</span></a><span class='Delimiter'>; </span><a href="index.c.html#LN570"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <a href="index.c.html#LN560"><span class='Ref_To_Local'>indkey</span></a><span class='Operator'>-&GT;</span><a href="../../include/c.h.html#LN474"><span class='Ref_to_Member'>values</span></a><span class='Delimiter'>[</span><a href="index.c.html#LN570"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="index.c.html#LN551"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN134"><span class='Ref_to_Member'>ii_KeyAttrNumbers</span></a><span class='Delimiter'>[</span><a href="index.c.html#LN570"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>    <a href="index.c.html#LN561"><span class='Ref_To_Local'>indcollation</span></a> <span class='Operator'>= </span><a href="../../include/utils/builtins.h.html#LN67"><span class='Ref_to_Proto'>buildoidvector</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN552"><span class='Ref_to_Parameter'>collationOids</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN551"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN133"><span class='Ref_to_Member'>ii_NumIndexAttrs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN562"><span class='Ref_To_Local'>indclass</span></a> <span class='Operator'>= </span><a href="../../include/utils/builtins.h.html#LN67"><span class='Ref_to_Proto'>buildoidvector</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN553"><span class='Ref_to_Parameter'>classOids</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN551"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN133"><span class='Ref_to_Member'>ii_NumIndexAttrs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN563"><span class='Ref_To_Local'>indoption</span></a> <span class='Operator'>= </span><a href="../../include/utils/builtins.h.html#LN36"><span class='Ref_to_Proto'>buildint2vector</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN554"><span class='Ref_to_Parameter'>coloptions</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN551"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN133"><span class='Ref_to_Member'>ii_NumIndexAttrs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Convert the index expressions (if any) to a text datum 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN551"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN135"><span class='Ref_to_Member'>ii_Expressions</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN588"></a>        <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>exprsString</span><span class='Delimiter'>; 
</span> 
        <a href="index.c.html#LN588"><span class='Ref_To_Local'>exprsString</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN598"><span class='Ref_to_Proto'>nodeToString</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN551"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN135"><span class='Ref_to_Member'>ii_Expressions</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="index.c.html#LN564"><span class='Ref_To_Local'>exprsDatum</span></a> <span class='Operator'>= </span><a href="../../include/utils/builtins.h.html#LN90"><span class='Ref_to_Macro'>CStringGetTextDatum</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN588"><span class='Ref_To_Local'>exprsString</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN588"><span class='Ref_To_Local'>exprsString</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
        <a href="index.c.html#LN564"><span class='Ref_To_Local'>exprsDatum</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Convert the index predicate (if any) to a text datum.  Note we convert 
     * implicit-AND format to normal explicit-AND for storage. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN551"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN137"><span class='Ref_to_Member'>ii_Predicate</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN603"></a>        <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>predString</span><span class='Delimiter'>; 
</span> 
        <a href="index.c.html#LN603"><span class='Ref_To_Local'>predString</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN598"><span class='Ref_to_Proto'>nodeToString</span></a><span class='Parentheses'>(</span><a href="../../include/optimizer/clauses.h.html#LN45"><span class='Ref_to_Proto'>make_ands_explicit</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN551"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN137"><span class='Ref_to_Member'>ii_Predicate</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="index.c.html#LN565"><span class='Ref_To_Local'>predDatum</span></a> <span class='Operator'>= </span><a href="../../include/utils/builtins.h.html#LN90"><span class='Ref_to_Macro'>CStringGetTextDatum</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN603"><span class='Ref_To_Local'>predString</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN603"><span class='Ref_To_Local'>predString</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
        <a href="index.c.html#LN565"><span class='Ref_To_Local'>predDatum</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * open the system catalog index relation 
     */ 
</span>    <a href="index.c.html#LN568"><span class='Ref_To_Local'>pg_index</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN91"><span class='Ref_to_Proto'>heap_open</span></a><span class='Parentheses'>(</span><a href="../../include/catalog/pg_index.h.html#LN28"><span class='Ref_to_Const'>IndexRelationId</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN37"><span class='Ref_to_Const'>RowExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Build a pg_index tuple 
     */ 
</span>    <a href="../../include/c.h.html#LN856"><span class='Ref_to_Macro'>MemSet</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN567"><span class='Ref_To_Local'>nulls</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="index.c.html#LN567"><span class='Ref_To_Local'>nulls</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="index.c.html#LN566"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><a href="../../include/catalog/pg_index.h.html#LN73"><span class='Ref_to_Const'>Anum_pg_index_indexrelid</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN549"><span class='Ref_to_Parameter'>indexoid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN566"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><a href="../../include/catalog/pg_index.h.html#LN74"><span class='Ref_to_Const'>Anum_pg_index_indrelid</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN550"><span class='Ref_to_Parameter'>heapoid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN566"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><a href="../../include/catalog/pg_index.h.html#LN75"><span class='Ref_to_Const'>Anum_pg_index_indnatts</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/postgres.h.html#LN456"><span class='Ref_to_Macro'>Int16GetDatum</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN551"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN133"><span class='Ref_to_Member'>ii_NumIndexAttrs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN566"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><a href="../../include/catalog/pg_index.h.html#LN76"><span class='Ref_to_Const'>Anum_pg_index_indisunique</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/postgres.h.html#LN407"><span class='Ref_to_Macro'>BoolGetDatum</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN551"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN145"><span class='Ref_to_Member'>ii_Unique</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN566"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><a href="../../include/catalog/pg_index.h.html#LN77"><span class='Ref_to_Const'>Anum_pg_index_indisprimary</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/postgres.h.html#LN407"><span class='Ref_to_Macro'>BoolGetDatum</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN555"><span class='Ref_to_Parameter'>primary</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN566"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><a href="../../include/catalog/pg_index.h.html#LN78"><span class='Ref_to_Const'>Anum_pg_index_indisexclusion</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/postgres.h.html#LN407"><span class='Ref_to_Macro'>BoolGetDatum</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN556"><span class='Ref_to_Parameter'>isexclusion</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN566"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><a href="../../include/catalog/pg_index.h.html#LN79"><span class='Ref_to_Const'>Anum_pg_index_indimmediate</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/postgres.h.html#LN407"><span class='Ref_to_Macro'>BoolGetDatum</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN557"><span class='Ref_to_Parameter'>immediate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN566"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><a href="../../include/catalog/pg_index.h.html#LN80"><span class='Ref_to_Const'>Anum_pg_index_indisclustered</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/postgres.h.html#LN407"><span class='Ref_to_Macro'>BoolGetDatum</span></a><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN566"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><a href="../../include/catalog/pg_index.h.html#LN81"><span class='Ref_to_Const'>Anum_pg_index_indisvalid</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/postgres.h.html#LN407"><span class='Ref_to_Macro'>BoolGetDatum</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN558"><span class='Ref_to_Parameter'>isvalid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN566"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><a href="../../include/catalog/pg_index.h.html#LN82"><span class='Ref_to_Const'>Anum_pg_index_indcheckxmin</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/postgres.h.html#LN407"><span class='Ref_to_Macro'>BoolGetDatum</span></a><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* we set isvalid and isready the same way */ 
</span>    <a href="index.c.html#LN566"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><a href="../../include/catalog/pg_index.h.html#LN83"><span class='Ref_to_Const'>Anum_pg_index_indisready</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/postgres.h.html#LN407"><span class='Ref_to_Macro'>BoolGetDatum</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN558"><span class='Ref_to_Parameter'>isvalid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN566"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><a href="../../include/catalog/pg_index.h.html#LN84"><span class='Ref_to_Const'>Anum_pg_index_indislive</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/postgres.h.html#LN407"><span class='Ref_to_Macro'>BoolGetDatum</span></a><span class='Parentheses'>(</span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN566"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><a href="../../include/catalog/pg_index.h.html#LN85"><span class='Ref_to_Const'>Anum_pg_index_indisreplident</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/postgres.h.html#LN407"><span class='Ref_to_Macro'>BoolGetDatum</span></a><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN566"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><a href="../../include/catalog/pg_index.h.html#LN86"><span class='Ref_to_Const'>Anum_pg_index_indkey</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN560"><span class='Ref_To_Local'>indkey</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN566"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><a href="../../include/catalog/pg_index.h.html#LN87"><span class='Ref_to_Const'>Anum_pg_index_indcollation</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN561"><span class='Ref_To_Local'>indcollation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN566"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><a href="../../include/catalog/pg_index.h.html#LN88"><span class='Ref_to_Const'>Anum_pg_index_indclass</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN562"><span class='Ref_To_Local'>indclass</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN566"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><a href="../../include/catalog/pg_index.h.html#LN89"><span class='Ref_to_Const'>Anum_pg_index_indoption</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN563"><span class='Ref_To_Local'>indoption</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN566"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><a href="../../include/catalog/pg_index.h.html#LN90"><span class='Ref_to_Const'>Anum_pg_index_indexprs</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="index.c.html#LN564"><span class='Ref_To_Local'>exprsDatum</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN564"><span class='Ref_To_Local'>exprsDatum</span></a> <span class='Operator'>== </span><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <a href="index.c.html#LN567"><span class='Ref_To_Local'>nulls</span></a><span class='Delimiter'>[</span><a href="../../include/catalog/pg_index.h.html#LN90"><span class='Ref_to_Const'>Anum_pg_index_indexprs</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN566"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><a href="../../include/catalog/pg_index.h.html#LN91"><span class='Ref_to_Const'>Anum_pg_index_indpred</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="index.c.html#LN565"><span class='Ref_To_Local'>predDatum</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN565"><span class='Ref_To_Local'>predDatum</span></a> <span class='Operator'>== </span><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <a href="index.c.html#LN567"><span class='Ref_To_Local'>nulls</span></a><span class='Delimiter'>[</span><a href="../../include/catalog/pg_index.h.html#LN91"><span class='Ref_to_Const'>Anum_pg_index_indpred</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <a href="index.c.html#LN569"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>= </span><a href="../access/common/heaptuple.c.html#LN690"><span class='Ref_to_Func'>heap_form_tuple</span></a><span class='Parentheses'>(</span><a href="../../include/utils/rel.h.html#LN428"><span class='Ref_to_Macro'>RelationGetDescr</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN568"><span class='Ref_To_Local'>pg_index</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="index.c.html#LN566"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN567"><span class='Ref_To_Local'>nulls</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * insert the tuple into the pg_index catalog 
     */ 
</span>    <a href="../../include/catalog/indexing.h.html#LN32"><span class='Ref_to_Proto'>CatalogTupleInsert</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN568"><span class='Ref_To_Local'>pg_index</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN569"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * close the relation and free the tuple 
     */ 
</span>    <a href="../../include/access/heapam.h.html#LN96"><span class='Ref_to_Macro'>heap_close</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN568"><span class='Ref_To_Local'>pg_index</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN37"><span class='Ref_to_Const'>RowExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/access/htup_details.h.html#LN815"><span class='Ref_to_Proto'>heap_freetuple</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN569"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end UpdateIndexRelation &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * index_create 
 * 
 * heapRelation: table to build index on (suitably locked by caller) 
 * indexRelationName: what it say 
 * indexRelationId: normally, pass InvalidOid to let this routine 
 *      generate an OID for the index.  During bootstrap this may be 
 *      nonzero to specify a preselected OID. 
 * relFileNode: normally, pass InvalidOid to get new storage.  May be 
 *      nonzero to attach an existing valid build. 
 * indexInfo: same info executor uses to insert into the index 
 * indexColNames: column names to use for index (List of char *) 
 * accessMethodObjectId: OID of index AM to use 
 * tableSpaceId: OID of tablespace to use 
 * collationObjectId: array of collation OIDs, one per index column 
 * classObjectId: array of index opclass OIDs, one per index column 
 * coloptions: array of per-index-column indoption settings 
 * reloptions: AM-specific options 
 * isprimary: index is a PRIMARY KEY 
 * isconstraint: index is owned by PRIMARY KEY, UNIQUE, or EXCLUSION constraint 
 * deferrable: constraint is DEFERRABLE 
 * initdeferred: constraint is INITIALLY DEFERRED 
 * allow_system_table_mods: allow table to be a system catalog 
 * skip_build: true to skip the index_build() step for the moment; caller 
 *      must do it later (typically via reindex_index()) 
 * concurrent: if true, do not lock the table against writers.  The index 
 *      will be marked "invalid" and the caller must take additional steps 
 *      to fix it up. 
 * is_internal: if true, post creation hook for new index 
 * if_not_exists: if true, do not throw an error if a relation with 
 *      the same name already exists. 
 * 
 * Returns the OID of the created index. 
 */ 
</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> 
<a name="LN697"></a><span class='Declare_Function'>index_create</span><span class='Parentheses'>(</span><a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>heapRelation</span><span class='Delimiter'>, 
</span><a name="LN698"></a>             <span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>indexRelationName</span><span class='Delimiter'>, 
</span><a name="LN699"></a>             <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>indexRelationId</span><span class='Delimiter'>, 
</span><a name="LN700"></a>             <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>relFileNode</span><span class='Delimiter'>, 
</span><a name="LN701"></a>             <a href="../../include/nodes/execnodes.h.html#LN130"><span class='Ref_to_Struct'>IndexInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>indexInfo</span><span class='Delimiter'>, 
</span><a name="LN702"></a>             <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>indexColNames</span><span class='Delimiter'>, 
</span><a name="LN703"></a>             <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>accessMethodObjectId</span><span class='Delimiter'>, 
</span><a name="LN704"></a>             <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>tableSpaceId</span><span class='Delimiter'>, 
</span><a name="LN705"></a>             <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>collationObjectId</span><span class='Delimiter'>, 
</span><a name="LN706"></a>             <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>classObjectId</span><span class='Delimiter'>, 
</span><a name="LN707"></a>             <a href="../../include/c.h.html#LN254"><span class='Ref_to_Typedef'>int16</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>coloptions</span><span class='Delimiter'>, 
</span><a name="LN708"></a>             <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>reloptions</span><span class='Delimiter'>, 
</span><a name="LN709"></a>             <span class='Keyword'>bool </span><span class='Declare_Parameter'>isprimary</span><span class='Delimiter'>, 
</span><a name="LN710"></a>             <span class='Keyword'>bool </span><span class='Declare_Parameter'>isconstraint</span><span class='Delimiter'>, 
</span><a name="LN711"></a>             <span class='Keyword'>bool </span><span class='Declare_Parameter'>deferrable</span><span class='Delimiter'>, 
</span><a name="LN712"></a>             <span class='Keyword'>bool </span><span class='Declare_Parameter'>initdeferred</span><span class='Delimiter'>, 
</span><a name="LN713"></a>             <span class='Keyword'>bool </span><span class='Declare_Parameter'>allow_system_table_mods</span><span class='Delimiter'>, 
</span><a name="LN714"></a>             <span class='Keyword'>bool </span><span class='Declare_Parameter'>skip_build</span><span class='Delimiter'>, 
</span><a name="LN715"></a>             <span class='Keyword'>bool </span><span class='Declare_Parameter'>concurrent</span><span class='Delimiter'>, 
</span><a name="LN716"></a>             <span class='Keyword'>bool </span><span class='Declare_Parameter'>is_internal</span><span class='Delimiter'>, 
</span><a name="LN717"></a>             <span class='Keyword'>bool </span><span class='Declare_Parameter'>if_not_exists</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN719"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>heapRelationId</span> <span class='Operator'>= </span><a href="../../include/utils/rel.h.html#LN416"><span class='Ref_to_Macro'>RelationGetRelid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN697"><span class='Ref_to_Parameter'>heapRelation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN720"></a>    <a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>pg_class</span><span class='Delimiter'>; 
</span><a name="LN721"></a>    <a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>indexRelation</span><span class='Delimiter'>; 
</span><a name="LN722"></a>    <a href="../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a>   <span class='Declare_Local'>indexTupDesc</span><span class='Delimiter'>; 
</span><a name="LN723"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>shared_relation</span><span class='Delimiter'>; 
</span><a name="LN724"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>mapped_relation</span><span class='Delimiter'>; 
</span><a name="LN725"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>is_exclusion</span><span class='Delimiter'>; 
</span><a name="LN726"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>namespaceId</span><span class='Delimiter'>; 
</span><a name="LN727"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN728"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>relpersistence</span><span class='Delimiter'>; 
</span> 
    <a href="index.c.html#LN725"><span class='Ref_To_Local'>is_exclusion</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="index.c.html#LN701"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN139"><span class='Ref_to_Member'>ii_ExclusionOps</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="index.c.html#LN720"><span class='Ref_To_Local'>pg_class</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN91"><span class='Ref_to_Proto'>heap_open</span></a><span class='Parentheses'>(</span><a href="../../include/catalog/pg_class.h.html#LN28"><span class='Ref_to_Const'>RelationRelationId</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN37"><span class='Ref_to_Const'>RowExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * The index will be in the same namespace as its parent table, and is 
     * shared across databases if and only if the parent is.  Likewise, it 
     * will use the relfilenode map if and only if the parent does; and it 
     * inherits the parent's relpersistence. 
     */ 
</span>    <a href="index.c.html#LN726"><span class='Ref_To_Local'>namespaceId</span></a> <span class='Operator'>= </span><a href="../../include/utils/rel.h.html#LN443"><span class='Ref_to_Macro'>RelationGetNamespace</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN697"><span class='Ref_to_Parameter'>heapRelation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN723"><span class='Ref_To_Local'>shared_relation</span></a> <span class='Operator'>= </span><a href="index.c.html#LN697"><span class='Ref_to_Parameter'>heapRelation</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relisshared<span class='Delimiter'>; 
</span>    <a href="index.c.html#LN724"><span class='Ref_To_Local'>mapped_relation</span></a> <span class='Operator'>= </span><a href="../../include/utils/rel.h.html#LN453"><span class='Ref_to_Macro'>RelationIsMapped</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN697"><span class='Ref_to_Parameter'>heapRelation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN728"><span class='Ref_To_Local'>relpersistence</span></a> <span class='Operator'>= </span><a href="index.c.html#LN697"><span class='Ref_to_Parameter'>heapRelation</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relpersistence<span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * check parameters 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN701"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN133"><span class='Ref_to_Member'>ii_NumIndexAttrs</span></a> <span class='Operator'>&LT; </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"must index at least one column"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="index.c.html#LN713"><span class='Ref_to_Parameter'>allow_system_table_mods</span></a> <span class='Operator'>&& 
</span>        <a href="../../include/catalog/catalog.h.html#LN29"><span class='Ref_to_Proto'>IsSystemRelation</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN697"><span class='Ref_to_Parameter'>heapRelation</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>        <a href="../../include/miscadmin.h.html#LN371"><span class='Ref_to_Macro'>IsNormalProcessingMode</span></a><span class='Parentheses'>())</span> 
        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"user-defined indexes on system catalog tables are not supported"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * concurrent index build on a system catalog is unsafe because we tend to 
     * release locks before committing in catalogs 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN715"><span class='Ref_to_Parameter'>concurrent</span></a> <span class='Operator'>&& 
</span>        <a href="../../include/catalog/catalog.h.html#LN29"><span class='Ref_to_Proto'>IsSystemRelation</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN697"><span class='Ref_to_Parameter'>heapRelation</span></a><span class='Parentheses'>))</span> 
        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"concurrent index creation on system catalog tables is not supported"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * This case is currently not supported, but there's no way to ask for it 
     * in the grammar anyway, so it can't happen. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN715"><span class='Ref_to_Parameter'>concurrent</span></a> <span class='Operator'>&& </span><a href="index.c.html#LN725"><span class='Ref_To_Local'>is_exclusion</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN825"><span class='Ref_to_Func'>errmsg_internal</span></a><span class='Parentheses'>(</span><span class='String'>"concurrent index creation for exclusion constraints is not supported"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We cannot allow indexing a shared relation after initdb (because 
     * there's no way to make the entry in other databases' pg_class). 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN723"><span class='Ref_To_Local'>shared_relation</span></a> <span class='Operator'>&& !</span><a href="../../include/miscadmin.h.html#LN369"><span class='Ref_to_Macro'>IsBootstrapProcessingMode</span></a><span class='Parentheses'>())</span> 
        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"shared indexes cannot be created after initdb"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Shared relations must be in pg_global, too (last-ditch check) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN723"><span class='Ref_To_Local'>shared_relation</span></a> <span class='Operator'>&& </span><a href="index.c.html#LN704"><span class='Ref_to_Parameter'>tableSpaceId</span></a> <span class='Operator'>!= </span><a href="../../include/catalog/pg_tablespace.h.html#LN63"><span class='Ref_to_Const'>GLOBALTABLESPACE_OID</span></a><span class='Parentheses'>) 
</span>        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"shared relations must be placed in pg_global tablespace"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/utils/lsyscache.h.html#LN123"><span class='Ref_to_Proto'>get_relname_relid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN698"><span class='Ref_to_Parameter'>indexRelationName</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN726"><span class='Ref_To_Local'>namespaceId</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN717"><span class='Ref_to_Parameter'>if_not_exists</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN36"><span class='Ref_to_Const'>NOTICE</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_DUPLICATE_TABLE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"relation \"%s\" already exists, skipping"</span><span class='Delimiter'>, 
</span>                            <a href="index.c.html#LN698"><span class='Ref_to_Parameter'>indexRelationName</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <a href="../../include/access/heapam.h.html#LN96"><span class='Ref_to_Macro'>heap_close</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN720"><span class='Ref_To_Local'>pg_class</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN37"><span class='Ref_to_Const'>RowExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span> <a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_DUPLICATE_TABLE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"relation \"%s\" already exists"</span><span class='Delimiter'>, 
</span>                        <a href="index.c.html#LN698"><span class='Ref_to_Parameter'>indexRelationName</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * construct tuple descriptor for index tuples 
     */ 
</span>    <a href="index.c.html#LN722"><span class='Ref_To_Local'>indexTupDesc</span></a> <span class='Operator'>= </span><a href="index.c.html#LN90"><span class='Ref_to_Proto'>ConstructTupleDescriptor</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN697"><span class='Ref_to_Parameter'>heapRelation</span></a><span class='Delimiter'>, 
</span>                                            <a href="index.c.html#LN701"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Delimiter'>, 
</span>                                            <a href="index.c.html#LN702"><span class='Ref_to_Parameter'>indexColNames</span></a><span class='Delimiter'>, 
</span>                                            <a href="index.c.html#LN703"><span class='Ref_to_Parameter'>accessMethodObjectId</span></a><span class='Delimiter'>, 
</span>                                            <a href="index.c.html#LN705"><span class='Ref_to_Parameter'>collationObjectId</span></a><span class='Delimiter'>, 
</span>                                            <a href="index.c.html#LN706"><span class='Ref_to_Parameter'>classObjectId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Allocate an OID for the index, unless we were told what to use. 
     * 
     * The OID will be the relfilenode as well, so make sure it doesn't 
     * collide with either pg_class OIDs or existing physical files. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN699"><span class='Ref_to_Parameter'>indexRelationId</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Use binary-upgrade override for pg_class.oid/relfilenode? */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../utils/init/globals.c.html#LN101"><span class='Ref_to_Global_Var'>IsBinaryUpgrade</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN76"><span class='Ref_to_Global_Var'>binary_upgrade_next_index_pg_class_oid</span></a><span class='Parentheses'>))</span> 
                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_INVALID_PARAMETER_VALUE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"pg_class index OID value not set when in binary upgrade mode"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
            <a href="index.c.html#LN699"><span class='Ref_to_Parameter'>indexRelationId</span></a> <span class='Operator'>= </span><a href="index.c.html#LN76"><span class='Ref_to_Global_Var'>binary_upgrade_next_index_pg_class_oid</span></a><span class='Delimiter'>; 
</span>            <a href="index.c.html#LN76"><span class='Ref_to_Global_Var'>binary_upgrade_next_index_pg_class_oid</span></a> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <a href="index.c.html#LN699"><span class='Ref_to_Parameter'>indexRelationId</span></a> <span class='Operator'>= 
</span>                <a href="../../include/catalog/catalog.h.html#LN47"><span class='Ref_to_Proto'>GetNewRelFileNode</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN704"><span class='Ref_to_Parameter'>tableSpaceId</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN720"><span class='Ref_To_Local'>pg_class</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN728"><span class='Ref_To_Local'>relpersistence</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * create the index relation's relcache entry and physical disk file. (If 
     * we fail further down, it's the smgr's responsibility to remove the disk 
     * file again.) 
     */ 
</span>    <a href="index.c.html#LN721"><span class='Ref_To_Local'>indexRelation</span></a> <span class='Operator'>= </span><a href="../../include/catalog/heap.h.html#LN41"><span class='Ref_to_Proto'>heap_create</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN698"><span class='Ref_to_Parameter'>indexRelationName</span></a><span class='Delimiter'>, 
</span>                                <a href="index.c.html#LN726"><span class='Ref_To_Local'>namespaceId</span></a><span class='Delimiter'>, 
</span>                                <a href="index.c.html#LN704"><span class='Ref_to_Parameter'>tableSpaceId</span></a><span class='Delimiter'>, 
</span>                                <a href="index.c.html#LN699"><span class='Ref_to_Parameter'>indexRelationId</span></a><span class='Delimiter'>, 
</span>                                <a href="index.c.html#LN700"><span class='Ref_to_Parameter'>relFileNode</span></a><span class='Delimiter'>, 
</span>                                <a href="index.c.html#LN722"><span class='Ref_To_Local'>indexTupDesc</span></a><span class='Delimiter'>, 
</span>                                <a href="../../include/catalog/pg_class.h.html#LN160"><span class='Ref_to_Const'>RELKIND_INDEX</span></a><span class='Delimiter'>, 
</span>                                <a href="index.c.html#LN728"><span class='Ref_To_Local'>relpersistence</span></a><span class='Delimiter'>, 
</span>                                <a href="index.c.html#LN723"><span class='Ref_To_Local'>shared_relation</span></a><span class='Delimiter'>, 
</span>                                <a href="index.c.html#LN724"><span class='Ref_To_Local'>mapped_relation</span></a><span class='Delimiter'>, 
</span>                                <a href="index.c.html#LN713"><span class='Ref_to_Parameter'>allow_system_table_mods</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="index.c.html#LN699"><span class='Ref_to_Parameter'>indexRelationId</span></a> <span class='Operator'>== </span><a href="../../include/utils/rel.h.html#LN416"><span class='Ref_to_Macro'>RelationGetRelid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN721"><span class='Ref_To_Local'>indexRelation</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Obtain exclusive lock on it.  Although no other backends can see it 
     * until we commit, this prevents deadlock-risk complaints from lock 
     * manager in cases such as CLUSTER. 
     */ 
</span>    <a href="../../include/storage/lmgr.h.html#LN44"><span class='Ref_to_Proto'>LockRelation</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN721"><span class='Ref_To_Local'>indexRelation</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN45"><span class='Ref_to_Const'>AccessExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Fill in fields of the index's pg_class entry that are not set correctly 
     * by heap_create. 
     * 
     * XXX should have a cleaner way to create cataloged indexes 
     */ 
</span>    <a href="index.c.html#LN721"><span class='Ref_To_Local'>indexRelation</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relowner <span class='Operator'>= </span><a href="index.c.html#LN697"><span class='Ref_to_Parameter'>heapRelation</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relowner<span class='Delimiter'>; 
</span>    <a href="index.c.html#LN721"><span class='Ref_To_Local'>indexRelation</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relam <span class='Operator'>= </span><a href="index.c.html#LN703"><span class='Ref_to_Parameter'>accessMethodObjectId</span></a><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN721"><span class='Ref_To_Local'>indexRelation</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relhasoids <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * store index's pg_class entry 
     */ 
</span>    <a href="../../include/catalog/heap.h.html#LN91"><span class='Ref_to_Proto'>InsertPgClassTuple</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN720"><span class='Ref_To_Local'>pg_class</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN721"><span class='Ref_To_Local'>indexRelation</span></a><span class='Delimiter'>, 
</span>                       <a href="../../include/utils/rel.h.html#LN416"><span class='Ref_to_Macro'>RelationGetRelid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN721"><span class='Ref_To_Local'>indexRelation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                       <span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Delimiter'>, 
</span>                       <a href="index.c.html#LN708"><span class='Ref_to_Parameter'>reloptions</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* done with pg_class */ 
</span>    <a href="../../include/access/heapam.h.html#LN96"><span class='Ref_to_Macro'>heap_close</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN720"><span class='Ref_To_Local'>pg_class</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN37"><span class='Ref_to_Const'>RowExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * now update the object id's of all the attribute tuple forms in the 
     * index relation's tuple descriptor 
     */ 
</span>    <a href="index.c.html#LN96"><span class='Ref_to_Proto'>InitializeAttributeOids</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN721"><span class='Ref_To_Local'>indexRelation</span></a><span class='Delimiter'>, 
</span>                            <a href="index.c.html#LN701"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN133"><span class='Ref_to_Member'>ii_NumIndexAttrs</span></a><span class='Delimiter'>, 
</span>                            <a href="index.c.html#LN699"><span class='Ref_to_Parameter'>indexRelationId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * append ATTRIBUTE tuples for the index 
     */ 
</span>    <a href="index.c.html#LN98"><span class='Ref_to_Proto'>AppendAttributeTuples</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN721"><span class='Ref_To_Local'>indexRelation</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN701"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN133"><span class='Ref_to_Member'>ii_NumIndexAttrs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* ---------------- 
     *    update pg_index 
     *    (append INDEX tuple) 
     * 
     *    Note that this stows away a representation of "predicate". 
     *    (Or, could define a rule to maintain the predicate) --Nels, Feb '92 
     * ---------------- 
     */ 
</span>    <a href="index.c.html#LN99"><span class='Ref_to_Proto'>UpdateIndexRelation</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN699"><span class='Ref_to_Parameter'>indexRelationId</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN719"><span class='Ref_To_Local'>heapRelationId</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN701"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Delimiter'>, 
</span>                        <a href="index.c.html#LN705"><span class='Ref_to_Parameter'>collationObjectId</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN706"><span class='Ref_to_Parameter'>classObjectId</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN707"><span class='Ref_to_Parameter'>coloptions</span></a><span class='Delimiter'>, 
</span>                        <a href="index.c.html#LN709"><span class='Ref_to_Parameter'>isprimary</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN725"><span class='Ref_To_Local'>is_exclusion</span></a><span class='Delimiter'>, 
</span>                        <span class='Operator'>!</span><a href="index.c.html#LN711"><span class='Ref_to_Parameter'>deferrable</span></a><span class='Delimiter'>, 
</span>                        <span class='Operator'>!</span><a href="index.c.html#LN715"><span class='Ref_to_Parameter'>concurrent</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Register constraint and dependencies for the index. 
     * 
     * If the index is from a CONSTRAINT clause, construct a pg_constraint 
     * entry.  The index will be linked to the constraint, which in turn is 
     * linked to the table.  If it's not a CONSTRAINT, we need to make a 
     * dependency directly on the table. 
     * 
     * We don't need a dependency on the namespace, because there'll be an 
     * indirect dependency via our parent table. 
     * 
     * During bootstrap we can't register any dependencies, and we don't try 
     * to make a constraint either. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/miscadmin.h.html#LN369"><span class='Ref_to_Macro'>IsBootstrapProcessingMode</span></a><span class='Parentheses'>())</span> 
    <span class='Delimiter'>{ 
</span><a name="LN936"></a>        <a href="../../include/catalog/objectaddress.h.html#LN23"><span class='Ref_to_Struct'>ObjectAddress</span></a> <span class='Declare_Local'>myself</span><span class='Delimiter'>, 
</span><a name="LN937"></a>                    <span class='Declare_Local'>referenced</span><span class='Delimiter'>; 
</span> 
        <a href="index.c.html#LN936"><span class='Ref_To_Local'>myself</span></a><span class='Operator'>.</span><a href="../../include/catalog/objectaddress.h.html#LN25"><span class='Ref_to_Member'>classId</span></a> <span class='Operator'>= </span><a href="../../include/catalog/pg_class.h.html#LN28"><span class='Ref_to_Const'>RelationRelationId</span></a><span class='Delimiter'>; 
</span>        <a href="index.c.html#LN936"><span class='Ref_To_Local'>myself</span></a><span class='Operator'>.</span><a href="../../include/catalog/objectaddress.h.html#LN26"><span class='Ref_to_Member'>objectId</span></a> <span class='Operator'>= </span><a href="index.c.html#LN699"><span class='Ref_to_Parameter'>indexRelationId</span></a><span class='Delimiter'>; 
</span>        <a href="index.c.html#LN936"><span class='Ref_To_Local'>myself</span></a><span class='Operator'>.</span><a href="../../include/catalog/objectaddress.h.html#LN27"><span class='Ref_to_Member'>objectSubId</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN710"><span class='Ref_to_Parameter'>isconstraint</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN945"></a>            <span class='Keyword'>char</span>        <span class='Declare_Local'>constraintType</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN709"><span class='Ref_to_Parameter'>isprimary</span></a><span class='Parentheses'>) 
</span>                <a href="index.c.html#LN945"><span class='Ref_To_Local'>constraintType</span></a> <span class='Operator'>= </span><a href="../../include/catalog/pg_constraint.h.html#LN189"><span class='Ref_to_Const'>CONSTRAINT_PRIMARY</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN701"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN145"><span class='Ref_to_Member'>ii_Unique</span></a><span class='Parentheses'>) 
</span>                <a href="index.c.html#LN945"><span class='Ref_To_Local'>constraintType</span></a> <span class='Operator'>= </span><a href="../../include/catalog/pg_constraint.h.html#LN190"><span class='Ref_to_Const'>CONSTRAINT_UNIQUE</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN725"><span class='Ref_To_Local'>is_exclusion</span></a><span class='Parentheses'>) 
</span>                <a href="index.c.html#LN945"><span class='Ref_To_Local'>constraintType</span></a> <span class='Operator'>= </span><a href="../../include/catalog/pg_constraint.h.html#LN192"><span class='Ref_to_Const'>CONSTRAINT_EXCLUSION</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"constraint must be PRIMARY, UNIQUE or EXCLUDE"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="index.c.html#LN945"><span class='Ref_To_Local'>constraintType</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* keep compiler quiet */ 
</span>            <span class='Delimiter'>} 
</span> 
            <a href="../../include/catalog/index.h.html#LN66"><span class='Ref_to_Proto'>index_constraint_create</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN697"><span class='Ref_to_Parameter'>heapRelation</span></a><span class='Delimiter'>, 
</span>                                    <a href="index.c.html#LN699"><span class='Ref_to_Parameter'>indexRelationId</span></a><span class='Delimiter'>, 
</span>                                    <a href="index.c.html#LN701"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Delimiter'>, 
</span>                                    <a href="index.c.html#LN698"><span class='Ref_to_Parameter'>indexRelationName</span></a><span class='Delimiter'>, 
</span>                                    <a href="index.c.html#LN945"><span class='Ref_To_Local'>constraintType</span></a><span class='Delimiter'>, 
</span>                                    <a href="index.c.html#LN711"><span class='Ref_to_Parameter'>deferrable</span></a><span class='Delimiter'>, 
</span>                                    <a href="index.c.html#LN712"><span class='Ref_to_Parameter'>initdeferred</span></a><span class='Delimiter'>, 
</span>                                    <span class='Boolean'>false</span><span class='Delimiter'>,</span>      <span class='Comment_Single_Line'>/* already marked primary */ 
</span>                                    <span class='Boolean'>false</span><span class='Delimiter'>,</span>      <span class='Comment_Single_Line'>/* pg_index entry is OK */ 
</span>                                    <span class='Boolean'>false</span><span class='Delimiter'>,</span>      <span class='Comment_Single_Line'>/* no old dependencies */ 
</span>                                    <a href="index.c.html#LN713"><span class='Ref_to_Parameter'>allow_system_table_mods</span></a><span class='Delimiter'>, 
</span>                                    <a href="index.c.html#LN716"><span class='Ref_to_Parameter'>is_internal</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if isconstraint &raquo; </span> 
        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span><a name="LN974"></a>            <span class='Keyword'>bool</span>        <span class='Declare_Local'>have_simple_col</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Create auto dependencies on simply-referenced columns */ 
</span>            <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="index.c.html#LN727"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="index.c.html#LN727"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="index.c.html#LN701"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN133"><span class='Ref_to_Member'>ii_NumIndexAttrs</span></a><span class='Delimiter'>; </span><a href="index.c.html#LN727"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN701"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN134"><span class='Ref_to_Member'>ii_KeyAttrNumbers</span></a><span class='Delimiter'>[</span><a href="index.c.html#LN727"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <a href="index.c.html#LN937"><span class='Ref_To_Local'>referenced</span></a><span class='Operator'>.</span><a href="../../include/catalog/objectaddress.h.html#LN25"><span class='Ref_to_Member'>classId</span></a> <span class='Operator'>= </span><a href="../../include/catalog/pg_class.h.html#LN28"><span class='Ref_to_Const'>RelationRelationId</span></a><span class='Delimiter'>; 
</span>                    <a href="index.c.html#LN937"><span class='Ref_To_Local'>referenced</span></a><span class='Operator'>.</span><a href="../../include/catalog/objectaddress.h.html#LN26"><span class='Ref_to_Member'>objectId</span></a> <span class='Operator'>= </span><a href="index.c.html#LN719"><span class='Ref_To_Local'>heapRelationId</span></a><span class='Delimiter'>; 
</span>                    <a href="index.c.html#LN937"><span class='Ref_To_Local'>referenced</span></a><span class='Operator'>.</span><a href="../../include/catalog/objectaddress.h.html#LN27"><span class='Ref_to_Member'>objectSubId</span></a> <span class='Operator'>= </span><a href="index.c.html#LN701"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN134"><span class='Ref_to_Member'>ii_KeyAttrNumbers</span></a><span class='Delimiter'>[</span><a href="index.c.html#LN727"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
                    <a href="pg_depend.c.html#LN42"><span class='Ref_to_Func'>recordDependencyOn</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="index.c.html#LN936"><span class='Ref_To_Local'>myself</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="index.c.html#LN937"><span class='Ref_To_Local'>referenced</span></a><span class='Delimiter'>, </span><a href="../../include/catalog/dependency.h.html#LN75"><span class='Ref_to_EnumConst'>DEPENDENCY_AUTO</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                    <a href="index.c.html#LN974"><span class='Ref_To_Local'>have_simple_col</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * If there are no simply-referenced columns, give the index an 
             * auto dependency on the whole table.  In most cases, this will 
             * be redundant, but it might not be if the index expressions and 
             * predicate contain no Vars or only whole-row Vars. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="index.c.html#LN974"><span class='Ref_To_Local'>have_simple_col</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="index.c.html#LN937"><span class='Ref_To_Local'>referenced</span></a><span class='Operator'>.</span><a href="../../include/catalog/objectaddress.h.html#LN25"><span class='Ref_to_Member'>classId</span></a> <span class='Operator'>= </span><a href="../../include/catalog/pg_class.h.html#LN28"><span class='Ref_to_Const'>RelationRelationId</span></a><span class='Delimiter'>; 
</span>                <a href="index.c.html#LN937"><span class='Ref_To_Local'>referenced</span></a><span class='Operator'>.</span><a href="../../include/catalog/objectaddress.h.html#LN26"><span class='Ref_to_Member'>objectId</span></a> <span class='Operator'>= </span><a href="index.c.html#LN719"><span class='Ref_To_Local'>heapRelationId</span></a><span class='Delimiter'>; 
</span>                <a href="index.c.html#LN937"><span class='Ref_To_Local'>referenced</span></a><span class='Operator'>.</span><a href="../../include/catalog/objectaddress.h.html#LN27"><span class='Ref_to_Member'>objectSubId</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
                <a href="pg_depend.c.html#LN42"><span class='Ref_to_Func'>recordDependencyOn</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="index.c.html#LN936"><span class='Ref_To_Local'>myself</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="index.c.html#LN937"><span class='Ref_To_Local'>referenced</span></a><span class='Delimiter'>, </span><a href="../../include/catalog/dependency.h.html#LN75"><span class='Ref_to_EnumConst'>DEPENDENCY_AUTO</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* Non-constraint indexes can't be deferrable */ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="index.c.html#LN711"><span class='Ref_to_Parameter'>deferrable</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="index.c.html#LN712"><span class='Ref_to_Parameter'>initdeferred</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* Store dependency on collations */ 
</span>        <span class='Comment_Multi_Line'>/* The default collation is pinned, so don't bother recording it */ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="index.c.html#LN727"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="index.c.html#LN727"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="index.c.html#LN701"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN133"><span class='Ref_to_Member'>ii_NumIndexAttrs</span></a><span class='Delimiter'>; </span><a href="index.c.html#LN727"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN705"><span class='Ref_to_Parameter'>collationObjectId</span></a><span class='Delimiter'>[</span><a href="index.c.html#LN727"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                <a href="index.c.html#LN705"><span class='Ref_to_Parameter'>collationObjectId</span></a><span class='Delimiter'>[</span><a href="index.c.html#LN727"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>!= </span><a href="../../include/catalog/pg_collation.h.html#LN74"><span class='Ref_to_Const'>DEFAULT_COLLATION_OID</span></a><span class='Parentheses'>)</span> 
            <span class='Delimiter'>{ 
</span>                <a href="index.c.html#LN937"><span class='Ref_To_Local'>referenced</span></a><span class='Operator'>.</span><a href="../../include/catalog/objectaddress.h.html#LN25"><span class='Ref_to_Member'>classId</span></a> <span class='Operator'>= </span><a href="../../include/catalog/pg_collation.h.html#LN29"><span class='Ref_to_Const'>CollationRelationId</span></a><span class='Delimiter'>; 
</span>                <a href="index.c.html#LN937"><span class='Ref_To_Local'>referenced</span></a><span class='Operator'>.</span><a href="../../include/catalog/objectaddress.h.html#LN26"><span class='Ref_to_Member'>objectId</span></a> <span class='Operator'>= </span><a href="index.c.html#LN705"><span class='Ref_to_Parameter'>collationObjectId</span></a><span class='Delimiter'>[</span><a href="index.c.html#LN727"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>                <a href="index.c.html#LN937"><span class='Ref_To_Local'>referenced</span></a><span class='Operator'>.</span><a href="../../include/catalog/objectaddress.h.html#LN27"><span class='Ref_to_Member'>objectSubId</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
                <a href="pg_depend.c.html#LN42"><span class='Ref_to_Func'>recordDependencyOn</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="index.c.html#LN936"><span class='Ref_To_Local'>myself</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="index.c.html#LN937"><span class='Ref_To_Local'>referenced</span></a><span class='Delimiter'>, </span><a href="../../include/catalog/dependency.h.html#LN74"><span class='Ref_to_EnumConst'>DEPENDENCY_NORMAL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* Store dependency on operator classes */ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="index.c.html#LN727"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="index.c.html#LN727"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="index.c.html#LN701"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN133"><span class='Ref_to_Member'>ii_NumIndexAttrs</span></a><span class='Delimiter'>; </span><a href="index.c.html#LN727"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="index.c.html#LN937"><span class='Ref_To_Local'>referenced</span></a><span class='Operator'>.</span><a href="../../include/catalog/objectaddress.h.html#LN25"><span class='Ref_to_Member'>classId</span></a> <span class='Operator'>= </span><a href="../../include/catalog/pg_opclass.h.html#LN48"><span class='Ref_to_Const'>OperatorClassRelationId</span></a><span class='Delimiter'>; 
</span>            <a href="index.c.html#LN937"><span class='Ref_To_Local'>referenced</span></a><span class='Operator'>.</span><a href="../../include/catalog/objectaddress.h.html#LN26"><span class='Ref_to_Member'>objectId</span></a> <span class='Operator'>= </span><a href="index.c.html#LN706"><span class='Ref_to_Parameter'>classObjectId</span></a><span class='Delimiter'>[</span><a href="index.c.html#LN727"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>            <a href="index.c.html#LN937"><span class='Ref_To_Local'>referenced</span></a><span class='Operator'>.</span><a href="../../include/catalog/objectaddress.h.html#LN27"><span class='Ref_to_Member'>objectSubId</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
            <a href="pg_depend.c.html#LN42"><span class='Ref_to_Func'>recordDependencyOn</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="index.c.html#LN936"><span class='Ref_To_Local'>myself</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="index.c.html#LN937"><span class='Ref_To_Local'>referenced</span></a><span class='Delimiter'>, </span><a href="../../include/catalog/dependency.h.html#LN74"><span class='Ref_to_EnumConst'>DEPENDENCY_NORMAL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* Store dependencies on anything mentioned in index expressions */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN701"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN135"><span class='Ref_to_Member'>ii_Expressions</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../include/catalog/dependency.h.html#LN192"><span class='Ref_to_Proto'>recordDependencyOnSingleRelExpr</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="index.c.html#LN936"><span class='Ref_To_Local'>myself</span></a><span class='Delimiter'>, 
</span>                                          <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="index.c.html#LN701"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN135"><span class='Ref_to_Member'>ii_Expressions</span></a><span class='Delimiter'>, 
</span>                                            <a href="index.c.html#LN719"><span class='Ref_To_Local'>heapRelationId</span></a><span class='Delimiter'>, 
</span>                                            <a href="../../include/catalog/dependency.h.html#LN74"><span class='Ref_to_EnumConst'>DEPENDENCY_NORMAL</span></a><span class='Delimiter'>, 
</span>                                            <a href="../../include/catalog/dependency.h.html#LN75"><span class='Ref_to_EnumConst'>DEPENDENCY_AUTO</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* Store dependencies on anything mentioned in predicate */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN701"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN137"><span class='Ref_to_Member'>ii_Predicate</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../include/catalog/dependency.h.html#LN192"><span class='Ref_to_Proto'>recordDependencyOnSingleRelExpr</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="index.c.html#LN936"><span class='Ref_To_Local'>myself</span></a><span class='Delimiter'>, 
</span>                                            <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="index.c.html#LN701"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN137"><span class='Ref_to_Member'>ii_Predicate</span></a><span class='Delimiter'>, 
</span>                                            <a href="index.c.html#LN719"><span class='Ref_To_Local'>heapRelationId</span></a><span class='Delimiter'>, 
</span>                                            <a href="../../include/catalog/dependency.h.html#LN74"><span class='Ref_to_EnumConst'>DEPENDENCY_NORMAL</span></a><span class='Delimiter'>, 
</span>                                            <a href="../../include/catalog/dependency.h.html#LN75"><span class='Ref_to_EnumConst'>DEPENDENCY_AUTO</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !IsBootstrapProcessin... &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Bootstrap mode - assert we weren't asked for constraint support */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="index.c.html#LN710"><span class='Ref_to_Parameter'>isconstraint</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="index.c.html#LN711"><span class='Ref_to_Parameter'>deferrable</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="index.c.html#LN712"><span class='Ref_to_Parameter'>initdeferred</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Post creation hook for new index */ 
</span>    <a href="../../include/catalog/objectaccess.h.html#LN146"><span class='Ref_to_Macro'>InvokeObjectPostCreateHookArg</span></a><span class='Parentheses'>(</span><a href="../../include/catalog/pg_class.h.html#LN28"><span class='Ref_to_Const'>RelationRelationId</span></a><span class='Delimiter'>, 
</span>                                  <a href="index.c.html#LN699"><span class='Ref_to_Parameter'>indexRelationId</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><a href="index.c.html#LN716"><span class='Ref_to_Parameter'>is_internal</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Advance the command counter so that we can see the newly-entered 
     * catalog tuples for the index. 
     */ 
</span>    <a href="../../include/access/xact.h.html#LN346"><span class='Ref_to_Proto'>CommandCounterIncrement</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * In bootstrap mode, we have to fill in the index strategy structure with 
     * information from the catalogs.  If we aren't bootstrapping, then the 
     * relcache entry has already been rebuilt thanks to sinval update during 
     * CommandCounterIncrement. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/miscadmin.h.html#LN369"><span class='Ref_to_Macro'>IsBootstrapProcessingMode</span></a><span class='Parentheses'>())</span> 
        <a href="../../include/utils/relcache.h.html#LN67"><span class='Ref_to_Proto'>RelationInitIndexAccessInfo</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN721"><span class='Ref_To_Local'>indexRelation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="index.c.html#LN721"><span class='Ref_To_Local'>indexRelation</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN178"><span class='Ref_to_Member'>rd_indexcxt</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If this is bootstrap (initdb) time, then we don't actually fill in the 
     * index yet.  We'll be creating more indexes and classes later, so we 
     * delay filling them in until just before we're done with bootstrapping. 
     * Similarly, if the caller specified skip_build then filling the index is 
     * delayed till later (ALTER TABLE can save work in some cases with this). 
     * Otherwise, we call the AM routine that constructs the index. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/miscadmin.h.html#LN369"><span class='Ref_to_Macro'>IsBootstrapProcessingMode</span></a><span class='Parentheses'>())</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../include/bootstrap/bootstrap.h.html#LN48"><span class='Ref_to_Proto'>index_register</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN719"><span class='Ref_To_Local'>heapRelationId</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN699"><span class='Ref_to_Parameter'>indexRelationId</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN701"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN714"><span class='Ref_to_Parameter'>skip_build</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Caller is responsible for filling the index later on.  However, 
         * we'd better make sure that the heap relation is correctly marked as 
         * having an index. 
         */ 
</span>        <a href="index.c.html#LN108"><span class='Ref_to_Proto'>index_update_stats</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN697"><span class='Ref_to_Parameter'>heapRelation</span></a><span class='Delimiter'>, 
</span>                           <span class='Boolean'>true</span><span class='Delimiter'>, 
</span>                           <a href="index.c.html#LN709"><span class='Ref_to_Parameter'>isprimary</span></a><span class='Delimiter'>, 
</span>                           <span class='Operator'>-</span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* Make the above update visible */ 
</span>        <a href="../../include/access/xact.h.html#LN346"><span class='Ref_to_Proto'>CommandCounterIncrement</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../include/catalog/index.h.html#LN91"><span class='Ref_to_Proto'>index_build</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN697"><span class='Ref_to_Parameter'>heapRelation</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN721"><span class='Ref_To_Local'>indexRelation</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN701"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN709"><span class='Ref_to_Parameter'>isprimary</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Close the index; but we keep the lock that we acquired above until end 
     * of transaction.  Closing the heap is caller's responsibility. 
     */ 
</span>    <a href="../../include/access/genam.h.html#LN130"><span class='Ref_to_Proto'>index_close</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN721"><span class='Ref_To_Local'>indexRelation</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN33"><span class='Ref_to_Const'>NoLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="index.c.html#LN699"><span class='Ref_to_Parameter'>indexRelationId</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end index_create &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * index_constraint_create 
 * 
 * Set up a constraint associated with an index.  Return the new constraint's 
 * address. 
 * 
 * heapRelation: table owning the index (must be suitably locked by caller) 
 * indexRelationId: OID of the index 
 * indexInfo: same info executor uses to insert into the index 
 * constraintName: what it say (generally, should match name of index) 
 * constraintType: one of CONSTRAINT_PRIMARY, CONSTRAINT_UNIQUE, or 
 *      CONSTRAINT_EXCLUSION 
 * deferrable: constraint is DEFERRABLE 
 * initdeferred: constraint is INITIALLY DEFERRED 
 * mark_as_primary: if true, set flags to mark index as primary key 
 * update_pgindex: if true, update pg_index row (else caller's done that) 
 * remove_old_dependencies: if true, remove existing dependencies of index 
 *      on table's columns 
 * allow_system_table_mods: allow table to be a system catalog 
 * is_internal: index is constructed due to internal process 
 */ 
</span><a href="../../include/catalog/objectaddress.h.html#LN23"><span class='Ref_to_Struct'>ObjectAddress</span></a> 
<a name="LN1147"></a><span class='Declare_Function'>index_constraint_create</span><span class='Parentheses'>(</span><a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>heapRelation</span><span class='Delimiter'>, 
</span><a name="LN1148"></a>                        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>indexRelationId</span><span class='Delimiter'>, 
</span><a name="LN1149"></a>                        <a href="../../include/nodes/execnodes.h.html#LN130"><span class='Ref_to_Struct'>IndexInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>indexInfo</span><span class='Delimiter'>, 
</span><a name="LN1150"></a>                        <span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>constraintName</span><span class='Delimiter'>, 
</span><a name="LN1151"></a>                        <span class='Keyword'>char </span><span class='Declare_Parameter'>constraintType</span><span class='Delimiter'>, 
</span><a name="LN1152"></a>                        <span class='Keyword'>bool </span><span class='Declare_Parameter'>deferrable</span><span class='Delimiter'>, 
</span><a name="LN1153"></a>                        <span class='Keyword'>bool </span><span class='Declare_Parameter'>initdeferred</span><span class='Delimiter'>, 
</span><a name="LN1154"></a>                        <span class='Keyword'>bool </span><span class='Declare_Parameter'>mark_as_primary</span><span class='Delimiter'>, 
</span><a name="LN1155"></a>                        <span class='Keyword'>bool </span><span class='Declare_Parameter'>update_pgindex</span><span class='Delimiter'>, 
</span><a name="LN1156"></a>                        <span class='Keyword'>bool </span><span class='Declare_Parameter'>remove_old_dependencies</span><span class='Delimiter'>, 
</span><a name="LN1157"></a>                        <span class='Keyword'>bool </span><span class='Declare_Parameter'>allow_system_table_mods</span><span class='Delimiter'>, 
</span><a name="LN1158"></a>                        <span class='Keyword'>bool </span><span class='Declare_Parameter'>is_internal</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1160"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>namespaceId</span> <span class='Operator'>= </span><a href="../../include/utils/rel.h.html#LN443"><span class='Ref_to_Macro'>RelationGetNamespace</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1147"><span class='Ref_to_Parameter'>heapRelation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1161"></a>    <a href="../../include/catalog/objectaddress.h.html#LN23"><span class='Ref_to_Struct'>ObjectAddress</span></a> <span class='Declare_Local'>myself</span><span class='Delimiter'>, 
</span><a name="LN1162"></a>                <span class='Declare_Local'>referenced</span><span class='Delimiter'>; 
</span><a name="LN1163"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>conOid</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* constraint creation support doesn't work while bootstrapping */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/miscadmin.h.html#LN369"><span class='Ref_to_Macro'>IsBootstrapProcessingMode</span></a><span class='Parentheses'>())</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* enforce system-table restriction */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="index.c.html#LN1157"><span class='Ref_to_Parameter'>allow_system_table_mods</span></a> <span class='Operator'>&& 
</span>        <a href="../../include/catalog/catalog.h.html#LN29"><span class='Ref_to_Proto'>IsSystemRelation</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1147"><span class='Ref_to_Parameter'>heapRelation</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>        <a href="../../include/miscadmin.h.html#LN371"><span class='Ref_to_Macro'>IsNormalProcessingMode</span></a><span class='Parentheses'>())</span> 
        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"user-defined indexes on system catalog tables are not supported"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* primary/unique constraints shouldn't have any expressions */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN1149"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN135"><span class='Ref_to_Member'>ii_Expressions</span></a> <span class='Operator'>&& 
</span>        <a href="index.c.html#LN1151"><span class='Ref_to_Parameter'>constraintType</span></a> <span class='Operator'>!= </span><a href="../../include/catalog/pg_constraint.h.html#LN192"><span class='Ref_to_Const'>CONSTRAINT_EXCLUSION</span></a><span class='Parentheses'>) 
</span>        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"constraints cannot have index expressions"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we're manufacturing a constraint for a pre-existing index, we need 
     * to get rid of the existing auto dependencies for the index (the ones 
     * that index_create() would have made instead of calling this function). 
     * 
     * Note: this code would not necessarily do the right thing if the index 
     * has any expressions or predicate, but we'd never be turning such an 
     * index into a UNIQUE or PRIMARY KEY constraint. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN1156"><span class='Ref_to_Parameter'>remove_old_dependencies</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/catalog/dependency.h.html#LN231"><span class='Ref_to_Proto'>deleteDependencyRecordsForClass</span></a><span class='Parentheses'>(</span><a href="../../include/catalog/pg_class.h.html#LN28"><span class='Ref_to_Const'>RelationRelationId</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN1148"><span class='Ref_to_Parameter'>indexRelationId</span></a><span class='Delimiter'>, 
</span>                                        <a href="../../include/catalog/pg_class.h.html#LN28"><span class='Ref_to_Const'>RelationRelationId</span></a><span class='Delimiter'>, </span><a href="../../include/catalog/dependency.h.html#LN75"><span class='Ref_to_EnumConst'>DEPENDENCY_AUTO</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Construct a pg_constraint entry. 
     */ 
</span>    <a href="index.c.html#LN1163"><span class='Ref_To_Local'>conOid</span></a> <span class='Operator'>= </span><a href="../../include/catalog/pg_constraint_fn.h.html#LN29"><span class='Ref_to_Proto'>CreateConstraintEntry</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1150"><span class='Ref_to_Parameter'>constraintName</span></a><span class='Delimiter'>, 
</span>                                   <a href="index.c.html#LN1160"><span class='Ref_To_Local'>namespaceId</span></a><span class='Delimiter'>, 
</span>                                   <a href="index.c.html#LN1151"><span class='Ref_to_Parameter'>constraintType</span></a><span class='Delimiter'>, 
</span>                                   <a href="index.c.html#LN1152"><span class='Ref_to_Parameter'>deferrable</span></a><span class='Delimiter'>, 
</span>                                   <a href="index.c.html#LN1153"><span class='Ref_to_Parameter'>initdeferred</span></a><span class='Delimiter'>, 
</span>                                   <span class='Boolean'>true</span><span class='Delimiter'>, 
</span>                                   <a href="../../include/utils/rel.h.html#LN416"><span class='Ref_to_Macro'>RelationGetRelid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1147"><span class='Ref_to_Parameter'>heapRelation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                   <a href="index.c.html#LN1149"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN134"><span class='Ref_to_Member'>ii_KeyAttrNumbers</span></a><span class='Delimiter'>, 
</span>                                   <a href="index.c.html#LN1149"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN133"><span class='Ref_to_Member'>ii_NumIndexAttrs</span></a><span class='Delimiter'>, 
</span>                                   <a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>,</span>  <span class='Comment_Single_Line'>/* no domain */ 
</span>                                   <a href="index.c.html#LN1148"><span class='Ref_to_Parameter'>indexRelationId</span></a><span class='Delimiter'>,</span>     <span class='Comment_Single_Line'>/* index OID */ 
</span>                                   <a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>,</span>  <span class='Comment_Single_Line'>/* no foreign key */ 
</span>                                   <span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                                   <span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                                   <span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                                   <span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                                   <span class='Number'>0</span><span class='Delimiter'>, 
</span>                                   <span class='String'>' '</span><span class='Delimiter'>, 
</span>                                   <span class='String'>' '</span><span class='Delimiter'>, 
</span>                                   <span class='String'>' '</span><span class='Delimiter'>, 
</span>                                   <a href="index.c.html#LN1149"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN139"><span class='Ref_to_Member'>ii_ExclusionOps</span></a><span class='Delimiter'>, 
</span>                                   <span class='Null_Value'>NULL</span><span class='Delimiter'>,</span>        <span class='Comment_Single_Line'>/* no check constraint */ 
</span>                                   <span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                                   <span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                                   <span class='Boolean'>true</span><span class='Delimiter'>,</span>        <span class='Comment_Single_Line'>/* islocal */ 
</span>                                   <span class='Number'>0</span><span class='Delimiter'>,</span>   <span class='Comment_Single_Line'>/* inhcount */ 
</span>                                   <span class='Boolean'>true</span><span class='Delimiter'>,</span>        <span class='Comment_Single_Line'>/* noinherit */ 
</span>                                   <a href="index.c.html#LN1158"><span class='Ref_to_Parameter'>is_internal</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Register the index as internally dependent on the constraint. 
     * 
     * Note that the constraint has a dependency on the table, so we don't 
     * need (or want) any direct dependency from the index to the table. 
     */ 
</span>    <a href="index.c.html#LN1161"><span class='Ref_To_Local'>myself</span></a><span class='Operator'>.</span><a href="../../include/catalog/objectaddress.h.html#LN25"><span class='Ref_to_Member'>classId</span></a> <span class='Operator'>= </span><a href="../../include/catalog/pg_class.h.html#LN28"><span class='Ref_to_Const'>RelationRelationId</span></a><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN1161"><span class='Ref_To_Local'>myself</span></a><span class='Operator'>.</span><a href="../../include/catalog/objectaddress.h.html#LN26"><span class='Ref_to_Member'>objectId</span></a> <span class='Operator'>= </span><a href="index.c.html#LN1148"><span class='Ref_to_Parameter'>indexRelationId</span></a><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN1161"><span class='Ref_To_Local'>myself</span></a><span class='Operator'>.</span><a href="../../include/catalog/objectaddress.h.html#LN27"><span class='Ref_to_Member'>objectSubId</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <a href="index.c.html#LN1162"><span class='Ref_To_Local'>referenced</span></a><span class='Operator'>.</span><a href="../../include/catalog/objectaddress.h.html#LN25"><span class='Ref_to_Member'>classId</span></a> <span class='Operator'>= </span><a href="../../include/catalog/pg_constraint.h.html#LN28"><span class='Ref_to_Const'>ConstraintRelationId</span></a><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN1162"><span class='Ref_To_Local'>referenced</span></a><span class='Operator'>.</span><a href="../../include/catalog/objectaddress.h.html#LN26"><span class='Ref_to_Member'>objectId</span></a> <span class='Operator'>= </span><a href="index.c.html#LN1163"><span class='Ref_To_Local'>conOid</span></a><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN1162"><span class='Ref_To_Local'>referenced</span></a><span class='Operator'>.</span><a href="../../include/catalog/objectaddress.h.html#LN27"><span class='Ref_to_Member'>objectSubId</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <a href="pg_depend.c.html#LN42"><span class='Ref_to_Func'>recordDependencyOn</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="index.c.html#LN1161"><span class='Ref_To_Local'>myself</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="index.c.html#LN1162"><span class='Ref_To_Local'>referenced</span></a><span class='Delimiter'>, </span><a href="../../include/catalog/dependency.h.html#LN76"><span class='Ref_to_EnumConst'>DEPENDENCY_INTERNAL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the constraint is deferrable, create the deferred uniqueness 
     * checking trigger.  (The trigger will be given an internal dependency on 
     * the constraint by CreateTrigger.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN1152"><span class='Ref_to_Parameter'>deferrable</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1249"></a>        <a href="../../include/nodes/parsenodes.h.html#LN2322"><span class='Ref_to_Struct'>CreateTrigStmt</span></a> <span class='Operator'>*</span><span class='Declare_Local'>trigger</span><span class='Delimiter'>; 
</span> 
        <a href="index.c.html#LN1249"><span class='Ref_To_Local'>trigger</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN2322"><span class='Ref_to_Struct'>CreateTrigStmt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="index.c.html#LN1249"><span class='Ref_To_Local'>trigger</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN2325"><span class='Ref_to_Member'>trigname</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="index.c.html#LN1151"><span class='Ref_to_Parameter'>constraintType</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_constraint.h.html#LN189"><span class='Ref_to_Const'>CONSTRAINT_PRIMARY</span></a><span class='Parentheses'>) </span><span class='Operator'>? 
</span>            <span class='String'>"PK_ConstraintTrigger"</span> <span class='Operator'>: 
</span>            <span class='String'>"Unique_ConstraintTrigger"</span><span class='Delimiter'>; 
</span>        <a href="index.c.html#LN1249"><span class='Ref_To_Local'>trigger</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN2326"><span class='Ref_to_Member'>relation</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <a href="index.c.html#LN1249"><span class='Ref_To_Local'>trigger</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN2327"><span class='Ref_to_Member'>funcname</span></a> <span class='Operator'>= </span><a href="../../include/parser/parser.h.html#LN37"><span class='Ref_to_Proto'>SystemFuncName</span></a><span class='Parentheses'>(</span><span class='String'>"unique_key_recheck"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="index.c.html#LN1249"><span class='Ref_To_Local'>trigger</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN2328"><span class='Ref_to_Member'>args</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>        <a href="index.c.html#LN1249"><span class='Ref_To_Local'>trigger</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN2329"><span class='Ref_to_Member'>row</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <a href="index.c.html#LN1249"><span class='Ref_To_Local'>trigger</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN2331"><span class='Ref_to_Member'>timing</span></a> <span class='Operator'>= </span><a href="../../include/catalog/pg_trigger.h.html#LN111"><span class='Ref_to_Const'>TRIGGER_TYPE_AFTER</span></a><span class='Delimiter'>; 
</span>        <a href="index.c.html#LN1249"><span class='Ref_To_Local'>trigger</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN2333"><span class='Ref_to_Member'>events</span></a> <span class='Operator'>= </span><a href="../../include/catalog/pg_trigger.h.html#LN99"><span class='Ref_to_Const'>TRIGGER_TYPE_INSERT</span></a> <span class='Operator'>| </span><a href="../../include/catalog/pg_trigger.h.html#LN101"><span class='Ref_to_Const'>TRIGGER_TYPE_UPDATE</span></a><span class='Delimiter'>; 
</span>        <a href="index.c.html#LN1249"><span class='Ref_To_Local'>trigger</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN2334"><span class='Ref_to_Member'>columns</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>        <a href="index.c.html#LN1249"><span class='Ref_To_Local'>trigger</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN2335"><span class='Ref_to_Member'>whenClause</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <a href="index.c.html#LN1249"><span class='Ref_To_Local'>trigger</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN2336"><span class='Ref_to_Member'>isconstraint</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <a href="index.c.html#LN1249"><span class='Ref_To_Local'>trigger</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN2340"><span class='Ref_to_Member'>deferrable</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <a href="index.c.html#LN1249"><span class='Ref_To_Local'>trigger</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN2341"><span class='Ref_to_Member'>initdeferred</span></a> <span class='Operator'>= </span><a href="index.c.html#LN1153"><span class='Ref_to_Parameter'>initdeferred</span></a><span class='Delimiter'>; 
</span>        <a href="index.c.html#LN1249"><span class='Ref_To_Local'>trigger</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN2342"><span class='Ref_to_Member'>constrrel</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
        <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="../../include/commands/trigger.h.html#LN113"><span class='Ref_to_Proto'>CreateTrigger</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1249"><span class='Ref_To_Local'>trigger</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><a href="../../include/utils/rel.h.html#LN416"><span class='Ref_to_Macro'>RelationGetRelid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1147"><span class='Ref_to_Parameter'>heapRelation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                             <a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN1163"><span class='Ref_To_Local'>conOid</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN1148"><span class='Ref_to_Parameter'>indexRelationId</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if deferrable &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * If needed, mark the table as having a primary key.  We assume it can't 
     * have been so marked already, so no need to clear the flag in the other 
     * case. 
     * 
     * Note: this might better be done by callers.  We do it here to avoid 
     * exposing index_update_stats() globally, but that wouldn't be necessary 
     * if relhaspkey went away. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN1154"><span class='Ref_to_Parameter'>mark_as_primary</span></a><span class='Parentheses'>) 
</span>        <a href="index.c.html#LN108"><span class='Ref_to_Proto'>index_update_stats</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1147"><span class='Ref_to_Parameter'>heapRelation</span></a><span class='Delimiter'>, 
</span>                           <span class='Boolean'>true</span><span class='Delimiter'>, 
</span>                           <span class='Boolean'>true</span><span class='Delimiter'>, 
</span>                           <span class='Operator'>-</span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If needed, mark the index as primary and/or deferred in pg_index. 
     * 
     * Note: When making an existing index into a constraint, caller must have 
     * a table lock that prevents concurrent table updates; otherwise, there 
     * is a risk that concurrent readers of the table will miss seeing this 
     * index at all. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN1155"><span class='Ref_to_Parameter'>update_pgindex</span></a> <span class='Operator'>&& </span><span class='Parentheses'>(</span><a href="index.c.html#LN1154"><span class='Ref_to_Parameter'>mark_as_primary</span></a> <span class='Operator'>|| </span><a href="index.c.html#LN1152"><span class='Ref_to_Parameter'>deferrable</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1297"></a>        <a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>pg_index</span><span class='Delimiter'>; 
</span><a name="LN1298"></a>        <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>indexTuple</span><span class='Delimiter'>; 
</span><a name="LN1299"></a>        <a href="../../include/catalog/pg_index.h.html#LN66"><span class='Ref_to_Typedef'>Form_pg_index</span></a> <span class='Declare_Local'>indexForm</span><span class='Delimiter'>; 
</span><a name="LN1300"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>dirty</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
        <a href="index.c.html#LN1297"><span class='Ref_To_Local'>pg_index</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN91"><span class='Ref_to_Proto'>heap_open</span></a><span class='Parentheses'>(</span><a href="../../include/catalog/pg_index.h.html#LN28"><span class='Ref_to_Const'>IndexRelationId</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN37"><span class='Ref_to_Const'>RowExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="index.c.html#LN1298"><span class='Ref_To_Local'>indexTuple</span></a> <span class='Operator'>= </span><a href="../../include/utils/syscache.h.html#LN164"><span class='Ref_to_Macro'>SearchSysCacheCopy1</span></a><span class='Parentheses'>(</span><a href="../../include/utils/syscache.h.html#LN65"><span class='Ref_to_EnumConst'>INDEXRELID</span></a><span class='Delimiter'>, 
</span>                                         <a href="../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1148"><span class='Ref_to_Parameter'>indexRelationId</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1298"><span class='Ref_To_Local'>indexTuple</span></a><span class='Parentheses'>))</span> 
            <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cache lookup failed for index %u"</span><span class='Delimiter'>, </span><a href="index.c.html#LN1148"><span class='Ref_to_Parameter'>indexRelationId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="index.c.html#LN1299"><span class='Ref_To_Local'>indexForm</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/catalog/pg_index.h.html#LN66"><span class='Ref_to_Typedef'>Form_pg_index</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1298"><span class='Ref_To_Local'>indexTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN1154"><span class='Ref_to_Parameter'>mark_as_primary</span></a> <span class='Operator'>&& !</span><a href="index.c.html#LN1299"><span class='Ref_To_Local'>indexForm</span></a><span class='Operator'>-&GT;</span>indisprimary<span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="index.c.html#LN1299"><span class='Ref_To_Local'>indexForm</span></a><span class='Operator'>-&GT;</span>indisprimary <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <a href="index.c.html#LN1300"><span class='Ref_To_Local'>dirty</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN1152"><span class='Ref_to_Parameter'>deferrable</span></a> <span class='Operator'>&& </span><a href="index.c.html#LN1299"><span class='Ref_To_Local'>indexForm</span></a><span class='Operator'>-&GT;</span>indimmediate<span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="index.c.html#LN1299"><span class='Ref_To_Local'>indexForm</span></a><span class='Operator'>-&GT;</span>indimmediate <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="index.c.html#LN1300"><span class='Ref_To_Local'>dirty</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN1300"><span class='Ref_To_Local'>dirty</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../include/catalog/indexing.h.html#LN35"><span class='Ref_to_Proto'>CatalogTupleUpdate</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1297"><span class='Ref_To_Local'>pg_index</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="index.c.html#LN1298"><span class='Ref_To_Local'>indexTuple</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/htup.h.html#LN64"><span class='Ref_to_Member'>t_self</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN1298"><span class='Ref_To_Local'>indexTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="../../include/catalog/objectaccess.h.html#LN165"><span class='Ref_to_Macro'>InvokeObjectPostAlterHookArg</span></a><span class='Parentheses'>(</span><a href="../../include/catalog/pg_index.h.html#LN28"><span class='Ref_to_Const'>IndexRelationId</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN1148"><span class='Ref_to_Parameter'>indexRelationId</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, 
</span>                                         <a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN1158"><span class='Ref_to_Parameter'>is_internal</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="../../include/access/htup_details.h.html#LN815"><span class='Ref_to_Proto'>heap_freetuple</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1298"><span class='Ref_To_Local'>indexTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/access/heapam.h.html#LN96"><span class='Ref_to_Macro'>heap_close</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1297"><span class='Ref_To_Local'>pg_index</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN37"><span class='Ref_to_Const'>RowExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if update_pgindex&&(mark... &raquo; </span> 
 
    <span class='Control'>return</span> <a href="index.c.html#LN1162"><span class='Ref_To_Local'>referenced</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end index_constraint_create &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 *      index_drop 
 * 
 * NOTE: this routine should now only be called through performDeletion(), 
 * else associated dependencies won't be cleaned up. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1344"></a><span class='Declare_Function'>index_drop</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>indexId</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>concurrent</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1346"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>heapId</span><span class='Delimiter'>; 
</span><a name="LN1347"></a>    <a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>userHeapRelation</span><span class='Delimiter'>; 
</span><a name="LN1348"></a>    <a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>userIndexRelation</span><span class='Delimiter'>; 
</span><a name="LN1349"></a>    <a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>indexRelation</span><span class='Delimiter'>; 
</span><a name="LN1350"></a>    <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>tuple</span><span class='Delimiter'>; 
</span><a name="LN1351"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>hasexprs</span><span class='Delimiter'>; 
</span><a name="LN1352"></a>    <a href="../../include/utils/rel.h.html#LN35"><span class='Ref_to_Struct'>LockRelId</span></a>   <span class='Declare_Local'>heaprelid</span><span class='Delimiter'>, 
</span><a name="LN1353"></a>                <span class='Declare_Local'>indexrelid</span><span class='Delimiter'>; 
</span><a name="LN1354"></a>    <a href="../../include/storage/lock.h.html#LN178"><span class='Ref_to_Struct'>LOCKTAG</span></a>     <span class='Declare_Local'>heaplocktag</span><span class='Delimiter'>; 
</span><a name="LN1355"></a>    <a href="../../include/storage/lockdefs.h.html#LN25"><span class='Ref_to_Typedef'>LOCKMODE</span></a>    <span class='Declare_Local'>lockmode</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * To drop an index safely, we must grab exclusive lock on its parent 
     * table.  Exclusive lock on the index alone is insufficient because 
     * another backend might be about to execute a query on the parent table. 
     * If it relies on a previously cached list of index OIDs, then it could 
     * attempt to access the just-dropped index.  We must therefore take a 
     * table lock strong enough to prevent all queries on the table from 
     * proceeding until we commit and send out a shared-cache-inval notice 
     * that will make them update their index lists. 
     * 
     * In the concurrent case we avoid this requirement by disabling index use 
     * in multiple steps and waiting out any transactions that might be using 
     * the index, so we don't need exclusive lock on the parent table. Instead 
     * we take ShareUpdateExclusiveLock, to ensure that two sessions aren't 
     * doing CREATE/DROP INDEX CONCURRENTLY on the same index.  (We will get 
     * AccessExclusiveLock on the index below, once we're sure nobody else is 
     * using it.) 
     */ 
</span>    <a href="index.c.html#LN1346"><span class='Ref_To_Local'>heapId</span></a> <span class='Operator'>= </span><a href="../../include/catalog/index.h.html#LN131"><span class='Ref_to_Proto'>IndexGetRelation</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1344"><span class='Ref_to_Parameter'>indexId</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN1355"><span class='Ref_To_Local'>lockmode</span></a> <span class='Operator'>= </span><a href="index.c.html#LN1344"><span class='Ref_to_Parameter'>concurrent</span></a> <span class='Operator'>? </span><a href="../../include/storage/lockdefs.h.html#LN38"><span class='Ref_to_Const'>ShareUpdateExclusiveLock</span></a> <span class='Operator'>: </span><a href="../../include/storage/lockdefs.h.html#LN45"><span class='Ref_to_Const'>AccessExclusiveLock</span></a><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN1347"><span class='Ref_To_Local'>userHeapRelation</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN91"><span class='Ref_to_Proto'>heap_open</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1346"><span class='Ref_To_Local'>heapId</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN1355"><span class='Ref_To_Local'>lockmode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN1348"><span class='Ref_To_Local'>userIndexRelation</span></a> <span class='Operator'>= </span><a href="../../include/access/genam.h.html#LN129"><span class='Ref_to_Proto'>index_open</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1344"><span class='Ref_to_Parameter'>indexId</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN1355"><span class='Ref_To_Local'>lockmode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We might still have open queries using it in our own session, which the 
     * above locking won't prevent, so test explicitly. 
     */ 
</span>    <a href="../../include/commands/tablecmds.h.html#LN52"><span class='Ref_to_Proto'>CheckTableNotInUse</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1348"><span class='Ref_To_Local'>userIndexRelation</span></a><span class='Delimiter'>, </span><span class='String'>"DROP INDEX"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Drop Index Concurrently is more or less the reverse process of Create 
     * Index Concurrently. 
     * 
     * First we unset indisvalid so queries starting afterwards don't use the 
     * index to answer queries anymore.  We have to keep indisready = true so 
     * transactions that are still scanning the index can continue to see 
     * valid index contents.  For instance, if they are using READ COMMITTED 
     * mode, and another transaction makes changes and commits, they need to 
     * see those new tuples in the index. 
     * 
     * After all transactions that could possibly have used the index for 
     * queries end, we can unset indisready and indislive, then wait till 
     * nobody could be touching it anymore.  (Note: we need indislive because 
     * this state must be distinct from the initial state during CREATE INDEX 
     * CONCURRENTLY, which has indislive true while indisready and indisvalid 
     * are false.  That's because in that state, transactions must examine the 
     * index for HOT-safety decisions, while in this state we don't want them 
     * to open it at all.) 
     * 
     * Since all predicate locks on the index are about to be made invalid, we 
     * must promote them to predicate locks on the heap.  In the 
     * non-concurrent case we can just do that now.  In the concurrent case 
     * it's a bit trickier.  The predicate locks must be moved when there are 
     * no index scans in progress on the index and no more can subsequently 
     * start, so that no new predicate locks can be made on the index.  Also, 
     * they must be moved before heap inserts stop maintaining the index, else 
     * the conflict with the predicate lock on the index gap could be missed 
     * before the lock on the heap relation is in place to detect a conflict 
     * based on the heap tuple insert. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN1344"><span class='Ref_to_Parameter'>concurrent</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * We must commit our transaction in order to make the first pg_index 
         * state update visible to other sessions.  If the DROP machinery has 
         * already performed any other actions (removal of other objects, 
         * pg_depend entries, etc), the commit would make those actions 
         * permanent, which would leave us with inconsistent catalog state if 
         * we fail partway through the following sequence.  Since DROP INDEX 
         * CONCURRENTLY is restricted to dropping just one index that has no 
         * dependencies, we should get here before anything's been done --- 
         * but let's check that to be sure.  We can verify that the current 
         * transaction has not executed any transactional updates by checking 
         * that no XID has been assigned. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/access/xact.h.html#LN332"><span class='Ref_to_Proto'>GetTopTransactionIdIfAny</span></a><span class='Parentheses'>() </span><span class='Operator'>!= </span><a href="../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Parentheses'>)</span> 
            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"DROP INDEX CONCURRENTLY must be first action in transaction"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Mark index invalid by updating its pg_index entry 
         */ 
</span>        <a href="../../include/catalog/index.h.html#LN115"><span class='Ref_to_Proto'>index_set_state_flags</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1344"><span class='Ref_to_Parameter'>indexId</span></a><span class='Delimiter'>, </span><a href="../../include/catalog/index.h.html#LN35"><span class='Ref_to_EnumConst'>INDEX_DROP_CLEAR_VALID</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Invalidate the relcache for the table, so that after this commit 
         * all sessions will refresh any cached plans that might reference the 
         * index. 
         */ 
</span>        <a href="../../include/utils/inval.h.html#LN43"><span class='Ref_to_Proto'>CacheInvalidateRelcache</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1347"><span class='Ref_To_Local'>userHeapRelation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* save lockrelid and locktag for below, then close but keep locks */ 
</span>        <a href="index.c.html#LN1352"><span class='Ref_To_Local'>heaprelid</span></a> <span class='Operator'>= </span><a href="index.c.html#LN1347"><span class='Ref_To_Local'>userHeapRelation</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN116"><span class='Ref_to_Member'>rd_lockInfo</span></a><span class='Operator'>.</span><a href="../../include/utils/rel.h.html#LN43"><span class='Ref_to_Member'>lockRelId</span></a><span class='Delimiter'>; 
</span>        <a href="../../include/storage/lock.h.html#LN193"><span class='Ref_to_Macro'>SET_LOCKTAG_RELATION</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1354"><span class='Ref_To_Local'>heaplocktag</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN1352"><span class='Ref_To_Local'>heaprelid</span></a><span class='Operator'>.</span><a href="../../include/utils/rel.h.html#LN38"><span class='Ref_to_Member'>dbId</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN1352"><span class='Ref_To_Local'>heaprelid</span></a><span class='Operator'>.</span><a href="../../include/utils/rel.h.html#LN37"><span class='Ref_to_Member'>relId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="index.c.html#LN1353"><span class='Ref_To_Local'>indexrelid</span></a> <span class='Operator'>= </span><a href="index.c.html#LN1348"><span class='Ref_To_Local'>userIndexRelation</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN116"><span class='Ref_to_Member'>rd_lockInfo</span></a><span class='Operator'>.</span><a href="../../include/utils/rel.h.html#LN43"><span class='Ref_to_Member'>lockRelId</span></a><span class='Delimiter'>; 
</span> 
        <a href="../../include/access/heapam.h.html#LN96"><span class='Ref_to_Macro'>heap_close</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1347"><span class='Ref_To_Local'>userHeapRelation</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN33"><span class='Ref_to_Const'>NoLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/access/genam.h.html#LN130"><span class='Ref_to_Proto'>index_close</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1348"><span class='Ref_To_Local'>userIndexRelation</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN33"><span class='Ref_to_Const'>NoLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We must commit our current transaction so that the indisvalid 
         * update becomes visible to other transactions; then start another. 
         * Note that any previously-built data structures are lost in the 
         * commit.  The only data we keep past here are the relation IDs. 
         * 
         * Before committing, get a session-level lock on the table, to ensure 
         * that neither it nor the index can be dropped before we finish. This 
         * cannot block, even if someone else is waiting for access, because 
         * we already have the same lock within our transaction. 
         */ 
</span>        <a href="../../include/storage/lmgr.h.html#LN49"><span class='Ref_to_Proto'>LockRelationIdForSession</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="index.c.html#LN1352"><span class='Ref_To_Local'>heaprelid</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN38"><span class='Ref_to_Const'>ShareUpdateExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/storage/lmgr.h.html#LN49"><span class='Ref_to_Proto'>LockRelationIdForSession</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="index.c.html#LN1353"><span class='Ref_To_Local'>indexrelid</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN38"><span class='Ref_to_Const'>ShareUpdateExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/utils/snapmgr.h.html#LN76"><span class='Ref_to_Proto'>PopActiveSnapshot</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <a href="../../include/access/xact.h.html#LN349"><span class='Ref_to_Proto'>CommitTransactionCommand</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <a href="../../include/access/xact.h.html#LN348"><span class='Ref_to_Proto'>StartTransactionCommand</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Now we must wait until no running transaction could be using the 
         * index for a query.  Use AccessExclusiveLock here to check for 
         * running transactions that hold locks of any kind on the table. Note 
         * we do not need to worry about xacts that open the table for reading 
         * after this point; they will see the index as invalid when they open 
         * the relation. 
         * 
         * Note: the reason we use actual lock acquisition here, rather than 
         * just checking the ProcArray and sleeping, is that deadlock is 
         * possible if one of the transactions in question is blocked trying 
         * to acquire an exclusive lock on our table.  The lock code will 
         * detect deadlock and error out properly. 
         */ 
</span>        <a href="../../include/storage/lmgr.h.html#LN78"><span class='Ref_to_Proto'>WaitForLockers</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1354"><span class='Ref_To_Local'>heaplocktag</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN45"><span class='Ref_to_Const'>AccessExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * No more predicate locks will be acquired on this index, and we're 
         * about to stop doing inserts into the index which could show 
         * conflicts with existing predicate locks, so now is the time to move 
         * them to the heap relation. 
         */ 
</span>        <a href="index.c.html#LN1347"><span class='Ref_To_Local'>userHeapRelation</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN91"><span class='Ref_to_Proto'>heap_open</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1346"><span class='Ref_To_Local'>heapId</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN38"><span class='Ref_to_Const'>ShareUpdateExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="index.c.html#LN1348"><span class='Ref_To_Local'>userIndexRelation</span></a> <span class='Operator'>= </span><a href="../../include/access/genam.h.html#LN129"><span class='Ref_to_Proto'>index_open</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1344"><span class='Ref_to_Parameter'>indexId</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN38"><span class='Ref_to_Const'>ShareUpdateExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/storage/predicate.h.html#LN55"><span class='Ref_to_Proto'>TransferPredicateLocksToHeapRelation</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1348"><span class='Ref_To_Local'>userIndexRelation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Now we are sure that nobody uses the index for queries; they just 
         * might have it open for updating it.  So now we can unset indisready 
         * and indislive, then wait till nobody could be using it at all 
         * anymore. 
         */ 
</span>        <a href="../../include/catalog/index.h.html#LN115"><span class='Ref_to_Proto'>index_set_state_flags</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1344"><span class='Ref_to_Parameter'>indexId</span></a><span class='Delimiter'>, </span><a href="../../include/catalog/index.h.html#LN36"><span class='Ref_to_EnumConst'>INDEX_DROP_SET_DEAD</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Invalidate the relcache for the table, so that after this commit 
         * all sessions will refresh the table's index list.  Forgetting just 
         * the index's relcache entry is not enough. 
         */ 
</span>        <a href="../../include/utils/inval.h.html#LN43"><span class='Ref_to_Proto'>CacheInvalidateRelcache</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1347"><span class='Ref_To_Local'>userHeapRelation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Close the relations again, though still holding session lock. 
         */ 
</span>        <a href="../../include/access/heapam.h.html#LN96"><span class='Ref_to_Macro'>heap_close</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1347"><span class='Ref_To_Local'>userHeapRelation</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN33"><span class='Ref_to_Const'>NoLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/access/genam.h.html#LN130"><span class='Ref_to_Proto'>index_close</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1348"><span class='Ref_To_Local'>userIndexRelation</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN33"><span class='Ref_to_Const'>NoLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Again, commit the transaction to make the pg_index update visible 
         * to other sessions. 
         */ 
</span>        <a href="../../include/access/xact.h.html#LN349"><span class='Ref_to_Proto'>CommitTransactionCommand</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <a href="../../include/access/xact.h.html#LN348"><span class='Ref_to_Proto'>StartTransactionCommand</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Wait till every transaction that saw the old index state has 
         * finished. 
         */ 
</span>        <a href="../../include/storage/lmgr.h.html#LN78"><span class='Ref_to_Proto'>WaitForLockers</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1354"><span class='Ref_To_Local'>heaplocktag</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN45"><span class='Ref_to_Const'>AccessExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Re-open relations to allow us to complete our actions. 
         * 
         * At this point, nothing should be accessing the index, but lets 
         * leave nothing to chance and grab AccessExclusiveLock on the index 
         * before the physical deletion. 
         */ 
</span>        <a href="index.c.html#LN1347"><span class='Ref_To_Local'>userHeapRelation</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN91"><span class='Ref_to_Proto'>heap_open</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1346"><span class='Ref_To_Local'>heapId</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN38"><span class='Ref_to_Const'>ShareUpdateExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="index.c.html#LN1348"><span class='Ref_To_Local'>userIndexRelation</span></a> <span class='Operator'>= </span><a href="../../include/access/genam.h.html#LN129"><span class='Ref_to_Proto'>index_open</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1344"><span class='Ref_to_Parameter'>indexId</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN45"><span class='Ref_to_Const'>AccessExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if concurrent &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Not concurrent, so just transfer predicate locks and we're good */ 
</span>        <a href="../../include/storage/predicate.h.html#LN55"><span class='Ref_to_Proto'>TransferPredicateLocksToHeapRelation</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1348"><span class='Ref_To_Local'>userIndexRelation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Schedule physical removal of the files 
     */ 
</span>    <a href="../../include/catalog/storage.h.html#LN21"><span class='Ref_to_Proto'>RelationDropStorage</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1348"><span class='Ref_To_Local'>userIndexRelation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Close and flush the index's relcache entry, to ensure relcache doesn't 
     * try to rebuild it while we're deleting catalog entries. We keep the 
     * lock though. 
     */ 
</span>    <a href="../../include/access/genam.h.html#LN130"><span class='Ref_to_Proto'>index_close</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1348"><span class='Ref_To_Local'>userIndexRelation</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN33"><span class='Ref_to_Const'>NoLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/utils/relcache.h.html#LN111"><span class='Ref_to_Proto'>RelationForgetRelation</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1344"><span class='Ref_to_Parameter'>indexId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * fix INDEX relation, and check for expressional index 
     */ 
</span>    <a href="index.c.html#LN1349"><span class='Ref_To_Local'>indexRelation</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN91"><span class='Ref_to_Proto'>heap_open</span></a><span class='Parentheses'>(</span><a href="../../include/catalog/pg_index.h.html#LN28"><span class='Ref_to_Const'>IndexRelationId</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN37"><span class='Ref_to_Const'>RowExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="index.c.html#LN1350"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>= </span><a href="../../include/utils/syscache.h.html#LN155"><span class='Ref_to_Macro'>SearchSysCache1</span></a><span class='Parentheses'>(</span><a href="../../include/utils/syscache.h.html#LN65"><span class='Ref_to_EnumConst'>INDEXRELID</span></a><span class='Delimiter'>, </span><a href="../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1344"><span class='Ref_to_Parameter'>indexId</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1350"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>))</span> 
        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cache lookup failed for index %u"</span><span class='Delimiter'>, </span><a href="index.c.html#LN1344"><span class='Ref_to_Parameter'>indexId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="index.c.html#LN1351"><span class='Ref_To_Local'>hasexprs</span></a> <span class='Operator'>= !</span><a href="../access/common/heaptuple.c.html#LN295"><span class='Ref_to_Func'>heap_attisnull</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1350"><span class='Ref_To_Local'>tuple</span></a><span class='Delimiter'>, </span><a href="../../include/catalog/pg_index.h.html#LN90"><span class='Ref_to_Const'>Anum_pg_index_indexprs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/catalog/indexing.h.html#LN40"><span class='Ref_to_Proto'>CatalogTupleDelete</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1349"><span class='Ref_To_Local'>indexRelation</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="index.c.html#LN1350"><span class='Ref_To_Local'>tuple</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/htup.h.html#LN64"><span class='Ref_to_Member'>t_self</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1350"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/access/heapam.h.html#LN96"><span class='Ref_to_Macro'>heap_close</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1349"><span class='Ref_To_Local'>indexRelation</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN37"><span class='Ref_to_Const'>RowExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * if it has any expression columns, we might have stored statistics about 
     * them. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN1351"><span class='Ref_To_Local'>hasexprs</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/catalog/heap.h.html#LN120"><span class='Ref_to_Proto'>RemoveStatistics</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1344"><span class='Ref_to_Parameter'>indexId</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * fix ATTRIBUTE relation 
     */ 
</span>    <a href="../../include/catalog/heap.h.html#LN114"><span class='Ref_to_Proto'>DeleteAttributeTuples</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1344"><span class='Ref_to_Parameter'>indexId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * fix RELATION relation 
     */ 
</span>    <a href="../../include/catalog/heap.h.html#LN113"><span class='Ref_to_Proto'>DeleteRelationTuple</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1344"><span class='Ref_to_Parameter'>indexId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We are presently too lazy to attempt to compute the new correct value 
     * of relhasindex (the next VACUUM will fix it if necessary). So there is 
     * no need to update the pg_class tuple for the owning relation. But we 
     * must send out a shared-cache-inval notice on the owning relation to 
     * ensure other backends update their relcache lists of indexes.  (In the 
     * concurrent case, this is redundant but harmless.) 
     */ 
</span>    <a href="../../include/utils/inval.h.html#LN43"><span class='Ref_to_Proto'>CacheInvalidateRelcache</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1347"><span class='Ref_To_Local'>userHeapRelation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Close owning rel, but keep lock 
     */ 
</span>    <a href="../../include/access/heapam.h.html#LN96"><span class='Ref_to_Macro'>heap_close</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1347"><span class='Ref_To_Local'>userHeapRelation</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN33"><span class='Ref_to_Const'>NoLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Release the session locks before we go. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN1344"><span class='Ref_to_Parameter'>concurrent</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../include/storage/lmgr.h.html#LN50"><span class='Ref_to_Proto'>UnlockRelationIdForSession</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="index.c.html#LN1352"><span class='Ref_To_Local'>heaprelid</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN38"><span class='Ref_to_Const'>ShareUpdateExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/storage/lmgr.h.html#LN50"><span class='Ref_to_Proto'>UnlockRelationIdForSession</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="index.c.html#LN1353"><span class='Ref_To_Local'>indexrelid</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN38"><span class='Ref_to_Const'>ShareUpdateExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end index_drop &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *                      index_build support 
 * ---------------------------------------------------------------- 
 */ 
</span> 
<span class='Comment_Multi_Line'>/* ---------------- 
 *      BuildIndexInfo 
 *          Construct an IndexInfo record for an open index 
 * 
 * IndexInfo stores the information about the index that's needed by 
 * FormIndexDatum, which is used for both index_build() and later insertion 
 * of individual index tuples.  Normally we build an IndexInfo for an index 
 * just once per command, and then use it for (potentially) many tuples. 
 * ---------------- 
 */ 
</span><a href="../../include/nodes/execnodes.h.html#LN130"><span class='Ref_to_Struct'>IndexInfo</span></a> <span class='Operator'>* 
</span><a name="LN1639"></a><span class='Declare_Function'>BuildIndexInfo</span><span class='Parentheses'>(</span><a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>index</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1641"></a>    <a href="../../include/nodes/execnodes.h.html#LN130"><span class='Ref_to_Struct'>IndexInfo</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>ii</span> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN130"><span class='Ref_to_Struct'>IndexInfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1642"></a>    <a href="../../include/catalog/pg_index.h.html#LN66"><span class='Ref_to_Typedef'>Form_pg_index</span></a> <span class='Declare_Local'>indexStruct</span> <span class='Operator'>= </span><a href="index.c.html#LN1639"><span class='Ref_to_Parameter'>index</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN158"><span class='Ref_to_Member'>rd_index</span></a><span class='Delimiter'>; 
</span><a name="LN1643"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN1644"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numKeys</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* check the number of keys, and copy attr numbers into the IndexInfo */ 
</span>    <a href="index.c.html#LN1644"><span class='Ref_To_Local'>numKeys</span></a> <span class='Operator'>= </span><a href="index.c.html#LN1642"><span class='Ref_To_Local'>indexStruct</span></a><span class='Operator'>-&GT;</span>indnatts<span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN1644"><span class='Ref_To_Local'>numKeys</span></a> <span class='Operator'>&LT; </span><span class='Number'>1</span> <span class='Operator'>|| </span><a href="index.c.html#LN1644"><span class='Ref_To_Local'>numKeys</span></a> <span class='Operator'>&GT; </span><a href="../../include/pg_config_manual.h.html#LN45"><span class='Ref_to_Const'>INDEX_MAX_KEYS</span></a><span class='Parentheses'>) 
</span>        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"invalid indnatts %d for index %u"</span><span class='Delimiter'>, 
</span>             <a href="index.c.html#LN1644"><span class='Ref_To_Local'>numKeys</span></a><span class='Delimiter'>, </span><a href="../../include/utils/rel.h.html#LN416"><span class='Ref_to_Macro'>RelationGetRelid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1639"><span class='Ref_to_Parameter'>index</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN1641"><span class='Ref_To_Local'>ii</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN133"><span class='Ref_to_Member'>ii_NumIndexAttrs</span></a> <span class='Operator'>= </span><a href="index.c.html#LN1644"><span class='Ref_To_Local'>numKeys</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="index.c.html#LN1643"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="index.c.html#LN1643"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="index.c.html#LN1644"><span class='Ref_To_Local'>numKeys</span></a><span class='Delimiter'>; </span><a href="index.c.html#LN1643"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <a href="index.c.html#LN1641"><span class='Ref_To_Local'>ii</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN134"><span class='Ref_to_Member'>ii_KeyAttrNumbers</span></a><span class='Delimiter'>[</span><a href="index.c.html#LN1643"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="index.c.html#LN1642"><span class='Ref_To_Local'>indexStruct</span></a><span class='Operator'>-&GT;</span>indkey<span class='Operator'>.</span>values<span class='Delimiter'>[</span><a href="index.c.html#LN1643"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
    <span class='Comment_Multi_Line'>/* fetch any expressions needed for expressional indexes */ 
</span>    <a href="index.c.html#LN1641"><span class='Ref_To_Local'>ii</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN135"><span class='Ref_to_Member'>ii_Expressions</span></a> <span class='Operator'>= </span><a href="../../include/utils/relcache.h.html#LN45"><span class='Ref_to_Proto'>RelationGetIndexExpressions</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1639"><span class='Ref_to_Parameter'>index</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN1641"><span class='Ref_To_Local'>ii</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN136"><span class='Ref_to_Member'>ii_ExpressionsState</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* fetch index predicate if any */ 
</span>    <a href="index.c.html#LN1641"><span class='Ref_To_Local'>ii</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN137"><span class='Ref_to_Member'>ii_Predicate</span></a> <span class='Operator'>= </span><a href="../../include/utils/relcache.h.html#LN46"><span class='Ref_to_Proto'>RelationGetIndexPredicate</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1639"><span class='Ref_to_Parameter'>index</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN1641"><span class='Ref_To_Local'>ii</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN138"><span class='Ref_to_Member'>ii_PredicateState</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* fetch exclusion constraint info if any */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN1642"><span class='Ref_To_Local'>indexStruct</span></a><span class='Operator'>-&GT;</span>indisexclusion<span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../include/utils/relcache.h.html#LN59"><span class='Ref_to_Proto'>RelationGetExclusionInfo</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1639"><span class='Ref_to_Parameter'>index</span></a><span class='Delimiter'>, 
</span>                                 <span class='Operator'>&</span><a href="index.c.html#LN1641"><span class='Ref_To_Local'>ii</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN139"><span class='Ref_to_Member'>ii_ExclusionOps</span></a><span class='Delimiter'>, 
</span>                                 <span class='Operator'>&</span><a href="index.c.html#LN1641"><span class='Ref_To_Local'>ii</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN140"><span class='Ref_to_Member'>ii_ExclusionProcs</span></a><span class='Delimiter'>, 
</span>                                 <span class='Operator'>&</span><a href="index.c.html#LN1641"><span class='Ref_To_Local'>ii</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN141"><span class='Ref_to_Member'>ii_ExclusionStrats</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="index.c.html#LN1641"><span class='Ref_To_Local'>ii</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN139"><span class='Ref_to_Member'>ii_ExclusionOps</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <a href="index.c.html#LN1641"><span class='Ref_To_Local'>ii</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN140"><span class='Ref_to_Member'>ii_ExclusionProcs</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <a href="index.c.html#LN1641"><span class='Ref_To_Local'>ii</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN141"><span class='Ref_to_Member'>ii_ExclusionStrats</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* other info */ 
</span>    <a href="index.c.html#LN1641"><span class='Ref_To_Local'>ii</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN145"><span class='Ref_to_Member'>ii_Unique</span></a> <span class='Operator'>= </span><a href="index.c.html#LN1642"><span class='Ref_To_Local'>indexStruct</span></a><span class='Operator'>-&GT;</span>indisunique<span class='Delimiter'>; 
</span>    <a href="index.c.html#LN1641"><span class='Ref_To_Local'>ii</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN146"><span class='Ref_to_Member'>ii_ReadyForInserts</span></a> <span class='Operator'>= </span><a href="../../include/catalog/pg_index.h.html#LN107"><span class='Ref_to_Macro'>IndexIsReady</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1642"><span class='Ref_To_Local'>indexStruct</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* assume not doing speculative insertion for now */ 
</span>    <a href="index.c.html#LN1641"><span class='Ref_To_Local'>ii</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN142"><span class='Ref_to_Member'>ii_UniqueOps</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN1641"><span class='Ref_To_Local'>ii</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN143"><span class='Ref_to_Member'>ii_UniqueProcs</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN1641"><span class='Ref_To_Local'>ii</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN144"><span class='Ref_to_Member'>ii_UniqueStrats</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* initialize index-build state to default */ 
</span>    <a href="index.c.html#LN1641"><span class='Ref_To_Local'>ii</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN147"><span class='Ref_to_Member'>ii_Concurrent</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN1641"><span class='Ref_To_Local'>ii</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN148"><span class='Ref_to_Member'>ii_BrokenHotChain</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* set up for possible use by index AM */ 
</span>    <a href="index.c.html#LN1641"><span class='Ref_To_Local'>ii</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN149"><span class='Ref_to_Member'>ii_AmCache</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN1641"><span class='Ref_To_Local'>ii</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN150"><span class='Ref_to_Member'>ii_Context</span></a> <span class='Operator'>= </span><a href="../utils/mmgr/mcxt.c.html#LN36"><span class='Ref_to_Global_Var'>CurrentMemoryContext</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="index.c.html#LN1641"><span class='Ref_To_Local'>ii</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end BuildIndexInfo &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* ---------------- 
 *      BuildSpeculativeIndexInfo 
 *          Add extra state to IndexInfo record 
 * 
 * For unique indexes, we usually don't want to add info to the IndexInfo for 
 * checking uniqueness, since the B-Tree AM handles that directly.  However, 
 * in the case of speculative insertion, additional support is required. 
 * 
 * Do this processing here rather than in BuildIndexInfo() to not incur the 
 * overhead in the common non-speculative cases. 
 * ---------------- 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1710"></a><span class='Declare_Function'>BuildSpeculativeIndexInfo</span><span class='Parentheses'>(</span><a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>index</span><span class='Delimiter'>, </span><a href="../../include/nodes/execnodes.h.html#LN130"><span class='Ref_to_Struct'>IndexInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>ii</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1712"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>ncols</span> <span class='Operator'>= </span><a href="index.c.html#LN1710"><span class='Ref_to_Parameter'>index</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relnatts<span class='Delimiter'>; 
</span><a name="LN1713"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * fetch info for checking unique indexes 
     */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="index.c.html#LN1710"><span class='Ref_to_Parameter'>ii</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN145"><span class='Ref_to_Member'>ii_Unique</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN1710"><span class='Ref_to_Parameter'>index</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relam <span class='Operator'>!= </span><a href="../../include/catalog/pg_am.h.html#LN69"><span class='Ref_to_Const'>BTREE_AM_OID</span></a><span class='Parentheses'>) 
</span>        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unexpected non-btree speculative unique index"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="index.c.html#LN1710"><span class='Ref_to_Parameter'>ii</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN142"><span class='Ref_to_Member'>ii_UniqueOps</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="index.c.html#LN1712"><span class='Ref_To_Local'>ncols</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN1710"><span class='Ref_to_Parameter'>ii</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN143"><span class='Ref_to_Member'>ii_UniqueProcs</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="index.c.html#LN1712"><span class='Ref_To_Local'>ncols</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN1710"><span class='Ref_to_Parameter'>ii</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN144"><span class='Ref_to_Member'>ii_UniqueStrats</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN266"><span class='Ref_to_Typedef'>uint16</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN266"><span class='Ref_to_Typedef'>uint16</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="index.c.html#LN1712"><span class='Ref_To_Local'>ncols</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We have to look up the operator's strategy number.  This provides a 
     * cross-check that the operator does match the index. 
     */ 
</span>    <span class='Comment_Multi_Line'>/* We need the func OIDs and strategy numbers too */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="index.c.html#LN1713"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="index.c.html#LN1713"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="index.c.html#LN1712"><span class='Ref_To_Local'>ncols</span></a><span class='Delimiter'>; </span><a href="index.c.html#LN1713"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="index.c.html#LN1710"><span class='Ref_to_Parameter'>ii</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN144"><span class='Ref_to_Member'>ii_UniqueStrats</span></a><span class='Delimiter'>[</span><a href="index.c.html#LN1713"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/access/stratnum.h.html#LN30"><span class='Ref_to_Const'>BTEqualStrategyNumber</span></a><span class='Delimiter'>; 
</span>        <a href="index.c.html#LN1710"><span class='Ref_to_Parameter'>ii</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN142"><span class='Ref_to_Member'>ii_UniqueOps</span></a><span class='Delimiter'>[</span><a href="index.c.html#LN1713"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= 
</span>            <a href="../../include/utils/lsyscache.h.html#LN70"><span class='Ref_to_Proto'>get_opfamily_member</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1710"><span class='Ref_to_Parameter'>index</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN181"><span class='Ref_to_Member'>rd_opfamily</span></a><span class='Delimiter'>[</span><a href="index.c.html#LN1713"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], 
</span>                                <a href="index.c.html#LN1710"><span class='Ref_to_Parameter'>index</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN182"><span class='Ref_to_Member'>rd_opcintype</span></a><span class='Delimiter'>[</span><a href="index.c.html#LN1713"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], 
</span>                                <a href="index.c.html#LN1710"><span class='Ref_to_Parameter'>index</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN182"><span class='Ref_to_Member'>rd_opcintype</span></a><span class='Delimiter'>[</span><a href="index.c.html#LN1713"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], 
</span>                                <a href="index.c.html#LN1710"><span class='Ref_to_Parameter'>ii</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN144"><span class='Ref_to_Member'>ii_UniqueStrats</span></a><span class='Delimiter'>[</span><a href="index.c.html#LN1713"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="index.c.html#LN1710"><span class='Ref_to_Parameter'>ii</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN143"><span class='Ref_to_Member'>ii_UniqueProcs</span></a><span class='Delimiter'>[</span><a href="index.c.html#LN1713"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/utils/lsyscache.h.html#LN98"><span class='Ref_to_Proto'>get_opcode</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1710"><span class='Ref_to_Parameter'>ii</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN142"><span class='Ref_to_Member'>ii_UniqueOps</span></a><span class='Delimiter'>[</span><a href="index.c.html#LN1713"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end BuildSpeculativeIndexInfo &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* ---------------- 
 *      FormIndexDatum 
 *          Construct values[] and isnull[] arrays for a new index tuple. 
 * 
 *  indexInfo       Info about the index 
 *  slot            Heap tuple for which we must prepare an index entry 
 *  estate          executor state for evaluating any index expressions 
 *  values          Array of index Datums (output area) 
 *  isnull          Array of is-null indicators (output area) 
 * 
 * When there are no index expressions, estate may be NULL.  Otherwise it 
 * must be supplied, *and* the ecxt_scantuple slot of its per-tuple expr 
 * context must point to the heap tuple passed in. 
 * 
 * Notice we don't actually call index_form_tuple() here; we just prepare 
 * its input arrays values[] and isnull[].  This is because the index AM 
 * may wish to alter the data before storage. 
 * ---------------- 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1764"></a><span class='Declare_Function'>FormIndexDatum</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN130"><span class='Ref_to_Struct'>IndexInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>indexInfo</span><span class='Delimiter'>, 
</span><a name="LN1765"></a>               <a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>slot</span><span class='Delimiter'>, 
</span><a name="LN1766"></a>               <a href="../../include/nodes/execnodes.h.html#LN402"><span class='Ref_to_Struct'>EState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>estate</span><span class='Delimiter'>, 
</span><a name="LN1767"></a>               <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>values</span><span class='Delimiter'>, 
</span><a name="LN1768"></a>               <span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>isnull</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1770"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>indexpr_item</span><span class='Delimiter'>; 
</span><a name="LN1771"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN1764"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN135"><span class='Ref_to_Member'>ii_Expressions</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>&& 
</span>        <a href="index.c.html#LN1764"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN136"><span class='Ref_to_Member'>ii_ExpressionsState</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* First time through, set up expression evaluation state */ 
</span>        <a href="index.c.html#LN1764"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN136"><span class='Ref_to_Member'>ii_ExpressionsState</span></a> <span class='Operator'>= 
</span>            <a href="../../include/executor/executor.h.html#LN249"><span class='Ref_to_Proto'>ExecPrepareExprList</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1764"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN135"><span class='Ref_to_Member'>ii_Expressions</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN1766"><span class='Ref_to_Parameter'>estate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* Check caller has set up context correctly */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../include/executor/executor.h.html#LN455"><span class='Ref_to_Macro'>GetPerTupleExprContext</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1766"><span class='Ref_to_Parameter'>estate</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>ecxt_scantuple <span class='Operator'>== </span><a href="index.c.html#LN1765"><span class='Ref_to_Parameter'>slot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="index.c.html#LN1770"><span class='Ref_To_Local'>indexpr_item</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1764"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN136"><span class='Ref_to_Member'>ii_ExpressionsState</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="index.c.html#LN1771"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="index.c.html#LN1771"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="index.c.html#LN1764"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN133"><span class='Ref_to_Member'>ii_NumIndexAttrs</span></a><span class='Delimiter'>; </span><a href="index.c.html#LN1771"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1786"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>keycol</span> <span class='Operator'>= </span><a href="index.c.html#LN1764"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN134"><span class='Ref_to_Member'>ii_KeyAttrNumbers</span></a><span class='Delimiter'>[</span><a href="index.c.html#LN1771"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span><a name="LN1787"></a>        <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>iDatum</span><span class='Delimiter'>; 
</span><a name="LN1788"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>isNull</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN1786"><span class='Ref_To_Local'>keycol</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Plain index column; get the value we need directly from the 
             * heap tuple. 
             */ 
</span>            <a href="index.c.html#LN1787"><span class='Ref_To_Local'>iDatum</span></a> <span class='Operator'>= </span><a href="../../include/executor/tuptable.h.html#LN167"><span class='Ref_to_Proto'>slot_getattr</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1765"><span class='Ref_to_Parameter'>slot</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN1786"><span class='Ref_To_Local'>keycol</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="index.c.html#LN1788"><span class='Ref_To_Local'>isNull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Index expression --- need to evaluate it. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN1770"><span class='Ref_To_Local'>indexpr_item</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>                <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"wrong number of index expressions"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="index.c.html#LN1787"><span class='Ref_To_Local'>iDatum</span></a> <span class='Operator'>= </span><a href="../../include/executor/executor.h.html#LN279"><span class='Ref_to_Func'>ExecEvalExprSwitchContext</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1770"><span class='Ref_To_Local'>indexpr_item</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                               <a href="../../include/executor/executor.h.html#LN455"><span class='Ref_to_Macro'>GetPerTupleExprContext</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1766"><span class='Ref_to_Parameter'>estate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                               <span class='Operator'>&</span><a href="index.c.html#LN1788"><span class='Ref_To_Local'>isNull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="index.c.html#LN1770"><span class='Ref_To_Local'>indexpr_item</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1770"><span class='Ref_To_Local'>indexpr_item</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <a href="index.c.html#LN1767"><span class='Ref_to_Parameter'>values</span></a><span class='Delimiter'>[</span><a href="index.c.html#LN1771"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="index.c.html#LN1787"><span class='Ref_To_Local'>iDatum</span></a><span class='Delimiter'>; 
</span>        <a href="index.c.html#LN1768"><span class='Ref_to_Parameter'>isnull</span></a><span class='Delimiter'>[</span><a href="index.c.html#LN1771"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="index.c.html#LN1788"><span class='Ref_To_Local'>isNull</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;indexInfo-&GT;ii_N... &raquo; </span> 
 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN1770"><span class='Ref_To_Local'>indexpr_item</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"wrong number of index expressions"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end FormIndexDatum &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * index_update_stats --- update pg_class entry after CREATE INDEX or REINDEX 
 * 
 * This routine updates the pg_class row of either an index or its parent 
 * relation after CREATE INDEX or REINDEX.  Its rather bizarre API is designed 
 * to ensure we can do all the necessary work in just one update. 
 * 
 * hasindex: set relhasindex to this value 
 * isprimary: if true, set relhaspkey true; else no change 
 * reltuples: if &GT;= 0, set reltuples to this value; else no change 
 * 
 * If reltuples &GT;= 0, relpages and relallvisible are also updated (using 
 * RelationGetNumberOfBlocks() and visibilitymap_count()). 
 * 
 * NOTE: an important side-effect of this operation is that an SI invalidation 
 * message is sent out to all backends --- including me --- causing relcache 
 * entries to be flushed or updated with the new data.  This must happen even 
 * if we find that no change is needed in the pg_class row.  When updating 
 * a heap entry, this ensures that other backends find out about the new 
 * index.  When updating an index, it's important because some index AMs 
 * expect a relcache flush to occur after REINDEX. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1842"></a><span class='Declare_Function'>index_update_stats</span><span class='Parentheses'>(</span><a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>rel</span><span class='Delimiter'>, 
</span><a name="LN1843"></a>                   <span class='Keyword'>bool </span><span class='Declare_Parameter'>hasindex</span><span class='Delimiter'>, 
</span><a name="LN1844"></a>                   <span class='Keyword'>bool </span><span class='Declare_Parameter'>isprimary</span><span class='Delimiter'>, 
</span><a name="LN1845"></a>                   <span class='Keyword'>double </span><span class='Declare_Parameter'>reltuples</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1847"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>relid</span> <span class='Operator'>= </span><a href="../../include/utils/rel.h.html#LN416"><span class='Ref_to_Macro'>RelationGetRelid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1842"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1848"></a>    <a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>pg_class</span><span class='Delimiter'>; 
</span><a name="LN1849"></a>    <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>tuple</span><span class='Delimiter'>; 
</span><a name="LN1850"></a>    <a href="../../include/catalog/pg_class.h.html#LN94"><span class='Ref_to_Typedef'>Form_pg_class</span></a> <span class='Declare_Local'>rd_rel</span><span class='Delimiter'>; 
</span><a name="LN1851"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>dirty</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We always update the pg_class row using a non-transactional, 
     * overwrite-in-place update.  There are several reasons for this: 
     * 
     * 1. In bootstrap mode, we have no choice --- UPDATE wouldn't work. 
     * 
     * 2. We could be reindexing pg_class itself, in which case we can't move 
     * its pg_class row because CatalogTupleInsert/CatalogTupleUpdate might 
     * not know about all the indexes yet (see reindex_relation). 
     * 
     * 3. Because we execute CREATE INDEX with just share lock on the parent 
     * rel (to allow concurrent index creations), an ordinary update could 
     * suffer a tuple-concurrently-updated failure against another CREATE 
     * INDEX committing at about the same time.  We can avoid that by having 
     * them both do nontransactional updates (we assume they will both be 
     * trying to change the pg_class row to the same thing, so it doesn't 
     * matter which goes first). 
     * 
     * It is safe to use a non-transactional update even though our 
     * transaction could still fail before committing.  Setting relhasindex 
     * true is safe even if there are no indexes (VACUUM will eventually fix 
     * it), likewise for relhaspkey.  And of course the new relpages and 
     * reltuples counts are correct regardless.  However, we don't want to 
     * change relpages (or relallvisible) if the caller isn't providing an 
     * updated reltuples count, because that would bollix the 
     * reltuples/relpages ratio which is what's really important. 
     */ 
</span> 
    <a href="index.c.html#LN1848"><span class='Ref_To_Local'>pg_class</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN91"><span class='Ref_to_Proto'>heap_open</span></a><span class='Parentheses'>(</span><a href="../../include/catalog/pg_class.h.html#LN28"><span class='Ref_to_Const'>RelationRelationId</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN37"><span class='Ref_to_Const'>RowExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Make a copy of the tuple to update.  Normally we use the syscache, but 
     * we can't rely on that during bootstrap or while reindexing pg_class 
     * itself. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/miscadmin.h.html#LN369"><span class='Ref_to_Macro'>IsBootstrapProcessingMode</span></a><span class='Parentheses'>() </span><span class='Operator'>|| 
</span>        <a href="../../include/catalog/index.h.html#LN129"><span class='Ref_to_Proto'>ReindexIsProcessingHeap</span></a><span class='Parentheses'>(</span><a href="../../include/catalog/pg_class.h.html#LN28"><span class='Ref_to_Const'>RelationRelationId</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* don't assume syscache will work */ 
</span><a name="LN1892"></a>        <a href="../../include/access/heapam.h.html#LN99"><span class='Ref_to_Typedef'>HeapScanDesc</span></a> <span class='Declare_Local'>pg_class_scan</span><span class='Delimiter'>; 
</span><a name="LN1893"></a>        <a href="../../include/access/skey.h.html#LN63"><span class='Ref_to_Struct'>ScanKeyData</span></a> <span class='Declare_Local'>key</span><span class='Delimiter'>[</span><span class='Number'>1</span><span class='Delimiter'>]; 
</span> 
        <a href="../access/common/scankey.c.html#LN74"><span class='Ref_to_Func'>ScanKeyInit</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="index.c.html#LN1893"><span class='Ref_To_Local'>key</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>], 
</span>                    <a href="../../include/access/sysattr.h.html#LN21"><span class='Ref_to_Const'>ObjectIdAttributeNumber</span></a><span class='Delimiter'>, 
</span>                    <a href="../../include/access/stratnum.h.html#LN30"><span class='Ref_to_Const'>BTEqualStrategyNumber</span></a><span class='Delimiter'>, </span>F_OIDEQ<span class='Delimiter'>, 
</span>                    <a href="../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1847"><span class='Ref_To_Local'>relid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <a href="index.c.html#LN1892"><span class='Ref_To_Local'>pg_class_scan</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN110"><span class='Ref_to_Proto'>heap_beginscan_catalog</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1848"><span class='Ref_To_Local'>pg_class</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Delimiter'>, </span><a href="index.c.html#LN1893"><span class='Ref_To_Local'>key</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="index.c.html#LN1849"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN127"><span class='Ref_to_Proto'>heap_getnext</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1892"><span class='Ref_To_Local'>pg_class_scan</span></a><span class='Delimiter'>, </span><a href="../../include/access/sdir.h.html#LN25"><span class='Ref_to_EnumConst'>ForwardScanDirection</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="index.c.html#LN1849"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>= </span><a href="../access/common/heaptuple.c.html#LN606"><span class='Ref_to_Func'>heap_copytuple</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1849"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/access/heapam.h.html#LN126"><span class='Ref_to_Proto'>heap_endscan</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1892"><span class='Ref_To_Local'>pg_class_scan</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* normal case, use syscache */ 
</span>        <a href="index.c.html#LN1849"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>= </span><a href="../../include/utils/syscache.h.html#LN164"><span class='Ref_to_Macro'>SearchSysCacheCopy1</span></a><span class='Parentheses'>(</span><a href="../../include/utils/syscache.h.html#LN83"><span class='Ref_to_EnumConst'>RELOID</span></a><span class='Delimiter'>, </span><a href="../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1847"><span class='Ref_To_Local'>relid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1849"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>))</span> 
        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"could not find tuple for relation %u"</span><span class='Delimiter'>, </span><a href="index.c.html#LN1847"><span class='Ref_To_Local'>relid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN1850"><span class='Ref_To_Local'>rd_rel</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/catalog/pg_class.h.html#LN94"><span class='Ref_to_Typedef'>Form_pg_class</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1849"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Apply required updates, if any, to copied tuple */ 
</span> 
    <a href="index.c.html#LN1851"><span class='Ref_To_Local'>dirty</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN1850"><span class='Ref_To_Local'>rd_rel</span></a><span class='Operator'>-&GT;</span>relhasindex <span class='Operator'>!= </span><a href="index.c.html#LN1843"><span class='Ref_to_Parameter'>hasindex</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="index.c.html#LN1850"><span class='Ref_To_Local'>rd_rel</span></a><span class='Operator'>-&GT;</span>relhasindex <span class='Operator'>= </span><a href="index.c.html#LN1843"><span class='Ref_to_Parameter'>hasindex</span></a><span class='Delimiter'>; 
</span>        <a href="index.c.html#LN1851"><span class='Ref_To_Local'>dirty</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN1844"><span class='Ref_to_Parameter'>isprimary</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="index.c.html#LN1850"><span class='Ref_To_Local'>rd_rel</span></a><span class='Operator'>-&GT;</span>relhaspkey<span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="index.c.html#LN1850"><span class='Ref_To_Local'>rd_rel</span></a><span class='Operator'>-&GT;</span>relhaspkey <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <a href="index.c.html#LN1851"><span class='Ref_To_Local'>dirty</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN1845"><span class='Ref_to_Parameter'>reltuples</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1934"></a>        <a href="../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Local'>relpages</span> <span class='Operator'>= </span><a href="../../include/storage/bufmgr.h.html#LN198"><span class='Ref_to_Macro'>RelationGetNumberOfBlocks</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1842"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1935"></a>        <a href="../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Local'>relallvisible</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN1850"><span class='Ref_To_Local'>rd_rel</span></a><span class='Operator'>-&GT;</span>relkind <span class='Operator'>!= </span><a href="../../include/catalog/pg_class.h.html#LN160"><span class='Ref_to_Const'>RELKIND_INDEX</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/access/visibilitymap.h.html#LN45"><span class='Ref_to_Proto'>visibilitymap_count</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1842"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="index.c.html#LN1935"><span class='Ref_To_Local'>relallvisible</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span>    <span class='Comment_Single_Line'>/* don't bother for indexes */ 
</span>            <a href="index.c.html#LN1935"><span class='Ref_To_Local'>relallvisible</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN1850"><span class='Ref_To_Local'>rd_rel</span></a><span class='Operator'>-&GT;</span>relpages <span class='Operator'>!= </span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a><span class='Parentheses'>) </span><a href="index.c.html#LN1934"><span class='Ref_To_Local'>relpages</span></a><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <a href="index.c.html#LN1850"><span class='Ref_To_Local'>rd_rel</span></a><span class='Operator'>-&GT;</span>relpages <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a><span class='Parentheses'>) </span><a href="index.c.html#LN1934"><span class='Ref_To_Local'>relpages</span></a><span class='Delimiter'>; 
</span>            <a href="index.c.html#LN1851"><span class='Ref_To_Local'>dirty</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN1850"><span class='Ref_To_Local'>rd_rel</span></a><span class='Operator'>-&GT;</span>reltuples <span class='Operator'>!= </span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN379"><span class='Ref_to_Typedef'>float4</span></a><span class='Parentheses'>) </span><a href="index.c.html#LN1845"><span class='Ref_to_Parameter'>reltuples</span></a><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <a href="index.c.html#LN1850"><span class='Ref_To_Local'>rd_rel</span></a><span class='Operator'>-&GT;</span>reltuples <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN379"><span class='Ref_to_Typedef'>float4</span></a><span class='Parentheses'>) </span><a href="index.c.html#LN1845"><span class='Ref_to_Parameter'>reltuples</span></a><span class='Delimiter'>; 
</span>            <a href="index.c.html#LN1851"><span class='Ref_To_Local'>dirty</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN1850"><span class='Ref_To_Local'>rd_rel</span></a><span class='Operator'>-&GT;</span>relallvisible <span class='Operator'>!= </span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a><span class='Parentheses'>) </span><a href="index.c.html#LN1935"><span class='Ref_To_Local'>relallvisible</span></a><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <a href="index.c.html#LN1850"><span class='Ref_To_Local'>rd_rel</span></a><span class='Operator'>-&GT;</span>relallvisible <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a><span class='Parentheses'>) </span><a href="index.c.html#LN1935"><span class='Ref_To_Local'>relallvisible</span></a><span class='Delimiter'>; 
</span>            <a href="index.c.html#LN1851"><span class='Ref_To_Local'>dirty</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if reltuples&GT;=0 &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * If anything changed, write out the tuple 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN1851"><span class='Ref_To_Local'>dirty</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../include/access/heapam.h.html#LN168"><span class='Ref_to_Proto'>heap_inplace_update</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1848"><span class='Ref_To_Local'>pg_class</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN1849"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* the above sends a cache inval message */ 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* no need to change tuple, but force relcache inval anyway */ 
</span>        <a href="../../include/utils/inval.h.html#LN47"><span class='Ref_to_Proto'>CacheInvalidateRelcacheByTuple</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1849"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../include/access/htup_details.h.html#LN815"><span class='Ref_to_Proto'>heap_freetuple</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1849"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/access/heapam.h.html#LN96"><span class='Ref_to_Macro'>heap_close</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1848"><span class='Ref_To_Local'>pg_class</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN37"><span class='Ref_to_Const'>RowExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end index_update_stats &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * index_build - invoke access-method-specific index build procedure 
 * 
 * On entry, the index's catalog entries are valid, and its physical disk 
 * file has been created but is empty.  We call the AM-specific build 
 * procedure to fill in the index contents.  We then update the pg_class 
 * entries of the index and heap relation as needed, using statistics 
 * returned by ambuild as well as data passed by the caller. 
 * 
 * isprimary tells whether to mark the index as a primary-key index. 
 * isreindex indicates we are recreating a previously-existing index. 
 * 
 * Note: when reindexing an existing index, isprimary can be false even if 
 * the index is a PK; it's already properly marked and need not be re-marked. 
 * 
 * Note: before Postgres 8.2, the passed-in heap and index Relations 
 * were automatically closed by this routine.  This is no longer the case. 
 * The caller opened 'em, and the caller should close 'em. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1999"></a><span class='Declare_Function'>index_build</span><span class='Parentheses'>(</span><a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>heapRelation</span><span class='Delimiter'>, 
</span><a name="LN2000"></a>            <a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>indexRelation</span><span class='Delimiter'>, 
</span><a name="LN2001"></a>            <a href="../../include/nodes/execnodes.h.html#LN130"><span class='Ref_to_Struct'>IndexInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>indexInfo</span><span class='Delimiter'>, 
</span><a name="LN2002"></a>            <span class='Keyword'>bool </span><span class='Declare_Parameter'>isprimary</span><span class='Delimiter'>, 
</span><a name="LN2003"></a>            <span class='Keyword'>bool </span><span class='Declare_Parameter'>isreindex</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2005"></a>    <a href="../../include/access/genam.h.html#LN29"><span class='Ref_to_Struct'>IndexBuildResult</span></a> <span class='Operator'>*</span><span class='Declare_Local'>stats</span><span class='Delimiter'>; 
</span><a name="LN2006"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>save_userid</span><span class='Delimiter'>; 
</span><a name="LN2007"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>save_sec_context</span><span class='Delimiter'>; 
</span><a name="LN2008"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>save_nestlevel</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * sanity checks 
     */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../include/utils/rel.h.html#LN389"><span class='Ref_to_Macro'>RelationIsValid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2000"><span class='Ref_to_Parameter'>indexRelation</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN525"><span class='Ref_to_Macro'>PointerIsValid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2000"><span class='Ref_to_Parameter'>indexRelation</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN180"><span class='Ref_to_Member'>rd_amroutine</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN525"><span class='Ref_to_Macro'>PointerIsValid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2000"><span class='Ref_to_Parameter'>indexRelation</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN180"><span class='Ref_to_Member'>rd_amroutine</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/amapi.h.html#LN197"><span class='Ref_to_Member'>ambuild</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN525"><span class='Ref_to_Macro'>PointerIsValid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2000"><span class='Ref_to_Parameter'>indexRelation</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN180"><span class='Ref_to_Member'>rd_amroutine</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/amapi.h.html#LN198"><span class='Ref_to_Member'>ambuildempty</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN24"><span class='Ref_to_Const'>DEBUG1</span></a><span class='Delimiter'>, 
</span>            <span class='Parentheses'>(</span><a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"building index \"%s\" on table \"%s\""</span><span class='Delimiter'>, 
</span>                    <a href="../../include/utils/rel.h.html#LN436"><span class='Ref_to_Macro'>RelationGetRelationName</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2000"><span class='Ref_to_Parameter'>indexRelation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                    <a href="../../include/utils/rel.h.html#LN436"><span class='Ref_to_Macro'>RelationGetRelationName</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1999"><span class='Ref_to_Parameter'>heapRelation</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Switch to the table owner's userid, so that any index functions are run 
     * as that user.  Also lock down security-restricted operations and 
     * arrange to make GUC variable changes local to this command. 
     */ 
</span>    <a href="../../include/miscadmin.h.html#LN312"><span class='Ref_to_Proto'>GetUserIdAndSecContext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="index.c.html#LN2006"><span class='Ref_To_Local'>save_userid</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="index.c.html#LN2007"><span class='Ref_To_Local'>save_sec_context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/miscadmin.h.html#LN313"><span class='Ref_to_Proto'>SetUserIdAndSecContext</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1999"><span class='Ref_to_Parameter'>heapRelation</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relowner<span class='Delimiter'>, 
</span>                           <a href="index.c.html#LN2007"><span class='Ref_To_Local'>save_sec_context</span></a> <span class='Operator'>| </span><a href="../../include/miscadmin.h.html#LN296"><span class='Ref_to_Const'>SECURITY_RESTRICTED_OPERATION</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN2008"><span class='Ref_To_Local'>save_nestlevel</span></a> <span class='Operator'>= </span><a href="../../include/utils/guc.h.html#LN354"><span class='Ref_to_Proto'>NewGUCNestLevel</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Call the access method's build procedure 
     */ 
</span>    <a href="index.c.html#LN2005"><span class='Ref_To_Local'>stats</span></a> <span class='Operator'>= </span><a href="index.c.html#LN2000"><span class='Ref_to_Parameter'>indexRelation</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN180"><span class='Ref_to_Member'>rd_amroutine</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/amapi.h.html#LN197"><span class='Ref_to_Member'>ambuild</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1999"><span class='Ref_to_Parameter'>heapRelation</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN2000"><span class='Ref_to_Parameter'>indexRelation</span></a><span class='Delimiter'>, 
</span>                                                 <a href="index.c.html#LN2001"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN525"><span class='Ref_to_Macro'>PointerIsValid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2005"><span class='Ref_To_Local'>stats</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If this is an unlogged index, we may need to write out an init fork for 
     * it -- but we must first check whether one already exists.  If, for 
     * example, an unlogged relation is truncated in the transaction that 
     * created it, or truncated twice in a subsequent transaction, the 
     * relfilenode won't change, and nothing needs to be done here. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN2000"><span class='Ref_to_Parameter'>indexRelation</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relpersistence <span class='Operator'>== </span><a href="../../include/catalog/pg_class.h.html#LN170"><span class='Ref_to_Const'>RELPERSISTENCE_UNLOGGED</span></a> <span class='Operator'>&& 
</span>        <span class='Operator'>!</span><a href="../../include/storage/smgr.h.html#LN84"><span class='Ref_to_Proto'>smgrexists</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2000"><span class='Ref_to_Parameter'>indexRelation</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN86"><span class='Ref_to_Member'>rd_smgr</span></a><span class='Delimiter'>, </span><a href="../../include/common/relpath.h.html#LN29"><span class='Ref_to_EnumConst'>INIT_FORKNUM</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../include/utils/rel.h.html#LN460"><span class='Ref_to_Macro'>RelationOpenSmgr</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2000"><span class='Ref_to_Parameter'>indexRelation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/storage/smgr.h.html#LN90"><span class='Ref_to_Proto'>smgrcreate</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2000"><span class='Ref_to_Parameter'>indexRelation</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN86"><span class='Ref_to_Member'>rd_smgr</span></a><span class='Delimiter'>, </span><a href="../../include/common/relpath.h.html#LN29"><span class='Ref_to_EnumConst'>INIT_FORKNUM</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="index.c.html#LN2000"><span class='Ref_to_Parameter'>indexRelation</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN180"><span class='Ref_to_Member'>rd_amroutine</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/amapi.h.html#LN198"><span class='Ref_to_Member'>ambuildempty</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2000"><span class='Ref_to_Parameter'>indexRelation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we found any potentially broken HOT chains, mark the index as not 
     * being usable until the current transaction is below the event horizon. 
     * See src/backend/access/heap/README.HOT for discussion.  Also set this 
     * if early pruning/vacuuming is enabled for the heap relation.  While it 
     * might become safe to use the index earlier based on actual cleanup 
     * activity and other active transactions, the test for that would be much 
     * more complex and would require some form of blocking, so keep it simple 
     * and fast by just using the current transaction. 
     * 
     * However, when reindexing an existing index, we should do nothing here. 
     * Any HOT chains that are broken with respect to the index must predate 
     * the index's original creation, so there is no need to change the 
     * index's usability horizon.  Moreover, we *must not* try to change the 
     * index's pg_index entry while reindexing pg_index itself, and this 
     * optimization nicely prevents that.  The more complex rules needed for a 
     * reindex are handled separately after this function returns. 
     * 
     * We also need not set indcheckxmin during a concurrent index build, 
     * because we won't set indisvalid true until all transactions that care 
     * about the broken HOT chains or early pruning/vacuuming are gone. 
     * 
     * Therefore, this code path can only be taken during non-concurrent 
     * CREATE INDEX.  Thus the fact that heap_update will set the pg_index 
     * tuple's xmin doesn't matter, because that tuple was created in the 
     * current transaction anyway.  That also means we don't need to worry 
     * about any concurrent readers of the tuple; no other transaction can see 
     * it yet. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="index.c.html#LN2001"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN148"><span class='Ref_to_Member'>ii_BrokenHotChain</span></a> <span class='Operator'>|| </span><a href="../../include/utils/snapmgr.h.html#LN45"><span class='Ref_to_Macro'>EarlyPruningEnabled</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1999"><span class='Ref_to_Parameter'>heapRelation</span></a><span class='Parentheses'>))</span> <span class='Operator'>&& 
</span>        <span class='Operator'>!</span><a href="index.c.html#LN2003"><span class='Ref_to_Parameter'>isreindex</span></a> <span class='Operator'>&& 
</span>        <span class='Operator'>!</span><a href="index.c.html#LN2001"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN147"><span class='Ref_to_Member'>ii_Concurrent</span></a><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span><a name="LN2088"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>indexId</span> <span class='Operator'>= </span><a href="../../include/utils/rel.h.html#LN416"><span class='Ref_to_Macro'>RelationGetRelid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2000"><span class='Ref_to_Parameter'>indexRelation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2089"></a>        <a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>pg_index</span><span class='Delimiter'>; 
</span><a name="LN2090"></a>        <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>indexTuple</span><span class='Delimiter'>; 
</span><a name="LN2091"></a>        <a href="../../include/catalog/pg_index.h.html#LN66"><span class='Ref_to_Typedef'>Form_pg_index</span></a> <span class='Declare_Local'>indexForm</span><span class='Delimiter'>; 
</span> 
        <a href="index.c.html#LN2089"><span class='Ref_To_Local'>pg_index</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN91"><span class='Ref_to_Proto'>heap_open</span></a><span class='Parentheses'>(</span><a href="../../include/catalog/pg_index.h.html#LN28"><span class='Ref_to_Const'>IndexRelationId</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN37"><span class='Ref_to_Const'>RowExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="index.c.html#LN2090"><span class='Ref_To_Local'>indexTuple</span></a> <span class='Operator'>= </span><a href="../../include/utils/syscache.h.html#LN164"><span class='Ref_to_Macro'>SearchSysCacheCopy1</span></a><span class='Parentheses'>(</span><a href="../../include/utils/syscache.h.html#LN65"><span class='Ref_to_EnumConst'>INDEXRELID</span></a><span class='Delimiter'>, 
</span>                                         <a href="../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2088"><span class='Ref_To_Local'>indexId</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2090"><span class='Ref_To_Local'>indexTuple</span></a><span class='Parentheses'>))</span> 
            <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cache lookup failed for index %u"</span><span class='Delimiter'>, </span><a href="index.c.html#LN2088"><span class='Ref_To_Local'>indexId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="index.c.html#LN2091"><span class='Ref_To_Local'>indexForm</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/catalog/pg_index.h.html#LN66"><span class='Ref_to_Typedef'>Form_pg_index</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2090"><span class='Ref_To_Local'>indexTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* If it's a new index, indcheckxmin shouldn't be set ... */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="index.c.html#LN2091"><span class='Ref_To_Local'>indexForm</span></a><span class='Operator'>-&GT;</span>indcheckxmin<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="index.c.html#LN2091"><span class='Ref_To_Local'>indexForm</span></a><span class='Operator'>-&GT;</span>indcheckxmin <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <a href="../../include/catalog/indexing.h.html#LN35"><span class='Ref_to_Proto'>CatalogTupleUpdate</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2089"><span class='Ref_To_Local'>pg_index</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="index.c.html#LN2090"><span class='Ref_To_Local'>indexTuple</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/htup.h.html#LN64"><span class='Ref_to_Member'>t_self</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN2090"><span class='Ref_To_Local'>indexTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/access/htup_details.h.html#LN815"><span class='Ref_to_Proto'>heap_freetuple</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2090"><span class='Ref_To_Local'>indexTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/access/heapam.h.html#LN96"><span class='Ref_to_Macro'>heap_close</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2089"><span class='Ref_To_Local'>pg_index</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN37"><span class='Ref_to_Const'>RowExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if (indexInfo-&GT;ii_Broken... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Update heap and index pg_class rows 
     */ 
</span>    <a href="index.c.html#LN108"><span class='Ref_to_Proto'>index_update_stats</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1999"><span class='Ref_to_Parameter'>heapRelation</span></a><span class='Delimiter'>, 
</span>                       <span class='Boolean'>true</span><span class='Delimiter'>, 
</span>                       <a href="index.c.html#LN2002"><span class='Ref_to_Parameter'>isprimary</span></a><span class='Delimiter'>, 
</span>                       <a href="index.c.html#LN2005"><span class='Ref_To_Local'>stats</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/genam.h.html#LN31"><span class='Ref_to_Member'>heap_tuples</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="index.c.html#LN108"><span class='Ref_to_Proto'>index_update_stats</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2000"><span class='Ref_to_Parameter'>indexRelation</span></a><span class='Delimiter'>, 
</span>                       <span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                       <span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                       <a href="index.c.html#LN2005"><span class='Ref_To_Local'>stats</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/genam.h.html#LN32"><span class='Ref_to_Member'>index_tuples</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Make the updated catalog row versions visible */ 
</span>    <a href="../../include/access/xact.h.html#LN346"><span class='Ref_to_Proto'>CommandCounterIncrement</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If it's for an exclusion constraint, make a second pass over the heap 
     * to verify that the constraint is satisfied.  We must not do this until 
     * the index is fully valid.  (Broken HOT chains shouldn't matter, though; 
     * see comments for IndexCheckExclusion.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN2001"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN139"><span class='Ref_to_Member'>ii_ExclusionOps</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="index.c.html#LN111"><span class='Ref_to_Proto'>IndexCheckExclusion</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN1999"><span class='Ref_to_Parameter'>heapRelation</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN2000"><span class='Ref_to_Parameter'>indexRelation</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN2001"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Roll back any GUC changes executed by index functions */ 
</span>    <a href="../../include/utils/guc.h.html#LN355"><span class='Ref_to_Proto'>AtEOXact_GUC</span></a><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Delimiter'>, </span><a href="index.c.html#LN2008"><span class='Ref_To_Local'>save_nestlevel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Restore userid and security context */ 
</span>    <a href="../../include/miscadmin.h.html#LN313"><span class='Ref_to_Proto'>SetUserIdAndSecContext</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2006"><span class='Ref_To_Local'>save_userid</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN2007"><span class='Ref_To_Local'>save_sec_context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end index_build &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * IndexBuildHeapScan - scan the heap relation to find tuples to be indexed 
 * 
 * This is called back from an access-method-specific index build procedure 
 * after the AM has done whatever setup it needs.  The parent heap relation 
 * is scanned to find tuples that should be entered into the index.  Each 
 * such tuple is passed to the AM's callback routine, which does the right 
 * things to add it to the new index.  After we return, the AM's index 
 * build procedure does whatever cleanup it needs. 
 * 
 * The total count of heap tuples is returned.  This is for updating pg_class 
 * statistics.  (It's annoying not to be able to do that here, but we want 
 * to merge that update with others; see index_update_stats.)  Note that the 
 * index AM itself must keep track of the number of index tuples; we don't do 
 * so here because the AM might reject some of the tuples for its own reasons, 
 * such as being unable to store NULLs. 
 * 
 * A side effect is to set indexInfo-&GT;ii_BrokenHotChain to true if we detect 
 * any potentially broken HOT chains.  Currently, we set this if there are 
 * any RECENTLY_DEAD or DELETE_IN_PROGRESS entries in a HOT chain, without 
 * trying very hard to detect whether they're really incompatible with the 
 * chain tip. 
 */ 
</span><span class='Keyword'>double 
</span><a name="LN2168"></a><span class='Declare_Function'>IndexBuildHeapScan</span><span class='Parentheses'>(</span><a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>heapRelation</span><span class='Delimiter'>, 
</span><a name="LN2169"></a>                   <a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>indexRelation</span><span class='Delimiter'>, 
</span><a name="LN2170"></a>                   <a href="../../include/nodes/execnodes.h.html#LN130"><span class='Ref_to_Struct'>IndexInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>indexInfo</span><span class='Delimiter'>, 
</span><a name="LN2171"></a>                   <span class='Keyword'>bool </span><span class='Declare_Parameter'>allow_sync</span><span class='Delimiter'>, 
</span><a name="LN2172"></a>                   <a href="../../include/catalog/index.h.html#LN23"><span class='Ref_to_Typedef'>IndexBuildCallback</span></a> <span class='Declare_Parameter'>callback</span><span class='Delimiter'>, 
</span><a name="LN2173"></a>                   <span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>callback_state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <a href="../../include/catalog/index.h.html#LN103"><span class='Ref_to_Proto'>IndexBuildHeapRangeScan</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2168"><span class='Ref_to_Parameter'>heapRelation</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN2169"><span class='Ref_to_Parameter'>indexRelation</span></a><span class='Delimiter'>, 
</span>                                   <a href="index.c.html#LN2170"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN2171"><span class='Ref_to_Parameter'>allow_sync</span></a><span class='Delimiter'>, 
</span>                                   <span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                                   <span class='Number'>0</span><span class='Delimiter'>, </span><a href="../../include/storage/block.h.html#LN32"><span class='Ref_to_Const'>InvalidBlockNumber</span></a><span class='Delimiter'>, 
</span>                                   <a href="index.c.html#LN2172"><span class='Ref_to_Parameter'>callback</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN2173"><span class='Ref_to_Parameter'>callback_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * As above, except that instead of scanning the complete heap, only the given 
 * number of blocks are scanned.  Scan to end-of-rel can be signalled by 
 * passing InvalidBlockNumber as numblocks.  Note that restricting the range 
 * to scan cannot be done when requesting syncscan. 
 * 
 * When "anyvisible" mode is requested, all tuples visible to any transaction 
 * are considered, including those inserted or deleted by transactions that are 
 * still in progress. 
 */ 
</span><span class='Keyword'>double 
</span><a name="LN2193"></a><span class='Declare_Function'>IndexBuildHeapRangeScan</span><span class='Parentheses'>(</span><a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>heapRelation</span><span class='Delimiter'>, 
</span><a name="LN2194"></a>                        <a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>indexRelation</span><span class='Delimiter'>, 
</span><a name="LN2195"></a>                        <a href="../../include/nodes/execnodes.h.html#LN130"><span class='Ref_to_Struct'>IndexInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>indexInfo</span><span class='Delimiter'>, 
</span><a name="LN2196"></a>                        <span class='Keyword'>bool </span><span class='Declare_Parameter'>allow_sync</span><span class='Delimiter'>, 
</span><a name="LN2197"></a>                        <span class='Keyword'>bool </span><span class='Declare_Parameter'>anyvisible</span><span class='Delimiter'>, 
</span><a name="LN2198"></a>                        <a href="../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Parameter'>start_blockno</span><span class='Delimiter'>, 
</span><a name="LN2199"></a>                        <a href="../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Parameter'>numblocks</span><span class='Delimiter'>, 
</span><a name="LN2200"></a>                        <a href="../../include/catalog/index.h.html#LN23"><span class='Ref_to_Typedef'>IndexBuildCallback</span></a> <span class='Declare_Parameter'>callback</span><span class='Delimiter'>, 
</span><a name="LN2201"></a>                        <span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>callback_state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2203"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>is_system_catalog</span><span class='Delimiter'>; 
</span><a name="LN2204"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>checking_uniqueness</span><span class='Delimiter'>; 
</span><a name="LN2205"></a>    <a href="../../include/access/heapam.h.html#LN99"><span class='Ref_to_Typedef'>HeapScanDesc</span></a> <span class='Declare_Local'>scan</span><span class='Delimiter'>; 
</span><a name="LN2206"></a>    <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>heapTuple</span><span class='Delimiter'>; 
</span><a name="LN2207"></a>    <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>values</span><span class='Delimiter'>[</span><a href="../../include/pg_config_manual.h.html#LN45"><span class='Ref_to_Const'>INDEX_MAX_KEYS</span></a><span class='Delimiter'>]; 
</span><a name="LN2208"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>isnull</span><span class='Delimiter'>[</span><a href="../../include/pg_config_manual.h.html#LN45"><span class='Ref_to_Const'>INDEX_MAX_KEYS</span></a><span class='Delimiter'>]; 
</span><a name="LN2209"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>reltuples</span><span class='Delimiter'>; 
</span><a name="LN2210"></a>    <a href="../../include/nodes/execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>predicate</span><span class='Delimiter'>; 
</span><a name="LN2211"></a>    <a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Local'>slot</span><span class='Delimiter'>; 
</span><a name="LN2212"></a>    <a href="../../include/nodes/execnodes.h.html#LN402"><span class='Ref_to_Struct'>EState</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>estate</span><span class='Delimiter'>; 
</span><a name="LN2213"></a>    <a href="../../include/nodes/execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Local'>econtext</span><span class='Delimiter'>; 
</span><a name="LN2214"></a>    <a href="../../include/utils/snapshot.h.html#LN22"><span class='Ref_to_Typedef'>Snapshot</span></a>    <span class='Declare_Local'>snapshot</span><span class='Delimiter'>; 
</span><a name="LN2215"></a>    <a href="../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>OldestXmin</span><span class='Delimiter'>; 
</span><a name="LN2216"></a>    <a href="../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Local'>root_blkno</span> <span class='Operator'>= </span><a href="../../include/storage/block.h.html#LN32"><span class='Ref_to_Const'>InvalidBlockNumber</span></a><span class='Delimiter'>; 
</span><a name="LN2217"></a>    <a href="../../include/storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Local'>root_offsets</span><span class='Delimiter'>[</span><a href="../../include/access/htup_details.h.html#LN574"><span class='Ref_to_Const'>MaxHeapTuplesPerPage</span></a><span class='Delimiter'>]; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * sanity checks 
     */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2194"><span class='Ref_to_Parameter'>indexRelation</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relam<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Remember if it's a system catalog */ 
</span>    <a href="index.c.html#LN2203"><span class='Ref_To_Local'>is_system_catalog</span></a> <span class='Operator'>= </span><a href="../../include/catalog/catalog.h.html#LN29"><span class='Ref_to_Proto'>IsSystemRelation</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2193"><span class='Ref_to_Parameter'>heapRelation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* See whether we're verifying uniqueness/exclusion properties */ 
</span>    <a href="index.c.html#LN2204"><span class='Ref_To_Local'>checking_uniqueness</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="index.c.html#LN2195"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN145"><span class='Ref_to_Member'>ii_Unique</span></a> <span class='Operator'>|| 
</span>                           <a href="index.c.html#LN2195"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN139"><span class='Ref_to_Member'>ii_ExclusionOps</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * "Any visible" mode is not compatible with uniqueness checks; make sure 
     * only one of those is requested. 
     */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span><a href="index.c.html#LN2197"><span class='Ref_to_Parameter'>anyvisible</span></a> <span class='Operator'>&& </span><a href="index.c.html#LN2204"><span class='Ref_To_Local'>checking_uniqueness</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Need an EState for evaluation of index expressions and partial-index 
     * predicates.  Also a slot to hold the current tuple. 
     */ 
</span>    <a href="index.c.html#LN2212"><span class='Ref_To_Local'>estate</span></a> <span class='Operator'>= </span><a href="../executor/execUtils.c.html#LN78"><span class='Ref_to_Func'>CreateExecutorState</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN2213"><span class='Ref_To_Local'>econtext</span></a> <span class='Operator'>= </span><a href="../../include/executor/executor.h.html#LN455"><span class='Ref_to_Macro'>GetPerTupleExprContext</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2212"><span class='Ref_To_Local'>estate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN2211"><span class='Ref_To_Local'>slot</span></a> <span class='Operator'>= </span><a href="../../include/executor/tuptable.h.html#LN144"><span class='Ref_to_Proto'>MakeSingleTupleTableSlot</span></a><span class='Parentheses'>(</span><a href="../../include/utils/rel.h.html#LN428"><span class='Ref_to_Macro'>RelationGetDescr</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2193"><span class='Ref_to_Parameter'>heapRelation</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Arrange for econtext's scan tuple to be the tuple under test */ 
</span>    <a href="index.c.html#LN2213"><span class='Ref_To_Local'>econtext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN196"><span class='Ref_to_Member'>ecxt_scantuple</span></a> <span class='Operator'>= </span><a href="index.c.html#LN2211"><span class='Ref_To_Local'>slot</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Set up execution state for predicate, if any. */ 
</span>    <a href="index.c.html#LN2210"><span class='Ref_To_Local'>predicate</span></a> <span class='Operator'>= </span><a href="../../include/executor/executor.h.html#LN247"><span class='Ref_to_Proto'>ExecPrepareQual</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2195"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN137"><span class='Ref_to_Member'>ii_Predicate</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN2212"><span class='Ref_To_Local'>estate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Prepare for scan of the base relation.  In a normal index build, we use 
     * SnapshotAny because we must retrieve all tuples and do our own time 
     * qual checks (because we have to index RECENTLY_DEAD tuples). In a 
     * concurrent build, or during bootstrap, we take a regular MVCC snapshot 
     * and index whatever's live according to that. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/miscadmin.h.html#LN369"><span class='Ref_to_Macro'>IsBootstrapProcessingMode</span></a><span class='Parentheses'>() </span><span class='Operator'>|| </span><a href="index.c.html#LN2195"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN147"><span class='Ref_to_Member'>ii_Concurrent</span></a><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <a href="index.c.html#LN2214"><span class='Ref_To_Local'>snapshot</span></a> <span class='Operator'>= </span><a href="../../include/utils/snapmgr.h.html#LN80"><span class='Ref_to_Proto'>RegisterSnapshot</span></a><span class='Parentheses'>(</span><a href="../../include/utils/snapmgr.h.html#LN63"><span class='Ref_to_Proto'>GetTransactionSnapshot</span></a><span class='Parentheses'>())</span><span class='Delimiter'>; 
</span>        <a href="index.c.html#LN2215"><span class='Ref_To_Local'>OldestXmin</span></a> <span class='Operator'>= </span><a href="../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* not used */ 
</span> 
        <span class='Comment_Multi_Line'>/* "any visible" mode is not compatible with this */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="index.c.html#LN2197"><span class='Ref_to_Parameter'>anyvisible</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="index.c.html#LN2214"><span class='Ref_To_Local'>snapshot</span></a> <span class='Operator'>= </span><a href="../../include/utils/tqual.h.html#LN27"><span class='Ref_to_Const'>SnapshotAny</span></a><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* okay to ignore lazy VACUUMs here */ 
</span>        <a href="index.c.html#LN2215"><span class='Ref_To_Local'>OldestXmin</span></a> <span class='Operator'>= </span><a href="../../include/storage/procarray.h.html#LN91"><span class='Ref_to_Proto'>GetOldestXmin</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2193"><span class='Ref_to_Parameter'>heapRelation</span></a><span class='Delimiter'>, </span><a href="../../include/storage/procarray.h.html#LN52"><span class='Ref_to_Const'>PROCARRAY_FLAGS_VACUUM</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="index.c.html#LN2205"><span class='Ref_To_Local'>scan</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN112"><span class='Ref_to_Proto'>heap_beginscan_strat</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2193"><span class='Ref_to_Parameter'>heapRelation</span></a><span class='Delimiter'>,</span>   <span class='Comment_Single_Line'>/* relation */ 
</span>                                <a href="index.c.html#LN2214"><span class='Ref_To_Local'>snapshot</span></a><span class='Delimiter'>,</span>       <span class='Comment_Single_Line'>/* snapshot */ 
</span>                                <span class='Number'>0</span><span class='Delimiter'>,</span>      <span class='Comment_Single_Line'>/* number of keys */ 
</span>                                <span class='Null_Value'>NULL</span><span class='Delimiter'>,</span>   <span class='Comment_Single_Line'>/* scan key */ 
</span>                                <span class='Boolean'>true</span><span class='Delimiter'>,</span>   <span class='Comment_Single_Line'>/* buffer access strategy OK */ 
</span>                                <a href="index.c.html#LN2196"><span class='Ref_to_Parameter'>allow_sync</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* syncscan OK? */ 
</span> 
    <span class='Comment_Multi_Line'>/* set our scan endpoints */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="index.c.html#LN2196"><span class='Ref_to_Parameter'>allow_sync</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/access/heapam.h.html#LN120"><span class='Ref_to_Proto'>heap_setscanlimits</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2205"><span class='Ref_To_Local'>scan</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN2198"><span class='Ref_to_Parameter'>start_blockno</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN2199"><span class='Ref_to_Parameter'>numblocks</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* syncscan can only be requested on whole relation */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="index.c.html#LN2198"><span class='Ref_to_Parameter'>start_blockno</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="index.c.html#LN2199"><span class='Ref_to_Parameter'>numblocks</span></a> <span class='Operator'>== </span><a href="../../include/storage/block.h.html#LN32"><span class='Ref_to_Const'>InvalidBlockNumber</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="index.c.html#LN2209"><span class='Ref_To_Local'>reltuples</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Scan all tuples in the base relation. 
     */ 
</span>    <span class='Control'>while</span> <span class='Parentheses'>((</span><a href="index.c.html#LN2206"><span class='Ref_To_Local'>heapTuple</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN127"><span class='Ref_to_Proto'>heap_getnext</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2205"><span class='Ref_To_Local'>scan</span></a><span class='Delimiter'>, </span><a href="../../include/access/sdir.h.html#LN25"><span class='Ref_to_EnumConst'>ForwardScanDirection</span></a><span class='Parentheses'>))</span> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span><a name="LN2297"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>tupleIsAlive</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/miscadmin.h.html#LN99"><span class='Ref_to_Macro'>CHECK_FOR_INTERRUPTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * When dealing with a HOT-chain of updated tuples, we want to index 
         * the values of the live tuple (if any), but index it under the TID 
         * of the chain's root tuple.  This approach is necessary to preserve 
         * the HOT-chain structure in the heap. So we need to be able to find 
         * the root item offset for every tuple that's in a HOT-chain.  When 
         * first reaching a new page of the relation, call 
         * heap_get_root_tuples() to build a map of root item offsets on the 
         * page. 
         * 
         * It might look unsafe to use this information across buffer 
         * lock/unlock.  However, we hold ShareLock on the table so no 
         * ordinary insert/update/delete should occur; and we hold pin on the 
         * buffer continuously while visiting the page, so no pruning 
         * operation can occur either. 
         * 
         * Also, although our opinions about tuple liveness could change while 
         * we scan the page (due to concurrent transaction commits/aborts), 
         * the chain root locations won't, so this info doesn't need to be 
         * rebuilt after waiting for another transaction. 
         * 
         * Note the implied assumption that there is no more than one live 
         * tuple per HOT-chain --- else we could create more than one index 
         * entry pointing to the same root tuple. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN2205"><span class='Ref_To_Local'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/relscan.h.html#LN68"><span class='Ref_to_Member'>rs_cblock</span></a> <span class='Operator'>!= </span><a href="index.c.html#LN2216"><span class='Ref_To_Local'>root_blkno</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN2328"></a>            <a href="../../include/storage/bufpage.h.html#LN73"><span class='Ref_to_Typedef'>Page</span></a>        <span class='Declare_Local'>page</span> <span class='Operator'>= </span><a href="../../include/storage/bufmgr.h.html#LN159"><span class='Ref_to_Macro'>BufferGetPage</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2205"><span class='Ref_To_Local'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/relscan.h.html#LN69"><span class='Ref_to_Member'>rs_cbuf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="../../include/storage/bufmgr.h.html#LN214"><span class='Ref_to_Proto'>LockBuffer</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2205"><span class='Ref_To_Local'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/relscan.h.html#LN69"><span class='Ref_to_Member'>rs_cbuf</span></a><span class='Delimiter'>, </span><a href="../../include/storage/bufmgr.h.html#LN87"><span class='Ref_to_Const'>BUFFER_LOCK_SHARE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../include/access/heapam.h.html#LN192"><span class='Ref_to_Proto'>heap_get_root_tuples</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2328"><span class='Ref_To_Local'>page</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN2217"><span class='Ref_To_Local'>root_offsets</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../include/storage/bufmgr.h.html#LN214"><span class='Ref_to_Proto'>LockBuffer</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2205"><span class='Ref_To_Local'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/relscan.h.html#LN69"><span class='Ref_to_Member'>rs_cbuf</span></a><span class='Delimiter'>, </span><a href="../../include/storage/bufmgr.h.html#LN86"><span class='Ref_to_Const'>BUFFER_LOCK_UNLOCK</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="index.c.html#LN2216"><span class='Ref_To_Local'>root_blkno</span></a> <span class='Operator'>= </span><a href="index.c.html#LN2205"><span class='Ref_To_Local'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/relscan.h.html#LN68"><span class='Ref_to_Member'>rs_cblock</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN2214"><span class='Ref_To_Local'>snapshot</span></a> <span class='Operator'>== </span><a href="../../include/utils/tqual.h.html#LN27"><span class='Ref_to_Const'>SnapshotAny</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* do our own time qual check */ 
</span><a name="LN2340"></a>            <span class='Keyword'>bool</span>        <span class='Declare_Local'>indexIt</span><span class='Delimiter'>; 
</span><a name="LN2341"></a>            <a href="../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>xwait</span><span class='Delimiter'>; 
</span> 
<a name="LN2343"></a>    <span class='Label'>recheck</span><span class='Operator'>: 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * We could possibly get away with not locking the buffer here, 
             * since caller should hold ShareLock on the relation, but let's 
             * be conservative about it.  (This remark is still correct even 
             * with HOT-pruning: our pin on the buffer prevents pruning.) 
             */ 
</span>            <a href="../../include/storage/bufmgr.h.html#LN214"><span class='Ref_to_Proto'>LockBuffer</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2205"><span class='Ref_To_Local'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/relscan.h.html#LN69"><span class='Ref_to_Member'>rs_cbuf</span></a><span class='Delimiter'>, </span><a href="../../include/storage/bufmgr.h.html#LN87"><span class='Ref_to_Const'>BUFFER_LOCK_SHARE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="../../include/utils/tqual.h.html#LN74"><span class='Ref_to_Proto'>HeapTupleSatisfiesVacuum</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2206"><span class='Ref_To_Local'>heapTuple</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN2215"><span class='Ref_To_Local'>OldestXmin</span></a><span class='Delimiter'>, 
</span>                                             <a href="index.c.html#LN2205"><span class='Ref_To_Local'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/relscan.h.html#LN69"><span class='Ref_to_Member'>rs_cbuf</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Control'>case</span> <a href="../../include/utils/tqual.h.html#LN50"><span class='Ref_to_EnumConst'>HEAPTUPLE_DEAD</span></a><span class='Operator'>: 
</span>                    <span class='Comment_Multi_Line'>/* Definitely dead, we can ignore it */ 
</span>                    <a href="index.c.html#LN2340"><span class='Ref_To_Local'>indexIt</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                    <a href="index.c.html#LN2297"><span class='Ref_To_Local'>tupleIsAlive</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Control'>case</span> <a href="../../include/utils/tqual.h.html#LN51"><span class='Ref_to_EnumConst'>HEAPTUPLE_LIVE</span></a><span class='Operator'>: 
</span>                    <span class='Comment_Multi_Line'>/* Normal case, index and unique-check it */ 
</span>                    <a href="index.c.html#LN2340"><span class='Ref_To_Local'>indexIt</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                    <a href="index.c.html#LN2297"><span class='Ref_To_Local'>tupleIsAlive</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Control'>case</span> <a href="../../include/utils/tqual.h.html#LN52"><span class='Ref_to_EnumConst'>HEAPTUPLE_RECENTLY_DEAD</span></a><span class='Operator'>: 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * If tuple is recently deleted then we must index it 
                     * anyway to preserve MVCC semantics.  (Pre-existing 
                     * transactions could try to use the index after we finish 
                     * building it, and may need to see such tuples.) 
                     * 
                     * However, if it was HOT-updated then we must only index 
                     * the live tuple at the end of the HOT-chain.  Since this 
                     * breaks semantics for pre-existing snapshots, mark the 
                     * index as unusable for them. 
                     */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/access/htup_details.h.html#LN676"><span class='Ref_to_Macro'>HeapTupleIsHotUpdated</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2206"><span class='Ref_To_Local'>heapTuple</span></a><span class='Parentheses'>))</span> 
                    <span class='Delimiter'>{ 
</span>                        <a href="index.c.html#LN2340"><span class='Ref_To_Local'>indexIt</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                        <span class='Comment_Multi_Line'>/* mark the index as unsafe for old snapshots */ 
</span>                        <a href="index.c.html#LN2195"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN148"><span class='Ref_to_Member'>ii_BrokenHotChain</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                    <span class='Control'>else</span> 
                        <a href="index.c.html#LN2340"><span class='Ref_To_Local'>indexIt</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                    <span class='Comment_Multi_Line'>/* In any case, exclude the tuple from unique-checking */ 
</span>                    <a href="index.c.html#LN2297"><span class='Ref_To_Local'>tupleIsAlive</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Control'>case</span> <a href="../../include/utils/tqual.h.html#LN53"><span class='Ref_to_EnumConst'>HEAPTUPLE_INSERT_IN_PROGRESS</span></a><span class='Operator'>: 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * In "anyvisible" mode, this tuple is visible and we 
                     * don't need any further checks. 
                     */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN2197"><span class='Ref_to_Parameter'>anyvisible</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <a href="index.c.html#LN2340"><span class='Ref_To_Local'>indexIt</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                        <a href="index.c.html#LN2297"><span class='Ref_To_Local'>tupleIsAlive</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                        <span class='Control'>break</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * Since caller should hold ShareLock or better, normally 
                     * the only way to see this is if it was inserted earlier 
                     * in our own transaction.  However, it can happen in 
                     * system catalogs, since we tend to release write lock 
                     * before commit there.  Give a warning if neither case 
                     * applies. 
                     */ 
</span>                    <a href="index.c.html#LN2341"><span class='Ref_To_Local'>xwait</span></a> <span class='Operator'>= </span><a href="../../include/access/htup_details.h.html#LN306"><span class='Ref_to_Macro'>HeapTupleHeaderGetXmin</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2206"><span class='Ref_To_Local'>heapTuple</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/htup.h.html#LN66"><span class='Ref_to_Member'>t_data</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/xact.h.html#LN345"><span class='Ref_to_Proto'>TransactionIdIsCurrentTransactionId</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2341"><span class='Ref_To_Local'>xwait</span></a><span class='Parentheses'>))</span> 
                    <span class='Delimiter'>{ 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="index.c.html#LN2203"><span class='Ref_To_Local'>is_system_catalog</span></a><span class='Parentheses'>) 
</span>                            <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN39"><span class='Ref_to_Const'>WARNING</span></a><span class='Delimiter'>, </span><span class='String'>"concurrent insert in progress within table \"%s\""</span><span class='Delimiter'>, 
</span>                                 <a href="../../include/utils/rel.h.html#LN436"><span class='Ref_to_Macro'>RelationGetRelationName</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2193"><span class='Ref_to_Parameter'>heapRelation</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
                        <span class='Comment_Multi_Line'>/* 
                         * If we are performing uniqueness checks, indexing 
                         * such a tuple could lead to a bogus uniqueness 
                         * failure.  In that case we wait for the inserting 
                         * transaction to finish and check again. 
                         */ 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN2204"><span class='Ref_To_Local'>checking_uniqueness</span></a><span class='Parentheses'>) 
</span>                        <span class='Delimiter'>{ 
</span>                            <span class='Comment_Multi_Line'>/* 
                             * Must drop the lock on the buffer before we wait 
                             */ 
</span>                            <a href="../../include/storage/bufmgr.h.html#LN214"><span class='Ref_to_Proto'>LockBuffer</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2205"><span class='Ref_To_Local'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/relscan.h.html#LN69"><span class='Ref_to_Member'>rs_cbuf</span></a><span class='Delimiter'>, </span><a href="../../include/storage/bufmgr.h.html#LN86"><span class='Ref_to_Const'>BUFFER_LOCK_UNLOCK</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                            <a href="../../include/storage/lmgr.h.html#LN73"><span class='Ref_to_Proto'>XactLockTableWait</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2341"><span class='Ref_To_Local'>xwait</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN2193"><span class='Ref_to_Parameter'>heapRelation</span></a><span class='Delimiter'>, 
</span>                                              <span class='Operator'>&</span><a href="index.c.html#LN2206"><span class='Ref_To_Local'>heapTuple</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/htup.h.html#LN64"><span class='Ref_to_Member'>t_self</span></a><span class='Delimiter'>, 
</span>                                              <a href="../../include/storage/lmgr.h.html#LN31"><span class='Ref_to_EnumConst'>XLTW_InsertIndexUnique</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                            <a href="../../include/miscadmin.h.html#LN99"><span class='Ref_to_Macro'>CHECK_FOR_INTERRUPTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>                            <span class='Control'>goto</span> <span class='Symbol_Characters'>&uarr;</span><a href="index.c.html#LN2343"><span class='Ref_to_Label'>recheck</span></a><span class='Delimiter'>; 
</span>                        <span class='Delimiter'>} 
</span>                    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !TransactionIdIsCurre... &raquo; </span> 
 
                    <span class='Comment_Multi_Line'>/* 
                     * We must index such tuples, since if the index build 
                     * commits then they're good. 
                     */ 
</span>                    <a href="index.c.html#LN2340"><span class='Ref_To_Local'>indexIt</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                    <a href="index.c.html#LN2297"><span class='Ref_To_Local'>tupleIsAlive</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Control'>case</span> <a href="../../include/utils/tqual.h.html#LN54"><span class='Ref_to_EnumConst'>HEAPTUPLE_DELETE_IN_PROGRESS</span></a><span class='Operator'>: 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * As with INSERT_IN_PROGRESS case, this is unexpected 
                     * unless it's our own deletion or a system catalog; but 
                     * in anyvisible mode, this tuple is visible. 
                     */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN2197"><span class='Ref_to_Parameter'>anyvisible</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <a href="index.c.html#LN2340"><span class='Ref_To_Local'>indexIt</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                        <a href="index.c.html#LN2297"><span class='Ref_To_Local'>tupleIsAlive</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                        <span class='Control'>break</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span> 
                    <a href="index.c.html#LN2341"><span class='Ref_To_Local'>xwait</span></a> <span class='Operator'>= </span><a href="../../include/access/htup_details.h.html#LN358"><span class='Ref_to_Macro'>HeapTupleHeaderGetUpdateXid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2206"><span class='Ref_To_Local'>heapTuple</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/htup.h.html#LN66"><span class='Ref_to_Member'>t_data</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/xact.h.html#LN345"><span class='Ref_to_Proto'>TransactionIdIsCurrentTransactionId</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2341"><span class='Ref_To_Local'>xwait</span></a><span class='Parentheses'>))</span> 
                    <span class='Delimiter'>{ 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="index.c.html#LN2203"><span class='Ref_To_Local'>is_system_catalog</span></a><span class='Parentheses'>) 
</span>                            <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN39"><span class='Ref_to_Const'>WARNING</span></a><span class='Delimiter'>, </span><span class='String'>"concurrent delete in progress within table \"%s\""</span><span class='Delimiter'>, 
</span>                                 <a href="../../include/utils/rel.h.html#LN436"><span class='Ref_to_Macro'>RelationGetRelationName</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2193"><span class='Ref_to_Parameter'>heapRelation</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
                        <span class='Comment_Multi_Line'>/* 
                         * If we are performing uniqueness checks, assuming 
                         * the tuple is dead could lead to missing a 
                         * uniqueness violation.  In that case we wait for the 
                         * deleting transaction to finish and check again. 
                         * 
                         * Also, if it's a HOT-updated tuple, we should not 
                         * index it but rather the live tuple at the end of 
                         * the HOT-chain.  However, the deleting transaction 
                         * could abort, possibly leaving this tuple as live 
                         * after all, in which case it has to be indexed. The 
                         * only way to know what to do is to wait for the 
                         * deleting transaction to finish and check again. 
                         */ 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN2204"><span class='Ref_To_Local'>checking_uniqueness</span></a> <span class='Operator'>|| 
</span>                            <a href="../../include/access/htup_details.h.html#LN676"><span class='Ref_to_Macro'>HeapTupleIsHotUpdated</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2206"><span class='Ref_To_Local'>heapTuple</span></a><span class='Parentheses'>))</span> 
                        <span class='Delimiter'>{ 
</span>                            <span class='Comment_Multi_Line'>/* 
                             * Must drop the lock on the buffer before we wait 
                             */ 
</span>                            <a href="../../include/storage/bufmgr.h.html#LN214"><span class='Ref_to_Proto'>LockBuffer</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2205"><span class='Ref_To_Local'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/relscan.h.html#LN69"><span class='Ref_to_Member'>rs_cbuf</span></a><span class='Delimiter'>, </span><a href="../../include/storage/bufmgr.h.html#LN86"><span class='Ref_to_Const'>BUFFER_LOCK_UNLOCK</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                            <a href="../../include/storage/lmgr.h.html#LN73"><span class='Ref_to_Proto'>XactLockTableWait</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2341"><span class='Ref_To_Local'>xwait</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN2193"><span class='Ref_to_Parameter'>heapRelation</span></a><span class='Delimiter'>, 
</span>                                              <span class='Operator'>&</span><a href="index.c.html#LN2206"><span class='Ref_To_Local'>heapTuple</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/htup.h.html#LN64"><span class='Ref_to_Member'>t_self</span></a><span class='Delimiter'>, 
</span>                                              <a href="../../include/storage/lmgr.h.html#LN31"><span class='Ref_to_EnumConst'>XLTW_InsertIndexUnique</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                            <a href="../../include/miscadmin.h.html#LN99"><span class='Ref_to_Macro'>CHECK_FOR_INTERRUPTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>                            <span class='Control'>goto</span> <span class='Symbol_Characters'>&uarr;</span><a href="index.c.html#LN2343"><span class='Ref_to_Label'>recheck</span></a><span class='Delimiter'>; 
</span>                        <span class='Delimiter'>} 
</span> 
                        <span class='Comment_Multi_Line'>/* 
                         * Otherwise index it but don't check for uniqueness, 
                         * the same as a RECENTLY_DEAD tuple. 
                         */ 
</span>                        <a href="index.c.html#LN2340"><span class='Ref_To_Local'>indexIt</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !TransactionIdIsCurre... &raquo; </span> 
                    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/access/htup_details.h.html#LN676"><span class='Ref_to_Macro'>HeapTupleIsHotUpdated</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2206"><span class='Ref_To_Local'>heapTuple</span></a><span class='Parentheses'>))</span> 
                    <span class='Delimiter'>{ 
</span>                        <span class='Comment_Multi_Line'>/* 
                         * It's a HOT-updated tuple deleted by our own xact. 
                         * We can assume the deletion will commit (else the 
                         * index contents don't matter), so treat the same as 
                         * RECENTLY_DEAD HOT-updated tuples. 
                         */ 
</span>                        <a href="index.c.html#LN2340"><span class='Ref_To_Local'>indexIt</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                        <span class='Comment_Multi_Line'>/* mark the index as unsafe for old snapshots */ 
</span>                        <a href="index.c.html#LN2195"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN148"><span class='Ref_to_Member'>ii_BrokenHotChain</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                    <span class='Control'>else</span> 
                    <span class='Delimiter'>{ 
</span>                        <span class='Comment_Multi_Line'>/* 
                         * It's a regular tuple deleted by our own xact. Index 
                         * it but don't check for uniqueness, the same as a 
                         * RECENTLY_DEAD tuple. 
                         */ 
</span>                        <a href="index.c.html#LN2340"><span class='Ref_To_Local'>indexIt</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                    <span class='Comment_Multi_Line'>/* In any case, exclude the tuple from unique-checking */ 
</span>                    <a href="index.c.html#LN2297"><span class='Ref_To_Local'>tupleIsAlive</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Control'>default</span><span class='Operator'>: 
</span>                    <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unexpected HeapTupleSatisfiesVacuum result"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="index.c.html#LN2340"><span class='Ref_To_Local'>indexIt</span></a> <span class='Operator'>= </span><a href="index.c.html#LN2297"><span class='Ref_To_Local'>tupleIsAlive</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* keep compiler quiet */ 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch HeapTupleSatisfiesVac... &raquo; </span> 
 
            <a href="../../include/storage/bufmgr.h.html#LN214"><span class='Ref_to_Proto'>LockBuffer</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2205"><span class='Ref_To_Local'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/relscan.h.html#LN69"><span class='Ref_to_Member'>rs_cbuf</span></a><span class='Delimiter'>, </span><a href="../../include/storage/bufmgr.h.html#LN86"><span class='Ref_to_Const'>BUFFER_LOCK_UNLOCK</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="index.c.html#LN2340"><span class='Ref_To_Local'>indexIt</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if snapshot==SnapshotAny &raquo; </span> 
        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* heap_getnext did the time qual check */ 
</span>            <a href="index.c.html#LN2297"><span class='Ref_To_Local'>tupleIsAlive</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="index.c.html#LN2209"><span class='Ref_To_Local'>reltuples</span></a> <span class='Operator'>+= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/utils/memutils.h.html#LN73"><span class='Ref_to_Proto'>MemoryContextReset</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2213"><span class='Ref_To_Local'>econtext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN202"><span class='Ref_to_Member'>ecxt_per_tuple_memory</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Set up for predicate or expression evaluation */ 
</span>        <a href="../../include/executor/tuptable.h.html#LN147"><span class='Ref_to_Proto'>ExecStoreTuple</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2206"><span class='Ref_To_Local'>heapTuple</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN2211"><span class='Ref_To_Local'>slot</span></a><span class='Delimiter'>, </span><a href="../../include/storage/buf.h.html#LN24"><span class='Ref_to_Const'>InvalidBuffer</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * In a partial index, discard tuples that don't satisfy the 
         * predicate. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN2210"><span class='Ref_To_Local'>predicate</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/executor/executor.h.html#LN344"><span class='Ref_to_Func'>ExecQual</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2210"><span class='Ref_To_Local'>predicate</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN2213"><span class='Ref_To_Local'>econtext</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * For the current heap tuple, extract all the attributes we use in 
         * this index, and note which are null.  This also performs evaluation 
         * of any expressions needed. 
         */ 
</span>        <a href="../../include/catalog/index.h.html#LN85"><span class='Ref_to_Proto'>FormIndexDatum</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2195"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Delimiter'>, 
</span>                       <a href="index.c.html#LN2211"><span class='Ref_To_Local'>slot</span></a><span class='Delimiter'>, 
</span>                       <a href="index.c.html#LN2212"><span class='Ref_To_Local'>estate</span></a><span class='Delimiter'>, 
</span>                       <a href="index.c.html#LN2207"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>, 
</span>                       <a href="index.c.html#LN2208"><span class='Ref_To_Local'>isnull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * You'd think we should go ahead and build the index tuple here, but 
         * some index AMs want to do further processing on the data first.  So 
         * pass the values[] and isnull[] arrays, instead. 
         */ 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/access/htup_details.h.html#LN685"><span class='Ref_to_Macro'>HeapTupleIsHeapOnly</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2206"><span class='Ref_To_Local'>heapTuple</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * For a heap-only tuple, pretend its TID is that of the root. See 
             * src/backend/access/heap/README.HOT for discussion. 
             */ 
</span><a name="LN2581"></a>            <a href="../../include/access/htup.h.html#LN61"><span class='Ref_to_Struct'>HeapTupleData</span></a> <span class='Declare_Local'>rootTuple</span><span class='Delimiter'>; 
</span><a name="LN2582"></a>            <a href="../../include/storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Local'>offnum</span><span class='Delimiter'>; 
</span> 
            <a href="index.c.html#LN2581"><span class='Ref_To_Local'>rootTuple</span></a> <span class='Operator'>= *</span><a href="index.c.html#LN2206"><span class='Ref_To_Local'>heapTuple</span></a><span class='Delimiter'>; 
</span>            <a href="index.c.html#LN2582"><span class='Ref_To_Local'>offnum</span></a> <span class='Operator'>= </span><a href="../../include/storage/itemptr.h.html#LN93"><span class='Ref_to_Macro'>ItemPointerGetOffsetNumber</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="index.c.html#LN2206"><span class='Ref_To_Local'>heapTuple</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/htup.h.html#LN64"><span class='Ref_to_Member'>t_self</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/storage/off.h.html#LN39"><span class='Ref_to_Macro'>OffsetNumberIsValid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2217"><span class='Ref_To_Local'>root_offsets</span></a><span class='Delimiter'>[</span><a href="index.c.html#LN2582"><span class='Ref_To_Local'>offnum</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]</span><span class='Parentheses'>))</span> 
                <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"failed to find parent tuple for heap-only tuple at (%u,%u) in table \"%s\""</span><span class='Delimiter'>, 
</span>                     <a href="../../include/storage/itemptr.h.html#LN74"><span class='Ref_to_Macro'>ItemPointerGetBlockNumber</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="index.c.html#LN2206"><span class='Ref_To_Local'>heapTuple</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/htup.h.html#LN64"><span class='Ref_to_Member'>t_self</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="index.c.html#LN2582"><span class='Ref_To_Local'>offnum</span></a><span class='Delimiter'>, </span><a href="../../include/utils/rel.h.html#LN436"><span class='Ref_to_Macro'>RelationGetRelationName</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2193"><span class='Ref_to_Parameter'>heapRelation</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
            <a href="../../include/storage/itemptr.h.html#LN124"><span class='Ref_to_Macro'>ItemPointerSetOffsetNumber</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="index.c.html#LN2581"><span class='Ref_To_Local'>rootTuple</span></a><span class='Operator'>.</span><a href="../../include/access/htup.h.html#LN64"><span class='Ref_to_Member'>t_self</span></a><span class='Delimiter'>, 
</span>                                       <a href="index.c.html#LN2217"><span class='Ref_To_Local'>root_offsets</span></a><span class='Delimiter'>[</span><a href="index.c.html#LN2582"><span class='Ref_To_Local'>offnum</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Call the AM's callback routine to process the tuple */ 
</span>            <a href="index.c.html#LN2200"><span class='Ref_to_Parameter'>callback</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2194"><span class='Ref_to_Parameter'>indexRelation</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="index.c.html#LN2581"><span class='Ref_To_Local'>rootTuple</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN2207"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN2208"><span class='Ref_To_Local'>isnull</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN2297"><span class='Ref_To_Local'>tupleIsAlive</span></a><span class='Delimiter'>, 
</span>                     <a href="index.c.html#LN2201"><span class='Ref_to_Parameter'>callback_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if HeapTupleIsHeapOnly(h... &raquo; </span> 
        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Call the AM's callback routine to process the tuple */ 
</span>            <a href="index.c.html#LN2200"><span class='Ref_to_Parameter'>callback</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2194"><span class='Ref_to_Parameter'>indexRelation</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN2206"><span class='Ref_To_Local'>heapTuple</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN2207"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN2208"><span class='Ref_To_Local'>isnull</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN2297"><span class='Ref_To_Local'>tupleIsAlive</span></a><span class='Delimiter'>, 
</span>                     <a href="index.c.html#LN2201"><span class='Ref_to_Parameter'>callback_state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while (heapTuple=heap_getne... &raquo; </span> 
 
    <a href="../../include/access/heapam.h.html#LN126"><span class='Ref_to_Proto'>heap_endscan</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2205"><span class='Ref_To_Local'>scan</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* we can now forget our snapshot, if set */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/miscadmin.h.html#LN369"><span class='Ref_to_Macro'>IsBootstrapProcessingMode</span></a><span class='Parentheses'>() </span><span class='Operator'>|| </span><a href="index.c.html#LN2195"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN147"><span class='Ref_to_Member'>ii_Concurrent</span></a><span class='Parentheses'>)</span> 
        <a href="../../include/utils/snapmgr.h.html#LN81"><span class='Ref_to_Proto'>UnregisterSnapshot</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2214"><span class='Ref_To_Local'>snapshot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/executor/tuptable.h.html#LN145"><span class='Ref_to_Proto'>ExecDropSingleTupleTableSlot</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2211"><span class='Ref_To_Local'>slot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../executor/execUtils.c.html#LN176"><span class='Ref_to_Func'>FreeExecutorState</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2212"><span class='Ref_To_Local'>estate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* These may have been pointing to the now-gone estate */ 
</span>    <a href="index.c.html#LN2195"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN136"><span class='Ref_to_Member'>ii_ExpressionsState</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN2195"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN138"><span class='Ref_to_Member'>ii_PredicateState</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="index.c.html#LN2209"><span class='Ref_To_Local'>reltuples</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end IndexBuildHeapRangeScan &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * IndexCheckExclusion - verify that a new exclusion constraint is satisfied 
 * 
 * When creating an exclusion constraint, we first build the index normally 
 * and then rescan the heap to check for conflicts.  We assume that we only 
 * need to validate tuples that are live according to an up-to-date snapshot, 
 * and that these were correctly indexed even in the presence of broken HOT 
 * chains.  This should be OK since we are holding at least ShareLock on the 
 * table, meaning there can be no uncommitted updates from other transactions. 
 * (Note: that wouldn't necessarily work for system catalogs, since many 
 * operations release write lock early on the system catalogs.) 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2638"></a><span class='Declare_Function'>IndexCheckExclusion</span><span class='Parentheses'>(</span><a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>heapRelation</span><span class='Delimiter'>, 
</span><a name="LN2639"></a>                    <a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>indexRelation</span><span class='Delimiter'>, 
</span><a name="LN2640"></a>                    <a href="../../include/nodes/execnodes.h.html#LN130"><span class='Ref_to_Struct'>IndexInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>indexInfo</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2642"></a>    <a href="../../include/access/heapam.h.html#LN99"><span class='Ref_to_Typedef'>HeapScanDesc</span></a> <span class='Declare_Local'>scan</span><span class='Delimiter'>; 
</span><a name="LN2643"></a>    <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>heapTuple</span><span class='Delimiter'>; 
</span><a name="LN2644"></a>    <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>values</span><span class='Delimiter'>[</span><a href="../../include/pg_config_manual.h.html#LN45"><span class='Ref_to_Const'>INDEX_MAX_KEYS</span></a><span class='Delimiter'>]; 
</span><a name="LN2645"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>isnull</span><span class='Delimiter'>[</span><a href="../../include/pg_config_manual.h.html#LN45"><span class='Ref_to_Const'>INDEX_MAX_KEYS</span></a><span class='Delimiter'>]; 
</span><a name="LN2646"></a>    <a href="../../include/nodes/execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>predicate</span><span class='Delimiter'>; 
</span><a name="LN2647"></a>    <a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Local'>slot</span><span class='Delimiter'>; 
</span><a name="LN2648"></a>    <a href="../../include/nodes/execnodes.h.html#LN402"><span class='Ref_to_Struct'>EState</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>estate</span><span class='Delimiter'>; 
</span><a name="LN2649"></a>    <a href="../../include/nodes/execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Local'>econtext</span><span class='Delimiter'>; 
</span><a name="LN2650"></a>    <a href="../../include/utils/snapshot.h.html#LN22"><span class='Ref_to_Typedef'>Snapshot</span></a>    <span class='Declare_Local'>snapshot</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we are reindexing the target index, mark it as no longer being 
     * reindexed, to forestall an Assert in index_beginscan when we try to use 
     * the index for probes.  This is OK because the index is now fully valid. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN122"><span class='Ref_to_Proto'>ReindexIsCurrentlyProcessingIndex</span></a><span class='Parentheses'>(</span><a href="../../include/utils/rel.h.html#LN416"><span class='Ref_to_Macro'>RelationGetRelid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2639"><span class='Ref_to_Parameter'>indexRelation</span></a><span class='Parentheses'>)))</span> 
        <a href="index.c.html#LN124"><span class='Ref_to_Proto'>ResetReindexProcessing</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Need an EState for evaluation of index expressions and partial-index 
     * predicates.  Also a slot to hold the current tuple. 
     */ 
</span>    <a href="index.c.html#LN2648"><span class='Ref_To_Local'>estate</span></a> <span class='Operator'>= </span><a href="../executor/execUtils.c.html#LN78"><span class='Ref_to_Func'>CreateExecutorState</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN2649"><span class='Ref_To_Local'>econtext</span></a> <span class='Operator'>= </span><a href="../../include/executor/executor.h.html#LN455"><span class='Ref_to_Macro'>GetPerTupleExprContext</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2648"><span class='Ref_To_Local'>estate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN2647"><span class='Ref_To_Local'>slot</span></a> <span class='Operator'>= </span><a href="../../include/executor/tuptable.h.html#LN144"><span class='Ref_to_Proto'>MakeSingleTupleTableSlot</span></a><span class='Parentheses'>(</span><a href="../../include/utils/rel.h.html#LN428"><span class='Ref_to_Macro'>RelationGetDescr</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2638"><span class='Ref_to_Parameter'>heapRelation</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Arrange for econtext's scan tuple to be the tuple under test */ 
</span>    <a href="index.c.html#LN2649"><span class='Ref_To_Local'>econtext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN196"><span class='Ref_to_Member'>ecxt_scantuple</span></a> <span class='Operator'>= </span><a href="index.c.html#LN2647"><span class='Ref_To_Local'>slot</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Set up execution state for predicate, if any. */ 
</span>    <a href="index.c.html#LN2646"><span class='Ref_To_Local'>predicate</span></a> <span class='Operator'>= </span><a href="../../include/executor/executor.h.html#LN247"><span class='Ref_to_Proto'>ExecPrepareQual</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2640"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN137"><span class='Ref_to_Member'>ii_Predicate</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN2648"><span class='Ref_To_Local'>estate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Scan all live tuples in the base relation. 
     */ 
</span>    <a href="index.c.html#LN2650"><span class='Ref_To_Local'>snapshot</span></a> <span class='Operator'>= </span><a href="../../include/utils/snapmgr.h.html#LN80"><span class='Ref_to_Proto'>RegisterSnapshot</span></a><span class='Parentheses'>(</span><a href="../../include/utils/snapmgr.h.html#LN64"><span class='Ref_to_Proto'>GetLatestSnapshot</span></a><span class='Parentheses'>())</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN2642"><span class='Ref_To_Local'>scan</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN112"><span class='Ref_to_Proto'>heap_beginscan_strat</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2638"><span class='Ref_to_Parameter'>heapRelation</span></a><span class='Delimiter'>,</span>   <span class='Comment_Single_Line'>/* relation */ 
</span>                                <a href="index.c.html#LN2650"><span class='Ref_To_Local'>snapshot</span></a><span class='Delimiter'>,</span>       <span class='Comment_Single_Line'>/* snapshot */ 
</span>                                <span class='Number'>0</span><span class='Delimiter'>,</span>      <span class='Comment_Single_Line'>/* number of keys */ 
</span>                                <span class='Null_Value'>NULL</span><span class='Delimiter'>,</span>   <span class='Comment_Single_Line'>/* scan key */ 
</span>                                <span class='Boolean'>true</span><span class='Delimiter'>,</span>   <span class='Comment_Single_Line'>/* buffer access strategy OK */ 
</span>                                <span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* syncscan OK */ 
</span> 
    <span class='Control'>while</span> <span class='Parentheses'>((</span><a href="index.c.html#LN2643"><span class='Ref_To_Local'>heapTuple</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN127"><span class='Ref_to_Proto'>heap_getnext</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2642"><span class='Ref_To_Local'>scan</span></a><span class='Delimiter'>, </span><a href="../../include/access/sdir.h.html#LN25"><span class='Ref_to_EnumConst'>ForwardScanDirection</span></a><span class='Parentheses'>))</span> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../include/miscadmin.h.html#LN99"><span class='Ref_to_Macro'>CHECK_FOR_INTERRUPTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/utils/memutils.h.html#LN73"><span class='Ref_to_Proto'>MemoryContextReset</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2649"><span class='Ref_To_Local'>econtext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN202"><span class='Ref_to_Member'>ecxt_per_tuple_memory</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Set up for predicate or expression evaluation */ 
</span>        <a href="../../include/executor/tuptable.h.html#LN147"><span class='Ref_to_Proto'>ExecStoreTuple</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2643"><span class='Ref_To_Local'>heapTuple</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN2647"><span class='Ref_To_Local'>slot</span></a><span class='Delimiter'>, </span><a href="../../include/storage/buf.h.html#LN24"><span class='Ref_to_Const'>InvalidBuffer</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * In a partial index, ignore tuples that don't satisfy the predicate. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN2646"><span class='Ref_To_Local'>predicate</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/executor/executor.h.html#LN344"><span class='Ref_to_Func'>ExecQual</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2646"><span class='Ref_To_Local'>predicate</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN2649"><span class='Ref_To_Local'>econtext</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Extract index column values, including computing expressions. 
         */ 
</span>        <a href="../../include/catalog/index.h.html#LN85"><span class='Ref_to_Proto'>FormIndexDatum</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2640"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Delimiter'>, 
</span>                       <a href="index.c.html#LN2647"><span class='Ref_To_Local'>slot</span></a><span class='Delimiter'>, 
</span>                       <a href="index.c.html#LN2648"><span class='Ref_To_Local'>estate</span></a><span class='Delimiter'>, 
</span>                       <a href="index.c.html#LN2644"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>, 
</span>                       <a href="index.c.html#LN2645"><span class='Ref_To_Local'>isnull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Check that this tuple has no conflicts. 
         */ 
</span>        <a href="../../include/executor/executor.h.html#LN514"><span class='Ref_to_Proto'>check_exclusion_constraint</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2638"><span class='Ref_to_Parameter'>heapRelation</span></a><span class='Delimiter'>, 
</span>                                   <a href="index.c.html#LN2639"><span class='Ref_to_Parameter'>indexRelation</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN2640"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Delimiter'>, 
</span>                                   <span class='Operator'>&</span><span class='Parentheses'>(</span><a href="index.c.html#LN2643"><span class='Ref_To_Local'>heapTuple</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/htup.h.html#LN64"><span class='Ref_to_Member'>t_self</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="index.c.html#LN2644"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN2645"><span class='Ref_To_Local'>isnull</span></a><span class='Delimiter'>, 
</span>                                   <a href="index.c.html#LN2648"><span class='Ref_To_Local'>estate</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while (heapTuple=heap_getne... &raquo; </span> 
 
    <a href="../../include/access/heapam.h.html#LN126"><span class='Ref_to_Proto'>heap_endscan</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2642"><span class='Ref_To_Local'>scan</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/utils/snapmgr.h.html#LN81"><span class='Ref_to_Proto'>UnregisterSnapshot</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2650"><span class='Ref_To_Local'>snapshot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/executor/tuptable.h.html#LN145"><span class='Ref_to_Proto'>ExecDropSingleTupleTableSlot</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2647"><span class='Ref_To_Local'>slot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../executor/execUtils.c.html#LN176"><span class='Ref_to_Func'>FreeExecutorState</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2648"><span class='Ref_To_Local'>estate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* These may have been pointing to the now-gone estate */ 
</span>    <a href="index.c.html#LN2640"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN136"><span class='Ref_to_Member'>ii_ExpressionsState</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN2640"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN138"><span class='Ref_to_Member'>ii_PredicateState</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end IndexCheckExclusion &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * validate_index - support code for concurrent index builds 
 * 
 * We do a concurrent index build by first inserting the catalog entry for the 
 * index via index_create(), marking it not indisready and not indisvalid. 
 * Then we commit our transaction and start a new one, then we wait for all 
 * transactions that could have been modifying the table to terminate.  Now 
 * we know that any subsequently-started transactions will see the index and 
 * honor its constraints on HOT updates; so while existing HOT-chains might 
 * be broken with respect to the index, no currently live tuple will have an 
 * incompatible HOT update done to it.  We now build the index normally via 
 * index_build(), while holding a weak lock that allows concurrent 
 * insert/update/delete.  Also, we index only tuples that are valid 
 * as of the start of the scan (see IndexBuildHeapScan), whereas a normal 
 * build takes care to include recently-dead tuples.  This is OK because 
 * we won't mark the index valid until all transactions that might be able 
 * to see those tuples are gone.  The reason for doing that is to avoid 
 * bogus unique-index failures due to concurrent UPDATEs (we might see 
 * different versions of the same row as being valid when we pass over them, 
 * if we used HeapTupleSatisfiesVacuum).  This leaves us with an index that 
 * does not contain any tuples added to the table while we built the index. 
 * 
 * Next, we mark the index "indisready" (but still not "indisvalid") and 
 * commit the second transaction and start a third.  Again we wait for all 
 * transactions that could have been modifying the table to terminate.  Now 
 * we know that any subsequently-started transactions will see the index and 
 * insert their new tuples into it.  We then take a new reference snapshot 
 * which is passed to validate_index().  Any tuples that are valid according 
 * to this snap, but are not in the index, must be added to the index. 
 * (Any tuples committed live after the snap will be inserted into the 
 * index by their originating transaction.  Any tuples committed dead before 
 * the snap need not be indexed, because we will wait out all transactions 
 * that might care about them before we mark the index valid.) 
 * 
 * validate_index() works by first gathering all the TIDs currently in the 
 * index, using a bulkdelete callback that just stores the TIDs and doesn't 
 * ever say "delete it".  (This should be faster than a plain indexscan; 
 * also, not all index AMs support full-index indexscan.)  Then we sort the 
 * TIDs, and finally scan the table doing a "merge join" against the TID list 
 * to see which tuples are missing from the index.  Thus we will ensure that 
 * all tuples valid according to the reference snapshot are in the index. 
 * 
 * Building a unique index this way is tricky: we might try to insert a 
 * tuple that is already dead or is in process of being deleted, and we 
 * mustn't have a uniqueness failure against an updated version of the same 
 * row.  We could try to check the tuple to see if it's already dead and tell 
 * index_insert() not to do the uniqueness check, but that still leaves us 
 * with a race condition against an in-progress update.  To handle that, 
 * we expect the index AM to recheck liveness of the to-be-inserted tuple 
 * before it declares a uniqueness error. 
 * 
 * After completing validate_index(), we wait until all transactions that 
 * were alive at the time of the reference snapshot are gone; this is 
 * necessary to be sure there are none left with a transaction snapshot 
 * older than the reference (and hence possibly able to see tuples we did 
 * not index).  Then we mark the index "indisvalid" and commit.  Subsequent 
 * transactions will be able to use it for queries. 
 * 
 * Doing two full table scans is a brute-force strategy.  We could try to be 
 * cleverer, eg storing new tuples in a special area of the table (perhaps 
 * making the table append-only by setting use_fsm).  However that would 
 * add yet more locking issues. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN2798"></a><span class='Declare_Function'>validate_index</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>heapId</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>indexId</span><span class='Delimiter'>, </span><a href="../../include/utils/snapshot.h.html#LN22"><span class='Ref_to_Typedef'>Snapshot</span></a> <span class='Declare_Parameter'>snapshot</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2800"></a>    <a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>heapRelation</span><span class='Delimiter'>, 
</span><a name="LN2801"></a>                <span class='Declare_Local'>indexRelation</span><span class='Delimiter'>; 
</span><a name="LN2802"></a>    <a href="../../include/nodes/execnodes.h.html#LN130"><span class='Ref_to_Struct'>IndexInfo</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>indexInfo</span><span class='Delimiter'>; 
</span><a name="LN2803"></a>    <a href="../../include/access/genam.h.html#LN43"><span class='Ref_to_Struct'>IndexVacuumInfo</span></a> <span class='Declare_Local'>ivinfo</span><span class='Delimiter'>; 
</span><a name="LN2804"></a>    <a href="index.c.html#LN79"><span class='Ref_to_Typedef'>v_i_state</span></a>   <span class='Declare_Local'>state</span><span class='Delimiter'>; 
</span><a name="LN2805"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>save_userid</span><span class='Delimiter'>; 
</span><a name="LN2806"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>save_sec_context</span><span class='Delimiter'>; 
</span><a name="LN2807"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>save_nestlevel</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Open and lock the parent heap relation */ 
</span>    <a href="index.c.html#LN2800"><span class='Ref_To_Local'>heapRelation</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN91"><span class='Ref_to_Proto'>heap_open</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2798"><span class='Ref_to_Parameter'>heapId</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN38"><span class='Ref_to_Const'>ShareUpdateExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* And the target index relation */ 
</span>    <a href="index.c.html#LN2801"><span class='Ref_To_Local'>indexRelation</span></a> <span class='Operator'>= </span><a href="../../include/access/genam.h.html#LN129"><span class='Ref_to_Proto'>index_open</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2798"><span class='Ref_to_Parameter'>indexId</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN37"><span class='Ref_to_Const'>RowExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Fetch info needed for index_insert.  (You might think this should be 
     * passed in from DefineIndex, but its copy is long gone due to having 
     * been built in a previous transaction.) 
     */ 
</span>    <a href="index.c.html#LN2802"><span class='Ref_To_Local'>indexInfo</span></a> <span class='Operator'>= </span><a href="../../include/catalog/index.h.html#LN81"><span class='Ref_to_Proto'>BuildIndexInfo</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2801"><span class='Ref_To_Local'>indexRelation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* mark build is concurrent just for consistency */ 
</span>    <a href="index.c.html#LN2802"><span class='Ref_To_Local'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN147"><span class='Ref_to_Member'>ii_Concurrent</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Switch to the table owner's userid, so that any index functions are run 
     * as that user.  Also lock down security-restricted operations and 
     * arrange to make GUC variable changes local to this command. 
     */ 
</span>    <a href="../../include/miscadmin.h.html#LN312"><span class='Ref_to_Proto'>GetUserIdAndSecContext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="index.c.html#LN2805"><span class='Ref_To_Local'>save_userid</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="index.c.html#LN2806"><span class='Ref_To_Local'>save_sec_context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/miscadmin.h.html#LN313"><span class='Ref_to_Proto'>SetUserIdAndSecContext</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2800"><span class='Ref_To_Local'>heapRelation</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relowner<span class='Delimiter'>, 
</span>                           <a href="index.c.html#LN2806"><span class='Ref_To_Local'>save_sec_context</span></a> <span class='Operator'>| </span><a href="../../include/miscadmin.h.html#LN296"><span class='Ref_to_Const'>SECURITY_RESTRICTED_OPERATION</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN2807"><span class='Ref_To_Local'>save_nestlevel</span></a> <span class='Operator'>= </span><a href="../../include/utils/guc.h.html#LN354"><span class='Ref_to_Proto'>NewGUCNestLevel</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Scan the index and gather up all the TIDs into a tuplesort object. 
     */ 
</span>    <a href="index.c.html#LN2803"><span class='Ref_To_Local'>ivinfo</span></a><span class='Operator'>.</span><a href="../../include/access/genam.h.html#LN45"><span class='Ref_to_Member'>index</span></a> <span class='Operator'>= </span><a href="index.c.html#LN2801"><span class='Ref_To_Local'>indexRelation</span></a><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN2803"><span class='Ref_To_Local'>ivinfo</span></a><span class='Operator'>.</span><a href="../../include/access/genam.h.html#LN46"><span class='Ref_to_Member'>analyze_only</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN2803"><span class='Ref_To_Local'>ivinfo</span></a><span class='Operator'>.</span><a href="../../include/access/genam.h.html#LN47"><span class='Ref_to_Member'>estimated_count</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN2803"><span class='Ref_To_Local'>ivinfo</span></a><span class='Operator'>.</span><a href="../../include/access/genam.h.html#LN48"><span class='Ref_to_Member'>message_level</span></a> <span class='Operator'>= </span><a href="../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN2803"><span class='Ref_To_Local'>ivinfo</span></a><span class='Operator'>.</span><a href="../../include/access/genam.h.html#LN49"><span class='Ref_to_Member'>num_heap_tuples</span></a> <span class='Operator'>= </span><a href="index.c.html#LN2800"><span class='Ref_To_Local'>heapRelation</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>reltuples<span class='Delimiter'>; 
</span>    <a href="index.c.html#LN2803"><span class='Ref_To_Local'>ivinfo</span></a><span class='Operator'>.</span><a href="../../include/access/genam.h.html#LN50"><span class='Ref_to_Member'>strategy</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Encode TIDs as int8 values for the sort, rather than directly sorting 
     * item pointers.  This can be significantly faster, primarily because TID 
     * is a pass-by-reference type on all platforms, whereas int8 is 
     * pass-by-value on most platforms. 
     */ 
</span>    <a href="index.c.html#LN2804"><span class='Ref_To_Local'>state</span></a><span class='Operator'>.</span><a href="index.c.html#LN81"><span class='Ref_to_Member'>tuplesort</span></a> <span class='Operator'>= </span><a href="../../include/utils/tuplesort.h.html#LN78"><span class='Ref_to_Proto'>tuplesort_begin_datum</span></a><span class='Parentheses'>(</span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN21"><span class='Ref_to_Const'>INT8OID</span></a><span class='Delimiter'>, </span><a href="../../include/catalog/pg_operator.h.html#LN180"><span class='Ref_to_Const'>Int8LessOperator</span></a><span class='Delimiter'>, 
</span>                                            <a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                                            <a href="../utils/init/globals.c.html#LN113"><span class='Ref_to_Global_Var'>maintenance_work_mem</span></a><span class='Delimiter'>, 
</span>                                            <span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN2804"><span class='Ref_To_Local'>state</span></a><span class='Operator'>.</span><a href="index.c.html#LN83"><span class='Ref_to_Member'>htups</span></a> <span class='Operator'>= </span><a href="index.c.html#LN2804"><span class='Ref_To_Local'>state</span></a><span class='Operator'>.</span><a href="index.c.html#LN84"><span class='Ref_to_Member'>itups</span></a> <span class='Operator'>= </span><a href="index.c.html#LN2804"><span class='Ref_To_Local'>state</span></a><span class='Operator'>.</span><a href="index.c.html#LN85"><span class='Ref_to_Member'>tups_inserted</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="../../include/access/genam.h.html#LN165"><span class='Ref_to_Proto'>index_bulk_delete</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="index.c.html#LN2803"><span class='Ref_To_Local'>ivinfo</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                             <a href="index.c.html#LN116"><span class='Ref_to_Proto'>validate_index_callback</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><a href="index.c.html#LN2804"><span class='Ref_To_Local'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Execute the sort */ 
</span>    <a href="../../include/utils/tuplesort.h.html#LN94"><span class='Ref_to_Proto'>tuplesort_performsort</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2804"><span class='Ref_To_Local'>state</span></a><span class='Operator'>.</span><a href="index.c.html#LN81"><span class='Ref_to_Member'>tuplesort</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now scan the heap and "merge" it with the index 
     */ 
</span>    <a href="index.c.html#LN117"><span class='Ref_to_Proto'>validate_index_heapscan</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2800"><span class='Ref_To_Local'>heapRelation</span></a><span class='Delimiter'>, 
</span>                            <a href="index.c.html#LN2801"><span class='Ref_To_Local'>indexRelation</span></a><span class='Delimiter'>, 
</span>                            <a href="index.c.html#LN2802"><span class='Ref_To_Local'>indexInfo</span></a><span class='Delimiter'>, 
</span>                            <a href="index.c.html#LN2798"><span class='Ref_to_Parameter'>snapshot</span></a><span class='Delimiter'>, 
</span>                            <span class='Operator'>&</span><a href="index.c.html#LN2804"><span class='Ref_To_Local'>state</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Done with tuplesort object */ 
</span>    <a href="../../include/utils/tuplesort.h.html#LN106"><span class='Ref_to_Proto'>tuplesort_end</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2804"><span class='Ref_To_Local'>state</span></a><span class='Operator'>.</span><a href="index.c.html#LN81"><span class='Ref_to_Member'>tuplesort</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Delimiter'>, 
</span>         <span class='String'>"validate_index found %.0f heap tuples, %.0f index tuples; inserted %.0f missing tuples"</span><span class='Delimiter'>, 
</span>         <a href="index.c.html#LN2804"><span class='Ref_To_Local'>state</span></a><span class='Operator'>.</span><a href="index.c.html#LN83"><span class='Ref_to_Member'>htups</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN2804"><span class='Ref_To_Local'>state</span></a><span class='Operator'>.</span><a href="index.c.html#LN84"><span class='Ref_to_Member'>itups</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN2804"><span class='Ref_To_Local'>state</span></a><span class='Operator'>.</span><a href="index.c.html#LN85"><span class='Ref_to_Member'>tups_inserted</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Roll back any GUC changes executed by index functions */ 
</span>    <a href="../../include/utils/guc.h.html#LN355"><span class='Ref_to_Proto'>AtEOXact_GUC</span></a><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Delimiter'>, </span><a href="index.c.html#LN2807"><span class='Ref_To_Local'>save_nestlevel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Restore userid and security context */ 
</span>    <a href="../../include/miscadmin.h.html#LN313"><span class='Ref_to_Proto'>SetUserIdAndSecContext</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2805"><span class='Ref_To_Local'>save_userid</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN2806"><span class='Ref_To_Local'>save_sec_context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Close rels, but keep locks */ 
</span>    <a href="../../include/access/genam.h.html#LN130"><span class='Ref_to_Proto'>index_close</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2801"><span class='Ref_To_Local'>indexRelation</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN33"><span class='Ref_to_Const'>NoLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/access/heapam.h.html#LN96"><span class='Ref_to_Macro'>heap_close</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2800"><span class='Ref_To_Local'>heapRelation</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN33"><span class='Ref_to_Const'>NoLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end validate_index &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * itemptr_encode - Encode ItemPointer as int64/int8 
 * 
 * This representation must produce values encoded as int64 that sort in the 
 * same order as their corresponding original TID values would (using the 
 * default int8 opclass to produce a result equivalent to the default TID 
 * opclass). 
 * 
 * As noted in validate_index(), this can be significantly faster. 
 */ 
</span><span class='Keyword'>static inline </span><a href="../../include/c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a> 
<a name="LN2900"></a><span class='Declare_Function'>itemptr_encode</span><span class='Parentheses'>(</span><a href="../../include/storage/itemptr.h.html#LN47"><span class='Ref_to_Typedef'>ItemPointer</span></a> <span class='Declare_Parameter'>itemptr</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2902"></a>    <a href="../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Local'>block</span> <span class='Operator'>= </span><a href="../../include/storage/itemptr.h.html#LN74"><span class='Ref_to_Macro'>ItemPointerGetBlockNumber</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2900"><span class='Ref_to_Parameter'>itemptr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2903"></a>    <a href="../../include/storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Local'>offset</span> <span class='Operator'>= </span><a href="../../include/storage/itemptr.h.html#LN93"><span class='Ref_to_Macro'>ItemPointerGetOffsetNumber</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2900"><span class='Ref_to_Parameter'>itemptr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2904"></a>    <a href="../../include/c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a>       <span class='Declare_Local'>encoded</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Use the 16 least significant bits for the offset.  32 adjacent bits are 
     * used for the block number.  Since remaining bits are unused, there 
     * cannot be negative encoded values (We assume a two's complement 
     * representation). 
     */ 
</span>    <a href="index.c.html#LN2904"><span class='Ref_To_Local'>encoded</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../include/c.h.html#LN297"><span class='Ref_to_Typedef'>uint64</span></a><span class='Parentheses'>) </span><a href="index.c.html#LN2902"><span class='Ref_To_Local'>block</span></a> <span class='Operator'>&LT;&LT; </span><span class='Number'>16</span><span class='Parentheses'>)</span> <span class='Operator'>| </span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN266"><span class='Ref_to_Typedef'>uint16</span></a><span class='Parentheses'>) </span><a href="index.c.html#LN2903"><span class='Ref_To_Local'>offset</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="index.c.html#LN2904"><span class='Ref_To_Local'>encoded</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * itemptr_decode - Decode int64/int8 representation back to ItemPointer 
 */ 
</span><span class='Keyword'>static inline void 
</span><a name="LN2921"></a><span class='Declare_Function'>itemptr_decode</span><span class='Parentheses'>(</span><a href="../../include/storage/itemptr.h.html#LN47"><span class='Ref_to_Typedef'>ItemPointer</span></a> <span class='Declare_Parameter'>itemptr</span><span class='Delimiter'>, </span><a href="../../include/c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a> <span class='Declare_Parameter'>encoded</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2923"></a>    <a href="../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Local'>block</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a><span class='Parentheses'>) (</span><a href="index.c.html#LN2921"><span class='Ref_to_Parameter'>encoded</span></a> <span class='Operator'>&GT;&GT; </span><span class='Number'>16</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2924"></a>    <a href="../../include/storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Local'>offset</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a><span class='Parentheses'>) (</span><a href="index.c.html#LN2921"><span class='Ref_to_Parameter'>encoded</span></a> <span class='Operator'>& </span><span class='Number'>0xFFFF</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/storage/itemptr.h.html#LN103"><span class='Ref_to_Macro'>ItemPointerSet</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2921"><span class='Ref_to_Parameter'>itemptr</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN2923"><span class='Ref_To_Local'>block</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN2924"><span class='Ref_To_Local'>offset</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * validate_index_callback - bulkdelete callback to collect the index TIDs 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN2933"></a><span class='Declare_Function'>validate_index_callback</span><span class='Parentheses'>(</span><a href="../../include/storage/itemptr.h.html#LN47"><span class='Ref_to_Typedef'>ItemPointer</span></a> <span class='Declare_Parameter'>itemptr</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>opaque</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2935"></a>    <a href="index.c.html#LN79"><span class='Ref_to_Typedef'>v_i_state</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>state</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="index.c.html#LN79"><span class='Ref_to_Typedef'>v_i_state</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="index.c.html#LN2933"><span class='Ref_to_Parameter'>opaque</span></a><span class='Delimiter'>; 
</span><a name="LN2936"></a>    <a href="../../include/c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a>       <span class='Declare_Local'>encoded</span> <span class='Operator'>= </span><a href="index.c.html#LN114"><span class='Ref_to_Proto'>itemptr_encode</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2933"><span class='Ref_to_Parameter'>itemptr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/utils/tuplesort.h.html#LN91"><span class='Ref_to_Proto'>tuplesort_putdatum</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2935"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="index.c.html#LN81"><span class='Ref_to_Member'>tuplesort</span></a><span class='Delimiter'>, </span><a href="../../include/postgres.h.html#LN624"><span class='Ref_to_Macro'>Int64GetDatum</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2936"><span class='Ref_To_Local'>encoded</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN2935"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="index.c.html#LN84"><span class='Ref_to_Member'>itups</span></a> <span class='Operator'>+= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>               <span class='Comment_Single_Line'>/* never actually delete anything */ 
</span><span class='Delimiter'>} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * validate_index_heapscan - second table scan for concurrent index build 
 * 
 * This has much code in common with IndexBuildHeapScan, but it's enough 
 * different that it seems cleaner to have two routines not one. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2950"></a><span class='Declare_Function'>validate_index_heapscan</span><span class='Parentheses'>(</span><a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>heapRelation</span><span class='Delimiter'>, 
</span><a name="LN2951"></a>                        <a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>indexRelation</span><span class='Delimiter'>, 
</span><a name="LN2952"></a>                        <a href="../../include/nodes/execnodes.h.html#LN130"><span class='Ref_to_Struct'>IndexInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>indexInfo</span><span class='Delimiter'>, 
</span><a name="LN2953"></a>                        <a href="../../include/utils/snapshot.h.html#LN22"><span class='Ref_to_Typedef'>Snapshot</span></a> <span class='Declare_Parameter'>snapshot</span><span class='Delimiter'>, 
</span><a name="LN2954"></a>                        <a href="index.c.html#LN79"><span class='Ref_to_Typedef'>v_i_state</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>state</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2956"></a>    <a href="../../include/access/heapam.h.html#LN99"><span class='Ref_to_Typedef'>HeapScanDesc</span></a> <span class='Declare_Local'>scan</span><span class='Delimiter'>; 
</span><a name="LN2957"></a>    <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>heapTuple</span><span class='Delimiter'>; 
</span><a name="LN2958"></a>    <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>values</span><span class='Delimiter'>[</span><a href="../../include/pg_config_manual.h.html#LN45"><span class='Ref_to_Const'>INDEX_MAX_KEYS</span></a><span class='Delimiter'>]; 
</span><a name="LN2959"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>isnull</span><span class='Delimiter'>[</span><a href="../../include/pg_config_manual.h.html#LN45"><span class='Ref_to_Const'>INDEX_MAX_KEYS</span></a><span class='Delimiter'>]; 
</span><a name="LN2960"></a>    <a href="../../include/nodes/execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>predicate</span><span class='Delimiter'>; 
</span><a name="LN2961"></a>    <a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Local'>slot</span><span class='Delimiter'>; 
</span><a name="LN2962"></a>    <a href="../../include/nodes/execnodes.h.html#LN402"><span class='Ref_to_Struct'>EState</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>estate</span><span class='Delimiter'>; 
</span><a name="LN2963"></a>    <a href="../../include/nodes/execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Local'>econtext</span><span class='Delimiter'>; 
</span><a name="LN2964"></a>    <a href="../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Local'>root_blkno</span> <span class='Operator'>= </span><a href="../../include/storage/block.h.html#LN32"><span class='Ref_to_Const'>InvalidBlockNumber</span></a><span class='Delimiter'>; 
</span><a name="LN2965"></a>    <a href="../../include/storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Local'>root_offsets</span><span class='Delimiter'>[</span><a href="../../include/access/htup_details.h.html#LN574"><span class='Ref_to_Const'>MaxHeapTuplesPerPage</span></a><span class='Delimiter'>]; 
</span><a name="LN2966"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>in_index</span><span class='Delimiter'>[</span><a href="../../include/access/htup_details.h.html#LN574"><span class='Ref_to_Const'>MaxHeapTuplesPerPage</span></a><span class='Delimiter'>]; 
</span> 
    <span class='Comment_Multi_Line'>/* state variables for the merge */ 
</span><a name="LN2969"></a>    <a href="../../include/storage/itemptr.h.html#LN47"><span class='Ref_to_Typedef'>ItemPointer</span></a> <span class='Declare_Local'>indexcursor</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN2970"></a>    <a href="../../include/storage/itemptr.h.html#LN35"><span class='Ref_to_Struct'>ItemPointerData</span></a> <span class='Declare_Local'>decoded</span><span class='Delimiter'>; 
</span><a name="LN2971"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>tuplesort_empty</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * sanity checks 
     */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2951"><span class='Ref_to_Parameter'>indexRelation</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relam<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Need an EState for evaluation of index expressions and partial-index 
     * predicates.  Also a slot to hold the current tuple. 
     */ 
</span>    <a href="index.c.html#LN2962"><span class='Ref_To_Local'>estate</span></a> <span class='Operator'>= </span><a href="../executor/execUtils.c.html#LN78"><span class='Ref_to_Func'>CreateExecutorState</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN2963"><span class='Ref_To_Local'>econtext</span></a> <span class='Operator'>= </span><a href="../../include/executor/executor.h.html#LN455"><span class='Ref_to_Macro'>GetPerTupleExprContext</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2962"><span class='Ref_To_Local'>estate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN2961"><span class='Ref_To_Local'>slot</span></a> <span class='Operator'>= </span><a href="../../include/executor/tuptable.h.html#LN144"><span class='Ref_to_Proto'>MakeSingleTupleTableSlot</span></a><span class='Parentheses'>(</span><a href="../../include/utils/rel.h.html#LN428"><span class='Ref_to_Macro'>RelationGetDescr</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2950"><span class='Ref_to_Parameter'>heapRelation</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Arrange for econtext's scan tuple to be the tuple under test */ 
</span>    <a href="index.c.html#LN2963"><span class='Ref_To_Local'>econtext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN196"><span class='Ref_to_Member'>ecxt_scantuple</span></a> <span class='Operator'>= </span><a href="index.c.html#LN2961"><span class='Ref_To_Local'>slot</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Set up execution state for predicate, if any. */ 
</span>    <a href="index.c.html#LN2960"><span class='Ref_To_Local'>predicate</span></a> <span class='Operator'>= </span><a href="../../include/executor/executor.h.html#LN247"><span class='Ref_to_Proto'>ExecPrepareQual</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2952"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN137"><span class='Ref_to_Member'>ii_Predicate</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN2962"><span class='Ref_To_Local'>estate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Prepare for scan of the base relation.  We need just those tuples 
     * satisfying the passed-in reference snapshot.  We must disable syncscan 
     * here, because it's critical that we read from block zero forward to 
     * match the sorted TIDs. 
     */ 
</span>    <a href="index.c.html#LN2956"><span class='Ref_To_Local'>scan</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN112"><span class='Ref_to_Proto'>heap_beginscan_strat</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2950"><span class='Ref_to_Parameter'>heapRelation</span></a><span class='Delimiter'>,</span>   <span class='Comment_Single_Line'>/* relation */ 
</span>                                <a href="index.c.html#LN2953"><span class='Ref_to_Parameter'>snapshot</span></a><span class='Delimiter'>,</span>       <span class='Comment_Single_Line'>/* snapshot */ 
</span>                                <span class='Number'>0</span><span class='Delimiter'>,</span>      <span class='Comment_Single_Line'>/* number of keys */ 
</span>                                <span class='Null_Value'>NULL</span><span class='Delimiter'>,</span>   <span class='Comment_Single_Line'>/* scan key */ 
</span>                                <span class='Boolean'>true</span><span class='Delimiter'>,</span>   <span class='Comment_Single_Line'>/* buffer access strategy OK */ 
</span>                                <span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* syncscan not OK */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Scan all tuples matching the snapshot. 
     */ 
</span>    <span class='Control'>while</span> <span class='Parentheses'>((</span><a href="index.c.html#LN2957"><span class='Ref_To_Local'>heapTuple</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN127"><span class='Ref_to_Proto'>heap_getnext</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2956"><span class='Ref_To_Local'>scan</span></a><span class='Delimiter'>, </span><a href="../../include/access/sdir.h.html#LN25"><span class='Ref_to_EnumConst'>ForwardScanDirection</span></a><span class='Parentheses'>))</span> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span><a name="LN3010"></a>        <a href="../../include/storage/itemptr.h.html#LN47"><span class='Ref_to_Typedef'>ItemPointer</span></a> <span class='Declare_Local'>heapcursor</span> <span class='Operator'>= &</span><a href="index.c.html#LN2957"><span class='Ref_To_Local'>heapTuple</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/htup.h.html#LN64"><span class='Ref_to_Member'>t_self</span></a><span class='Delimiter'>; 
</span><a name="LN3011"></a>        <a href="../../include/storage/itemptr.h.html#LN35"><span class='Ref_to_Struct'>ItemPointerData</span></a> <span class='Declare_Local'>rootTuple</span><span class='Delimiter'>; 
</span><a name="LN3012"></a>        <a href="../../include/storage/off.h.html#LN23"><span class='Ref_to_Typedef'>OffsetNumber</span></a> <span class='Declare_Local'>root_offnum</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/miscadmin.h.html#LN99"><span class='Ref_to_Macro'>CHECK_FOR_INTERRUPTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <a href="index.c.html#LN2954"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="index.c.html#LN83"><span class='Ref_to_Member'>htups</span></a> <span class='Operator'>+= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * As commented in IndexBuildHeapScan, we should index heap-only 
         * tuples under the TIDs of their root tuples; so when we advance onto 
         * a new heap page, build a map of root item offsets on the page. 
         * 
         * This complicates merging against the tuplesort output: we will 
         * visit the live tuples in order by their offsets, but the root 
         * offsets that we need to compare against the index contents might be 
         * ordered differently.  So we might have to "look back" within the 
         * tuplesort output, but only within the current page.  We handle that 
         * by keeping a bool array in_index[] showing all the 
         * already-passed-over tuplesort output TIDs of the current page. We 
         * clear that array here, when advancing onto a new heap page. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN2956"><span class='Ref_To_Local'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/relscan.h.html#LN68"><span class='Ref_to_Member'>rs_cblock</span></a> <span class='Operator'>!= </span><a href="index.c.html#LN2964"><span class='Ref_To_Local'>root_blkno</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN3034"></a>            <a href="../../include/storage/bufpage.h.html#LN73"><span class='Ref_to_Typedef'>Page</span></a>        <span class='Declare_Local'>page</span> <span class='Operator'>= </span><a href="../../include/storage/bufmgr.h.html#LN159"><span class='Ref_to_Macro'>BufferGetPage</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2956"><span class='Ref_To_Local'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/relscan.h.html#LN69"><span class='Ref_to_Member'>rs_cbuf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="../../include/storage/bufmgr.h.html#LN214"><span class='Ref_to_Proto'>LockBuffer</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2956"><span class='Ref_To_Local'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/relscan.h.html#LN69"><span class='Ref_to_Member'>rs_cbuf</span></a><span class='Delimiter'>, </span><a href="../../include/storage/bufmgr.h.html#LN87"><span class='Ref_to_Const'>BUFFER_LOCK_SHARE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../include/access/heapam.h.html#LN192"><span class='Ref_to_Proto'>heap_get_root_tuples</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3034"><span class='Ref_To_Local'>page</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN2965"><span class='Ref_To_Local'>root_offsets</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../include/storage/bufmgr.h.html#LN214"><span class='Ref_to_Proto'>LockBuffer</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2956"><span class='Ref_To_Local'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/relscan.h.html#LN69"><span class='Ref_to_Member'>rs_cbuf</span></a><span class='Delimiter'>, </span><a href="../../include/storage/bufmgr.h.html#LN86"><span class='Ref_to_Const'>BUFFER_LOCK_UNLOCK</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            memset<span class='Parentheses'>(</span><a href="index.c.html#LN2966"><span class='Ref_To_Local'>in_index</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="index.c.html#LN2966"><span class='Ref_To_Local'>in_index</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
            <a href="index.c.html#LN2964"><span class='Ref_To_Local'>root_blkno</span></a> <span class='Operator'>= </span><a href="index.c.html#LN2956"><span class='Ref_To_Local'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/relscan.h.html#LN68"><span class='Ref_to_Member'>rs_cblock</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* Convert actual tuple TID to root TID */ 
</span>        <a href="index.c.html#LN3011"><span class='Ref_To_Local'>rootTuple</span></a> <span class='Operator'>= *</span><a href="index.c.html#LN3010"><span class='Ref_To_Local'>heapcursor</span></a><span class='Delimiter'>; 
</span>        <a href="index.c.html#LN3012"><span class='Ref_To_Local'>root_offnum</span></a> <span class='Operator'>= </span><a href="../../include/storage/itemptr.h.html#LN93"><span class='Ref_to_Macro'>ItemPointerGetOffsetNumber</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3010"><span class='Ref_To_Local'>heapcursor</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/access/htup_details.h.html#LN685"><span class='Ref_to_Macro'>HeapTupleIsHeapOnly</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2957"><span class='Ref_To_Local'>heapTuple</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="index.c.html#LN3012"><span class='Ref_To_Local'>root_offnum</span></a> <span class='Operator'>= </span><a href="index.c.html#LN2965"><span class='Ref_To_Local'>root_offsets</span></a><span class='Delimiter'>[</span><a href="index.c.html#LN3012"><span class='Ref_To_Local'>root_offnum</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/storage/off.h.html#LN39"><span class='Ref_to_Macro'>OffsetNumberIsValid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3012"><span class='Ref_To_Local'>root_offnum</span></a><span class='Parentheses'>))</span> 
                <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"failed to find parent tuple for heap-only tuple at (%u,%u) in table \"%s\""</span><span class='Delimiter'>, 
</span>                     <a href="../../include/storage/itemptr.h.html#LN74"><span class='Ref_to_Macro'>ItemPointerGetBlockNumber</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3010"><span class='Ref_To_Local'>heapcursor</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../include/storage/itemptr.h.html#LN93"><span class='Ref_to_Macro'>ItemPointerGetOffsetNumber</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3010"><span class='Ref_To_Local'>heapcursor</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../../include/utils/rel.h.html#LN436"><span class='Ref_to_Macro'>RelationGetRelationName</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2950"><span class='Ref_to_Parameter'>heapRelation</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="../../include/storage/itemptr.h.html#LN124"><span class='Ref_to_Macro'>ItemPointerSetOffsetNumber</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="index.c.html#LN3011"><span class='Ref_To_Local'>rootTuple</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN3012"><span class='Ref_To_Local'>root_offnum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * "merge" by skipping through the index tuples until we find or pass 
         * the current root tuple. 
         */ 
</span>        <span class='Control'>while</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="index.c.html#LN2971"><span class='Ref_To_Local'>tuplesort_empty</span></a> <span class='Operator'>&& 
</span>               <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="index.c.html#LN2969"><span class='Ref_To_Local'>indexcursor</span></a> <span class='Operator'>|| 
</span>                <a href="../storage/page/itemptr.c.html#LN50"><span class='Ref_to_Func'>ItemPointerCompare</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2969"><span class='Ref_To_Local'>indexcursor</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="index.c.html#LN3011"><span class='Ref_To_Local'>rootTuple</span></a><span class='Parentheses'>) </span><span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN3068"></a>            <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>ts_val</span><span class='Delimiter'>; 
</span><a name="LN3069"></a>            <span class='Keyword'>bool</span>        <span class='Declare_Local'>ts_isnull</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN2969"><span class='Ref_To_Local'>indexcursor</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * Remember index items seen earlier on the current heap page 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/storage/itemptr.h.html#LN74"><span class='Ref_to_Macro'>ItemPointerGetBlockNumber</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2969"><span class='Ref_To_Local'>indexcursor</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="index.c.html#LN2964"><span class='Ref_To_Local'>root_blkno</span></a><span class='Parentheses'>)</span> 
                    <a href="index.c.html#LN2966"><span class='Ref_To_Local'>in_index</span></a><span class='Delimiter'>[</span><a href="../../include/storage/itemptr.h.html#LN93"><span class='Ref_to_Macro'>ItemPointerGetOffsetNumber</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2969"><span class='Ref_To_Local'>indexcursor</span></a><span class='Parentheses'>) </span><span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <a href="index.c.html#LN2971"><span class='Ref_To_Local'>tuplesort_empty</span></a> <span class='Operator'>= !</span><a href="../../include/utils/tuplesort.h.html#LN100"><span class='Ref_to_Proto'>tuplesort_getdatum</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2954"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="index.c.html#LN81"><span class='Ref_to_Member'>tuplesort</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, 
</span>                                                  <span class='Operator'>&</span><a href="index.c.html#LN3068"><span class='Ref_To_Local'>ts_val</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="index.c.html#LN3069"><span class='Ref_To_Local'>ts_isnull</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="index.c.html#LN2971"><span class='Ref_To_Local'>tuplesort_empty</span></a> <span class='Operator'>|| !</span><a href="index.c.html#LN3069"><span class='Ref_To_Local'>ts_isnull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="index.c.html#LN2971"><span class='Ref_To_Local'>tuplesort_empty</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="index.c.html#LN115"><span class='Ref_to_Proto'>itemptr_decode</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="index.c.html#LN2970"><span class='Ref_To_Local'>decoded</span></a><span class='Delimiter'>, </span><a href="../../include/postgres.h.html#LN610"><span class='Ref_to_Macro'>DatumGetInt64</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3068"><span class='Ref_To_Local'>ts_val</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <a href="index.c.html#LN2969"><span class='Ref_To_Local'>indexcursor</span></a> <span class='Operator'>= &</span><a href="index.c.html#LN2970"><span class='Ref_To_Local'>decoded</span></a><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* If int8 is pass-by-ref, free (encoded) TID Datum memory */ 
</span><span class='Directive'>#ifndef</span> USE_FLOAT8_BYVAL 
                <a href="../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN554"><span class='Ref_to_Macro'>DatumGetPointer</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3068"><span class='Ref_To_Local'>ts_val</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* Be tidy */ 
</span>                <a href="index.c.html#LN2969"><span class='Ref_To_Local'>indexcursor</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while !tuplesort_empty&&(!i... &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* 
         * If the tuplesort has overshot *and* we didn't see a match earlier, 
         * then this tuple is missing from the index, so insert it. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="index.c.html#LN2971"><span class='Ref_To_Local'>tuplesort_empty</span></a> <span class='Operator'>|| 
</span>             <a href="../storage/page/itemptr.c.html#LN50"><span class='Ref_to_Func'>ItemPointerCompare</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2969"><span class='Ref_To_Local'>indexcursor</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="index.c.html#LN3011"><span class='Ref_To_Local'>rootTuple</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>            <span class='Operator'>!</span><a href="index.c.html#LN2966"><span class='Ref_To_Local'>in_index</span></a><span class='Delimiter'>[</span><a href="index.c.html#LN3012"><span class='Ref_To_Local'>root_offnum</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <a href="../../include/utils/memutils.h.html#LN73"><span class='Ref_to_Proto'>MemoryContextReset</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2963"><span class='Ref_To_Local'>econtext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN202"><span class='Ref_to_Member'>ecxt_per_tuple_memory</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Set up for predicate or expression evaluation */ 
</span>            <a href="../../include/executor/tuptable.h.html#LN147"><span class='Ref_to_Proto'>ExecStoreTuple</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2957"><span class='Ref_To_Local'>heapTuple</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN2961"><span class='Ref_To_Local'>slot</span></a><span class='Delimiter'>, </span><a href="../../include/storage/buf.h.html#LN24"><span class='Ref_to_Const'>InvalidBuffer</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * In a partial index, discard tuples that don't satisfy the 
             * predicate. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN2960"><span class='Ref_To_Local'>predicate</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/executor/executor.h.html#LN344"><span class='Ref_to_Func'>ExecQual</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2960"><span class='Ref_To_Local'>predicate</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN2963"><span class='Ref_To_Local'>econtext</span></a><span class='Parentheses'>))</span> 
                    <span class='Control'>continue</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * For the current heap tuple, extract all the attributes we use 
             * in this index, and note which are null.  This also performs 
             * evaluation of any expressions needed. 
             */ 
</span>            <a href="../../include/catalog/index.h.html#LN85"><span class='Ref_to_Proto'>FormIndexDatum</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2952"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Delimiter'>, 
</span>                           <a href="index.c.html#LN2961"><span class='Ref_To_Local'>slot</span></a><span class='Delimiter'>, 
</span>                           <a href="index.c.html#LN2962"><span class='Ref_To_Local'>estate</span></a><span class='Delimiter'>, 
</span>                           <a href="index.c.html#LN2958"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>, 
</span>                           <a href="index.c.html#LN2959"><span class='Ref_To_Local'>isnull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * You'd think we should go ahead and build the index tuple here, 
             * but some index AMs want to do further processing on the data 
             * first. So pass the values[] and isnull[] arrays, instead. 
             */ 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * If the tuple is already committed dead, you might think we 
             * could suppress uniqueness checking, but this is no longer true 
             * in the presence of HOT, because the insert is actually a proxy 
             * for a uniqueness check on the whole HOT-chain.  That is, the 
             * tuple we have here could be dead because it was already 
             * HOT-updated, and if so the updating transaction will not have 
             * thought it should insert index entries.  The index AM will 
             * check the whole HOT-chain and correctly detect a conflict if 
             * there is one. 
             */ 
</span> 
            <a href="../../include/access/genam.h.html#LN132"><span class='Ref_to_Proto'>index_insert</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2951"><span class='Ref_to_Parameter'>indexRelation</span></a><span class='Delimiter'>, 
</span>                         <a href="index.c.html#LN2958"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>, 
</span>                         <a href="index.c.html#LN2959"><span class='Ref_To_Local'>isnull</span></a><span class='Delimiter'>, 
</span>                         <span class='Operator'>&</span><a href="index.c.html#LN3011"><span class='Ref_To_Local'>rootTuple</span></a><span class='Delimiter'>, 
</span>                         <a href="index.c.html#LN2950"><span class='Ref_to_Parameter'>heapRelation</span></a><span class='Delimiter'>, 
</span>                         <a href="index.c.html#LN2952"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN145"><span class='Ref_to_Member'>ii_Unique</span></a> <span class='Operator'>? 
</span>                         <a href="../../include/access/genam.h.html#LN113"><span class='Ref_to_EnumConst'>UNIQUE_CHECK_YES</span></a> <span class='Operator'>: </span><a href="../../include/access/genam.h.html#LN112"><span class='Ref_to_EnumConst'>UNIQUE_CHECK_NO</span></a><span class='Delimiter'>, 
</span>                         <a href="index.c.html#LN2952"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="index.c.html#LN2954"><span class='Ref_to_Parameter'>state</span></a><span class='Operator'>-&GT;</span><a href="index.c.html#LN85"><span class='Ref_to_Member'>tups_inserted</span></a> <span class='Operator'>+= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if (tuplesort_empty||Ite... &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while (heapTuple=heap_getne... &raquo; </span> 
 
    <a href="../../include/access/heapam.h.html#LN126"><span class='Ref_to_Proto'>heap_endscan</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2956"><span class='Ref_To_Local'>scan</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/executor/tuptable.h.html#LN145"><span class='Ref_to_Proto'>ExecDropSingleTupleTableSlot</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2961"><span class='Ref_To_Local'>slot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../executor/execUtils.c.html#LN176"><span class='Ref_to_Func'>FreeExecutorState</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN2962"><span class='Ref_To_Local'>estate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* These may have been pointing to the now-gone estate */ 
</span>    <a href="index.c.html#LN2952"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN136"><span class='Ref_to_Member'>ii_ExpressionsState</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN2952"><span class='Ref_to_Parameter'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN138"><span class='Ref_to_Member'>ii_PredicateState</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end validate_index_heapscan &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * index_set_state_flags - adjust pg_index state flags 
 * 
 * This is used during CREATE/DROP INDEX CONCURRENTLY to adjust the pg_index 
 * flags that denote the index's state.  Because the update is not 
 * transactional and will not roll back on error, this must only be used as 
 * the last step in a transaction that has not made any transactional catalog 
 * updates! 
 * 
 * Note that heap_inplace_update does send a cache inval message for the 
 * tuple, so other sessions will hear about the update as soon as we commit. 
 * 
 * NB: In releases prior to PostgreSQL 9.4, the use of a non-transactional 
 * update here would have been unsafe; now that MVCC rules apply even for 
 * system catalog scans, we could potentially use a transactional update here 
 * instead. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN3195"></a><span class='Declare_Function'>index_set_state_flags</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>indexId</span><span class='Delimiter'>, </span><a href="../../include/catalog/index.h.html#LN31"><span class='Ref_to_Typedef'>IndexStateFlagsAction</span></a> <span class='Declare_Parameter'>action</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3197"></a>    <a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>pg_index</span><span class='Delimiter'>; 
</span><a name="LN3198"></a>    <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>indexTuple</span><span class='Delimiter'>; 
</span><a name="LN3199"></a>    <a href="../../include/catalog/pg_index.h.html#LN66"><span class='Ref_to_Typedef'>Form_pg_index</span></a> <span class='Declare_Local'>indexForm</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Assert that current xact hasn't done any transactional updates */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../include/access/xact.h.html#LN332"><span class='Ref_to_Proto'>GetTopTransactionIdIfAny</span></a><span class='Parentheses'>() </span><span class='Operator'>== </span><a href="../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Open pg_index and fetch a writable copy of the index's tuple */ 
</span>    <a href="index.c.html#LN3197"><span class='Ref_To_Local'>pg_index</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN91"><span class='Ref_to_Proto'>heap_open</span></a><span class='Parentheses'>(</span><a href="../../include/catalog/pg_index.h.html#LN28"><span class='Ref_to_Const'>IndexRelationId</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN37"><span class='Ref_to_Const'>RowExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="index.c.html#LN3198"><span class='Ref_To_Local'>indexTuple</span></a> <span class='Operator'>= </span><a href="../../include/utils/syscache.h.html#LN164"><span class='Ref_to_Macro'>SearchSysCacheCopy1</span></a><span class='Parentheses'>(</span><a href="../../include/utils/syscache.h.html#LN65"><span class='Ref_to_EnumConst'>INDEXRELID</span></a><span class='Delimiter'>, 
</span>                                     <a href="../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3195"><span class='Ref_to_Parameter'>indexId</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3198"><span class='Ref_To_Local'>indexTuple</span></a><span class='Parentheses'>))</span> 
        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cache lookup failed for index %u"</span><span class='Delimiter'>, </span><a href="index.c.html#LN3195"><span class='Ref_to_Parameter'>indexId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN3199"><span class='Ref_To_Local'>indexForm</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/catalog/pg_index.h.html#LN66"><span class='Ref_to_Typedef'>Form_pg_index</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3198"><span class='Ref_To_Local'>indexTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Perform the requested state change on the copy */ 
</span>    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="index.c.html#LN3195"><span class='Ref_to_Parameter'>action</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../include/catalog/index.h.html#LN33"><span class='Ref_to_EnumConst'>INDEX_CREATE_SET_READY</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* Set indisready during a CREATE INDEX CONCURRENTLY sequence */ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="index.c.html#LN3199"><span class='Ref_To_Local'>indexForm</span></a><span class='Operator'>-&GT;</span>indislive<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="index.c.html#LN3199"><span class='Ref_To_Local'>indexForm</span></a><span class='Operator'>-&GT;</span>indisready<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="index.c.html#LN3199"><span class='Ref_To_Local'>indexForm</span></a><span class='Operator'>-&GT;</span>indisvalid<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="index.c.html#LN3199"><span class='Ref_To_Local'>indexForm</span></a><span class='Operator'>-&GT;</span>indisready <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/catalog/index.h.html#LN34"><span class='Ref_to_EnumConst'>INDEX_CREATE_SET_VALID</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* Set indisvalid during a CREATE INDEX CONCURRENTLY sequence */ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="index.c.html#LN3199"><span class='Ref_To_Local'>indexForm</span></a><span class='Operator'>-&GT;</span>indislive<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="index.c.html#LN3199"><span class='Ref_To_Local'>indexForm</span></a><span class='Operator'>-&GT;</span>indisready<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="index.c.html#LN3199"><span class='Ref_To_Local'>indexForm</span></a><span class='Operator'>-&GT;</span>indisvalid<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="index.c.html#LN3199"><span class='Ref_To_Local'>indexForm</span></a><span class='Operator'>-&GT;</span>indisvalid <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/catalog/index.h.html#LN35"><span class='Ref_to_EnumConst'>INDEX_DROP_CLEAR_VALID</span></a><span class='Operator'>: 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Clear indisvalid during a DROP INDEX CONCURRENTLY sequence 
             * 
             * If indisready == true we leave it set so the index still gets 
             * maintained by active transactions.  We only need to ensure that 
             * indisvalid is false.  (We don't assert that either is initially 
             * true, though, since we want to be able to retry a DROP INDEX 
             * CONCURRENTLY that failed partway through.) 
             * 
             * Note: the CLUSTER logic assumes that indisclustered cannot be 
             * set on any invalid index, so clear that flag too. 
             */ 
</span>            <a href="index.c.html#LN3199"><span class='Ref_To_Local'>indexForm</span></a><span class='Operator'>-&GT;</span>indisvalid <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="index.c.html#LN3199"><span class='Ref_To_Local'>indexForm</span></a><span class='Operator'>-&GT;</span>indisclustered <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../include/catalog/index.h.html#LN36"><span class='Ref_to_EnumConst'>INDEX_DROP_SET_DEAD</span></a><span class='Operator'>: 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Clear indisready/indislive during DROP INDEX CONCURRENTLY 
             * 
             * We clear both indisready and indislive, because we not only 
             * want to stop updates, we want to prevent sessions from touching 
             * the index at all. 
             */ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="index.c.html#LN3199"><span class='Ref_To_Local'>indexForm</span></a><span class='Operator'>-&GT;</span>indisvalid<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="index.c.html#LN3199"><span class='Ref_To_Local'>indexForm</span></a><span class='Operator'>-&GT;</span>indisready <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="index.c.html#LN3199"><span class='Ref_To_Local'>indexForm</span></a><span class='Operator'>-&GT;</span>indislive <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch action &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* ... and write it back in-place */ 
</span>    <a href="../../include/access/heapam.h.html#LN168"><span class='Ref_to_Proto'>heap_inplace_update</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3197"><span class='Ref_To_Local'>pg_index</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN3198"><span class='Ref_To_Local'>indexTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/access/heapam.h.html#LN96"><span class='Ref_to_Macro'>heap_close</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3197"><span class='Ref_To_Local'>pg_index</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN37"><span class='Ref_to_Const'>RowExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end index_set_state_flags &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * IndexGetRelation: given an index's relation OID, get the OID of the 
 * relation it is an index on.  Uses the system cache. 
 */ 
</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> 
<a name="LN3274"></a><span class='Declare_Function'>IndexGetRelation</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>indexId</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>missing_ok</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3276"></a>    <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>tuple</span><span class='Delimiter'>; 
</span><a name="LN3277"></a>    <a href="../../include/catalog/pg_index.h.html#LN66"><span class='Ref_to_Typedef'>Form_pg_index</span></a> <span class='Declare_Local'>index</span><span class='Delimiter'>; 
</span><a name="LN3278"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span> 
    <a href="index.c.html#LN3276"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>= </span><a href="../../include/utils/syscache.h.html#LN155"><span class='Ref_to_Macro'>SearchSysCache1</span></a><span class='Parentheses'>(</span><a href="../../include/utils/syscache.h.html#LN65"><span class='Ref_to_EnumConst'>INDEXRELID</span></a><span class='Delimiter'>, </span><a href="../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3274"><span class='Ref_to_Parameter'>indexId</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3276"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN3274"><span class='Ref_to_Parameter'>missing_ok</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cache lookup failed for index %u"</span><span class='Delimiter'>, </span><a href="index.c.html#LN3274"><span class='Ref_to_Parameter'>indexId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="index.c.html#LN3277"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/catalog/pg_index.h.html#LN66"><span class='Ref_to_Typedef'>Form_pg_index</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3276"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="index.c.html#LN3277"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span>indexrelid <span class='Operator'>== </span><a href="index.c.html#LN3274"><span class='Ref_to_Parameter'>indexId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="index.c.html#LN3278"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="index.c.html#LN3277"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span>indrelid<span class='Delimiter'>; 
</span>    <a href="../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3276"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="index.c.html#LN3278"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end IndexGetRelation &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * reindex_index - This routine is used to recreate a single index 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN3299"></a><span class='Declare_Function'>reindex_index</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>indexId</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>skip_constraint_checks</span><span class='Delimiter'>, </span><span class='Keyword'>char </span><span class='Declare_Parameter'>persistence</span><span class='Delimiter'>, 
</span><a name="LN3300"></a>              <span class='Keyword'>int </span><span class='Declare_Parameter'>options</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3302"></a>    <a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>iRel</span><span class='Delimiter'>, 
</span><a name="LN3303"></a>                <span class='Declare_Local'>heapRelation</span><span class='Delimiter'>; 
</span><a name="LN3304"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>heapId</span><span class='Delimiter'>; 
</span><a name="LN3305"></a>    <a href="../../include/nodes/execnodes.h.html#LN130"><span class='Ref_to_Struct'>IndexInfo</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>indexInfo</span><span class='Delimiter'>; 
</span><a name="LN3306"></a>    <span class='Keyword'>volatile bool </span><span class='Declare_Local'>skipped_constraint</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN3307"></a>    <a href="../../include/utils/pg_rusage.h.html#LN26"><span class='Ref_to_Struct'>PGRUsage</span></a>    <span class='Declare_Local'>ru0</span><span class='Delimiter'>; 
</span> 
    <a href="../utils/misc/pg_rusage.c.html#LN25"><span class='Ref_to_Func'>pg_rusage_init</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="index.c.html#LN3307"><span class='Ref_To_Local'>ru0</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Open and lock the parent heap relation.  ShareLock is sufficient since 
     * we only need to be sure no schema or data changes are going on. 
     */ 
</span>    <a href="index.c.html#LN3304"><span class='Ref_To_Local'>heapId</span></a> <span class='Operator'>= </span><a href="../../include/catalog/index.h.html#LN131"><span class='Ref_to_Proto'>IndexGetRelation</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3299"><span class='Ref_to_Parameter'>indexId</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN3303"><span class='Ref_To_Local'>heapRelation</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN91"><span class='Ref_to_Proto'>heap_open</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3304"><span class='Ref_To_Local'>heapId</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN40"><span class='Ref_to_Const'>ShareLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Open the target index relation and get an exclusive lock on it, to 
     * ensure that no one else is touching this particular index. 
     */ 
</span>    <a href="index.c.html#LN3302"><span class='Ref_To_Local'>iRel</span></a> <span class='Operator'>= </span><a href="../../include/access/genam.h.html#LN129"><span class='Ref_to_Proto'>index_open</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3299"><span class='Ref_to_Parameter'>indexId</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN45"><span class='Ref_to_Const'>AccessExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Don't allow reindex on temp tables of other backends ... their local 
     * buffer manager is not going to cope. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/utils/rel.h.html#LN533"><span class='Ref_to_Macro'>RELATION_IS_OTHER_TEMP</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3302"><span class='Ref_To_Local'>iRel</span></a><span class='Parentheses'>))</span> 
        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>               <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"cannot reindex temporary tables of other sessions"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Also check for active uses of the index in the current transaction; we 
     * don't want to reindex underneath an open indexscan. 
     */ 
</span>    <a href="../../include/commands/tablecmds.h.html#LN52"><span class='Ref_to_Proto'>CheckTableNotInUse</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3302"><span class='Ref_To_Local'>iRel</span></a><span class='Delimiter'>, </span><span class='String'>"REINDEX INDEX"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * All predicate locks on the index are about to be made invalid. Promote 
     * them to relation locks on the heap. 
     */ 
</span>    <a href="../../include/storage/predicate.h.html#LN55"><span class='Ref_to_Proto'>TransferPredicateLocksToHeapRelation</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3302"><span class='Ref_To_Local'>iRel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/utils/elog.h.html#LN283"><span class='Ref_to_Macro'>PG_TRY</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Suppress use of the target index while rebuilding it */ 
</span>        <a href="index.c.html#LN123"><span class='Ref_to_Proto'>SetReindexProcessing</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3304"><span class='Ref_To_Local'>heapId</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN3299"><span class='Ref_to_Parameter'>indexId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Fetch info needed for index_build */ 
</span>        <a href="index.c.html#LN3305"><span class='Ref_To_Local'>indexInfo</span></a> <span class='Operator'>= </span><a href="../../include/catalog/index.h.html#LN81"><span class='Ref_to_Proto'>BuildIndexInfo</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3302"><span class='Ref_To_Local'>iRel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* If requested, skip checking uniqueness/exclusion constraints */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN3299"><span class='Ref_to_Parameter'>skip_constraint_checks</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN3305"><span class='Ref_To_Local'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN145"><span class='Ref_to_Member'>ii_Unique</span></a> <span class='Operator'>|| </span><a href="index.c.html#LN3305"><span class='Ref_To_Local'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN139"><span class='Ref_to_Member'>ii_ExclusionOps</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>                <a href="index.c.html#LN3306"><span class='Ref_To_Local'>skipped_constraint</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <a href="index.c.html#LN3305"><span class='Ref_To_Local'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN145"><span class='Ref_to_Member'>ii_Unique</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="index.c.html#LN3305"><span class='Ref_To_Local'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN139"><span class='Ref_to_Member'>ii_ExclusionOps</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>            <a href="index.c.html#LN3305"><span class='Ref_To_Local'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN140"><span class='Ref_to_Member'>ii_ExclusionProcs</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>            <a href="index.c.html#LN3305"><span class='Ref_To_Local'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN141"><span class='Ref_to_Member'>ii_ExclusionStrats</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* We'll build a new physical relation for the index */ 
</span>        <a href="../../include/utils/relcache.h.html#LN105"><span class='Ref_to_Proto'>RelationSetNewRelfilenode</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3302"><span class='Ref_To_Local'>iRel</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN3299"><span class='Ref_to_Parameter'>persistence</span></a><span class='Delimiter'>, </span><a href="../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>, 
</span>                                  <a href="../../include/access/multixact.h.html#LN22"><span class='Ref_to_Const'>InvalidMultiXactId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Initialize the index and rebuild */ 
</span>        <span class='Comment_Multi_Line'>/* Note: we do not need to re-establish pkey setting */ 
</span>        <a href="../../include/catalog/index.h.html#LN91"><span class='Ref_to_Proto'>index_build</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3303"><span class='Ref_To_Local'>heapRelation</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN3302"><span class='Ref_To_Local'>iRel</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN3305"><span class='Ref_To_Local'>indexInfo</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="../../include/utils/elog.h.html#LN292"><span class='Ref_to_Macro'>PG_CATCH</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Make sure flag gets cleared on error exit */ 
</span>        <a href="index.c.html#LN124"><span class='Ref_to_Proto'>ResetReindexProcessing</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <a href="../../include/utils/elog.h.html#LN310"><span class='Ref_to_Macro'>PG_RE_THROW</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="../../include/utils/elog.h.html#LN299"><span class='Ref_to_Macro'>PG_END_TRY</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN124"><span class='Ref_to_Proto'>ResetReindexProcessing</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the index is marked invalid/not-ready/dead (ie, it's from a failed 
     * CREATE INDEX CONCURRENTLY, or a DROP INDEX CONCURRENTLY failed midway), 
     * and we didn't skip a uniqueness check, we can now mark it valid.  This 
     * allows REINDEX to be used to clean up in such cases. 
     * 
     * We can also reset indcheckxmin, because we have now done a 
     * non-concurrent index build, *except* in the case where index_build 
     * found some still-broken HOT chains. If it did, and we don't have to 
     * change any of the other flags, we just leave indcheckxmin alone (note 
     * that index_build won't have changed it, because this is a reindex). 
     * This is okay and desirable because not updating the tuple leaves the 
     * index's usability horizon (recorded as the tuple's xmin value) the same 
     * as it was. 
     * 
     * But, if the index was invalid/not-ready/dead and there were broken HOT 
     * chains, we had better force indcheckxmin true, because the normal 
     * argument that the HOT chains couldn't conflict with the index is 
     * suspect for an invalid index.  (A conflict is definitely possible if 
     * the index was dead.  It probably shouldn't happen otherwise, but let's 
     * be conservative.)  In this case advancing the usability horizon is 
     * appropriate. 
     * 
     * Another reason for avoiding unnecessary updates here is that while 
     * reindexing pg_index itself, we must not try to update tuples in it. 
     * pg_index's indexes should always have these flags in their clean state, 
     * so that won't happen. 
     * 
     * If early pruning/vacuuming is enabled for the heap relation, the 
     * usability horizon must be advanced to the current transaction on every 
     * build or rebuild.  pg_index is OK in this regard because catalog tables 
     * are not subject to early cleanup. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="index.c.html#LN3306"><span class='Ref_To_Local'>skipped_constraint</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3416"></a>        <a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>pg_index</span><span class='Delimiter'>; 
</span><a name="LN3417"></a>        <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>indexTuple</span><span class='Delimiter'>; 
</span><a name="LN3418"></a>        <a href="../../include/catalog/pg_index.h.html#LN66"><span class='Ref_to_Typedef'>Form_pg_index</span></a> <span class='Declare_Local'>indexForm</span><span class='Delimiter'>; 
</span><a name="LN3419"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>index_bad</span><span class='Delimiter'>; 
</span><a name="LN3420"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>early_pruning_enabled</span> <span class='Operator'>= </span><a href="../../include/utils/snapmgr.h.html#LN45"><span class='Ref_to_Macro'>EarlyPruningEnabled</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3303"><span class='Ref_To_Local'>heapRelation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="index.c.html#LN3416"><span class='Ref_To_Local'>pg_index</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN91"><span class='Ref_to_Proto'>heap_open</span></a><span class='Parentheses'>(</span><a href="../../include/catalog/pg_index.h.html#LN28"><span class='Ref_to_Const'>IndexRelationId</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN37"><span class='Ref_to_Const'>RowExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="index.c.html#LN3417"><span class='Ref_To_Local'>indexTuple</span></a> <span class='Operator'>= </span><a href="../../include/utils/syscache.h.html#LN164"><span class='Ref_to_Macro'>SearchSysCacheCopy1</span></a><span class='Parentheses'>(</span><a href="../../include/utils/syscache.h.html#LN65"><span class='Ref_to_EnumConst'>INDEXRELID</span></a><span class='Delimiter'>, 
</span>                                         <a href="../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3299"><span class='Ref_to_Parameter'>indexId</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3417"><span class='Ref_To_Local'>indexTuple</span></a><span class='Parentheses'>))</span> 
            <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cache lookup failed for index %u"</span><span class='Delimiter'>, </span><a href="index.c.html#LN3299"><span class='Ref_to_Parameter'>indexId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="index.c.html#LN3418"><span class='Ref_To_Local'>indexForm</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/catalog/pg_index.h.html#LN66"><span class='Ref_to_Typedef'>Form_pg_index</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3417"><span class='Ref_To_Local'>indexTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="index.c.html#LN3419"><span class='Ref_To_Local'>index_bad</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="index.c.html#LN3418"><span class='Ref_To_Local'>indexForm</span></a><span class='Operator'>-&GT;</span>indisvalid <span class='Operator'>|| 
</span>                     <span class='Operator'>!</span><a href="index.c.html#LN3418"><span class='Ref_To_Local'>indexForm</span></a><span class='Operator'>-&GT;</span>indisready <span class='Operator'>|| 
</span>                     <span class='Operator'>!</span><a href="index.c.html#LN3418"><span class='Ref_To_Local'>indexForm</span></a><span class='Operator'>-&GT;</span>indislive<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN3419"><span class='Ref_To_Local'>index_bad</span></a> <span class='Operator'>|| 
</span>            <span class='Parentheses'>(</span><a href="index.c.html#LN3418"><span class='Ref_To_Local'>indexForm</span></a><span class='Operator'>-&GT;</span>indcheckxmin <span class='Operator'>&& !</span><a href="index.c.html#LN3305"><span class='Ref_To_Local'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN148"><span class='Ref_to_Member'>ii_BrokenHotChain</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>            <a href="index.c.html#LN3420"><span class='Ref_To_Local'>early_pruning_enabled</span></a><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="index.c.html#LN3305"><span class='Ref_To_Local'>indexInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN148"><span class='Ref_to_Member'>ii_BrokenHotChain</span></a> <span class='Operator'>&& !</span><a href="index.c.html#LN3420"><span class='Ref_To_Local'>early_pruning_enabled</span></a><span class='Parentheses'>) 
</span>                <a href="index.c.html#LN3418"><span class='Ref_To_Local'>indexForm</span></a><span class='Operator'>-&GT;</span>indcheckxmin <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN3419"><span class='Ref_To_Local'>index_bad</span></a> <span class='Operator'>|| </span><a href="index.c.html#LN3420"><span class='Ref_To_Local'>early_pruning_enabled</span></a><span class='Parentheses'>) 
</span>                <a href="index.c.html#LN3418"><span class='Ref_To_Local'>indexForm</span></a><span class='Operator'>-&GT;</span>indcheckxmin <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <a href="index.c.html#LN3418"><span class='Ref_To_Local'>indexForm</span></a><span class='Operator'>-&GT;</span>indisvalid <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <a href="index.c.html#LN3418"><span class='Ref_To_Local'>indexForm</span></a><span class='Operator'>-&GT;</span>indisready <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <a href="index.c.html#LN3418"><span class='Ref_To_Local'>indexForm</span></a><span class='Operator'>-&GT;</span>indislive <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <a href="../../include/catalog/indexing.h.html#LN35"><span class='Ref_to_Proto'>CatalogTupleUpdate</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3416"><span class='Ref_To_Local'>pg_index</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="index.c.html#LN3417"><span class='Ref_To_Local'>indexTuple</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/htup.h.html#LN64"><span class='Ref_to_Member'>t_self</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN3417"><span class='Ref_To_Local'>indexTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Invalidate the relcache for the table, so that after we commit 
             * all sessions will refresh the table's index list.  This ensures 
             * that if anyone misses seeing the pg_index row during this 
             * update, they'll refresh their list before attempting any update 
             * on the table. 
             */ 
</span>            <a href="../../include/utils/inval.h.html#LN43"><span class='Ref_to_Proto'>CacheInvalidateRelcache</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3303"><span class='Ref_To_Local'>heapRelation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if index_bad||(indexForm... &raquo; </span> 
 
        <a href="../../include/access/heapam.h.html#LN96"><span class='Ref_to_Macro'>heap_close</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3416"><span class='Ref_To_Local'>pg_index</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN37"><span class='Ref_to_Const'>RowExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !skipped_constraint &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* Log what we did */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN3300"><span class='Ref_to_Parameter'>options</span></a> <span class='Operator'>& </span><a href="../../include/nodes/parsenodes.h.html#LN3187"><span class='Ref_to_Const'>REINDEXOPT_VERBOSE</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN32"><span class='Ref_to_Const'>INFO</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"index \"%s\" was reindexed"</span><span class='Delimiter'>, 
</span>                        <a href="../../include/utils/lsyscache.h.html#LN124"><span class='Ref_to_Proto'>get_rel_name</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3299"><span class='Ref_to_Parameter'>indexId</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN898"><span class='Ref_to_Func'>errdetail_internal</span></a><span class='Parentheses'>(</span><span class='String'>"%s"</span><span class='Delimiter'>, 
</span>                                    <a href="../../include/utils/pg_rusage.h.html#LN34"><span class='Ref_to_Proto'>pg_rusage_show</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="index.c.html#LN3307"><span class='Ref_To_Local'>ru0</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Close rels, but keep locks */ 
</span>    <a href="../../include/access/genam.h.html#LN130"><span class='Ref_to_Proto'>index_close</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3302"><span class='Ref_To_Local'>iRel</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN33"><span class='Ref_to_Const'>NoLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/access/heapam.h.html#LN96"><span class='Ref_to_Macro'>heap_close</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3303"><span class='Ref_To_Local'>heapRelation</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN33"><span class='Ref_to_Const'>NoLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end reindex_index &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * reindex_relation - This routine is used to recreate all indexes 
 * of a relation (and optionally its toast relation too, if any). 
 * 
 * "flags" is a bitmask that can include any combination of these bits: 
 * 
 * REINDEX_REL_PROCESS_TOAST: if true, process the toast table too (if any). 
 * 
 * REINDEX_REL_SUPPRESS_INDEX_USE: if true, the relation was just completely 
 * rebuilt by an operation such as VACUUM FULL or CLUSTER, and therefore its 
 * indexes are inconsistent with it.  This makes things tricky if the relation 
 * is a system catalog that we might consult during the reindexing.  To deal 
 * with that case, we mark all of the indexes as pending rebuild so that they 
 * won't be trusted until rebuilt.  The caller is required to call us *without* 
 * having made the rebuilt table visible by doing CommandCounterIncrement; 
 * we'll do CCI after having collected the index list.  (This way we can still 
 * use catalog indexes while collecting the list.) 
 * 
 * REINDEX_REL_CHECK_CONSTRAINTS: if true, recheck unique and exclusion 
 * constraint conditions, else don't.  To avoid deadlocks, VACUUM FULL or 
 * CLUSTER on a system catalog must omit this flag.  REINDEX should be used to 
 * rebuild an index if constraint inconsistency is suspected.  For optimal 
 * performance, other callers should include the flag only after transforming 
 * the data in a manner that risks a change in constraint validity. 
 * 
 * REINDEX_REL_FORCE_INDEXES_UNLOGGED: if true, set the persistence of the 
 * rebuilt indexes to unlogged. 
 * 
 * REINDEX_REL_FORCE_INDEXES_PERMANENT: if true, set the persistence of the 
 * rebuilt indexes to permanent. 
 * 
 * Returns true if any indexes were rebuilt (including toast table's index 
 * when relevant).  Note that a CommandCounterIncrement will occur after each 
 * index rebuild. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN3508"></a><span class='Declare_Function'>reindex_relation</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>relid</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>flags</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>options</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3510"></a>    <a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>rel</span><span class='Delimiter'>; 
</span><a name="LN3511"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>toast_relid</span><span class='Delimiter'>; 
</span><a name="LN3512"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>indexIds</span><span class='Delimiter'>; 
</span><a name="LN3513"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>is_pg_class</span><span class='Delimiter'>; 
</span><a name="LN3514"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Open and lock the relation.  ShareLock is sufficient since we only need 
     * to prevent schema and data changes in it.  The lock level used here 
     * should match ReindexTable(). 
     */ 
</span>    <a href="index.c.html#LN3510"><span class='Ref_To_Local'>rel</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN91"><span class='Ref_to_Proto'>heap_open</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3508"><span class='Ref_to_Parameter'>relid</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN40"><span class='Ref_to_Const'>ShareLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="index.c.html#LN3511"><span class='Ref_To_Local'>toast_relid</span></a> <span class='Operator'>= </span><a href="index.c.html#LN3510"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>reltoastrelid<span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Get the list of index OIDs for this relation.  (We trust to the 
     * relcache to get this with a sequential scan if ignoring system 
     * indexes.) 
     */ 
</span>    <a href="index.c.html#LN3512"><span class='Ref_To_Local'>indexIds</span></a> <span class='Operator'>= </span><a href="../../include/utils/relcache.h.html#LN40"><span class='Ref_to_Proto'>RelationGetIndexList</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3510"><span class='Ref_To_Local'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * reindex_index will attempt to update the pg_class rows for the relation 
     * and index.  If we are processing pg_class itself, we want to make sure 
     * that the updates do not try to insert index entries into indexes we 
     * have not processed yet.  (When we are trying to recover from corrupted 
     * indexes, that could easily cause a crash.) We can accomplish this 
     * because CatalogTupleInsert/CatalogTupleUpdate will use the relcache's 
     * index list to know which indexes to update. We just force the index 
     * list to be only the stuff we've processed. 
     * 
     * It is okay to not insert entries into the indexes we have not processed 
     * yet because all of this is transaction-safe.  If we fail partway 
     * through, the updated rows are dead and it doesn't matter whether they 
     * have index entries.  Also, a new pg_class index will be created with a 
     * correct entry for its own pg_class row because we do 
     * RelationSetNewRelfilenode() before we do index_build(). 
     * 
     * Note that we also clear pg_class's rd_oidindex until the loop is done, 
     * so that that index can't be accessed either.  This means we cannot 
     * safely generate new relation OIDs while in the loop; shouldn't be a 
     * problem. 
     */ 
</span>    <a href="index.c.html#LN3513"><span class='Ref_To_Local'>is_pg_class</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/utils/rel.h.html#LN416"><span class='Ref_to_Macro'>RelationGetRelid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3510"><span class='Ref_To_Local'>rel</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="../../include/catalog/pg_class.h.html#LN28"><span class='Ref_to_Const'>RelationRelationId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Ensure rd_indexattr is valid; see comments for RelationSetIndexList */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN3513"><span class='Ref_To_Local'>is_pg_class</span></a><span class='Parentheses'>) 
</span>        <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="../../include/utils/relcache.h.html#LN56"><span class='Ref_to_Proto'>RelationGetIndexAttrBitmap</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3510"><span class='Ref_To_Local'>rel</span></a><span class='Delimiter'>, </span><a href="../../include/utils/relcache.h.html#LN50"><span class='Ref_to_EnumConst'>INDEX_ATTR_BITMAP_ALL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/utils/elog.h.html#LN283"><span class='Ref_to_Macro'>PG_TRY</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3562"></a>        <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>doneIndexes</span><span class='Delimiter'>; 
</span><a name="LN3563"></a>        <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>indexId</span><span class='Delimiter'>; 
</span><a name="LN3564"></a>        <span class='Keyword'>char</span>        <span class='Declare_Local'>persistence</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN3508"><span class='Ref_to_Parameter'>flags</span></a> <span class='Operator'>& </span><a href="../../include/catalog/index.h.html#LN122"><span class='Ref_to_Const'>REINDEX_REL_SUPPRESS_INDEX_USE</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Suppress use of all the indexes until they are rebuilt */ 
</span>            <a href="index.c.html#LN125"><span class='Ref_to_Proto'>SetReindexPending</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3512"><span class='Ref_To_Local'>indexIds</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Make the new heap contents visible --- now things might be 
             * inconsistent! 
             */ 
</span>            <a href="../../include/access/xact.h.html#LN346"><span class='Ref_to_Proto'>CommandCounterIncrement</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Compute persistence of indexes: same as that of owning rel, unless 
         * caller specified otherwise. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN3508"><span class='Ref_to_Parameter'>flags</span></a> <span class='Operator'>& </span><a href="../../include/catalog/index.h.html#LN124"><span class='Ref_to_Const'>REINDEX_REL_FORCE_INDEXES_UNLOGGED</span></a><span class='Parentheses'>) 
</span>            <a href="index.c.html#LN3564"><span class='Ref_To_Local'>persistence</span></a> <span class='Operator'>= </span><a href="../../include/catalog/pg_class.h.html#LN170"><span class='Ref_to_Const'>RELPERSISTENCE_UNLOGGED</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN3508"><span class='Ref_to_Parameter'>flags</span></a> <span class='Operator'>& </span><a href="../../include/catalog/index.h.html#LN125"><span class='Ref_to_Const'>REINDEX_REL_FORCE_INDEXES_PERMANENT</span></a><span class='Parentheses'>) 
</span>            <a href="index.c.html#LN3564"><span class='Ref_To_Local'>persistence</span></a> <span class='Operator'>= </span><a href="../../include/catalog/pg_class.h.html#LN169"><span class='Ref_to_Const'>RELPERSISTENCE_PERMANENT</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="index.c.html#LN3564"><span class='Ref_To_Local'>persistence</span></a> <span class='Operator'>= </span><a href="index.c.html#LN3510"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relpersistence<span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Reindex all the indexes. */ 
</span>        <a href="index.c.html#LN3562"><span class='Ref_To_Local'>doneIndexes</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>        <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3563"><span class='Ref_To_Local'>indexId</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN3512"><span class='Ref_To_Local'>indexIds</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN3593"></a>            <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>indexOid</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN107"><span class='Ref_to_Macro'>lfirst_oid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3563"><span class='Ref_To_Local'>indexId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN3513"><span class='Ref_To_Local'>is_pg_class</span></a><span class='Parentheses'>) 
</span>                <a href="../../include/utils/relcache.h.html#LN64"><span class='Ref_to_Proto'>RelationSetIndexList</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3510"><span class='Ref_To_Local'>rel</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN3562"><span class='Ref_To_Local'>doneIndexes</span></a><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="../../include/catalog/index.h.html#LN117"><span class='Ref_to_Proto'>reindex_index</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3593"><span class='Ref_To_Local'>indexOid</span></a><span class='Delimiter'>, </span><span class='Operator'>!</span><span class='Parentheses'>(</span><a href="index.c.html#LN3508"><span class='Ref_to_Parameter'>flags</span></a> <span class='Operator'>& </span><a href="../../include/catalog/index.h.html#LN123"><span class='Ref_to_Const'>REINDEX_REL_CHECK_CONSTRAINTS</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                          <a href="index.c.html#LN3564"><span class='Ref_To_Local'>persistence</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN3508"><span class='Ref_to_Parameter'>options</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="../../include/access/xact.h.html#LN346"><span class='Ref_to_Proto'>CommandCounterIncrement</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Index should no longer be in the pending list */ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/catalog/index.h.html#LN130"><span class='Ref_to_Proto'>ReindexIsProcessingIndex</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3593"><span class='Ref_To_Local'>indexOid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN3513"><span class='Ref_To_Local'>is_pg_class</span></a><span class='Parentheses'>) 
</span>                <a href="index.c.html#LN3562"><span class='Ref_To_Local'>doneIndexes</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN162"><span class='Ref_to_Func'>lappend_oid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3562"><span class='Ref_To_Local'>doneIndexes</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN3593"><span class='Ref_To_Local'>indexOid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span>    <a href="../../include/utils/elog.h.html#LN292"><span class='Ref_to_Macro'>PG_CATCH</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Make sure list gets cleared on error exit */ 
</span>        <a href="index.c.html#LN127"><span class='Ref_to_Proto'>ResetReindexPending</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <a href="../../include/utils/elog.h.html#LN310"><span class='Ref_to_Macro'>PG_RE_THROW</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="../../include/utils/elog.h.html#LN299"><span class='Ref_to_Macro'>PG_END_TRY</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN127"><span class='Ref_to_Proto'>ResetReindexPending</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN3513"><span class='Ref_To_Local'>is_pg_class</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/utils/relcache.h.html#LN64"><span class='Ref_to_Proto'>RelationSetIndexList</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3510"><span class='Ref_To_Local'>rel</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN3512"><span class='Ref_To_Local'>indexIds</span></a><span class='Delimiter'>, </span><a href="../../include/catalog/indexing.h.html#LN111"><span class='Ref_to_Const'>ClassOidIndexId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Close rel, but continue to hold the lock. 
     */ 
</span>    <a href="../../include/access/heapam.h.html#LN96"><span class='Ref_to_Macro'>heap_close</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3510"><span class='Ref_To_Local'>rel</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN33"><span class='Ref_to_Const'>NoLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="index.c.html#LN3514"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="index.c.html#LN3512"><span class='Ref_To_Local'>indexIds</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the relation has a secondary toast rel, reindex that too while we 
     * still hold the lock on the master table. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="index.c.html#LN3508"><span class='Ref_to_Parameter'>flags</span></a> <span class='Operator'>& </span><a href="../../include/catalog/index.h.html#LN121"><span class='Ref_to_Const'>REINDEX_REL_PROCESS_TOAST</span></a><span class='Parentheses'>) </span><span class='Operator'>&& </span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3511"><span class='Ref_To_Local'>toast_relid</span></a><span class='Parentheses'>))</span> 
        <a href="index.c.html#LN3514"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>|= </span><a href="../../include/catalog/index.h.html#LN127"><span class='Ref_to_Proto'>reindex_relation</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3511"><span class='Ref_To_Local'>toast_relid</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN3508"><span class='Ref_to_Parameter'>flags</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN3508"><span class='Ref_to_Parameter'>options</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="index.c.html#LN3514"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end reindex_relation &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *      System index reindexing support 
 * 
 * When we are busy reindexing a system index, this code provides support 
 * for preventing catalog lookups from using that index.  We also make use 
 * of this to catch attempted uses of user indexes during reindexing of 
 * those indexes. 
 * ---------------------------------------------------------------- 
 */ 
</span> 
<a name="LN3650"></a><span class='Keyword'>static </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>  <span class='Declare_Var'>currentlyReindexedHeap</span> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span><a name="LN3651"></a><span class='Keyword'>static </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>  <span class='Declare_Var'>currentlyReindexedIndex</span> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span><a name="LN3652"></a><span class='Keyword'>static </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Var'>pendingReindexedIndexes</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * ReindexIsProcessingHeap 
 *      True if heap specified by OID is currently being reindexed. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN3659"></a><span class='Declare_Function'>ReindexIsProcessingHeap</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>heapOid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <a href="index.c.html#LN3659"><span class='Ref_to_Parameter'>heapOid</span></a> <span class='Operator'>== </span><a href="index.c.html#LN3650"><span class='Ref_to_Global_Var'>currentlyReindexedHeap</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * ReindexIsCurrentlyProcessingIndex 
 *      True if index specified by OID is currently being reindexed. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN3669"></a><span class='Declare_Function'>ReindexIsCurrentlyProcessingIndex</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>indexOid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <a href="index.c.html#LN3669"><span class='Ref_to_Parameter'>indexOid</span></a> <span class='Operator'>== </span><a href="index.c.html#LN3651"><span class='Ref_to_Global_Var'>currentlyReindexedIndex</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * ReindexIsProcessingIndex 
 *      True if index specified by OID is currently being reindexed, 
 *      or should be treated as invalid because it is awaiting reindex. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN3680"></a><span class='Declare_Function'>ReindexIsProcessingIndex</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>indexOid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <a href="index.c.html#LN3680"><span class='Ref_to_Parameter'>indexOid</span></a> <span class='Operator'>== </span><a href="index.c.html#LN3651"><span class='Ref_to_Global_Var'>currentlyReindexedIndex</span></a> <span class='Operator'>|| 
</span>        <a href="../../include/nodes/pg_list.h.html#LN231"><span class='Ref_to_Proto'>list_member_oid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3652"><span class='Ref_to_Global_Var'>pendingReindexedIndexes</span></a><span class='Delimiter'>, </span><a href="index.c.html#LN3680"><span class='Ref_to_Parameter'>indexOid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * SetReindexProcessing 
 *      Set flag that specified heap/index are being reindexed. 
 * 
 * NB: caller must use a PG_TRY block to ensure ResetReindexProcessing is done. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN3693"></a><span class='Declare_Function'>SetReindexProcessing</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>heapOid</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>indexOid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3693"><span class='Ref_to_Parameter'>heapOid</span></a><span class='Parentheses'>) </span><span class='Operator'>&& </span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3693"><span class='Ref_to_Parameter'>indexOid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* Reindexing is not re-entrant. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3650"><span class='Ref_to_Global_Var'>currentlyReindexedHeap</span></a><span class='Parentheses'>))</span> 
        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cannot reindex while reindexing"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN3650"><span class='Ref_to_Global_Var'>currentlyReindexedHeap</span></a> <span class='Operator'>= </span><a href="index.c.html#LN3693"><span class='Ref_to_Parameter'>heapOid</span></a><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN3651"><span class='Ref_to_Global_Var'>currentlyReindexedIndex</span></a> <span class='Operator'>= </span><a href="index.c.html#LN3693"><span class='Ref_to_Parameter'>indexOid</span></a><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* Index is no longer "pending" reindex. */ 
</span>    <a href="index.c.html#LN126"><span class='Ref_to_Proto'>RemoveReindexPending</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3693"><span class='Ref_to_Parameter'>indexOid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * ResetReindexProcessing 
 *      Unset reindexing status. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN3710"></a><span class='Declare_Function'>ResetReindexProcessing</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="index.c.html#LN3650"><span class='Ref_to_Global_Var'>currentlyReindexedHeap</span></a> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN3651"><span class='Ref_to_Global_Var'>currentlyReindexedIndex</span></a> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * SetReindexPending 
 *      Mark the given indexes as pending reindex. 
 * 
 * NB: caller must use a PG_TRY block to ensure ResetReindexPending is done. 
 * Also, we assume that the current memory context stays valid throughout. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN3724"></a><span class='Declare_Function'>SetReindexPending</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>indexes</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* Reindexing is not re-entrant. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="index.c.html#LN3652"><span class='Ref_to_Global_Var'>pendingReindexedIndexes</span></a><span class='Parentheses'>) 
</span>        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cannot reindex while reindexing"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="index.c.html#LN3652"><span class='Ref_to_Global_Var'>pendingReindexedIndexes</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN268"><span class='Ref_to_Proto'>list_copy</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3724"><span class='Ref_to_Parameter'>indexes</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * RemoveReindexPending 
 *      Remove the given index from the pending list. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN3737"></a><span class='Declare_Function'>RemoveReindexPending</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>indexOid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="index.c.html#LN3652"><span class='Ref_to_Global_Var'>pendingReindexedIndexes</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN236"><span class='Ref_to_Proto'>list_delete_oid</span></a><span class='Parentheses'>(</span><a href="index.c.html#LN3652"><span class='Ref_to_Global_Var'>pendingReindexedIndexes</span></a><span class='Delimiter'>, 
</span>                                              <a href="index.c.html#LN3737"><span class='Ref_to_Parameter'>indexOid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * ResetReindexPending 
 *      Unset reindex-pending status. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN3748"></a><span class='Declare_Function'>ResetReindexPending</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="index.c.html#LN3652"><span class='Ref_to_Global_Var'>pendingReindexedIndexes</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
} 
</span></pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>