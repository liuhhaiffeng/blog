<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\commands\async.c</title>
<LINK REL=StyleSheet HREF="../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\commands\async.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:34 2017
</td></tr>
<tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
</span><span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * async.c 
 *    Asynchronous notification: NOTIFY, LISTEN, UNLISTEN 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * IDENTIFICATION 
 *    src/backend/commands/async.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span> 
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * Async Notification Model as of 9.0: 
 * 
 * 1. Multiple backends on same machine. Multiple backends listening on 
 *    several channels. (Channels are also called "conditions" in other 
 *    parts of the code.) 
 * 
 * 2. There is one central queue in disk-based storage (directory pg_notify/), 
 *    with actively-used pages mapped into shared memory by the slru.c module. 
 *    All notification messages are placed in the queue and later read out 
 *    by listening backends. 
 * 
 *    There is no central knowledge of which backend listens on which channel; 
 *    every backend has its own list of interesting channels. 
 * 
 *    Although there is only one queue, notifications are treated as being 
 *    database-local; this is done by including the sender's database OID 
 *    in each notification message.  Listening backends ignore messages 
 *    that don't match their database OID.  This is important because it 
 *    ensures senders and receivers have the same database encoding and won't 
 *    misinterpret non-ASCII text in the channel name or payload string. 
 * 
 *    Since notifications are not expected to survive database crashes, 
 *    we can simply clean out the pg_notify data at any reboot, and there 
 *    is no need for WAL support or fsync'ing. 
 * 
 * 3. Every backend that is listening on at least one channel registers by 
 *    entering its PID into the array in AsyncQueueControl. It then scans all 
 *    incoming notifications in the central queue and first compares the 
 *    database OID of the notification with its own database OID and then 
 *    compares the notified channel with the list of channels that it listens 
 *    to. In case there is a match it delivers the notification event to its 
 *    frontend.  Non-matching events are simply skipped. 
 * 
 * 4. The NOTIFY statement (routine Async_Notify) stores the notification in 
 *    a backend-local list which will not be processed until transaction end. 
 * 
 *    Duplicate notifications from the same transaction are sent out as one 
 *    notification only. This is done to save work when for example a trigger 
 *    on a 2 million row table fires a notification for each row that has been 
 *    changed. If the application needs to receive every single notification 
 *    that has been sent, it can easily add some unique string into the extra 
 *    payload parameter. 
 * 
 *    When the transaction is ready to commit, PreCommit_Notify() adds the 
 *    pending notifications to the head of the queue. The head pointer of the 
 *    queue always points to the next free position and a position is just a 
 *    page number and the offset in that page. This is done before marking the 
 *    transaction as committed in clog. If we run into problems writing the 
 *    notifications, we can still call elog(ERROR, ...) and the transaction 
 *    will roll back. 
 * 
 *    Once we have put all of the notifications into the queue, we return to 
 *    CommitTransaction() which will then do the actual transaction commit. 
 * 
 *    After commit we are called another time (AtCommit_Notify()). Here we 
 *    make the actual updates to the effective listen state (listenChannels). 
 * 
 *    Finally, after we are out of the transaction altogether, we check if 
 *    we need to signal listening backends.  In SignalBackends() we scan the 
 *    list of listening backends and send a PROCSIG_NOTIFY_INTERRUPT signal 
 *    to every listening backend (we don't know which backend is listening on 
 *    which channel so we must signal them all). We can exclude backends that 
 *    are already up to date, though.  We don't bother with a self-signal 
 *    either, but just process the queue directly. 
 * 
 * 5. Upon receipt of a PROCSIG_NOTIFY_INTERRUPT signal, the signal handler 
 *    sets the process's latch, which triggers the event to be processed 
 *    immediately if this backend is idle (i.e., it is waiting for a frontend 
 *    command and is not within a transaction block. C.f. 
 *    ProcessClientReadInterrupt()).  Otherwise the handler may only set a 
 *    flag, which will cause the processing to occur just before we next go 
 *    idle. 
 * 
 *    Inbound-notify processing consists of reading all of the notifications 
 *    that have arrived since scanning last time. We read every notification 
 *    until we reach either a notification from an uncommitted transaction or 
 *    the head pointer's position. Then we check if we were the laziest 
 *    backend: if our pointer is set to the same position as the global tail 
 *    pointer is set, then we move the global tail pointer ahead to where the 
 *    second-laziest backend is (in general, we take the MIN of the current 
 *    head position and all active backends' new tail pointers). Whenever we 
 *    move the global tail pointer we also truncate now-unused pages (i.e., 
 *    delete files in pg_notify/ that are no longer used). 
 * 
 * An application that listens on the same channel it notifies will get 
 * NOTIFY messages for its own NOTIFYs.  These can be ignored, if not useful, 
 * by comparing be_pid in the NOTIFY message to the application's own backend's 
 * PID.  (As of FE/BE protocol 2.0, the backend's PID is provided to the 
 * frontend during startup.)  The above design guarantees that notifies from 
 * other backends will never be missed by ignoring self-notifies. 
 * 
 * The amount of shared memory used for notify management (NUM_ASYNC_BUFFERS) 
 * can be varied without affecting anything but performance.  The maximum 
 * amount of notification data that can be queued at one time is determined 
 * by slru.c's wraparound limit; see QUEUE_MAX_PAGE below. 
 *------------------------------------------------------------------------- 
 */ 
</span> 
<span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>&LT;limits.h&GT;</span> 
<span class='Keyword'>#include </span><span class='String'>&LT;unistd.h&GT;</span> 
<span class='Keyword'>#include </span><span class='String'>&LT;signal.h&GT;</span> 
 
<span class='Keyword'>#include </span><span class='String'>"access/parallel.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/slru.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/transam.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/xact.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_database.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"commands/async.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"funcapi.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"libpq/libpq.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"libpq/pqformat.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"miscadmin.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/ipc.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/lmgr.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/proc.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/procarray.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/procsignal.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/sinval.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"tcop/tcopprot.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/builtins.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/memutils.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/ps_status.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/timestamp.h"</span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * Maximum size of a NOTIFY payload, including terminating NULL.  This 
 * must be kept small enough so that a notification message fits on one 
 * SLRU page.  The magic fudge factor here is noncritical as long as it's 
 * more than AsyncQueueEntryEmptySize --- we make it significantly bigger 
 * than that, so changes in that data structure won't affect user-visible 
 * restrictions. 
 */ 
</span><a name="LN150"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>NOTIFY_PAYLOAD_MAX_LENGTH</span>   <span class='Parentheses'>(</span>BLCKSZ <span class='Operator'>- </span><a href="../../interfaces/ecpg/include/sqlda-native.h.html#LN15"><span class='Ref_to_Const'>NAMEDATALEN</span></a> <span class='Operator'>- </span><span class='Number'>128</span><span class='Parentheses'>) 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Struct representing an entry in the global notify queue 
 * 
 * This struct declaration has the maximal length, but in a real queue entry 
 * the data area is only big enough for the actual channel and payload strings 
 * (each null-terminated).  AsyncQueueEntryEmptySize is the minimum possible 
 * entry size, if both channel and payload strings are empty (but note it 
 * doesn't include alignment padding). 
 * 
 * The "length" field should always be rounded up to the next QUEUEALIGN 
 * multiple so that all fields are properly aligned. 
 */ 
</span><a name="LN164"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AsyncQueueEntry</span> 
<span class='Delimiter'>{ 
</span><a name="LN166"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>length</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* total allocated length of entry */ 
</span><a name="LN167"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>dboid</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* sender's database OID */ 
</span><a name="LN168"></a>    <a href="../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Member'>xid</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* sender's XID */ 
</span><a name="LN169"></a>    <a href="../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Member'>srcPid</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* sender's PID */ 
</span><a name="LN170"></a>    <span class='Keyword'>char</span>        <span class='Declare_Member'>data</span><span class='Delimiter'>[</span><a href="../../interfaces/ecpg/include/sqlda-native.h.html#LN15"><span class='Ref_to_Const'>NAMEDATALEN</span></a> <span class='Operator'>+ </span><a href="async.c.html#LN150"><span class='Ref_to_Const'>NOTIFY_PAYLOAD_MAX_LENGTH</span></a><span class='Delimiter'>]; 
</span><a name="LN171"></a>} <span class='Declare_Typedef'>AsyncQueueEntry</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* Currently, no field of AsyncQueueEntry requires more than int alignment */ 
</span><a name="LN174"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>QUEUEALIGN</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>len</span><span class='Parentheses'>)</span>     <a href="../../include/c.h.html#LN584"><span class='Ref_to_Macro'>INTALIGN</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN174"><span class='Ref_to_Parameter'>len</span></a><span class='Parentheses'>) 
</span> 
<a name="LN176"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>AsyncQueueEntryEmptySize</span>    <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN164"><span class='Ref_to_Struct'>AsyncQueueEntry</span></a><span class='Delimiter'>, </span>data<span class='Parentheses'>) </span><span class='Operator'>+ </span><span class='Number'>2</span><span class='Parentheses'>)</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Struct describing a queue position, and assorted macros for working with it 
 */ 
</span><a name="LN181"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>QueuePosition</span> 
<span class='Delimiter'>{ 
</span><a name="LN183"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>page</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* SLRU page number */ 
</span><a name="LN184"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>offset</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* byte offset within page */ 
</span><a name="LN185"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>QueuePosition</span><span class='Delimiter'>; 
</span> 
<a name="LN187"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>QUEUE_POS_PAGE</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>x</span><span class='Parentheses'>)</span>       <span class='Parentheses'>((</span><a href="async.c.html#LN187"><span class='Ref_to_Parameter'>x</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>page<span class='Parentheses'>)</span> 
<a name="LN188"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>QUEUE_POS_OFFSET</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>x</span><span class='Parentheses'>)</span>     <span class='Parentheses'>((</span><a href="async.c.html#LN188"><span class='Ref_to_Parameter'>x</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>offset<span class='Parentheses'>)</span> 
 
<a name="LN190"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>SET_QUEUE_POS</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>x</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>y</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>z</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <span class='Control'>do</span> <span class='Delimiter'>{ </span><span class='Operator'>\ 
</span>        <span class='Parentheses'>(</span><a href="async.c.html#LN190"><span class='Ref_to_Parameter'>x</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>page <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="async.c.html#LN190"><span class='Ref_to_Parameter'>y</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; </span><span class='Operator'>\ 
</span>        <span class='Parentheses'>(</span><a href="async.c.html#LN190"><span class='Ref_to_Parameter'>x</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>offset <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="async.c.html#LN190"><span class='Ref_to_Parameter'>z</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; </span><span class='Operator'>\ 
</span>    <span class='Delimiter'>} </span><span class='Control'>while</span> <span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>) 
</span> 
<a name="LN196"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>QUEUE_POS_EQUAL</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>x</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>y</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>     <span class='Parentheses'>((</span><a href="async.c.html#LN196"><span class='Ref_to_Parameter'>x</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>page <span class='Operator'>== </span><span class='Parentheses'>(</span><a href="async.c.html#LN196"><span class='Ref_to_Parameter'>y</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>page <span class='Operator'>&& </span><span class='Parentheses'>(</span><a href="async.c.html#LN196"><span class='Ref_to_Parameter'>x</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>offset <span class='Operator'>== </span><span class='Parentheses'>(</span><a href="async.c.html#LN196"><span class='Ref_to_Parameter'>y</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>offset<span class='Parentheses'>)</span> 
 
<span class='Comment_Multi_Line'>/* choose logically smaller QueuePosition */ 
</span><a name="LN200"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>QUEUE_POS_MIN</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>x</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>y</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <span class='Parentheses'>(</span><a href="async.c.html#LN370"><span class='Ref_to_Proto'>asyncQueuePagePrecedes</span></a><span class='Parentheses'>((</span><a href="async.c.html#LN200"><span class='Ref_to_Parameter'>x</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>page<span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="async.c.html#LN200"><span class='Ref_to_Parameter'>y</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>page<span class='Parentheses'>)</span> <span class='Operator'>? </span><span class='Parentheses'>(</span><a href="async.c.html#LN200"><span class='Ref_to_Parameter'>x</span></a><span class='Parentheses'>)</span> <span class='Operator'>: \ 
</span>     <span class='Parentheses'>(</span><a href="async.c.html#LN200"><span class='Ref_to_Parameter'>x</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>page <span class='Operator'>!= </span><span class='Parentheses'>(</span><a href="async.c.html#LN200"><span class='Ref_to_Parameter'>y</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>page <span class='Operator'>? </span><span class='Parentheses'>(</span><a href="async.c.html#LN200"><span class='Ref_to_Parameter'>y</span></a><span class='Parentheses'>)</span> <span class='Operator'>: \ 
</span>     <span class='Parentheses'>(</span><a href="async.c.html#LN200"><span class='Ref_to_Parameter'>x</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>offset <span class='Operator'>&LT; </span><span class='Parentheses'>(</span><a href="async.c.html#LN200"><span class='Ref_to_Parameter'>y</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>offset <span class='Operator'>? </span><span class='Parentheses'>(</span><a href="async.c.html#LN200"><span class='Ref_to_Parameter'>x</span></a><span class='Parentheses'>)</span> <span class='Operator'>: </span><span class='Parentheses'>(</span><a href="async.c.html#LN200"><span class='Ref_to_Parameter'>y</span></a><span class='Parentheses'>))</span> 
 
<span class='Comment_Multi_Line'>/* choose logically larger QueuePosition */ 
</span><a name="LN206"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>QUEUE_POS_MAX</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>x</span><span class='Delimiter'>,</span><span class='Declare_Parameter'>y</span><span class='Parentheses'>) </span><span class='Operator'>\ 
</span>    <span class='Parentheses'>(</span><a href="async.c.html#LN370"><span class='Ref_to_Proto'>asyncQueuePagePrecedes</span></a><span class='Parentheses'>((</span><a href="async.c.html#LN206"><span class='Ref_to_Parameter'>x</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>page<span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="async.c.html#LN206"><span class='Ref_to_Parameter'>y</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>page<span class='Parentheses'>)</span> <span class='Operator'>? </span><span class='Parentheses'>(</span><a href="async.c.html#LN206"><span class='Ref_to_Parameter'>y</span></a><span class='Parentheses'>)</span> <span class='Operator'>: \ 
</span>     <span class='Parentheses'>(</span><a href="async.c.html#LN206"><span class='Ref_to_Parameter'>x</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>page <span class='Operator'>!= </span><span class='Parentheses'>(</span><a href="async.c.html#LN206"><span class='Ref_to_Parameter'>y</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>page <span class='Operator'>? </span><span class='Parentheses'>(</span><a href="async.c.html#LN206"><span class='Ref_to_Parameter'>x</span></a><span class='Parentheses'>)</span> <span class='Operator'>: \ 
</span>     <span class='Parentheses'>(</span><a href="async.c.html#LN206"><span class='Ref_to_Parameter'>x</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>offset <span class='Operator'>&GT; </span><span class='Parentheses'>(</span><a href="async.c.html#LN206"><span class='Ref_to_Parameter'>y</span></a><span class='Parentheses'>)</span><span class='Operator'>.</span>offset <span class='Operator'>? </span><span class='Parentheses'>(</span><a href="async.c.html#LN206"><span class='Ref_to_Parameter'>x</span></a><span class='Parentheses'>)</span> <span class='Operator'>: </span><span class='Parentheses'>(</span><a href="async.c.html#LN206"><span class='Ref_to_Parameter'>y</span></a><span class='Parentheses'>))</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Struct describing a listening backend's status 
 */ 
</span><a name="LN214"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>QueueBackendStatus</span> 
<span class='Delimiter'>{ 
</span><a name="LN216"></a>    <a href="../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Member'>pid</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* either a PID or InvalidPid */ 
</span><a name="LN217"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>dboid</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* backend's database OID, or InvalidOid */ 
</span><a name="LN218"></a>    <a href="async.c.html#LN181"><span class='Ref_to_Struct'>QueuePosition</span></a> <span class='Declare_Member'>pos</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* backend has read queue up to here */ 
</span><a name="LN219"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>QueueBackendStatus</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Shared memory state for LISTEN/NOTIFY (excluding its SLRU stuff) 
 * 
 * The AsyncQueueControl structure is protected by the AsyncQueueLock. 
 * 
 * When holding the lock in SHARED mode, backends may only inspect their own 
 * entries as well as the head and tail pointers. Consequently we can allow a 
 * backend to update its own record while holding only SHARED lock (since no 
 * other backend will inspect it). 
 * 
 * When holding the lock in EXCLUSIVE mode, backends can inspect the entries 
 * of other backends and also change the head and tail pointers. 
 * 
 * AsyncCtlLock is used as the control lock for the pg_notify SLRU buffers. 
 * In order to avoid deadlocks, whenever we need both locks, we always first 
 * get AsyncQueueLock and then AsyncCtlLock. 
 * 
 * Each backend uses the backend[] array entry with index equal to its 
 * BackendId (which can range from 1 to MaxBackends).  We rely on this to make 
 * SendProcSignal fast. 
 */ 
</span><a name="LN242"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AsyncQueueControl</span> 
<span class='Delimiter'>{ 
</span><a name="LN244"></a>    <a href="async.c.html#LN181"><span class='Ref_to_Struct'>QueuePosition</span></a> <span class='Declare_Member'>head</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* head points to the next free location */ 
</span><a name="LN245"></a>    <a href="async.c.html#LN181"><span class='Ref_to_Struct'>QueuePosition</span></a> <span class='Declare_Member'>tail</span><span class='Delimiter'>;</span>         <span class='Comment_Multi_Line'>/* the global tail is equivalent to the pos of 
                                 * the "slowest" backend */ 
</span><a name="LN247"></a>    <a href="../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <span class='Declare_Member'>lastQueueFillWarn</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* time of last queue-full msg */ 
</span><a name="LN248"></a>    <a href="async.c.html#LN214"><span class='Ref_to_Struct'>QueueBackendStatus</span></a> <span class='Declare_Member'>backend</span><span class='Delimiter'>[</span>FLEXIBLE_ARRAY_MEMBER<span class='Delimiter'>]; 
</span>    <span class='Comment_Multi_Line'>/* backend[0] is not used; used entries are from [1] to [MaxBackends] */ 
</span><a name="LN250"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>AsyncQueueControl</span><span class='Delimiter'>; 
</span> 
<a name="LN252"></a><span class='Keyword'>static </span><a href="async.c.html#LN242"><span class='Ref_to_Struct'>AsyncQueueControl</span></a> <span class='Operator'>*</span><span class='Declare_Var'>asyncQueueControl</span><span class='Delimiter'>; 
</span> 
<a name="LN254"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>QUEUE_HEAD</span>                  <span class='Parentheses'>(</span><a href="async.c.html#LN252"><span class='Ref_to_Global_Var'>asyncQueueControl</span></a><span class='Operator'>-&GT;</span><a href="async.c.html#LN244"><span class='Ref_to_Member'>head</span></a><span class='Parentheses'>) 
</span><a name="LN255"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>QUEUE_TAIL</span>                  <span class='Parentheses'>(</span><a href="async.c.html#LN252"><span class='Ref_to_Global_Var'>asyncQueueControl</span></a><span class='Operator'>-&GT;</span><a href="async.c.html#LN245"><span class='Ref_to_Member'>tail</span></a><span class='Parentheses'>) 
</span><a name="LN256"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>QUEUE_BACKEND_PID</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>i</span><span class='Parentheses'>)</span>        <span class='Parentheses'>(</span><a href="async.c.html#LN252"><span class='Ref_to_Global_Var'>asyncQueueControl</span></a><span class='Operator'>-&GT;</span><a href="async.c.html#LN248"><span class='Ref_to_Member'>backend</span></a><span class='Delimiter'>[</span><a href="async.c.html#LN256"><span class='Ref_to_Parameter'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="async.c.html#LN216"><span class='Ref_to_Member'>pid</span></a><span class='Parentheses'>) 
</span><a name="LN257"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>QUEUE_BACKEND_DBOID</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>i</span><span class='Parentheses'>)</span>      <span class='Parentheses'>(</span><a href="async.c.html#LN252"><span class='Ref_to_Global_Var'>asyncQueueControl</span></a><span class='Operator'>-&GT;</span><a href="async.c.html#LN248"><span class='Ref_to_Member'>backend</span></a><span class='Delimiter'>[</span><a href="async.c.html#LN257"><span class='Ref_to_Parameter'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="async.c.html#LN217"><span class='Ref_to_Member'>dboid</span></a><span class='Parentheses'>) 
</span><a name="LN258"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>QUEUE_BACKEND_POS</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>i</span><span class='Parentheses'>)</span>        <span class='Parentheses'>(</span><a href="async.c.html#LN252"><span class='Ref_to_Global_Var'>asyncQueueControl</span></a><span class='Operator'>-&GT;</span><a href="async.c.html#LN248"><span class='Ref_to_Member'>backend</span></a><span class='Delimiter'>[</span><a href="async.c.html#LN258"><span class='Ref_to_Parameter'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="async.c.html#LN218"><span class='Ref_to_Member'>pos</span></a><span class='Parentheses'>) 
</span> 
<span class='Comment_Multi_Line'>/* 
 * The SLRU buffer area through which we access the notification queue 
 */ 
</span><a name="LN263"></a><span class='Keyword'>static </span><a href="../../include/access/slru.h.html#LN116"><span class='Ref_to_Struct'>SlruCtlData</span></a> <span class='Declare_Var'>AsyncCtlData</span><span class='Delimiter'>; 
</span> 
<a name="LN265"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>AsyncCtl</span>                    <span class='Parentheses'>(</span><span class='Operator'>&</span><a href="async.c.html#LN263"><span class='Ref_to_Global_Var'>AsyncCtlData</span></a><span class='Parentheses'>) 
</span><a name="LN266"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>QUEUE_PAGESIZE</span>              BLCKSZ 
<a name="LN267"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>QUEUE_FULL_WARN_INTERVAL</span>    <span class='Number'>5000</span>        <span class='Comment_Single_Line'>/* warn at most once every 5s */ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * slru.c currently assumes that all filenames are four characters of hex 
 * digits. That means that we can use segments 0000 through FFFF. 
 * Each segment contains SLRU_PAGES_PER_SEGMENT pages which gives us 
 * the pages from 0 to SLRU_PAGES_PER_SEGMENT * 0x10000 - 1. 
 * 
 * It's of course possible to enhance slru.c, but this gives us so much 
 * space already that it doesn't seem worth the trouble. 
 * 
 * The most data we can have in the queue at a time is QUEUE_MAX_PAGE/2 
 * pages, because more than that would confuse slru.c into thinking there 
 * was a wraparound condition.  With the default BLCKSZ this means there 
 * can be up to 8GB of queued-and-not-read data. 
 * 
 * Note: it's possible to redefine QUEUE_MAX_PAGE with a smaller multiple of 
 * SLRU_PAGES_PER_SEGMENT, for easier testing of queue-full behaviour. 
 */ 
</span><a name="LN286"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>QUEUE_MAX_PAGE</span>          <span class='Parentheses'>(</span><a href="../../include/access/slru.h.html#LN36"><span class='Ref_to_Const'>SLRU_PAGES_PER_SEGMENT</span></a> <span class='Operator'>* </span><span class='Number'>0x10000</span> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>) 
</span> 
<span class='Comment_Multi_Line'>/* 
 * listenChannels identifies the channels we are actually listening to 
 * (ie, have committed a LISTEN on).  It is a simple list of channel names, 
 * allocated in TopMemoryContext. 
 */ 
</span><a name="LN293"></a><span class='Keyword'>static </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Var'>listenChannels</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* list of C strings */ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * State for pending LISTEN/UNLISTEN actions consists of an ordered list of 
 * all actions requested in the current transaction.  As explained above, 
 * we don't actually change listenChannels until we reach transaction commit. 
 * 
 * The list is kept in CurTransactionContext.  In subtransactions, each 
 * subtransaction has its own list in its own CurTransactionContext, but 
 * successful subtransactions attach their lists to their parent's list. 
 * Failed subtransactions simply discard their lists. 
 */ 
</span><span class='Control'>typedef</span> <span class='Control'>enum</span> 
<span class='Delimiter'>{ 
</span><a name="LN307"></a>    <span class='Declare_Enum_Const'>LISTEN_LISTEN</span><span class='Delimiter'>, 
</span><a name="LN308"></a>    <span class='Declare_Enum_Const'>LISTEN_UNLISTEN</span><span class='Delimiter'>, 
</span><a name="LN309"></a>    <span class='Declare_Enum_Const'>LISTEN_UNLISTEN_ALL</span> 
<a name="LN310"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>ListenActionKind</span><span class='Delimiter'>; 
</span> 
<span class='Control'>typedef</span> <span class='Control'>struct</span> 
<span class='Delimiter'>{ 
</span><a name="LN314"></a>    <a href="async.c.html#LN305"><span class='Ref_to_Typedef'>ListenActionKind</span></a> <span class='Declare_Member'>action</span><span class='Delimiter'>; 
</span><a name="LN315"></a>    <span class='Keyword'>char</span>        <span class='Declare_Member'>channel</span><span class='Delimiter'>[</span>FLEXIBLE_ARRAY_MEMBER<span class='Delimiter'>]; </span><span class='Comment_Single_Line'>/* nul-terminated string */ 
</span><a name="LN316"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>ListenAction</span><span class='Delimiter'>; 
</span> 
<a name="LN318"></a><span class='Keyword'>static </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Var'>pendingActions</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* list of ListenAction */ 
</span> 
<a name="LN320"></a><span class='Keyword'>static </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Var'>upperPendingActions</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* list of upper-xact lists */ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * State for outbound notifies consists of a list of all channels+payloads 
 * NOTIFYed in the current transaction. We do not actually perform a NOTIFY 
 * until and unless the transaction commits.  pendingNotifies is NIL if no 
 * NOTIFYs have been done in the current transaction. 
 * 
 * The list is kept in CurTransactionContext.  In subtransactions, each 
 * subtransaction has its own list in its own CurTransactionContext, but 
 * successful subtransactions attach their lists to their parent's list. 
 * Failed subtransactions simply discard their lists. 
 * 
 * Note: the action and notify lists do not interact within a transaction. 
 * In particular, if a transaction does NOTIFY and then LISTEN on the same 
 * condition name, it will get a self-notify at commit.  This is a bit odd 
 * but is consistent with our historical behavior. 
 */ 
</span><a name="LN338"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>Notification</span> 
<span class='Delimiter'>{ 
</span><a name="LN340"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>channel</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* channel name */ 
</span><a name="LN341"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Member'>payload</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* payload string (can be empty) */ 
</span><a name="LN342"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>Notification</span><span class='Delimiter'>; 
</span> 
<a name="LN344"></a><span class='Keyword'>static </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Var'>pendingNotifies</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* list of Notifications */ 
</span> 
<a name="LN346"></a><span class='Keyword'>static </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Var'>upperPendingNotifies</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* list of upper-xact lists */ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Inbound notifications are initially processed by HandleNotifyInterrupt(), 
 * called from inside a signal handler. That just sets the 
 * notifyInterruptPending flag and sets the process 
 * latch. ProcessNotifyInterrupt() will then be called whenever it's safe to 
 * actually deal with the interrupt. 
 */ 
</span><a name="LN355"></a><span class='Keyword'>volatile </span>sig_atomic_t <span class='Declare_Var'>notifyInterruptPending</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* True if we've registered an on_shmem_exit cleanup */ 
</span><a name="LN358"></a><span class='Keyword'>static bool </span><span class='Declare_Var'>unlistenExitRegistered</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* True if we're currently registered as a listener in asyncQueueControl */ 
</span><a name="LN361"></a><span class='Keyword'>static bool </span><span class='Declare_Var'>amRegisteredListener</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* has this backend sent notifications in the current transaction? */ 
</span><a name="LN364"></a><span class='Keyword'>static bool </span><span class='Declare_Var'>backendHasSentNotifications</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* GUC parameter */ 
</span><a name="LN367"></a><span class='Keyword'>bool</span>        <span class='Declare_Var'>Trace_notify</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* local function prototypes */ 
</span><a name="LN370"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>asyncQueuePagePrecedes</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>p</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>q</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN371"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>queue_listen</span><span class='Parentheses'>(</span><a href="async.c.html#LN305"><span class='Ref_to_Typedef'>ListenActionKind</span></a> <span class='Declare_Parameter'>action</span><span class='Delimiter'>, </span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>channel</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN372"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>Async_UnlistenOnExit</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>code</span><span class='Delimiter'>, </span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>arg</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN373"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>Exec_ListenPreCommit</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN374"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>Exec_ListenCommit</span><span class='Parentheses'>(</span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>channel</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN375"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>Exec_UnlistenCommit</span><span class='Parentheses'>(</span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>channel</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN376"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>Exec_UnlistenAllCommit</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN377"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>IsListeningOn</span><span class='Parentheses'>(</span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>channel</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN378"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>asyncQueueUnregister</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN379"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>asyncQueueIsFull</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN380"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>asyncQueueAdvance</span><span class='Parentheses'>(</span><span class='Keyword'>volatile </span><a href="async.c.html#LN181"><span class='Ref_to_Struct'>QueuePosition</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>position</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>entryLength</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN381"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>asyncQueueNotificationToEntry</span><span class='Parentheses'>(</span><a href="async.c.html#LN338"><span class='Ref_to_Struct'>Notification</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>n</span><span class='Delimiter'>, </span><a href="async.c.html#LN164"><span class='Ref_to_Struct'>AsyncQueueEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>qe</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN382"></a><span class='Keyword'>static </span><a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>asyncQueueAddEntries</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>nextNotify</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN383"></a><span class='Keyword'>static double </span><span class='Declare_Prototype'>asyncQueueUsage</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN384"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>asyncQueueFillWarning</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN385"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>SignalBackends</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN386"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>asyncQueueReadAllNotifications</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN387"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>asyncQueueProcessPageEntries</span><span class='Parentheses'>(</span><span class='Keyword'>volatile </span><a href="async.c.html#LN181"><span class='Ref_to_Struct'>QueuePosition</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>current</span><span class='Delimiter'>, 
</span><a name="LN388"></a>                             <a href="async.c.html#LN181"><span class='Ref_to_Struct'>QueuePosition</span></a> <span class='Declare_Parameter'>stop</span><span class='Delimiter'>, 
</span><a name="LN389"></a>                             <span class='Keyword'>char </span><span class='Operator'>*</span><span class='Declare_Parameter'>page_buffer</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN390"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>asyncQueueAdvanceTail</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN391"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>ProcessIncomingNotify</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN392"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>AsyncExistsPendingNotify</span><span class='Parentheses'>(</span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>channel</span><span class='Delimiter'>, </span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>payload</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN393"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>ClearPendingActionsAndNotifies</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * We will work on the page range of 0..QUEUE_MAX_PAGE. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN399"></a><span class='Declare_Function'>asyncQueuePagePrecedes</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>p</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>q</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN401"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>diff</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We have to compare modulo (QUEUE_MAX_PAGE+1)/2.  Both inputs should be 
     * in the range 0..QUEUE_MAX_PAGE. 
     */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="async.c.html#LN399"><span class='Ref_to_Parameter'>p</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="async.c.html#LN399"><span class='Ref_to_Parameter'>p</span></a> <span class='Operator'>&LT;= </span><a href="async.c.html#LN286"><span class='Ref_to_Const'>QUEUE_MAX_PAGE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="async.c.html#LN399"><span class='Ref_to_Parameter'>q</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="async.c.html#LN399"><span class='Ref_to_Parameter'>q</span></a> <span class='Operator'>&LT;= </span><a href="async.c.html#LN286"><span class='Ref_to_Const'>QUEUE_MAX_PAGE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="async.c.html#LN401"><span class='Ref_To_Local'>diff</span></a> <span class='Operator'>= </span><a href="async.c.html#LN399"><span class='Ref_to_Parameter'>p</span></a> <span class='Operator'>- </span><a href="async.c.html#LN399"><span class='Ref_to_Parameter'>q</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN401"><span class='Ref_To_Local'>diff</span></a> <span class='Operator'>&GT;= </span><span class='Parentheses'>((</span><a href="async.c.html#LN286"><span class='Ref_to_Const'>QUEUE_MAX_PAGE</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>) </span><span class='Operator'>/ </span><span class='Number'>2</span><span class='Parentheses'>))</span> 
        <a href="async.c.html#LN401"><span class='Ref_To_Local'>diff</span></a> <span class='Operator'>-= </span><a href="async.c.html#LN286"><span class='Ref_to_Const'>QUEUE_MAX_PAGE</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN401"><span class='Ref_To_Local'>diff</span></a> <span class='Operator'>&LT; -</span><span class='Parentheses'>((</span><a href="async.c.html#LN286"><span class='Ref_to_Const'>QUEUE_MAX_PAGE</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>) </span><span class='Operator'>/ </span><span class='Number'>2</span><span class='Parentheses'>))</span> 
        <a href="async.c.html#LN401"><span class='Ref_To_Local'>diff</span></a> <span class='Operator'>+= </span><a href="async.c.html#LN286"><span class='Ref_to_Const'>QUEUE_MAX_PAGE</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="async.c.html#LN401"><span class='Ref_To_Local'>diff</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Report space needed for our shared memory area 
 */ 
</span><a href="../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a> 
<a name="LN422"></a><span class='Declare_Function'>AsyncShmemSize</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN424"></a>    <a href="../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a>        <span class='Declare_Local'>size</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* This had better match AsyncShmemInit */ 
</span>    <a href="async.c.html#LN424"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>= </span><a href="../../include/storage/shmem.h.html#LN45"><span class='Ref_to_Proto'>mul_size</span></a><span class='Parentheses'>(</span><a href="../utils/init/globals.c.html#LN126"><span class='Ref_to_Global_Var'>MaxBackends</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="async.c.html#LN214"><span class='Ref_to_Struct'>QueueBackendStatus</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="async.c.html#LN424"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>= </span><a href="../../include/storage/shmem.h.html#LN44"><span class='Ref_to_Proto'>add_size</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN424"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>, </span><a href="../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN242"><span class='Ref_to_Struct'>AsyncQueueControl</span></a><span class='Delimiter'>, </span>backend<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="async.c.html#LN424"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>= </span><a href="../../include/storage/shmem.h.html#LN44"><span class='Ref_to_Proto'>add_size</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN424"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>, </span><a href="../access/transam/slru.c.html#LN143"><span class='Ref_to_Func'>SimpleLruShmemSize</span></a><span class='Parentheses'>(</span><a href="../../include/commands/async.h.html#LN22"><span class='Ref_to_Const'>NUM_ASYNC_BUFFERS</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="async.c.html#LN424"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Initialize our shared memory area 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN439"></a><span class='Declare_Function'>AsyncShmemInit</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN441"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>found</span><span class='Delimiter'>; 
</span><a name="LN442"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>slotno</span><span class='Delimiter'>; 
</span><a name="LN443"></a>    <a href="../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a>        <span class='Declare_Local'>size</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Create or attach to the AsyncQueueControl structure. 
     * 
     * The used entries in the backend[] array run from 1 to MaxBackends; the 
     * zero'th entry is unused but must be allocated. 
     */ 
</span>    <a href="async.c.html#LN443"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>= </span><a href="../../include/storage/shmem.h.html#LN45"><span class='Ref_to_Proto'>mul_size</span></a><span class='Parentheses'>(</span><a href="../utils/init/globals.c.html#LN126"><span class='Ref_to_Global_Var'>MaxBackends</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="async.c.html#LN214"><span class='Ref_to_Struct'>QueueBackendStatus</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="async.c.html#LN443"><span class='Ref_To_Local'>size</span></a> <span class='Operator'>= </span><a href="../../include/storage/shmem.h.html#LN44"><span class='Ref_to_Proto'>add_size</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN443"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>, </span><a href="../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN242"><span class='Ref_to_Struct'>AsyncQueueControl</span></a><span class='Delimiter'>, </span>backend<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="async.c.html#LN252"><span class='Ref_to_Global_Var'>asyncQueueControl</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="async.c.html#LN242"><span class='Ref_to_Struct'>AsyncQueueControl</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>        <a href="../../include/storage/shmem.h.html#LN43"><span class='Ref_to_Proto'>ShmemInitStruct</span></a><span class='Parentheses'>(</span><span class='String'>"Async Queue Control"</span><span class='Delimiter'>, </span><a href="async.c.html#LN443"><span class='Ref_To_Local'>size</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="async.c.html#LN441"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="async.c.html#LN441"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* First time through, so initialize it */ 
</span><a name="LN460"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
        <a href="async.c.html#LN190"><span class='Ref_to_Macro'>SET_QUEUE_POS</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN254"><span class='Ref_to_Const'>QUEUE_HEAD</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="async.c.html#LN190"><span class='Ref_to_Macro'>SET_QUEUE_POS</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN255"><span class='Ref_to_Const'>QUEUE_TAIL</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="async.c.html#LN252"><span class='Ref_to_Global_Var'>asyncQueueControl</span></a><span class='Operator'>-&GT;</span><a href="async.c.html#LN247"><span class='Ref_to_Member'>lastQueueFillWarn</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* zero'th entry won't be used, but let's initialize it anyway */ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="async.c.html#LN460"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="async.c.html#LN460"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT;= </span><a href="../utils/init/globals.c.html#LN126"><span class='Ref_to_Global_Var'>MaxBackends</span></a><span class='Delimiter'>; </span><a href="async.c.html#LN460"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="async.c.html#LN256"><span class='Ref_to_Macro'>QUEUE_BACKEND_PID</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN460"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>) </span><span class='Operator'>= </span><a href="../../include/miscadmin.h.html#LN32"><span class='Ref_to_Const'>InvalidPid</span></a><span class='Delimiter'>; 
</span>            <a href="async.c.html#LN257"><span class='Ref_to_Macro'>QUEUE_BACKEND_DBOID</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN460"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>) </span><span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>            <a href="async.c.html#LN190"><span class='Ref_to_Macro'>SET_QUEUE_POS</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN258"><span class='Ref_to_Macro'>QUEUE_BACKEND_POS</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN460"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Set up SLRU management of the pg_notify data. 
     */ 
</span>    <a href="async.c.html#LN265"><span class='Ref_to_Const'>AsyncCtl</span></a><span class='Operator'>-&GT;</span>PagePrecedes <span class='Operator'>= </span><a href="async.c.html#LN370"><span class='Ref_to_Proto'>asyncQueuePagePrecedes</span></a><span class='Delimiter'>; 
</span>    <a href="../../include/access/slru.h.html#LN144"><span class='Ref_to_Proto'>SimpleLruInit</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN265"><span class='Ref_to_Const'>AsyncCtl</span></a><span class='Delimiter'>, </span><span class='String'>"async"</span><span class='Delimiter'>, </span><a href="../../include/commands/async.h.html#LN22"><span class='Ref_to_Const'>NUM_ASYNC_BUFFERS</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, 
</span>                  AsyncCtlLock<span class='Delimiter'>, </span><span class='String'>"pg_notify"</span><span class='Delimiter'>, </span><a href="../../include/storage/lwlock.h.html#LN202"><span class='Ref_to_EnumConst'>LWTRANCHE_ASYNC_BUFFERS</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* Override default assumption that writes should be fsync'd */ 
</span>    <a href="async.c.html#LN265"><span class='Ref_to_Const'>AsyncCtl</span></a><span class='Operator'>-&GT;</span>do_fsync <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="async.c.html#LN441"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * During start or reboot, clean out the pg_notify directory. 
         */ 
</span>        <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="../../include/access/slru.h.html#LN158"><span class='Ref_to_Proto'>SlruScanDirectory</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN265"><span class='Ref_to_Const'>AsyncCtl</span></a><span class='Delimiter'>, </span><a href="../../include/access/slru.h.html#LN164"><span class='Ref_to_Proto'>SlruScanDirCbDeleteAll</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Now initialize page zero to empty */ 
</span>        <a href="../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>AsyncCtlLock<span class='Delimiter'>, </span><a href="../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="async.c.html#LN442"><span class='Ref_To_Local'>slotno</span></a> <span class='Operator'>= </span><a href="../../include/access/slru.h.html#LN146"><span class='Ref_to_Proto'>SimpleLruZeroPage</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN265"><span class='Ref_to_Const'>AsyncCtl</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN187"><span class='Ref_to_Macro'>QUEUE_POS_PAGE</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN254"><span class='Ref_to_Const'>QUEUE_HEAD</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* This write is just to verify that pg_notify/ is writable */ 
</span>        <a href="../../include/access/slru.h.html#LN151"><span class='Ref_to_Proto'>SimpleLruWritePage</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN265"><span class='Ref_to_Const'>AsyncCtl</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN442"><span class='Ref_To_Local'>slotno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>AsyncCtlLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end AsyncShmemInit &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * pg_notify - 
 *    SQL function to send a notification event 
 */ 
</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN505"></a><span class='Declare_Function'>pg_notify</span><span class='Parentheses'>(</span><a href="../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN507"></a>    <span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Local'>channel</span><span class='Delimiter'>; 
</span><a name="LN508"></a>    <span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Local'>payload</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/fmgr.h.html#LN173"><span class='Ref_to_Macro'>PG_ARGISNULL</span></a><span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>))</span> 
        <a href="async.c.html#LN507"><span class='Ref_To_Local'>channel</span></a> <span class='Operator'>= </span><span class='String'>""</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="async.c.html#LN507"><span class='Ref_To_Local'>channel</span></a> <span class='Operator'>= </span><a href="../../include/utils/builtins.h.html#LN87"><span class='Ref_to_Proto'>text_to_cstring</span></a><span class='Parentheses'>(</span><a href="../../include/fmgr.h.html#LN272"><span class='Ref_to_Macro'>PG_GETARG_TEXT_PP</span></a><span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/fmgr.h.html#LN173"><span class='Ref_to_Macro'>PG_ARGISNULL</span></a><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Parentheses'>))</span> 
        <a href="async.c.html#LN508"><span class='Ref_To_Local'>payload</span></a> <span class='Operator'>= </span><span class='String'>""</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="async.c.html#LN508"><span class='Ref_To_Local'>payload</span></a> <span class='Operator'>= </span><a href="../../include/utils/builtins.h.html#LN87"><span class='Ref_to_Proto'>text_to_cstring</span></a><span class='Parentheses'>(</span><a href="../../include/fmgr.h.html#LN272"><span class='Ref_to_Macro'>PG_GETARG_TEXT_PP</span></a><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* For NOTIFY as a statement, this is checked in ProcessUtility */ 
</span>    <a href="../tcop/utility.c.html#LN271"><span class='Ref_to_Func'>PreventCommandDuringRecovery</span></a><span class='Parentheses'>(</span><span class='String'>"NOTIFY"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/commands/async.h.html#LN35"><span class='Ref_to_Proto'>Async_Notify</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN507"><span class='Ref_To_Local'>channel</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN508"><span class='Ref_To_Local'>payload</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/fmgr.h.html#LN308"><span class='Ref_to_Macro'>PG_RETURN_VOID</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end pg_notify &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * Async_Notify 
 * 
 *      This is executed by the SQL notify command. 
 * 
 *      Adds the message to the list of pending notifies. 
 *      Actual notification happens during transaction commit. 
 *      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN539"></a><span class='Declare_Function'>Async_Notify</span><span class='Parentheses'>(</span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>channel</span><span class='Delimiter'>, </span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>payload</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN541"></a>    <a href="async.c.html#LN338"><span class='Ref_to_Struct'>Notification</span></a> <span class='Operator'>*</span><span class='Declare_Local'>n</span><span class='Delimiter'>; 
</span><a name="LN542"></a>    <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldcontext</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/access/parallel.h.html#LN51"><span class='Ref_to_Macro'>IsParallelWorker</span></a><span class='Parentheses'>())</span> 
        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cannot send notifications from a parallel worker"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN367"><span class='Ref_to_Global_Var'>Trace_notify</span></a><span class='Parentheses'>) 
</span>        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN24"><span class='Ref_to_Const'>DEBUG1</span></a><span class='Delimiter'>, </span><span class='String'>"Async_Notify(%s)"</span><span class='Delimiter'>, </span><a href="async.c.html#LN539"><span class='Ref_to_Parameter'>channel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* a channel name must be specified */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="async.c.html#LN539"><span class='Ref_to_Parameter'>channel</span></a> <span class='Operator'>|| !</span>strlen<span class='Parentheses'>(</span><a href="async.c.html#LN539"><span class='Ref_to_Parameter'>channel</span></a><span class='Parentheses'>))</span> 
        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_INVALID_PARAMETER_VALUE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"channel name cannot be empty"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span>strlen<span class='Parentheses'>(</span><a href="async.c.html#LN539"><span class='Ref_to_Parameter'>channel</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT;= </span><a href="../../interfaces/ecpg/include/sqlda-native.h.html#LN15"><span class='Ref_to_Const'>NAMEDATALEN</span></a><span class='Parentheses'>)</span> 
        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_INVALID_PARAMETER_VALUE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"channel name too long"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN539"><span class='Ref_to_Parameter'>payload</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span>strlen<span class='Parentheses'>(</span><a href="async.c.html#LN539"><span class='Ref_to_Parameter'>payload</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT;= </span><a href="async.c.html#LN150"><span class='Ref_to_Const'>NOTIFY_PAYLOAD_MAX_LENGTH</span></a><span class='Parentheses'>)</span> 
            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_INVALID_PARAMETER_VALUE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"payload string too long"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* no point in making duplicate entries in the list ... */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN392"><span class='Ref_to_Proto'>AsyncExistsPendingNotify</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN539"><span class='Ref_to_Parameter'>channel</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN539"><span class='Ref_to_Parameter'>payload</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * The notification list needs to live until end of transaction, so store 
     * it in the transaction context. 
     */ 
</span>    <a href="async.c.html#LN542"><span class='Ref_To_Local'>oldcontext</span></a> <span class='Operator'>= </span><a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="../utils/mmgr/mcxt.c.html#LN48"><span class='Ref_to_Global_Var'>CurTransactionContext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="async.c.html#LN541"><span class='Ref_To_Local'>n</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="async.c.html#LN338"><span class='Ref_to_Struct'>Notification</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="async.c.html#LN338"><span class='Ref_to_Struct'>Notification</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="async.c.html#LN541"><span class='Ref_To_Local'>n</span></a><span class='Operator'>-&GT;</span><a href="async.c.html#LN340"><span class='Ref_to_Member'>channel</span></a> <span class='Operator'>= </span><a href="../../include/common/fe_memutils.h.html#LN32"><span class='Ref_to_Proto'>pstrdup</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN539"><span class='Ref_to_Parameter'>channel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN539"><span class='Ref_to_Parameter'>payload</span></a><span class='Parentheses'>) 
</span>        <a href="async.c.html#LN541"><span class='Ref_To_Local'>n</span></a><span class='Operator'>-&GT;</span><a href="async.c.html#LN341"><span class='Ref_to_Member'>payload</span></a> <span class='Operator'>= </span><a href="../../include/common/fe_memutils.h.html#LN32"><span class='Ref_to_Proto'>pstrdup</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN539"><span class='Ref_to_Parameter'>payload</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="async.c.html#LN541"><span class='Ref_To_Local'>n</span></a><span class='Operator'>-&GT;</span><a href="async.c.html#LN341"><span class='Ref_to_Member'>payload</span></a> <span class='Operator'>= </span><span class='String'>""</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We want to preserve the order so we need to append every notification. 
     * See comments at AsyncExistsPendingNotify(). 
     */ 
</span>    <a href="async.c.html#LN344"><span class='Ref_to_Global_Var'>pendingNotifies</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN344"><span class='Ref_to_Global_Var'>pendingNotifies</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN541"><span class='Ref_To_Local'>n</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN542"><span class='Ref_To_Local'>oldcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end Async_Notify &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * queue_listen 
 *      Common code for listen, unlisten, unlisten all commands. 
 * 
 *      Adds the request to the list of pending actions. 
 *      Actual update of the listenChannels list happens during transaction 
 *      commit. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN604"></a><span class='Declare_Function'>queue_listen</span><span class='Parentheses'>(</span><a href="async.c.html#LN305"><span class='Ref_to_Typedef'>ListenActionKind</span></a> <span class='Declare_Parameter'>action</span><span class='Delimiter'>, </span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>channel</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN606"></a>    <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldcontext</span><span class='Delimiter'>; 
</span><a name="LN607"></a>    <a href="async.c.html#LN312"><span class='Ref_to_Typedef'>ListenAction</span></a> <span class='Operator'>*</span><span class='Declare_Local'>actrec</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Unlike Async_Notify, we don't try to collapse out duplicates. It would 
     * be too complicated to ensure we get the right interactions of 
     * conflicting LISTEN/UNLISTEN/UNLISTEN_ALL, and it's unlikely that there 
     * would be any performance benefit anyway in sane applications. 
     */ 
</span>    <a href="async.c.html#LN606"><span class='Ref_To_Local'>oldcontext</span></a> <span class='Operator'>= </span><a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="../utils/mmgr/mcxt.c.html#LN48"><span class='Ref_to_Global_Var'>CurTransactionContext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* space for terminating null is included in sizeof(ListenAction) */ 
</span>    <a href="async.c.html#LN607"><span class='Ref_To_Local'>actrec</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="async.c.html#LN312"><span class='Ref_to_Typedef'>ListenAction</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN312"><span class='Ref_to_Typedef'>ListenAction</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN604"><span class='Ref_to_Parameter'>channel</span></a><span class='Parentheses'>) </span><span class='Operator'>+ 
</span>                                     strlen<span class='Parentheses'>(</span><a href="async.c.html#LN604"><span class='Ref_to_Parameter'>channel</span></a><span class='Parentheses'>) </span><span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="async.c.html#LN607"><span class='Ref_To_Local'>actrec</span></a><span class='Operator'>-&GT;</span><a href="async.c.html#LN314"><span class='Ref_to_Member'>action</span></a> <span class='Operator'>= </span><a href="async.c.html#LN604"><span class='Ref_to_Parameter'>action</span></a><span class='Delimiter'>; 
</span>    <a href="../../../contrib/cube/cubeparse.y.html#LN150"><span class='Ref_to_Proto'>strcpy</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN607"><span class='Ref_To_Local'>actrec</span></a><span class='Operator'>-&GT;</span><a href="async.c.html#LN315"><span class='Ref_to_Member'>channel</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN604"><span class='Ref_to_Parameter'>channel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="async.c.html#LN318"><span class='Ref_to_Global_Var'>pendingActions</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN318"><span class='Ref_to_Global_Var'>pendingActions</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN607"><span class='Ref_To_Local'>actrec</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN606"><span class='Ref_To_Local'>oldcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end queue_listen &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Async_Listen 
 * 
 *      This is executed by the SQL listen command. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN634"></a><span class='Declare_Function'>Async_Listen</span><span class='Parentheses'>(</span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>channel</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN367"><span class='Ref_to_Global_Var'>Trace_notify</span></a><span class='Parentheses'>) 
</span>        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN24"><span class='Ref_to_Const'>DEBUG1</span></a><span class='Delimiter'>, </span><span class='String'>"Async_Listen(%s,%d)"</span><span class='Delimiter'>, </span><a href="async.c.html#LN634"><span class='Ref_to_Parameter'>channel</span></a><span class='Delimiter'>, </span><a href="../utils/init/globals.c.html#LN38"><span class='Ref_to_Global_Var'>MyProcPid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="async.c.html#LN371"><span class='Ref_to_Proto'>queue_listen</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN307"><span class='Ref_to_EnumConst'>LISTEN_LISTEN</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN634"><span class='Ref_to_Parameter'>channel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Async_Unlisten 
 * 
 *      This is executed by the SQL unlisten command. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN648"></a><span class='Declare_Function'>Async_Unlisten</span><span class='Parentheses'>(</span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>channel</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN367"><span class='Ref_to_Global_Var'>Trace_notify</span></a><span class='Parentheses'>) 
</span>        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN24"><span class='Ref_to_Const'>DEBUG1</span></a><span class='Delimiter'>, </span><span class='String'>"Async_Unlisten(%s,%d)"</span><span class='Delimiter'>, </span><a href="async.c.html#LN648"><span class='Ref_to_Parameter'>channel</span></a><span class='Delimiter'>, </span><a href="../utils/init/globals.c.html#LN38"><span class='Ref_to_Global_Var'>MyProcPid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* If we couldn't possibly be listening, no need to queue anything */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN318"><span class='Ref_to_Global_Var'>pendingActions</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>&& !</span><a href="async.c.html#LN358"><span class='Ref_to_Global_Var'>unlistenExitRegistered</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <a href="async.c.html#LN371"><span class='Ref_to_Proto'>queue_listen</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN308"><span class='Ref_to_EnumConst'>LISTEN_UNLISTEN</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN648"><span class='Ref_to_Parameter'>channel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Async_UnlistenAll 
 * 
 *      This is invoked by UNLISTEN * command, and also at backend exit. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN666"></a><span class='Declare_Function'>Async_UnlistenAll</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN367"><span class='Ref_to_Global_Var'>Trace_notify</span></a><span class='Parentheses'>) 
</span>        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN24"><span class='Ref_to_Const'>DEBUG1</span></a><span class='Delimiter'>, </span><span class='String'>"Async_UnlistenAll(%d)"</span><span class='Delimiter'>, </span><a href="../utils/init/globals.c.html#LN38"><span class='Ref_to_Global_Var'>MyProcPid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* If we couldn't possibly be listening, no need to queue anything */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN318"><span class='Ref_to_Global_Var'>pendingActions</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>&& !</span><a href="async.c.html#LN358"><span class='Ref_to_Global_Var'>unlistenExitRegistered</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <a href="async.c.html#LN371"><span class='Ref_to_Proto'>queue_listen</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN309"><span class='Ref_to_EnumConst'>LISTEN_UNLISTEN_ALL</span></a><span class='Delimiter'>, </span><span class='String'>""</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * SQL function: return a set of the channel names this backend is actively 
 * listening to. 
 * 
 * Note: this coding relies on the fact that the listenChannels list cannot 
 * change within a transaction. 
 */ 
</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN686"></a><span class='Declare_Function'>pg_listening_channels</span><span class='Parentheses'>(</span><a href="../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN688"></a>    <a href="../../include/funcapi.h.html#LN56"><span class='Ref_to_Struct'>FuncCallContext</span></a> <span class='Operator'>*</span><span class='Declare_Local'>funcctx</span><span class='Delimiter'>; 
</span><a name="LN689"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>  <span class='Operator'>**</span><span class='Declare_Local'>lcp</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* stuff done only on the first call of the function */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/funcapi.h.html#LN284"><span class='Ref_to_Macro'>SRF_IS_FIRSTCALL</span></a><span class='Parentheses'>())</span> 
    <span class='Delimiter'>{ 
</span><a name="LN694"></a>        <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldcontext</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* create a function context for cross-call persistence */ 
</span>        <a href="async.c.html#LN688"><span class='Ref_To_Local'>funcctx</span></a> <span class='Operator'>= </span><a href="../../include/funcapi.h.html#LN286"><span class='Ref_to_Macro'>SRF_FIRSTCALL_INIT</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* switch to memory context appropriate for multiple function calls */ 
</span>        <a href="async.c.html#LN694"><span class='Ref_To_Local'>oldcontext</span></a> <span class='Operator'>= </span><a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN688"><span class='Ref_To_Local'>funcctx</span></a><span class='Operator'>-&GT;</span><a href="../../include/funcapi.h.html#LN108"><span class='Ref_to_Member'>multi_call_memory_ctx</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* allocate memory for user context */ 
</span>        <a href="async.c.html#LN689"><span class='Ref_To_Local'>lcp</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a> <span class='Operator'>**</span><span class='Parentheses'>) </span><a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a> <span class='Operator'>*</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="async.c.html#LN689"><span class='Ref_To_Local'>lcp</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN293"><span class='Ref_to_Global_Var'>listenChannels</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="async.c.html#LN688"><span class='Ref_To_Local'>funcctx</span></a><span class='Operator'>-&GT;</span><a href="../../include/funcapi.h.html#LN89"><span class='Ref_to_Member'>user_fctx</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="async.c.html#LN689"><span class='Ref_To_Local'>lcp</span></a><span class='Delimiter'>; 
</span> 
        <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN694"><span class='Ref_To_Local'>oldcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* stuff done on every call of the function */ 
</span>    <a href="async.c.html#LN688"><span class='Ref_To_Local'>funcctx</span></a> <span class='Operator'>= </span><a href="../../include/funcapi.h.html#LN288"><span class='Ref_to_Macro'>SRF_PERCALL_SETUP</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="async.c.html#LN689"><span class='Ref_To_Local'>lcp</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a> <span class='Operator'>**</span><span class='Parentheses'>) </span><a href="async.c.html#LN688"><span class='Ref_To_Local'>funcctx</span></a><span class='Operator'>-&GT;</span><a href="../../include/funcapi.h.html#LN89"><span class='Ref_to_Member'>user_fctx</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>while</span> <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="async.c.html#LN689"><span class='Ref_To_Local'>lcp</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN716"></a>        <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>channel</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="async.c.html#LN689"><span class='Ref_To_Local'>lcp</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Operator'>*</span><a href="async.c.html#LN689"><span class='Ref_To_Local'>lcp</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="async.c.html#LN689"><span class='Ref_To_Local'>lcp</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/funcapi.h.html#LN290"><span class='Ref_to_Macro'>SRF_RETURN_NEXT</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN688"><span class='Ref_To_Local'>funcctx</span></a><span class='Delimiter'>, </span><a href="../../include/utils/builtins.h.html#LN90"><span class='Ref_to_Macro'>CStringGetTextDatum</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN716"><span class='Ref_To_Local'>channel</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../include/funcapi.h.html#LN308"><span class='Ref_to_Macro'>SRF_RETURN_DONE</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN688"><span class='Ref_To_Local'>funcctx</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end pg_listening_channels &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Async_UnlistenOnExit 
 * 
 * This is executed at backend exit if we have done any LISTENs in this 
 * backend.  It might not be necessary anymore, if the user UNLISTENed 
 * everything, but we don't try to detect that case. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN733"></a><span class='Declare_Function'>Async_UnlistenOnExit</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>code</span><span class='Delimiter'>, </span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>arg</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="async.c.html#LN376"><span class='Ref_to_Proto'>Exec_UnlistenAllCommit</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="async.c.html#LN378"><span class='Ref_to_Proto'>asyncQueueUnregister</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * AtPrepare_Notify 
 * 
 *      This is called at the prepare phase of a two-phase 
 *      transaction.  Save the state for possible commit later. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN746"></a><span class='Declare_Function'>AtPrepare_Notify</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* It's not allowed to have any pending LISTEN/UNLISTEN/NOTIFY actions */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN318"><span class='Ref_to_Global_Var'>pendingActions</span></a> <span class='Operator'>|| </span><a href="async.c.html#LN344"><span class='Ref_to_Global_Var'>pendingNotifies</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"cannot PREPARE a transaction that has executed LISTEN, UNLISTEN, or NOTIFY"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * PreCommit_Notify 
 * 
 *      This is called at transaction commit, before actually committing to 
 *      clog. 
 * 
 *      If there are pending LISTEN actions, make sure we are listed in the 
 *      shared-memory listener array.  This must happen before commit to 
 *      ensure we don't miss any notifies from transactions that commit 
 *      just after ours. 
 * 
 *      If there are outbound notify requests in the pendingNotifies list, 
 *      add them to the global queue.  We do that before commit so that 
 *      we can still throw error if we run out of queue space. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN771"></a><span class='Declare_Function'>PreCommit_Notify</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN773"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>p</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN318"><span class='Ref_to_Global_Var'>pendingActions</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>&& </span><a href="async.c.html#LN344"><span class='Ref_to_Global_Var'>pendingNotifies</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>;</span>                 <span class='Comment_Single_Line'>/* no relevant statements in this xact */ 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN367"><span class='Ref_to_Global_Var'>Trace_notify</span></a><span class='Parentheses'>) 
</span>        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN24"><span class='Ref_to_Const'>DEBUG1</span></a><span class='Delimiter'>, </span><span class='String'>"PreCommit_Notify"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Preflight for any pending listen/unlisten actions */ 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN773"><span class='Ref_To_Local'>p</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN318"><span class='Ref_to_Global_Var'>pendingActions</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN784"></a>        <a href="async.c.html#LN312"><span class='Ref_to_Typedef'>ListenAction</span></a> <span class='Operator'>*</span><span class='Declare_Local'>actrec</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="async.c.html#LN312"><span class='Ref_to_Typedef'>ListenAction</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN773"><span class='Ref_To_Local'>p</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="async.c.html#LN784"><span class='Ref_To_Local'>actrec</span></a><span class='Operator'>-&GT;</span><a href="async.c.html#LN314"><span class='Ref_to_Member'>action</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>case</span> <a href="async.c.html#LN307"><span class='Ref_to_EnumConst'>LISTEN_LISTEN</span></a><span class='Operator'>: 
</span>                <a href="async.c.html#LN373"><span class='Ref_to_Proto'>Exec_ListenPreCommit</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="async.c.html#LN308"><span class='Ref_to_EnumConst'>LISTEN_UNLISTEN</span></a><span class='Operator'>: 
</span>                <span class='Comment_Multi_Line'>/* there is no Exec_UnlistenPreCommit() */ 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="async.c.html#LN309"><span class='Ref_to_EnumConst'>LISTEN_UNLISTEN_ALL</span></a><span class='Operator'>: 
</span>                <span class='Comment_Multi_Line'>/* there is no Exec_UnlistenAllPreCommit() */ 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Queue any pending notifies */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN344"><span class='Ref_to_Global_Var'>pendingNotifies</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN803"></a>        <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>nextNotify</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Make sure that we have an XID assigned to the current transaction. 
         * GetCurrentTransactionId is cheap if we already have an XID, but not 
         * so cheap if we don't, and we'd prefer not to do that work while 
         * holding AsyncQueueLock. 
         */ 
</span>        <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="../../include/access/xact.h.html#LN333"><span class='Ref_to_Proto'>GetCurrentTransactionId</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Serialize writers by acquiring a special lock that we hold till 
         * after commit.  This ensures that queue entries appear in commit 
         * order, and in particular that there are never uncommitted queue 
         * entries ahead of committed ones, so an uncommitted transaction 
         * can't block delivery of deliverable notifications. 
         * 
         * We use a heavyweight lock so that it'll automatically be released 
         * after either commit or abort.  This also allows deadlocks to be 
         * detected, though really a deadlock shouldn't be possible here. 
         * 
         * The lock is on "database 0", which is pretty ugly but it doesn't 
         * seem worth inventing a special locktag category just for this. 
         * (Historical note: before PG 9.0, a similar lock on "database 0" was 
         * used by the flatfiles mechanism.) 
         */ 
</span>        <a href="../../include/storage/lmgr.h.html#LN93"><span class='Ref_to_Proto'>LockSharedObject</span></a><span class='Parentheses'>(</span><a href="../../include/catalog/pg_database.h.html#LN28"><span class='Ref_to_Const'>DatabaseRelationId</span></a><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, 
</span>                         <a href="../../include/storage/lockdefs.h.html#LN45"><span class='Ref_to_Const'>AccessExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Now push the notifications into the queue */ 
</span>        <a href="async.c.html#LN364"><span class='Ref_to_Global_Var'>backendHasSentNotifications</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
        <a href="async.c.html#LN803"><span class='Ref_To_Local'>nextNotify</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN344"><span class='Ref_to_Global_Var'>pendingNotifies</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="async.c.html#LN803"><span class='Ref_To_Local'>nextNotify</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Add the pending notifications to the queue.  We acquire and 
             * release AsyncQueueLock once per page, which might be overkill 
             * but it does allow readers to get in while we're doing this. 
             * 
             * A full queue is very uncommon and should really not happen, 
             * given that we have so much space available in the SLRU pages. 
             * Nevertheless we need to deal with this possibility. Note that 
             * when we get here we are in the process of committing our 
             * transaction, but we have not yet committed to clog, so at this 
             * point in time we can still roll the transaction back. 
             */ 
</span>            <a href="../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>AsyncQueueLock<span class='Delimiter'>, </span><a href="../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="async.c.html#LN384"><span class='Ref_to_Proto'>asyncQueueFillWarning</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN379"><span class='Ref_to_Proto'>asyncQueueIsFull</span></a><span class='Parentheses'>())</span> 
                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_PROGRAM_LIMIT_EXCEEDED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                      <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"too many notifications in the NOTIFY queue"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <a href="async.c.html#LN803"><span class='Ref_To_Local'>nextNotify</span></a> <span class='Operator'>= </span><a href="async.c.html#LN382"><span class='Ref_to_Proto'>asyncQueueAddEntries</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN803"><span class='Ref_To_Local'>nextNotify</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>AsyncQueueLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while nextNotify!=NULL &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if pendingNotifies &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end PreCommit_Notify &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * AtCommit_Notify 
 * 
 *      This is called at transaction commit, after committing to clog. 
 * 
 *      Update listenChannels and clear transaction-local state. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN870"></a><span class='Declare_Function'>AtCommit_Notify</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN872"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>p</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Allow transactions that have not executed LISTEN/UNLISTEN/NOTIFY to 
     * return as soon as possible 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="async.c.html#LN318"><span class='Ref_to_Global_Var'>pendingActions</span></a> <span class='Operator'>&& !</span><a href="async.c.html#LN344"><span class='Ref_to_Global_Var'>pendingNotifies</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN367"><span class='Ref_to_Global_Var'>Trace_notify</span></a><span class='Parentheses'>) 
</span>        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN24"><span class='Ref_to_Const'>DEBUG1</span></a><span class='Delimiter'>, </span><span class='String'>"AtCommit_Notify"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Perform any pending listen/unlisten actions */ 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN872"><span class='Ref_To_Local'>p</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN318"><span class='Ref_to_Global_Var'>pendingActions</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN887"></a>        <a href="async.c.html#LN312"><span class='Ref_to_Typedef'>ListenAction</span></a> <span class='Operator'>*</span><span class='Declare_Local'>actrec</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="async.c.html#LN312"><span class='Ref_to_Typedef'>ListenAction</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN872"><span class='Ref_To_Local'>p</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="async.c.html#LN887"><span class='Ref_To_Local'>actrec</span></a><span class='Operator'>-&GT;</span><a href="async.c.html#LN314"><span class='Ref_to_Member'>action</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>case</span> <a href="async.c.html#LN307"><span class='Ref_to_EnumConst'>LISTEN_LISTEN</span></a><span class='Operator'>: 
</span>                <a href="async.c.html#LN374"><span class='Ref_to_Proto'>Exec_ListenCommit</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN887"><span class='Ref_To_Local'>actrec</span></a><span class='Operator'>-&GT;</span><a href="async.c.html#LN315"><span class='Ref_to_Member'>channel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="async.c.html#LN308"><span class='Ref_to_EnumConst'>LISTEN_UNLISTEN</span></a><span class='Operator'>: 
</span>                <a href="async.c.html#LN375"><span class='Ref_to_Proto'>Exec_UnlistenCommit</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN887"><span class='Ref_To_Local'>actrec</span></a><span class='Operator'>-&GT;</span><a href="async.c.html#LN315"><span class='Ref_to_Member'>channel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="async.c.html#LN309"><span class='Ref_to_EnumConst'>LISTEN_UNLISTEN_ALL</span></a><span class='Operator'>: 
</span>                <a href="async.c.html#LN376"><span class='Ref_to_Proto'>Exec_UnlistenAllCommit</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* If no longer listening to anything, get out of listener array */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN361"><span class='Ref_to_Global_Var'>amRegisteredListener</span></a> <span class='Operator'>&& </span><a href="async.c.html#LN293"><span class='Ref_to_Global_Var'>listenChannels</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <a href="async.c.html#LN378"><span class='Ref_to_Proto'>asyncQueueUnregister</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* And clean up */ 
</span>    <a href="async.c.html#LN393"><span class='Ref_to_Proto'>ClearPendingActionsAndNotifies</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end AtCommit_Notify &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Exec_ListenPreCommit --- subroutine for PreCommit_Notify 
 * 
 * This function must make sure we are ready to catch any incoming messages. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN917"></a><span class='Declare_Function'>Exec_ListenPreCommit</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN919"></a>    <a href="async.c.html#LN181"><span class='Ref_to_Struct'>QueuePosition</span></a> <span class='Declare_Local'>head</span><span class='Delimiter'>; 
</span><a name="LN920"></a>    <a href="async.c.html#LN181"><span class='Ref_to_Struct'>QueuePosition</span></a> <span class='Declare_Local'>max</span><span class='Delimiter'>; 
</span><a name="LN921"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Nothing to do if we are already listening to something, nor if we 
     * already ran this routine in this transaction. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN361"><span class='Ref_to_Global_Var'>amRegisteredListener</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN367"><span class='Ref_to_Global_Var'>Trace_notify</span></a><span class='Parentheses'>) 
</span>        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN24"><span class='Ref_to_Const'>DEBUG1</span></a><span class='Delimiter'>, </span><span class='String'>"Exec_ListenPreCommit(%d)"</span><span class='Delimiter'>, </span><a href="../utils/init/globals.c.html#LN38"><span class='Ref_to_Global_Var'>MyProcPid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Before registering, make sure we will unlisten before dying. (Note: 
     * this action does not get undone if we abort later.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="async.c.html#LN358"><span class='Ref_to_Global_Var'>unlistenExitRegistered</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../include/storage/ipc.h.html#LN70"><span class='Ref_to_Proto'>before_shmem_exit</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN372"><span class='Ref_to_Proto'>Async_UnlistenOnExit</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="async.c.html#LN358"><span class='Ref_to_Global_Var'>unlistenExitRegistered</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * This is our first LISTEN, so establish our pointer. 
     * 
     * We set our pointer to the global tail pointer and then move it forward 
     * over already-committed notifications.  This ensures we cannot miss any 
     * not-yet-committed notifications.  We might get a few more but that 
     * doesn't hurt. 
     * 
     * In some scenarios there might be a lot of committed notifications that 
     * have not yet been pruned away (because some backend is being lazy about 
     * reading them).  To reduce our startup time, we can look at other 
     * backends and adopt the maximum "pos" pointer of any backend that's in 
     * our database; any notifications it's already advanced over are surely 
     * committed and need not be re-examined by us.  (We must consider only 
     * backends connected to our DB, because others will not have bothered to 
     * check committed-ness of notifications in our DB.)  But we only bother 
     * with that if there's more than a page worth of notifications 
     * outstanding, otherwise scanning all the other backends isn't worth it. 
     * 
     * We need exclusive lock here so we can look at other backends' entries. 
     */ 
</span>    <a href="../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>AsyncQueueLock<span class='Delimiter'>, </span><a href="../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="async.c.html#LN919"><span class='Ref_To_Local'>head</span></a> <span class='Operator'>= </span><a href="async.c.html#LN254"><span class='Ref_to_Const'>QUEUE_HEAD</span></a><span class='Delimiter'>; 
</span>    <a href="async.c.html#LN920"><span class='Ref_To_Local'>max</span></a> <span class='Operator'>= </span><a href="async.c.html#LN255"><span class='Ref_to_Const'>QUEUE_TAIL</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN187"><span class='Ref_to_Macro'>QUEUE_POS_PAGE</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN920"><span class='Ref_To_Local'>max</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><a href="async.c.html#LN187"><span class='Ref_to_Macro'>QUEUE_POS_PAGE</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN919"><span class='Ref_To_Local'>head</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="async.c.html#LN921"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="async.c.html#LN921"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT;= </span><a href="../utils/init/globals.c.html#LN126"><span class='Ref_to_Global_Var'>MaxBackends</span></a><span class='Delimiter'>; </span><a href="async.c.html#LN921"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN257"><span class='Ref_to_Macro'>QUEUE_BACKEND_DBOID</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN921"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="../utils/init/globals.c.html#LN76"><span class='Ref_to_Global_Var'>MyDatabaseId</span></a><span class='Parentheses'>)</span> 
                <a href="async.c.html#LN920"><span class='Ref_To_Local'>max</span></a> <span class='Operator'>= </span><a href="async.c.html#LN206"><span class='Ref_to_Macro'>QUEUE_POS_MAX</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN920"><span class='Ref_To_Local'>max</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN258"><span class='Ref_to_Macro'>QUEUE_BACKEND_POS</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN921"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span>    <a href="async.c.html#LN258"><span class='Ref_to_Macro'>QUEUE_BACKEND_POS</span></a><span class='Parentheses'>(</span><a href="../utils/init/globals.c.html#LN72"><span class='Ref_to_Global_Var'>MyBackendId</span></a><span class='Parentheses'>) </span><span class='Operator'>= </span><a href="async.c.html#LN920"><span class='Ref_To_Local'>max</span></a><span class='Delimiter'>; 
</span>    <a href="async.c.html#LN256"><span class='Ref_to_Macro'>QUEUE_BACKEND_PID</span></a><span class='Parentheses'>(</span><a href="../utils/init/globals.c.html#LN72"><span class='Ref_to_Global_Var'>MyBackendId</span></a><span class='Parentheses'>) </span><span class='Operator'>= </span><a href="../utils/init/globals.c.html#LN38"><span class='Ref_to_Global_Var'>MyProcPid</span></a><span class='Delimiter'>; 
</span>    <a href="async.c.html#LN257"><span class='Ref_to_Macro'>QUEUE_BACKEND_DBOID</span></a><span class='Parentheses'>(</span><a href="../utils/init/globals.c.html#LN72"><span class='Ref_to_Global_Var'>MyBackendId</span></a><span class='Parentheses'>) </span><span class='Operator'>= </span><a href="../utils/init/globals.c.html#LN76"><span class='Ref_to_Global_Var'>MyDatabaseId</span></a><span class='Delimiter'>; 
</span>    <a href="../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>AsyncQueueLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Now we are listed in the global array, so remember we're listening */ 
</span>    <a href="async.c.html#LN361"><span class='Ref_to_Global_Var'>amRegisteredListener</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Try to move our pointer forward as far as possible. This will skip over 
     * already-committed notifications. Still, we could get notifications that 
     * have already committed before we started to LISTEN. 
     * 
     * Note that we are not yet listening on anything, so we won't deliver any 
     * notification to the frontend. 
     * 
     * This will also advance the global tail pointer if possible. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="async.c.html#LN196"><span class='Ref_to_Macro'>QUEUE_POS_EQUAL</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN920"><span class='Ref_To_Local'>max</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN919"><span class='Ref_To_Local'>head</span></a><span class='Parentheses'>))</span> 
        <a href="async.c.html#LN386"><span class='Ref_to_Proto'>asyncQueueReadAllNotifications</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end Exec_ListenPreCommit &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Exec_ListenCommit --- subroutine for AtCommit_Notify 
 * 
 * Add the channel to the list of channels we are listening on. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1003"></a><span class='Declare_Function'>Exec_ListenCommit</span><span class='Parentheses'>(</span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>channel</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1005"></a>    <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldcontext</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Do nothing if we are already listening on this channel */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN377"><span class='Ref_to_Proto'>IsListeningOn</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1003"><span class='Ref_to_Parameter'>channel</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Add the new channel name to listenChannels. 
     * 
     * XXX It is theoretically possible to get an out-of-memory failure here, 
     * which would be bad because we already committed.  For the moment it 
     * doesn't seem worth trying to guard against that, but maybe improve this 
     * later. 
     */ 
</span>    <a href="async.c.html#LN1005"><span class='Ref_To_Local'>oldcontext</span></a> <span class='Operator'>= </span><a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="../utils/mmgr/mcxt.c.html#LN42"><span class='Ref_to_Global_Var'>TopMemoryContext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="async.c.html#LN293"><span class='Ref_to_Global_Var'>listenChannels</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN293"><span class='Ref_to_Global_Var'>listenChannels</span></a><span class='Delimiter'>, </span><a href="../../include/common/fe_memutils.h.html#LN32"><span class='Ref_to_Proto'>pstrdup</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1003"><span class='Ref_to_Parameter'>channel</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1005"><span class='Ref_To_Local'>oldcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end Exec_ListenCommit &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Exec_UnlistenCommit --- subroutine for AtCommit_Notify 
 * 
 * Remove the specified channel name from listenChannels. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1030"></a><span class='Declare_Function'>Exec_UnlistenCommit</span><span class='Parentheses'>(</span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>channel</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1032"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>q</span><span class='Delimiter'>; 
</span><a name="LN1033"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>prev</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN367"><span class='Ref_to_Global_Var'>Trace_notify</span></a><span class='Parentheses'>) 
</span>        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN24"><span class='Ref_to_Const'>DEBUG1</span></a><span class='Delimiter'>, </span><span class='String'>"Exec_UnlistenCommit(%s,%d)"</span><span class='Delimiter'>, </span><a href="async.c.html#LN1030"><span class='Ref_to_Parameter'>channel</span></a><span class='Delimiter'>, </span><a href="../utils/init/globals.c.html#LN38"><span class='Ref_to_Global_Var'>MyProcPid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="async.c.html#LN1033"><span class='Ref_To_Local'>prev</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1032"><span class='Ref_To_Local'>q</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN293"><span class='Ref_to_Global_Var'>listenChannels</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1041"></a>        <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>lchan</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1032"><span class='Ref_To_Local'>q</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span><a href="async.c.html#LN1041"><span class='Ref_To_Local'>lchan</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN1030"><span class='Ref_to_Parameter'>channel</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <a href="async.c.html#LN293"><span class='Ref_to_Global_Var'>listenChannels</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN238"><span class='Ref_to_Proto'>list_delete_cell</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN293"><span class='Ref_to_Global_Var'>listenChannels</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN1032"><span class='Ref_To_Local'>q</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN1033"><span class='Ref_To_Local'>prev</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1041"><span class='Ref_To_Local'>lchan</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <a href="async.c.html#LN1033"><span class='Ref_To_Local'>prev</span></a> <span class='Operator'>= </span><a href="async.c.html#LN1032"><span class='Ref_To_Local'>q</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We do not complain about unlistening something not being listened; 
     * should we? 
     */ 
</span><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end Exec_UnlistenCommit &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Exec_UnlistenAllCommit --- subroutine for AtCommit_Notify 
 * 
 *      Unlisten on all channels for this backend. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1064"></a><span class='Declare_Function'>Exec_UnlistenAllCommit</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN367"><span class='Ref_to_Global_Var'>Trace_notify</span></a><span class='Parentheses'>) 
</span>        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN24"><span class='Ref_to_Const'>DEBUG1</span></a><span class='Delimiter'>, </span><span class='String'>"Exec_UnlistenAllCommit(%d)"</span><span class='Delimiter'>, </span><a href="../utils/init/globals.c.html#LN38"><span class='Ref_to_Global_Var'>MyProcPid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN266"><span class='Ref_to_Proto'>list_free_deep</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN293"><span class='Ref_to_Global_Var'>listenChannels</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="async.c.html#LN293"><span class='Ref_to_Global_Var'>listenChannels</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * ProcessCompletedNotifies --- send out signals and self-notifies 
 * 
 * This is called from postgres.c just before going idle at the completion 
 * of a transaction.  If we issued any notifications in the just-completed 
 * transaction, send signals to other backends to process them, and also 
 * process the queue ourselves to send messages to our own frontend. 
 * 
 * The reason that this is not done in AtCommit_Notify is that there is 
 * a nonzero chance of errors here (for example, encoding conversion errors 
 * while trying to format messages to our frontend).  An error during 
 * AtCommit_Notify would be a PANIC condition.  The timing is also arranged 
 * to ensure that a transaction's self-notifies are delivered to the frontend 
 * before it gets the terminating ReadyForQuery message. 
 * 
 * Note that we send signals and process the queue even if the transaction 
 * eventually aborted.  This is because we need to clean out whatever got 
 * added to the queue. 
 * 
 * NOTE: we are outside of any transaction here. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1095"></a><span class='Declare_Function'>ProcessCompletedNotifies</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1097"></a>    <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>caller_context</span><span class='Delimiter'>; 
</span><a name="LN1098"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>signalled</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Nothing to do if we didn't send any notifications */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="async.c.html#LN364"><span class='Ref_to_Global_Var'>backendHasSentNotifications</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We reset the flag immediately; otherwise, if any sort of error occurs 
     * below, we'd be locked up in an infinite loop, because control will come 
     * right back here after error cleanup. 
     */ 
</span>    <a href="async.c.html#LN364"><span class='Ref_to_Global_Var'>backendHasSentNotifications</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We must preserve the caller's memory context (probably MessageContext) 
     * across the transaction we do here. 
     */ 
</span>    <a href="async.c.html#LN1097"><span class='Ref_To_Local'>caller_context</span></a> <span class='Operator'>= </span><a href="../utils/mmgr/mcxt.c.html#LN36"><span class='Ref_to_Global_Var'>CurrentMemoryContext</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN367"><span class='Ref_to_Global_Var'>Trace_notify</span></a><span class='Parentheses'>) 
</span>        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN24"><span class='Ref_to_Const'>DEBUG1</span></a><span class='Delimiter'>, </span><span class='String'>"ProcessCompletedNotifies"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We must run asyncQueueReadAllNotifications inside a transaction, else 
     * bad things happen if it gets an error. 
     */ 
</span>    <a href="../../include/access/xact.h.html#LN348"><span class='Ref_to_Proto'>StartTransactionCommand</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Send signals to other backends */ 
</span>    <a href="async.c.html#LN1098"><span class='Ref_To_Local'>signalled</span></a> <span class='Operator'>= </span><a href="async.c.html#LN385"><span class='Ref_to_Proto'>SignalBackends</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN293"><span class='Ref_to_Global_Var'>listenChannels</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Read the queue ourselves, and send relevant stuff to the frontend */ 
</span>        <a href="async.c.html#LN386"><span class='Ref_to_Proto'>asyncQueueReadAllNotifications</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="async.c.html#LN1098"><span class='Ref_To_Local'>signalled</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * If we found no other listening backends, and we aren't listening 
         * ourselves, then we must execute asyncQueueAdvanceTail to flush the 
         * queue, because ain't nobody else gonna do it.  This prevents queue 
         * overflow when we're sending useless notifies to nobody. (A new 
         * listener could have joined since we looked, but if so this is 
         * harmless.) 
         */ 
</span>        <a href="async.c.html#LN390"><span class='Ref_to_Proto'>asyncQueueAdvanceTail</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../include/access/xact.h.html#LN349"><span class='Ref_to_Proto'>CommitTransactionCommand</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1097"><span class='Ref_To_Local'>caller_context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* We don't need pq_flush() here since postgres.c will do one shortly */ 
</span><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end ProcessCompletedNotifies &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Test whether we are actively listening on the given channel name. 
 * 
 * Note: this function is executed for every notification found in the queue. 
 * Perhaps it is worth further optimization, eg convert the list to a sorted 
 * array so we can binary-search it.  In practice the list is likely to be 
 * fairly short, though. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN1163"></a><span class='Declare_Function'>IsListeningOn</span><span class='Parentheses'>(</span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>channel</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1165"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>p</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1165"><span class='Ref_To_Local'>p</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN293"><span class='Ref_to_Global_Var'>listenChannels</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1169"></a>        <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>lchan</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1165"><span class='Ref_To_Local'>p</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span><a href="async.c.html#LN1169"><span class='Ref_To_Local'>lchan</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN1163"><span class='Ref_to_Parameter'>channel</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Remove our entry from the listeners array when we are no longer listening 
 * on any channel.  NB: must not fail if we're already not listening. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1182"></a><span class='Declare_Function'>asyncQueueUnregister</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1184"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>advanceTail</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="async.c.html#LN293"><span class='Ref_to_Global_Var'>listenChannels</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* else caller error */ 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="async.c.html#LN361"><span class='Ref_to_Global_Var'>amRegisteredListener</span></a><span class='Parentheses'>)</span>  <span class='Comment_Single_Line'>/* nothing to do */ 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>AsyncQueueLock<span class='Delimiter'>, </span><a href="../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* check if entry is valid and oldest ... */ 
</span>    <a href="async.c.html#LN1184"><span class='Ref_To_Local'>advanceTail</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../utils/init/globals.c.html#LN38"><span class='Ref_to_Global_Var'>MyProcPid</span></a> <span class='Operator'>== </span><a href="async.c.html#LN256"><span class='Ref_to_Macro'>QUEUE_BACKEND_PID</span></a><span class='Parentheses'>(</span><a href="../utils/init/globals.c.html#LN72"><span class='Ref_to_Global_Var'>MyBackendId</span></a><span class='Parentheses'>))</span> <span class='Operator'>&& 
</span>        <a href="async.c.html#LN196"><span class='Ref_to_Macro'>QUEUE_POS_EQUAL</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN258"><span class='Ref_to_Macro'>QUEUE_BACKEND_POS</span></a><span class='Parentheses'>(</span><a href="../utils/init/globals.c.html#LN72"><span class='Ref_to_Global_Var'>MyBackendId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="async.c.html#LN255"><span class='Ref_to_Const'>QUEUE_TAIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* ... then mark it invalid */ 
</span>    <a href="async.c.html#LN256"><span class='Ref_to_Macro'>QUEUE_BACKEND_PID</span></a><span class='Parentheses'>(</span><a href="../utils/init/globals.c.html#LN72"><span class='Ref_to_Global_Var'>MyBackendId</span></a><span class='Parentheses'>) </span><span class='Operator'>= </span><a href="../../include/miscadmin.h.html#LN32"><span class='Ref_to_Const'>InvalidPid</span></a><span class='Delimiter'>; 
</span>    <a href="async.c.html#LN257"><span class='Ref_to_Macro'>QUEUE_BACKEND_DBOID</span></a><span class='Parentheses'>(</span><a href="../utils/init/globals.c.html#LN72"><span class='Ref_to_Global_Var'>MyBackendId</span></a><span class='Parentheses'>) </span><span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>    <a href="../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>AsyncQueueLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* mark ourselves as no longer listed in the global array */ 
</span>    <a href="async.c.html#LN361"><span class='Ref_to_Global_Var'>amRegisteredListener</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* If we were the laziest backend, try to advance the tail pointer */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN1184"><span class='Ref_To_Local'>advanceTail</span></a><span class='Parentheses'>) 
</span>        <a href="async.c.html#LN390"><span class='Ref_to_Proto'>asyncQueueAdvanceTail</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end asyncQueueUnregister &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Test whether there is room to insert more notification messages. 
 * 
 * Caller must hold at least shared AsyncQueueLock. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN1214"></a><span class='Declare_Function'>asyncQueueIsFull</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1216"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>nexthead</span><span class='Delimiter'>; 
</span><a name="LN1217"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>boundary</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * The queue is full if creating a new head page would create a page that 
     * logically precedes the current global tail pointer, ie, the head 
     * pointer would wrap around compared to the tail.  We cannot create such 
     * a head page for fear of confusing slru.c.  For safety we round the tail 
     * pointer back to a segment boundary (compare the truncation logic in 
     * asyncQueueAdvanceTail). 
     * 
     * Note that this test is *not* dependent on how much space there is on 
     * the current head page.  This is necessary because asyncQueueAddEntries 
     * might try to create the next head page in any case. 
     */ 
</span>    <a href="async.c.html#LN1216"><span class='Ref_To_Local'>nexthead</span></a> <span class='Operator'>= </span><a href="async.c.html#LN187"><span class='Ref_to_Macro'>QUEUE_POS_PAGE</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN254"><span class='Ref_to_Const'>QUEUE_HEAD</span></a><span class='Parentheses'>) </span><span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN1216"><span class='Ref_To_Local'>nexthead</span></a> <span class='Operator'>&GT; </span><a href="async.c.html#LN286"><span class='Ref_to_Const'>QUEUE_MAX_PAGE</span></a><span class='Parentheses'>) 
</span>        <a href="async.c.html#LN1216"><span class='Ref_To_Local'>nexthead</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* wrap around */ 
</span>    <a href="async.c.html#LN1217"><span class='Ref_To_Local'>boundary</span></a> <span class='Operator'>= </span><a href="async.c.html#LN187"><span class='Ref_to_Macro'>QUEUE_POS_PAGE</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN255"><span class='Ref_to_Const'>QUEUE_TAIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="async.c.html#LN1217"><span class='Ref_To_Local'>boundary</span></a> <span class='Operator'>-= </span><a href="async.c.html#LN1217"><span class='Ref_To_Local'>boundary</span></a> <span class='Operator'>% </span><a href="../../include/access/slru.h.html#LN36"><span class='Ref_to_Const'>SLRU_PAGES_PER_SEGMENT</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="async.c.html#LN370"><span class='Ref_to_Proto'>asyncQueuePagePrecedes</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1216"><span class='Ref_To_Local'>nexthead</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN1217"><span class='Ref_To_Local'>boundary</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end asyncQueueIsFull &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Advance the QueuePosition to the next entry, assuming that the current 
 * entry is of length entryLength.  If we jump to a new page the function 
 * returns true, else false. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN1245"></a><span class='Declare_Function'>asyncQueueAdvance</span><span class='Parentheses'>(</span><span class='Keyword'>volatile </span><a href="async.c.html#LN181"><span class='Ref_to_Struct'>QueuePosition</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>position</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>entryLength</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1247"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>pageno</span> <span class='Operator'>= </span><a href="async.c.html#LN187"><span class='Ref_to_Macro'>QUEUE_POS_PAGE</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="async.c.html#LN1245"><span class='Ref_to_Parameter'>position</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1248"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>offset</span> <span class='Operator'>= </span><a href="async.c.html#LN188"><span class='Ref_to_Macro'>QUEUE_POS_OFFSET</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="async.c.html#LN1245"><span class='Ref_to_Parameter'>position</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1249"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>pageJump</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Move to the next writing position: First jump over what we have just 
     * written or read. 
     */ 
</span>    <a href="async.c.html#LN1248"><span class='Ref_To_Local'>offset</span></a> <span class='Operator'>+= </span><a href="async.c.html#LN1245"><span class='Ref_to_Parameter'>entryLength</span></a><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="async.c.html#LN1248"><span class='Ref_To_Local'>offset</span></a> <span class='Operator'>&LT;= </span><a href="async.c.html#LN266"><span class='Ref_to_Const'>QUEUE_PAGESIZE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * In a second step check if another entry can possibly be written to the 
     * page. If so, stay here, we have reached the next position. If not, then 
     * we need to move on to the next page. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN1248"><span class='Ref_To_Local'>offset</span></a> <span class='Operator'>+ </span><a href="async.c.html#LN174"><span class='Ref_to_Macro'>QUEUEALIGN</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN176"><span class='Ref_to_Const'>AsyncQueueEntryEmptySize</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT; </span><a href="async.c.html#LN266"><span class='Ref_to_Const'>QUEUE_PAGESIZE</span></a><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <a href="async.c.html#LN1247"><span class='Ref_To_Local'>pageno</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN1247"><span class='Ref_To_Local'>pageno</span></a> <span class='Operator'>&GT; </span><a href="async.c.html#LN286"><span class='Ref_to_Const'>QUEUE_MAX_PAGE</span></a><span class='Parentheses'>) 
</span>            <a href="async.c.html#LN1247"><span class='Ref_To_Local'>pageno</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* wrap around */ 
</span>        <a href="async.c.html#LN1248"><span class='Ref_To_Local'>offset</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="async.c.html#LN1249"><span class='Ref_To_Local'>pageJump</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="async.c.html#LN190"><span class='Ref_to_Macro'>SET_QUEUE_POS</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="async.c.html#LN1245"><span class='Ref_to_Parameter'>position</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN1247"><span class='Ref_To_Local'>pageno</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN1248"><span class='Ref_To_Local'>offset</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="async.c.html#LN1249"><span class='Ref_To_Local'>pageJump</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end asyncQueueAdvance &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Fill the AsyncQueueEntry at *qe with an outbound notification message. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1280"></a><span class='Declare_Function'>asyncQueueNotificationToEntry</span><span class='Parentheses'>(</span><a href="async.c.html#LN338"><span class='Ref_to_Struct'>Notification</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>n</span><span class='Delimiter'>, </span><a href="async.c.html#LN164"><span class='Ref_to_Struct'>AsyncQueueEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>qe</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1282"></a>    size_t      <span class='Declare_Local'>channellen</span> <span class='Operator'>= </span>strlen<span class='Parentheses'>(</span><a href="async.c.html#LN1280"><span class='Ref_to_Parameter'>n</span></a><span class='Operator'>-&GT;</span><a href="async.c.html#LN340"><span class='Ref_to_Member'>channel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1283"></a>    size_t      <span class='Declare_Local'>payloadlen</span> <span class='Operator'>= </span>strlen<span class='Parentheses'>(</span><a href="async.c.html#LN1280"><span class='Ref_to_Parameter'>n</span></a><span class='Operator'>-&GT;</span><a href="async.c.html#LN341"><span class='Ref_to_Member'>payload</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1284"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>entryLength</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="async.c.html#LN1282"><span class='Ref_To_Local'>channellen</span></a> <span class='Operator'>&LT; </span><a href="../../interfaces/ecpg/include/sqlda-native.h.html#LN15"><span class='Ref_to_Const'>NAMEDATALEN</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="async.c.html#LN1283"><span class='Ref_To_Local'>payloadlen</span></a> <span class='Operator'>&LT; </span><a href="async.c.html#LN150"><span class='Ref_to_Const'>NOTIFY_PAYLOAD_MAX_LENGTH</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* The terminators are already included in AsyncQueueEntryEmptySize */ 
</span>    <a href="async.c.html#LN1284"><span class='Ref_To_Local'>entryLength</span></a> <span class='Operator'>= </span><a href="async.c.html#LN176"><span class='Ref_to_Const'>AsyncQueueEntryEmptySize</span></a> <span class='Operator'>+ </span><a href="async.c.html#LN1283"><span class='Ref_To_Local'>payloadlen</span></a> <span class='Operator'>+ </span><a href="async.c.html#LN1282"><span class='Ref_To_Local'>channellen</span></a><span class='Delimiter'>; 
</span>    <a href="async.c.html#LN1284"><span class='Ref_To_Local'>entryLength</span></a> <span class='Operator'>= </span><a href="async.c.html#LN174"><span class='Ref_to_Macro'>QUEUEALIGN</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1284"><span class='Ref_To_Local'>entryLength</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="async.c.html#LN1280"><span class='Ref_to_Parameter'>qe</span></a><span class='Operator'>-&GT;</span><a href="async.c.html#LN166"><span class='Ref_to_Member'>length</span></a> <span class='Operator'>= </span><a href="async.c.html#LN1284"><span class='Ref_To_Local'>entryLength</span></a><span class='Delimiter'>; 
</span>    <a href="async.c.html#LN1280"><span class='Ref_to_Parameter'>qe</span></a><span class='Operator'>-&GT;</span><a href="async.c.html#LN167"><span class='Ref_to_Member'>dboid</span></a> <span class='Operator'>= </span><a href="../utils/init/globals.c.html#LN76"><span class='Ref_to_Global_Var'>MyDatabaseId</span></a><span class='Delimiter'>; 
</span>    <a href="async.c.html#LN1280"><span class='Ref_to_Parameter'>qe</span></a><span class='Operator'>-&GT;</span><a href="async.c.html#LN168"><span class='Ref_to_Member'>xid</span></a> <span class='Operator'>= </span><a href="../../include/access/xact.h.html#LN333"><span class='Ref_to_Proto'>GetCurrentTransactionId</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="async.c.html#LN1280"><span class='Ref_to_Parameter'>qe</span></a><span class='Operator'>-&GT;</span><a href="async.c.html#LN169"><span class='Ref_to_Member'>srcPid</span></a> <span class='Operator'>= </span><a href="../utils/init/globals.c.html#LN38"><span class='Ref_to_Global_Var'>MyProcPid</span></a><span class='Delimiter'>; 
</span>    memcpy<span class='Parentheses'>(</span><a href="async.c.html#LN1280"><span class='Ref_to_Parameter'>qe</span></a><span class='Operator'>-&GT;</span><a href="async.c.html#LN170"><span class='Ref_to_Member'>data</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN1280"><span class='Ref_to_Parameter'>n</span></a><span class='Operator'>-&GT;</span><a href="async.c.html#LN340"><span class='Ref_to_Member'>channel</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN1282"><span class='Ref_To_Local'>channellen</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    memcpy<span class='Parentheses'>(</span><a href="async.c.html#LN1280"><span class='Ref_to_Parameter'>qe</span></a><span class='Operator'>-&GT;</span><a href="async.c.html#LN170"><span class='Ref_to_Member'>data</span></a> <span class='Operator'>+ </span><a href="async.c.html#LN1282"><span class='Ref_To_Local'>channellen</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>, </span><a href="async.c.html#LN1280"><span class='Ref_to_Parameter'>n</span></a><span class='Operator'>-&GT;</span><a href="async.c.html#LN341"><span class='Ref_to_Member'>payload</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN1283"><span class='Ref_To_Local'>payloadlen</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end asyncQueueNotificationToEntry &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Add pending notifications to the queue. 
 * 
 * We go page by page here, i.e. we stop once we have to go to a new page but 
 * we will be called again and then fill that next page. If an entry does not 
 * fit into the current page, we write a dummy entry with an InvalidOid as the 
 * database OID in order to fill the page. So every page is always used up to 
 * the last byte which simplifies reading the page later. 
 * 
 * We are passed the list cell containing the next notification to write 
 * and return the first still-unwritten cell back.  Eventually we will return 
 * NULL indicating all is done. 
 * 
 * We are holding AsyncQueueLock already from the caller and grab AsyncCtlLock 
 * locally in this function. 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a> <span class='Operator'>* 
</span><a name="LN1317"></a><span class='Declare_Function'>asyncQueueAddEntries</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>nextNotify</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1319"></a>    <a href="async.c.html#LN164"><span class='Ref_to_Struct'>AsyncQueueEntry</span></a> <span class='Declare_Local'>qe</span><span class='Delimiter'>; 
</span><a name="LN1320"></a>    <a href="async.c.html#LN181"><span class='Ref_to_Struct'>QueuePosition</span></a> <span class='Declare_Local'>queue_head</span><span class='Delimiter'>; 
</span><a name="LN1321"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>pageno</span><span class='Delimiter'>; 
</span><a name="LN1322"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>offset</span><span class='Delimiter'>; 
</span><a name="LN1323"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>slotno</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* We hold both AsyncQueueLock and AsyncCtlLock during this operation */ 
</span>    <a href="../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>AsyncCtlLock<span class='Delimiter'>, </span><a href="../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We work with a local copy of QUEUE_HEAD, which we write back to shared 
     * memory upon exiting.  The reason for this is that if we have to advance 
     * to a new page, SimpleLruZeroPage might fail (out of disk space, for 
     * instance), and we must not advance QUEUE_HEAD if it does.  (Otherwise, 
     * subsequent insertions would try to put entries into a page that slru.c 
     * thinks doesn't exist yet.)  So, use a local position variable.  Note 
     * that if we do fail, any already-inserted queue entries are forgotten; 
     * this is okay, since they'd be useless anyway after our transaction 
     * rolls back. 
     */ 
</span>    <a href="async.c.html#LN1320"><span class='Ref_To_Local'>queue_head</span></a> <span class='Operator'>= </span><a href="async.c.html#LN254"><span class='Ref_to_Const'>QUEUE_HEAD</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Fetch the current page */ 
</span>    <a href="async.c.html#LN1321"><span class='Ref_To_Local'>pageno</span></a> <span class='Operator'>= </span><a href="async.c.html#LN187"><span class='Ref_to_Macro'>QUEUE_POS_PAGE</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1320"><span class='Ref_To_Local'>queue_head</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="async.c.html#LN1323"><span class='Ref_To_Local'>slotno</span></a> <span class='Operator'>= </span><a href="../../include/access/slru.h.html#LN147"><span class='Ref_to_Proto'>SimpleLruReadPage</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN265"><span class='Ref_to_Const'>AsyncCtl</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN1321"><span class='Ref_To_Local'>pageno</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, </span><a href="../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* Note we mark the page dirty before writing in it */ 
</span>    <a href="async.c.html#LN265"><span class='Ref_to_Const'>AsyncCtl</span></a><span class='Operator'>-&GT;</span>shared<span class='Operator'>-&GT;</span>page_dirty<span class='Delimiter'>[</span><a href="async.c.html#LN1323"><span class='Ref_To_Local'>slotno</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="async.c.html#LN1317"><span class='Ref_to_Parameter'>nextNotify</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1349"></a>        <a href="async.c.html#LN338"><span class='Ref_to_Struct'>Notification</span></a> <span class='Operator'>*</span><span class='Declare_Local'>n</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="async.c.html#LN338"><span class='Ref_to_Struct'>Notification</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1317"><span class='Ref_to_Parameter'>nextNotify</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Construct a valid queue entry in local variable qe */ 
</span>        <a href="async.c.html#LN381"><span class='Ref_to_Proto'>asyncQueueNotificationToEntry</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1349"><span class='Ref_To_Local'>n</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="async.c.html#LN1319"><span class='Ref_To_Local'>qe</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="async.c.html#LN1322"><span class='Ref_To_Local'>offset</span></a> <span class='Operator'>= </span><a href="async.c.html#LN188"><span class='Ref_to_Macro'>QUEUE_POS_OFFSET</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1320"><span class='Ref_To_Local'>queue_head</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Check whether the entry really fits on the current page */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN1322"><span class='Ref_To_Local'>offset</span></a> <span class='Operator'>+ </span><a href="async.c.html#LN1319"><span class='Ref_To_Local'>qe</span></a><span class='Operator'>.</span><a href="async.c.html#LN166"><span class='Ref_to_Member'>length</span></a> <span class='Operator'>&LT;= </span><a href="async.c.html#LN266"><span class='Ref_to_Const'>QUEUE_PAGESIZE</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* OK, so advance nextNotify past this item */ 
</span>            <a href="async.c.html#LN1317"><span class='Ref_to_Parameter'>nextNotify</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1317"><span class='Ref_to_Parameter'>nextNotify</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Write a dummy entry to fill up the page. Actually readers will 
             * only check dboid and since it won't match any reader's database 
             * OID, they will ignore this entry and move on. 
             */ 
</span>            <a href="async.c.html#LN1319"><span class='Ref_To_Local'>qe</span></a><span class='Operator'>.</span><a href="async.c.html#LN166"><span class='Ref_to_Member'>length</span></a> <span class='Operator'>= </span><a href="async.c.html#LN266"><span class='Ref_to_Const'>QUEUE_PAGESIZE</span></a> <span class='Operator'>- </span><a href="async.c.html#LN1322"><span class='Ref_To_Local'>offset</span></a><span class='Delimiter'>; 
</span>            <a href="async.c.html#LN1319"><span class='Ref_To_Local'>qe</span></a><span class='Operator'>.</span><a href="async.c.html#LN167"><span class='Ref_to_Member'>dboid</span></a> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>            <a href="async.c.html#LN1319"><span class='Ref_To_Local'>qe</span></a><span class='Operator'>.</span><a href="async.c.html#LN170"><span class='Ref_to_Member'>data</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='String'>'\0'</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* empty channel */ 
</span>            <a href="async.c.html#LN1319"><span class='Ref_To_Local'>qe</span></a><span class='Operator'>.</span><a href="async.c.html#LN170"><span class='Ref_to_Member'>data</span></a><span class='Delimiter'>[</span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='String'>'\0'</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* empty payload */ 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* Now copy qe into the shared buffer page */ 
</span>        memcpy<span class='Parentheses'>(</span><a href="async.c.html#LN265"><span class='Ref_to_Const'>AsyncCtl</span></a><span class='Operator'>-&GT;</span>shared<span class='Operator'>-&GT;</span>page_buffer<span class='Delimiter'>[</span><a href="async.c.html#LN1323"><span class='Ref_To_Local'>slotno</span></a><span class='Delimiter'>] </span><span class='Operator'>+ </span><a href="async.c.html#LN1322"><span class='Ref_To_Local'>offset</span></a><span class='Delimiter'>, 
</span>               <span class='Operator'>&</span><a href="async.c.html#LN1319"><span class='Ref_To_Local'>qe</span></a><span class='Delimiter'>, 
</span>               <a href="async.c.html#LN1319"><span class='Ref_To_Local'>qe</span></a><span class='Operator'>.</span><a href="async.c.html#LN166"><span class='Ref_to_Member'>length</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Advance queue_head appropriately, and detect if page is full */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN380"><span class='Ref_to_Proto'>asyncQueueAdvance</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="async.c.html#LN1320"><span class='Ref_To_Local'>queue_head</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="async.c.html#LN1319"><span class='Ref_To_Local'>qe</span></a><span class='Operator'>.</span><a href="async.c.html#LN166"><span class='Ref_to_Member'>length</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Page is full, so we're done here, but first fill the next page 
             * with zeroes.  The reason to do this is to ensure that slru.c's 
             * idea of the head page is always the same as ours, which avoids 
             * boundary problems in SimpleLruTruncate.  The test in 
             * asyncQueueIsFull() ensured that there is room to create this 
             * page without overrunning the queue. 
             */ 
</span>            <a href="async.c.html#LN1323"><span class='Ref_To_Local'>slotno</span></a> <span class='Operator'>= </span><a href="../../include/access/slru.h.html#LN146"><span class='Ref_to_Proto'>SimpleLruZeroPage</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN265"><span class='Ref_to_Const'>AsyncCtl</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN187"><span class='Ref_to_Macro'>QUEUE_POS_PAGE</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1320"><span class='Ref_To_Local'>queue_head</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* And exit the loop */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while nextNotify!=NULL &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* Success, so update the global QUEUE_HEAD */ 
</span>    <a href="async.c.html#LN254"><span class='Ref_to_Const'>QUEUE_HEAD</span></a> <span class='Operator'>= </span><a href="async.c.html#LN1320"><span class='Ref_To_Local'>queue_head</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>AsyncCtlLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="async.c.html#LN1317"><span class='Ref_to_Parameter'>nextNotify</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end asyncQueueAddEntries &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * SQL function to return the fraction of the notification queue currently 
 * occupied. 
 */ 
</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN1410"></a><span class='Declare_Function'>pg_notification_queue_usage</span><span class='Parentheses'>(</span><a href="../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1412"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>usage</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>AsyncQueueLock<span class='Delimiter'>, </span><a href="../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="async.c.html#LN1412"><span class='Ref_To_Local'>usage</span></a> <span class='Operator'>= </span><a href="async.c.html#LN383"><span class='Ref_to_Proto'>asyncQueueUsage</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>AsyncQueueLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/fmgr.h.html#LN325"><span class='Ref_to_Macro'>PG_RETURN_FLOAT8</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1412"><span class='Ref_To_Local'>usage</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Return the fraction of the queue that is currently occupied. 
 * 
 * The caller must hold AsyncQueueLock in (at least) shared mode. 
 */ 
</span><span class='Keyword'>static double 
</span><a name="LN1427"></a><span class='Declare_Function'>asyncQueueUsage</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1429"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>headPage</span> <span class='Operator'>= </span><a href="async.c.html#LN187"><span class='Ref_to_Macro'>QUEUE_POS_PAGE</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN254"><span class='Ref_to_Const'>QUEUE_HEAD</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1430"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>tailPage</span> <span class='Operator'>= </span><a href="async.c.html#LN187"><span class='Ref_to_Macro'>QUEUE_POS_PAGE</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN255"><span class='Ref_to_Const'>QUEUE_TAIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1431"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>occupied</span><span class='Delimiter'>; 
</span> 
    <a href="async.c.html#LN1431"><span class='Ref_To_Local'>occupied</span></a> <span class='Operator'>= </span><a href="async.c.html#LN1429"><span class='Ref_To_Local'>headPage</span></a> <span class='Operator'>- </span><a href="async.c.html#LN1430"><span class='Ref_To_Local'>tailPage</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN1431"><span class='Ref_To_Local'>occupied</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* fast exit for common case */ 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN1431"><span class='Ref_To_Local'>occupied</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* head has wrapped around, tail not yet */ 
</span>        <a href="async.c.html#LN1431"><span class='Ref_To_Local'>occupied</span></a> <span class='Operator'>+= </span><a href="async.c.html#LN286"><span class='Ref_to_Const'>QUEUE_MAX_PAGE</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="async.c.html#LN1431"><span class='Ref_To_Local'>occupied</span></a> <span class='Operator'>/ </span><span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) ((</span><a href="async.c.html#LN286"><span class='Ref_to_Const'>QUEUE_MAX_PAGE</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>) </span><span class='Operator'>/ </span><span class='Number'>2</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end asyncQueueUsage &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Check whether the queue is at least half full, and emit a warning if so. 
 * 
 * This is unlikely given the size of the queue, but possible. 
 * The warnings show up at most once every QUEUE_FULL_WARN_INTERVAL. 
 * 
 * Caller must hold exclusive AsyncQueueLock. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1456"></a><span class='Declare_Function'>asyncQueueFillWarning</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1458"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>fillDegree</span><span class='Delimiter'>; 
</span><a name="LN1459"></a>    <a href="../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <span class='Declare_Local'>t</span><span class='Delimiter'>; 
</span> 
    <a href="async.c.html#LN1458"><span class='Ref_To_Local'>fillDegree</span></a> <span class='Operator'>= </span><a href="async.c.html#LN383"><span class='Ref_to_Proto'>asyncQueueUsage</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN1458"><span class='Ref_To_Local'>fillDegree</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>5</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <a href="async.c.html#LN1459"><span class='Ref_To_Local'>t</span></a> <span class='Operator'>= </span><a href="../../include/utils/timestamp.h.html#LN69"><span class='Ref_to_Proto'>GetCurrentTimestamp</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/utils/timestamp.h.html#LN74"><span class='Ref_to_Proto'>TimestampDifferenceExceeds</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN252"><span class='Ref_to_Global_Var'>asyncQueueControl</span></a><span class='Operator'>-&GT;</span><a href="async.c.html#LN247"><span class='Ref_to_Member'>lastQueueFillWarn</span></a><span class='Delimiter'>, 
</span>                                   <a href="async.c.html#LN1459"><span class='Ref_To_Local'>t</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN267"><span class='Ref_to_Const'>QUEUE_FULL_WARN_INTERVAL</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1470"></a>        <a href="async.c.html#LN181"><span class='Ref_to_Struct'>QueuePosition</span></a> <span class='Declare_Local'>min</span> <span class='Operator'>= </span><a href="async.c.html#LN254"><span class='Ref_to_Const'>QUEUE_HEAD</span></a><span class='Delimiter'>; 
</span><a name="LN1471"></a>        <a href="../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Local'>minPid</span> <span class='Operator'>= </span><a href="../../include/miscadmin.h.html#LN32"><span class='Ref_to_Const'>InvalidPid</span></a><span class='Delimiter'>; 
</span><a name="LN1472"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="async.c.html#LN1472"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="async.c.html#LN1472"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT;= </span><a href="../utils/init/globals.c.html#LN126"><span class='Ref_to_Global_Var'>MaxBackends</span></a><span class='Delimiter'>; </span><a href="async.c.html#LN1472"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN256"><span class='Ref_to_Macro'>QUEUE_BACKEND_PID</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1472"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><a href="../../include/miscadmin.h.html#LN32"><span class='Ref_to_Const'>InvalidPid</span></a><span class='Parentheses'>)</span> 
            <span class='Delimiter'>{ 
</span>                <a href="async.c.html#LN1470"><span class='Ref_To_Local'>min</span></a> <span class='Operator'>= </span><a href="async.c.html#LN200"><span class='Ref_to_Macro'>QUEUE_POS_MIN</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1470"><span class='Ref_To_Local'>min</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN258"><span class='Ref_to_Macro'>QUEUE_BACKEND_POS</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1472"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN196"><span class='Ref_to_Macro'>QUEUE_POS_EQUAL</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1470"><span class='Ref_To_Local'>min</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN258"><span class='Ref_to_Macro'>QUEUE_BACKEND_POS</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1472"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>)))</span> 
                    <a href="async.c.html#LN1471"><span class='Ref_To_Local'>minPid</span></a> <span class='Operator'>= </span><a href="async.c.html#LN256"><span class='Ref_to_Macro'>QUEUE_BACKEND_PID</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1472"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN39"><span class='Ref_to_Const'>WARNING</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"NOTIFY queue is %.0f%% full"</span><span class='Delimiter'>, </span><a href="async.c.html#LN1458"><span class='Ref_To_Local'>fillDegree</span></a> <span class='Operator'>* </span><span class='Number'>100</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <span class='Parentheses'>(</span><a href="async.c.html#LN1471"><span class='Ref_To_Local'>minPid</span></a> <span class='Operator'>!= </span><a href="../../include/miscadmin.h.html#LN32"><span class='Ref_to_Const'>InvalidPid</span></a> <span class='Operator'>? 
</span>                  <a href="../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"The server process with PID %d is among those with the oldest transactions."</span><span class='Delimiter'>, </span><a href="async.c.html#LN1471"><span class='Ref_To_Local'>minPid</span></a><span class='Parentheses'>) 
</span>                  <span class='Operator'>: </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <span class='Parentheses'>(</span><a href="async.c.html#LN1471"><span class='Ref_To_Local'>minPid</span></a> <span class='Operator'>!= </span><a href="../../include/miscadmin.h.html#LN32"><span class='Ref_to_Const'>InvalidPid</span></a> <span class='Operator'>? 
</span>                  <a href="../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"The NOTIFY queue cannot be emptied until that process ends its current transaction."</span><span class='Parentheses'>) 
</span>                  <span class='Operator'>: </span><span class='Number'>0</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <a href="async.c.html#LN252"><span class='Ref_to_Global_Var'>asyncQueueControl</span></a><span class='Operator'>-&GT;</span><a href="async.c.html#LN247"><span class='Ref_to_Member'>lastQueueFillWarn</span></a> <span class='Operator'>= </span><a href="async.c.html#LN1459"><span class='Ref_To_Local'>t</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if TimestampDifferenceEx... &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end asyncQueueFillWarning &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Send signals to all listening backends (except our own). 
 * 
 * Returns true if we sent at least one signal. 
 * 
 * Since we need EXCLUSIVE lock anyway we also check the position of the other 
 * backends and in case one is already up-to-date we don't signal it. 
 * This can happen if concurrent notifying transactions have sent a signal and 
 * the signaled backend has read the other notifications and ours in the same 
 * step. 
 * 
 * Since we know the BackendId and the Pid the signalling is quite cheap. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN1511"></a><span class='Declare_Function'>SignalBackends</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1513"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>signalled</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN1514"></a>    <a href="../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>pids</span><span class='Delimiter'>; 
</span><a name="LN1515"></a>    <a href="../../include/storage/backendid.h.html#LN20"><span class='Ref_to_Typedef'>BackendId</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>ids</span><span class='Delimiter'>; 
</span><a name="LN1516"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>count</span><span class='Delimiter'>; 
</span><a name="LN1517"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN1518"></a>    <a href="../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Local'>pid</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Identify all backends that are listening and not already up-to-date. We 
     * don't want to send signals while holding the AsyncQueueLock, so we just 
     * build a list of target PIDs. 
     * 
     * XXX in principle these pallocs could fail, which would be bad. Maybe 
     * preallocate the arrays?  But in practice this is only run in trivial 
     * transactions, so there should surely be space available. 
     */ 
</span>    <a href="async.c.html#LN1514"><span class='Ref_To_Local'>pids</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="../utils/init/globals.c.html#LN126"><span class='Ref_to_Global_Var'>MaxBackends</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="async.c.html#LN1515"><span class='Ref_To_Local'>ids</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/storage/backendid.h.html#LN20"><span class='Ref_to_Typedef'>BackendId</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="../utils/init/globals.c.html#LN126"><span class='Ref_to_Global_Var'>MaxBackends</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/storage/backendid.h.html#LN20"><span class='Ref_to_Typedef'>BackendId</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="async.c.html#LN1516"><span class='Ref_To_Local'>count</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>AsyncQueueLock<span class='Delimiter'>, </span><a href="../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="async.c.html#LN1517"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="async.c.html#LN1517"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT;= </span><a href="../utils/init/globals.c.html#LN126"><span class='Ref_to_Global_Var'>MaxBackends</span></a><span class='Delimiter'>; </span><a href="async.c.html#LN1517"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="async.c.html#LN1518"><span class='Ref_To_Local'>pid</span></a> <span class='Operator'>= </span><a href="async.c.html#LN256"><span class='Ref_to_Macro'>QUEUE_BACKEND_PID</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1517"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN1518"><span class='Ref_To_Local'>pid</span></a> <span class='Operator'>!= </span><a href="../../include/miscadmin.h.html#LN32"><span class='Ref_to_Const'>InvalidPid</span></a> <span class='Operator'>&& </span><a href="async.c.html#LN1518"><span class='Ref_To_Local'>pid</span></a> <span class='Operator'>!= </span><a href="../utils/init/globals.c.html#LN38"><span class='Ref_to_Global_Var'>MyProcPid</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1539"></a>            <a href="async.c.html#LN181"><span class='Ref_to_Struct'>QueuePosition</span></a> <span class='Declare_Local'>pos</span> <span class='Operator'>= </span><a href="async.c.html#LN258"><span class='Ref_to_Macro'>QUEUE_BACKEND_POS</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1517"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="async.c.html#LN196"><span class='Ref_to_Macro'>QUEUE_POS_EQUAL</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1539"><span class='Ref_To_Local'>pos</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN254"><span class='Ref_to_Const'>QUEUE_HEAD</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <a href="async.c.html#LN1514"><span class='Ref_To_Local'>pids</span></a><span class='Delimiter'>[</span><a href="async.c.html#LN1516"><span class='Ref_To_Local'>count</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="async.c.html#LN1518"><span class='Ref_To_Local'>pid</span></a><span class='Delimiter'>; 
</span>                <a href="async.c.html#LN1515"><span class='Ref_To_Local'>ids</span></a><span class='Delimiter'>[</span><a href="async.c.html#LN1516"><span class='Ref_To_Local'>count</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="async.c.html#LN1517"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>; 
</span>                <a href="async.c.html#LN1516"><span class='Ref_To_Local'>count</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span>    <a href="../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>AsyncQueueLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Now send signals */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="async.c.html#LN1517"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="async.c.html#LN1517"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="async.c.html#LN1516"><span class='Ref_To_Local'>count</span></a><span class='Delimiter'>; </span><a href="async.c.html#LN1517"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="async.c.html#LN1518"><span class='Ref_To_Local'>pid</span></a> <span class='Operator'>= </span><a href="async.c.html#LN1514"><span class='Ref_To_Local'>pids</span></a><span class='Delimiter'>[</span><a href="async.c.html#LN1517"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Note: assuming things aren't broken, a signal failure here could 
         * only occur if the target backend exited since we released 
         * AsyncQueueLock; which is unlikely but certainly possible. So we 
         * just log a low-level debug message if it happens. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/storage/procsignal.h.html#LN55"><span class='Ref_to_Proto'>SendProcSignal</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1518"><span class='Ref_To_Local'>pid</span></a><span class='Delimiter'>, </span><a href="../../include/storage/procsignal.h.html#LN32"><span class='Ref_to_EnumConst'>PROCSIG_NOTIFY_INTERRUPT</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN1515"><span class='Ref_To_Local'>ids</span></a><span class='Delimiter'>[</span><a href="async.c.html#LN1517"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) </span><span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
            <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN22"><span class='Ref_to_Const'>DEBUG3</span></a><span class='Delimiter'>, </span><span class='String'>"could not signal backend with PID %d: %m"</span><span class='Delimiter'>, </span><a href="async.c.html#LN1518"><span class='Ref_To_Local'>pid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="async.c.html#LN1513"><span class='Ref_To_Local'>signalled</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1514"><span class='Ref_To_Local'>pids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1515"><span class='Ref_To_Local'>ids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="async.c.html#LN1513"><span class='Ref_To_Local'>signalled</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end SignalBackends &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * AtAbort_Notify 
 * 
 *  This is called at transaction abort. 
 * 
 *  Gets rid of pending actions and outbound notifies that we would have 
 *  executed if the transaction got committed. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1583"></a><span class='Declare_Function'>AtAbort_Notify</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * If we LISTEN but then roll back the transaction after PreCommit_Notify, 
     * we have registered as a listener but have not made any entry in 
     * listenChannels.  In that case, deregister again. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN361"><span class='Ref_to_Global_Var'>amRegisteredListener</span></a> <span class='Operator'>&& </span><a href="async.c.html#LN293"><span class='Ref_to_Global_Var'>listenChannels</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <a href="async.c.html#LN378"><span class='Ref_to_Proto'>asyncQueueUnregister</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* And clean up */ 
</span>    <a href="async.c.html#LN393"><span class='Ref_to_Proto'>ClearPendingActionsAndNotifies</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * AtSubStart_Notify() --- Take care of subtransaction start. 
 * 
 * Push empty state for the new subtransaction. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1603"></a><span class='Declare_Function'>AtSubStart_Notify</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1605"></a>    <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>old_cxt</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Keep the list-of-lists in TopTransactionContext for simplicity */ 
</span>    <a href="async.c.html#LN1605"><span class='Ref_To_Local'>old_cxt</span></a> <span class='Operator'>= </span><a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="../utils/mmgr/mcxt.c.html#LN47"><span class='Ref_to_Global_Var'>TopTransactionContext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="async.c.html#LN320"><span class='Ref_to_Global_Var'>upperPendingActions</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN215"><span class='Ref_to_Proto'>lcons</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN318"><span class='Ref_to_Global_Var'>pendingActions</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN320"><span class='Ref_to_Global_Var'>upperPendingActions</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN320"><span class='Ref_to_Global_Var'>upperPendingActions</span></a><span class='Parentheses'>) </span><span class='Operator'>== 
</span>           <a href="../../include/access/xact.h.html#LN344"><span class='Ref_to_Proto'>GetCurrentTransactionNestLevel</span></a><span class='Parentheses'>() </span><span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="async.c.html#LN318"><span class='Ref_to_Global_Var'>pendingActions</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
    <a href="async.c.html#LN346"><span class='Ref_to_Global_Var'>upperPendingNotifies</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN215"><span class='Ref_to_Proto'>lcons</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN344"><span class='Ref_to_Global_Var'>pendingNotifies</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN346"><span class='Ref_to_Global_Var'>upperPendingNotifies</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN346"><span class='Ref_to_Global_Var'>upperPendingNotifies</span></a><span class='Parentheses'>) </span><span class='Operator'>== 
</span>           <a href="../../include/access/xact.h.html#LN344"><span class='Ref_to_Proto'>GetCurrentTransactionNestLevel</span></a><span class='Parentheses'>() </span><span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="async.c.html#LN344"><span class='Ref_to_Global_Var'>pendingNotifies</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1605"><span class='Ref_To_Local'>old_cxt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end AtSubStart_Notify &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * AtSubCommit_Notify() --- Take care of subtransaction commit. 
 * 
 * Reassign all items in the pending lists to the parent transaction. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1633"></a><span class='Declare_Function'>AtSubCommit_Notify</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1635"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>parentPendingActions</span><span class='Delimiter'>; 
</span><a name="LN1636"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>parentPendingNotifies</span><span class='Delimiter'>; 
</span> 
    <a href="async.c.html#LN1635"><span class='Ref_To_Local'>parentPendingActions</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN113"><span class='Ref_to_Macro'>linitial_node</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN320"><span class='Ref_to_Global_Var'>upperPendingActions</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="async.c.html#LN320"><span class='Ref_to_Global_Var'>upperPendingActions</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN237"><span class='Ref_to_Proto'>list_delete_first</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN320"><span class='Ref_to_Global_Var'>upperPendingActions</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN320"><span class='Ref_to_Global_Var'>upperPendingActions</span></a><span class='Parentheses'>) </span><span class='Operator'>== 
</span>           <a href="../../include/access/xact.h.html#LN344"><span class='Ref_to_Proto'>GetCurrentTransactionNestLevel</span></a><span class='Parentheses'>() </span><span class='Operator'>- </span><span class='Number'>2</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Mustn't try to eliminate duplicates here --- see queue_listen() 
     */ 
</span>    <a href="async.c.html#LN318"><span class='Ref_to_Global_Var'>pendingActions</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN219"><span class='Ref_to_Proto'>list_concat</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1635"><span class='Ref_To_Local'>parentPendingActions</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN318"><span class='Ref_to_Global_Var'>pendingActions</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="async.c.html#LN1636"><span class='Ref_To_Local'>parentPendingNotifies</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN113"><span class='Ref_to_Macro'>linitial_node</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN346"><span class='Ref_to_Global_Var'>upperPendingNotifies</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="async.c.html#LN346"><span class='Ref_to_Global_Var'>upperPendingNotifies</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN237"><span class='Ref_to_Proto'>list_delete_first</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN346"><span class='Ref_to_Global_Var'>upperPendingNotifies</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN346"><span class='Ref_to_Global_Var'>upperPendingNotifies</span></a><span class='Parentheses'>) </span><span class='Operator'>== 
</span>           <a href="../../include/access/xact.h.html#LN344"><span class='Ref_to_Proto'>GetCurrentTransactionNestLevel</span></a><span class='Parentheses'>() </span><span class='Operator'>- </span><span class='Number'>2</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We could try to eliminate duplicates here, but it seems not worthwhile. 
     */ 
</span>    <a href="async.c.html#LN344"><span class='Ref_to_Global_Var'>pendingNotifies</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN219"><span class='Ref_to_Proto'>list_concat</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1636"><span class='Ref_To_Local'>parentPendingNotifies</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN344"><span class='Ref_to_Global_Var'>pendingNotifies</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end AtSubCommit_Notify &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * AtSubAbort_Notify() --- Take care of subtransaction abort. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1665"></a><span class='Declare_Function'>AtSubAbort_Notify</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1667"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>my_level</span> <span class='Operator'>= </span><a href="../../include/access/xact.h.html#LN344"><span class='Ref_to_Proto'>GetCurrentTransactionNestLevel</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * All we have to do is pop the stack --- the actions/notifies made in 
     * this subxact are no longer interesting, and the space will be freed 
     * when CurTransactionContext is recycled. 
     * 
     * This routine could be called more than once at a given nesting level if 
     * there is trouble during subxact abort.  Avoid dumping core by using 
     * GetCurrentTransactionNestLevel as the indicator of how far we need to 
     * prune the list. 
     */ 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN320"><span class='Ref_to_Global_Var'>upperPendingActions</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT; </span><a href="async.c.html#LN1667"><span class='Ref_To_Local'>my_level</span></a> <span class='Operator'>- </span><span class='Number'>2</span><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <a href="async.c.html#LN318"><span class='Ref_to_Global_Var'>pendingActions</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN113"><span class='Ref_to_Macro'>linitial_node</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN320"><span class='Ref_to_Global_Var'>upperPendingActions</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="async.c.html#LN320"><span class='Ref_to_Global_Var'>upperPendingActions</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN237"><span class='Ref_to_Proto'>list_delete_first</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN320"><span class='Ref_to_Global_Var'>upperPendingActions</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN346"><span class='Ref_to_Global_Var'>upperPendingNotifies</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT; </span><a href="async.c.html#LN1667"><span class='Ref_To_Local'>my_level</span></a> <span class='Operator'>- </span><span class='Number'>2</span><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <a href="async.c.html#LN344"><span class='Ref_to_Global_Var'>pendingNotifies</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN113"><span class='Ref_to_Macro'>linitial_node</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN346"><span class='Ref_to_Global_Var'>upperPendingNotifies</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="async.c.html#LN346"><span class='Ref_to_Global_Var'>upperPendingNotifies</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN237"><span class='Ref_to_Proto'>list_delete_first</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN346"><span class='Ref_to_Global_Var'>upperPendingNotifies</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end AtSubAbort_Notify &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * HandleNotifyInterrupt 
 * 
 *      Signal handler portion of interrupt handling. Let the backend know 
 *      that there's a pending notify interrupt. If we're currently reading 
 *      from the client, this will interrupt the read and 
 *      ProcessClientReadInterrupt() will call ProcessNotifyInterrupt(). 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1701"></a><span class='Declare_Function'>HandleNotifyInterrupt</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * Note: this is called by a SIGNAL HANDLER. You must be very wary what 
     * you do here. 
     */ 
</span> 
    <span class='Comment_Multi_Line'>/* signal that work needs to be done */ 
</span>    <a href="async.c.html#LN355"><span class='Ref_to_Global_Var'>notifyInterruptPending</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* make sure the event is processed in due course */ 
</span>    <a href="../../include/storage/latch.h.html#LN151"><span class='Ref_to_Proto'>SetLatch</span></a><span class='Parentheses'>(</span><a href="../utils/init/globals.c.html#LN51"><span class='Ref_to_Global_Var'>MyLatch</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * ProcessNotifyInterrupt 
 * 
 *      This is called just after waiting for a frontend command.  If a 
 *      interrupt arrives (via HandleNotifyInterrupt()) while reading, the 
 *      read will be interrupted via the process's latch, and this routine 
 *      will get called.  If we are truly idle (ie, *not* inside a transaction 
 *      block), process the incoming notifies. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1725"></a><span class='Declare_Function'>ProcessNotifyInterrupt</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/access/xact.h.html#LN367"><span class='Ref_to_Proto'>IsTransactionOrTransactionBlock</span></a><span class='Parentheses'>())</span> 
        <span class='Control'>return</span><span class='Delimiter'>;</span>                 <span class='Comment_Single_Line'>/* not really idle */ 
</span> 
    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="async.c.html#LN355"><span class='Ref_to_Global_Var'>notifyInterruptPending</span></a><span class='Parentheses'>) 
</span>        <a href="async.c.html#LN391"><span class='Ref_to_Proto'>ProcessIncomingNotify</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
} 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Read all pending notifications from the queue, and deliver appropriate 
 * ones to my frontend.  Stop when we reach queue head or an uncommitted 
 * notification. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1741"></a><span class='Declare_Function'>asyncQueueReadAllNotifications</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1743"></a>    <span class='Keyword'>volatile </span><a href="async.c.html#LN181"><span class='Ref_to_Struct'>QueuePosition</span></a> <span class='Declare_Local'>pos</span><span class='Delimiter'>; 
</span><a name="LN1744"></a>    <a href="async.c.html#LN181"><span class='Ref_to_Struct'>QueuePosition</span></a> <span class='Declare_Local'>oldpos</span><span class='Delimiter'>; 
</span><a name="LN1745"></a>    <a href="async.c.html#LN181"><span class='Ref_to_Struct'>QueuePosition</span></a> <span class='Declare_Local'>head</span><span class='Delimiter'>; 
</span><a name="LN1746"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>advanceTail</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* page_buffer must be adequately aligned, so use a union */ 
</span>    <span class='Control'>union</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1751"></a>        <span class='Keyword'>char</span>        <span class='Declare_Member'>buf</span><span class='Delimiter'>[</span><a href="async.c.html#LN266"><span class='Ref_to_Const'>QUEUE_PAGESIZE</span></a><span class='Delimiter'>]; 
</span><a name="LN1752"></a>        <a href="async.c.html#LN164"><span class='Ref_to_Struct'>AsyncQueueEntry</span></a> <span class='Declare_Member'>align</span><span class='Delimiter'>; 
</span><a name="LN1753"></a>    <span class='Delimiter'>}</span>           <span class='Declare_Local'>page_buffer</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Fetch current state */ 
</span>    <a href="../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>AsyncQueueLock<span class='Delimiter'>, </span><a href="../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* Assert checks that we have a valid state entry */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../utils/init/globals.c.html#LN38"><span class='Ref_to_Global_Var'>MyProcPid</span></a> <span class='Operator'>== </span><a href="async.c.html#LN256"><span class='Ref_to_Macro'>QUEUE_BACKEND_PID</span></a><span class='Parentheses'>(</span><a href="../utils/init/globals.c.html#LN72"><span class='Ref_to_Global_Var'>MyBackendId</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="async.c.html#LN1743"><span class='Ref_To_Local'>pos</span></a> <span class='Operator'>= </span><a href="async.c.html#LN1744"><span class='Ref_To_Local'>oldpos</span></a> <span class='Operator'>= </span><a href="async.c.html#LN258"><span class='Ref_to_Macro'>QUEUE_BACKEND_POS</span></a><span class='Parentheses'>(</span><a href="../utils/init/globals.c.html#LN72"><span class='Ref_to_Global_Var'>MyBackendId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="async.c.html#LN1745"><span class='Ref_To_Local'>head</span></a> <span class='Operator'>= </span><a href="async.c.html#LN254"><span class='Ref_to_Const'>QUEUE_HEAD</span></a><span class='Delimiter'>; 
</span>    <a href="../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>AsyncQueueLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN196"><span class='Ref_to_Macro'>QUEUE_POS_EQUAL</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1743"><span class='Ref_To_Local'>pos</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN1745"><span class='Ref_To_Local'>head</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Nothing to do, we have read all notifications already. */ 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/*---------- 
     * Note that we deliver everything that we see in the queue and that 
     * matches our _current_ listening state. 
     * Especially we do not take into account different commit times. 
     * Consider the following example: 
     * 
     * Backend 1:                    Backend 2: 
     * 
     * transaction starts 
     * NOTIFY foo; 
     * commit starts 
     *                               transaction starts 
     *                               LISTEN foo; 
     *                               commit starts 
     * commit to clog 
     *                               commit to clog 
     * 
     * It could happen that backend 2 sees the notification from backend 1 in 
     * the queue.  Even though the notifying transaction committed before 
     * the listening transaction, we still deliver the notification. 
     * 
     * The idea is that an additional notification does not do any harm, we 
     * just need to make sure that we do not miss a notification. 
     * 
     * It is possible that we fail while trying to send a message to our 
     * frontend (for example, because of encoding conversion failure). 
     * If that happens it is critical that we not try to send the same 
     * message over and over again.  Therefore, we place a PG_TRY block 
     * here that will forcibly advance our backend position before we lose 
     * control to an error.  (We could alternatively retake AsyncQueueLock 
     * and move the position before handling each individual message, but 
     * that seems like too much lock traffic.) 
     *---------- 
     */ 
</span>    <a href="../../include/utils/elog.h.html#LN283"><span class='Ref_to_Macro'>PG_TRY</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1805"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>reachedStop</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>do</span> 
        <span class='Delimiter'>{ 
</span><a name="LN1809"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>curpage</span> <span class='Operator'>= </span><a href="async.c.html#LN187"><span class='Ref_to_Macro'>QUEUE_POS_PAGE</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1743"><span class='Ref_To_Local'>pos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1810"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>curoffset</span> <span class='Operator'>= </span><a href="async.c.html#LN188"><span class='Ref_to_Macro'>QUEUE_POS_OFFSET</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1743"><span class='Ref_To_Local'>pos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1811"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>slotno</span><span class='Delimiter'>; 
</span><a name="LN1812"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>copysize</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * We copy the data from SLRU into a local buffer, so as to avoid 
             * holding the AsyncCtlLock while we are examining the entries and 
             * possibly transmitting them to our frontend.  Copy only the part 
             * of the page we will actually inspect. 
             */ 
</span>            <a href="async.c.html#LN1811"><span class='Ref_To_Local'>slotno</span></a> <span class='Operator'>= </span><a href="../../include/access/slru.h.html#LN149"><span class='Ref_to_Proto'>SimpleLruReadPage_ReadOnly</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN265"><span class='Ref_to_Const'>AsyncCtl</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN1809"><span class='Ref_To_Local'>curpage</span></a><span class='Delimiter'>, 
</span>                                                <a href="../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN1809"><span class='Ref_To_Local'>curpage</span></a> <span class='Operator'>== </span><a href="async.c.html#LN187"><span class='Ref_to_Macro'>QUEUE_POS_PAGE</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1745"><span class='Ref_To_Local'>head</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* we only want to read as far as head */ 
</span>                <a href="async.c.html#LN1812"><span class='Ref_To_Local'>copysize</span></a> <span class='Operator'>= </span><a href="async.c.html#LN188"><span class='Ref_to_Macro'>QUEUE_POS_OFFSET</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1745"><span class='Ref_To_Local'>head</span></a><span class='Parentheses'>) </span><span class='Operator'>- </span><a href="async.c.html#LN1810"><span class='Ref_To_Local'>curoffset</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN1812"><span class='Ref_To_Local'>copysize</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                    <a href="async.c.html#LN1812"><span class='Ref_To_Local'>copysize</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* just for safety */ 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* fetch all the rest of the page */ 
</span>                <a href="async.c.html#LN1812"><span class='Ref_To_Local'>copysize</span></a> <span class='Operator'>= </span><a href="async.c.html#LN266"><span class='Ref_to_Const'>QUEUE_PAGESIZE</span></a> <span class='Operator'>- </span><a href="async.c.html#LN1810"><span class='Ref_To_Local'>curoffset</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            memcpy<span class='Parentheses'>(</span><a href="async.c.html#LN1753"><span class='Ref_To_Local'>page_buffer</span></a><span class='Operator'>.</span><a href="async.c.html#LN1751"><span class='Ref_to_Member'>buf</span></a> <span class='Operator'>+ </span><a href="async.c.html#LN1810"><span class='Ref_To_Local'>curoffset</span></a><span class='Delimiter'>, 
</span>                   <a href="async.c.html#LN265"><span class='Ref_to_Const'>AsyncCtl</span></a><span class='Operator'>-&GT;</span>shared<span class='Operator'>-&GT;</span>page_buffer<span class='Delimiter'>[</span><a href="async.c.html#LN1811"><span class='Ref_To_Local'>slotno</span></a><span class='Delimiter'>] </span><span class='Operator'>+ </span><a href="async.c.html#LN1810"><span class='Ref_To_Local'>curoffset</span></a><span class='Delimiter'>, 
</span>                   <a href="async.c.html#LN1812"><span class='Ref_To_Local'>copysize</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* Release lock that we got from SimpleLruReadPage_ReadOnly() */ 
</span>            <a href="../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>AsyncCtlLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Process messages up to the stop position, end of page, or an 
             * uncommitted message. 
             * 
             * Our stop position is what we found to be the head's position 
             * when we entered this function. It might have changed already. 
             * But if it has, we will receive (or have already received and 
             * queued) another signal and come here again. 
             * 
             * We are not holding AsyncQueueLock here! The queue can only 
             * extend beyond the head pointer (see above) and we leave our 
             * backend's pointer where it is so nobody will truncate or 
             * rewrite pages under us. Especially we don't want to hold a lock 
             * while sending the notifications to the frontend. 
             */ 
</span>            <a href="async.c.html#LN1805"><span class='Ref_To_Local'>reachedStop</span></a> <span class='Operator'>= </span><a href="async.c.html#LN387"><span class='Ref_to_Proto'>asyncQueueProcessPageEntries</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="async.c.html#LN1743"><span class='Ref_To_Local'>pos</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN1745"><span class='Ref_To_Local'>head</span></a><span class='Delimiter'>, 
</span>                                                       <a href="async.c.html#LN1753"><span class='Ref_To_Local'>page_buffer</span></a><span class='Operator'>.</span><a href="async.c.html#LN1751"><span class='Ref_to_Member'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end do &raquo; </span> <span class='Control'>while</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="async.c.html#LN1805"><span class='Ref_To_Local'>reachedStop</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="../../include/utils/elog.h.html#LN292"><span class='Ref_to_Macro'>PG_CATCH</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Update shared state */ 
</span>        <a href="../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>AsyncQueueLock<span class='Delimiter'>, </span><a href="../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="async.c.html#LN258"><span class='Ref_to_Macro'>QUEUE_BACKEND_POS</span></a><span class='Parentheses'>(</span><a href="../utils/init/globals.c.html#LN72"><span class='Ref_to_Global_Var'>MyBackendId</span></a><span class='Parentheses'>) </span><span class='Operator'>= </span><a href="async.c.html#LN1743"><span class='Ref_To_Local'>pos</span></a><span class='Delimiter'>; 
</span>        <a href="async.c.html#LN1746"><span class='Ref_To_Local'>advanceTail</span></a> <span class='Operator'>= </span><a href="async.c.html#LN196"><span class='Ref_to_Macro'>QUEUE_POS_EQUAL</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1744"><span class='Ref_To_Local'>oldpos</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN255"><span class='Ref_to_Const'>QUEUE_TAIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>AsyncQueueLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* If we were the laziest backend, try to advance the tail pointer */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN1746"><span class='Ref_To_Local'>advanceTail</span></a><span class='Parentheses'>) 
</span>            <a href="async.c.html#LN390"><span class='Ref_to_Proto'>asyncQueueAdvanceTail</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/utils/elog.h.html#LN310"><span class='Ref_to_Macro'>PG_RE_THROW</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="../../include/utils/elog.h.html#LN299"><span class='Ref_to_Macro'>PG_END_TRY</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Update shared state */ 
</span>    <a href="../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>AsyncQueueLock<span class='Delimiter'>, </span><a href="../../include/storage/lwlock.h.html#LN134"><span class='Ref_to_EnumConst'>LW_SHARED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="async.c.html#LN258"><span class='Ref_to_Macro'>QUEUE_BACKEND_POS</span></a><span class='Parentheses'>(</span><a href="../utils/init/globals.c.html#LN72"><span class='Ref_to_Global_Var'>MyBackendId</span></a><span class='Parentheses'>) </span><span class='Operator'>= </span><a href="async.c.html#LN1743"><span class='Ref_To_Local'>pos</span></a><span class='Delimiter'>; 
</span>    <a href="async.c.html#LN1746"><span class='Ref_To_Local'>advanceTail</span></a> <span class='Operator'>= </span><a href="async.c.html#LN196"><span class='Ref_to_Macro'>QUEUE_POS_EQUAL</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1744"><span class='Ref_To_Local'>oldpos</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN255"><span class='Ref_to_Const'>QUEUE_TAIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>AsyncQueueLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* If we were the laziest backend, try to advance the tail pointer */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN1746"><span class='Ref_To_Local'>advanceTail</span></a><span class='Parentheses'>) 
</span>        <a href="async.c.html#LN390"><span class='Ref_to_Proto'>asyncQueueAdvanceTail</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end asyncQueueReadAllNotifications &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Fetch notifications from the shared queue, beginning at position current, 
 * and deliver relevant ones to my frontend. 
 * 
 * The current page must have been fetched into page_buffer from shared 
 * memory.  (We could access the page right in shared memory, but that 
 * would imply holding the AsyncCtlLock throughout this routine.) 
 * 
 * We stop if we reach the "stop" position, or reach a notification from an 
 * uncommitted transaction, or reach the end of the page. 
 * 
 * The function returns true once we have reached the stop position or an 
 * uncommitted notification, and false if we have finished with the page. 
 * In other words: once it returns true there is no need to look further. 
 * The QueuePosition *current is advanced past all processed messages. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN1903"></a><span class='Declare_Function'>asyncQueueProcessPageEntries</span><span class='Parentheses'>(</span><span class='Keyword'>volatile </span><a href="async.c.html#LN181"><span class='Ref_to_Struct'>QueuePosition</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>current</span><span class='Delimiter'>, 
</span><a name="LN1904"></a>                             <a href="async.c.html#LN181"><span class='Ref_to_Struct'>QueuePosition</span></a> <span class='Declare_Parameter'>stop</span><span class='Delimiter'>, 
</span><a name="LN1905"></a>                             <span class='Keyword'>char </span><span class='Operator'>*</span><span class='Declare_Parameter'>page_buffer</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1907"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>reachedStop</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN1908"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>reachedEndOfPage</span><span class='Delimiter'>; 
</span><a name="LN1909"></a>    <a href="async.c.html#LN164"><span class='Ref_to_Struct'>AsyncQueueEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>qe</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>do</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1913"></a>        <a href="async.c.html#LN181"><span class='Ref_to_Struct'>QueuePosition</span></a> <span class='Declare_Local'>thisentry</span> <span class='Operator'>= *</span><a href="async.c.html#LN1903"><span class='Ref_to_Parameter'>current</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN196"><span class='Ref_to_Macro'>QUEUE_POS_EQUAL</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1913"><span class='Ref_To_Local'>thisentry</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN1904"><span class='Ref_to_Parameter'>stop</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <a href="async.c.html#LN1909"><span class='Ref_To_Local'>qe</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="async.c.html#LN164"><span class='Ref_to_Struct'>AsyncQueueEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) (</span><a href="async.c.html#LN1905"><span class='Ref_to_Parameter'>page_buffer</span></a> <span class='Operator'>+ </span><a href="async.c.html#LN188"><span class='Ref_to_Macro'>QUEUE_POS_OFFSET</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1913"><span class='Ref_To_Local'>thisentry</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Advance *current over this message, possibly to the next page. As 
         * noted in the comments for asyncQueueReadAllNotifications, we must 
         * do this before possibly failing while processing the message. 
         */ 
</span>        <a href="async.c.html#LN1908"><span class='Ref_To_Local'>reachedEndOfPage</span></a> <span class='Operator'>= </span><a href="async.c.html#LN380"><span class='Ref_to_Proto'>asyncQueueAdvance</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1903"><span class='Ref_to_Parameter'>current</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN1909"><span class='Ref_To_Local'>qe</span></a><span class='Operator'>-&GT;</span><a href="async.c.html#LN166"><span class='Ref_to_Member'>length</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Ignore messages destined for other databases */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN1909"><span class='Ref_To_Local'>qe</span></a><span class='Operator'>-&GT;</span><a href="async.c.html#LN167"><span class='Ref_to_Member'>dboid</span></a> <span class='Operator'>== </span><a href="../utils/init/globals.c.html#LN76"><span class='Ref_to_Global_Var'>MyDatabaseId</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/storage/procarray.h.html#LN89"><span class='Ref_to_Proto'>TransactionIdIsInProgress</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1909"><span class='Ref_To_Local'>qe</span></a><span class='Operator'>-&GT;</span><a href="async.c.html#LN168"><span class='Ref_to_Member'>xid</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * The source transaction is still in progress, so we can't 
                 * process this message yet.  Break out of the loop, but first 
                 * back up *current so we will reprocess the message next 
                 * time.  (Note: it is unlikely but not impossible for 
                 * TransactionIdDidCommit to fail, so we can't really avoid 
                 * this advance-then-back-up behavior when dealing with an 
                 * uncommitted message.) 
                 * 
                 * Note that we must test TransactionIdIsInProgress before we 
                 * test TransactionIdDidCommit, else we might return a message 
                 * from a transaction that is not yet visible to snapshots; 
                 * compare the comments at the head of tqual.c. 
                 */ 
</span>                <span class='Operator'>*</span><a href="async.c.html#LN1903"><span class='Ref_to_Parameter'>current</span></a> <span class='Operator'>= </span><a href="async.c.html#LN1913"><span class='Ref_To_Local'>thisentry</span></a><span class='Delimiter'>; 
</span>                <a href="async.c.html#LN1907"><span class='Ref_To_Local'>reachedStop</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if TransactionIdIsInProg... &raquo; </span> 
            <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../access/transam/transam.c.html#LN123"><span class='Ref_to_Func'>TransactionIdDidCommit</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1909"><span class='Ref_To_Local'>qe</span></a><span class='Operator'>-&GT;</span><a href="async.c.html#LN168"><span class='Ref_to_Member'>xid</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* qe-&GT;data is the null-terminated channel name */ 
</span><a name="LN1953"></a>                <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>channel</span> <span class='Operator'>= </span><a href="async.c.html#LN1909"><span class='Ref_To_Local'>qe</span></a><span class='Operator'>-&GT;</span><a href="async.c.html#LN170"><span class='Ref_to_Member'>data</span></a><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN377"><span class='Ref_to_Proto'>IsListeningOn</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1953"><span class='Ref_To_Local'>channel</span></a><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* payload follows channel name */ 
</span><a name="LN1958"></a>                    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>payload</span> <span class='Operator'>= </span><a href="async.c.html#LN1909"><span class='Ref_To_Local'>qe</span></a><span class='Operator'>-&GT;</span><a href="async.c.html#LN170"><span class='Ref_to_Member'>data</span></a> <span class='Operator'>+ </span>strlen<span class='Parentheses'>(</span><a href="async.c.html#LN1953"><span class='Ref_To_Local'>channel</span></a><span class='Parentheses'>) </span><span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
                    <a href="../../include/commands/async.h.html#LN30"><span class='Ref_to_Proto'>NotifyMyFrontEnd</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1953"><span class='Ref_To_Local'>channel</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN1958"><span class='Ref_To_Local'>payload</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN1909"><span class='Ref_To_Local'>qe</span></a><span class='Operator'>-&GT;</span><a href="async.c.html#LN169"><span class='Ref_to_Member'>srcPid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * The source transaction aborted or crashed, so we just 
                 * ignore its notifications. 
                 */ 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if qe-&GT;dboid==MyDatabase... &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* Loop back if we're not at end of page */ 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end do &raquo; </span> <span class='Control'>while</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="async.c.html#LN1908"><span class='Ref_To_Local'>reachedEndOfPage</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN196"><span class='Ref_to_Macro'>QUEUE_POS_EQUAL</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="async.c.html#LN1903"><span class='Ref_to_Parameter'>current</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN1904"><span class='Ref_to_Parameter'>stop</span></a><span class='Parentheses'>))</span> 
        <a href="async.c.html#LN1907"><span class='Ref_To_Local'>reachedStop</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="async.c.html#LN1907"><span class='Ref_To_Local'>reachedStop</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end asyncQueueProcessPageEntries &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Advance the shared queue tail variable to the minimum of all the 
 * per-backend tail pointers.  Truncate pg_notify space if possible. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1986"></a><span class='Declare_Function'>asyncQueueAdvanceTail</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1988"></a>    <a href="async.c.html#LN181"><span class='Ref_to_Struct'>QueuePosition</span></a> <span class='Declare_Local'>min</span><span class='Delimiter'>; 
</span><a name="LN1989"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN1990"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>oldtailpage</span><span class='Delimiter'>; 
</span><a name="LN1991"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>newtailpage</span><span class='Delimiter'>; 
</span><a name="LN1992"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>boundary</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>AsyncQueueLock<span class='Delimiter'>, </span><a href="../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="async.c.html#LN1988"><span class='Ref_To_Local'>min</span></a> <span class='Operator'>= </span><a href="async.c.html#LN254"><span class='Ref_to_Const'>QUEUE_HEAD</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="async.c.html#LN1989"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="async.c.html#LN1989"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT;= </span><a href="../utils/init/globals.c.html#LN126"><span class='Ref_to_Global_Var'>MaxBackends</span></a><span class='Delimiter'>; </span><a href="async.c.html#LN1989"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN256"><span class='Ref_to_Macro'>QUEUE_BACKEND_PID</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1989"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><a href="../../include/miscadmin.h.html#LN32"><span class='Ref_to_Const'>InvalidPid</span></a><span class='Parentheses'>)</span> 
            <a href="async.c.html#LN1988"><span class='Ref_To_Local'>min</span></a> <span class='Operator'>= </span><a href="async.c.html#LN200"><span class='Ref_to_Macro'>QUEUE_POS_MIN</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1988"><span class='Ref_To_Local'>min</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN258"><span class='Ref_to_Macro'>QUEUE_BACKEND_POS</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1989"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="async.c.html#LN1990"><span class='Ref_To_Local'>oldtailpage</span></a> <span class='Operator'>= </span><a href="async.c.html#LN187"><span class='Ref_to_Macro'>QUEUE_POS_PAGE</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN255"><span class='Ref_to_Const'>QUEUE_TAIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="async.c.html#LN255"><span class='Ref_to_Const'>QUEUE_TAIL</span></a> <span class='Operator'>= </span><a href="async.c.html#LN1988"><span class='Ref_To_Local'>min</span></a><span class='Delimiter'>; 
</span>    <a href="../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>AsyncQueueLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We can truncate something if the global tail advanced across an SLRU 
     * segment boundary. 
     * 
     * XXX it might be better to truncate only once every several segments, to 
     * reduce the number of directory scans. 
     */ 
</span>    <a href="async.c.html#LN1991"><span class='Ref_To_Local'>newtailpage</span></a> <span class='Operator'>= </span><a href="async.c.html#LN187"><span class='Ref_to_Macro'>QUEUE_POS_PAGE</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1988"><span class='Ref_To_Local'>min</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="async.c.html#LN1992"><span class='Ref_To_Local'>boundary</span></a> <span class='Operator'>= </span><a href="async.c.html#LN1991"><span class='Ref_To_Local'>newtailpage</span></a> <span class='Operator'>- </span><span class='Parentheses'>(</span><a href="async.c.html#LN1991"><span class='Ref_To_Local'>newtailpage</span></a> <span class='Operator'>% </span><a href="../../include/access/slru.h.html#LN36"><span class='Ref_to_Const'>SLRU_PAGES_PER_SEGMENT</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN370"><span class='Ref_to_Proto'>asyncQueuePagePrecedes</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN1990"><span class='Ref_To_Local'>oldtailpage</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN1992"><span class='Ref_To_Local'>boundary</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * SimpleLruTruncate() will ask for AsyncCtlLock but will also release 
         * the lock again. 
         */ 
</span>        <a href="../../include/access/slru.h.html#LN153"><span class='Ref_to_Proto'>SimpleLruTruncate</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN265"><span class='Ref_to_Const'>AsyncCtl</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN1991"><span class='Ref_To_Local'>newtailpage</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end asyncQueueAdvanceTail &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * ProcessIncomingNotify 
 * 
 *      Deal with arriving NOTIFYs from other backends as soon as it's safe to 
 *      do so. This used to be called from the PROCSIG_NOTIFY_INTERRUPT 
 *      signal handler, but isn't anymore. 
 * 
 *      Scan the queue for arriving notifications and report them to my front 
 *      end. 
 * 
 *      NOTE: since we are outside any transaction, we must create our own. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2037"></a><span class='Declare_Function'>ProcessIncomingNotify</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* We *must* reset the flag */ 
</span>    <a href="async.c.html#LN355"><span class='Ref_to_Global_Var'>notifyInterruptPending</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Do nothing else if we aren't actively listening */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN293"><span class='Ref_to_Global_Var'>listenChannels</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN367"><span class='Ref_to_Global_Var'>Trace_notify</span></a><span class='Parentheses'>) 
</span>        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN24"><span class='Ref_to_Const'>DEBUG1</span></a><span class='Delimiter'>, </span><span class='String'>"ProcessIncomingNotify"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/utils/ps_status.h.html#LN21"><span class='Ref_to_Proto'>set_ps_display</span></a><span class='Parentheses'>(</span><span class='String'>"notify interrupt"</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We must run asyncQueueReadAllNotifications inside a transaction, else 
     * bad things happen if it gets an error. 
     */ 
</span>    <a href="../../include/access/xact.h.html#LN348"><span class='Ref_to_Proto'>StartTransactionCommand</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <a href="async.c.html#LN386"><span class='Ref_to_Proto'>asyncQueueReadAllNotifications</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/access/xact.h.html#LN349"><span class='Ref_to_Proto'>CommitTransactionCommand</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Must flush the notify messages to ensure frontend gets them promptly. 
     */ 
</span>    <a href="../../include/libpq/libpq.h.html#LN38"><span class='Ref_to_Macro'>pq_flush</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/utils/ps_status.h.html#LN21"><span class='Ref_to_Proto'>set_ps_display</span></a><span class='Parentheses'>(</span><span class='String'>"idle"</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN367"><span class='Ref_to_Global_Var'>Trace_notify</span></a><span class='Parentheses'>) 
</span>        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN24"><span class='Ref_to_Const'>DEBUG1</span></a><span class='Delimiter'>, </span><span class='String'>"ProcessIncomingNotify: done"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ProcessIncomingNotify &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Send NOTIFY message to my front end. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN2076"></a><span class='Declare_Function'>NotifyMyFrontEnd</span><span class='Parentheses'>(</span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>channel</span><span class='Delimiter'>, </span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>payload</span><span class='Delimiter'>, </span><a href="../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a> <span class='Declare_Parameter'>srcPid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../tcop/postgres.c.html#LN87"><span class='Ref_to_Global_Var'>whereToSendOutput</span></a> <span class='Operator'>== </span><a href="../../include/tcop/dest.h.html#LN89"><span class='Ref_to_EnumConst'>DestRemote</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2080"></a>        <a href="../../include/lib/stringinfo.h.html#LN34"><span class='Ref_to_Struct'>StringInfoData</span></a> <span class='Declare_Local'>buf</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/libpq/pqformat.h.html#LN17"><span class='Ref_to_Proto'>pq_beginmessage</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="async.c.html#LN2080"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><span class='String'>'A'</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/libpq/pqformat.h.html#LN25"><span class='Ref_to_Proto'>pq_sendint</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="async.c.html#LN2080"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN2076"><span class='Ref_to_Parameter'>srcPid</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="../../include/libpq/pqformat.h.html#LN23"><span class='Ref_to_Proto'>pq_sendstring</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="async.c.html#LN2080"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN2076"><span class='Ref_to_Parameter'>channel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/libpq/pqcomm.h.html#LN103"><span class='Ref_to_Macro'>PG_PROTOCOL_MAJOR</span></a><span class='Parentheses'>(</span><a href="../utils/init/globals.c.html#LN26"><span class='Ref_to_Global_Var'>FrontendProtocol</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT;= </span><span class='Number'>3</span><span class='Parentheses'>)</span> 
            <a href="../../include/libpq/pqformat.h.html#LN23"><span class='Ref_to_Proto'>pq_sendstring</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="async.c.html#LN2080"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN2076"><span class='Ref_to_Parameter'>payload</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/libpq/pqformat.h.html#LN29"><span class='Ref_to_Proto'>pq_endmessage</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="async.c.html#LN2080"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * NOTE: we do not do pq_flush() here.  For a self-notify, it will 
         * happen at the end of the transaction, and for incoming notifies 
         * ProcessIncomingNotify will do it after finding all the notifies. 
         */ 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN32"><span class='Ref_to_Const'>INFO</span></a><span class='Delimiter'>, </span><span class='String'>"NOTIFY for \"%s\" payload \"%s\""</span><span class='Delimiter'>, </span><a href="async.c.html#LN2076"><span class='Ref_to_Parameter'>channel</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN2076"><span class='Ref_to_Parameter'>payload</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end NotifyMyFrontEnd &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* Does pendingNotifies include the given channel/payload? */ 
</span><span class='Keyword'>static bool 
</span><a name="LN2101"></a><span class='Declare_Function'>AsyncExistsPendingNotify</span><span class='Parentheses'>(</span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>channel</span><span class='Delimiter'>, </span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>payload</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2103"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>p</span><span class='Delimiter'>; 
</span><a name="LN2104"></a>    <a href="async.c.html#LN338"><span class='Ref_to_Struct'>Notification</span></a> <span class='Operator'>*</span><span class='Declare_Local'>n</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN344"><span class='Ref_to_Global_Var'>pendingNotifies</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="async.c.html#LN2101"><span class='Ref_to_Parameter'>payload</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="async.c.html#LN2101"><span class='Ref_to_Parameter'>payload</span></a> <span class='Operator'>= </span><span class='String'>""</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/*---------- 
     * We need to append new elements to the end of the list in order to keep 
     * the order. However, on the other hand we'd like to check the list 
     * backwards in order to make duplicate-elimination a tad faster when the 
     * same condition is signaled many times in a row. So as a compromise we 
     * check the tail element first which we can access directly. If this 
     * doesn't match, we check the whole list. 
     * 
     * As we are not checking our parents' lists, we can still get duplicates 
     * in combination with subtransactions, like in: 
     * 
     * begin; 
     * notify foo '1'; 
     * savepoint foo; 
     * notify foo '1'; 
     * commit; 
     *---------- 
     */ 
</span>    <a href="async.c.html#LN2104"><span class='Ref_To_Local'>n</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="async.c.html#LN338"><span class='Ref_to_Struct'>Notification</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN130"><span class='Ref_to_Macro'>llast</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN344"><span class='Ref_to_Global_Var'>pendingNotifies</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span><a href="async.c.html#LN2104"><span class='Ref_To_Local'>n</span></a><span class='Operator'>-&GT;</span><a href="async.c.html#LN340"><span class='Ref_to_Member'>channel</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN2101"><span class='Ref_to_Parameter'>channel</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span> <span class='Operator'>&& 
</span>        strcmp<span class='Parentheses'>(</span><a href="async.c.html#LN2104"><span class='Ref_To_Local'>n</span></a><span class='Operator'>-&GT;</span><a href="async.c.html#LN341"><span class='Ref_to_Member'>payload</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN2101"><span class='Ref_to_Parameter'>payload</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN2103"><span class='Ref_To_Local'>p</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN344"><span class='Ref_to_Global_Var'>pendingNotifies</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="async.c.html#LN2104"><span class='Ref_To_Local'>n</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="async.c.html#LN338"><span class='Ref_to_Struct'>Notification</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="async.c.html#LN2103"><span class='Ref_To_Local'>p</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span><a href="async.c.html#LN2104"><span class='Ref_To_Local'>n</span></a><span class='Operator'>-&GT;</span><a href="async.c.html#LN340"><span class='Ref_to_Member'>channel</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN2101"><span class='Ref_to_Parameter'>channel</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span> <span class='Operator'>&& 
</span>            strcmp<span class='Parentheses'>(</span><a href="async.c.html#LN2104"><span class='Ref_To_Local'>n</span></a><span class='Operator'>-&GT;</span><a href="async.c.html#LN341"><span class='Ref_to_Member'>payload</span></a><span class='Delimiter'>, </span><a href="async.c.html#LN2101"><span class='Ref_to_Parameter'>payload</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end AsyncExistsPendingNotify &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* Clear the pendingActions and pendingNotifies lists. */ 
</span><span class='Keyword'>static void 
</span><a name="LN2149"></a><span class='Declare_Function'>ClearPendingActionsAndNotifies</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * We used to have to explicitly deallocate the list members and nodes, 
     * because they were malloc'd.  Now, since we know they are palloc'd in 
     * CurTransactionContext, we need not do that --- they'll go away 
     * automatically at transaction exit.  We need only reset the list head 
     * pointers. 
     */ 
</span>    <a href="async.c.html#LN318"><span class='Ref_to_Global_Var'>pendingActions</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="async.c.html#LN344"><span class='Ref_to_Global_Var'>pendingNotifies</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
} 
</span></pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>