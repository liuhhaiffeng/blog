<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\commands\cluster.c</title>
<LINK REL=StyleSheet HREF="../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\commands\cluster.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:34 2017
</td></tr>
<tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
</span><span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * cluster.c 
 *    CLUSTER a table on an index.  This is now also used for VACUUM FULL. 
 * 
 * There is hardly anything left of Paul Brown's original implementation... 
 * 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994-5, Regents of the University of California 
 * 
 * 
 * IDENTIFICATION 
 *    src/backend/commands/cluster.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"access/amapi.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/multixact.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/relscan.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/rewriteheap.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/transam.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/tuptoaster.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/xact.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/xlog.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_am.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/catalog.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/dependency.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/heap.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/index.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/namespace.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/objectaccess.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/toasting.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"commands/cluster.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"commands/tablecmds.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"commands/vacuum.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"miscadmin.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/planner.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/bufmgr.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/lmgr.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/predicate.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/smgr.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/acl.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/fmgroids.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/inval.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/lsyscache.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/memutils.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/pg_rusage.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/relmapper.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/snapmgr.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/syscache.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/tqual.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/tuplesort.h"</span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * This struct is used to pass around the information on tables to be 
 * clustered. We need this so we can make a list of them when invoked without 
 * a specific table/index pair. 
 */ 
</span><span class='Control'>typedef</span> <span class='Control'>struct</span> 
<span class='Delimiter'>{ 
</span><a name="LN64"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>tableOid</span><span class='Delimiter'>; 
</span><a name="LN65"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>indexOid</span><span class='Delimiter'>; 
</span><a name="LN66"></a>} <span class='Declare_Typedef'>RelToCluster</span><span class='Delimiter'>; 
</span> 
 
<a name="LN69"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>rebuild_relation</span><span class='Parentheses'>(</span><a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>OldHeap</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>indexOid</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>verbose</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN70"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>copy_heap_data</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>OIDNewHeap</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>OIDOldHeap</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>OIDOldIndex</span><span class='Delimiter'>, 
</span><a name="LN71"></a>               <span class='Keyword'>bool </span><span class='Declare_Parameter'>verbose</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>pSwapToastByContent</span><span class='Delimiter'>, 
</span><a name="LN72"></a>               <a href="../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pFreezeXid</span><span class='Delimiter'>, </span><a href="../../include/c.h.html#LN406"><span class='Ref_to_Typedef'>MultiXactId</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pCutoffMulti</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN73"></a><span class='Keyword'>static </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>get_tables_to_cluster</span><span class='Parentheses'>(</span><a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Parameter'>cluster_context</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN74"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>reform_and_rewrite_tuple</span><span class='Parentheses'>(</span><a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a> <span class='Declare_Parameter'>tuple</span><span class='Delimiter'>, 
</span><a name="LN75"></a>                         <a href="../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a> <span class='Declare_Parameter'>oldTupDesc</span><span class='Delimiter'>, </span><a href="../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a> <span class='Declare_Parameter'>newTupDesc</span><span class='Delimiter'>, 
</span><a name="LN76"></a>                         <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>values</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>isnull</span><span class='Delimiter'>, 
</span><a name="LN77"></a>                         <span class='Keyword'>bool </span><span class='Declare_Parameter'>newRelHasOids</span><span class='Delimiter'>, </span><a href="../../include/access/rewriteheap.h.html#LN21"><span class='Ref_to_Typedef'>RewriteState</span></a> <span class='Declare_Parameter'>rwstate</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/*--------------------------------------------------------------------------- 
 * This cluster code allows for clustering multiple tables at once. Because 
 * of this, we cannot just run everything on a single transaction, or we 
 * would be forced to acquire exclusive locks on all the tables being 
 * clustered, simultaneously --- very likely leading to deadlock. 
 * 
 * To solve this we follow a similar strategy to VACUUM code, 
 * clustering each relation in a separate transaction. For this to work, 
 * we need to: 
 *  - provide a separate memory context so that we can pass information in 
 *    a way that survives across transactions 
 *  - start a new transaction every time a new relation is clustered 
 *  - check for validity of the information on to-be-clustered relations, 
 *    as someone might have deleted a relation behind our back, or 
 *    clustered one on a different index 
 *  - end the transaction 
 * 
 * The single-relation case does not have any such overhead. 
 * 
 * We also allow a relation to be specified without index.  In that case, 
 * the indisclustered bit will be looked up, and an ERROR will be thrown 
 * if there is no index with the bit set. 
 *--------------------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN105"></a><span class='Declare_Function'>cluster</span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN3044"><span class='Ref_to_Struct'>ClusterStmt</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stmt</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>isTopLevel</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN105"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN3047"><span class='Ref_to_Member'>relation</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* This is the single-relation case. */ 
</span><a name="LN110"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>tableOid</span><span class='Delimiter'>, 
</span><a name="LN111"></a>                    <span class='Declare_Local'>indexOid</span> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span><a name="LN112"></a>        <a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>rel</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Find, lock, and check permissions on the table */ 
</span>        <a href="cluster.c.html#LN110"><span class='Ref_To_Local'>tableOid</span></a> <span class='Operator'>= </span><a href="../../include/catalog/namespace.h.html#LN55"><span class='Ref_to_Proto'>RangeVarGetRelidExtended</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN105"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN3047"><span class='Ref_to_Member'>relation</span></a><span class='Delimiter'>, 
</span>                                            <a href="../../include/storage/lockdefs.h.html#LN45"><span class='Ref_to_Const'>AccessExclusiveLock</span></a><span class='Delimiter'>, 
</span>                                            <span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                                            <a href="../../include/commands/tablecmds.h.html#LN84"><span class='Ref_to_Proto'>RangeVarCallbackOwnsTable</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="cluster.c.html#LN112"><span class='Ref_To_Local'>rel</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN91"><span class='Ref_to_Proto'>heap_open</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN110"><span class='Ref_To_Local'>tableOid</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN33"><span class='Ref_to_Const'>NoLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Reject clustering a remote temp table ... their local buffer 
         * manager is not going to cope. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/utils/rel.h.html#LN533"><span class='Ref_to_Macro'>RELATION_IS_OTHER_TEMP</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN112"><span class='Ref_To_Local'>rel</span></a><span class='Parentheses'>))</span> 
            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>               <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"cannot cluster temporary tables of other sessions"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN105"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN3048"><span class='Ref_to_Member'>indexname</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN132"></a>            <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>index</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* We need to find the index that has indisclustered set. */ 
</span>            <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN132"><span class='Ref_To_Local'>index</span></a><span class='Delimiter'>, </span><a href="../../include/utils/relcache.h.html#LN40"><span class='Ref_to_Proto'>RelationGetIndexList</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN112"><span class='Ref_To_Local'>rel</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span><a name="LN137"></a>                <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>idxtuple</span><span class='Delimiter'>; 
</span><a name="LN138"></a>                <a href="../../include/catalog/pg_index.h.html#LN66"><span class='Ref_to_Typedef'>Form_pg_index</span></a> <span class='Declare_Local'>indexForm</span><span class='Delimiter'>; 
</span> 
                <a href="cluster.c.html#LN111"><span class='Ref_To_Local'>indexOid</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN107"><span class='Ref_to_Macro'>lfirst_oid</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN132"><span class='Ref_To_Local'>index</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="cluster.c.html#LN137"><span class='Ref_To_Local'>idxtuple</span></a> <span class='Operator'>= </span><a href="../../include/utils/syscache.h.html#LN155"><span class='Ref_to_Macro'>SearchSysCache1</span></a><span class='Parentheses'>(</span><a href="../../include/utils/syscache.h.html#LN65"><span class='Ref_to_EnumConst'>INDEXRELID</span></a><span class='Delimiter'>, 
</span>                                           <a href="../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN111"><span class='Ref_To_Local'>indexOid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN137"><span class='Ref_To_Local'>idxtuple</span></a><span class='Parentheses'>))</span> 
                    <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cache lookup failed for index %u"</span><span class='Delimiter'>, </span><a href="cluster.c.html#LN111"><span class='Ref_To_Local'>indexOid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="cluster.c.html#LN138"><span class='Ref_To_Local'>indexForm</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/catalog/pg_index.h.html#LN66"><span class='Ref_to_Typedef'>Form_pg_index</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN137"><span class='Ref_To_Local'>idxtuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN138"><span class='Ref_To_Local'>indexForm</span></a><span class='Operator'>-&GT;</span>indisclustered<span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <a href="../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN137"><span class='Ref_To_Local'>idxtuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <a href="../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN137"><span class='Ref_To_Local'>idxtuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="cluster.c.html#LN111"><span class='Ref_To_Local'>indexOid</span></a> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN111"><span class='Ref_To_Local'>indexOid</span></a><span class='Parentheses'>))</span> 
                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_UNDEFINED_OBJECT<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"there is no previously clustered index for table \"%s\""</span><span class='Delimiter'>, 
</span>                                <a href="cluster.c.html#LN105"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN3047"><span class='Ref_to_Member'>relation</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN67"><span class='Ref_to_Member'>relname</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if stmt-&GT;indexname==NULL &raquo; </span> 
        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * The index is expected to be in the same namespace as the 
             * relation. 
             */ 
</span>            <a href="cluster.c.html#LN111"><span class='Ref_To_Local'>indexOid</span></a> <span class='Operator'>= </span><a href="../../include/utils/lsyscache.h.html#LN123"><span class='Ref_to_Proto'>get_relname_relid</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN105"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN3048"><span class='Ref_to_Member'>indexname</span></a><span class='Delimiter'>, 
</span>                                         <a href="cluster.c.html#LN112"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relnamespace<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN111"><span class='Ref_To_Local'>indexOid</span></a><span class='Parentheses'>))</span> 
                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_UNDEFINED_OBJECT<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                       <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"index \"%s\" for table \"%s\" does not exist"</span><span class='Delimiter'>, 
</span>                              <a href="cluster.c.html#LN105"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN3048"><span class='Ref_to_Member'>indexname</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN105"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN3047"><span class='Ref_to_Member'>relation</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN67"><span class='Ref_to_Member'>relname</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* close relation, keep lock till commit */ 
</span>        <a href="../../include/access/heapam.h.html#LN96"><span class='Ref_to_Macro'>heap_close</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN112"><span class='Ref_To_Local'>rel</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN33"><span class='Ref_to_Const'>NoLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Do the job. */ 
</span>        <a href="../../include/commands/cluster.h.html#LN21"><span class='Ref_to_Proto'>cluster_rel</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN110"><span class='Ref_To_Local'>tableOid</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN111"><span class='Ref_To_Local'>indexOid</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><a href="cluster.c.html#LN105"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN3049"><span class='Ref_to_Member'>verbose</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if stmt-&GT;relation!=NULL &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * This is the "multi relation" case. We need to cluster all tables 
         * that have some index with indisclustered set. 
         */ 
</span><a name="LN188"></a>        <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>cluster_context</span><span class='Delimiter'>; 
</span><a name="LN189"></a>        <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>rvs</span><span class='Delimiter'>; 
</span><a name="LN190"></a>        <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>rv</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We cannot run this form of CLUSTER inside a user transaction block; 
         * we'd be holding locks way too long. 
         */ 
</span>        <a href="../../include/access/xact.h.html#LN370"><span class='Ref_to_Proto'>PreventTransactionChain</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN105"><span class='Ref_to_Parameter'>isTopLevel</span></a><span class='Delimiter'>, </span><span class='String'>"CLUSTER"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Create special memory context for cross-transaction storage. 
         * 
         * Since it is a child of PortalContext, it will go away even in case 
         * of error. 
         */ 
</span>        <a href="cluster.c.html#LN188"><span class='Ref_To_Local'>cluster_context</span></a> <span class='Operator'>= </span><a href="../../include/utils/memutils.h.html#LN145"><span class='Ref_to_Proto'>AllocSetContextCreate</span></a><span class='Parentheses'>(</span><a href="../utils/mmgr/mcxt.c.html#LN51"><span class='Ref_to_Global_Var'>PortalContext</span></a><span class='Delimiter'>, 
</span>                                                <span class='String'>"Cluster"</span><span class='Delimiter'>, 
</span>                                                <a href="../../include/utils/memutils.h.html#LN164"><span class='Ref_to_Const'>ALLOCSET_DEFAULT_SIZES</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Build the list of relations to cluster.  Note that this lives in 
         * cluster_context. 
         */ 
</span>        <a href="cluster.c.html#LN189"><span class='Ref_To_Local'>rvs</span></a> <span class='Operator'>= </span><a href="cluster.c.html#LN73"><span class='Ref_to_Proto'>get_tables_to_cluster</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN188"><span class='Ref_To_Local'>cluster_context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Commit to get out of starting transaction */ 
</span>        <a href="../../include/utils/snapmgr.h.html#LN76"><span class='Ref_to_Proto'>PopActiveSnapshot</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <a href="../../include/access/xact.h.html#LN349"><span class='Ref_to_Proto'>CommitTransactionCommand</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Ok, now that we've got them all, cluster them one by one */ 
</span>        <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN190"><span class='Ref_To_Local'>rv</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN189"><span class='Ref_To_Local'>rvs</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN221"></a>            <a href="cluster.c.html#LN62"><span class='Ref_to_Typedef'>RelToCluster</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rvtc</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="cluster.c.html#LN62"><span class='Ref_to_Typedef'>RelToCluster</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN190"><span class='Ref_To_Local'>rv</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Start a new transaction for each relation. */ 
</span>            <a href="../../include/access/xact.h.html#LN348"><span class='Ref_to_Proto'>StartTransactionCommand</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* functions in indexes may want a snapshot set */ 
</span>            <a href="../../include/utils/snapmgr.h.html#LN73"><span class='Ref_to_Proto'>PushActiveSnapshot</span></a><span class='Parentheses'>(</span><a href="../../include/utils/snapmgr.h.html#LN63"><span class='Ref_to_Proto'>GetTransactionSnapshot</span></a><span class='Parentheses'>())</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* Do the job. */ 
</span>            <a href="../../include/commands/cluster.h.html#LN21"><span class='Ref_to_Proto'>cluster_rel</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN221"><span class='Ref_To_Local'>rvtc</span></a><span class='Operator'>-&GT;</span><a href="cluster.c.html#LN64"><span class='Ref_to_Member'>tableOid</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN221"><span class='Ref_To_Local'>rvtc</span></a><span class='Operator'>-&GT;</span><a href="cluster.c.html#LN65"><span class='Ref_to_Member'>indexOid</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, </span><a href="cluster.c.html#LN105"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN3049"><span class='Ref_to_Member'>verbose</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../include/utils/snapmgr.h.html#LN76"><span class='Ref_to_Proto'>PopActiveSnapshot</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>            <a href="../../include/access/xact.h.html#LN349"><span class='Ref_to_Proto'>CommitTransactionCommand</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* Start a new transaction for the cleanup work. */ 
</span>        <a href="../../include/access/xact.h.html#LN348"><span class='Ref_to_Proto'>StartTransactionCommand</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Clean up working storage */ 
</span>        <a href="../../include/utils/memutils.h.html#LN74"><span class='Ref_to_Proto'>MemoryContextDelete</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN188"><span class='Ref_To_Local'>cluster_context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end cluster &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * cluster_rel 
 * 
 * This clusters the table by creating a new, clustered table and 
 * swapping the relfilenodes of the new table and the old table, so 
 * the OID of the original table is preserved.  Thus we do not lose 
 * GRANT, inheritance nor references to this table (this was a bug 
 * in releases through 7.3). 
 * 
 * Indexes are rebuilt too, via REINDEX. Since we are effectively bulk-loading 
 * the new table, it's better to create the indexes afterwards than to fill 
 * them incrementally while we load the table. 
 * 
 * If indexOid is InvalidOid, the table will be rewritten in physical order 
 * instead of index order.  This is the new implementation of VACUUM FULL, 
 * and error messages should refer to the operation as VACUUM not CLUSTER. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN259"></a><span class='Declare_Function'>cluster_rel</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>tableOid</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>indexOid</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>recheck</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>verbose</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN261"></a>    <a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>OldHeap</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Check for user-requested abort. */ 
</span>    <a href="../../include/miscadmin.h.html#LN99"><span class='Ref_to_Macro'>CHECK_FOR_INTERRUPTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We grab exclusive access to the target rel and index for the duration 
     * of the transaction.  (This is redundant for the single-transaction 
     * case, since cluster() already did it.)  The index lock is taken inside 
     * check_index_is_clusterable. 
     */ 
</span>    <a href="cluster.c.html#LN261"><span class='Ref_To_Local'>OldHeap</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN85"><span class='Ref_to_Proto'>try_relation_open</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN259"><span class='Ref_to_Parameter'>tableOid</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN45"><span class='Ref_to_Const'>AccessExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* If the table has gone away, we can skip processing it */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="cluster.c.html#LN261"><span class='Ref_To_Local'>OldHeap</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Since we may open a new transaction for each relation, we have to check 
     * that the relation still is what we think it is. 
     * 
     * If this is a single-transaction CLUSTER, we can skip these tests. We 
     * *must* skip the one on indisclustered since it would reject an attempt 
     * to cluster a not-previously-clustered index. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN259"><span class='Ref_to_Parameter'>recheck</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN288"></a>        <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>tuple</span><span class='Delimiter'>; 
</span><a name="LN289"></a>        <a href="../../include/catalog/pg_index.h.html#LN66"><span class='Ref_to_Typedef'>Form_pg_index</span></a> <span class='Declare_Local'>indexForm</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Check that the user still owns the relation */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/utils/acl.h.html#LN308"><span class='Ref_to_Proto'>pg_class_ownercheck</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN259"><span class='Ref_to_Parameter'>tableOid</span></a><span class='Delimiter'>, </span><a href="../utils/init/miscinit.c.html#LN281"><span class='Ref_to_Func'>GetUserId</span></a><span class='Parentheses'>()))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="../../include/access/heapam.h.html#LN89"><span class='Ref_to_Proto'>relation_close</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN261"><span class='Ref_To_Local'>OldHeap</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN45"><span class='Ref_to_Const'>AccessExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Silently skip a temp table for a remote session.  Only doing this 
         * check in the "recheck" case is appropriate (which currently means 
         * somebody is executing a database-wide CLUSTER), because there is 
         * another check in cluster() which will stop any attempt to cluster 
         * remote temp tables by name.  There is another check in cluster_rel 
         * which is redundant, but we leave it for extra safety. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/utils/rel.h.html#LN533"><span class='Ref_to_Macro'>RELATION_IS_OTHER_TEMP</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN261"><span class='Ref_To_Local'>OldHeap</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="../../include/access/heapam.h.html#LN89"><span class='Ref_to_Proto'>relation_close</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN261"><span class='Ref_To_Local'>OldHeap</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN45"><span class='Ref_to_Const'>AccessExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN259"><span class='Ref_to_Parameter'>indexOid</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Check that the index still exists 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/utils/syscache.h.html#LN173"><span class='Ref_to_Macro'>SearchSysCacheExists1</span></a><span class='Parentheses'>(</span><a href="../../include/utils/syscache.h.html#LN83"><span class='Ref_to_EnumConst'>RELOID</span></a><span class='Delimiter'>, </span><a href="../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN259"><span class='Ref_to_Parameter'>indexOid</span></a><span class='Parentheses'>)))</span> 
            <span class='Delimiter'>{ 
</span>                <a href="../../include/access/heapam.h.html#LN89"><span class='Ref_to_Proto'>relation_close</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN261"><span class='Ref_To_Local'>OldHeap</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN45"><span class='Ref_to_Const'>AccessExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>return</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Check that the index is still the one with indisclustered set. 
             */ 
</span>            <a href="cluster.c.html#LN288"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>= </span><a href="../../include/utils/syscache.h.html#LN155"><span class='Ref_to_Macro'>SearchSysCache1</span></a><span class='Parentheses'>(</span><a href="../../include/utils/syscache.h.html#LN65"><span class='Ref_to_EnumConst'>INDEXRELID</span></a><span class='Delimiter'>, </span><a href="../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN259"><span class='Ref_to_Parameter'>indexOid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN288"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>))</span>       <span class='Comment_Single_Line'>/* probably can't happen */ 
</span>            <span class='Delimiter'>{ 
</span>                <a href="../../include/access/heapam.h.html#LN89"><span class='Ref_to_Proto'>relation_close</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN261"><span class='Ref_To_Local'>OldHeap</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN45"><span class='Ref_to_Const'>AccessExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>return</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <a href="cluster.c.html#LN289"><span class='Ref_To_Local'>indexForm</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/catalog/pg_index.h.html#LN66"><span class='Ref_to_Typedef'>Form_pg_index</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN288"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="cluster.c.html#LN289"><span class='Ref_To_Local'>indexForm</span></a><span class='Operator'>-&GT;</span>indisclustered<span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN288"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="../../include/access/heapam.h.html#LN89"><span class='Ref_to_Proto'>relation_close</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN261"><span class='Ref_To_Local'>OldHeap</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN45"><span class='Ref_to_Const'>AccessExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>return</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <a href="../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN288"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if OidIsValid(indexOid) &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if recheck &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * We allow VACUUM FULL, but not CLUSTER, on shared catalogs.  CLUSTER 
     * would work in most respects, but the index would only get marked as 
     * indisclustered in the current database, leading to unexpected behavior 
     * if CLUSTER were later invoked in another database. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN259"><span class='Ref_to_Parameter'>indexOid</span></a><span class='Parentheses'>) </span><span class='Operator'>&& </span><a href="cluster.c.html#LN261"><span class='Ref_To_Local'>OldHeap</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relisshared<span class='Parentheses'>)</span> 
        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"cannot cluster a shared catalog"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Don't process temp tables of other backends ... their local buffer 
     * manager is not going to cope. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/utils/rel.h.html#LN533"><span class='Ref_to_Macro'>RELATION_IS_OTHER_TEMP</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN261"><span class='Ref_To_Local'>OldHeap</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN259"><span class='Ref_to_Parameter'>indexOid</span></a><span class='Parentheses'>))</span> 
            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>               <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"cannot cluster temporary tables of other sessions"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"cannot vacuum temporary tables of other sessions"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Also check for active uses of the relation in the current transaction, 
     * including open scans and pending AFTER trigger events. 
     */ 
</span>    <a href="../../include/commands/tablecmds.h.html#LN52"><span class='Ref_to_Proto'>CheckTableNotInUse</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN261"><span class='Ref_To_Local'>OldHeap</span></a><span class='Delimiter'>, </span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN259"><span class='Ref_to_Parameter'>indexOid</span></a><span class='Parentheses'>) </span><span class='Operator'>? </span><span class='String'>"CLUSTER"</span> <span class='Operator'>: </span><span class='String'>"VACUUM"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Check heap and index are valid to cluster on */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN259"><span class='Ref_to_Parameter'>indexOid</span></a><span class='Parentheses'>))</span> 
        <a href="../../include/commands/cluster.h.html#LN23"><span class='Ref_to_Proto'>check_index_is_clusterable</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN261"><span class='Ref_To_Local'>OldHeap</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN259"><span class='Ref_to_Parameter'>indexOid</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN259"><span class='Ref_to_Parameter'>recheck</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN45"><span class='Ref_to_Const'>AccessExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Quietly ignore the request if this is a materialized view which has not 
     * been populated from its query. No harm is done because there is no data 
     * to deal with, and we don't want to throw an error if this is part of a 
     * multi-relation request -- for example, CLUSTER was run on the entire 
     * database. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN261"><span class='Ref_To_Local'>OldHeap</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relkind <span class='Operator'>== </span><a href="../../include/catalog/pg_class.h.html#LN164"><span class='Ref_to_Const'>RELKIND_MATVIEW</span></a> <span class='Operator'>&& 
</span>        <span class='Operator'>!</span><a href="../../include/utils/rel.h.html#LN552"><span class='Ref_to_Macro'>RelationIsPopulated</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN261"><span class='Ref_To_Local'>OldHeap</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../include/access/heapam.h.html#LN89"><span class='Ref_to_Proto'>relation_close</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN261"><span class='Ref_To_Local'>OldHeap</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN45"><span class='Ref_to_Const'>AccessExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * All predicate locks on the tuples or pages are about to be made 
     * invalid, because we move tuples around.  Promote them to relation 
     * locks.  Predicate locks on indexes will be promoted when they are 
     * reindexed. 
     */ 
</span>    <a href="../../include/storage/predicate.h.html#LN55"><span class='Ref_to_Proto'>TransferPredicateLocksToHeapRelation</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN261"><span class='Ref_To_Local'>OldHeap</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* rebuild_relation does all the dirty work */ 
</span>    <a href="cluster.c.html#LN69"><span class='Ref_to_Proto'>rebuild_relation</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN261"><span class='Ref_To_Local'>OldHeap</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN259"><span class='Ref_to_Parameter'>indexOid</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN259"><span class='Ref_to_Parameter'>verbose</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* NB: rebuild_relation does heap_close() on OldHeap */ 
</span><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end cluster_rel &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Verify that the specified heap and index are valid to cluster on 
 * 
 * Side effect: obtains lock on the index.  The caller may 
 * in some cases already have AccessExclusiveLock on the table, but 
 * not in all cases so we can't rely on the table-level lock for 
 * protection here. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN417"></a><span class='Declare_Function'>check_index_is_clusterable</span><span class='Parentheses'>(</span><a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>OldHeap</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>indexOid</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>recheck</span><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN25"><span class='Ref_to_Typedef'>LOCKMODE</span></a> <span class='Declare_Parameter'>lockmode</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN419"></a>    <a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>OldIndex</span><span class='Delimiter'>; 
</span> 
    <a href="cluster.c.html#LN419"><span class='Ref_To_Local'>OldIndex</span></a> <span class='Operator'>= </span><a href="../../include/access/genam.h.html#LN129"><span class='Ref_to_Proto'>index_open</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN417"><span class='Ref_to_Parameter'>indexOid</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN417"><span class='Ref_to_Parameter'>lockmode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Check that index is in fact an index on the given relation 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN419"><span class='Ref_To_Local'>OldIndex</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN158"><span class='Ref_to_Member'>rd_index</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>|| 
</span>        <a href="cluster.c.html#LN419"><span class='Ref_To_Local'>OldIndex</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN158"><span class='Ref_to_Member'>rd_index</span></a><span class='Operator'>-&GT;</span>indrelid <span class='Operator'>!= </span><a href="../../include/utils/rel.h.html#LN416"><span class='Ref_to_Macro'>RelationGetRelid</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN417"><span class='Ref_to_Parameter'>OldHeap</span></a><span class='Parentheses'>))</span> 
        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_WRONG_OBJECT_TYPE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"\"%s\" is not an index for table \"%s\""</span><span class='Delimiter'>, 
</span>                        <a href="../../include/utils/rel.h.html#LN436"><span class='Ref_to_Macro'>RelationGetRelationName</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN419"><span class='Ref_To_Local'>OldIndex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                        <a href="../../include/utils/rel.h.html#LN436"><span class='Ref_to_Macro'>RelationGetRelationName</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN417"><span class='Ref_to_Parameter'>OldHeap</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Index AM must allow clustering */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="cluster.c.html#LN419"><span class='Ref_To_Local'>OldIndex</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN180"><span class='Ref_to_Member'>rd_amroutine</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/amapi.h.html#LN188"><span class='Ref_to_Member'>amclusterable</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"cannot cluster on index \"%s\" because access method does not support clustering"</span><span class='Delimiter'>, 
</span>                        <a href="../../include/utils/rel.h.html#LN436"><span class='Ref_to_Macro'>RelationGetRelationName</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN419"><span class='Ref_To_Local'>OldIndex</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Disallow clustering on incomplete indexes (those that might not index 
     * every row of the relation).  We could relax this by making a separate 
     * seqscan pass over the table to copy the missing rows, but that seems 
     * expensive and tedious. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../access/common/heaptuple.c.html#LN295"><span class='Ref_to_Func'>heap_attisnull</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN419"><span class='Ref_To_Local'>OldIndex</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN160"><span class='Ref_to_Member'>rd_indextuple</span></a><span class='Delimiter'>, </span><a href="../../include/catalog/pg_index.h.html#LN91"><span class='Ref_to_Const'>Anum_pg_index_indpred</span></a><span class='Parentheses'>))</span> 
        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"cannot cluster on partial index \"%s\""</span><span class='Delimiter'>, 
</span>                        <a href="../../include/utils/rel.h.html#LN436"><span class='Ref_to_Macro'>RelationGetRelationName</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN419"><span class='Ref_To_Local'>OldIndex</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Disallow if index is left over from a failed CREATE INDEX CONCURRENTLY; 
     * it might well not contain entries for every heap row, or might not even 
     * be internally consistent.  (But note that we don't check indcheckxmin; 
     * the worst consequence of following broken HOT chains would be that we 
     * might put recently-dead tuples out-of-order in the new table, and there 
     * is little harm in that.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/catalog/pg_index.h.html#LN106"><span class='Ref_to_Macro'>IndexIsValid</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN419"><span class='Ref_To_Local'>OldIndex</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN158"><span class='Ref_to_Member'>rd_index</span></a><span class='Parentheses'>))</span> 
        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"cannot cluster on invalid index \"%s\""</span><span class='Delimiter'>, 
</span>                        <a href="../../include/utils/rel.h.html#LN436"><span class='Ref_to_Macro'>RelationGetRelationName</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN419"><span class='Ref_To_Local'>OldIndex</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Drop relcache refcnt on OldIndex, but keep lock */ 
</span>    <a href="../../include/access/genam.h.html#LN130"><span class='Ref_to_Proto'>index_close</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN419"><span class='Ref_To_Local'>OldIndex</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN33"><span class='Ref_to_Const'>NoLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end check_index_is_clusterable &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * mark_index_clustered: mark the specified index as the one clustered on 
 * 
 * With indexOid == InvalidOid, will mark all indexes of rel not-clustered. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN477"></a><span class='Declare_Function'>mark_index_clustered</span><span class='Parentheses'>(</span><a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>rel</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>indexOid</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>is_internal</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN479"></a>    <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>indexTuple</span><span class='Delimiter'>; 
</span><a name="LN480"></a>    <a href="../../include/catalog/pg_index.h.html#LN66"><span class='Ref_to_Typedef'>Form_pg_index</span></a> <span class='Declare_Local'>indexForm</span><span class='Delimiter'>; 
</span><a name="LN481"></a>    <a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>pg_index</span><span class='Delimiter'>; 
</span><a name="LN482"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>index</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the index is already marked clustered, no need to do anything. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN477"><span class='Ref_to_Parameter'>indexOid</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="cluster.c.html#LN479"><span class='Ref_To_Local'>indexTuple</span></a> <span class='Operator'>= </span><a href="../../include/utils/syscache.h.html#LN155"><span class='Ref_to_Macro'>SearchSysCache1</span></a><span class='Parentheses'>(</span><a href="../../include/utils/syscache.h.html#LN65"><span class='Ref_to_EnumConst'>INDEXRELID</span></a><span class='Delimiter'>, </span><a href="../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN477"><span class='Ref_to_Parameter'>indexOid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN479"><span class='Ref_To_Local'>indexTuple</span></a><span class='Parentheses'>))</span> 
            <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cache lookup failed for index %u"</span><span class='Delimiter'>, </span><a href="cluster.c.html#LN477"><span class='Ref_to_Parameter'>indexOid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="cluster.c.html#LN480"><span class='Ref_To_Local'>indexForm</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/catalog/pg_index.h.html#LN66"><span class='Ref_to_Typedef'>Form_pg_index</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN479"><span class='Ref_To_Local'>indexTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN480"><span class='Ref_To_Local'>indexForm</span></a><span class='Operator'>-&GT;</span>indisclustered<span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN479"><span class='Ref_To_Local'>indexTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN479"><span class='Ref_To_Local'>indexTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Check each index of the relation and set/clear the bit as needed. 
     */ 
</span>    <a href="cluster.c.html#LN481"><span class='Ref_To_Local'>pg_index</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN91"><span class='Ref_to_Proto'>heap_open</span></a><span class='Parentheses'>(</span><a href="../../include/catalog/pg_index.h.html#LN28"><span class='Ref_to_Const'>IndexRelationId</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN37"><span class='Ref_to_Const'>RowExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN482"><span class='Ref_To_Local'>index</span></a><span class='Delimiter'>, </span><a href="../../include/utils/relcache.h.html#LN40"><span class='Ref_to_Proto'>RelationGetIndexList</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN477"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN510"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>thisIndexOid</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN107"><span class='Ref_to_Macro'>lfirst_oid</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN482"><span class='Ref_To_Local'>index</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="cluster.c.html#LN479"><span class='Ref_To_Local'>indexTuple</span></a> <span class='Operator'>= </span><a href="../../include/utils/syscache.h.html#LN164"><span class='Ref_to_Macro'>SearchSysCacheCopy1</span></a><span class='Parentheses'>(</span><a href="../../include/utils/syscache.h.html#LN65"><span class='Ref_to_EnumConst'>INDEXRELID</span></a><span class='Delimiter'>, 
</span>                                         <a href="../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN510"><span class='Ref_To_Local'>thisIndexOid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN479"><span class='Ref_To_Local'>indexTuple</span></a><span class='Parentheses'>))</span> 
            <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cache lookup failed for index %u"</span><span class='Delimiter'>, </span><a href="cluster.c.html#LN510"><span class='Ref_To_Local'>thisIndexOid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="cluster.c.html#LN480"><span class='Ref_To_Local'>indexForm</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/catalog/pg_index.h.html#LN66"><span class='Ref_to_Typedef'>Form_pg_index</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN479"><span class='Ref_To_Local'>indexTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Unset the bit if set.  We know it's wrong because we checked this 
         * earlier. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN480"><span class='Ref_To_Local'>indexForm</span></a><span class='Operator'>-&GT;</span>indisclustered<span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="cluster.c.html#LN480"><span class='Ref_To_Local'>indexForm</span></a><span class='Operator'>-&GT;</span>indisclustered <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="../../include/catalog/indexing.h.html#LN35"><span class='Ref_to_Proto'>CatalogTupleUpdate</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN481"><span class='Ref_To_Local'>pg_index</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="cluster.c.html#LN479"><span class='Ref_To_Local'>indexTuple</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/htup.h.html#LN64"><span class='Ref_to_Member'>t_self</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN479"><span class='Ref_To_Local'>indexTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN510"><span class='Ref_To_Local'>thisIndexOid</span></a> <span class='Operator'>== </span><a href="cluster.c.html#LN477"><span class='Ref_to_Parameter'>indexOid</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* this was checked earlier, but let's be real sure */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/catalog/pg_index.h.html#LN106"><span class='Ref_to_Macro'>IndexIsValid</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN480"><span class='Ref_To_Local'>indexForm</span></a><span class='Parentheses'>))</span> 
                <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cannot cluster on invalid index %u"</span><span class='Delimiter'>, </span><a href="cluster.c.html#LN477"><span class='Ref_to_Parameter'>indexOid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="cluster.c.html#LN480"><span class='Ref_To_Local'>indexForm</span></a><span class='Operator'>-&GT;</span>indisclustered <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <a href="../../include/catalog/indexing.h.html#LN35"><span class='Ref_to_Proto'>CatalogTupleUpdate</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN481"><span class='Ref_To_Local'>pg_index</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="cluster.c.html#LN479"><span class='Ref_To_Local'>indexTuple</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/htup.h.html#LN64"><span class='Ref_to_Member'>t_self</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN479"><span class='Ref_To_Local'>indexTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="../../include/catalog/objectaccess.h.html#LN165"><span class='Ref_to_Macro'>InvokeObjectPostAlterHookArg</span></a><span class='Parentheses'>(</span><a href="../../include/catalog/pg_index.h.html#LN28"><span class='Ref_to_Const'>IndexRelationId</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN510"><span class='Ref_To_Local'>thisIndexOid</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, 
</span>                                     <a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN477"><span class='Ref_to_Parameter'>is_internal</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/access/htup_details.h.html#LN815"><span class='Ref_to_Proto'>heap_freetuple</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN479"><span class='Ref_To_Local'>indexTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../include/access/heapam.h.html#LN96"><span class='Ref_to_Macro'>heap_close</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN481"><span class='Ref_To_Local'>pg_index</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN37"><span class='Ref_to_Const'>RowExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end mark_index_clustered &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * rebuild_relation: rebuild an existing relation in index or physical order 
 * 
 * OldHeap: table to rebuild --- must be opened and exclusive-locked! 
 * indexOid: index to cluster by, or InvalidOid to rewrite in physical order. 
 * 
 * NB: this routine closes OldHeap at the right time; caller should not. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN554"></a><span class='Declare_Function'>rebuild_relation</span><span class='Parentheses'>(</span><a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>OldHeap</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>indexOid</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>verbose</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN556"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>tableOid</span> <span class='Operator'>= </span><a href="../../include/utils/rel.h.html#LN416"><span class='Ref_to_Macro'>RelationGetRelid</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN554"><span class='Ref_to_Parameter'>OldHeap</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN557"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>tableSpace</span> <span class='Operator'>= </span><a href="cluster.c.html#LN554"><span class='Ref_to_Parameter'>OldHeap</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>reltablespace<span class='Delimiter'>; 
</span><a name="LN558"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>OIDNewHeap</span><span class='Delimiter'>; 
</span><a name="LN559"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>relpersistence</span><span class='Delimiter'>; 
</span><a name="LN560"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>is_system_catalog</span><span class='Delimiter'>; 
</span><a name="LN561"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>swap_toast_by_content</span><span class='Delimiter'>; 
</span><a name="LN562"></a>    <a href="../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>frozenXid</span><span class='Delimiter'>; 
</span><a name="LN563"></a>    <a href="../../include/c.h.html#LN406"><span class='Ref_to_Typedef'>MultiXactId</span></a> <span class='Declare_Local'>cutoffMulti</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Mark the correct index as clustered */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN554"><span class='Ref_to_Parameter'>indexOid</span></a><span class='Parentheses'>))</span> 
        <a href="../../include/commands/cluster.h.html#LN25"><span class='Ref_to_Proto'>mark_index_clustered</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN554"><span class='Ref_to_Parameter'>OldHeap</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN554"><span class='Ref_to_Parameter'>indexOid</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Remember info about rel before closing OldHeap */ 
</span>    <a href="cluster.c.html#LN559"><span class='Ref_To_Local'>relpersistence</span></a> <span class='Operator'>= </span><a href="cluster.c.html#LN554"><span class='Ref_to_Parameter'>OldHeap</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relpersistence<span class='Delimiter'>; 
</span>    <a href="cluster.c.html#LN560"><span class='Ref_To_Local'>is_system_catalog</span></a> <span class='Operator'>= </span><a href="../../include/catalog/catalog.h.html#LN29"><span class='Ref_to_Proto'>IsSystemRelation</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN554"><span class='Ref_to_Parameter'>OldHeap</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Close relcache entry, but keep lock until transaction commit */ 
</span>    <a href="../../include/access/heapam.h.html#LN96"><span class='Ref_to_Macro'>heap_close</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN554"><span class='Ref_to_Parameter'>OldHeap</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN33"><span class='Ref_to_Const'>NoLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Create the transient table that will receive the re-ordered data */ 
</span>    <a href="cluster.c.html#LN558"><span class='Ref_To_Local'>OIDNewHeap</span></a> <span class='Operator'>= </span><a href="../../include/commands/cluster.h.html#LN27"><span class='Ref_to_Proto'>make_new_heap</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN556"><span class='Ref_To_Local'>tableOid</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN557"><span class='Ref_To_Local'>tableSpace</span></a><span class='Delimiter'>, 
</span>                               <a href="cluster.c.html#LN559"><span class='Ref_To_Local'>relpersistence</span></a><span class='Delimiter'>, 
</span>                               <a href="../../include/storage/lockdefs.h.html#LN45"><span class='Ref_to_Const'>AccessExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Copy the heap data into the new table in the desired order */ 
</span>    <a href="cluster.c.html#LN70"><span class='Ref_to_Proto'>copy_heap_data</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN558"><span class='Ref_To_Local'>OIDNewHeap</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN556"><span class='Ref_To_Local'>tableOid</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN554"><span class='Ref_to_Parameter'>indexOid</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN554"><span class='Ref_to_Parameter'>verbose</span></a><span class='Delimiter'>, 
</span>                   <span class='Operator'>&</span><a href="cluster.c.html#LN561"><span class='Ref_To_Local'>swap_toast_by_content</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="cluster.c.html#LN562"><span class='Ref_To_Local'>frozenXid</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="cluster.c.html#LN563"><span class='Ref_To_Local'>cutoffMulti</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Swap the physical files of the target and transient tables, then 
     * rebuild the target's indexes and throw away the transient table. 
     */ 
</span>    <a href="../../include/commands/cluster.h.html#LN29"><span class='Ref_to_Proto'>finish_heap_swap</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN556"><span class='Ref_To_Local'>tableOid</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN558"><span class='Ref_To_Local'>OIDNewHeap</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN560"><span class='Ref_To_Local'>is_system_catalog</span></a><span class='Delimiter'>, 
</span>                     <a href="cluster.c.html#LN561"><span class='Ref_To_Local'>swap_toast_by_content</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, 
</span>                     <a href="cluster.c.html#LN562"><span class='Ref_To_Local'>frozenXid</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN563"><span class='Ref_To_Local'>cutoffMulti</span></a><span class='Delimiter'>, 
</span>                     <a href="cluster.c.html#LN559"><span class='Ref_To_Local'>relpersistence</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end rebuild_relation &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * Create the transient table that will be filled with new data during 
 * CLUSTER, ALTER TABLE, and similar operations.  The transient table 
 * duplicates the logical structure of the OldHeap, but is placed in 
 * NewTableSpace which might be different from OldHeap's.  Also, it's built 
 * with the specified persistence, which might differ from the original's. 
 * 
 * After this, the caller should load the new heap with transferred/modified 
 * data, then call finish_heap_swap to complete the operation. 
 */ 
</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> 
<a name="LN607"></a><span class='Declare_Function'>make_new_heap</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>OIDOldHeap</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>NewTableSpace</span><span class='Delimiter'>, </span><span class='Keyword'>char </span><span class='Declare_Parameter'>relpersistence</span><span class='Delimiter'>, 
</span><a name="LN608"></a>              <a href="../../include/storage/lockdefs.h.html#LN25"><span class='Ref_to_Typedef'>LOCKMODE</span></a> <span class='Declare_Parameter'>lockmode</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN610"></a>    <a href="../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a>   <span class='Declare_Local'>OldHeapDesc</span><span class='Delimiter'>; 
</span><a name="LN611"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>NewHeapName</span><span class='Delimiter'>[</span><a href="../../interfaces/ecpg/include/sqlda-native.h.html#LN15"><span class='Ref_to_Const'>NAMEDATALEN</span></a><span class='Delimiter'>]; 
</span><a name="LN612"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>OIDNewHeap</span><span class='Delimiter'>; 
</span><a name="LN613"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>toastid</span><span class='Delimiter'>; 
</span><a name="LN614"></a>    <a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>OldHeap</span><span class='Delimiter'>; 
</span><a name="LN615"></a>    <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>tuple</span><span class='Delimiter'>; 
</span><a name="LN616"></a>    <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>reloptions</span><span class='Delimiter'>; 
</span><a name="LN617"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>isNull</span><span class='Delimiter'>; 
</span><a name="LN618"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>namespaceid</span><span class='Delimiter'>; 
</span> 
    <a href="cluster.c.html#LN614"><span class='Ref_To_Local'>OldHeap</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN91"><span class='Ref_to_Proto'>heap_open</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN607"><span class='Ref_to_Parameter'>OIDOldHeap</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN608"><span class='Ref_to_Parameter'>lockmode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="cluster.c.html#LN610"><span class='Ref_To_Local'>OldHeapDesc</span></a> <span class='Operator'>= </span><a href="../../include/utils/rel.h.html#LN428"><span class='Ref_to_Macro'>RelationGetDescr</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN614"><span class='Ref_To_Local'>OldHeap</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Note that the NewHeap will not receive any of the defaults or 
     * constraints associated with the OldHeap; we don't need 'em, and there's 
     * no reason to spend cycles inserting them into the catalogs only to 
     * delete them. 
     */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * But we do want to use reloptions of the old heap for new heap. 
     */ 
</span>    <a href="cluster.c.html#LN615"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>= </span><a href="../../include/utils/syscache.h.html#LN155"><span class='Ref_to_Macro'>SearchSysCache1</span></a><span class='Parentheses'>(</span><a href="../../include/utils/syscache.h.html#LN83"><span class='Ref_to_EnumConst'>RELOID</span></a><span class='Delimiter'>, </span><a href="../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN607"><span class='Ref_to_Parameter'>OIDOldHeap</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN615"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>))</span> 
        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cache lookup failed for relation %u"</span><span class='Delimiter'>, </span><a href="cluster.c.html#LN607"><span class='Ref_to_Parameter'>OIDOldHeap</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="cluster.c.html#LN616"><span class='Ref_To_Local'>reloptions</span></a> <span class='Operator'>= </span><a href="../../include/utils/syscache.h.html#LN133"><span class='Ref_to_Proto'>SysCacheGetAttr</span></a><span class='Parentheses'>(</span><a href="../../include/utils/syscache.h.html#LN83"><span class='Ref_to_EnumConst'>RELOID</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN615"><span class='Ref_To_Local'>tuple</span></a><span class='Delimiter'>, </span><a href="../../include/catalog/pg_class.h.html#LN133"><span class='Ref_to_Const'>Anum_pg_class_reloptions</span></a><span class='Delimiter'>, 
</span>                                 <span class='Operator'>&</span><a href="cluster.c.html#LN617"><span class='Ref_To_Local'>isNull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN617"><span class='Ref_To_Local'>isNull</span></a><span class='Parentheses'>) 
</span>        <a href="cluster.c.html#LN616"><span class='Ref_To_Local'>reloptions</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN607"><span class='Ref_to_Parameter'>relpersistence</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_class.h.html#LN171"><span class='Ref_to_Const'>RELPERSISTENCE_TEMP</span></a><span class='Parentheses'>) 
</span>        <a href="cluster.c.html#LN618"><span class='Ref_To_Local'>namespaceid</span></a> <span class='Operator'>= </span><a href="../../include/catalog/namespace.h.html#LN116"><span class='Ref_to_Proto'>LookupCreationNamespace</span></a><span class='Parentheses'>(</span><span class='String'>"pg_temp"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="cluster.c.html#LN618"><span class='Ref_To_Local'>namespaceid</span></a> <span class='Operator'>= </span><a href="../../include/utils/rel.h.html#LN443"><span class='Ref_to_Macro'>RelationGetNamespace</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN614"><span class='Ref_To_Local'>OldHeap</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Create the new heap, using a temporary name in the same namespace as 
     * the existing table.  NOTE: there is some risk of collision with user 
     * relnames.  Working around this seems more trouble than it's worth; in 
     * particular, we can't create the new heap in a different namespace from 
     * the old, or we will have problems with the TEMP status of temp tables. 
     * 
     * Note: the new heap is not a shared relation, even if we are rebuilding 
     * a shared rel.  However, we do make the new heap mapped if the source is 
     * mapped.  This simplifies swap_relation_files, and is absolutely 
     * necessary for rebuilding pg_class, for reasons explained there. 
     */ 
</span>    <a href="../../pl/plperl/plperl.h.html#LN60"><span class='Ref_to_Macro'>snprintf</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN611"><span class='Ref_To_Local'>NewHeapName</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="cluster.c.html#LN611"><span class='Ref_To_Local'>NewHeapName</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='String'>"pg_temp_%u"</span><span class='Delimiter'>, </span><a href="cluster.c.html#LN607"><span class='Ref_to_Parameter'>OIDOldHeap</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="cluster.c.html#LN612"><span class='Ref_To_Local'>OIDNewHeap</span></a> <span class='Operator'>= </span><a href="../../include/catalog/heap.h.html#LN53"><span class='Ref_to_Proto'>heap_create_with_catalog</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN611"><span class='Ref_To_Local'>NewHeapName</span></a><span class='Delimiter'>, 
</span>                                          <a href="cluster.c.html#LN618"><span class='Ref_To_Local'>namespaceid</span></a><span class='Delimiter'>, 
</span>                                          <a href="cluster.c.html#LN607"><span class='Ref_to_Parameter'>NewTableSpace</span></a><span class='Delimiter'>, 
</span>                                          <a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, 
</span>                                          <a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, 
</span>                                          <a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, 
</span>                                          <a href="cluster.c.html#LN614"><span class='Ref_To_Local'>OldHeap</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relowner<span class='Delimiter'>, 
</span>                                          <a href="cluster.c.html#LN610"><span class='Ref_To_Local'>OldHeapDesc</span></a><span class='Delimiter'>, 
</span>                                          <a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>, 
</span>                                          <a href="../../include/catalog/pg_class.h.html#LN159"><span class='Ref_to_Const'>RELKIND_RELATION</span></a><span class='Delimiter'>, 
</span>                                          <a href="cluster.c.html#LN607"><span class='Ref_to_Parameter'>relpersistence</span></a><span class='Delimiter'>, 
</span>                                          <span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                                          <a href="../../include/utils/rel.h.html#LN453"><span class='Ref_to_Macro'>RelationIsMapped</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN614"><span class='Ref_To_Local'>OldHeap</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                          <span class='Boolean'>true</span><span class='Delimiter'>, 
</span>                                          <span class='Number'>0</span><span class='Delimiter'>, 
</span>                                          <a href="../../include/nodes/primnodes.h.html#LN48"><span class='Ref_to_EnumConst'>ONCOMMIT_NOOP</span></a><span class='Delimiter'>, 
</span>                                          <a href="cluster.c.html#LN616"><span class='Ref_To_Local'>reloptions</span></a><span class='Delimiter'>, 
</span>                                          <span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                                          <span class='Boolean'>true</span><span class='Delimiter'>, 
</span>                                          <span class='Boolean'>true</span><span class='Delimiter'>, 
</span>                                          <span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="cluster.c.html#LN612"><span class='Ref_To_Local'>OIDNewHeap</span></a> <span class='Operator'>!= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN615"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Advance command counter so that the newly-created relation's catalog 
     * tuples will be visible to heap_open. 
     */ 
</span>    <a href="../../include/access/xact.h.html#LN346"><span class='Ref_to_Proto'>CommandCounterIncrement</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If necessary, create a TOAST table for the new relation. 
     * 
     * If the relation doesn't have a TOAST table already, we can't need one 
     * for the new relation.  The other way around is possible though: if some 
     * wide columns have been dropped, NewHeapCreateToastTable can decide that 
     * no TOAST table is needed for the new table. 
     * 
     * Note that NewHeapCreateToastTable ends with CommandCounterIncrement, so 
     * that the TOAST table will be visible for insertion. 
     */ 
</span>    <a href="cluster.c.html#LN613"><span class='Ref_To_Local'>toastid</span></a> <span class='Operator'>= </span><a href="cluster.c.html#LN614"><span class='Ref_To_Local'>OldHeap</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>reltoastrelid<span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN613"><span class='Ref_To_Local'>toastid</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* keep the existing toast table's reloptions, if any */ 
</span>        <a href="cluster.c.html#LN615"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>= </span><a href="../../include/utils/syscache.h.html#LN155"><span class='Ref_to_Macro'>SearchSysCache1</span></a><span class='Parentheses'>(</span><a href="../../include/utils/syscache.h.html#LN83"><span class='Ref_to_EnumConst'>RELOID</span></a><span class='Delimiter'>, </span><a href="../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN613"><span class='Ref_To_Local'>toastid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN615"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>))</span> 
            <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cache lookup failed for relation %u"</span><span class='Delimiter'>, </span><a href="cluster.c.html#LN613"><span class='Ref_To_Local'>toastid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="cluster.c.html#LN616"><span class='Ref_To_Local'>reloptions</span></a> <span class='Operator'>= </span><a href="../../include/utils/syscache.h.html#LN133"><span class='Ref_to_Proto'>SysCacheGetAttr</span></a><span class='Parentheses'>(</span><a href="../../include/utils/syscache.h.html#LN83"><span class='Ref_to_EnumConst'>RELOID</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN615"><span class='Ref_To_Local'>tuple</span></a><span class='Delimiter'>, </span><a href="../../include/catalog/pg_class.h.html#LN133"><span class='Ref_to_Const'>Anum_pg_class_reloptions</span></a><span class='Delimiter'>, 
</span>                                     <span class='Operator'>&</span><a href="cluster.c.html#LN617"><span class='Ref_To_Local'>isNull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN617"><span class='Ref_To_Local'>isNull</span></a><span class='Parentheses'>) 
</span>            <a href="cluster.c.html#LN616"><span class='Ref_To_Local'>reloptions</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/catalog/toasting.h.html#LN22"><span class='Ref_to_Proto'>NewHeapCreateToastTable</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN612"><span class='Ref_To_Local'>OIDNewHeap</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN616"><span class='Ref_To_Local'>reloptions</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN608"><span class='Ref_to_Parameter'>lockmode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN615"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../include/access/heapam.h.html#LN96"><span class='Ref_to_Macro'>heap_close</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN614"><span class='Ref_To_Local'>OldHeap</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN33"><span class='Ref_to_Const'>NoLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="cluster.c.html#LN612"><span class='Ref_To_Local'>OIDNewHeap</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end make_new_heap &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Do the physical copying of heap data. 
 * 
 * There are three output parameters: 
 * *pSwapToastByContent is set true if toast tables must be swapped by content. 
 * *pFreezeXid receives the TransactionId used as freeze cutoff point. 
 * *pCutoffMulti receives the MultiXactId used as a cutoff point. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN733"></a><span class='Declare_Function'>copy_heap_data</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>OIDNewHeap</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>OIDOldHeap</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>OIDOldIndex</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>verbose</span><span class='Delimiter'>, 
</span><a name="LN734"></a>               <span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>pSwapToastByContent</span><span class='Delimiter'>, </span><a href="../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pFreezeXid</span><span class='Delimiter'>, 
</span><a name="LN735"></a>               <a href="../../include/c.h.html#LN406"><span class='Ref_to_Typedef'>MultiXactId</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pCutoffMulti</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN737"></a>    <a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>NewHeap</span><span class='Delimiter'>, 
</span><a name="LN738"></a>                <span class='Declare_Local'>OldHeap</span><span class='Delimiter'>, 
</span><a name="LN739"></a>                <span class='Declare_Local'>OldIndex</span><span class='Delimiter'>; 
</span><a name="LN740"></a>    <a href="../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a>   <span class='Declare_Local'>oldTupDesc</span><span class='Delimiter'>; 
</span><a name="LN741"></a>    <a href="../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a>   <span class='Declare_Local'>newTupDesc</span><span class='Delimiter'>; 
</span><a name="LN742"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>natts</span><span class='Delimiter'>; 
</span><a name="LN743"></a>    <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>values</span><span class='Delimiter'>; 
</span><a name="LN744"></a>    <span class='Keyword'>bool</span>       <span class='Operator'>*</span><span class='Declare_Local'>isnull</span><span class='Delimiter'>; 
</span><a name="LN745"></a>    <a href="../../include/access/genam.h.html#LN85"><span class='Ref_to_Typedef'>IndexScanDesc</span></a> <span class='Declare_Local'>indexScan</span><span class='Delimiter'>; 
</span><a name="LN746"></a>    <a href="../../include/access/heapam.h.html#LN99"><span class='Ref_to_Typedef'>HeapScanDesc</span></a> <span class='Declare_Local'>heapScan</span><span class='Delimiter'>; 
</span><a name="LN747"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>use_wal</span><span class='Delimiter'>; 
</span><a name="LN748"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>is_system_catalog</span><span class='Delimiter'>; 
</span><a name="LN749"></a>    <a href="../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>OldestXmin</span><span class='Delimiter'>; 
</span><a name="LN750"></a>    <a href="../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>FreezeXid</span><span class='Delimiter'>; 
</span><a name="LN751"></a>    <a href="../../include/c.h.html#LN406"><span class='Ref_to_Typedef'>MultiXactId</span></a> <span class='Declare_Local'>MultiXactCutoff</span><span class='Delimiter'>; 
</span><a name="LN752"></a>    <a href="../../include/access/rewriteheap.h.html#LN21"><span class='Ref_to_Typedef'>RewriteState</span></a> <span class='Declare_Local'>rwstate</span><span class='Delimiter'>; 
</span><a name="LN753"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>use_sort</span><span class='Delimiter'>; 
</span><a name="LN754"></a>    <a href="../utils/sort/tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tuplesort</span><span class='Delimiter'>; 
</span><a name="LN755"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>num_tuples</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>, 
</span><a name="LN756"></a>                <span class='Declare_Local'>tups_vacuumed</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>, 
</span><a name="LN757"></a>                <span class='Declare_Local'>tups_recently_dead</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN758"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>elevel</span> <span class='Operator'>= </span><a href="cluster.c.html#LN733"><span class='Ref_to_Parameter'>verbose</span></a> <span class='Operator'>? </span><a href="../../include/utils/elog.h.html#LN32"><span class='Ref_to_Const'>INFO</span></a> <span class='Operator'>: </span><a href="../../include/utils/elog.h.html#LN23"><span class='Ref_to_Const'>DEBUG2</span></a><span class='Delimiter'>; 
</span><a name="LN759"></a>    <a href="../../include/utils/pg_rusage.h.html#LN26"><span class='Ref_to_Struct'>PGRUsage</span></a>    <span class='Declare_Local'>ru0</span><span class='Delimiter'>; 
</span> 
    <a href="../utils/misc/pg_rusage.c.html#LN25"><span class='Ref_to_Func'>pg_rusage_init</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="cluster.c.html#LN759"><span class='Ref_To_Local'>ru0</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Open the relations we need. 
     */ 
</span>    <a href="cluster.c.html#LN737"><span class='Ref_To_Local'>NewHeap</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN91"><span class='Ref_to_Proto'>heap_open</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN733"><span class='Ref_to_Parameter'>OIDNewHeap</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN45"><span class='Ref_to_Const'>AccessExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="cluster.c.html#LN738"><span class='Ref_To_Local'>OldHeap</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN91"><span class='Ref_to_Proto'>heap_open</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN733"><span class='Ref_to_Parameter'>OIDOldHeap</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN45"><span class='Ref_to_Const'>AccessExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN733"><span class='Ref_to_Parameter'>OIDOldIndex</span></a><span class='Parentheses'>))</span> 
        <a href="cluster.c.html#LN739"><span class='Ref_To_Local'>OldIndex</span></a> <span class='Operator'>= </span><a href="../../include/access/genam.h.html#LN129"><span class='Ref_to_Proto'>index_open</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN733"><span class='Ref_to_Parameter'>OIDOldIndex</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN45"><span class='Ref_to_Const'>AccessExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="cluster.c.html#LN739"><span class='Ref_To_Local'>OldIndex</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Their tuple descriptors should be exactly alike, but here we only need 
     * assume that they have the same number of columns. 
     */ 
</span>    <a href="cluster.c.html#LN740"><span class='Ref_To_Local'>oldTupDesc</span></a> <span class='Operator'>= </span><a href="../../include/utils/rel.h.html#LN428"><span class='Ref_to_Macro'>RelationGetDescr</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN738"><span class='Ref_To_Local'>OldHeap</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="cluster.c.html#LN741"><span class='Ref_To_Local'>newTupDesc</span></a> <span class='Operator'>= </span><a href="../../include/utils/rel.h.html#LN428"><span class='Ref_to_Macro'>RelationGetDescr</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN737"><span class='Ref_To_Local'>NewHeap</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="cluster.c.html#LN741"><span class='Ref_To_Local'>newTupDesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/tupdesc.h.html#LN72"><span class='Ref_to_Member'>natts</span></a> <span class='Operator'>== </span><a href="cluster.c.html#LN740"><span class='Ref_To_Local'>oldTupDesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/tupdesc.h.html#LN72"><span class='Ref_to_Member'>natts</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Preallocate values/isnull arrays */ 
</span>    <a href="cluster.c.html#LN742"><span class='Ref_To_Local'>natts</span></a> <span class='Operator'>= </span><a href="cluster.c.html#LN741"><span class='Ref_To_Local'>newTupDesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/tupdesc.h.html#LN72"><span class='Ref_to_Member'>natts</span></a><span class='Delimiter'>; 
</span>    <a href="cluster.c.html#LN743"><span class='Ref_To_Local'>values</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN742"><span class='Ref_To_Local'>natts</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="cluster.c.html#LN744"><span class='Ref_To_Local'>isnull</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN742"><span class='Ref_To_Local'>natts</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>bool</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the OldHeap has a toast table, get lock on the toast table to keep 
     * it from being vacuumed.  This is needed because autovacuum processes 
     * toast tables independently of their main tables, with no lock on the 
     * latter.  If an autovacuum were to start on the toast table after we 
     * compute our OldestXmin below, it would use a later OldestXmin, and then 
     * possibly remove as DEAD toast tuples belonging to main tuples we think 
     * are only RECENTLY_DEAD.  Then we'd fail while trying to copy those 
     * tuples. 
     * 
     * We don't need to open the toast relation here, just lock it.  The lock 
     * will be held till end of transaction. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN738"><span class='Ref_To_Local'>OldHeap</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>reltoastrelid<span class='Parentheses'>) 
</span>        <a href="../../include/storage/lmgr.h.html#LN39"><span class='Ref_to_Proto'>LockRelationOid</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN738"><span class='Ref_To_Local'>OldHeap</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>reltoastrelid<span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN45"><span class='Ref_to_Const'>AccessExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We need to log the copied data in WAL iff WAL archiving/streaming is 
     * enabled AND it's a WAL-logged rel. 
     */ 
</span>    <a href="cluster.c.html#LN747"><span class='Ref_To_Local'>use_wal</span></a> <span class='Operator'>= </span><a href="../../include/access/xlog.h.html#LN144"><span class='Ref_to_Macro'>XLogIsNeeded</span></a><span class='Parentheses'>() </span><span class='Operator'>&& </span><a href="../../include/utils/rel.h.html#LN505"><span class='Ref_to_Macro'>RelationNeedsWAL</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN737"><span class='Ref_To_Local'>NewHeap</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* use_wal off requires smgr_targblock be initially invalid */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../include/utils/rel.h.html#LN488"><span class='Ref_to_Macro'>RelationGetTargetBlock</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN737"><span class='Ref_To_Local'>NewHeap</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="../../include/storage/block.h.html#LN32"><span class='Ref_to_Const'>InvalidBlockNumber</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If both tables have TOAST tables, perform toast swap by content.  It is 
     * possible that the old table has a toast table but the new one doesn't, 
     * if toastable columns have been dropped.  In that case we have to do 
     * swap by links.  This is okay because swap by content is only essential 
     * for system catalogs, and we don't support schema changes for them. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN738"><span class='Ref_To_Local'>OldHeap</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>reltoastrelid <span class='Operator'>&& </span><a href="cluster.c.html#LN737"><span class='Ref_To_Local'>NewHeap</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>reltoastrelid<span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Operator'>*</span><a href="cluster.c.html#LN734"><span class='Ref_to_Parameter'>pSwapToastByContent</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * When doing swap by content, any toast pointers written into NewHeap 
         * must use the old toast table's OID, because that's where the toast 
         * data will eventually be found.  Set this up by setting rd_toastoid. 
         * This also tells toast_save_datum() to preserve the toast value 
         * OIDs, which we want so as not to invalidate toast pointers in 
         * system catalog caches, and to avoid making multiple copies of a 
         * single toast value. 
         * 
         * Note that we must hold NewHeap open until we are done writing data, 
         * since the relcache will not guarantee to remember this setting once 
         * the relation is closed.  Also, this technique depends on the fact 
         * that no one will try to read from the NewHeap until after we've 
         * finished writing it and swapping the rels --- otherwise they could 
         * follow the toast pointers to the wrong place.  (It would actually 
         * work for values copied over from the old toast table, but not for 
         * any values that we toast which were previously not toasted.) 
         */ 
</span>        <a href="cluster.c.html#LN737"><span class='Ref_To_Local'>NewHeap</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN214"><span class='Ref_to_Member'>rd_toastoid</span></a> <span class='Operator'>= </span><a href="cluster.c.html#LN738"><span class='Ref_To_Local'>OldHeap</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>reltoastrelid<span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if OldHeap-&GT;rd_rel-&GT;relt... &raquo; </span> 
    <span class='Control'>else</span> 
        <span class='Operator'>*</span><a href="cluster.c.html#LN734"><span class='Ref_to_Parameter'>pSwapToastByContent</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Compute xids used to freeze and weed out dead tuples and multixacts. 
     * Since we're going to rewrite the whole table anyway, there's no reason 
     * not to be aggressive about this. 
     */ 
</span>    <a href="../../include/commands/vacuum.h.html#LN178"><span class='Ref_to_Proto'>vacuum_set_xid_limits</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN738"><span class='Ref_To_Local'>OldHeap</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, 
</span>                          <span class='Operator'>&</span><a href="cluster.c.html#LN749"><span class='Ref_To_Local'>OldestXmin</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="cluster.c.html#LN750"><span class='Ref_To_Local'>FreezeXid</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="cluster.c.html#LN751"><span class='Ref_To_Local'>MultiXactCutoff</span></a><span class='Delimiter'>, 
</span>                          <span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * FreezeXid will become the table's new relfrozenxid, and that mustn't go 
     * backwards, so take the max. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN750"><span class='Ref_To_Local'>FreezeXid</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN738"><span class='Ref_To_Local'>OldHeap</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relfrozenxid<span class='Parentheses'>))</span> 
        <a href="cluster.c.html#LN750"><span class='Ref_To_Local'>FreezeXid</span></a> <span class='Operator'>= </span><a href="cluster.c.html#LN738"><span class='Ref_To_Local'>OldHeap</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relfrozenxid<span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * MultiXactCutoff, similarly, shouldn't go backwards either. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/access/multixact.h.html#LN114"><span class='Ref_to_Proto'>MultiXactIdPrecedes</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN751"><span class='Ref_To_Local'>MultiXactCutoff</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN738"><span class='Ref_To_Local'>OldHeap</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relminmxid<span class='Parentheses'>))</span> 
        <a href="cluster.c.html#LN751"><span class='Ref_To_Local'>MultiXactCutoff</span></a> <span class='Operator'>= </span><a href="cluster.c.html#LN738"><span class='Ref_To_Local'>OldHeap</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relminmxid<span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* return selected values to caller */ 
</span>    <span class='Operator'>*</span><a href="cluster.c.html#LN734"><span class='Ref_to_Parameter'>pFreezeXid</span></a> <span class='Operator'>= </span><a href="cluster.c.html#LN750"><span class='Ref_To_Local'>FreezeXid</span></a><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="cluster.c.html#LN735"><span class='Ref_to_Parameter'>pCutoffMulti</span></a> <span class='Operator'>= </span><a href="cluster.c.html#LN751"><span class='Ref_To_Local'>MultiXactCutoff</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Remember if it's a system catalog */ 
</span>    <a href="cluster.c.html#LN748"><span class='Ref_To_Local'>is_system_catalog</span></a> <span class='Operator'>= </span><a href="../../include/catalog/catalog.h.html#LN29"><span class='Ref_to_Proto'>IsSystemRelation</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN738"><span class='Ref_To_Local'>OldHeap</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Initialize the rewrite operation */ 
</span>    <a href="cluster.c.html#LN752"><span class='Ref_To_Local'>rwstate</span></a> <span class='Operator'>= </span><a href="../../include/access/rewriteheap.h.html#LN23"><span class='Ref_to_Proto'>begin_heap_rewrite</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN738"><span class='Ref_To_Local'>OldHeap</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN737"><span class='Ref_To_Local'>NewHeap</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN749"><span class='Ref_To_Local'>OldestXmin</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN750"><span class='Ref_To_Local'>FreezeXid</span></a><span class='Delimiter'>, 
</span>                                 <a href="cluster.c.html#LN751"><span class='Ref_To_Local'>MultiXactCutoff</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN747"><span class='Ref_To_Local'>use_wal</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Decide whether to use an indexscan or seqscan-and-optional-sort to scan 
     * the OldHeap.  We know how to use a sort to duplicate the ordering of a 
     * btree index, and will use seqscan-and-sort for that case if the planner 
     * tells us it's cheaper.  Otherwise, always indexscan if an index is 
     * provided, else plain seqscan. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN739"><span class='Ref_To_Local'>OldIndex</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL </span><span class='Operator'>&& </span><a href="cluster.c.html#LN739"><span class='Ref_To_Local'>OldIndex</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relam <span class='Operator'>== </span><a href="../../include/catalog/pg_am.h.html#LN69"><span class='Ref_to_Const'>BTREE_AM_OID</span></a><span class='Parentheses'>) 
</span>        <a href="cluster.c.html#LN753"><span class='Ref_To_Local'>use_sort</span></a> <span class='Operator'>= </span><a href="../../include/optimizer/planner.h.html#LN57"><span class='Ref_to_Proto'>plan_cluster_use_sort</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN733"><span class='Ref_to_Parameter'>OIDOldHeap</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN733"><span class='Ref_to_Parameter'>OIDOldIndex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="cluster.c.html#LN753"><span class='Ref_To_Local'>use_sort</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Set up sorting if wanted */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN753"><span class='Ref_To_Local'>use_sort</span></a><span class='Parentheses'>) 
</span>        <a href="cluster.c.html#LN754"><span class='Ref_To_Local'>tuplesort</span></a> <span class='Operator'>= </span><a href="../../include/utils/tuplesort.h.html#LN65"><span class='Ref_to_Proto'>tuplesort_begin_cluster</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN740"><span class='Ref_To_Local'>oldTupDesc</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN739"><span class='Ref_To_Local'>OldIndex</span></a><span class='Delimiter'>, 
</span>                                            <a href="../utils/init/globals.c.html#LN113"><span class='Ref_to_Global_Var'>maintenance_work_mem</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="cluster.c.html#LN754"><span class='Ref_To_Local'>tuplesort</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Prepare to scan the OldHeap.  To ensure we see recently-dead tuples 
     * that still need to be copied, we scan with SnapshotAny and use 
     * HeapTupleSatisfiesVacuum for the visibility test. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN739"><span class='Ref_To_Local'>OldIndex</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL </span><span class='Operator'>&& !</span><a href="cluster.c.html#LN753"><span class='Ref_To_Local'>use_sort</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="cluster.c.html#LN746"><span class='Ref_To_Local'>heapScan</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <a href="cluster.c.html#LN745"><span class='Ref_To_Local'>indexScan</span></a> <span class='Operator'>= </span><a href="../../include/access/genam.h.html#LN139"><span class='Ref_to_Proto'>index_beginscan</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN738"><span class='Ref_To_Local'>OldHeap</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN739"><span class='Ref_To_Local'>OldIndex</span></a><span class='Delimiter'>, </span><a href="../../include/utils/tqual.h.html#LN27"><span class='Ref_to_Const'>SnapshotAny</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/access/genam.h.html#LN146"><span class='Ref_to_Proto'>index_rescan</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN745"><span class='Ref_To_Local'>indexScan</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="cluster.c.html#LN746"><span class='Ref_To_Local'>heapScan</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN108"><span class='Ref_to_Proto'>heap_beginscan</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN738"><span class='Ref_To_Local'>OldHeap</span></a><span class='Delimiter'>, </span><a href="../../include/utils/tqual.h.html#LN27"><span class='Ref_to_Const'>SnapshotAny</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a><span class='Parentheses'>) </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="cluster.c.html#LN745"><span class='Ref_To_Local'>indexScan</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Log what we're doing */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN745"><span class='Ref_To_Local'>indexScan</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN758"><span class='Ref_To_Local'>elevel</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"clustering \"%s.%s\" using index scan on \"%s\""</span><span class='Delimiter'>, 
</span>                        <a href="../../include/utils/lsyscache.h.html#LN175"><span class='Ref_to_Proto'>get_namespace_name</span></a><span class='Parentheses'>(</span><a href="../../include/utils/rel.h.html#LN443"><span class='Ref_to_Macro'>RelationGetNamespace</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN738"><span class='Ref_To_Local'>OldHeap</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                        <a href="../../include/utils/rel.h.html#LN436"><span class='Ref_to_Macro'>RelationGetRelationName</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN738"><span class='Ref_To_Local'>OldHeap</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                        <a href="../../include/utils/rel.h.html#LN436"><span class='Ref_to_Macro'>RelationGetRelationName</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN739"><span class='Ref_To_Local'>OldIndex</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN754"><span class='Ref_To_Local'>tuplesort</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN758"><span class='Ref_To_Local'>elevel</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"clustering \"%s.%s\" using sequential scan and sort"</span><span class='Delimiter'>, 
</span>                        <a href="../../include/utils/lsyscache.h.html#LN175"><span class='Ref_to_Proto'>get_namespace_name</span></a><span class='Parentheses'>(</span><a href="../../include/utils/rel.h.html#LN443"><span class='Ref_to_Macro'>RelationGetNamespace</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN738"><span class='Ref_To_Local'>OldHeap</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                        <a href="../../include/utils/rel.h.html#LN436"><span class='Ref_to_Macro'>RelationGetRelationName</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN738"><span class='Ref_To_Local'>OldHeap</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN758"><span class='Ref_To_Local'>elevel</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"vacuuming \"%s.%s\""</span><span class='Delimiter'>, 
</span>                        <a href="../../include/utils/lsyscache.h.html#LN175"><span class='Ref_to_Proto'>get_namespace_name</span></a><span class='Parentheses'>(</span><a href="../../include/utils/rel.h.html#LN443"><span class='Ref_to_Macro'>RelationGetNamespace</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN738"><span class='Ref_To_Local'>OldHeap</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>                        <a href="../../include/utils/rel.h.html#LN436"><span class='Ref_to_Macro'>RelationGetRelationName</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN738"><span class='Ref_To_Local'>OldHeap</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Scan through the OldHeap, either in OldIndex order or sequentially; 
     * copy each tuple into the NewHeap, or transiently to the tuplesort 
     * module.  Note that we don't bother sorting dead tuples (they won't get 
     * to the new table anyway). 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>;;</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN940"></a>        <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>tuple</span><span class='Delimiter'>; 
</span><a name="LN941"></a>        <a href="../../include/storage/buf.h.html#LN22"><span class='Ref_to_Typedef'>Buffer</span></a>      <span class='Declare_Local'>buf</span><span class='Delimiter'>; 
</span><a name="LN942"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>isdead</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/miscadmin.h.html#LN99"><span class='Ref_to_Macro'>CHECK_FOR_INTERRUPTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN745"><span class='Ref_To_Local'>indexScan</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="cluster.c.html#LN940"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>= </span><a href="../../include/access/genam.h.html#LN162"><span class='Ref_to_Proto'>index_getnext</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN745"><span class='Ref_To_Local'>indexScan</span></a><span class='Delimiter'>, </span><a href="../../include/access/sdir.h.html#LN25"><span class='Ref_to_EnumConst'>ForwardScanDirection</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN940"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Since we used no scan keys, should never need to recheck */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN745"><span class='Ref_To_Local'>indexScan</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/relscan.h.html#LN121"><span class='Ref_to_Member'>xs_recheck</span></a><span class='Parentheses'>) 
</span>                <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"CLUSTER does not support lossy index conditions"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="cluster.c.html#LN941"><span class='Ref_To_Local'>buf</span></a> <span class='Operator'>= </span><a href="cluster.c.html#LN745"><span class='Ref_To_Local'>indexScan</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/relscan.h.html#LN119"><span class='Ref_to_Member'>xs_cbuf</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <a href="cluster.c.html#LN940"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN127"><span class='Ref_to_Proto'>heap_getnext</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN746"><span class='Ref_To_Local'>heapScan</span></a><span class='Delimiter'>, </span><a href="../../include/access/sdir.h.html#LN25"><span class='Ref_to_EnumConst'>ForwardScanDirection</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN940"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
            <a href="cluster.c.html#LN941"><span class='Ref_To_Local'>buf</span></a> <span class='Operator'>= </span><a href="cluster.c.html#LN746"><span class='Ref_To_Local'>heapScan</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/relscan.h.html#LN69"><span class='Ref_to_Member'>rs_cbuf</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="../../include/storage/bufmgr.h.html#LN214"><span class='Ref_to_Proto'>LockBuffer</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN941"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><a href="../../include/storage/bufmgr.h.html#LN87"><span class='Ref_to_Const'>BUFFER_LOCK_SHARE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="../../include/utils/tqual.h.html#LN74"><span class='Ref_to_Proto'>HeapTupleSatisfiesVacuum</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN940"><span class='Ref_To_Local'>tuple</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN749"><span class='Ref_To_Local'>OldestXmin</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN941"><span class='Ref_To_Local'>buf</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>case</span> <a href="../../include/utils/tqual.h.html#LN50"><span class='Ref_to_EnumConst'>HEAPTUPLE_DEAD</span></a><span class='Operator'>: 
</span>                <span class='Comment_Multi_Line'>/* Definitely dead */ 
</span>                <a href="cluster.c.html#LN942"><span class='Ref_To_Local'>isdead</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../include/utils/tqual.h.html#LN52"><span class='Ref_to_EnumConst'>HEAPTUPLE_RECENTLY_DEAD</span></a><span class='Operator'>: 
</span>                <a href="cluster.c.html#LN757"><span class='Ref_To_Local'>tups_recently_dead</span></a> <span class='Operator'>+= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>                <span class='Comment_Multi_Line'>/* fall through */ 
</span>            <span class='Control'>case</span> <a href="../../include/utils/tqual.h.html#LN51"><span class='Ref_to_EnumConst'>HEAPTUPLE_LIVE</span></a><span class='Operator'>: 
</span>                <span class='Comment_Multi_Line'>/* Live or recently dead, must copy it */ 
</span>                <a href="cluster.c.html#LN942"><span class='Ref_To_Local'>isdead</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../include/utils/tqual.h.html#LN53"><span class='Ref_to_EnumConst'>HEAPTUPLE_INSERT_IN_PROGRESS</span></a><span class='Operator'>: 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * Since we hold exclusive lock on the relation, normally the 
                 * only way to see this is if it was inserted earlier in our 
                 * own transaction.  However, it can happen in system 
                 * catalogs, since we tend to release write lock before commit 
                 * there.  Give a warning if neither case applies; but in any 
                 * case we had better copy it. 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="cluster.c.html#LN748"><span class='Ref_To_Local'>is_system_catalog</span></a> <span class='Operator'>&& 
</span>                    <span class='Operator'>!</span><a href="../../include/access/xact.h.html#LN345"><span class='Ref_to_Proto'>TransactionIdIsCurrentTransactionId</span></a><span class='Parentheses'>(</span><a href="../../include/access/htup_details.h.html#LN306"><span class='Ref_to_Macro'>HeapTupleHeaderGetXmin</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN940"><span class='Ref_To_Local'>tuple</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/htup.h.html#LN66"><span class='Ref_to_Member'>t_data</span></a><span class='Parentheses'>)))</span> 
                    <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN39"><span class='Ref_to_Const'>WARNING</span></a><span class='Delimiter'>, </span><span class='String'>"concurrent insert in progress within table \"%s\""</span><span class='Delimiter'>, 
</span>                         <a href="../../include/utils/rel.h.html#LN436"><span class='Ref_to_Macro'>RelationGetRelationName</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN738"><span class='Ref_To_Local'>OldHeap</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <span class='Comment_Multi_Line'>/* treat as live */ 
</span>                <a href="cluster.c.html#LN942"><span class='Ref_To_Local'>isdead</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../include/utils/tqual.h.html#LN54"><span class='Ref_to_EnumConst'>HEAPTUPLE_DELETE_IN_PROGRESS</span></a><span class='Operator'>: 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * Similar situation to INSERT_IN_PROGRESS case. 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="cluster.c.html#LN748"><span class='Ref_To_Local'>is_system_catalog</span></a> <span class='Operator'>&& 
</span>                    <span class='Operator'>!</span><a href="../../include/access/xact.h.html#LN345"><span class='Ref_to_Proto'>TransactionIdIsCurrentTransactionId</span></a><span class='Parentheses'>(</span><a href="../../include/access/htup_details.h.html#LN358"><span class='Ref_to_Macro'>HeapTupleHeaderGetUpdateXid</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN940"><span class='Ref_To_Local'>tuple</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/htup.h.html#LN66"><span class='Ref_to_Member'>t_data</span></a><span class='Parentheses'>)))</span> 
                    <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN39"><span class='Ref_to_Const'>WARNING</span></a><span class='Delimiter'>, </span><span class='String'>"concurrent delete in progress within table \"%s\""</span><span class='Delimiter'>, 
</span>                         <a href="../../include/utils/rel.h.html#LN436"><span class='Ref_to_Macro'>RelationGetRelationName</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN738"><span class='Ref_To_Local'>OldHeap</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <span class='Comment_Multi_Line'>/* treat as recently dead */ 
</span>                <a href="cluster.c.html#LN757"><span class='Ref_To_Local'>tups_recently_dead</span></a> <span class='Operator'>+= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>                <a href="cluster.c.html#LN942"><span class='Ref_To_Local'>isdead</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>default</span><span class='Operator'>: 
</span>                <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unexpected HeapTupleSatisfiesVacuum result"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="cluster.c.html#LN942"><span class='Ref_To_Local'>isdead</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* keep compiler quiet */ 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch HeapTupleSatisfiesVac... &raquo; </span> 
 
        <a href="../../include/storage/bufmgr.h.html#LN214"><span class='Ref_to_Proto'>LockBuffer</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN941"><span class='Ref_To_Local'>buf</span></a><span class='Delimiter'>, </span><a href="../../include/storage/bufmgr.h.html#LN86"><span class='Ref_to_Const'>BUFFER_LOCK_UNLOCK</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN942"><span class='Ref_To_Local'>isdead</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="cluster.c.html#LN756"><span class='Ref_To_Local'>tups_vacuumed</span></a> <span class='Operator'>+= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* heap rewrite module still needs to see it... */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/access/rewriteheap.h.html#LN29"><span class='Ref_to_Proto'>rewrite_heap_dead_tuple</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN752"><span class='Ref_To_Local'>rwstate</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN940"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* A previous recently-dead tuple is now known dead */ 
</span>                <a href="cluster.c.html#LN756"><span class='Ref_To_Local'>tups_vacuumed</span></a> <span class='Operator'>+= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>                <a href="cluster.c.html#LN757"><span class='Ref_To_Local'>tups_recently_dead</span></a> <span class='Operator'>-= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="cluster.c.html#LN755"><span class='Ref_To_Local'>num_tuples</span></a> <span class='Operator'>+= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN754"><span class='Ref_To_Local'>tuplesort</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <a href="../../include/utils/tuplesort.h.html#LN87"><span class='Ref_to_Proto'>tuplesort_putheaptuple</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN754"><span class='Ref_To_Local'>tuplesort</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN940"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="cluster.c.html#LN74"><span class='Ref_to_Proto'>reform_and_rewrite_tuple</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN940"><span class='Ref_To_Local'>tuple</span></a><span class='Delimiter'>, 
</span>                                     <a href="cluster.c.html#LN740"><span class='Ref_To_Local'>oldTupDesc</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN741"><span class='Ref_To_Local'>newTupDesc</span></a><span class='Delimiter'>, 
</span>                                     <a href="cluster.c.html#LN743"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN744"><span class='Ref_To_Local'>isnull</span></a><span class='Delimiter'>, 
</span>                                     <a href="cluster.c.html#LN737"><span class='Ref_To_Local'>NewHeap</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relhasoids<span class='Delimiter'>, </span><a href="cluster.c.html#LN752"><span class='Ref_To_Local'>rwstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for ;; &raquo; </span> 
 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN745"><span class='Ref_To_Local'>indexScan</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="../../include/access/genam.h.html#LN149"><span class='Ref_to_Proto'>index_endscan</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN745"><span class='Ref_To_Local'>indexScan</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN746"><span class='Ref_To_Local'>heapScan</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="../../include/access/heapam.h.html#LN126"><span class='Ref_to_Proto'>heap_endscan</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN746"><span class='Ref_To_Local'>heapScan</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * In scan-and-sort mode, complete the sort, then read out all live tuples 
     * from the tuplestore and write them to the new relation. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN754"><span class='Ref_To_Local'>tuplesort</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../include/utils/tuplesort.h.html#LN94"><span class='Ref_to_Proto'>tuplesort_performsort</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN754"><span class='Ref_To_Local'>tuplesort</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>;;</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1058"></a>            <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>tuple</span><span class='Delimiter'>; 
</span> 
            <a href="../../include/miscadmin.h.html#LN99"><span class='Ref_to_Macro'>CHECK_FOR_INTERRUPTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
            <a href="cluster.c.html#LN1058"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>= </span><a href="../../include/utils/tuplesort.h.html#LN98"><span class='Ref_to_Proto'>tuplesort_getheaptuple</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN754"><span class='Ref_To_Local'>tuplesort</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN1058"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
            <a href="cluster.c.html#LN74"><span class='Ref_to_Proto'>reform_and_rewrite_tuple</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1058"><span class='Ref_To_Local'>tuple</span></a><span class='Delimiter'>, 
</span>                                     <a href="cluster.c.html#LN740"><span class='Ref_To_Local'>oldTupDesc</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN741"><span class='Ref_To_Local'>newTupDesc</span></a><span class='Delimiter'>, 
</span>                                     <a href="cluster.c.html#LN743"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN744"><span class='Ref_To_Local'>isnull</span></a><span class='Delimiter'>, 
</span>                                     <a href="cluster.c.html#LN737"><span class='Ref_To_Local'>NewHeap</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relhasoids<span class='Delimiter'>, </span><a href="cluster.c.html#LN752"><span class='Ref_To_Local'>rwstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="../../include/utils/tuplesort.h.html#LN106"><span class='Ref_to_Proto'>tuplesort_end</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN754"><span class='Ref_To_Local'>tuplesort</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if tuplesort!=NULL &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* Write out any remaining tuples, and fsync if needed */ 
</span>    <a href="../../include/access/rewriteheap.h.html#LN26"><span class='Ref_to_Proto'>end_heap_rewrite</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN752"><span class='Ref_To_Local'>rwstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Reset rd_toastoid just to be tidy --- it shouldn't be looked at again */ 
</span>    <a href="cluster.c.html#LN737"><span class='Ref_To_Local'>NewHeap</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN214"><span class='Ref_to_Member'>rd_toastoid</span></a> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Log what we did */ 
</span>    <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN758"><span class='Ref_To_Local'>elevel</span></a><span class='Delimiter'>, 
</span>            <span class='Parentheses'>(</span><a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"\"%s\": found %.0f removable, %.0f nonremovable row versions in %u pages"</span><span class='Delimiter'>, 
</span>                    <a href="../../include/utils/rel.h.html#LN436"><span class='Ref_to_Macro'>RelationGetRelationName</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN738"><span class='Ref_To_Local'>OldHeap</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                    <a href="cluster.c.html#LN756"><span class='Ref_To_Local'>tups_vacuumed</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN755"><span class='Ref_To_Local'>num_tuples</span></a><span class='Delimiter'>, 
</span>                    <a href="../../include/storage/bufmgr.h.html#LN198"><span class='Ref_to_Macro'>RelationGetNumberOfBlocks</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN738"><span class='Ref_To_Local'>OldHeap</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>             <a href="../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"%.0f dead row versions cannot be removed yet.\n"</span> 
                       <span class='String'>"%s."</span><span class='Delimiter'>, 
</span>                       <a href="cluster.c.html#LN757"><span class='Ref_To_Local'>tups_recently_dead</span></a><span class='Delimiter'>, 
</span>                       <a href="../../include/utils/pg_rusage.h.html#LN34"><span class='Ref_to_Proto'>pg_rusage_show</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="cluster.c.html#LN759"><span class='Ref_To_Local'>ru0</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Clean up */ 
</span>    <a href="../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN743"><span class='Ref_To_Local'>values</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN744"><span class='Ref_To_Local'>isnull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN739"><span class='Ref_To_Local'>OldIndex</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="../../include/access/genam.h.html#LN130"><span class='Ref_to_Proto'>index_close</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN739"><span class='Ref_To_Local'>OldIndex</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN33"><span class='Ref_to_Const'>NoLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/access/heapam.h.html#LN96"><span class='Ref_to_Macro'>heap_close</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN738"><span class='Ref_To_Local'>OldHeap</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN33"><span class='Ref_to_Const'>NoLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/access/heapam.h.html#LN96"><span class='Ref_to_Macro'>heap_close</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN737"><span class='Ref_To_Local'>NewHeap</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN33"><span class='Ref_to_Const'>NoLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end copy_heap_data &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Swap the physical files of two given relations. 
 * 
 * We swap the physical identity (reltablespace, relfilenode) while keeping the 
 * same logical identities of the two relations.  relpersistence is also 
 * swapped, which is critical since it determines where buffers live for each 
 * relation. 
 * 
 * We can swap associated TOAST data in either of two ways: recursively swap 
 * the physical content of the toast tables (and their indexes), or swap the 
 * TOAST links in the given relations' pg_class entries.  The former is needed 
 * to manage rewrites of shared catalogs (where we cannot change the pg_class 
 * links) while the latter is the only way to handle cases in which a toast 
 * table is added or removed altogether. 
 * 
 * Additionally, the first relation is marked with relfrozenxid set to 
 * frozenXid.  It seems a bit ugly to have this here, but the caller would 
 * have to do it anyway, so having it here saves a heap_update.  Note: in 
 * the swap-toast-links case, we assume we don't need to change the toast 
 * table's relfrozenxid: the new version of the toast table should already 
 * have relfrozenxid set to RecentXmin, which is good enough. 
 * 
 * Lastly, if r2 and its toast table and toast index (if any) are mapped, 
 * their OIDs are emitted into mapped_tables[].  This is hacky but beats 
 * having to look the information up again later in finish_heap_swap. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1129"></a><span class='Declare_Function'>swap_relation_files</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>r1</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>r2</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>target_is_pg_class</span><span class='Delimiter'>, 
</span><a name="LN1130"></a>                    <span class='Keyword'>bool </span><span class='Declare_Parameter'>swap_toast_by_content</span><span class='Delimiter'>, 
</span><a name="LN1131"></a>                    <span class='Keyword'>bool </span><span class='Declare_Parameter'>is_internal</span><span class='Delimiter'>, 
</span><a name="LN1132"></a>                    <a href="../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>frozenXid</span><span class='Delimiter'>, 
</span><a name="LN1133"></a>                    <a href="../../include/c.h.html#LN406"><span class='Ref_to_Typedef'>MultiXactId</span></a> <span class='Declare_Parameter'>cutoffMulti</span><span class='Delimiter'>, 
</span><a name="LN1134"></a>                    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>mapped_tables</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1136"></a>    <a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>relRelation</span><span class='Delimiter'>; 
</span><a name="LN1137"></a>    <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>reltup1</span><span class='Delimiter'>, 
</span><a name="LN1138"></a>                <span class='Declare_Local'>reltup2</span><span class='Delimiter'>; 
</span><a name="LN1139"></a>    <a href="../../include/catalog/pg_class.h.html#LN94"><span class='Ref_to_Typedef'>Form_pg_class</span></a> <span class='Declare_Local'>relform1</span><span class='Delimiter'>, 
</span><a name="LN1140"></a>                <span class='Declare_Local'>relform2</span><span class='Delimiter'>; 
</span><a name="LN1141"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>relfilenode1</span><span class='Delimiter'>, 
</span><a name="LN1142"></a>                <span class='Declare_Local'>relfilenode2</span><span class='Delimiter'>; 
</span><a name="LN1143"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>swaptemp</span><span class='Delimiter'>; 
</span><a name="LN1144"></a>    <span class='Keyword'>char</span>        <span class='Declare_Local'>swptmpchr</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* We need writable copies of both pg_class tuples. */ 
</span>    <a href="cluster.c.html#LN1136"><span class='Ref_To_Local'>relRelation</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN91"><span class='Ref_to_Proto'>heap_open</span></a><span class='Parentheses'>(</span><a href="../../include/catalog/pg_class.h.html#LN28"><span class='Ref_to_Const'>RelationRelationId</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN37"><span class='Ref_to_Const'>RowExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="cluster.c.html#LN1137"><span class='Ref_To_Local'>reltup1</span></a> <span class='Operator'>= </span><a href="../../include/utils/syscache.h.html#LN164"><span class='Ref_to_Macro'>SearchSysCacheCopy1</span></a><span class='Parentheses'>(</span><a href="../../include/utils/syscache.h.html#LN83"><span class='Ref_to_EnumConst'>RELOID</span></a><span class='Delimiter'>, </span><a href="../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1129"><span class='Ref_to_Parameter'>r1</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1137"><span class='Ref_To_Local'>reltup1</span></a><span class='Parentheses'>))</span> 
        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cache lookup failed for relation %u"</span><span class='Delimiter'>, </span><a href="cluster.c.html#LN1129"><span class='Ref_to_Parameter'>r1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="cluster.c.html#LN1139"><span class='Ref_To_Local'>relform1</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/catalog/pg_class.h.html#LN94"><span class='Ref_to_Typedef'>Form_pg_class</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1137"><span class='Ref_To_Local'>reltup1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="cluster.c.html#LN1138"><span class='Ref_To_Local'>reltup2</span></a> <span class='Operator'>= </span><a href="../../include/utils/syscache.h.html#LN164"><span class='Ref_to_Macro'>SearchSysCacheCopy1</span></a><span class='Parentheses'>(</span><a href="../../include/utils/syscache.h.html#LN83"><span class='Ref_to_EnumConst'>RELOID</span></a><span class='Delimiter'>, </span><a href="../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1129"><span class='Ref_to_Parameter'>r2</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1138"><span class='Ref_To_Local'>reltup2</span></a><span class='Parentheses'>))</span> 
        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cache lookup failed for relation %u"</span><span class='Delimiter'>, </span><a href="cluster.c.html#LN1129"><span class='Ref_to_Parameter'>r2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="cluster.c.html#LN1140"><span class='Ref_To_Local'>relform2</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/catalog/pg_class.h.html#LN94"><span class='Ref_to_Typedef'>Form_pg_class</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1138"><span class='Ref_To_Local'>reltup2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="cluster.c.html#LN1141"><span class='Ref_To_Local'>relfilenode1</span></a> <span class='Operator'>= </span><a href="cluster.c.html#LN1139"><span class='Ref_To_Local'>relform1</span></a><span class='Operator'>-&GT;</span>relfilenode<span class='Delimiter'>; 
</span>    <a href="cluster.c.html#LN1142"><span class='Ref_To_Local'>relfilenode2</span></a> <span class='Operator'>= </span><a href="cluster.c.html#LN1140"><span class='Ref_To_Local'>relform2</span></a><span class='Operator'>-&GT;</span>relfilenode<span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1141"><span class='Ref_To_Local'>relfilenode1</span></a><span class='Parentheses'>) </span><span class='Operator'>&& </span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1142"><span class='Ref_To_Local'>relfilenode2</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Normal non-mapped relations: swap relfilenodes, reltablespaces, 
         * relpersistence 
         */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="cluster.c.html#LN1129"><span class='Ref_to_Parameter'>target_is_pg_class</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="cluster.c.html#LN1143"><span class='Ref_To_Local'>swaptemp</span></a> <span class='Operator'>= </span><a href="cluster.c.html#LN1139"><span class='Ref_To_Local'>relform1</span></a><span class='Operator'>-&GT;</span>relfilenode<span class='Delimiter'>; 
</span>        <a href="cluster.c.html#LN1139"><span class='Ref_To_Local'>relform1</span></a><span class='Operator'>-&GT;</span>relfilenode <span class='Operator'>= </span><a href="cluster.c.html#LN1140"><span class='Ref_To_Local'>relform2</span></a><span class='Operator'>-&GT;</span>relfilenode<span class='Delimiter'>; 
</span>        <a href="cluster.c.html#LN1140"><span class='Ref_To_Local'>relform2</span></a><span class='Operator'>-&GT;</span>relfilenode <span class='Operator'>= </span><a href="cluster.c.html#LN1143"><span class='Ref_To_Local'>swaptemp</span></a><span class='Delimiter'>; 
</span> 
        <a href="cluster.c.html#LN1143"><span class='Ref_To_Local'>swaptemp</span></a> <span class='Operator'>= </span><a href="cluster.c.html#LN1139"><span class='Ref_To_Local'>relform1</span></a><span class='Operator'>-&GT;</span>reltablespace<span class='Delimiter'>; 
</span>        <a href="cluster.c.html#LN1139"><span class='Ref_To_Local'>relform1</span></a><span class='Operator'>-&GT;</span>reltablespace <span class='Operator'>= </span><a href="cluster.c.html#LN1140"><span class='Ref_To_Local'>relform2</span></a><span class='Operator'>-&GT;</span>reltablespace<span class='Delimiter'>; 
</span>        <a href="cluster.c.html#LN1140"><span class='Ref_To_Local'>relform2</span></a><span class='Operator'>-&GT;</span>reltablespace <span class='Operator'>= </span><a href="cluster.c.html#LN1143"><span class='Ref_To_Local'>swaptemp</span></a><span class='Delimiter'>; 
</span> 
        <a href="cluster.c.html#LN1144"><span class='Ref_To_Local'>swptmpchr</span></a> <span class='Operator'>= </span><a href="cluster.c.html#LN1139"><span class='Ref_To_Local'>relform1</span></a><span class='Operator'>-&GT;</span>relpersistence<span class='Delimiter'>; 
</span>        <a href="cluster.c.html#LN1139"><span class='Ref_To_Local'>relform1</span></a><span class='Operator'>-&GT;</span>relpersistence <span class='Operator'>= </span><a href="cluster.c.html#LN1140"><span class='Ref_To_Local'>relform2</span></a><span class='Operator'>-&GT;</span>relpersistence<span class='Delimiter'>; 
</span>        <a href="cluster.c.html#LN1140"><span class='Ref_To_Local'>relform2</span></a><span class='Operator'>-&GT;</span>relpersistence <span class='Operator'>= </span><a href="cluster.c.html#LN1144"><span class='Ref_To_Local'>swptmpchr</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Also swap toast links, if we're swapping by links */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="cluster.c.html#LN1130"><span class='Ref_to_Parameter'>swap_toast_by_content</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="cluster.c.html#LN1143"><span class='Ref_To_Local'>swaptemp</span></a> <span class='Operator'>= </span><a href="cluster.c.html#LN1139"><span class='Ref_To_Local'>relform1</span></a><span class='Operator'>-&GT;</span>reltoastrelid<span class='Delimiter'>; 
</span>            <a href="cluster.c.html#LN1139"><span class='Ref_To_Local'>relform1</span></a><span class='Operator'>-&GT;</span>reltoastrelid <span class='Operator'>= </span><a href="cluster.c.html#LN1140"><span class='Ref_To_Local'>relform2</span></a><span class='Operator'>-&GT;</span>reltoastrelid<span class='Delimiter'>; 
</span>            <a href="cluster.c.html#LN1140"><span class='Ref_To_Local'>relform2</span></a><span class='Operator'>-&GT;</span>reltoastrelid <span class='Operator'>= </span><a href="cluster.c.html#LN1143"><span class='Ref_To_Local'>swaptemp</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if OidIsValid(relfilenod... &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Mapped-relation case.  Here we have to swap the relation mappings 
         * instead of modifying the pg_class columns.  Both must be mapped. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1141"><span class='Ref_To_Local'>relfilenode1</span></a><span class='Parentheses'>) </span><span class='Operator'>|| </span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1142"><span class='Ref_To_Local'>relfilenode2</span></a><span class='Parentheses'>))</span> 
            <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cannot swap mapped relation \"%s\" with non-mapped relation"</span><span class='Delimiter'>, 
</span>                 <a href="../../include/c.h.html#LN498"><span class='Ref_to_Macro'>NameStr</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1139"><span class='Ref_To_Local'>relform1</span></a><span class='Operator'>-&GT;</span>relname<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We can't change the tablespace nor persistence of a mapped rel, and 
         * we can't handle toast link swapping for one either, because we must 
         * not apply any critical changes to its pg_class row.  These cases 
         * should be prevented by upstream permissions tests, so these checks 
         * are non-user-facing emergency backstop. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN1139"><span class='Ref_To_Local'>relform1</span></a><span class='Operator'>-&GT;</span>reltablespace <span class='Operator'>!= </span><a href="cluster.c.html#LN1140"><span class='Ref_To_Local'>relform2</span></a><span class='Operator'>-&GT;</span>reltablespace<span class='Parentheses'>) 
</span>            <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cannot change tablespace of mapped relation \"%s\""</span><span class='Delimiter'>, 
</span>                 <a href="../../include/c.h.html#LN498"><span class='Ref_to_Macro'>NameStr</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1139"><span class='Ref_To_Local'>relform1</span></a><span class='Operator'>-&GT;</span>relname<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN1139"><span class='Ref_To_Local'>relform1</span></a><span class='Operator'>-&GT;</span>relpersistence <span class='Operator'>!= </span><a href="cluster.c.html#LN1140"><span class='Ref_To_Local'>relform2</span></a><span class='Operator'>-&GT;</span>relpersistence<span class='Parentheses'>) 
</span>            <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cannot change persistence of mapped relation \"%s\""</span><span class='Delimiter'>, 
</span>                 <a href="../../include/c.h.html#LN498"><span class='Ref_to_Macro'>NameStr</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1139"><span class='Ref_To_Local'>relform1</span></a><span class='Operator'>-&GT;</span>relname<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="cluster.c.html#LN1130"><span class='Ref_to_Parameter'>swap_toast_by_content</span></a> <span class='Operator'>&& 
</span>            <span class='Parentheses'>(</span><a href="cluster.c.html#LN1139"><span class='Ref_To_Local'>relform1</span></a><span class='Operator'>-&GT;</span>reltoastrelid <span class='Operator'>|| </span><a href="cluster.c.html#LN1140"><span class='Ref_To_Local'>relform2</span></a><span class='Operator'>-&GT;</span>reltoastrelid<span class='Parentheses'>))</span> 
            <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cannot swap toast by links for mapped relation \"%s\""</span><span class='Delimiter'>, 
</span>                 <a href="../../include/c.h.html#LN498"><span class='Ref_to_Macro'>NameStr</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1139"><span class='Ref_To_Local'>relform1</span></a><span class='Operator'>-&GT;</span>relname<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Fetch the mappings --- shouldn't fail, but be paranoid 
         */ 
</span>        <a href="cluster.c.html#LN1141"><span class='Ref_To_Local'>relfilenode1</span></a> <span class='Operator'>= </span><a href="../../include/utils/relmapper.h.html#LN37"><span class='Ref_to_Proto'>RelationMapOidToFilenode</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1129"><span class='Ref_to_Parameter'>r1</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN1139"><span class='Ref_To_Local'>relform1</span></a><span class='Operator'>-&GT;</span>relisshared<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1141"><span class='Ref_To_Local'>relfilenode1</span></a><span class='Parentheses'>))</span> 
            <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"could not find relation mapping for relation \"%s\", OID %u"</span><span class='Delimiter'>, 
</span>                 <a href="../../include/c.h.html#LN498"><span class='Ref_to_Macro'>NameStr</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1139"><span class='Ref_To_Local'>relform1</span></a><span class='Operator'>-&GT;</span>relname<span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="cluster.c.html#LN1129"><span class='Ref_to_Parameter'>r1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="cluster.c.html#LN1142"><span class='Ref_To_Local'>relfilenode2</span></a> <span class='Operator'>= </span><a href="../../include/utils/relmapper.h.html#LN37"><span class='Ref_to_Proto'>RelationMapOidToFilenode</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1129"><span class='Ref_to_Parameter'>r2</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN1140"><span class='Ref_To_Local'>relform2</span></a><span class='Operator'>-&GT;</span>relisshared<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1142"><span class='Ref_To_Local'>relfilenode2</span></a><span class='Parentheses'>))</span> 
            <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"could not find relation mapping for relation \"%s\", OID %u"</span><span class='Delimiter'>, 
</span>                 <a href="../../include/c.h.html#LN498"><span class='Ref_to_Macro'>NameStr</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1140"><span class='Ref_To_Local'>relform2</span></a><span class='Operator'>-&GT;</span>relname<span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="cluster.c.html#LN1129"><span class='Ref_to_Parameter'>r2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Send replacement mappings to relmapper.  Note these won't actually 
         * take effect until CommandCounterIncrement. 
         */ 
</span>        <a href="../../include/utils/relmapper.h.html#LN41"><span class='Ref_to_Proto'>RelationMapUpdateMap</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1129"><span class='Ref_to_Parameter'>r1</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN1142"><span class='Ref_To_Local'>relfilenode2</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN1139"><span class='Ref_To_Local'>relform1</span></a><span class='Operator'>-&GT;</span>relisshared<span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/utils/relmapper.h.html#LN41"><span class='Ref_to_Proto'>RelationMapUpdateMap</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1129"><span class='Ref_to_Parameter'>r2</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN1141"><span class='Ref_To_Local'>relfilenode1</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN1140"><span class='Ref_To_Local'>relform2</span></a><span class='Operator'>-&GT;</span>relisshared<span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Pass OIDs of mapped r2 tables back to caller */ 
</span>        <span class='Operator'>*</span><a href="cluster.c.html#LN1134"><span class='Ref_to_Parameter'>mapped_tables</span></a><span class='Operator'>++ = </span><a href="cluster.c.html#LN1129"><span class='Ref_to_Parameter'>r2</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * In the case of a shared catalog, these next few steps will only affect 
     * our own database's pg_class row; but that's okay, because they are all 
     * noncritical updates.  That's also an important fact for the case of a 
     * mapped catalog, because it's possible that we'll commit the map change 
     * and then fail to commit the pg_class update. 
     */ 
</span> 
    <span class='Comment_Multi_Line'>/* set rel1's frozen Xid and minimum MultiXid */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN1139"><span class='Ref_To_Local'>relform1</span></a><span class='Operator'>-&GT;</span>relkind <span class='Operator'>!= </span><a href="../../include/catalog/pg_class.h.html#LN160"><span class='Ref_to_Const'>RELKIND_INDEX</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1132"><span class='Ref_to_Parameter'>frozenXid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="cluster.c.html#LN1139"><span class='Ref_To_Local'>relform1</span></a><span class='Operator'>-&GT;</span>relfrozenxid <span class='Operator'>= </span><a href="cluster.c.html#LN1132"><span class='Ref_to_Parameter'>frozenXid</span></a><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../include/access/multixact.h.html#LN26"><span class='Ref_to_Macro'>MultiXactIdIsValid</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1133"><span class='Ref_to_Parameter'>cutoffMulti</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="cluster.c.html#LN1139"><span class='Ref_To_Local'>relform1</span></a><span class='Operator'>-&GT;</span>relminmxid <span class='Operator'>= </span><a href="cluster.c.html#LN1133"><span class='Ref_to_Parameter'>cutoffMulti</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* swap size statistics too, since new rel has freshly-updated stats */ 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1260"></a>        <a href="../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Local'>swap_pages</span><span class='Delimiter'>; 
</span><a name="LN1261"></a>        <a href="../../include/c.h.html#LN379"><span class='Ref_to_Typedef'>float4</span></a>      <span class='Declare_Local'>swap_tuples</span><span class='Delimiter'>; 
</span><a name="LN1262"></a>        <a href="../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Local'>swap_allvisible</span><span class='Delimiter'>; 
</span> 
        <a href="cluster.c.html#LN1260"><span class='Ref_To_Local'>swap_pages</span></a> <span class='Operator'>= </span><a href="cluster.c.html#LN1139"><span class='Ref_To_Local'>relform1</span></a><span class='Operator'>-&GT;</span>relpages<span class='Delimiter'>; 
</span>        <a href="cluster.c.html#LN1139"><span class='Ref_To_Local'>relform1</span></a><span class='Operator'>-&GT;</span>relpages <span class='Operator'>= </span><a href="cluster.c.html#LN1140"><span class='Ref_To_Local'>relform2</span></a><span class='Operator'>-&GT;</span>relpages<span class='Delimiter'>; 
</span>        <a href="cluster.c.html#LN1140"><span class='Ref_To_Local'>relform2</span></a><span class='Operator'>-&GT;</span>relpages <span class='Operator'>= </span><a href="cluster.c.html#LN1260"><span class='Ref_To_Local'>swap_pages</span></a><span class='Delimiter'>; 
</span> 
        <a href="cluster.c.html#LN1261"><span class='Ref_To_Local'>swap_tuples</span></a> <span class='Operator'>= </span><a href="cluster.c.html#LN1139"><span class='Ref_To_Local'>relform1</span></a><span class='Operator'>-&GT;</span>reltuples<span class='Delimiter'>; 
</span>        <a href="cluster.c.html#LN1139"><span class='Ref_To_Local'>relform1</span></a><span class='Operator'>-&GT;</span>reltuples <span class='Operator'>= </span><a href="cluster.c.html#LN1140"><span class='Ref_To_Local'>relform2</span></a><span class='Operator'>-&GT;</span>reltuples<span class='Delimiter'>; 
</span>        <a href="cluster.c.html#LN1140"><span class='Ref_To_Local'>relform2</span></a><span class='Operator'>-&GT;</span>reltuples <span class='Operator'>= </span><a href="cluster.c.html#LN1261"><span class='Ref_To_Local'>swap_tuples</span></a><span class='Delimiter'>; 
</span> 
        <a href="cluster.c.html#LN1262"><span class='Ref_To_Local'>swap_allvisible</span></a> <span class='Operator'>= </span><a href="cluster.c.html#LN1139"><span class='Ref_To_Local'>relform1</span></a><span class='Operator'>-&GT;</span>relallvisible<span class='Delimiter'>; 
</span>        <a href="cluster.c.html#LN1139"><span class='Ref_To_Local'>relform1</span></a><span class='Operator'>-&GT;</span>relallvisible <span class='Operator'>= </span><a href="cluster.c.html#LN1140"><span class='Ref_To_Local'>relform2</span></a><span class='Operator'>-&GT;</span>relallvisible<span class='Delimiter'>; 
</span>        <a href="cluster.c.html#LN1140"><span class='Ref_To_Local'>relform2</span></a><span class='Operator'>-&GT;</span>relallvisible <span class='Operator'>= </span><a href="cluster.c.html#LN1262"><span class='Ref_To_Local'>swap_allvisible</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Update the tuples in pg_class --- unless the target relation of the 
     * swap is pg_class itself.  In that case, there is zero point in making 
     * changes because we'd be updating the old data that we're about to throw 
     * away.  Because the real work being done here for a mapped relation is 
     * just to change the relation map settings, it's all right to not update 
     * the pg_class rows in this case. The most important changes will instead 
     * performed later, in finish_heap_swap() itself. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="cluster.c.html#LN1129"><span class='Ref_to_Parameter'>target_is_pg_class</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1288"></a>        <a href="../../include/catalog/indexing.h.html#LN25"><span class='Ref_to_Typedef'>CatalogIndexState</span></a> <span class='Declare_Local'>indstate</span><span class='Delimiter'>; 
</span> 
        <a href="cluster.c.html#LN1288"><span class='Ref_To_Local'>indstate</span></a> <span class='Operator'>= </span><a href="../../include/catalog/indexing.h.html#LN30"><span class='Ref_to_Proto'>CatalogOpenIndexes</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1136"><span class='Ref_To_Local'>relRelation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/catalog/indexing.h.html#LN37"><span class='Ref_to_Proto'>CatalogTupleUpdateWithInfo</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1136"><span class='Ref_To_Local'>relRelation</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="cluster.c.html#LN1137"><span class='Ref_To_Local'>reltup1</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/htup.h.html#LN64"><span class='Ref_to_Member'>t_self</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN1137"><span class='Ref_To_Local'>reltup1</span></a><span class='Delimiter'>, 
</span>                                   <a href="cluster.c.html#LN1288"><span class='Ref_To_Local'>indstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/catalog/indexing.h.html#LN37"><span class='Ref_to_Proto'>CatalogTupleUpdateWithInfo</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1136"><span class='Ref_To_Local'>relRelation</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="cluster.c.html#LN1138"><span class='Ref_To_Local'>reltup2</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/htup.h.html#LN64"><span class='Ref_to_Member'>t_self</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN1138"><span class='Ref_To_Local'>reltup2</span></a><span class='Delimiter'>, 
</span>                                   <a href="cluster.c.html#LN1288"><span class='Ref_To_Local'>indstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/catalog/indexing.h.html#LN31"><span class='Ref_to_Proto'>CatalogCloseIndexes</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1288"><span class='Ref_To_Local'>indstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* no update ... but we do still need relcache inval */ 
</span>        <a href="../../include/utils/inval.h.html#LN47"><span class='Ref_to_Proto'>CacheInvalidateRelcacheByTuple</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1137"><span class='Ref_To_Local'>reltup1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/utils/inval.h.html#LN47"><span class='Ref_to_Proto'>CacheInvalidateRelcacheByTuple</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1138"><span class='Ref_To_Local'>reltup2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Post alter hook for modified relations. The change to r2 is always 
     * internal, but r1 depends on the invocation context. 
     */ 
</span>    <a href="../../include/catalog/objectaccess.h.html#LN165"><span class='Ref_to_Macro'>InvokeObjectPostAlterHookArg</span></a><span class='Parentheses'>(</span><a href="../../include/catalog/pg_class.h.html#LN28"><span class='Ref_to_Const'>RelationRelationId</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN1129"><span class='Ref_to_Parameter'>r1</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, 
</span>                                 <a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN1131"><span class='Ref_to_Parameter'>is_internal</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/catalog/objectaccess.h.html#LN165"><span class='Ref_to_Macro'>InvokeObjectPostAlterHookArg</span></a><span class='Parentheses'>(</span><a href="../../include/catalog/pg_class.h.html#LN28"><span class='Ref_to_Const'>RelationRelationId</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN1129"><span class='Ref_to_Parameter'>r2</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, 
</span>                                 <a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we have toast tables associated with the relations being swapped, 
     * deal with them too. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN1139"><span class='Ref_To_Local'>relform1</span></a><span class='Operator'>-&GT;</span>reltoastrelid <span class='Operator'>|| </span><a href="cluster.c.html#LN1140"><span class='Ref_To_Local'>relform2</span></a><span class='Operator'>-&GT;</span>reltoastrelid<span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN1130"><span class='Ref_to_Parameter'>swap_toast_by_content</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN1139"><span class='Ref_To_Local'>relform1</span></a><span class='Operator'>-&GT;</span>reltoastrelid <span class='Operator'>&& </span><a href="cluster.c.html#LN1140"><span class='Ref_To_Local'>relform2</span></a><span class='Operator'>-&GT;</span>reltoastrelid<span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* Recursively swap the contents of the toast tables */ 
</span>                <a href="cluster.c.html#LN1128"><span class='Ref_to_Func'>swap_relation_files</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1139"><span class='Ref_To_Local'>relform1</span></a><span class='Operator'>-&GT;</span>reltoastrelid<span class='Delimiter'>, 
</span>                                    <a href="cluster.c.html#LN1140"><span class='Ref_To_Local'>relform2</span></a><span class='Operator'>-&GT;</span>reltoastrelid<span class='Delimiter'>, 
</span>                                    <a href="cluster.c.html#LN1129"><span class='Ref_to_Parameter'>target_is_pg_class</span></a><span class='Delimiter'>, 
</span>                                    <a href="cluster.c.html#LN1130"><span class='Ref_to_Parameter'>swap_toast_by_content</span></a><span class='Delimiter'>, 
</span>                                    <a href="cluster.c.html#LN1131"><span class='Ref_to_Parameter'>is_internal</span></a><span class='Delimiter'>, 
</span>                                    <a href="cluster.c.html#LN1132"><span class='Ref_to_Parameter'>frozenXid</span></a><span class='Delimiter'>, 
</span>                                    <a href="cluster.c.html#LN1133"><span class='Ref_to_Parameter'>cutoffMulti</span></a><span class='Delimiter'>, 
</span>                                    <a href="cluster.c.html#LN1134"><span class='Ref_to_Parameter'>mapped_tables</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* caller messed up */ 
</span>                <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cannot swap toast files by content when there's only one"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if swap_toast_by_content &raquo; </span> 
        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * We swapped the ownership links, so we need to change dependency 
             * data to match. 
             * 
             * NOTE: it is possible that only one table has a toast table. 
             * 
             * NOTE: at present, a TOAST table's only dependency is the one on 
             * its owning table.  If more are ever created, we'd need to use 
             * something more selective than deleteDependencyRecordsFor() to 
             * get rid of just the link we want. 
             */ 
</span><a name="LN1352"></a>            <a href="../../include/catalog/objectaddress.h.html#LN23"><span class='Ref_to_Struct'>ObjectAddress</span></a> <span class='Declare_Local'>baseobject</span><span class='Delimiter'>, 
</span><a name="LN1353"></a>                        <span class='Declare_Local'>toastobject</span><span class='Delimiter'>; 
</span><a name="LN1354"></a>            <span class='Keyword'>long</span>        <span class='Declare_Local'>count</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * We disallow this case for system catalogs, to avoid the 
             * possibility that the catalog we're rebuilding is one of the 
             * ones the dependency changes would change.  It's too late to be 
             * making any data changes to the target catalog. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/catalog/catalog.h.html#LN33"><span class='Ref_to_Proto'>IsSystemClass</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1129"><span class='Ref_to_Parameter'>r1</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN1139"><span class='Ref_To_Local'>relform1</span></a><span class='Parentheses'>))</span> 
                <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cannot swap toast files by links for system catalogs"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Delete old dependencies */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN1139"><span class='Ref_To_Local'>relform1</span></a><span class='Operator'>-&GT;</span>reltoastrelid<span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="cluster.c.html#LN1354"><span class='Ref_To_Local'>count</span></a> <span class='Operator'>= </span><a href="../catalog/pg_depend.c.html#LN189"><span class='Ref_to_Func'>deleteDependencyRecordsFor</span></a><span class='Parentheses'>(</span><a href="../../include/catalog/pg_class.h.html#LN28"><span class='Ref_to_Const'>RelationRelationId</span></a><span class='Delimiter'>, 
</span>                                                   <a href="cluster.c.html#LN1139"><span class='Ref_To_Local'>relform1</span></a><span class='Operator'>-&GT;</span>reltoastrelid<span class='Delimiter'>, 
</span>                                                   <span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN1354"><span class='Ref_To_Local'>count</span></a> <span class='Operator'>!= </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>                    <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"expected one dependency record for TOAST table, found %ld"</span><span class='Delimiter'>, 
</span>                         <a href="cluster.c.html#LN1354"><span class='Ref_To_Local'>count</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN1140"><span class='Ref_To_Local'>relform2</span></a><span class='Operator'>-&GT;</span>reltoastrelid<span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="cluster.c.html#LN1354"><span class='Ref_To_Local'>count</span></a> <span class='Operator'>= </span><a href="../catalog/pg_depend.c.html#LN189"><span class='Ref_to_Func'>deleteDependencyRecordsFor</span></a><span class='Parentheses'>(</span><a href="../../include/catalog/pg_class.h.html#LN28"><span class='Ref_to_Const'>RelationRelationId</span></a><span class='Delimiter'>, 
</span>                                                   <a href="cluster.c.html#LN1140"><span class='Ref_To_Local'>relform2</span></a><span class='Operator'>-&GT;</span>reltoastrelid<span class='Delimiter'>, 
</span>                                                   <span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN1354"><span class='Ref_To_Local'>count</span></a> <span class='Operator'>!= </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>                    <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"expected one dependency record for TOAST table, found %ld"</span><span class='Delimiter'>, 
</span>                         <a href="cluster.c.html#LN1354"><span class='Ref_To_Local'>count</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* Register new dependencies */ 
</span>            <a href="cluster.c.html#LN1352"><span class='Ref_To_Local'>baseobject</span></a><span class='Operator'>.</span><a href="../../include/catalog/objectaddress.h.html#LN25"><span class='Ref_to_Member'>classId</span></a> <span class='Operator'>= </span><a href="../../include/catalog/pg_class.h.html#LN28"><span class='Ref_to_Const'>RelationRelationId</span></a><span class='Delimiter'>; 
</span>            <a href="cluster.c.html#LN1352"><span class='Ref_To_Local'>baseobject</span></a><span class='Operator'>.</span><a href="../../include/catalog/objectaddress.h.html#LN27"><span class='Ref_to_Member'>objectSubId</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <a href="cluster.c.html#LN1353"><span class='Ref_To_Local'>toastobject</span></a><span class='Operator'>.</span><a href="../../include/catalog/objectaddress.h.html#LN25"><span class='Ref_to_Member'>classId</span></a> <span class='Operator'>= </span><a href="../../include/catalog/pg_class.h.html#LN28"><span class='Ref_to_Const'>RelationRelationId</span></a><span class='Delimiter'>; 
</span>            <a href="cluster.c.html#LN1353"><span class='Ref_To_Local'>toastobject</span></a><span class='Operator'>.</span><a href="../../include/catalog/objectaddress.h.html#LN27"><span class='Ref_to_Member'>objectSubId</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN1139"><span class='Ref_To_Local'>relform1</span></a><span class='Operator'>-&GT;</span>reltoastrelid<span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="cluster.c.html#LN1352"><span class='Ref_To_Local'>baseobject</span></a><span class='Operator'>.</span><a href="../../include/catalog/objectaddress.h.html#LN26"><span class='Ref_to_Member'>objectId</span></a> <span class='Operator'>= </span><a href="cluster.c.html#LN1129"><span class='Ref_to_Parameter'>r1</span></a><span class='Delimiter'>; 
</span>                <a href="cluster.c.html#LN1353"><span class='Ref_To_Local'>toastobject</span></a><span class='Operator'>.</span><a href="../../include/catalog/objectaddress.h.html#LN26"><span class='Ref_to_Member'>objectId</span></a> <span class='Operator'>= </span><a href="cluster.c.html#LN1139"><span class='Ref_To_Local'>relform1</span></a><span class='Operator'>-&GT;</span>reltoastrelid<span class='Delimiter'>; 
</span>                <a href="../catalog/pg_depend.c.html#LN42"><span class='Ref_to_Func'>recordDependencyOn</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="cluster.c.html#LN1353"><span class='Ref_To_Local'>toastobject</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="cluster.c.html#LN1352"><span class='Ref_To_Local'>baseobject</span></a><span class='Delimiter'>, 
</span>                                   <a href="../../include/catalog/dependency.h.html#LN76"><span class='Ref_to_EnumConst'>DEPENDENCY_INTERNAL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN1140"><span class='Ref_To_Local'>relform2</span></a><span class='Operator'>-&GT;</span>reltoastrelid<span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="cluster.c.html#LN1352"><span class='Ref_To_Local'>baseobject</span></a><span class='Operator'>.</span><a href="../../include/catalog/objectaddress.h.html#LN26"><span class='Ref_to_Member'>objectId</span></a> <span class='Operator'>= </span><a href="cluster.c.html#LN1129"><span class='Ref_to_Parameter'>r2</span></a><span class='Delimiter'>; 
</span>                <a href="cluster.c.html#LN1353"><span class='Ref_To_Local'>toastobject</span></a><span class='Operator'>.</span><a href="../../include/catalog/objectaddress.h.html#LN26"><span class='Ref_to_Member'>objectId</span></a> <span class='Operator'>= </span><a href="cluster.c.html#LN1140"><span class='Ref_To_Local'>relform2</span></a><span class='Operator'>-&GT;</span>reltoastrelid<span class='Delimiter'>; 
</span>                <a href="../catalog/pg_depend.c.html#LN42"><span class='Ref_to_Func'>recordDependencyOn</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="cluster.c.html#LN1353"><span class='Ref_To_Local'>toastobject</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="cluster.c.html#LN1352"><span class='Ref_To_Local'>baseobject</span></a><span class='Delimiter'>, 
</span>                                   <a href="../../include/catalog/dependency.h.html#LN76"><span class='Ref_to_EnumConst'>DEPENDENCY_INTERNAL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if relform1-&GT;reltoastrel... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * If we're swapping two toast tables by content, do the same for their 
     * valid index. The swap can actually be safely done only if the relations 
     * have indexes. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN1130"><span class='Ref_to_Parameter'>swap_toast_by_content</span></a> <span class='Operator'>&& 
</span>        <a href="cluster.c.html#LN1139"><span class='Ref_To_Local'>relform1</span></a><span class='Operator'>-&GT;</span>relkind <span class='Operator'>== </span><a href="../../include/catalog/pg_class.h.html#LN162"><span class='Ref_to_Const'>RELKIND_TOASTVALUE</span></a> <span class='Operator'>&& 
</span>        <a href="cluster.c.html#LN1140"><span class='Ref_To_Local'>relform2</span></a><span class='Operator'>-&GT;</span>relkind <span class='Operator'>== </span><a href="../../include/catalog/pg_class.h.html#LN162"><span class='Ref_to_Const'>RELKIND_TOASTVALUE</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1418"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>toastIndex1</span><span class='Delimiter'>, 
</span><a name="LN1419"></a>                    <span class='Declare_Local'>toastIndex2</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Get valid index for each relation */ 
</span>        <a href="cluster.c.html#LN1418"><span class='Ref_To_Local'>toastIndex1</span></a> <span class='Operator'>= </span><a href="../../include/access/tuptoaster.h.html#LN236"><span class='Ref_to_Proto'>toast_get_valid_index</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1129"><span class='Ref_to_Parameter'>r1</span></a><span class='Delimiter'>, 
</span>                                            <a href="../../include/storage/lockdefs.h.html#LN45"><span class='Ref_to_Const'>AccessExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="cluster.c.html#LN1419"><span class='Ref_To_Local'>toastIndex2</span></a> <span class='Operator'>= </span><a href="../../include/access/tuptoaster.h.html#LN236"><span class='Ref_to_Proto'>toast_get_valid_index</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1129"><span class='Ref_to_Parameter'>r2</span></a><span class='Delimiter'>, 
</span>                                            <a href="../../include/storage/lockdefs.h.html#LN45"><span class='Ref_to_Const'>AccessExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="cluster.c.html#LN1128"><span class='Ref_to_Func'>swap_relation_files</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1418"><span class='Ref_To_Local'>toastIndex1</span></a><span class='Delimiter'>, 
</span>                            <a href="cluster.c.html#LN1419"><span class='Ref_To_Local'>toastIndex2</span></a><span class='Delimiter'>, 
</span>                            <a href="cluster.c.html#LN1129"><span class='Ref_to_Parameter'>target_is_pg_class</span></a><span class='Delimiter'>, 
</span>                            <a href="cluster.c.html#LN1130"><span class='Ref_to_Parameter'>swap_toast_by_content</span></a><span class='Delimiter'>, 
</span>                            <a href="cluster.c.html#LN1131"><span class='Ref_to_Parameter'>is_internal</span></a><span class='Delimiter'>, 
</span>                            <a href="../../include/access/transam.h.html#LN30"><span class='Ref_to_Const'>InvalidTransactionId</span></a><span class='Delimiter'>, 
</span>                            <a href="../../include/access/multixact.h.html#LN22"><span class='Ref_to_Const'>InvalidMultiXactId</span></a><span class='Delimiter'>, 
</span>                            <a href="cluster.c.html#LN1134"><span class='Ref_to_Parameter'>mapped_tables</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if swap_toast_by_content... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* Clean up. */ 
</span>    <a href="../../include/access/htup_details.h.html#LN815"><span class='Ref_to_Proto'>heap_freetuple</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1137"><span class='Ref_To_Local'>reltup1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/access/htup_details.h.html#LN815"><span class='Ref_to_Proto'>heap_freetuple</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1138"><span class='Ref_To_Local'>reltup2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/access/heapam.h.html#LN96"><span class='Ref_to_Macro'>heap_close</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1136"><span class='Ref_To_Local'>relRelation</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN37"><span class='Ref_to_Const'>RowExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Close both relcache entries' smgr links.  We need this kluge because 
     * both links will be invalidated during upcoming CommandCounterIncrement. 
     * Whichever of the rels is the second to be cleared will have a dangling 
     * reference to the other's smgr entry.  Rather than trying to avoid this 
     * by ordering operations just so, it's easiest to close the links first. 
     * (Fortunately, since one of the entries is local in our transaction, 
     * it's sufficient to clear out our own relcache this way; the problem 
     * cannot arise for other backends when they see our update on the 
     * non-transient relation.) 
     * 
     * Caution: the placement of this step interacts with the decision to 
     * handle toast rels by recursion.  When we are trying to rebuild pg_class 
     * itself, the smgr close on pg_class must happen after all accesses in 
     * this function. 
     */ 
</span>    <a href="../../include/utils/relcache.h.html#LN117"><span class='Ref_to_Proto'>RelationCloseSmgrByOid</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1129"><span class='Ref_to_Parameter'>r1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/utils/relcache.h.html#LN117"><span class='Ref_to_Proto'>RelationCloseSmgrByOid</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1129"><span class='Ref_to_Parameter'>r2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end swap_relation_files &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Remove the transient table that was built by make_new_heap, and finish 
 * cleaning up (including rebuilding all indexes on the old heap). 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1468"></a><span class='Declare_Function'>finish_heap_swap</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>OIDOldHeap</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>OIDNewHeap</span><span class='Delimiter'>, 
</span><a name="LN1469"></a>                 <span class='Keyword'>bool </span><span class='Declare_Parameter'>is_system_catalog</span><span class='Delimiter'>, 
</span><a name="LN1470"></a>                 <span class='Keyword'>bool </span><span class='Declare_Parameter'>swap_toast_by_content</span><span class='Delimiter'>, 
</span><a name="LN1471"></a>                 <span class='Keyword'>bool </span><span class='Declare_Parameter'>check_constraints</span><span class='Delimiter'>, 
</span><a name="LN1472"></a>                 <span class='Keyword'>bool </span><span class='Declare_Parameter'>is_internal</span><span class='Delimiter'>, 
</span><a name="LN1473"></a>                 <a href="../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>frozenXid</span><span class='Delimiter'>, 
</span><a name="LN1474"></a>                 <a href="../../include/c.h.html#LN406"><span class='Ref_to_Typedef'>MultiXactId</span></a> <span class='Declare_Parameter'>cutoffMulti</span><span class='Delimiter'>, 
</span><a name="LN1475"></a>                 <span class='Keyword'>char </span><span class='Declare_Parameter'>newrelpersistence</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1477"></a>    <a href="../../include/catalog/objectaddress.h.html#LN23"><span class='Ref_to_Struct'>ObjectAddress</span></a> <span class='Declare_Local'>object</span><span class='Delimiter'>; 
</span><a name="LN1478"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>mapped_tables</span><span class='Delimiter'>[</span><span class='Number'>4</span><span class='Delimiter'>]; 
</span><a name="LN1479"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>reindex_flags</span><span class='Delimiter'>; 
</span><a name="LN1480"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Zero out possible results from swapped_relation_files */ 
</span>    memset<span class='Parentheses'>(</span><a href="cluster.c.html#LN1478"><span class='Ref_To_Local'>mapped_tables</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="cluster.c.html#LN1478"><span class='Ref_To_Local'>mapped_tables</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Swap the contents of the heap relations (including any toast tables). 
     * Also set old heap's relfrozenxid to frozenXid. 
     */ 
</span>    <a href="cluster.c.html#LN1128"><span class='Ref_to_Func'>swap_relation_files</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1468"><span class='Ref_to_Parameter'>OIDOldHeap</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN1468"><span class='Ref_to_Parameter'>OIDNewHeap</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="cluster.c.html#LN1468"><span class='Ref_to_Parameter'>OIDOldHeap</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_class.h.html#LN28"><span class='Ref_to_Const'>RelationRelationId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                        <a href="cluster.c.html#LN1470"><span class='Ref_to_Parameter'>swap_toast_by_content</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN1472"><span class='Ref_to_Parameter'>is_internal</span></a><span class='Delimiter'>, 
</span>                        <a href="cluster.c.html#LN1473"><span class='Ref_to_Parameter'>frozenXid</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN1474"><span class='Ref_to_Parameter'>cutoffMulti</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN1478"><span class='Ref_To_Local'>mapped_tables</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If it's a system catalog, queue an sinval message to flush all 
     * catcaches on the catalog when we reach CommandCounterIncrement. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN1469"><span class='Ref_to_Parameter'>is_system_catalog</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/utils/inval.h.html#LN41"><span class='Ref_to_Proto'>CacheInvalidateCatalog</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1468"><span class='Ref_to_Parameter'>OIDOldHeap</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Rebuild each index on the relation (but not the toast table, which is 
     * all-new at this point).  It is important to do this before the DROP 
     * step because if we are processing a system catalog that will be used 
     * during DROP, we want to have its indexes available.  There is no 
     * advantage to the other order anyway because this is all transactional, 
     * so no chance to reclaim disk space before commit.  We do not need a 
     * final CommandCounterIncrement() because reindex_relation does it. 
     * 
     * Note: because index_build is called via reindex_relation, it will never 
     * set indcheckxmin true for the indexes.  This is OK even though in some 
     * sense we are building new indexes rather than rebuilding existing ones, 
     * because the new heap won't contain any HOT chains at all, let alone 
     * broken ones, so it can't be necessary to set indcheckxmin. 
     */ 
</span>    <a href="cluster.c.html#LN1479"><span class='Ref_To_Local'>reindex_flags</span></a> <span class='Operator'>= </span><a href="../../include/catalog/index.h.html#LN122"><span class='Ref_to_Const'>REINDEX_REL_SUPPRESS_INDEX_USE</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN1471"><span class='Ref_to_Parameter'>check_constraints</span></a><span class='Parentheses'>) 
</span>        <a href="cluster.c.html#LN1479"><span class='Ref_To_Local'>reindex_flags</span></a> <span class='Operator'>|= </span><a href="../../include/catalog/index.h.html#LN123"><span class='Ref_to_Const'>REINDEX_REL_CHECK_CONSTRAINTS</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Ensure that the indexes have the same persistence as the parent 
     * relation. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN1475"><span class='Ref_to_Parameter'>newrelpersistence</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_class.h.html#LN170"><span class='Ref_to_Const'>RELPERSISTENCE_UNLOGGED</span></a><span class='Parentheses'>) 
</span>        <a href="cluster.c.html#LN1479"><span class='Ref_To_Local'>reindex_flags</span></a> <span class='Operator'>|= </span><a href="../../include/catalog/index.h.html#LN124"><span class='Ref_to_Const'>REINDEX_REL_FORCE_INDEXES_UNLOGGED</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN1475"><span class='Ref_to_Parameter'>newrelpersistence</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_class.h.html#LN169"><span class='Ref_to_Const'>RELPERSISTENCE_PERMANENT</span></a><span class='Parentheses'>) 
</span>        <a href="cluster.c.html#LN1479"><span class='Ref_To_Local'>reindex_flags</span></a> <span class='Operator'>|= </span><a href="../../include/catalog/index.h.html#LN125"><span class='Ref_to_Const'>REINDEX_REL_FORCE_INDEXES_PERMANENT</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../include/catalog/index.h.html#LN127"><span class='Ref_to_Proto'>reindex_relation</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1468"><span class='Ref_to_Parameter'>OIDOldHeap</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN1479"><span class='Ref_To_Local'>reindex_flags</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the relation being rebuild is pg_class, swap_relation_files() 
     * couldn't update pg_class's own pg_class entry (check comments in 
     * swap_relation_files()), thus relfrozenxid was not updated. That's 
     * annoying because a potential reason for doing a VACUUM FULL is a 
     * imminent or actual anti-wraparound shutdown.  So, now that we can 
     * access the new relation using it's indices, update relfrozenxid. 
     * pg_class doesn't have a toast relation, so we don't need to update the 
     * corresponding toast relation. Not that there's little point moving all 
     * relfrozenxid updates here since swap_relation_files() needs to write to 
     * pg_class for non-mapped relations anyway. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN1468"><span class='Ref_to_Parameter'>OIDOldHeap</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_class.h.html#LN28"><span class='Ref_to_Const'>RelationRelationId</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1545"></a>        <a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>relRelation</span><span class='Delimiter'>; 
</span><a name="LN1546"></a>        <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>reltup</span><span class='Delimiter'>; 
</span><a name="LN1547"></a>        <a href="../../include/catalog/pg_class.h.html#LN94"><span class='Ref_to_Typedef'>Form_pg_class</span></a> <span class='Declare_Local'>relform</span><span class='Delimiter'>; 
</span> 
        <a href="cluster.c.html#LN1545"><span class='Ref_To_Local'>relRelation</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN91"><span class='Ref_to_Proto'>heap_open</span></a><span class='Parentheses'>(</span><a href="../../include/catalog/pg_class.h.html#LN28"><span class='Ref_to_Const'>RelationRelationId</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN37"><span class='Ref_to_Const'>RowExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="cluster.c.html#LN1546"><span class='Ref_To_Local'>reltup</span></a> <span class='Operator'>= </span><a href="../../include/utils/syscache.h.html#LN164"><span class='Ref_to_Macro'>SearchSysCacheCopy1</span></a><span class='Parentheses'>(</span><a href="../../include/utils/syscache.h.html#LN83"><span class='Ref_to_EnumConst'>RELOID</span></a><span class='Delimiter'>, </span><a href="../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1468"><span class='Ref_to_Parameter'>OIDOldHeap</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1546"><span class='Ref_To_Local'>reltup</span></a><span class='Parentheses'>))</span> 
            <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cache lookup failed for relation %u"</span><span class='Delimiter'>, </span><a href="cluster.c.html#LN1468"><span class='Ref_to_Parameter'>OIDOldHeap</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="cluster.c.html#LN1547"><span class='Ref_To_Local'>relform</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/catalog/pg_class.h.html#LN94"><span class='Ref_to_Typedef'>Form_pg_class</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1546"><span class='Ref_To_Local'>reltup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="cluster.c.html#LN1547"><span class='Ref_To_Local'>relform</span></a><span class='Operator'>-&GT;</span>relfrozenxid <span class='Operator'>= </span><a href="cluster.c.html#LN1473"><span class='Ref_to_Parameter'>frozenXid</span></a><span class='Delimiter'>; 
</span>        <a href="cluster.c.html#LN1547"><span class='Ref_To_Local'>relform</span></a><span class='Operator'>-&GT;</span>relminmxid <span class='Operator'>= </span><a href="cluster.c.html#LN1474"><span class='Ref_to_Parameter'>cutoffMulti</span></a><span class='Delimiter'>; 
</span> 
        <a href="../../include/catalog/indexing.h.html#LN35"><span class='Ref_to_Proto'>CatalogTupleUpdate</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1545"><span class='Ref_To_Local'>relRelation</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="cluster.c.html#LN1546"><span class='Ref_To_Local'>reltup</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/htup.h.html#LN64"><span class='Ref_to_Member'>t_self</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN1546"><span class='Ref_To_Local'>reltup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/access/heapam.h.html#LN96"><span class='Ref_to_Macro'>heap_close</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1545"><span class='Ref_To_Local'>relRelation</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN37"><span class='Ref_to_Const'>RowExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if OIDOldHeap==RelationR... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* Destroy new heap with old filenode */ 
</span>    <a href="cluster.c.html#LN1477"><span class='Ref_To_Local'>object</span></a><span class='Operator'>.</span><a href="../../include/catalog/objectaddress.h.html#LN25"><span class='Ref_to_Member'>classId</span></a> <span class='Operator'>= </span><a href="../../include/catalog/pg_class.h.html#LN28"><span class='Ref_to_Const'>RelationRelationId</span></a><span class='Delimiter'>; 
</span>    <a href="cluster.c.html#LN1477"><span class='Ref_To_Local'>object</span></a><span class='Operator'>.</span><a href="../../include/catalog/objectaddress.h.html#LN26"><span class='Ref_to_Member'>objectId</span></a> <span class='Operator'>= </span><a href="cluster.c.html#LN1468"><span class='Ref_to_Parameter'>OIDNewHeap</span></a><span class='Delimiter'>; 
</span>    <a href="cluster.c.html#LN1477"><span class='Ref_To_Local'>object</span></a><span class='Operator'>.</span><a href="../../include/catalog/objectaddress.h.html#LN27"><span class='Ref_to_Member'>objectSubId</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * The new relation is local to our transaction and we know nothing 
     * depends on it, so DROP_RESTRICT should be OK. 
     */ 
</span>    <a href="../../include/catalog/dependency.h.html#LN182"><span class='Ref_to_Proto'>performDeletion</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="cluster.c.html#LN1477"><span class='Ref_To_Local'>object</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN1654"><span class='Ref_to_EnumConst'>DROP_RESTRICT</span></a><span class='Delimiter'>, </span><a href="../../include/catalog/dependency.h.html#LN173"><span class='Ref_to_Const'>PERFORM_DELETION_INTERNAL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* performDeletion does CommandCounterIncrement at end */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now we must remove any relation mapping entries that we set up for the 
     * transient table, as well as its toast table and toast index if any. If 
     * we fail to do this before commit, the relmapper will complain about new 
     * permanent map entries being added post-bootstrap. 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN1480"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1478"><span class='Ref_To_Local'>mapped_tables</span></a><span class='Delimiter'>[</span><a href="cluster.c.html#LN1480"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; </span><a href="cluster.c.html#LN1480"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>)</span> 
        <a href="../../include/utils/relmapper.h.html#LN44"><span class='Ref_to_Proto'>RelationMapRemoveMapping</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1478"><span class='Ref_To_Local'>mapped_tables</span></a><span class='Delimiter'>[</span><a href="cluster.c.html#LN1480"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * At this point, everything is kosher except that, if we did toast swap 
     * by links, the toast table's name corresponds to the transient table. 
     * The name is irrelevant to the backend because it's referenced by OID, 
     * but users looking at the catalogs could be confused.  Rename it to 
     * prevent this problem. 
     * 
     * Note no lock required on the relation, because we already hold an 
     * exclusive lock on it. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="cluster.c.html#LN1470"><span class='Ref_to_Parameter'>swap_toast_by_content</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1598"></a>        <a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>newrel</span><span class='Delimiter'>; 
</span> 
        <a href="cluster.c.html#LN1598"><span class='Ref_To_Local'>newrel</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN91"><span class='Ref_to_Proto'>heap_open</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1468"><span class='Ref_to_Parameter'>OIDOldHeap</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN33"><span class='Ref_to_Const'>NoLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1598"><span class='Ref_To_Local'>newrel</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>reltoastrelid<span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN1603"></a>            <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>toastidx</span><span class='Delimiter'>; 
</span><a name="LN1604"></a>            <span class='Keyword'>char</span>        <span class='Declare_Local'>NewToastName</span><span class='Delimiter'>[</span><a href="../../interfaces/ecpg/include/sqlda-native.h.html#LN15"><span class='Ref_to_Const'>NAMEDATALEN</span></a><span class='Delimiter'>]; 
</span> 
            <span class='Comment_Multi_Line'>/* Get the associated valid index to be renamed */ 
</span>            <a href="cluster.c.html#LN1603"><span class='Ref_To_Local'>toastidx</span></a> <span class='Operator'>= </span><a href="../../include/access/tuptoaster.h.html#LN236"><span class='Ref_to_Proto'>toast_get_valid_index</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1598"><span class='Ref_To_Local'>newrel</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>reltoastrelid<span class='Delimiter'>, 
</span>                                             <a href="../../include/storage/lockdefs.h.html#LN35"><span class='Ref_to_Const'>AccessShareLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* rename the toast table ... */ 
</span>            <a href="../../pl/plperl/plperl.h.html#LN60"><span class='Ref_to_Macro'>snprintf</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1604"><span class='Ref_To_Local'>NewToastName</span></a><span class='Delimiter'>, </span><a href="../../interfaces/ecpg/include/sqlda-native.h.html#LN15"><span class='Ref_to_Const'>NAMEDATALEN</span></a><span class='Delimiter'>, </span><span class='String'>"pg_toast_%u"</span><span class='Delimiter'>, 
</span>                     <a href="cluster.c.html#LN1468"><span class='Ref_to_Parameter'>OIDOldHeap</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../include/commands/tablecmds.h.html#LN66"><span class='Ref_to_Proto'>RenameRelationInternal</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1598"><span class='Ref_To_Local'>newrel</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>reltoastrelid<span class='Delimiter'>, 
</span>                                   <a href="cluster.c.html#LN1604"><span class='Ref_To_Local'>NewToastName</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* ... and its valid index too. */ 
</span>            <a href="../../pl/plperl/plperl.h.html#LN60"><span class='Ref_to_Macro'>snprintf</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1604"><span class='Ref_To_Local'>NewToastName</span></a><span class='Delimiter'>, </span><a href="../../interfaces/ecpg/include/sqlda-native.h.html#LN15"><span class='Ref_to_Const'>NAMEDATALEN</span></a><span class='Delimiter'>, </span><span class='String'>"pg_toast_%u_index"</span><span class='Delimiter'>, 
</span>                     <a href="cluster.c.html#LN1468"><span class='Ref_to_Parameter'>OIDOldHeap</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="../../include/commands/tablecmds.h.html#LN66"><span class='Ref_to_Proto'>RenameRelationInternal</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1603"><span class='Ref_To_Local'>toastidx</span></a><span class='Delimiter'>, 
</span>                                   <a href="cluster.c.html#LN1604"><span class='Ref_To_Local'>NewToastName</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if OidIsValid(newrel-&GT;rd... &raquo; </span> 
        <a href="../../include/access/heapam.h.html#LN89"><span class='Ref_to_Proto'>relation_close</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1598"><span class='Ref_To_Local'>newrel</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN33"><span class='Ref_to_Const'>NoLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !swap_toast_by_conten... &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end finish_heap_swap &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * Get a list of tables that the current user owns and 
 * have indisclustered set.  Return the list in a List * of rvsToCluster 
 * with the tableOid and the indexOid on which the table is already 
 * clustered. 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN1635"></a><span class='Declare_Function'>get_tables_to_cluster</span><span class='Parentheses'>(</span><a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Parameter'>cluster_context</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1637"></a>    <a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>indRelation</span><span class='Delimiter'>; 
</span><a name="LN1638"></a>    <a href="../../include/access/heapam.h.html#LN99"><span class='Ref_to_Typedef'>HeapScanDesc</span></a> <span class='Declare_Local'>scan</span><span class='Delimiter'>; 
</span><a name="LN1639"></a>    <a href="../../include/access/skey.h.html#LN63"><span class='Ref_to_Struct'>ScanKeyData</span></a> <span class='Declare_Local'>entry</span><span class='Delimiter'>; 
</span><a name="LN1640"></a>    <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>indexTuple</span><span class='Delimiter'>; 
</span><a name="LN1641"></a>    <a href="../../include/catalog/pg_index.h.html#LN66"><span class='Ref_to_Typedef'>Form_pg_index</span></a> <span class='Declare_Local'>index</span><span class='Delimiter'>; 
</span><a name="LN1642"></a>    <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>old_context</span><span class='Delimiter'>; 
</span><a name="LN1643"></a>    <a href="cluster.c.html#LN62"><span class='Ref_to_Typedef'>RelToCluster</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rvtc</span><span class='Delimiter'>; 
</span><a name="LN1644"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>rvs</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Get all indexes that have indisclustered set and are owned by 
     * appropriate user. System relations or nailed-in relations cannot ever 
     * have indisclustered set, because CLUSTER will refuse to set it when 
     * called with one of them as argument. 
     */ 
</span>    <a href="cluster.c.html#LN1637"><span class='Ref_To_Local'>indRelation</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN91"><span class='Ref_to_Proto'>heap_open</span></a><span class='Parentheses'>(</span><a href="../../include/catalog/pg_index.h.html#LN28"><span class='Ref_to_Const'>IndexRelationId</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN35"><span class='Ref_to_Const'>AccessShareLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../access/common/scankey.c.html#LN74"><span class='Ref_to_Func'>ScanKeyInit</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="cluster.c.html#LN1639"><span class='Ref_To_Local'>entry</span></a><span class='Delimiter'>, 
</span>                <a href="../../include/catalog/pg_index.h.html#LN80"><span class='Ref_to_Const'>Anum_pg_index_indisclustered</span></a><span class='Delimiter'>, 
</span>                <a href="../../include/access/stratnum.h.html#LN30"><span class='Ref_to_Const'>BTEqualStrategyNumber</span></a><span class='Delimiter'>, </span>F_BOOLEQ<span class='Delimiter'>, 
</span>                <a href="../../include/postgres.h.html#LN407"><span class='Ref_to_Macro'>BoolGetDatum</span></a><span class='Parentheses'>(</span><span class='Boolean'>true</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="cluster.c.html#LN1638"><span class='Ref_To_Local'>scan</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN110"><span class='Ref_to_Proto'>heap_beginscan_catalog</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1637"><span class='Ref_To_Local'>indRelation</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="cluster.c.html#LN1639"><span class='Ref_To_Local'>entry</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>while</span> <span class='Parentheses'>((</span><a href="cluster.c.html#LN1640"><span class='Ref_To_Local'>indexTuple</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN127"><span class='Ref_to_Proto'>heap_getnext</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1638"><span class='Ref_To_Local'>scan</span></a><span class='Delimiter'>, </span><a href="../../include/access/sdir.h.html#LN25"><span class='Ref_to_EnumConst'>ForwardScanDirection</span></a><span class='Parentheses'>))</span> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <a href="cluster.c.html#LN1641"><span class='Ref_To_Local'>index</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/catalog/pg_index.h.html#LN66"><span class='Ref_to_Typedef'>Form_pg_index</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1640"><span class='Ref_To_Local'>indexTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/utils/acl.h.html#LN308"><span class='Ref_to_Proto'>pg_class_ownercheck</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1641"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span>indrelid<span class='Delimiter'>, </span><a href="../utils/init/miscinit.c.html#LN281"><span class='Ref_to_Func'>GetUserId</span></a><span class='Parentheses'>()))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We have to build the list in a different memory context so it will 
         * survive the cross-transaction processing 
         */ 
</span>        <a href="cluster.c.html#LN1642"><span class='Ref_To_Local'>old_context</span></a> <span class='Operator'>= </span><a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1635"><span class='Ref_to_Parameter'>cluster_context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="cluster.c.html#LN1643"><span class='Ref_To_Local'>rvtc</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="cluster.c.html#LN62"><span class='Ref_to_Typedef'>RelToCluster</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="cluster.c.html#LN62"><span class='Ref_to_Typedef'>RelToCluster</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="cluster.c.html#LN1643"><span class='Ref_To_Local'>rvtc</span></a><span class='Operator'>-&GT;</span><a href="cluster.c.html#LN64"><span class='Ref_to_Member'>tableOid</span></a> <span class='Operator'>= </span><a href="cluster.c.html#LN1641"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span>indrelid<span class='Delimiter'>; 
</span>        <a href="cluster.c.html#LN1643"><span class='Ref_To_Local'>rvtc</span></a><span class='Operator'>-&GT;</span><a href="cluster.c.html#LN65"><span class='Ref_to_Member'>indexOid</span></a> <span class='Operator'>= </span><a href="cluster.c.html#LN1641"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span>indexrelid<span class='Delimiter'>; 
</span>        <a href="cluster.c.html#LN1644"><span class='Ref_To_Local'>rvs</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN215"><span class='Ref_to_Proto'>lcons</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1643"><span class='Ref_To_Local'>rvtc</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN1644"><span class='Ref_To_Local'>rvs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1642"><span class='Ref_To_Local'>old_context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while (indexTuple=heap_getn... &raquo; </span> 
    <a href="../../include/access/heapam.h.html#LN126"><span class='Ref_to_Proto'>heap_endscan</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1638"><span class='Ref_To_Local'>scan</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/access/heapam.h.html#LN89"><span class='Ref_to_Proto'>relation_close</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1637"><span class='Ref_To_Local'>indRelation</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN35"><span class='Ref_to_Const'>AccessShareLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="cluster.c.html#LN1644"><span class='Ref_To_Local'>rvs</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end get_tables_to_cluster &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * Reconstruct and rewrite the given tuple 
 * 
 * We cannot simply copy the tuple as-is, for several reasons: 
 * 
 * 1. We'd like to squeeze out the values of any dropped columns, both 
 * to save space and to ensure we have no corner-case failures. (It's 
 * possible for example that the new table hasn't got a TOAST table 
 * and so is unable to store any large values of dropped cols.) 
 * 
 * 2. The tuple might not even be legal for the new table; this is 
 * currently only known to happen as an after-effect of ALTER TABLE 
 * SET WITHOUT OIDS. 
 * 
 * So, we must reconstruct the tuple from component Datums. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1703"></a><span class='Declare_Function'>reform_and_rewrite_tuple</span><span class='Parentheses'>(</span><a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a> <span class='Declare_Parameter'>tuple</span><span class='Delimiter'>, 
</span><a name="LN1704"></a>                         <a href="../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a> <span class='Declare_Parameter'>oldTupDesc</span><span class='Delimiter'>, </span><a href="../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a> <span class='Declare_Parameter'>newTupDesc</span><span class='Delimiter'>, 
</span><a name="LN1705"></a>                         <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>values</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>isnull</span><span class='Delimiter'>, 
</span><a name="LN1706"></a>                         <span class='Keyword'>bool </span><span class='Declare_Parameter'>newRelHasOids</span><span class='Delimiter'>, </span><a href="../../include/access/rewriteheap.h.html#LN21"><span class='Ref_to_Typedef'>RewriteState</span></a> <span class='Declare_Parameter'>rwstate</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1708"></a>    <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>copiedTuple</span><span class='Delimiter'>; 
</span><a name="LN1709"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/access/htup_details.h.html#LN813"><span class='Ref_to_Proto'>heap_deform_tuple</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1703"><span class='Ref_to_Parameter'>tuple</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN1704"><span class='Ref_to_Parameter'>oldTupDesc</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN1705"><span class='Ref_to_Parameter'>values</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN1705"><span class='Ref_to_Parameter'>isnull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Be sure to null out any dropped columns */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN1709"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="cluster.c.html#LN1709"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="cluster.c.html#LN1704"><span class='Ref_to_Parameter'>newTupDesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/tupdesc.h.html#LN72"><span class='Ref_to_Member'>natts</span></a><span class='Delimiter'>; </span><a href="cluster.c.html#LN1709"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN1704"><span class='Ref_to_Parameter'>newTupDesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/tupdesc.h.html#LN73"><span class='Ref_to_Member'>attrs</span></a><span class='Delimiter'>[</span><a href="cluster.c.html#LN1709"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>-&GT;</span>attisdropped<span class='Parentheses'>) 
</span>            <a href="cluster.c.html#LN1705"><span class='Ref_to_Parameter'>isnull</span></a><span class='Delimiter'>[</span><a href="cluster.c.html#LN1709"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="cluster.c.html#LN1708"><span class='Ref_To_Local'>copiedTuple</span></a> <span class='Operator'>= </span><a href="../access/common/heaptuple.c.html#LN690"><span class='Ref_to_Func'>heap_form_tuple</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1704"><span class='Ref_to_Parameter'>newTupDesc</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN1705"><span class='Ref_to_Parameter'>values</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN1705"><span class='Ref_to_Parameter'>isnull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Preserve OID, if any */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="cluster.c.html#LN1706"><span class='Ref_to_Parameter'>newRelHasOids</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/access/htup_details.h.html#LN697"><span class='Ref_to_Macro'>HeapTupleSetOid</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1708"><span class='Ref_To_Local'>copiedTuple</span></a><span class='Delimiter'>, </span><a href="../../include/access/htup_details.h.html#LN694"><span class='Ref_to_Macro'>HeapTupleGetOid</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1703"><span class='Ref_to_Parameter'>tuple</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* The heap rewrite module does the rest */ 
</span>    <a href="../../include/access/rewriteheap.h.html#LN27"><span class='Ref_to_Proto'>rewrite_heap_tuple</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1706"><span class='Ref_to_Parameter'>rwstate</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN1703"><span class='Ref_to_Parameter'>tuple</span></a><span class='Delimiter'>, </span><a href="cluster.c.html#LN1708"><span class='Ref_To_Local'>copiedTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/access/htup_details.h.html#LN815"><span class='Ref_to_Proto'>heap_freetuple</span></a><span class='Parentheses'>(</span><a href="cluster.c.html#LN1708"><span class='Ref_To_Local'>copiedTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end reform_and_rewrite_tuple &raquo; </span> 
</pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>