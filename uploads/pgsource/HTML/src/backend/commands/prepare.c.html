<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\commands\prepare.c</title>
<LINK REL=StyleSheet HREF="../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\commands\prepare.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:36 2017
</td></tr>
<tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * prepare.c 
 *    Prepareable SQL statements via PREPARE, EXECUTE and DEALLOCATE 
 * 
 * This module also implements storage of prepared statements that are 
 * accessed via the extended FE/BE query protocol. 
 * 
 * 
 * Copyright (c) 2002-2017, PostgreSQL Global Development Group 
 * 
 * IDENTIFICATION 
 *    src/backend/commands/prepare.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>&LT;limits.h&GT;</span> 
 
<span class='Keyword'>#include </span><span class='String'>"access/xact.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_type.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"commands/createas.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"commands/prepare.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"miscadmin.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/nodeFuncs.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/analyze.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_coerce.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_collate.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_expr.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_type.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"rewrite/rewriteHandler.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"tcop/pquery.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"tcop/utility.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/builtins.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/snapmgr.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/timestamp.h"</span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * The hash table in which prepared queries are stored. This is 
 * per-backend: query plans are not shared between backends. 
 * The keys for this hash table are the arguments to PREPARE and EXECUTE 
 * (statement names); the entries are PreparedStatement structs. 
 */ 
</span><a name="LN45"></a><span class='Keyword'>static </span><a href="../utils/hash/dynahash.c.html#LN192"><span class='Ref_to_Struct'>HTAB</span></a> <span class='Operator'>*</span><span class='Declare_Var'>prepared_queries</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
<a name="LN47"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>InitQueryHashTable</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN48"></a><span class='Keyword'>static </span><a href="../../include/nodes/params.h.html#LN61"><span class='Ref_to_Typedef'>ParamListInfo</span></a> <span class='Declare_Prototype'>EvaluateParams</span><span class='Parentheses'>(</span><a href="../../include/commands/prepare.h.html#LN26"><span class='Ref_to_Typedef'>PreparedStatement</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstmt</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>params</span><span class='Delimiter'>, 
</span><a name="LN49"></a>               <span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>queryString</span><span class='Delimiter'>, </span><a href="../../include/nodes/execnodes.h.html#LN402"><span class='Ref_to_Struct'>EState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>estate</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN50"></a><span class='Keyword'>static </span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Prototype'>build_regtype_array</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>param_types</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>num_params</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Implements the 'PREPARE' utility statement. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN56"></a><span class='Declare_Function'>PrepareQuery</span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN3254"><span class='Ref_to_Struct'>PrepareStmt</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stmt</span><span class='Delimiter'>, </span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>queryString</span><span class='Delimiter'>, 
</span><a name="LN57"></a>             <span class='Keyword'>int </span><span class='Declare_Parameter'>stmt_location</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>stmt_len</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN59"></a>    <a href="../../include/nodes/parsenodes.h.html#LN1396"><span class='Ref_to_Struct'>RawStmt</span></a>    <span class='Operator'>*</span><span class='Declare_Local'>rawstmt</span><span class='Delimiter'>; 
</span><a name="LN60"></a>    <a href="../../include/utils/plancache.h.html#LN79"><span class='Ref_to_Struct'>CachedPlanSource</span></a> <span class='Operator'>*</span><span class='Declare_Local'>plansource</span><span class='Delimiter'>; 
</span><a name="LN61"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>argtypes</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN62"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>nargs</span><span class='Delimiter'>; 
</span><a name="LN63"></a>    <a href="../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>query</span><span class='Delimiter'>; 
</span><a name="LN64"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>query_list</span><span class='Delimiter'>; 
</span><a name="LN65"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Disallow empty-string statement name (conflicts with protocol-level 
     * unnamed statement). 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="prepare.c.html#LN56"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN3257"><span class='Ref_to_Member'>name</span></a> <span class='Operator'>|| </span><a href="prepare.c.html#LN56"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN3257"><span class='Ref_to_Member'>name</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>== </span><span class='String'>'\0'</span><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_INVALID_PSTATEMENT_DEFINITION<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"invalid statement name: must not be empty"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Need to wrap the contained statement in a RawStmt node to pass it to 
     * parse analysis. 
     * 
     * Because parse analysis scribbles on the raw querytree, we must make a 
     * copy to ensure we don't modify the passed-in tree.  FIXME someday. 
     */ 
</span>    <a href="prepare.c.html#LN59"><span class='Ref_To_Local'>rawstmt</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN1396"><span class='Ref_to_Struct'>RawStmt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="prepare.c.html#LN59"><span class='Ref_To_Local'>rawstmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1399"><span class='Ref_to_Member'>stmt</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/nodes.h.html#LN618"><span class='Ref_to_Macro'>copyObject</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN56"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN3259"><span class='Ref_to_Member'>query</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="prepare.c.html#LN59"><span class='Ref_To_Local'>rawstmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1400"><span class='Ref_to_Member'>stmt_location</span></a> <span class='Operator'>= </span><a href="prepare.c.html#LN57"><span class='Ref_to_Parameter'>stmt_location</span></a><span class='Delimiter'>; 
</span>    <a href="prepare.c.html#LN59"><span class='Ref_To_Local'>rawstmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1401"><span class='Ref_to_Member'>stmt_len</span></a> <span class='Operator'>= </span><a href="prepare.c.html#LN57"><span class='Ref_to_Parameter'>stmt_len</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Create the CachedPlanSource before we do parse analysis, since it needs 
     * to see the unmodified raw parse tree. 
     */ 
</span>    <a href="prepare.c.html#LN60"><span class='Ref_To_Local'>plansource</span></a> <span class='Operator'>= </span><a href="../../include/utils/plancache.h.html#LN149"><span class='Ref_to_Proto'>CreateCachedPlan</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN59"><span class='Ref_To_Local'>rawstmt</span></a><span class='Delimiter'>, </span><a href="prepare.c.html#LN56"><span class='Ref_to_Parameter'>queryString</span></a><span class='Delimiter'>, 
</span>                                  <a href="../../include/tcop/utility.h.html#LN48"><span class='Ref_to_Proto'>CreateCommandTag</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN56"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN3259"><span class='Ref_to_Member'>query</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Transform list of TypeNames to array of type OIDs */ 
</span>    <a href="prepare.c.html#LN62"><span class='Ref_To_Local'>nargs</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN56"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN3258"><span class='Ref_to_Member'>argtypes</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="prepare.c.html#LN62"><span class='Ref_To_Local'>nargs</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN100"></a>        <a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Local'>pstate</span><span class='Delimiter'>; 
</span><a name="LN101"></a>        <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * typenameTypeId wants a ParseState to carry the source query string. 
         * Is it worth refactoring its API to avoid this? 
         */ 
</span>        <a href="prepare.c.html#LN100"><span class='Ref_To_Local'>pstate</span></a> <span class='Operator'>= </span><a href="../parser/parse_node.c.html#LN42"><span class='Ref_to_Func'>make_parsestate</span></a><span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="prepare.c.html#LN100"><span class='Ref_To_Local'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN167"><span class='Ref_to_Member'>p_sourcetext</span></a> <span class='Operator'>= </span><a href="prepare.c.html#LN56"><span class='Ref_to_Parameter'>queryString</span></a><span class='Delimiter'>; 
</span> 
        <a href="prepare.c.html#LN61"><span class='Ref_To_Local'>argtypes</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN62"><span class='Ref_To_Local'>nargs</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="prepare.c.html#LN65"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN101"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="prepare.c.html#LN56"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN3258"><span class='Ref_to_Member'>argtypes</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN115"></a>            <a href="../../include/nodes/parsenodes.h.html#LN205"><span class='Ref_to_Struct'>TypeName</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>tn</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN101"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN116"></a>            <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>toid</span> <span class='Operator'>= </span><a href="../../include/parser/parse_type.h.html#LN27"><span class='Ref_to_Proto'>typenameTypeId</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN100"><span class='Ref_To_Local'>pstate</span></a><span class='Delimiter'>, </span><a href="prepare.c.html#LN115"><span class='Ref_To_Local'>tn</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="prepare.c.html#LN61"><span class='Ref_To_Local'>argtypes</span></a><span class='Delimiter'>[</span><a href="prepare.c.html#LN65"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="prepare.c.html#LN116"><span class='Ref_To_Local'>toid</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if nargs &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Analyze the statement using these parameter types (any parameters 
     * passed in from above us will not be visible to it), allowing 
     * information about unknown parameters to be deduced from context. 
     */ 
</span>    <a href="prepare.c.html#LN63"><span class='Ref_To_Local'>query</span></a> <span class='Operator'>= </span><a href="../../include/parser/analyze.h.html#LN26"><span class='Ref_to_Proto'>parse_analyze_varparams</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN59"><span class='Ref_To_Local'>rawstmt</span></a><span class='Delimiter'>, </span><a href="prepare.c.html#LN56"><span class='Ref_to_Parameter'>queryString</span></a><span class='Delimiter'>, 
</span>                                    <span class='Operator'>&</span><a href="prepare.c.html#LN61"><span class='Ref_To_Local'>argtypes</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="prepare.c.html#LN62"><span class='Ref_To_Local'>nargs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Check that all parameter types were determined. 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="prepare.c.html#LN65"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="prepare.c.html#LN65"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="prepare.c.html#LN62"><span class='Ref_To_Local'>nargs</span></a><span class='Delimiter'>; </span><a href="prepare.c.html#LN65"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN135"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>argtype</span> <span class='Operator'>= </span><a href="prepare.c.html#LN61"><span class='Ref_To_Local'>argtypes</span></a><span class='Delimiter'>[</span><a href="prepare.c.html#LN65"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="prepare.c.html#LN135"><span class='Ref_To_Local'>argtype</span></a> <span class='Operator'>== </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a> <span class='Operator'>|| </span><a href="prepare.c.html#LN135"><span class='Ref_To_Local'>argtype</span></a> <span class='Operator'>== </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN43"><span class='Ref_to_Const'>UNKNOWNOID</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_INDETERMINATE_DATATYPE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"could not determine data type of parameter $%d"</span><span class='Delimiter'>, 
</span>                            <a href="prepare.c.html#LN65"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * grammar only allows OptimizableStmt, so this check should be redundant 
     */ 
</span>    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="prepare.c.html#LN63"><span class='Ref_To_Local'>query</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN109"><span class='Ref_to_Member'>commandType</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN650"><span class='Ref_to_EnumConst'>CMD_SELECT</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN652"><span class='Ref_to_EnumConst'>CMD_INSERT</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN651"><span class='Ref_to_EnumConst'>CMD_UPDATE</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN653"><span class='Ref_to_EnumConst'>CMD_DELETE</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* OK */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>default</span><span class='Operator'>: 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_INVALID_PSTATEMENT_DEFINITION<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"utility statements cannot be prepared"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Rewrite the query. The result could be 0, 1, or many queries. */ 
</span>    <a href="prepare.c.html#LN64"><span class='Ref_To_Local'>query_list</span></a> <span class='Operator'>= </span><a href="../../include/rewrite/rewriteHandler.h.html#LN19"><span class='Ref_to_Proto'>QueryRewrite</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN63"><span class='Ref_To_Local'>query</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Finish filling in the CachedPlanSource */ 
</span>    <a href="../../include/utils/plancache.h.html#LN155"><span class='Ref_to_Proto'>CompleteCachedPlan</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN60"><span class='Ref_To_Local'>plansource</span></a><span class='Delimiter'>, 
</span>                       <a href="prepare.c.html#LN64"><span class='Ref_To_Local'>query_list</span></a><span class='Delimiter'>, 
</span>                       <span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                       <a href="prepare.c.html#LN61"><span class='Ref_To_Local'>argtypes</span></a><span class='Delimiter'>, 
</span>                       <a href="prepare.c.html#LN62"><span class='Ref_To_Local'>nargs</span></a><span class='Delimiter'>, 
</span>                       <span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                       <span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                       <a href="../../include/nodes/parsenodes.h.html#LN2610"><span class='Ref_to_Const'>CURSOR_OPT_PARALLEL_OK</span></a><span class='Delimiter'>,</span>  <span class='Comment_Single_Line'>/* allow parallel mode */ 
</span>                       <span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* fixed result */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Save the results. 
     */ 
</span>    <a href="../../include/commands/prepare.h.html#LN48"><span class='Ref_to_Proto'>StorePreparedStatement</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN56"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN3257"><span class='Ref_to_Member'>name</span></a><span class='Delimiter'>, 
</span>                           <a href="prepare.c.html#LN60"><span class='Ref_To_Local'>plansource</span></a><span class='Delimiter'>, 
</span>                           <span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end PrepareQuery &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * ExecuteQuery --- implement the 'EXECUTE' utility statement. 
 * 
 * This code also supports CREATE TABLE ... AS EXECUTE.  That case is 
 * indicated by passing a non-null intoClause.  The DestReceiver is already 
 * set up correctly for CREATE TABLE AS, but we still have to make a few 
 * other adjustments here. 
 * 
 * Note: this is one of very few places in the code that needs to deal with 
 * two query strings at once.  The passed-in queryString is that of the 
 * EXECUTE, which we might need for error reporting while processing the 
 * parameter expressions.  The query_string that we copy from the plan 
 * source is that of the original PREPARE. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN199"></a><span class='Declare_Function'>ExecuteQuery</span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN3268"><span class='Ref_to_Struct'>ExecuteStmt</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stmt</span><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN104"><span class='Ref_to_Struct'>IntoClause</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>intoClause</span><span class='Delimiter'>, 
</span><a name="LN200"></a>             <span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>queryString</span><span class='Delimiter'>, </span><a href="../../include/nodes/params.h.html#LN61"><span class='Ref_to_Typedef'>ParamListInfo</span></a> <span class='Declare_Parameter'>params</span><span class='Delimiter'>, 
</span><a name="LN201"></a>             <a href="../../include/tcop/dest.h.html#LN112"><span class='Ref_to_Typedef'>DestReceiver</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>dest</span><span class='Delimiter'>, </span><span class='Keyword'>char </span><span class='Operator'>*</span><span class='Declare_Parameter'>completionTag</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN203"></a>    <a href="../../include/commands/prepare.h.html#LN26"><span class='Ref_to_Typedef'>PreparedStatement</span></a> <span class='Operator'>*</span><span class='Declare_Local'>entry</span><span class='Delimiter'>; 
</span><a name="LN204"></a>    <a href="../../include/utils/plancache.h.html#LN129"><span class='Ref_to_Struct'>CachedPlan</span></a> <span class='Operator'>*</span><span class='Declare_Local'>cplan</span><span class='Delimiter'>; 
</span><a name="LN205"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>plan_list</span><span class='Delimiter'>; 
</span><a name="LN206"></a>    <a href="../../include/nodes/params.h.html#LN61"><span class='Ref_to_Typedef'>ParamListInfo</span></a> <span class='Declare_Local'>paramLI</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN207"></a>    <a href="../../include/nodes/execnodes.h.html#LN402"><span class='Ref_to_Struct'>EState</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>estate</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN208"></a>    <a href="../../include/utils/portal.h.html#LN111"><span class='Ref_to_Typedef'>Portal</span></a>      <span class='Declare_Local'>portal</span><span class='Delimiter'>; 
</span><a name="LN209"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>query_string</span><span class='Delimiter'>; 
</span><a name="LN210"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>eflags</span><span class='Delimiter'>; 
</span><a name="LN211"></a>    <span class='Keyword'>long</span>        <span class='Declare_Local'>count</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Look it up in the hash table */ 
</span>    <a href="prepare.c.html#LN203"><span class='Ref_To_Local'>entry</span></a> <span class='Operator'>= </span><a href="../../include/commands/prepare.h.html#LN51"><span class='Ref_to_Proto'>FetchPreparedStatement</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN199"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN3271"><span class='Ref_to_Member'>name</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Shouldn't find a non-fixed-result cached plan */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="prepare.c.html#LN203"><span class='Ref_To_Local'>entry</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/prepare.h.html#LN30"><span class='Ref_to_Member'>plansource</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/plancache.h.html#LN90"><span class='Ref_to_Member'>fixed_result</span></a><span class='Parentheses'>) 
</span>        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"EXECUTE does not support variable-result cached plans"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Evaluate parameters, if any */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="prepare.c.html#LN203"><span class='Ref_To_Local'>entry</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/prepare.h.html#LN30"><span class='Ref_to_Member'>plansource</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/plancache.h.html#LN86"><span class='Ref_to_Member'>num_params</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Need an EState to evaluate parameters; must not delete it till end 
         * of query, in case parameters are pass-by-reference.  Note that the 
         * passed-in "params" could possibly be referenced in the parameter 
         * expressions. 
         */ 
</span>        <a href="prepare.c.html#LN207"><span class='Ref_To_Local'>estate</span></a> <span class='Operator'>= </span><a href="../executor/execUtils.c.html#LN78"><span class='Ref_to_Func'>CreateExecutorState</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <a href="prepare.c.html#LN207"><span class='Ref_To_Local'>estate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN441"><span class='Ref_to_Member'>es_param_list_info</span></a> <span class='Operator'>= </span><a href="prepare.c.html#LN200"><span class='Ref_to_Parameter'>params</span></a><span class='Delimiter'>; 
</span>        <a href="prepare.c.html#LN206"><span class='Ref_To_Local'>paramLI</span></a> <span class='Operator'>= </span><a href="prepare.c.html#LN48"><span class='Ref_to_Proto'>EvaluateParams</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN203"><span class='Ref_To_Local'>entry</span></a><span class='Delimiter'>, </span><a href="prepare.c.html#LN199"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN3272"><span class='Ref_to_Member'>params</span></a><span class='Delimiter'>, 
</span>                                 <a href="prepare.c.html#LN200"><span class='Ref_to_Parameter'>queryString</span></a><span class='Delimiter'>, </span><a href="prepare.c.html#LN207"><span class='Ref_To_Local'>estate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Create a new portal to run the query in */ 
</span>    <a href="prepare.c.html#LN208"><span class='Ref_To_Local'>portal</span></a> <span class='Operator'>= </span><a href="../../include/utils/portal.h.html#LN221"><span class='Ref_to_Proto'>CreateNewPortal</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* Don't display the portal in pg_cursors, it is for internal use only */ 
</span>    <a href="prepare.c.html#LN208"><span class='Ref_To_Local'>portal</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/portal.h.html#LN191"><span class='Ref_to_Member'>visible</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Copy the plan's saved query string into the portal's memory */ 
</span>    <a href="prepare.c.html#LN209"><span class='Ref_To_Local'>query_string</span></a> <span class='Operator'>= </span><a href="../../include/utils/palloc.h.html#LN125"><span class='Ref_to_Proto'>MemoryContextStrdup</span></a><span class='Parentheses'>(</span><a href="../../include/utils/portal.h.html#LN204"><span class='Ref_to_Macro'>PortalGetHeapMemory</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN208"><span class='Ref_To_Local'>portal</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                       <a href="prepare.c.html#LN203"><span class='Ref_To_Local'>entry</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/prepare.h.html#LN30"><span class='Ref_to_Member'>plansource</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/plancache.h.html#LN83"><span class='Ref_to_Member'>query_string</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Replan if needed, and increment plan refcount for portal */ 
</span>    <a href="prepare.c.html#LN204"><span class='Ref_To_Local'>cplan</span></a> <span class='Operator'>= </span><a href="../../include/utils/plancache.h.html#LN178"><span class='Ref_to_Proto'>GetCachedPlan</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN203"><span class='Ref_To_Local'>entry</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/prepare.h.html#LN30"><span class='Ref_to_Member'>plansource</span></a><span class='Delimiter'>, </span><a href="prepare.c.html#LN206"><span class='Ref_To_Local'>paramLI</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="prepare.c.html#LN205"><span class='Ref_To_Local'>plan_list</span></a> <span class='Operator'>= </span><a href="prepare.c.html#LN204"><span class='Ref_To_Local'>cplan</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/plancache.h.html#LN132"><span class='Ref_to_Member'>stmt_list</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * For CREATE TABLE ... AS EXECUTE, we must verify that the prepared 
     * statement is one that produces tuples.  Currently we insist that it be 
     * a plain old SELECT.  In future we might consider supporting other 
     * things such as INSERT ... RETURNING, but there are a couple of issues 
     * to be settled first, notably how WITH NO DATA should be handled in such 
     * a case (do we really want to suppress execution?) and how to pass down 
     * the OID-determining eflags (PortalStart won't handle them in such a 
     * case, and for that matter it's not clear the executor will either). 
     * 
     * For CREATE TABLE ... AS EXECUTE, we also have to ensure that the proper 
     * eflags and fetch count are passed to PortalStart/PortalRun. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="prepare.c.html#LN199"><span class='Ref_to_Parameter'>intoClause</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN263"></a>        <a href="../../include/nodes/plannodes.h.html#LN40"><span class='Ref_to_Struct'>PlannedStmt</span></a> <span class='Operator'>*</span><span class='Declare_Local'>pstmt</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN205"><span class='Ref_To_Local'>plan_list</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_WRONG_OBJECT_TYPE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"prepared statement is not a SELECT"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <a href="prepare.c.html#LN263"><span class='Ref_To_Local'>pstmt</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN113"><span class='Ref_to_Macro'>linitial_node</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/plannodes.h.html#LN40"><span class='Ref_to_Struct'>PlannedStmt</span></a><span class='Delimiter'>, </span><a href="prepare.c.html#LN205"><span class='Ref_To_Local'>plan_list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="prepare.c.html#LN263"><span class='Ref_To_Local'>pstmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN44"><span class='Ref_to_Member'>commandType</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/nodes.h.html#LN650"><span class='Ref_to_EnumConst'>CMD_SELECT</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_WRONG_OBJECT_TYPE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"prepared statement is not a SELECT"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Set appropriate eflags */ 
</span>        <a href="prepare.c.html#LN210"><span class='Ref_To_Local'>eflags</span></a> <span class='Operator'>= </span><a href="../../include/commands/createas.h.html#LN26"><span class='Ref_to_Proto'>GetIntoRelEFlags</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN199"><span class='Ref_to_Parameter'>intoClause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* And tell PortalRun whether to run to completion or not */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="prepare.c.html#LN199"><span class='Ref_to_Parameter'>intoClause</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN114"><span class='Ref_to_Member'>skipData</span></a><span class='Parentheses'>) 
</span>            <a href="prepare.c.html#LN211"><span class='Ref_To_Local'>count</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="prepare.c.html#LN211"><span class='Ref_To_Local'>count</span></a> <span class='Operator'>= </span><a href="../../include/nodes/parsenodes.h.html#LN2645"><span class='Ref_to_Const'>FETCH_ALL</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if intoClause &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Plain old EXECUTE */ 
</span>        <a href="prepare.c.html#LN210"><span class='Ref_To_Local'>eflags</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="prepare.c.html#LN211"><span class='Ref_To_Local'>count</span></a> <span class='Operator'>= </span><a href="../../include/nodes/parsenodes.h.html#LN2645"><span class='Ref_to_Const'>FETCH_ALL</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../include/utils/portal.h.html#LN229"><span class='Ref_to_Proto'>PortalDefineQuery</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN208"><span class='Ref_To_Local'>portal</span></a><span class='Delimiter'>, 
</span>                      <span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                      <a href="prepare.c.html#LN209"><span class='Ref_To_Local'>query_string</span></a><span class='Delimiter'>, 
</span>                      <a href="prepare.c.html#LN203"><span class='Ref_To_Local'>entry</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/prepare.h.html#LN30"><span class='Ref_to_Member'>plansource</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/plancache.h.html#LN84"><span class='Ref_to_Member'>commandTag</span></a><span class='Delimiter'>, 
</span>                      <a href="prepare.c.html#LN205"><span class='Ref_To_Local'>plan_list</span></a><span class='Delimiter'>, 
</span>                      <a href="prepare.c.html#LN204"><span class='Ref_To_Local'>cplan</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Run the portal as appropriate. 
     */ 
</span>    <a href="../../include/tcop/pquery.h.html#LN29"><span class='Ref_to_Proto'>PortalStart</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN208"><span class='Ref_To_Local'>portal</span></a><span class='Delimiter'>, </span><a href="prepare.c.html#LN206"><span class='Ref_To_Local'>paramLI</span></a><span class='Delimiter'>, </span><a href="prepare.c.html#LN210"><span class='Ref_To_Local'>eflags</span></a><span class='Delimiter'>, </span><a href="../../include/utils/snapmgr.h.html#LN77"><span class='Ref_to_Proto'>GetActiveSnapshot</span></a><span class='Parentheses'>())</span><span class='Delimiter'>; 
</span> 
    <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="../../include/tcop/pquery.h.html#LN35"><span class='Ref_to_Proto'>PortalRun</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN208"><span class='Ref_To_Local'>portal</span></a><span class='Delimiter'>, </span><a href="prepare.c.html#LN211"><span class='Ref_To_Local'>count</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, </span><a href="prepare.c.html#LN201"><span class='Ref_to_Parameter'>dest</span></a><span class='Delimiter'>, </span><a href="prepare.c.html#LN201"><span class='Ref_to_Parameter'>dest</span></a><span class='Delimiter'>, </span><a href="prepare.c.html#LN201"><span class='Ref_to_Parameter'>completionTag</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/utils/portal.h.html#LN227"><span class='Ref_to_Proto'>PortalDrop</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN208"><span class='Ref_To_Local'>portal</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="prepare.c.html#LN207"><span class='Ref_To_Local'>estate</span></a><span class='Parentheses'>) 
</span>        <a href="../executor/execUtils.c.html#LN176"><span class='Ref_to_Func'>FreeExecutorState</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN207"><span class='Ref_To_Local'>estate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* No need to pfree other memory, MemoryContext will be reset */ 
</span><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end ExecuteQuery &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * EvaluateParams: evaluate a list of parameters. 
 * 
 * pstmt: statement we are getting parameters for. 
 * params: list of given parameter expressions (raw parser output!) 
 * queryString: source text for error messages. 
 * estate: executor state to use. 
 * 
 * Returns a filled-in ParamListInfo -- this can later be passed to 
 * CreateQueryDesc(), which allows the executor to make use of the parameters 
 * during query execution. 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/params.h.html#LN61"><span class='Ref_to_Typedef'>ParamListInfo</span></a> 
<a name="LN326"></a><span class='Declare_Function'>EvaluateParams</span><span class='Parentheses'>(</span><a href="../../include/commands/prepare.h.html#LN26"><span class='Ref_to_Typedef'>PreparedStatement</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pstmt</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>params</span><span class='Delimiter'>, 
</span><a name="LN327"></a>               <span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>queryString</span><span class='Delimiter'>, </span><a href="../../include/nodes/execnodes.h.html#LN402"><span class='Ref_to_Struct'>EState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>estate</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN329"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>param_types</span> <span class='Operator'>= </span><a href="prepare.c.html#LN326"><span class='Ref_to_Parameter'>pstmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/prepare.h.html#LN30"><span class='Ref_to_Member'>plansource</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/plancache.h.html#LN85"><span class='Ref_to_Member'>param_types</span></a><span class='Delimiter'>; 
</span><a name="LN330"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>num_params</span> <span class='Operator'>= </span><a href="prepare.c.html#LN326"><span class='Ref_to_Parameter'>pstmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/prepare.h.html#LN30"><span class='Ref_to_Member'>plansource</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/plancache.h.html#LN86"><span class='Ref_to_Member'>num_params</span></a><span class='Delimiter'>; 
</span><a name="LN331"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>nparams</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN326"><span class='Ref_to_Parameter'>params</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN332"></a>    <a href="../../include/parser/parse_node.h.html#LN164"><span class='Ref_to_Struct'>ParseState</span></a> <span class='Operator'>*</span><span class='Declare_Local'>pstate</span><span class='Delimiter'>; 
</span><a name="LN333"></a>    <a href="../../include/nodes/params.h.html#LN61"><span class='Ref_to_Typedef'>ParamListInfo</span></a> <span class='Declare_Local'>paramLI</span><span class='Delimiter'>; 
</span><a name="LN334"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>exprstates</span><span class='Delimiter'>; 
</span><a name="LN335"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span><a name="LN336"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="prepare.c.html#LN331"><span class='Ref_To_Local'>nparams</span></a> <span class='Operator'>!= </span><a href="prepare.c.html#LN330"><span class='Ref_To_Local'>num_params</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_SYNTAX_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>           <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"wrong number of parameters for prepared statement \"%s\""</span><span class='Delimiter'>, 
</span>                  <a href="prepare.c.html#LN326"><span class='Ref_to_Parameter'>pstmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/prepare.h.html#LN29"><span class='Ref_to_Member'>stmt_name</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"Expected %d parameters but got %d."</span><span class='Delimiter'>, 
</span>                           <a href="prepare.c.html#LN330"><span class='Ref_To_Local'>num_params</span></a><span class='Delimiter'>, </span><a href="prepare.c.html#LN331"><span class='Ref_To_Local'>nparams</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Quick exit if no parameters */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="prepare.c.html#LN330"><span class='Ref_To_Local'>num_params</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We have to run parse analysis for the expressions.  Since the parser is 
     * not cool about scribbling on its input, copy first. 
     */ 
</span>    <a href="prepare.c.html#LN326"><span class='Ref_to_Parameter'>params</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN618"><span class='Ref_to_Macro'>copyObject</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN326"><span class='Ref_to_Parameter'>params</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="prepare.c.html#LN332"><span class='Ref_To_Local'>pstate</span></a> <span class='Operator'>= </span><a href="../parser/parse_node.c.html#LN42"><span class='Ref_to_Func'>make_parsestate</span></a><span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="prepare.c.html#LN332"><span class='Ref_To_Local'>pstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/parser/parse_node.h.html#LN167"><span class='Ref_to_Member'>p_sourcetext</span></a> <span class='Operator'>= </span><a href="prepare.c.html#LN327"><span class='Ref_to_Parameter'>queryString</span></a><span class='Delimiter'>; 
</span> 
    <a href="prepare.c.html#LN336"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN335"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="prepare.c.html#LN326"><span class='Ref_to_Parameter'>params</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN362"></a>        <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN335"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN363"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>expected_type_id</span> <span class='Operator'>= </span><a href="prepare.c.html#LN329"><span class='Ref_To_Local'>param_types</span></a><span class='Delimiter'>[</span><a href="prepare.c.html#LN336"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span><a name="LN364"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>given_type_id</span><span class='Delimiter'>; 
</span> 
        <a href="prepare.c.html#LN362"><span class='Ref_To_Local'>expr</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_expr.h.html#LN21"><span class='Ref_to_Proto'>transformExpr</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN332"><span class='Ref_To_Local'>pstate</span></a><span class='Delimiter'>, </span><a href="prepare.c.html#LN362"><span class='Ref_To_Local'>expr</span></a><span class='Delimiter'>, </span><a href="../../include/parser/parse_node.h.html#LN66"><span class='Ref_to_EnumConst'>EXPR_KIND_EXECUTE_PARAMETER</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="prepare.c.html#LN364"><span class='Ref_To_Local'>given_type_id</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN362"><span class='Ref_To_Local'>expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="prepare.c.html#LN362"><span class='Ref_To_Local'>expr</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_coerce.h.html#LN37"><span class='Ref_to_Proto'>coerce_to_target_type</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN332"><span class='Ref_To_Local'>pstate</span></a><span class='Delimiter'>, </span><a href="prepare.c.html#LN362"><span class='Ref_To_Local'>expr</span></a><span class='Delimiter'>, </span><a href="prepare.c.html#LN364"><span class='Ref_To_Local'>given_type_id</span></a><span class='Delimiter'>, 
</span>                                     <a href="prepare.c.html#LN363"><span class='Ref_To_Local'>expected_type_id</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, 
</span>                                     <a href="../../include/nodes/primnodes.h.html#LN421"><span class='Ref_to_EnumConst'>COERCION_ASSIGNMENT</span></a><span class='Delimiter'>, 
</span>                                     <a href="../../include/nodes/primnodes.h.html#LN438"><span class='Ref_to_EnumConst'>COERCE_IMPLICIT_CAST</span></a><span class='Delimiter'>, 
</span>                                     <span class='Operator'>-</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="prepare.c.html#LN362"><span class='Ref_To_Local'>expr</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_DATATYPE_MISMATCH<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"parameter $%d of type %s cannot be coerced to the expected type %s"</span><span class='Delimiter'>, 
</span>                            <a href="prepare.c.html#LN336"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>, 
</span>                            <a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN364"><span class='Ref_To_Local'>given_type_id</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                            <a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN363"><span class='Ref_To_Local'>expected_type_id</span></a><span class='Parentheses'>))</span><span class='Delimiter'>, 
</span>               <a href="../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"You will need to rewrite or cast the expression."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Take care of collations in the finished expression. */ 
</span>        <a href="../../include/parser/parse_collate.h.html#LN22"><span class='Ref_to_Proto'>assign_expr_collations</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN332"><span class='Ref_To_Local'>pstate</span></a><span class='Delimiter'>, </span><a href="prepare.c.html#LN362"><span class='Ref_To_Local'>expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN335"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>) </span><span class='Operator'>= </span><a href="prepare.c.html#LN362"><span class='Ref_To_Local'>expr</span></a><span class='Delimiter'>; 
</span>        <a href="prepare.c.html#LN336"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Prepare the expressions for execution */ 
</span>    <a href="prepare.c.html#LN334"><span class='Ref_To_Local'>exprstates</span></a> <span class='Operator'>= </span><a href="../../include/executor/executor.h.html#LN249"><span class='Ref_to_Proto'>ExecPrepareExprList</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN326"><span class='Ref_to_Parameter'>params</span></a><span class='Delimiter'>, </span><a href="prepare.c.html#LN327"><span class='Ref_to_Parameter'>estate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="prepare.c.html#LN333"><span class='Ref_To_Local'>paramLI</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/params.h.html#LN61"><span class='Ref_to_Typedef'>ParamListInfo</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN554"><span class='Ref_to_Macro'>offsetof</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/params.h.html#LN67"><span class='Ref_to_Struct'>ParamListInfoData</span></a><span class='Delimiter'>, </span><a href="prepare.c.html#LN326"><span class='Ref_to_Parameter'>params</span></a><span class='Parentheses'>) </span><span class='Operator'>+ 
</span>               <a href="prepare.c.html#LN330"><span class='Ref_To_Local'>num_params</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/nodes/params.h.html#LN53"><span class='Ref_to_Struct'>ParamExternData</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* we have static list of params, so no hooks needed */ 
</span>    <a href="prepare.c.html#LN333"><span class='Ref_To_Local'>paramLI</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/params.h.html#LN69"><span class='Ref_to_Member'>paramFetch</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="prepare.c.html#LN333"><span class='Ref_To_Local'>paramLI</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/params.h.html#LN70"><span class='Ref_to_Member'>paramFetchArg</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="prepare.c.html#LN333"><span class='Ref_To_Local'>paramLI</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/params.h.html#LN71"><span class='Ref_to_Member'>parserSetup</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="prepare.c.html#LN333"><span class='Ref_To_Local'>paramLI</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/params.h.html#LN72"><span class='Ref_to_Member'>parserSetupArg</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="prepare.c.html#LN333"><span class='Ref_To_Local'>paramLI</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/params.h.html#LN73"><span class='Ref_to_Member'>numParams</span></a> <span class='Operator'>= </span><a href="prepare.c.html#LN330"><span class='Ref_To_Local'>num_params</span></a><span class='Delimiter'>; 
</span>    <a href="prepare.c.html#LN333"><span class='Ref_To_Local'>paramLI</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/params.h.html#LN74"><span class='Ref_to_Member'>paramMask</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <a href="prepare.c.html#LN336"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN335"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="prepare.c.html#LN334"><span class='Ref_To_Local'>exprstates</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN409"></a>        <a href="../../include/nodes/execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>n</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN335"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN410"></a>        <a href="../../include/nodes/params.h.html#LN53"><span class='Ref_to_Struct'>ParamExternData</span></a> <span class='Operator'>*</span><span class='Declare_Local'>prm</span> <span class='Operator'>= &</span><a href="prepare.c.html#LN333"><span class='Ref_To_Local'>paramLI</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/params.h.html#LN75"><span class='Ref_to_Member'>params</span></a><span class='Delimiter'>[</span><a href="prepare.c.html#LN336"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
        <a href="prepare.c.html#LN410"><span class='Ref_To_Local'>prm</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/params.h.html#LN58"><span class='Ref_to_Member'>ptype</span></a> <span class='Operator'>= </span><a href="prepare.c.html#LN329"><span class='Ref_To_Local'>param_types</span></a><span class='Delimiter'>[</span><a href="prepare.c.html#LN336"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>        <a href="prepare.c.html#LN410"><span class='Ref_To_Local'>prm</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/params.h.html#LN57"><span class='Ref_to_Member'>pflags</span></a> <span class='Operator'>= </span><a href="../../include/nodes/params.h.html#LN51"><span class='Ref_to_Const'>PARAM_FLAG_CONST</span></a><span class='Delimiter'>; 
</span>        <a href="prepare.c.html#LN410"><span class='Ref_To_Local'>prm</span></a><span class='Operator'>-&GT;</span><span class='Keyword'>value </span><span class='Operator'>= </span><a href="../../include/executor/executor.h.html#LN279"><span class='Ref_to_Func'>ExecEvalExprSwitchContext</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN409"><span class='Ref_To_Local'>n</span></a><span class='Delimiter'>, 
</span>                                               <a href="../../include/executor/executor.h.html#LN455"><span class='Ref_to_Macro'>GetPerTupleExprContext</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN327"><span class='Ref_to_Parameter'>estate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                               <span class='Operator'>&</span><a href="prepare.c.html#LN410"><span class='Ref_To_Local'>prm</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/params.h.html#LN56"><span class='Ref_to_Member'>isnull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="prepare.c.html#LN336"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="prepare.c.html#LN333"><span class='Ref_To_Local'>paramLI</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end EvaluateParams &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * Initialize query hash table upon first use. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN429"></a><span class='Declare_Function'>InitQueryHashTable</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN431"></a>    <a href="../../include/utils/hsearch.h.html#LN64"><span class='Ref_to_Struct'>HASHCTL</span></a>     <span class='Declare_Local'>hash_ctl</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/c.h.html#LN856"><span class='Ref_to_Macro'>MemSet</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="prepare.c.html#LN431"><span class='Ref_To_Local'>hash_ctl</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="prepare.c.html#LN431"><span class='Ref_To_Local'>hash_ctl</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="prepare.c.html#LN431"><span class='Ref_To_Local'>hash_ctl</span></a><span class='Operator'>.</span><a href="../../include/utils/hsearch.h.html#LN71"><span class='Ref_to_Member'>keysize</span></a> <span class='Operator'>= </span><a href="../../interfaces/ecpg/include/sqlda-native.h.html#LN15"><span class='Ref_to_Const'>NAMEDATALEN</span></a><span class='Delimiter'>; 
</span>    <a href="prepare.c.html#LN431"><span class='Ref_To_Local'>hash_ctl</span></a><span class='Operator'>.</span><a href="../../include/utils/hsearch.h.html#LN72"><span class='Ref_to_Member'>entrysize</span></a> <span class='Operator'>= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/commands/prepare.h.html#LN26"><span class='Ref_to_Typedef'>PreparedStatement</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="prepare.c.html#LN45"><span class='Ref_to_Global_Var'>prepared_queries</span></a> <span class='Operator'>= </span><a href="../../include/utils/hsearch.h.html#LN121"><span class='Ref_to_Proto'>hash_create</span></a><span class='Parentheses'>(</span><span class='String'>"Prepared Queries"</span><span class='Delimiter'>, 
</span>                                   <span class='Number'>32</span><span class='Delimiter'>, 
</span>                                   <span class='Operator'>&</span><a href="prepare.c.html#LN431"><span class='Ref_To_Local'>hash_ctl</span></a><span class='Delimiter'>, 
</span>                                   <a href="../../include/utils/hsearch.h.html#LN86"><span class='Ref_to_Const'>HASH_ELEM</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Store all the data pertaining to a query in the hash table using 
 * the specified key.  The passed CachedPlanSource should be "unsaved" 
 * in case we get an error here; we'll save it once we've created the hash 
 * table entry. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN451"></a><span class='Declare_Function'>StorePreparedStatement</span><span class='Parentheses'>(</span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>stmt_name</span><span class='Delimiter'>, 
</span><a name="LN452"></a>                       <a href="../../include/utils/plancache.h.html#LN79"><span class='Ref_to_Struct'>CachedPlanSource</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>plansource</span><span class='Delimiter'>, 
</span><a name="LN453"></a>                       <span class='Keyword'>bool </span><span class='Declare_Parameter'>from_sql</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN455"></a>    <a href="../../include/commands/prepare.h.html#LN26"><span class='Ref_to_Typedef'>PreparedStatement</span></a> <span class='Operator'>*</span><span class='Declare_Local'>entry</span><span class='Delimiter'>; 
</span><a name="LN456"></a>    <a href="../../interfaces/ecpg/include/pgtypes_timestamp.h.html#LN9"><span class='Ref_to_Typedef'>TimestampTz</span></a> <span class='Declare_Local'>cur_ts</span> <span class='Operator'>= </span><a href="../../include/access/xact.h.html#LN341"><span class='Ref_to_Proto'>GetCurrentStatementStartTimestamp</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span><a name="LN457"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>found</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Initialize the hash table, if necessary */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="prepare.c.html#LN45"><span class='Ref_to_Global_Var'>prepared_queries</span></a><span class='Parentheses'>) 
</span>        <a href="prepare.c.html#LN47"><span class='Ref_to_Proto'>InitQueryHashTable</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Add entry to hash table */ 
</span>    <a href="prepare.c.html#LN455"><span class='Ref_To_Local'>entry</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/commands/prepare.h.html#LN26"><span class='Ref_to_Typedef'>PreparedStatement</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/utils/hsearch.h.html#LN125"><span class='Ref_to_Proto'>hash_search</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN45"><span class='Ref_to_Global_Var'>prepared_queries</span></a><span class='Delimiter'>, 
</span>                                              <a href="prepare.c.html#LN451"><span class='Ref_to_Parameter'>stmt_name</span></a><span class='Delimiter'>, 
</span>                                              <a href="../../include/utils/hsearch.h.html#LN105"><span class='Ref_to_EnumConst'>HASH_ENTER</span></a><span class='Delimiter'>, 
</span>                                              <span class='Operator'>&</span><a href="prepare.c.html#LN457"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Shouldn't get a duplicate entry */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="prepare.c.html#LN457"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_DUPLICATE_PSTATEMENT<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"prepared statement \"%s\" already exists"</span><span class='Delimiter'>, 
</span>                        <a href="prepare.c.html#LN451"><span class='Ref_to_Parameter'>stmt_name</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Fill in the hash table entry */ 
</span>    <a href="prepare.c.html#LN455"><span class='Ref_To_Local'>entry</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/prepare.h.html#LN30"><span class='Ref_to_Member'>plansource</span></a> <span class='Operator'>= </span><a href="prepare.c.html#LN452"><span class='Ref_to_Parameter'>plansource</span></a><span class='Delimiter'>; 
</span>    <a href="prepare.c.html#LN455"><span class='Ref_To_Local'>entry</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/prepare.h.html#LN31"><span class='Ref_to_Member'>from_sql</span></a> <span class='Operator'>= </span><a href="prepare.c.html#LN453"><span class='Ref_to_Parameter'>from_sql</span></a><span class='Delimiter'>; 
</span>    <a href="prepare.c.html#LN455"><span class='Ref_To_Local'>entry</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/prepare.h.html#LN32"><span class='Ref_to_Member'>prepare_time</span></a> <span class='Operator'>= </span><a href="prepare.c.html#LN456"><span class='Ref_To_Local'>cur_ts</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Now it's safe to move the CachedPlanSource to permanent memory */ 
</span>    <a href="../../include/utils/plancache.h.html#LN165"><span class='Ref_to_Proto'>SaveCachedPlan</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN452"><span class='Ref_to_Parameter'>plansource</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end StorePreparedStatement &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Lookup an existing query in the hash table. If the query does not 
 * actually exist, throw ereport(ERROR) or return NULL per second parameter. 
 * 
 * Note: this does not force the referenced plancache entry to be valid, 
 * since not all callers care. 
 */ 
</span><a href="../../include/commands/prepare.h.html#LN26"><span class='Ref_to_Typedef'>PreparedStatement</span></a> <span class='Operator'>* 
</span><a name="LN493"></a><span class='Declare_Function'>FetchPreparedStatement</span><span class='Parentheses'>(</span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>stmt_name</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>throwError</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN495"></a>    <a href="../../include/commands/prepare.h.html#LN26"><span class='Ref_to_Typedef'>PreparedStatement</span></a> <span class='Operator'>*</span><span class='Declare_Local'>entry</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the hash table hasn't been initialized, it can't be storing 
     * anything, therefore it couldn't possibly store our plan. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="prepare.c.html#LN45"><span class='Ref_to_Global_Var'>prepared_queries</span></a><span class='Parentheses'>) 
</span>        <a href="prepare.c.html#LN495"><span class='Ref_To_Local'>entry</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/commands/prepare.h.html#LN26"><span class='Ref_to_Typedef'>PreparedStatement</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/utils/hsearch.h.html#LN125"><span class='Ref_to_Proto'>hash_search</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN45"><span class='Ref_to_Global_Var'>prepared_queries</span></a><span class='Delimiter'>, 
</span>                                                  <a href="prepare.c.html#LN493"><span class='Ref_to_Parameter'>stmt_name</span></a><span class='Delimiter'>, 
</span>                                                  <a href="../../include/utils/hsearch.h.html#LN104"><span class='Ref_to_EnumConst'>HASH_FIND</span></a><span class='Delimiter'>, 
</span>                                                  <span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="prepare.c.html#LN495"><span class='Ref_To_Local'>entry</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="prepare.c.html#LN495"><span class='Ref_To_Local'>entry</span></a> <span class='Operator'>&& </span><a href="prepare.c.html#LN493"><span class='Ref_to_Parameter'>throwError</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_UNDEFINED_PSTATEMENT<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"prepared statement \"%s\" does not exist"</span><span class='Delimiter'>, 
</span>                        <a href="prepare.c.html#LN493"><span class='Ref_to_Parameter'>stmt_name</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="prepare.c.html#LN495"><span class='Ref_To_Local'>entry</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end FetchPreparedStatement &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Given a prepared statement, determine the result tupledesc it will 
 * produce.  Returns NULL if the execution will not return tuples. 
 * 
 * Note: the result is created or copied into current memory context. 
 */ 
</span><a href="../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a> 
<a name="LN525"></a><span class='Declare_Function'>FetchPreparedStatementResultDesc</span><span class='Parentheses'>(</span><a href="../../include/commands/prepare.h.html#LN26"><span class='Ref_to_Typedef'>PreparedStatement</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stmt</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * Since we don't allow prepared statements' result tupdescs to change, 
     * there's no need to worry about revalidating the cached plan here. 
     */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="prepare.c.html#LN525"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/prepare.h.html#LN30"><span class='Ref_to_Member'>plansource</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/plancache.h.html#LN90"><span class='Ref_to_Member'>fixed_result</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="prepare.c.html#LN525"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/prepare.h.html#LN30"><span class='Ref_to_Member'>plansource</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/plancache.h.html#LN91"><span class='Ref_to_Member'>resultDesc</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="../../include/access/tupdesc.h.html#LN88"><span class='Ref_to_Proto'>CreateTupleDescCopy</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN525"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/prepare.h.html#LN30"><span class='Ref_to_Member'>plansource</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/plancache.h.html#LN91"><span class='Ref_to_Member'>resultDesc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Given a prepared statement that returns tuples, extract the query 
 * targetlist.  Returns NIL if the statement doesn't have a determinable 
 * targetlist. 
 * 
 * Note: this is pretty ugly, but since it's only used in corner cases like 
 * Describe Statement on an EXECUTE command, we don't worry too much about 
 * efficiency. 
 */ 
</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN548"></a><span class='Declare_Function'>FetchPreparedStatementTargetList</span><span class='Parentheses'>(</span><a href="../../include/commands/prepare.h.html#LN26"><span class='Ref_to_Typedef'>PreparedStatement</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stmt</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN550"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>tlist</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Get the plan's primary targetlist */ 
</span>    <a href="prepare.c.html#LN550"><span class='Ref_To_Local'>tlist</span></a> <span class='Operator'>= </span><a href="../../include/utils/plancache.h.html#LN175"><span class='Ref_to_Proto'>CachedPlanGetTargetList</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN548"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/prepare.h.html#LN30"><span class='Ref_to_Member'>plansource</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Copy into caller's context in case plan gets invalidated */ 
</span>    <span class='Control'>return</span> <a href="../../include/nodes/nodes.h.html#LN618"><span class='Ref_to_Macro'>copyObject</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN550"><span class='Ref_To_Local'>tlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Implements the 'DEALLOCATE' utility statement: deletes the 
 * specified plan from storage. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN564"></a><span class='Declare_Function'>DeallocateQuery</span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN3280"><span class='Ref_to_Struct'>DeallocateStmt</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>stmt</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="prepare.c.html#LN564"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN3283"><span class='Ref_to_Member'>name</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/commands/prepare.h.html#LN53"><span class='Ref_to_Proto'>DropPreparedStatement</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN564"><span class='Ref_to_Parameter'>stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN3283"><span class='Ref_to_Member'>name</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="../../include/commands/prepare.h.html#LN57"><span class='Ref_to_Proto'>DropAllPreparedStatements</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Internal version of DEALLOCATE 
 * 
 * If showError is false, dropping a nonexistent statement is a no-op. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN578"></a><span class='Declare_Function'>DropPreparedStatement</span><span class='Parentheses'>(</span><span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>stmt_name</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>showError</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN580"></a>    <a href="../../include/commands/prepare.h.html#LN26"><span class='Ref_to_Typedef'>PreparedStatement</span></a> <span class='Operator'>*</span><span class='Declare_Local'>entry</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Find the query's hash table entry; raise error if wanted */ 
</span>    <a href="prepare.c.html#LN580"><span class='Ref_To_Local'>entry</span></a> <span class='Operator'>= </span><a href="../../include/commands/prepare.h.html#LN51"><span class='Ref_to_Proto'>FetchPreparedStatement</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN578"><span class='Ref_to_Parameter'>stmt_name</span></a><span class='Delimiter'>, </span><a href="prepare.c.html#LN578"><span class='Ref_to_Parameter'>showError</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="prepare.c.html#LN580"><span class='Ref_To_Local'>entry</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Release the plancache entry */ 
</span>        <a href="../../include/utils/plancache.h.html#LN166"><span class='Ref_to_Proto'>DropCachedPlan</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN580"><span class='Ref_To_Local'>entry</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/prepare.h.html#LN30"><span class='Ref_to_Member'>plansource</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Now we can remove the hash table entry */ 
</span>        <a href="../../include/utils/hsearch.h.html#LN125"><span class='Ref_to_Proto'>hash_search</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN45"><span class='Ref_to_Global_Var'>prepared_queries</span></a><span class='Delimiter'>, </span><a href="prepare.c.html#LN580"><span class='Ref_To_Local'>entry</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/prepare.h.html#LN29"><span class='Ref_to_Member'>stmt_name</span></a><span class='Delimiter'>, </span><a href="../../include/utils/hsearch.h.html#LN106"><span class='Ref_to_EnumConst'>HASH_REMOVE</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Drop all cached statements. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN599"></a><span class='Declare_Function'>DropAllPreparedStatements</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN601"></a>    <a href="../../include/utils/hsearch.h.html#LN111"><span class='Ref_to_Typedef'>HASH_SEQ_STATUS</span></a> <span class='Declare_Local'>seq</span><span class='Delimiter'>; 
</span><a name="LN602"></a>    <a href="../../include/commands/prepare.h.html#LN26"><span class='Ref_to_Typedef'>PreparedStatement</span></a> <span class='Operator'>*</span><span class='Declare_Local'>entry</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* nothing cached */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="prepare.c.html#LN45"><span class='Ref_to_Global_Var'>prepared_queries</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* walk over cache */ 
</span>    <a href="../../include/utils/hsearch.h.html#LN134"><span class='Ref_to_Proto'>hash_seq_init</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="prepare.c.html#LN601"><span class='Ref_To_Local'>seq</span></a><span class='Delimiter'>, </span><a href="prepare.c.html#LN45"><span class='Ref_to_Global_Var'>prepared_queries</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>while</span> <span class='Parentheses'>((</span><a href="prepare.c.html#LN602"><span class='Ref_To_Local'>entry</span></a> <span class='Operator'>= </span><a href="../../include/utils/hsearch.h.html#LN135"><span class='Ref_to_Proto'>hash_seq_search</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="prepare.c.html#LN601"><span class='Ref_To_Local'>seq</span></a><span class='Parentheses'>))</span> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Release the plancache entry */ 
</span>        <a href="../../include/utils/plancache.h.html#LN166"><span class='Ref_to_Proto'>DropCachedPlan</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN602"><span class='Ref_To_Local'>entry</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/prepare.h.html#LN30"><span class='Ref_to_Member'>plansource</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Now we can remove the hash table entry */ 
</span>        <a href="../../include/utils/hsearch.h.html#LN125"><span class='Ref_to_Proto'>hash_search</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN45"><span class='Ref_to_Global_Var'>prepared_queries</span></a><span class='Delimiter'>, </span><a href="prepare.c.html#LN602"><span class='Ref_To_Local'>entry</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/prepare.h.html#LN29"><span class='Ref_to_Member'>stmt_name</span></a><span class='Delimiter'>, </span><a href="../../include/utils/hsearch.h.html#LN106"><span class='Ref_to_EnumConst'>HASH_REMOVE</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end DropAllPreparedStatements &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Implements the 'EXPLAIN EXECUTE' utility statement. 
 * 
 * "into" is NULL unless we are doing EXPLAIN CREATE TABLE AS EXECUTE, 
 * in which case executing the query should result in creating that table. 
 * 
 * Note: the passed-in queryString is that of the EXPLAIN EXECUTE, 
 * not the original PREPARE; we get the latter string from the plancache. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN630"></a><span class='Declare_Function'>ExplainExecuteQuery</span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN3268"><span class='Ref_to_Struct'>ExecuteStmt</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>execstmt</span><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN104"><span class='Ref_to_Struct'>IntoClause</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>into</span><span class='Delimiter'>, </span><a href="../../include/commands/explain.h.html#LN27"><span class='Ref_to_Struct'>ExplainState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>es</span><span class='Delimiter'>, 
</span><a name="LN631"></a>                    <span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Parameter'>queryString</span><span class='Delimiter'>, </span><a href="../../include/nodes/params.h.html#LN61"><span class='Ref_to_Typedef'>ParamListInfo</span></a> <span class='Declare_Parameter'>params</span><span class='Delimiter'>, 
</span><a name="LN632"></a>                    <a href="../utils/misc/queryenvironment.c.html#LN31"><span class='Ref_to_Struct'>QueryEnvironment</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>queryEnv</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN634"></a>    <a href="../../include/commands/prepare.h.html#LN26"><span class='Ref_to_Typedef'>PreparedStatement</span></a> <span class='Operator'>*</span><span class='Declare_Local'>entry</span><span class='Delimiter'>; 
</span><a name="LN635"></a>    <span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Local'>query_string</span><span class='Delimiter'>; 
</span><a name="LN636"></a>    <a href="../../include/utils/plancache.h.html#LN129"><span class='Ref_to_Struct'>CachedPlan</span></a> <span class='Operator'>*</span><span class='Declare_Local'>cplan</span><span class='Delimiter'>; 
</span><a name="LN637"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>plan_list</span><span class='Delimiter'>; 
</span><a name="LN638"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>p</span><span class='Delimiter'>; 
</span><a name="LN639"></a>    <a href="../../include/nodes/params.h.html#LN61"><span class='Ref_to_Typedef'>ParamListInfo</span></a> <span class='Declare_Local'>paramLI</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN640"></a>    <a href="../../include/nodes/execnodes.h.html#LN402"><span class='Ref_to_Struct'>EState</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>estate</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN641"></a>    <a href="../../include/portability/instr_time.h.html#LN146"><span class='Ref_to_Typedef'>instr_time</span></a>  <span class='Declare_Local'>planstart</span><span class='Delimiter'>; 
</span><a name="LN642"></a>    <a href="../../include/portability/instr_time.h.html#LN146"><span class='Ref_to_Typedef'>instr_time</span></a>  <span class='Declare_Local'>planduration</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/portability/instr_time.h.html#LN88"><span class='Ref_to_Macro'>INSTR_TIME_SET_CURRENT</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN641"><span class='Ref_To_Local'>planstart</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Look it up in the hash table */ 
</span>    <a href="prepare.c.html#LN634"><span class='Ref_To_Local'>entry</span></a> <span class='Operator'>= </span><a href="../../include/commands/prepare.h.html#LN51"><span class='Ref_to_Proto'>FetchPreparedStatement</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN630"><span class='Ref_to_Parameter'>execstmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN3271"><span class='Ref_to_Member'>name</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Shouldn't find a non-fixed-result cached plan */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="prepare.c.html#LN634"><span class='Ref_To_Local'>entry</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/prepare.h.html#LN30"><span class='Ref_to_Member'>plansource</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/plancache.h.html#LN90"><span class='Ref_to_Member'>fixed_result</span></a><span class='Parentheses'>) 
</span>        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"EXPLAIN EXECUTE does not support variable-result cached plans"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="prepare.c.html#LN635"><span class='Ref_To_Local'>query_string</span></a> <span class='Operator'>= </span><a href="prepare.c.html#LN634"><span class='Ref_To_Local'>entry</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/prepare.h.html#LN30"><span class='Ref_to_Member'>plansource</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/plancache.h.html#LN83"><span class='Ref_to_Member'>query_string</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Evaluate parameters, if any */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="prepare.c.html#LN634"><span class='Ref_To_Local'>entry</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/prepare.h.html#LN30"><span class='Ref_to_Member'>plansource</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/plancache.h.html#LN86"><span class='Ref_to_Member'>num_params</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Need an EState to evaluate parameters; must not delete it till end 
         * of query, in case parameters are pass-by-reference.  Note that the 
         * passed-in "params" could possibly be referenced in the parameter 
         * expressions. 
         */ 
</span>        <a href="prepare.c.html#LN640"><span class='Ref_To_Local'>estate</span></a> <span class='Operator'>= </span><a href="../executor/execUtils.c.html#LN78"><span class='Ref_to_Func'>CreateExecutorState</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <a href="prepare.c.html#LN640"><span class='Ref_To_Local'>estate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN441"><span class='Ref_to_Member'>es_param_list_info</span></a> <span class='Operator'>= </span><a href="prepare.c.html#LN631"><span class='Ref_to_Parameter'>params</span></a><span class='Delimiter'>; 
</span>        <a href="prepare.c.html#LN639"><span class='Ref_To_Local'>paramLI</span></a> <span class='Operator'>= </span><a href="prepare.c.html#LN48"><span class='Ref_to_Proto'>EvaluateParams</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN634"><span class='Ref_To_Local'>entry</span></a><span class='Delimiter'>, </span><a href="prepare.c.html#LN630"><span class='Ref_to_Parameter'>execstmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN3272"><span class='Ref_to_Member'>params</span></a><span class='Delimiter'>, 
</span>                                 <a href="prepare.c.html#LN631"><span class='Ref_to_Parameter'>queryString</span></a><span class='Delimiter'>, </span><a href="prepare.c.html#LN640"><span class='Ref_To_Local'>estate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Replan if needed, and acquire a transient refcount */ 
</span>    <a href="prepare.c.html#LN636"><span class='Ref_To_Local'>cplan</span></a> <span class='Operator'>= </span><a href="../../include/utils/plancache.h.html#LN178"><span class='Ref_to_Proto'>GetCachedPlan</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN634"><span class='Ref_To_Local'>entry</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/prepare.h.html#LN30"><span class='Ref_to_Member'>plansource</span></a><span class='Delimiter'>, </span><a href="prepare.c.html#LN639"><span class='Ref_To_Local'>paramLI</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, </span><a href="prepare.c.html#LN632"><span class='Ref_to_Parameter'>queryEnv</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/portability/instr_time.h.html#LN88"><span class='Ref_to_Macro'>INSTR_TIME_SET_CURRENT</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN642"><span class='Ref_To_Local'>planduration</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/portability/instr_time.h.html#LN102"><span class='Ref_to_Macro'>INSTR_TIME_SUBTRACT</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN642"><span class='Ref_To_Local'>planduration</span></a><span class='Delimiter'>, </span><a href="prepare.c.html#LN641"><span class='Ref_To_Local'>planstart</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="prepare.c.html#LN637"><span class='Ref_To_Local'>plan_list</span></a> <span class='Operator'>= </span><a href="prepare.c.html#LN636"><span class='Ref_To_Local'>cplan</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/plancache.h.html#LN132"><span class='Ref_to_Member'>stmt_list</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Explain each query */ 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN638"><span class='Ref_To_Local'>p</span></a><span class='Delimiter'>, </span><a href="prepare.c.html#LN637"><span class='Ref_To_Local'>plan_list</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN681"></a>        <a href="../../include/nodes/plannodes.h.html#LN40"><span class='Ref_to_Struct'>PlannedStmt</span></a> <span class='Operator'>*</span><span class='Declare_Local'>pstmt</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN108"><span class='Ref_to_Macro'>lfirst_node</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/plannodes.h.html#LN40"><span class='Ref_to_Struct'>PlannedStmt</span></a><span class='Delimiter'>, </span><a href="prepare.c.html#LN638"><span class='Ref_To_Local'>p</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="prepare.c.html#LN681"><span class='Ref_To_Local'>pstmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN44"><span class='Ref_to_Member'>commandType</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/nodes.h.html#LN654"><span class='Ref_to_EnumConst'>CMD_UTILITY</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/commands/explain.h.html#LN74"><span class='Ref_to_Proto'>ExplainOnePlan</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN681"><span class='Ref_To_Local'>pstmt</span></a><span class='Delimiter'>, </span><a href="prepare.c.html#LN630"><span class='Ref_to_Parameter'>into</span></a><span class='Delimiter'>, </span><a href="prepare.c.html#LN630"><span class='Ref_to_Parameter'>es</span></a><span class='Delimiter'>, </span><a href="prepare.c.html#LN635"><span class='Ref_To_Local'>query_string</span></a><span class='Delimiter'>, </span><a href="prepare.c.html#LN639"><span class='Ref_To_Local'>paramLI</span></a><span class='Delimiter'>, </span><a href="prepare.c.html#LN632"><span class='Ref_to_Parameter'>queryEnv</span></a><span class='Delimiter'>, 
</span>                           <span class='Operator'>&</span><a href="prepare.c.html#LN642"><span class='Ref_To_Local'>planduration</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="../../include/commands/explain.h.html#LN70"><span class='Ref_to_Proto'>ExplainOneUtility</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN681"><span class='Ref_To_Local'>pstmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN93"><span class='Ref_to_Member'>utilityStmt</span></a><span class='Delimiter'>, </span><a href="prepare.c.html#LN630"><span class='Ref_to_Parameter'>into</span></a><span class='Delimiter'>, </span><a href="prepare.c.html#LN630"><span class='Ref_to_Parameter'>es</span></a><span class='Delimiter'>, </span><a href="prepare.c.html#LN635"><span class='Ref_To_Local'>query_string</span></a><span class='Delimiter'>, 
</span>                              <a href="prepare.c.html#LN639"><span class='Ref_To_Local'>paramLI</span></a><span class='Delimiter'>, </span><a href="prepare.c.html#LN632"><span class='Ref_to_Parameter'>queryEnv</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* No need for CommandCounterIncrement, as ExplainOnePlan did it */ 
</span> 
        <span class='Comment_Multi_Line'>/* Separate plans with an appropriate separator */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN638"><span class='Ref_To_Local'>p</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
            <a href="../../include/commands/explain.h.html#LN86"><span class='Ref_to_Proto'>ExplainSeparatePlans</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN630"><span class='Ref_to_Parameter'>es</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="prepare.c.html#LN640"><span class='Ref_To_Local'>estate</span></a><span class='Parentheses'>) 
</span>        <a href="../executor/execUtils.c.html#LN176"><span class='Ref_to_Func'>FreeExecutorState</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN640"><span class='Ref_To_Local'>estate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/utils/plancache.h.html#LN182"><span class='Ref_to_Proto'>ReleaseCachedPlan</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN636"><span class='Ref_To_Local'>cplan</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ExplainExecuteQuery &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * This set returning function reads all the prepared statements and 
 * returns a set of (name, statement, prepare_time, param_types, from_sql). 
 */ 
</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN708"></a><span class='Declare_Function'>pg_prepared_statement</span><span class='Parentheses'>(</span><a href="../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN710"></a>    <a href="../../include/nodes/execnodes.h.html#LN261"><span class='Ref_to_Struct'>ReturnSetInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rsinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN261"><span class='Ref_to_Struct'>ReturnSetInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span>fcinfo<span class='Operator'>-&GT;</span>resultinfo<span class='Delimiter'>; 
</span><a name="LN711"></a>    <a href="../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a>   <span class='Declare_Local'>tupdesc</span><span class='Delimiter'>; 
</span><a name="LN712"></a>    <a href="../utils/sort/tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tupstore</span><span class='Delimiter'>; 
</span><a name="LN713"></a>    <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>per_query_ctx</span><span class='Delimiter'>; 
</span><a name="LN714"></a>    <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldcontext</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* check to see if caller supports us returning a tuplestore */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="prepare.c.html#LN710"><span class='Ref_To_Local'>rsinfo</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>|| !</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN710"><span class='Ref_To_Local'>rsinfo</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/execnodes.h.html#LN261"><span class='Ref_to_Struct'>ReturnSetInfo</span></a><span class='Parentheses'>))</span> 
        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"set-valued function called in context that cannot accept a set"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span><a href="prepare.c.html#LN710"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN267"><span class='Ref_to_Member'>allowedModes</span></a> <span class='Operator'>& </span><a href="../../include/nodes/execnodes.h.html#LN250"><span class='Ref_to_EnumConst'>SFRM_Materialize</span></a><span class='Parentheses'>))</span> 
        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"materialize mode required, but it is not "</span> <span class='Operator'>\ 
</span>                        <span class='String'>"allowed in this context"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* need to build tuplestore in query context */ 
</span>    <a href="prepare.c.html#LN713"><span class='Ref_To_Local'>per_query_ctx</span></a> <span class='Operator'>= </span><a href="prepare.c.html#LN710"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN265"><span class='Ref_to_Member'>econtext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN201"><span class='Ref_to_Member'>ecxt_per_query_memory</span></a><span class='Delimiter'>; 
</span>    <a href="prepare.c.html#LN714"><span class='Ref_To_Local'>oldcontext</span></a> <span class='Operator'>= </span><a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN713"><span class='Ref_To_Local'>per_query_ctx</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * build tupdesc for result tuples. This must match the definition of the 
     * pg_prepared_statements view in system_views.sql 
     */ 
</span>    <a href="prepare.c.html#LN711"><span class='Ref_To_Local'>tupdesc</span></a> <span class='Operator'>= </span><a href="../access/common/tupdesc.c.html#LN39"><span class='Ref_to_Func'>CreateTemplateTupleDesc</span></a><span class='Parentheses'>(</span><span class='Number'>5</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/access/tupdesc.h.html#LN114"><span class='Ref_to_Proto'>TupleDescInitEntry</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN711"><span class='Ref_To_Local'>tupdesc</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a><span class='Parentheses'>) </span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='String'>"name"</span><span class='Delimiter'>, 
</span>                       <a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN26"><span class='Ref_to_Const'>TEXTOID</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/access/tupdesc.h.html#LN114"><span class='Ref_to_Proto'>TupleDescInitEntry</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN711"><span class='Ref_To_Local'>tupdesc</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a><span class='Parentheses'>) </span><span class='Number'>2</span><span class='Delimiter'>, </span><span class='String'>"statement"</span><span class='Delimiter'>, 
</span>                       <a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN26"><span class='Ref_to_Const'>TEXTOID</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/access/tupdesc.h.html#LN114"><span class='Ref_to_Proto'>TupleDescInitEntry</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN711"><span class='Ref_To_Local'>tupdesc</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a><span class='Parentheses'>) </span><span class='Number'>3</span><span class='Delimiter'>, </span><span class='String'>"prepare_time"</span><span class='Delimiter'>, 
</span>                       <a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN53"><span class='Ref_to_Const'>TIMESTAMPTZOID</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/access/tupdesc.h.html#LN114"><span class='Ref_to_Proto'>TupleDescInitEntry</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN711"><span class='Ref_To_Local'>tupdesc</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a><span class='Parentheses'>) </span><span class='Number'>4</span><span class='Delimiter'>, </span><span class='String'>"parameter_types"</span><span class='Delimiter'>, 
</span>                       <a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN67"><span class='Ref_to_Const'>REGTYPEARRAYOID</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/access/tupdesc.h.html#LN114"><span class='Ref_to_Proto'>TupleDescInitEntry</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN711"><span class='Ref_To_Local'>tupdesc</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a><span class='Parentheses'>) </span><span class='Number'>5</span><span class='Delimiter'>, </span><span class='String'>"from_sql"</span><span class='Delimiter'>, 
</span>                       <a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN17"><span class='Ref_to_Const'>BOOLOID</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We put all the tuples into a tuplestore in one scan of the hashtable. 
     * This avoids any issue of the hashtable possibly changing between calls. 
     */ 
</span>    <a href="prepare.c.html#LN712"><span class='Ref_To_Local'>tupstore</span></a> <span class='Operator'>= 
</span>        <a href="../../include/utils/tuplestore.h.html#LN46"><span class='Ref_to_Proto'>tuplestore_begin_heap</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN710"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN267"><span class='Ref_to_Member'>allowedModes</span></a> <span class='Operator'>& </span><a href="../../include/nodes/execnodes.h.html#LN251"><span class='Ref_to_EnumConst'>SFRM_Materialize_Random</span></a><span class='Delimiter'>, 
</span>                              <span class='Boolean'>false</span><span class='Delimiter'>, </span><a href="../utils/init/globals.c.html#LN112"><span class='Ref_to_Global_Var'>work_mem</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* generate junk in short-term context */ 
</span>    <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN714"><span class='Ref_To_Local'>oldcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* hash table might be uninitialized */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="prepare.c.html#LN45"><span class='Ref_to_Global_Var'>prepared_queries</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN761"></a>        <a href="../../include/utils/hsearch.h.html#LN111"><span class='Ref_to_Typedef'>HASH_SEQ_STATUS</span></a> <span class='Declare_Local'>hash_seq</span><span class='Delimiter'>; 
</span><a name="LN762"></a>        <a href="../../include/commands/prepare.h.html#LN26"><span class='Ref_to_Typedef'>PreparedStatement</span></a> <span class='Operator'>*</span><span class='Declare_Local'>prep_stmt</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/utils/hsearch.h.html#LN134"><span class='Ref_to_Proto'>hash_seq_init</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="prepare.c.html#LN761"><span class='Ref_To_Local'>hash_seq</span></a><span class='Delimiter'>, </span><a href="prepare.c.html#LN45"><span class='Ref_to_Global_Var'>prepared_queries</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>while</span> <span class='Parentheses'>((</span><a href="prepare.c.html#LN762"><span class='Ref_To_Local'>prep_stmt</span></a> <span class='Operator'>= </span><a href="../../include/utils/hsearch.h.html#LN135"><span class='Ref_to_Proto'>hash_seq_search</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="prepare.c.html#LN761"><span class='Ref_To_Local'>hash_seq</span></a><span class='Parentheses'>))</span> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span><a name="LN767"></a>            <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>values</span><span class='Delimiter'>[</span><span class='Number'>5</span><span class='Delimiter'>]; 
</span><a name="LN768"></a>            <span class='Keyword'>bool</span>        <span class='Declare_Local'>nulls</span><span class='Delimiter'>[</span><span class='Number'>5</span><span class='Delimiter'>]; 
</span> 
            <a href="../../include/c.h.html#LN856"><span class='Ref_to_Macro'>MemSet</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN768"><span class='Ref_To_Local'>nulls</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="prepare.c.html#LN768"><span class='Ref_To_Local'>nulls</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
            <a href="prepare.c.html#LN767"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/utils/builtins.h.html#LN90"><span class='Ref_to_Macro'>CStringGetTextDatum</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN762"><span class='Ref_To_Local'>prep_stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/prepare.h.html#LN29"><span class='Ref_to_Member'>stmt_name</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="prepare.c.html#LN767"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/utils/builtins.h.html#LN90"><span class='Ref_to_Macro'>CStringGetTextDatum</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN762"><span class='Ref_To_Local'>prep_stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/prepare.h.html#LN30"><span class='Ref_to_Member'>plansource</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/plancache.h.html#LN83"><span class='Ref_to_Member'>query_string</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="prepare.c.html#LN767"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><span class='Number'>2</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/utils/timestamp.h.html#LN31"><span class='Ref_to_Macro'>TimestampTzGetDatum</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN762"><span class='Ref_To_Local'>prep_stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/prepare.h.html#LN32"><span class='Ref_to_Member'>prepare_time</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="prepare.c.html#LN767"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><span class='Number'>3</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="prepare.c.html#LN50"><span class='Ref_to_Proto'>build_regtype_array</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN762"><span class='Ref_To_Local'>prep_stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/prepare.h.html#LN30"><span class='Ref_to_Member'>plansource</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/plancache.h.html#LN85"><span class='Ref_to_Member'>param_types</span></a><span class='Delimiter'>, 
</span>                                          <a href="prepare.c.html#LN762"><span class='Ref_To_Local'>prep_stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/prepare.h.html#LN30"><span class='Ref_to_Member'>plansource</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/plancache.h.html#LN86"><span class='Ref_to_Member'>num_params</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="prepare.c.html#LN767"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>[</span><span class='Number'>4</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/postgres.h.html#LN407"><span class='Ref_to_Macro'>BoolGetDatum</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN762"><span class='Ref_To_Local'>prep_stmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/prepare.h.html#LN31"><span class='Ref_to_Member'>from_sql</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="../../include/utils/tuplestore.h.html#LN55"><span class='Ref_to_Proto'>tuplestore_putvalues</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN712"><span class='Ref_To_Local'>tupstore</span></a><span class='Delimiter'>, </span><a href="prepare.c.html#LN711"><span class='Ref_To_Local'>tupdesc</span></a><span class='Delimiter'>, </span><a href="prepare.c.html#LN767"><span class='Ref_To_Local'>values</span></a><span class='Delimiter'>, </span><a href="prepare.c.html#LN768"><span class='Ref_To_Local'>nulls</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if prepared_queries &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* clean up and return the tuplestore */ 
</span>    <a href="../../include/utils/tuplestore.h.html#LN59"><span class='Ref_to_Macro'>tuplestore_donestoring</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN712"><span class='Ref_To_Local'>tupstore</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="prepare.c.html#LN710"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN269"><span class='Ref_to_Member'>returnMode</span></a> <span class='Operator'>= </span><a href="../../include/nodes/execnodes.h.html#LN250"><span class='Ref_to_EnumConst'>SFRM_Materialize</span></a><span class='Delimiter'>; 
</span>    <a href="prepare.c.html#LN710"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN272"><span class='Ref_to_Member'>setResult</span></a> <span class='Operator'>= </span><a href="prepare.c.html#LN712"><span class='Ref_To_Local'>tupstore</span></a><span class='Delimiter'>; 
</span>    <a href="prepare.c.html#LN710"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN273"><span class='Ref_to_Member'>setDesc</span></a> <span class='Operator'>= </span><a href="prepare.c.html#LN711"><span class='Ref_To_Local'>tupdesc</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end pg_prepared_statement &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * This utility function takes a C array of Oids, and returns a Datum 
 * pointing to a one-dimensional Postgres array of regtypes. An empty 
 * array is returned as a zero-element array, not NULL. 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN799"></a><span class='Declare_Function'>build_regtype_array</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>param_types</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>num_params</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN801"></a>    <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>tmp_ary</span><span class='Delimiter'>; 
</span><a name="LN802"></a>    <a href="../../include/utils/array.h.html#LN75"><span class='Ref_to_Typedef'>ArrayType</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span><a name="LN803"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <a href="prepare.c.html#LN801"><span class='Ref_To_Local'>tmp_ary</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN799"><span class='Ref_to_Parameter'>num_params</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="prepare.c.html#LN803"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="prepare.c.html#LN803"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="prepare.c.html#LN799"><span class='Ref_to_Parameter'>num_params</span></a><span class='Delimiter'>; </span><a href="prepare.c.html#LN803"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <a href="prepare.c.html#LN801"><span class='Ref_To_Local'>tmp_ary</span></a><span class='Delimiter'>[</span><a href="prepare.c.html#LN803"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN799"><span class='Ref_to_Parameter'>param_types</span></a><span class='Delimiter'>[</span><a href="prepare.c.html#LN803"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* XXX: this hardcodes assumptions about the regtype type */ 
</span>    <a href="prepare.c.html#LN802"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/utils/array.h.html#LN369"><span class='Ref_to_Proto'>construct_array</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN801"><span class='Ref_To_Local'>tmp_ary</span></a><span class='Delimiter'>, </span><a href="prepare.c.html#LN799"><span class='Ref_to_Parameter'>num_params</span></a><span class='Delimiter'>, </span><a href="../../interfaces/ecpg/ecpglib/pg_type.h.html#LN64"><span class='Ref_to_Const'>REGTYPEOID</span></a><span class='Delimiter'>, </span><span class='Number'>4</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='String'>'i'</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><a href="prepare.c.html#LN802"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span></pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>