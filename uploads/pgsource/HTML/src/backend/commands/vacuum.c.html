<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\commands\vacuum.c</title>
<LINK REL=StyleSheet HREF="../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\commands\vacuum.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:37 2017
</td></tr>
<tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * vacuum.c 
 *    The postgres vacuum cleaner. 
 * 
 * This file now includes only control and dispatch code for VACUUM and 
 * ANALYZE commands.  Regular VACUUM is implemented in vacuumlazy.c, 
 * ANALYZE in analyze.c, and VACUUM FULL is a variant of CLUSTER, handled 
 * in cluster.c. 
 * 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * 
 * IDENTIFICATION 
 *    src/backend/commands/vacuum.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>&LT;math.h&GT;</span> 
 
<span class='Keyword'>#include </span><span class='String'>"access/clog.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/commit_ts.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/genam.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/heapam.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/htup_details.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/multixact.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/transam.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/xact.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/namespace.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_database.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_inherits_fn.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_namespace.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"commands/cluster.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"commands/vacuum.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"miscadmin.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"pgstat.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"postmaster/autovacuum.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/bufmgr.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/lmgr.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/proc.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"storage/procarray.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/acl.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/fmgroids.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/guc.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/memutils.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/snapmgr.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/syscache.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/tqual.h"</span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * GUC parameters 
 */ 
</span><a name="LN57"></a><span class='Keyword'>int</span>         <span class='Declare_Var'>vacuum_freeze_min_age</span><span class='Delimiter'>; 
</span><a name="LN58"></a><span class='Keyword'>int</span>         <span class='Declare_Var'>vacuum_freeze_table_age</span><span class='Delimiter'>; 
</span><a name="LN59"></a><span class='Keyword'>int</span>         <span class='Declare_Var'>vacuum_multixact_freeze_min_age</span><span class='Delimiter'>; 
</span><a name="LN60"></a><span class='Keyword'>int</span>         <span class='Declare_Var'>vacuum_multixact_freeze_table_age</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* A few variables that don't seem worth passing around as parameters */ 
</span><a name="LN64"></a><span class='Keyword'>static </span><a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Var'>vac_context</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN65"></a><span class='Keyword'>static </span><a href="../../include/storage/buf.h.html#LN43"><span class='Ref_to_Typedef'>BufferAccessStrategy</span></a> <span class='Declare_Var'>vac_strategy</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* non-export function prototypes */ 
</span><a name="LN69"></a><span class='Keyword'>static </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>get_rel_oids</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>relid</span><span class='Delimiter'>, </span><span class='Keyword'>const </span><a href="../../include/nodes/primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>vacrel</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN70"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>vac_truncate_clog</span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>frozenXID</span><span class='Delimiter'>, 
</span><a name="LN71"></a>                  <a href="../../include/c.h.html#LN406"><span class='Ref_to_Typedef'>MultiXactId</span></a> <span class='Declare_Parameter'>minMulti</span><span class='Delimiter'>, 
</span><a name="LN72"></a>                  <a href="../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>lastSaneFrozenXid</span><span class='Delimiter'>, 
</span><a name="LN73"></a>                  <a href="../../include/c.h.html#LN406"><span class='Ref_to_Typedef'>MultiXactId</span></a> <span class='Declare_Parameter'>lastSaneMinMulti</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN74"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>vacuum_rel</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>relid</span><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>relation</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>options</span><span class='Delimiter'>, 
</span><a name="LN75"></a>           <a href="../../include/commands/vacuum.h.html#LN135"><span class='Ref_to_Struct'>VacuumParams</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>params</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Primary entry point for manual VACUUM and ANALYZE commands 
 * 
 * This is mainly a preparation wrapper for the real operations that will 
 * happen in vacuum(). 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN84"></a><span class='Declare_Function'>ExecVacuum</span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN3072"><span class='Ref_to_Struct'>VacuumStmt</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>vacstmt</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>isTopLevel</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN86"></a>    <a href="../../include/commands/vacuum.h.html#LN135"><span class='Ref_to_Struct'>VacuumParams</span></a> <span class='Declare_Local'>params</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* sanity checks on options */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="vacuum.c.html#LN84"><span class='Ref_to_Parameter'>vacstmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN3075"><span class='Ref_to_Member'>options</span></a> <span class='Operator'>& </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN3062"><span class='Ref_to_EnumConst'>VACOPT_VACUUM</span></a> <span class='Operator'>| </span><a href="../../include/nodes/parsenodes.h.html#LN3063"><span class='Ref_to_EnumConst'>VACOPT_ANALYZE</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>((</span><a href="vacuum.c.html#LN84"><span class='Ref_to_Parameter'>vacstmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN3075"><span class='Ref_to_Member'>options</span></a> <span class='Operator'>& </span><a href="../../include/nodes/parsenodes.h.html#LN3062"><span class='Ref_to_EnumConst'>VACOPT_VACUUM</span></a><span class='Parentheses'>)</span> <span class='Operator'>|| 
</span>           <span class='Operator'>!</span><span class='Parentheses'>(</span><a href="vacuum.c.html#LN84"><span class='Ref_to_Parameter'>vacstmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN3075"><span class='Ref_to_Member'>options</span></a> <span class='Operator'>& </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN3066"><span class='Ref_to_EnumConst'>VACOPT_FULL</span></a> <span class='Operator'>| </span><a href="../../include/nodes/parsenodes.h.html#LN3065"><span class='Ref_to_EnumConst'>VACOPT_FREEZE</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>((</span><a href="vacuum.c.html#LN84"><span class='Ref_to_Parameter'>vacstmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN3075"><span class='Ref_to_Member'>options</span></a> <span class='Operator'>& </span><a href="../../include/nodes/parsenodes.h.html#LN3063"><span class='Ref_to_EnumConst'>VACOPT_ANALYZE</span></a><span class='Parentheses'>) </span><span class='Operator'>|| </span><a href="vacuum.c.html#LN84"><span class='Ref_to_Parameter'>vacstmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN3077"><span class='Ref_to_Member'>va_cols</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span><a href="vacuum.c.html#LN84"><span class='Ref_to_Parameter'>vacstmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN3075"><span class='Ref_to_Member'>options</span></a> <span class='Operator'>& </span><a href="../../include/nodes/parsenodes.h.html#LN3068"><span class='Ref_to_EnumConst'>VACOPT_SKIPTOAST</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * All freeze ages are zero if the FREEZE option is given; otherwise pass 
     * them as -1 which means to use the default values. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN84"><span class='Ref_to_Parameter'>vacstmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN3075"><span class='Ref_to_Member'>options</span></a> <span class='Operator'>& </span><a href="../../include/nodes/parsenodes.h.html#LN3065"><span class='Ref_to_EnumConst'>VACOPT_FREEZE</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="vacuum.c.html#LN86"><span class='Ref_To_Local'>params</span></a><span class='Operator'>.</span><a href="../../include/commands/vacuum.h.html#LN137"><span class='Ref_to_Member'>freeze_min_age</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="vacuum.c.html#LN86"><span class='Ref_To_Local'>params</span></a><span class='Operator'>.</span><a href="../../include/commands/vacuum.h.html#LN138"><span class='Ref_to_Member'>freeze_table_age</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="vacuum.c.html#LN86"><span class='Ref_To_Local'>params</span></a><span class='Operator'>.</span><a href="../../include/commands/vacuum.h.html#LN139"><span class='Ref_to_Member'>multixact_freeze_min_age</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="vacuum.c.html#LN86"><span class='Ref_To_Local'>params</span></a><span class='Operator'>.</span><a href="../../include/commands/vacuum.h.html#LN141"><span class='Ref_to_Member'>multixact_freeze_table_age</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="vacuum.c.html#LN86"><span class='Ref_To_Local'>params</span></a><span class='Operator'>.</span><a href="../../include/commands/vacuum.h.html#LN137"><span class='Ref_to_Member'>freeze_min_age</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>        <a href="vacuum.c.html#LN86"><span class='Ref_To_Local'>params</span></a><span class='Operator'>.</span><a href="../../include/commands/vacuum.h.html#LN138"><span class='Ref_to_Member'>freeze_table_age</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>        <a href="vacuum.c.html#LN86"><span class='Ref_To_Local'>params</span></a><span class='Operator'>.</span><a href="../../include/commands/vacuum.h.html#LN139"><span class='Ref_to_Member'>multixact_freeze_min_age</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>        <a href="vacuum.c.html#LN86"><span class='Ref_To_Local'>params</span></a><span class='Operator'>.</span><a href="../../include/commands/vacuum.h.html#LN141"><span class='Ref_to_Member'>multixact_freeze_table_age</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* user-invoked vacuum is never "for wraparound" */ 
</span>    <a href="vacuum.c.html#LN86"><span class='Ref_To_Local'>params</span></a><span class='Operator'>.</span><a href="../../include/commands/vacuum.h.html#LN143"><span class='Ref_to_Member'>is_wraparound</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* user-invoked vacuum never uses this parameter */ 
</span>    <a href="vacuum.c.html#LN86"><span class='Ref_To_Local'>params</span></a><span class='Operator'>.</span><a href="../../include/commands/vacuum.h.html#LN144"><span class='Ref_to_Member'>log_min_duration</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Now go through the common routine */ 
</span>    <a href="vacuum.c.html#LN147"><span class='Ref_to_Func'>vacuum</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN84"><span class='Ref_to_Parameter'>vacstmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN3075"><span class='Ref_to_Member'>options</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN84"><span class='Ref_to_Parameter'>vacstmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN3076"><span class='Ref_to_Member'>relation</span></a><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="vacuum.c.html#LN86"><span class='Ref_To_Local'>params</span></a><span class='Delimiter'>, 
</span>           <a href="vacuum.c.html#LN84"><span class='Ref_to_Parameter'>vacstmt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN3077"><span class='Ref_to_Member'>va_cols</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><a href="vacuum.c.html#LN84"><span class='Ref_to_Parameter'>isTopLevel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ExecVacuum &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Primary entry point for VACUUM and ANALYZE commands. 
 * 
 * options is a bitmask of VacuumOption flags, indicating what to do. 
 * 
 * relid, if not InvalidOid, indicate the relation to process; otherwise, 
 * the RangeVar is used.  (The latter must always be passed, because it's 
 * used for error messages.) 
 * 
 * params contains a set of parameters that can be used to customize the 
 * behavior. 
 * 
 * va_cols is a list of columns to analyze, or NIL to process them all. 
 * 
 * bstrategy is normally given as NULL, but in autovacuum it can be passed 
 * in to use the same buffer strategy object across multiple vacuum() calls. 
 * 
 * isTopLevel should be passed down from ProcessUtility. 
 * 
 * It is the caller's responsibility that all parameters are allocated in a 
 * memory context that will not disappear at transaction commit. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN148"></a><span class='Declare_Function'>vacuum</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>options</span><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>relation</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>relid</span><span class='Delimiter'>, </span><a href="../../include/commands/vacuum.h.html#LN135"><span class='Ref_to_Struct'>VacuumParams</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>params</span><span class='Delimiter'>, 
</span><a name="LN149"></a>       <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>va_cols</span><span class='Delimiter'>, </span><a href="../../include/storage/buf.h.html#LN43"><span class='Ref_to_Typedef'>BufferAccessStrategy</span></a> <span class='Declare_Parameter'>bstrategy</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>isTopLevel</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN151"></a>    <span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Local'>stmttype</span><span class='Delimiter'>; 
</span><a name="LN152"></a>    <span class='Keyword'>volatile bool </span><span class='Declare_Local'>in_outer_xact</span><span class='Delimiter'>, 
</span><a name="LN153"></a>                <span class='Declare_Local'>use_own_xacts</span><span class='Delimiter'>; 
</span><a name="LN154"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>relations</span><span class='Delimiter'>; 
</span><a name="LN155"></a>    <span class='Keyword'>static bool </span><span class='Declare_Local'>in_vacuum</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="vacuum.c.html#LN148"><span class='Ref_to_Parameter'>params</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="vacuum.c.html#LN151"><span class='Ref_To_Local'>stmttype</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="vacuum.c.html#LN148"><span class='Ref_to_Parameter'>options</span></a> <span class='Operator'>& </span><a href="../../include/nodes/parsenodes.h.html#LN3062"><span class='Ref_to_EnumConst'>VACOPT_VACUUM</span></a><span class='Parentheses'>) </span><span class='Operator'>? </span><span class='String'>"VACUUM"</span> <span class='Operator'>: </span><span class='String'>"ANALYZE"</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We cannot run VACUUM inside a user transaction block; if we were inside 
     * a transaction, then our commit- and start-transaction-command calls 
     * would not have the intended effect!  There are numerous other subtle 
     * dependencies on this, too. 
     * 
     * ANALYZE (without VACUUM) can run either way. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN148"><span class='Ref_to_Parameter'>options</span></a> <span class='Operator'>& </span><a href="../../include/nodes/parsenodes.h.html#LN3062"><span class='Ref_to_EnumConst'>VACOPT_VACUUM</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../include/access/xact.h.html#LN370"><span class='Ref_to_Proto'>PreventTransactionChain</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN149"><span class='Ref_to_Parameter'>isTopLevel</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN151"><span class='Ref_To_Local'>stmttype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="vacuum.c.html#LN152"><span class='Ref_To_Local'>in_outer_xact</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
        <a href="vacuum.c.html#LN152"><span class='Ref_To_Local'>in_outer_xact</span></a> <span class='Operator'>= </span><a href="../../include/access/xact.h.html#LN373"><span class='Ref_to_Proto'>IsInTransactionChain</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN149"><span class='Ref_to_Parameter'>isTopLevel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Due to static variables vac_context, anl_context and vac_strategy, 
     * vacuum() is not reentrant.  This matters when VACUUM FULL or ANALYZE 
     * calls a hostile index expression that itself calls ANALYZE. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN155"><span class='Ref_To_Local'>in_vacuum</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"%s cannot be executed from VACUUM or ANALYZE"</span><span class='Delimiter'>, 
</span>                        <a href="vacuum.c.html#LN151"><span class='Ref_To_Local'>stmttype</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Sanity check DISABLE_PAGE_SKIPPING option. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="vacuum.c.html#LN148"><span class='Ref_to_Parameter'>options</span></a> <span class='Operator'>& </span><a href="../../include/nodes/parsenodes.h.html#LN3066"><span class='Ref_to_EnumConst'>VACOPT_FULL</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span> <span class='Operator'>&& 
</span>        <span class='Parentheses'>(</span><a href="vacuum.c.html#LN148"><span class='Ref_to_Parameter'>options</span></a> <span class='Operator'>& </span><a href="../../include/nodes/parsenodes.h.html#LN3069"><span class='Ref_to_EnumConst'>VACOPT_DISABLE_PAGE_SKIPPING</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"VACUUM option DISABLE_PAGE_SKIPPING cannot be used with FULL"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Send info about dead objects to the statistics collector, unless we are 
     * in autovacuum --- autovacuum.c does this for itself. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="vacuum.c.html#LN148"><span class='Ref_to_Parameter'>options</span></a> <span class='Operator'>& </span><a href="../../include/nodes/parsenodes.h.html#LN3062"><span class='Ref_to_EnumConst'>VACOPT_VACUUM</span></a><span class='Parentheses'>) </span><span class='Operator'>&& !</span><a href="../../include/postmaster/autovacuum.h.html#LN50"><span class='Ref_to_Proto'>IsAutoVacuumWorkerProcess</span></a><span class='Parentheses'>())</span> 
        <a href="../postmaster/pgstat.c.html#LN1020"><span class='Ref_to_Func'>pgstat_vacuum_stat</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Create special memory context for cross-transaction storage. 
     * 
     * Since it is a child of PortalContext, it will go away eventually even 
     * if we suffer an error; there's no need for special abort cleanup logic. 
     */ 
</span>    <a href="vacuum.c.html#LN64"><span class='Ref_to_Global_Var'>vac_context</span></a> <span class='Operator'>= </span><a href="../../include/utils/memutils.h.html#LN145"><span class='Ref_to_Proto'>AllocSetContextCreate</span></a><span class='Parentheses'>(</span><a href="../utils/mmgr/mcxt.c.html#LN51"><span class='Ref_to_Global_Var'>PortalContext</span></a><span class='Delimiter'>, 
</span>                                        <span class='String'>"Vacuum"</span><span class='Delimiter'>, 
</span>                                        <a href="../../include/utils/memutils.h.html#LN164"><span class='Ref_to_Const'>ALLOCSET_DEFAULT_SIZES</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If caller didn't give us a buffer strategy object, make one in the 
     * cross-transaction memory context. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN149"><span class='Ref_to_Parameter'>bstrategy</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN220"></a>        <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>old_context</span> <span class='Operator'>= </span><a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN64"><span class='Ref_to_Global_Var'>vac_context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="vacuum.c.html#LN149"><span class='Ref_to_Parameter'>bstrategy</span></a> <span class='Operator'>= </span><a href="../../include/storage/bufmgr.h.html#LN231"><span class='Ref_to_Proto'>GetAccessStrategy</span></a><span class='Parentheses'>(</span><a href="../../include/storage/bufmgr.h.html#LN33"><span class='Ref_to_EnumConst'>BAS_VACUUM</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN220"><span class='Ref_To_Local'>old_context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="vacuum.c.html#LN65"><span class='Ref_to_Global_Var'>vac_strategy</span></a> <span class='Operator'>= </span><a href="vacuum.c.html#LN149"><span class='Ref_to_Parameter'>bstrategy</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Build list of relations to process, unless caller gave us one. (If we 
     * build one, we put it in vac_context for safekeeping.) 
     */ 
</span>    <a href="vacuum.c.html#LN154"><span class='Ref_To_Local'>relations</span></a> <span class='Operator'>= </span><a href="vacuum.c.html#LN69"><span class='Ref_to_Proto'>get_rel_oids</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN148"><span class='Ref_to_Parameter'>relid</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN148"><span class='Ref_to_Parameter'>relation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Decide whether we need to start/commit our own transactions. 
     * 
     * For VACUUM (with or without ANALYZE): always do so, so that we can 
     * release locks as soon as possible.  (We could possibly use the outer 
     * transaction for a one-table VACUUM, but handling TOAST tables would be 
     * problematic.) 
     * 
     * For ANALYZE (no VACUUM): if inside a transaction block, we cannot 
     * start/commit our own transactions.  Also, there's no need to do so if 
     * only processing one relation.  For multiple relations when not within a 
     * transaction block, and also in an autovacuum worker, use own 
     * transactions so we can release locks sooner. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN148"><span class='Ref_to_Parameter'>options</span></a> <span class='Operator'>& </span><a href="../../include/nodes/parsenodes.h.html#LN3062"><span class='Ref_to_EnumConst'>VACOPT_VACUUM</span></a><span class='Parentheses'>) 
</span>        <a href="vacuum.c.html#LN153"><span class='Ref_To_Local'>use_own_xacts</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="vacuum.c.html#LN148"><span class='Ref_to_Parameter'>options</span></a> <span class='Operator'>& </span><a href="../../include/nodes/parsenodes.h.html#LN3063"><span class='Ref_to_EnumConst'>VACOPT_ANALYZE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/postmaster/autovacuum.h.html#LN50"><span class='Ref_to_Proto'>IsAutoVacuumWorkerProcess</span></a><span class='Parentheses'>())</span> 
            <a href="vacuum.c.html#LN153"><span class='Ref_To_Local'>use_own_xacts</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN152"><span class='Ref_To_Local'>in_outer_xact</span></a><span class='Parentheses'>) 
</span>            <a href="vacuum.c.html#LN153"><span class='Ref_To_Local'>use_own_xacts</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN154"><span class='Ref_To_Local'>relations</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
            <a href="vacuum.c.html#LN153"><span class='Ref_To_Local'>use_own_xacts</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="vacuum.c.html#LN153"><span class='Ref_To_Local'>use_own_xacts</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * vacuum_rel expects to be entered with no transaction active; it will 
     * start and commit its own transaction.  But we are called by an SQL 
     * command, and so we are executing inside a transaction already. We 
     * commit the transaction started in PostgresMain() here, and start 
     * another one before exiting to match the commit waiting for us back in 
     * PostgresMain(). 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN153"><span class='Ref_To_Local'>use_own_xacts</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="vacuum.c.html#LN152"><span class='Ref_To_Local'>in_outer_xact</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* ActiveSnapshot is not set by autovacuum */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/utils/snapmgr.h.html#LN78"><span class='Ref_to_Proto'>ActiveSnapshotSet</span></a><span class='Parentheses'>())</span> 
            <a href="../../include/utils/snapmgr.h.html#LN76"><span class='Ref_to_Proto'>PopActiveSnapshot</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* matches the StartTransaction in PostgresMain() */ 
</span>        <a href="../../include/access/xact.h.html#LN349"><span class='Ref_to_Proto'>CommitTransactionCommand</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Turn vacuum cost accounting on or off */ 
</span>    <a href="../../include/utils/elog.h.html#LN283"><span class='Ref_to_Macro'>PG_TRY</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>{ 
</span><a name="LN285"></a>        <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>cur</span><span class='Delimiter'>; 
</span> 
        <a href="vacuum.c.html#LN155"><span class='Ref_To_Local'>in_vacuum</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <a href="../utils/init/globals.c.html#LN139"><span class='Ref_to_Global_Var'>VacuumCostActive</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../utils/init/globals.c.html#LN132"><span class='Ref_to_Global_Var'>VacuumCostDelay</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../utils/init/globals.c.html#LN138"><span class='Ref_to_Global_Var'>VacuumCostBalance</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="../utils/init/globals.c.html#LN134"><span class='Ref_to_Global_Var'>VacuumPageHit</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="../utils/init/globals.c.html#LN135"><span class='Ref_to_Global_Var'>VacuumPageMiss</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="../utils/init/globals.c.html#LN136"><span class='Ref_to_Global_Var'>VacuumPageDirty</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Loop to process each selected relation. 
         */ 
</span>        <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN285"><span class='Ref_To_Local'>cur</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN154"><span class='Ref_To_Local'>relations</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN299"></a>            <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>relid</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN107"><span class='Ref_to_Macro'>lfirst_oid</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN285"><span class='Ref_To_Local'>cur</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN148"><span class='Ref_to_Parameter'>options</span></a> <span class='Operator'>& </span><a href="../../include/nodes/parsenodes.h.html#LN3062"><span class='Ref_to_EnumConst'>VACOPT_VACUUM</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="vacuum.c.html#LN74"><span class='Ref_to_Proto'>vacuum_rel</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN299"><span class='Ref_To_Local'>relid</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN148"><span class='Ref_to_Parameter'>relation</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN148"><span class='Ref_to_Parameter'>options</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN148"><span class='Ref_to_Parameter'>params</span></a><span class='Parentheses'>))</span> 
                    <span class='Control'>continue</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN148"><span class='Ref_to_Parameter'>options</span></a> <span class='Operator'>& </span><a href="../../include/nodes/parsenodes.h.html#LN3063"><span class='Ref_to_EnumConst'>VACOPT_ANALYZE</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * If using separate xacts, start one for analyze. Otherwise, 
                 * we can use the outer transaction. 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN153"><span class='Ref_To_Local'>use_own_xacts</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <a href="../../include/access/xact.h.html#LN348"><span class='Ref_to_Proto'>StartTransactionCommand</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>                    <span class='Comment_Multi_Line'>/* functions in indexes may want a snapshot set */ 
</span>                    <a href="../../include/utils/snapmgr.h.html#LN73"><span class='Ref_to_Proto'>PushActiveSnapshot</span></a><span class='Parentheses'>(</span><a href="../../include/utils/snapmgr.h.html#LN63"><span class='Ref_to_Proto'>GetTransactionSnapshot</span></a><span class='Parentheses'>())</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
                <a href="analyze.c.html#LN109"><span class='Ref_to_Func'>analyze_rel</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN299"><span class='Ref_To_Local'>relid</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN148"><span class='Ref_to_Parameter'>relation</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN148"><span class='Ref_to_Parameter'>options</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN148"><span class='Ref_to_Parameter'>params</span></a><span class='Delimiter'>, 
</span>                            <a href="vacuum.c.html#LN149"><span class='Ref_to_Parameter'>va_cols</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN152"><span class='Ref_To_Local'>in_outer_xact</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN65"><span class='Ref_to_Global_Var'>vac_strategy</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN153"><span class='Ref_To_Local'>use_own_xacts</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <a href="../../include/utils/snapmgr.h.html#LN76"><span class='Ref_to_Proto'>PopActiveSnapshot</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>                    <a href="../../include/access/xact.h.html#LN349"><span class='Ref_to_Proto'>CommitTransactionCommand</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if options&VACOPT_ANALYZ... &raquo; </span> 
        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span>    <a href="../../include/utils/elog.h.html#LN292"><span class='Ref_to_Macro'>PG_CATCH</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>{ 
</span>        <a href="vacuum.c.html#LN155"><span class='Ref_To_Local'>in_vacuum</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <a href="../utils/init/globals.c.html#LN139"><span class='Ref_to_Global_Var'>VacuumCostActive</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <a href="../../include/utils/elog.h.html#LN310"><span class='Ref_to_Macro'>PG_RE_THROW</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="../../include/utils/elog.h.html#LN299"><span class='Ref_to_Macro'>PG_END_TRY</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <a href="vacuum.c.html#LN155"><span class='Ref_To_Local'>in_vacuum</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="../utils/init/globals.c.html#LN139"><span class='Ref_to_Global_Var'>VacuumCostActive</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Finish up processing. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN153"><span class='Ref_To_Local'>use_own_xacts</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* here, we are not in a transaction */ 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * This matches the CommitTransaction waiting for us in 
         * PostgresMain(). 
         */ 
</span>        <a href="../../include/access/xact.h.html#LN348"><span class='Ref_to_Proto'>StartTransactionCommand</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="vacuum.c.html#LN148"><span class='Ref_to_Parameter'>options</span></a> <span class='Operator'>& </span><a href="../../include/nodes/parsenodes.h.html#LN3062"><span class='Ref_to_EnumConst'>VACOPT_VACUUM</span></a><span class='Parentheses'>) </span><span class='Operator'>&& !</span><a href="../../include/postmaster/autovacuum.h.html#LN50"><span class='Ref_to_Proto'>IsAutoVacuumWorkerProcess</span></a><span class='Parentheses'>())</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Update pg_database.datfrozenxid, and truncate pg_xact if possible. 
         * (autovacuum.c does this for itself.) 
         */ 
</span>        <a href="../../include/commands/vacuum.h.html#LN187"><span class='Ref_to_Proto'>vac_update_datfrozenxid</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Clean up working storage --- note we must do this after 
     * StartTransactionCommand, else we might be trying to delete the active 
     * context! 
     */ 
</span>    <a href="../../include/utils/memutils.h.html#LN74"><span class='Ref_to_Proto'>MemoryContextDelete</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN64"><span class='Ref_to_Global_Var'>vac_context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="vacuum.c.html#LN64"><span class='Ref_to_Global_Var'>vac_context</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end vacuum &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Build a list of Oids for each relation to be processed 
 * 
 * The list is built in vac_context so that it will survive across our 
 * per-relation transactions. 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN381"></a><span class='Declare_Function'>get_rel_oids</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>relid</span><span class='Delimiter'>, </span><span class='Keyword'>const </span><a href="../../include/nodes/primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>vacrel</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN383"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>oid_list</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN384"></a>    <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldcontext</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* OID supplied by VACUUM's caller? */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN381"><span class='Ref_to_Parameter'>relid</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="vacuum.c.html#LN384"><span class='Ref_To_Local'>oldcontext</span></a> <span class='Operator'>= </span><a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN64"><span class='Ref_to_Global_Var'>vac_context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="vacuum.c.html#LN383"><span class='Ref_To_Local'>oid_list</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN162"><span class='Ref_to_Func'>lappend_oid</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN383"><span class='Ref_To_Local'>oid_list</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN381"><span class='Ref_to_Parameter'>relid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN384"><span class='Ref_To_Local'>oldcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN381"><span class='Ref_to_Parameter'>vacrel</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Process a specific relation */ 
</span><a name="LN396"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>relid</span><span class='Delimiter'>; 
</span><a name="LN397"></a>        <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>tuple</span><span class='Delimiter'>; 
</span><a name="LN398"></a>        <a href="../../include/catalog/pg_class.h.html#LN94"><span class='Ref_to_Typedef'>Form_pg_class</span></a> <span class='Declare_Local'>classForm</span><span class='Delimiter'>; 
</span><a name="LN399"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>include_parts</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Since we don't take a lock here, the relation might be gone, or the 
         * RangeVar might no longer refer to the OID we look up here.  In the 
         * former case, VACUUM will do nothing; in the latter case, it will 
         * process the OID we looked up here, rather than the new one. Neither 
         * is ideal, but there's little practical alternative, since we're 
         * going to commit this transaction and begin a new one between now 
         * and then. 
         */ 
</span>        <a href="vacuum.c.html#LN396"><span class='Ref_To_Local'>relid</span></a> <span class='Operator'>= </span><a href="../../include/catalog/namespace.h.html#LN52"><span class='Ref_to_Macro'>RangeVarGetRelid</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN381"><span class='Ref_to_Parameter'>vacrel</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN33"><span class='Ref_to_Const'>NoLock</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * To check whether the relation is a partitioned table, fetch its 
         * syscache entry. 
         */ 
</span>        <a href="vacuum.c.html#LN397"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>= </span><a href="../../include/utils/syscache.h.html#LN155"><span class='Ref_to_Macro'>SearchSysCache1</span></a><span class='Parentheses'>(</span><a href="../../include/utils/syscache.h.html#LN83"><span class='Ref_to_EnumConst'>RELOID</span></a><span class='Delimiter'>, </span><a href="../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN396"><span class='Ref_To_Local'>relid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN397"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>))</span> 
            <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cache lookup failed for relation %u"</span><span class='Delimiter'>, </span><a href="vacuum.c.html#LN396"><span class='Ref_To_Local'>relid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="vacuum.c.html#LN398"><span class='Ref_To_Local'>classForm</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/catalog/pg_class.h.html#LN94"><span class='Ref_to_Typedef'>Form_pg_class</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN397"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="vacuum.c.html#LN399"><span class='Ref_To_Local'>include_parts</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="vacuum.c.html#LN398"><span class='Ref_To_Local'>classForm</span></a><span class='Operator'>-&GT;</span>relkind <span class='Operator'>== </span><a href="../../include/catalog/pg_class.h.html#LN167"><span class='Ref_to_Const'>RELKIND_PARTITIONED_TABLE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN397"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Make relation list entries for this guy and its partitions, if any. 
         * Note that the list returned by find_all_inheritors() include the 
         * passed-in OID at its head.  Also note that we did not request a 
         * lock to be taken to match what would be done otherwise. 
         */ 
</span>        <a href="vacuum.c.html#LN384"><span class='Ref_To_Local'>oldcontext</span></a> <span class='Operator'>= </span><a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN64"><span class='Ref_to_Global_Var'>vac_context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN399"><span class='Ref_To_Local'>include_parts</span></a><span class='Parentheses'>) 
</span>            <a href="vacuum.c.html#LN383"><span class='Ref_To_Local'>oid_list</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN219"><span class='Ref_to_Proto'>list_concat</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN383"><span class='Ref_To_Local'>oid_list</span></a><span class='Delimiter'>, 
</span>                                   <a href="../../include/catalog/pg_inherits_fn.h.html#LN20"><span class='Ref_to_Proto'>find_all_inheritors</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN396"><span class='Ref_To_Local'>relid</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN33"><span class='Ref_to_Const'>NoLock</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="vacuum.c.html#LN383"><span class='Ref_To_Local'>oid_list</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN162"><span class='Ref_to_Func'>lappend_oid</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN383"><span class='Ref_To_Local'>oid_list</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN396"><span class='Ref_To_Local'>relid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN384"><span class='Ref_To_Local'>oldcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if vacrel &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Process all plain relations and materialized views listed in 
         * pg_class 
         */ 
</span><a name="LN443"></a>        <a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>pgclass</span><span class='Delimiter'>; 
</span><a name="LN444"></a>        <a href="../../include/access/heapam.h.html#LN99"><span class='Ref_to_Typedef'>HeapScanDesc</span></a> <span class='Declare_Local'>scan</span><span class='Delimiter'>; 
</span><a name="LN445"></a>        <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>tuple</span><span class='Delimiter'>; 
</span> 
        <a href="vacuum.c.html#LN443"><span class='Ref_To_Local'>pgclass</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN91"><span class='Ref_to_Proto'>heap_open</span></a><span class='Parentheses'>(</span><a href="../../include/catalog/pg_class.h.html#LN28"><span class='Ref_to_Const'>RelationRelationId</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN35"><span class='Ref_to_Const'>AccessShareLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="vacuum.c.html#LN444"><span class='Ref_To_Local'>scan</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN110"><span class='Ref_to_Proto'>heap_beginscan_catalog</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN443"><span class='Ref_To_Local'>pgclass</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>while</span> <span class='Parentheses'>((</span><a href="vacuum.c.html#LN445"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN127"><span class='Ref_to_Proto'>heap_getnext</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN444"><span class='Ref_To_Local'>scan</span></a><span class='Delimiter'>, </span><a href="../../include/access/sdir.h.html#LN25"><span class='Ref_to_EnumConst'>ForwardScanDirection</span></a><span class='Parentheses'>))</span> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span><a name="LN453"></a>            <a href="../../include/catalog/pg_class.h.html#LN94"><span class='Ref_to_Typedef'>Form_pg_class</span></a> <span class='Declare_Local'>classForm</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/catalog/pg_class.h.html#LN94"><span class='Ref_to_Typedef'>Form_pg_class</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN445"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * We include partitioned tables here; depending on which 
             * operation is to be performed, caller will decide whether to 
             * process or ignore them. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN453"><span class='Ref_To_Local'>classForm</span></a><span class='Operator'>-&GT;</span>relkind <span class='Operator'>!= </span><a href="../../include/catalog/pg_class.h.html#LN159"><span class='Ref_to_Const'>RELKIND_RELATION</span></a> <span class='Operator'>&& 
</span>                <a href="vacuum.c.html#LN453"><span class='Ref_To_Local'>classForm</span></a><span class='Operator'>-&GT;</span>relkind <span class='Operator'>!= </span><a href="../../include/catalog/pg_class.h.html#LN164"><span class='Ref_to_Const'>RELKIND_MATVIEW</span></a> <span class='Operator'>&& 
</span>                <a href="vacuum.c.html#LN453"><span class='Ref_To_Local'>classForm</span></a><span class='Operator'>-&GT;</span>relkind <span class='Operator'>!= </span><a href="../../include/catalog/pg_class.h.html#LN167"><span class='Ref_to_Const'>RELKIND_PARTITIONED_TABLE</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Make a relation list entry for this guy */ 
</span>            <a href="vacuum.c.html#LN384"><span class='Ref_To_Local'>oldcontext</span></a> <span class='Operator'>= </span><a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN64"><span class='Ref_to_Global_Var'>vac_context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="vacuum.c.html#LN383"><span class='Ref_To_Local'>oid_list</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN162"><span class='Ref_to_Func'>lappend_oid</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN383"><span class='Ref_To_Local'>oid_list</span></a><span class='Delimiter'>, </span><a href="../../include/access/htup_details.h.html#LN694"><span class='Ref_to_Macro'>HeapTupleGetOid</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN445"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN384"><span class='Ref_To_Local'>oldcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="../../include/access/heapam.h.html#LN126"><span class='Ref_to_Proto'>heap_endscan</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN444"><span class='Ref_To_Local'>scan</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/access/heapam.h.html#LN96"><span class='Ref_to_Macro'>heap_close</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN443"><span class='Ref_To_Local'>pgclass</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN35"><span class='Ref_to_Const'>AccessShareLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
    <span class='Control'>return</span> <a href="vacuum.c.html#LN383"><span class='Ref_To_Local'>oid_list</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end get_rel_oids &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * vacuum_set_xid_limits() -- compute oldest-Xmin and freeze cutoff points 
 * 
 * The output parameters are: 
 * - oldestXmin is the cutoff value used to distinguish whether tuples are 
 *   DEAD or RECENTLY_DEAD (see HeapTupleSatisfiesVacuum). 
 * - freezeLimit is the Xid below which all Xids are replaced by 
 *   FrozenTransactionId during vacuum. 
 * - xidFullScanLimit (computed from table_freeze_age parameter) 
 *   represents a minimum Xid value; a table whose relfrozenxid is older than 
 *   this will have a full-table vacuum applied to it, to freeze tuples across 
 *   the whole table.  Vacuuming a table younger than this value can use a 
 *   partial scan. 
 * - multiXactCutoff is the value below which all MultiXactIds are removed from 
 *   Xmax. 
 * - mxactFullScanLimit is a value against which a table's relminmxid value is 
 *   compared to produce a full-table vacuum, as with xidFullScanLimit. 
 * 
 * xidFullScanLimit and mxactFullScanLimit can be passed as NULL if caller is 
 * not interested. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN500"></a><span class='Declare_Function'>vacuum_set_xid_limits</span><span class='Parentheses'>(</span><a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>rel</span><span class='Delimiter'>, 
</span><a name="LN501"></a>                      <span class='Keyword'>int </span><span class='Declare_Parameter'>freeze_min_age</span><span class='Delimiter'>, 
</span><a name="LN502"></a>                      <span class='Keyword'>int </span><span class='Declare_Parameter'>freeze_table_age</span><span class='Delimiter'>, 
</span><a name="LN503"></a>                      <span class='Keyword'>int </span><span class='Declare_Parameter'>multixact_freeze_min_age</span><span class='Delimiter'>, 
</span><a name="LN504"></a>                      <span class='Keyword'>int </span><span class='Declare_Parameter'>multixact_freeze_table_age</span><span class='Delimiter'>, 
</span><a name="LN505"></a>                      <a href="../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>oldestXmin</span><span class='Delimiter'>, 
</span><a name="LN506"></a>                      <a href="../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>freezeLimit</span><span class='Delimiter'>, 
</span><a name="LN507"></a>                      <a href="../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>xidFullScanLimit</span><span class='Delimiter'>, 
</span><a name="LN508"></a>                      <a href="../../include/c.h.html#LN406"><span class='Ref_to_Typedef'>MultiXactId</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>multiXactCutoff</span><span class='Delimiter'>, 
</span><a name="LN509"></a>                      <a href="../../include/c.h.html#LN406"><span class='Ref_to_Typedef'>MultiXactId</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>mxactFullScanLimit</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN511"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>freezemin</span><span class='Delimiter'>; 
</span><a name="LN512"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>mxid_freezemin</span><span class='Delimiter'>; 
</span><a name="LN513"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>effective_multixact_freeze_max_age</span><span class='Delimiter'>; 
</span><a name="LN514"></a>    <a href="../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>limit</span><span class='Delimiter'>; 
</span><a name="LN515"></a>    <a href="../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>safeLimit</span><span class='Delimiter'>; 
</span><a name="LN516"></a>    <a href="../../include/c.h.html#LN406"><span class='Ref_to_Typedef'>MultiXactId</span></a> <span class='Declare_Local'>mxactLimit</span><span class='Delimiter'>; 
</span><a name="LN517"></a>    <a href="../../include/c.h.html#LN406"><span class='Ref_to_Typedef'>MultiXactId</span></a> <span class='Declare_Local'>safeMxactLimit</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We can always ignore processes running lazy vacuum.  This is because we 
     * use these values only for deciding which tuples we must keep in the 
     * tables.  Since lazy vacuum doesn't write its XID anywhere, it's safe to 
     * ignore it.  In theory it could be problematic to ignore lazy vacuums in 
     * a full vacuum, but keep in mind that only one vacuum process can be 
     * working on a particular table at any time, and that each vacuum is 
     * always an independent transaction. 
     */ 
</span>    <span class='Operator'>*</span><a href="vacuum.c.html#LN505"><span class='Ref_to_Parameter'>oldestXmin</span></a> <span class='Operator'>= 
</span>        <a href="../../include/utils/snapmgr.h.html#LN93"><span class='Ref_to_Proto'>TransactionIdLimitedForOldSnapshots</span></a><span class='Parentheses'>(</span><a href="../../include/storage/procarray.h.html#LN91"><span class='Ref_to_Proto'>GetOldestXmin</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN500"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="../../include/storage/procarray.h.html#LN52"><span class='Ref_to_Const'>PROCARRAY_FLAGS_VACUUM</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="vacuum.c.html#LN500"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="vacuum.c.html#LN505"><span class='Ref_to_Parameter'>oldestXmin</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Determine the minimum freeze age to use: as specified by the caller, or 
     * vacuum_freeze_min_age, but in any case not more than half 
     * autovacuum_freeze_max_age, so that autovacuums to prevent XID 
     * wraparound won't occur too frequently. 
     */ 
</span>    <a href="vacuum.c.html#LN511"><span class='Ref_To_Local'>freezemin</span></a> <span class='Operator'>= </span><a href="vacuum.c.html#LN501"><span class='Ref_to_Parameter'>freeze_min_age</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN511"><span class='Ref_To_Local'>freezemin</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="vacuum.c.html#LN511"><span class='Ref_To_Local'>freezemin</span></a> <span class='Operator'>= </span><a href="vacuum.c.html#LN57"><span class='Ref_to_Global_Var'>vacuum_freeze_min_age</span></a><span class='Delimiter'>; 
</span>    <a href="vacuum.c.html#LN511"><span class='Ref_To_Local'>freezemin</span></a> <span class='Operator'>= </span><a href="../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN11"><span class='Ref_to_Macro'>Min</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN511"><span class='Ref_To_Local'>freezemin</span></a><span class='Delimiter'>, </span><a href="../postmaster/autovacuum.c.html#LN119"><span class='Ref_to_Global_Var'>autovacuum_freeze_max_age</span></a> <span class='Operator'>/ </span><span class='Number'>2</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="vacuum.c.html#LN511"><span class='Ref_To_Local'>freezemin</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Compute the cutoff XID, being careful not to generate a "permanent" XID 
     */ 
</span>    <a href="vacuum.c.html#LN514"><span class='Ref_To_Local'>limit</span></a> <span class='Operator'>= *</span><a href="vacuum.c.html#LN505"><span class='Ref_to_Parameter'>oldestXmin</span></a> <span class='Operator'>- </span><a href="vacuum.c.html#LN511"><span class='Ref_To_Local'>freezemin</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN514"><span class='Ref_To_Local'>limit</span></a><span class='Parentheses'>))</span> 
        <a href="vacuum.c.html#LN514"><span class='Ref_To_Local'>limit</span></a> <span class='Operator'>= </span><a href="../../include/access/transam.h.html#LN33"><span class='Ref_to_Const'>FirstNormalTransactionId</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If oldestXmin is very far back (in practice, more than 
     * autovacuum_freeze_max_age / 2 XIDs old), complain and force a minimum 
     * freeze age of zero. 
     */ 
</span>    <a href="vacuum.c.html#LN515"><span class='Ref_To_Local'>safeLimit</span></a> <span class='Operator'>= </span><a href="../../include/access/transam.h.html#LN178"><span class='Ref_to_Proto'>ReadNewTransactionId</span></a><span class='Parentheses'>() </span><span class='Operator'>- </span><a href="../postmaster/autovacuum.c.html#LN119"><span class='Ref_to_Global_Var'>autovacuum_freeze_max_age</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN515"><span class='Ref_To_Local'>safeLimit</span></a><span class='Parentheses'>))</span> 
        <a href="vacuum.c.html#LN515"><span class='Ref_To_Local'>safeLimit</span></a> <span class='Operator'>= </span><a href="../../include/access/transam.h.html#LN33"><span class='Ref_to_Const'>FirstNormalTransactionId</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN514"><span class='Ref_To_Local'>limit</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN515"><span class='Ref_To_Local'>safeLimit</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN39"><span class='Ref_to_Const'>WARNING</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"oldest xmin is far in the past"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"Close open transactions soon to avoid wraparound problems."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <a href="vacuum.c.html#LN514"><span class='Ref_To_Local'>limit</span></a> <span class='Operator'>= *</span><a href="vacuum.c.html#LN505"><span class='Ref_to_Parameter'>oldestXmin</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Operator'>*</span><a href="vacuum.c.html#LN506"><span class='Ref_to_Parameter'>freezeLimit</span></a> <span class='Operator'>= </span><a href="vacuum.c.html#LN514"><span class='Ref_To_Local'>limit</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Compute the multixact age for which freezing is urgent.  This is 
     * normally autovacuum_multixact_freeze_max_age, but may be less if we are 
     * short of multixact member space. 
     */ 
</span>    <a href="vacuum.c.html#LN513"><span class='Ref_To_Local'>effective_multixact_freeze_max_age</span></a> <span class='Operator'>= </span><a href="../../include/access/multixact.h.html#LN144"><span class='Ref_to_Proto'>MultiXactMemberFreezeThreshold</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Determine the minimum multixact freeze age to use: as specified by 
     * caller, or vacuum_multixact_freeze_min_age, but in any case not more 
     * than half effective_multixact_freeze_max_age, so that autovacuums to 
     * prevent MultiXact wraparound won't occur too frequently. 
     */ 
</span>    <a href="vacuum.c.html#LN512"><span class='Ref_To_Local'>mxid_freezemin</span></a> <span class='Operator'>= </span><a href="vacuum.c.html#LN503"><span class='Ref_to_Parameter'>multixact_freeze_min_age</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN512"><span class='Ref_To_Local'>mxid_freezemin</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="vacuum.c.html#LN512"><span class='Ref_To_Local'>mxid_freezemin</span></a> <span class='Operator'>= </span><a href="vacuum.c.html#LN59"><span class='Ref_to_Global_Var'>vacuum_multixact_freeze_min_age</span></a><span class='Delimiter'>; 
</span>    <a href="vacuum.c.html#LN512"><span class='Ref_To_Local'>mxid_freezemin</span></a> <span class='Operator'>= </span><a href="../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN11"><span class='Ref_to_Macro'>Min</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN512"><span class='Ref_To_Local'>mxid_freezemin</span></a><span class='Delimiter'>, 
</span>                         <a href="vacuum.c.html#LN513"><span class='Ref_To_Local'>effective_multixact_freeze_max_age</span></a> <span class='Operator'>/ </span><span class='Number'>2</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="vacuum.c.html#LN512"><span class='Ref_To_Local'>mxid_freezemin</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* compute the cutoff multi, being careful to generate a valid value */ 
</span>    <a href="vacuum.c.html#LN516"><span class='Ref_To_Local'>mxactLimit</span></a> <span class='Operator'>= </span><a href="../../include/access/multixact.h.html#LN137"><span class='Ref_to_Proto'>GetOldestMultiXactId</span></a><span class='Parentheses'>() </span><span class='Operator'>- </span><a href="vacuum.c.html#LN512"><span class='Ref_To_Local'>mxid_freezemin</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN516"><span class='Ref_To_Local'>mxactLimit</span></a> <span class='Operator'>&LT; </span><a href="../../include/access/multixact.h.html#LN23"><span class='Ref_to_Const'>FirstMultiXactId</span></a><span class='Parentheses'>) 
</span>        <a href="vacuum.c.html#LN516"><span class='Ref_To_Local'>mxactLimit</span></a> <span class='Operator'>= </span><a href="../../include/access/multixact.h.html#LN23"><span class='Ref_to_Const'>FirstMultiXactId</span></a><span class='Delimiter'>; 
</span> 
    <a href="vacuum.c.html#LN517"><span class='Ref_To_Local'>safeMxactLimit</span></a> <span class='Operator'>= 
</span>        <a href="../../include/access/multixact.h.html#LN109"><span class='Ref_to_Proto'>ReadNextMultiXactId</span></a><span class='Parentheses'>() </span><span class='Operator'>- </span><a href="vacuum.c.html#LN513"><span class='Ref_To_Local'>effective_multixact_freeze_max_age</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN517"><span class='Ref_To_Local'>safeMxactLimit</span></a> <span class='Operator'>&LT; </span><a href="../../include/access/multixact.h.html#LN23"><span class='Ref_to_Const'>FirstMultiXactId</span></a><span class='Parentheses'>) 
</span>        <a href="vacuum.c.html#LN517"><span class='Ref_To_Local'>safeMxactLimit</span></a> <span class='Operator'>= </span><a href="../../include/access/multixact.h.html#LN23"><span class='Ref_to_Const'>FirstMultiXactId</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/access/multixact.h.html#LN114"><span class='Ref_to_Proto'>MultiXactIdPrecedes</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN516"><span class='Ref_To_Local'>mxactLimit</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN517"><span class='Ref_To_Local'>safeMxactLimit</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN39"><span class='Ref_to_Const'>WARNING</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"oldest multixact is far in the past"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN985"><span class='Ref_to_Func'>errhint</span></a><span class='Parentheses'>(</span><span class='String'>"Close open transactions with multixacts soon to avoid wraparound problems."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <a href="vacuum.c.html#LN516"><span class='Ref_To_Local'>mxactLimit</span></a> <span class='Operator'>= </span><a href="vacuum.c.html#LN517"><span class='Ref_To_Local'>safeMxactLimit</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Operator'>*</span><a href="vacuum.c.html#LN508"><span class='Ref_to_Parameter'>multiXactCutoff</span></a> <span class='Operator'>= </span><a href="vacuum.c.html#LN516"><span class='Ref_To_Local'>mxactLimit</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN507"><span class='Ref_to_Parameter'>xidFullScanLimit</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN613"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>freezetable</span><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="vacuum.c.html#LN509"><span class='Ref_to_Parameter'>mxactFullScanLimit</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Determine the table freeze age to use: as specified by the caller, 
         * or vacuum_freeze_table_age, but in any case not more than 
         * autovacuum_freeze_max_age * 0.95, so that if you have e.g nightly 
         * VACUUM schedule, the nightly VACUUM gets a chance to freeze tuples 
         * before anti-wraparound autovacuum is launched. 
         */ 
</span>        <a href="vacuum.c.html#LN613"><span class='Ref_To_Local'>freezetable</span></a> <span class='Operator'>= </span><a href="vacuum.c.html#LN502"><span class='Ref_to_Parameter'>freeze_table_age</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN613"><span class='Ref_To_Local'>freezetable</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <a href="vacuum.c.html#LN613"><span class='Ref_To_Local'>freezetable</span></a> <span class='Operator'>= </span><a href="vacuum.c.html#LN58"><span class='Ref_to_Global_Var'>vacuum_freeze_table_age</span></a><span class='Delimiter'>; 
</span>        <a href="vacuum.c.html#LN613"><span class='Ref_To_Local'>freezetable</span></a> <span class='Operator'>= </span><a href="../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN11"><span class='Ref_to_Macro'>Min</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN613"><span class='Ref_To_Local'>freezetable</span></a><span class='Delimiter'>, </span><a href="../postmaster/autovacuum.c.html#LN119"><span class='Ref_to_Global_Var'>autovacuum_freeze_max_age</span></a> <span class='Operator'>* </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>95</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="vacuum.c.html#LN613"><span class='Ref_To_Local'>freezetable</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Compute XID limit causing a full-table vacuum, being careful not to 
         * generate a "permanent" XID. 
         */ 
</span>        <a href="vacuum.c.html#LN514"><span class='Ref_To_Local'>limit</span></a> <span class='Operator'>= </span><a href="../../include/access/transam.h.html#LN178"><span class='Ref_to_Proto'>ReadNewTransactionId</span></a><span class='Parentheses'>() </span><span class='Operator'>- </span><a href="vacuum.c.html#LN613"><span class='Ref_To_Local'>freezetable</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN514"><span class='Ref_To_Local'>limit</span></a><span class='Parentheses'>))</span> 
            <a href="vacuum.c.html#LN514"><span class='Ref_To_Local'>limit</span></a> <span class='Operator'>= </span><a href="../../include/access/transam.h.html#LN33"><span class='Ref_to_Const'>FirstNormalTransactionId</span></a><span class='Delimiter'>; 
</span> 
        <span class='Operator'>*</span><a href="vacuum.c.html#LN507"><span class='Ref_to_Parameter'>xidFullScanLimit</span></a> <span class='Operator'>= </span><a href="vacuum.c.html#LN514"><span class='Ref_To_Local'>limit</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Similar to the above, determine the table freeze age to use for 
         * multixacts: as specified by the caller, or 
         * vacuum_multixact_freeze_table_age, but in any case not more than 
         * autovacuum_multixact_freeze_table_age * 0.95, so that if you have 
         * e.g. nightly VACUUM schedule, the nightly VACUUM gets a chance to 
         * freeze multixacts before anti-wraparound autovacuum is launched. 
         */ 
</span>        <a href="vacuum.c.html#LN613"><span class='Ref_To_Local'>freezetable</span></a> <span class='Operator'>= </span><a href="vacuum.c.html#LN504"><span class='Ref_to_Parameter'>multixact_freeze_table_age</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN613"><span class='Ref_To_Local'>freezetable</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <a href="vacuum.c.html#LN613"><span class='Ref_To_Local'>freezetable</span></a> <span class='Operator'>= </span><a href="vacuum.c.html#LN60"><span class='Ref_to_Global_Var'>vacuum_multixact_freeze_table_age</span></a><span class='Delimiter'>; 
</span>        <a href="vacuum.c.html#LN613"><span class='Ref_To_Local'>freezetable</span></a> <span class='Operator'>= </span><a href="../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN11"><span class='Ref_to_Macro'>Min</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN613"><span class='Ref_To_Local'>freezetable</span></a><span class='Delimiter'>, 
</span>                          <a href="vacuum.c.html#LN513"><span class='Ref_To_Local'>effective_multixact_freeze_max_age</span></a> <span class='Operator'>* </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>95</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="vacuum.c.html#LN613"><span class='Ref_To_Local'>freezetable</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Compute MultiXact limit causing a full-table vacuum, being careful 
         * to generate a valid MultiXact value. 
         */ 
</span>        <a href="vacuum.c.html#LN516"><span class='Ref_To_Local'>mxactLimit</span></a> <span class='Operator'>= </span><a href="../../include/access/multixact.h.html#LN109"><span class='Ref_to_Proto'>ReadNextMultiXactId</span></a><span class='Parentheses'>() </span><span class='Operator'>- </span><a href="vacuum.c.html#LN613"><span class='Ref_To_Local'>freezetable</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN516"><span class='Ref_To_Local'>mxactLimit</span></a> <span class='Operator'>&LT; </span><a href="../../include/access/multixact.h.html#LN23"><span class='Ref_to_Const'>FirstMultiXactId</span></a><span class='Parentheses'>) 
</span>            <a href="vacuum.c.html#LN516"><span class='Ref_To_Local'>mxactLimit</span></a> <span class='Operator'>= </span><a href="../../include/access/multixact.h.html#LN23"><span class='Ref_to_Const'>FirstMultiXactId</span></a><span class='Delimiter'>; 
</span> 
        <span class='Operator'>*</span><a href="vacuum.c.html#LN509"><span class='Ref_to_Parameter'>mxactFullScanLimit</span></a> <span class='Operator'>= </span><a href="vacuum.c.html#LN516"><span class='Ref_To_Local'>mxactLimit</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if xidFullScanLimit!=NUL... &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="vacuum.c.html#LN509"><span class='Ref_to_Parameter'>mxactFullScanLimit</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end vacuum_set_xid_limits &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * vac_estimate_reltuples() -- estimate the new value for pg_class.reltuples 
 * 
 *      If we scanned the whole relation then we should just use the count of 
 *      live tuples seen; but if we did not, we should not trust the count 
 *      unreservedly, especially not in VACUUM, which may have scanned a quite 
 *      nonrandom subset of the table.  When we have only partial information, 
 *      we take the old value of pg_class.reltuples as a measurement of the 
 *      tuple density in the unscanned pages. 
 * 
 *      This routine is shared by VACUUM and ANALYZE. 
 */ 
</span><span class='Keyword'>double 
</span><a name="LN684"></a><span class='Declare_Function'>vac_estimate_reltuples</span><span class='Parentheses'>(</span><a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>relation</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>is_analyze</span><span class='Delimiter'>, 
</span><a name="LN685"></a>                       <a href="../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Parameter'>total_pages</span><span class='Delimiter'>, 
</span><a name="LN686"></a>                       <a href="../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Parameter'>scanned_pages</span><span class='Delimiter'>, 
</span><a name="LN687"></a>                       <span class='Keyword'>double </span><span class='Declare_Parameter'>scanned_tuples</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN689"></a>    <a href="../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Local'>old_rel_pages</span> <span class='Operator'>= </span><a href="vacuum.c.html#LN684"><span class='Ref_to_Parameter'>relation</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relpages<span class='Delimiter'>; 
</span><a name="LN690"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>old_rel_tuples</span> <span class='Operator'>= </span><a href="vacuum.c.html#LN684"><span class='Ref_to_Parameter'>relation</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>reltuples<span class='Delimiter'>; 
</span><a name="LN691"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>old_density</span><span class='Delimiter'>; 
</span><a name="LN692"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>new_density</span><span class='Delimiter'>; 
</span><a name="LN693"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>multiplier</span><span class='Delimiter'>; 
</span><a name="LN694"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>updated_density</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* If we did scan the whole table, just use the count as-is */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN686"><span class='Ref_to_Parameter'>scanned_pages</span></a> <span class='Operator'>&GT;= </span><a href="vacuum.c.html#LN685"><span class='Ref_to_Parameter'>total_pages</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="vacuum.c.html#LN687"><span class='Ref_to_Parameter'>scanned_tuples</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If scanned_pages is zero but total_pages isn't, keep the existing value 
     * of reltuples.  (Note: callers should avoid updating the pg_class 
     * statistics in this situation, since no new information has been 
     * provided.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN686"><span class='Ref_to_Parameter'>scanned_pages</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="vacuum.c.html#LN690"><span class='Ref_To_Local'>old_rel_tuples</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If old value of relpages is zero, old density is indeterminate; we 
     * can't do much except scale up scanned_tuples to match total_pages. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN689"><span class='Ref_To_Local'>old_rel_pages</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> floor<span class='Parentheses'>((</span><a href="vacuum.c.html#LN687"><span class='Ref_to_Parameter'>scanned_tuples</span></a> <span class='Operator'>/ </span><a href="vacuum.c.html#LN686"><span class='Ref_to_Parameter'>scanned_pages</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="vacuum.c.html#LN685"><span class='Ref_to_Parameter'>total_pages</span></a> <span class='Operator'>+ </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>5</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Okay, we've covered the corner cases.  The normal calculation is to 
     * convert the old measurement to a density (tuples per page), then update 
     * the density using an exponential-moving-average approach, and finally 
     * compute reltuples as updated_density * total_pages. 
     * 
     * For ANALYZE, the moving average multiplier is just the fraction of the 
     * table's pages we scanned.  This is equivalent to assuming that the 
     * tuple density in the unscanned pages didn't change.  Of course, it 
     * probably did, if the new density measurement is different. But over 
     * repeated cycles, the value of reltuples will converge towards the 
     * correct value, if repeated measurements show the same new density. 
     * 
     * For VACUUM, the situation is a bit different: we have looked at a 
     * nonrandom sample of pages, but we know for certain that the pages we 
     * didn't look at are precisely the ones that haven't changed lately. 
     * Thus, there is a reasonable argument for doing exactly the same thing 
     * as for the ANALYZE case, that is use the old density measurement as the 
     * value for the unscanned pages. 
     * 
     * This logic could probably use further refinement. 
     */ 
</span>    <a href="vacuum.c.html#LN691"><span class='Ref_To_Local'>old_density</span></a> <span class='Operator'>= </span><a href="vacuum.c.html#LN690"><span class='Ref_To_Local'>old_rel_tuples</span></a> <span class='Operator'>/ </span><a href="vacuum.c.html#LN689"><span class='Ref_To_Local'>old_rel_pages</span></a><span class='Delimiter'>; 
</span>    <a href="vacuum.c.html#LN692"><span class='Ref_To_Local'>new_density</span></a> <span class='Operator'>= </span><a href="vacuum.c.html#LN687"><span class='Ref_to_Parameter'>scanned_tuples</span></a> <span class='Operator'>/ </span><a href="vacuum.c.html#LN686"><span class='Ref_to_Parameter'>scanned_pages</span></a><span class='Delimiter'>; 
</span>    <a href="vacuum.c.html#LN693"><span class='Ref_To_Local'>multiplier</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="vacuum.c.html#LN686"><span class='Ref_to_Parameter'>scanned_pages</span></a> <span class='Operator'>/ </span><span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="vacuum.c.html#LN685"><span class='Ref_to_Parameter'>total_pages</span></a><span class='Delimiter'>; 
</span>    <a href="vacuum.c.html#LN694"><span class='Ref_To_Local'>updated_density</span></a> <span class='Operator'>= </span><a href="vacuum.c.html#LN691"><span class='Ref_To_Local'>old_density</span></a> <span class='Operator'>+ </span><span class='Parentheses'>(</span><a href="vacuum.c.html#LN692"><span class='Ref_To_Local'>new_density</span></a> <span class='Operator'>- </span><a href="vacuum.c.html#LN691"><span class='Ref_To_Local'>old_density</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="vacuum.c.html#LN693"><span class='Ref_To_Local'>multiplier</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> floor<span class='Parentheses'>(</span><a href="vacuum.c.html#LN694"><span class='Ref_To_Local'>updated_density</span></a> <span class='Operator'>* </span><a href="vacuum.c.html#LN685"><span class='Ref_to_Parameter'>total_pages</span></a> <span class='Operator'>+ </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>5</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end vac_estimate_reltuples &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 *  vac_update_relstats() -- update statistics for one relation 
 * 
 *      Update the whole-relation statistics that are kept in its pg_class 
 *      row.  There are additional stats that will be updated if we are 
 *      doing ANALYZE, but we always update these stats.  This routine works 
 *      for both index and heap relation entries in pg_class. 
 * 
 *      We violate transaction semantics here by overwriting the rel's 
 *      existing pg_class tuple with the new values.  This is reasonably 
 *      safe as long as we're sure that the new values are correct whether or 
 *      not this transaction commits.  The reason for doing this is that if 
 *      we updated these tuples in the usual way, vacuuming pg_class itself 
 *      wouldn't work very well --- by the time we got done with a vacuum 
 *      cycle, most of the tuples in pg_class would've been obsoleted.  Of 
 *      course, this only works for fixed-size not-null columns, but these are. 
 * 
 *      Another reason for doing it this way is that when we are in a lazy 
 *      VACUUM and have PROC_IN_VACUUM set, we mustn't do any regular updates. 
 *      Somebody vacuuming pg_class might think they could delete a tuple 
 *      marked with xmin = our xid. 
 * 
 *      In addition to fundamentally nontransactional statistics such as 
 *      relpages and relallvisible, we try to maintain certain lazily-updated 
 *      DDL flags such as relhasindex, by clearing them if no longer correct. 
 *      It's safe to do this in VACUUM, which can't run in parallel with 
 *      CREATE INDEX/RULE/TRIGGER and can't be part of a transaction block. 
 *      However, it's *not* safe to do it in an ANALYZE that's within an 
 *      outer transaction, because for example the current transaction might 
 *      have dropped the last index; then we'd think relhasindex should be 
 *      cleared, but if the transaction later rolls back this would be wrong. 
 *      So we refrain from updating the DDL flags if we're inside an outer 
 *      transaction.  This is OK since postponing the flag maintenance is 
 *      always allowable. 
 * 
 *      This routine is shared by VACUUM and ANALYZE. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN784"></a><span class='Declare_Function'>vac_update_relstats</span><span class='Parentheses'>(</span><a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>relation</span><span class='Delimiter'>, 
</span><a name="LN785"></a>                    <a href="../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Parameter'>num_pages</span><span class='Delimiter'>, </span><span class='Keyword'>double </span><span class='Declare_Parameter'>num_tuples</span><span class='Delimiter'>, 
</span><a name="LN786"></a>                    <a href="../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Parameter'>num_all_visible_pages</span><span class='Delimiter'>, 
</span><a name="LN787"></a>                    <span class='Keyword'>bool </span><span class='Declare_Parameter'>hasindex</span><span class='Delimiter'>, </span><a href="../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>frozenxid</span><span class='Delimiter'>, 
</span><a name="LN788"></a>                    <a href="../../include/c.h.html#LN406"><span class='Ref_to_Typedef'>MultiXactId</span></a> <span class='Declare_Parameter'>minmulti</span><span class='Delimiter'>, 
</span><a name="LN789"></a>                    <span class='Keyword'>bool </span><span class='Declare_Parameter'>in_outer_xact</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN791"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>relid</span> <span class='Operator'>= </span><a href="../../include/utils/rel.h.html#LN416"><span class='Ref_to_Macro'>RelationGetRelid</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN784"><span class='Ref_to_Parameter'>relation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN792"></a>    <a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>rd</span><span class='Delimiter'>; 
</span><a name="LN793"></a>    <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>ctup</span><span class='Delimiter'>; 
</span><a name="LN794"></a>    <a href="../../include/catalog/pg_class.h.html#LN94"><span class='Ref_to_Typedef'>Form_pg_class</span></a> <span class='Declare_Local'>pgcform</span><span class='Delimiter'>; 
</span><a name="LN795"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>dirty</span><span class='Delimiter'>; 
</span> 
    <a href="vacuum.c.html#LN792"><span class='Ref_To_Local'>rd</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN91"><span class='Ref_to_Proto'>heap_open</span></a><span class='Parentheses'>(</span><a href="../../include/catalog/pg_class.h.html#LN28"><span class='Ref_to_Const'>RelationRelationId</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN37"><span class='Ref_to_Const'>RowExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Fetch a copy of the tuple to scribble on */ 
</span>    <a href="vacuum.c.html#LN793"><span class='Ref_To_Local'>ctup</span></a> <span class='Operator'>= </span><a href="../../include/utils/syscache.h.html#LN164"><span class='Ref_to_Macro'>SearchSysCacheCopy1</span></a><span class='Parentheses'>(</span><a href="../../include/utils/syscache.h.html#LN83"><span class='Ref_to_EnumConst'>RELOID</span></a><span class='Delimiter'>, </span><a href="../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN791"><span class='Ref_To_Local'>relid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN793"><span class='Ref_To_Local'>ctup</span></a><span class='Parentheses'>))</span> 
        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"pg_class entry for relid %u vanished during vacuuming"</span><span class='Delimiter'>, 
</span>             <a href="vacuum.c.html#LN791"><span class='Ref_To_Local'>relid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="vacuum.c.html#LN794"><span class='Ref_To_Local'>pgcform</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/catalog/pg_class.h.html#LN94"><span class='Ref_to_Typedef'>Form_pg_class</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN793"><span class='Ref_To_Local'>ctup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Apply statistical updates, if any, to copied tuple */ 
</span> 
    <a href="vacuum.c.html#LN795"><span class='Ref_To_Local'>dirty</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN794"><span class='Ref_To_Local'>pgcform</span></a><span class='Operator'>-&GT;</span>relpages <span class='Operator'>!= </span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a><span class='Parentheses'>) </span><a href="vacuum.c.html#LN785"><span class='Ref_to_Parameter'>num_pages</span></a><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <a href="vacuum.c.html#LN794"><span class='Ref_To_Local'>pgcform</span></a><span class='Operator'>-&GT;</span>relpages <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a><span class='Parentheses'>) </span><a href="vacuum.c.html#LN785"><span class='Ref_to_Parameter'>num_pages</span></a><span class='Delimiter'>; 
</span>        <a href="vacuum.c.html#LN795"><span class='Ref_To_Local'>dirty</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN794"><span class='Ref_To_Local'>pgcform</span></a><span class='Operator'>-&GT;</span>reltuples <span class='Operator'>!= </span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN379"><span class='Ref_to_Typedef'>float4</span></a><span class='Parentheses'>) </span><a href="vacuum.c.html#LN785"><span class='Ref_to_Parameter'>num_tuples</span></a><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <a href="vacuum.c.html#LN794"><span class='Ref_To_Local'>pgcform</span></a><span class='Operator'>-&GT;</span>reltuples <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN379"><span class='Ref_to_Typedef'>float4</span></a><span class='Parentheses'>) </span><a href="vacuum.c.html#LN785"><span class='Ref_to_Parameter'>num_tuples</span></a><span class='Delimiter'>; 
</span>        <a href="vacuum.c.html#LN795"><span class='Ref_To_Local'>dirty</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN794"><span class='Ref_To_Local'>pgcform</span></a><span class='Operator'>-&GT;</span>relallvisible <span class='Operator'>!= </span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a><span class='Parentheses'>) </span><a href="vacuum.c.html#LN786"><span class='Ref_to_Parameter'>num_all_visible_pages</span></a><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <a href="vacuum.c.html#LN794"><span class='Ref_To_Local'>pgcform</span></a><span class='Operator'>-&GT;</span>relallvisible <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a><span class='Parentheses'>) </span><a href="vacuum.c.html#LN786"><span class='Ref_to_Parameter'>num_all_visible_pages</span></a><span class='Delimiter'>; 
</span>        <a href="vacuum.c.html#LN795"><span class='Ref_To_Local'>dirty</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Apply DDL updates, but not inside an outer transaction (see above) */ 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="vacuum.c.html#LN789"><span class='Ref_to_Parameter'>in_outer_xact</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * If we didn't find any indexes, reset relhasindex. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN794"><span class='Ref_To_Local'>pgcform</span></a><span class='Operator'>-&GT;</span>relhasindex <span class='Operator'>&& !</span><a href="vacuum.c.html#LN787"><span class='Ref_to_Parameter'>hasindex</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="vacuum.c.html#LN794"><span class='Ref_To_Local'>pgcform</span></a><span class='Operator'>-&GT;</span>relhasindex <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="vacuum.c.html#LN795"><span class='Ref_To_Local'>dirty</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If we have discovered that there are no indexes, then there's no 
         * primary key either.  This could be done more thoroughly... 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN794"><span class='Ref_To_Local'>pgcform</span></a><span class='Operator'>-&GT;</span>relhaspkey <span class='Operator'>&& !</span><a href="vacuum.c.html#LN787"><span class='Ref_to_Parameter'>hasindex</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="vacuum.c.html#LN794"><span class='Ref_To_Local'>pgcform</span></a><span class='Operator'>-&GT;</span>relhaspkey <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="vacuum.c.html#LN795"><span class='Ref_To_Local'>dirty</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* We also clear relhasrules and relhastriggers if needed */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN794"><span class='Ref_To_Local'>pgcform</span></a><span class='Operator'>-&GT;</span>relhasrules <span class='Operator'>&& </span><a href="vacuum.c.html#LN784"><span class='Ref_to_Parameter'>relation</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN117"><span class='Ref_to_Member'>rd_rules</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="vacuum.c.html#LN794"><span class='Ref_To_Local'>pgcform</span></a><span class='Operator'>-&GT;</span>relhasrules <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="vacuum.c.html#LN795"><span class='Ref_To_Local'>dirty</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN794"><span class='Ref_To_Local'>pgcform</span></a><span class='Operator'>-&GT;</span>relhastriggers <span class='Operator'>&& </span><a href="vacuum.c.html#LN784"><span class='Ref_to_Parameter'>relation</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN119"><span class='Ref_to_Member'>trigdesc</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="vacuum.c.html#LN794"><span class='Ref_To_Local'>pgcform</span></a><span class='Operator'>-&GT;</span>relhastriggers <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="vacuum.c.html#LN795"><span class='Ref_To_Local'>dirty</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !in_outer_xact &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Update relfrozenxid, unless caller passed InvalidTransactionId 
     * indicating it has no new data. 
     * 
     * Ordinarily, we don't let relfrozenxid go backwards: if things are 
     * working correctly, the only way the new frozenxid could be older would 
     * be if a previous VACUUM was done with a tighter freeze_min_age, in 
     * which case we don't want to forget the work it already did.  However, 
     * if the stored relfrozenxid is "in the future", then it must be corrupt 
     * and it seems best to overwrite it with the cutoff we used this time. 
     * This should match vac_update_datfrozenxid() concerning what we consider 
     * to be "in the future". 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN787"><span class='Ref_to_Parameter'>frozenxid</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>        <a href="vacuum.c.html#LN794"><span class='Ref_To_Local'>pgcform</span></a><span class='Operator'>-&GT;</span>relfrozenxid <span class='Operator'>!= </span><a href="vacuum.c.html#LN787"><span class='Ref_to_Parameter'>frozenxid</span></a> <span class='Operator'>&& 
</span>        <span class='Parentheses'>(</span><a href="../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN794"><span class='Ref_To_Local'>pgcform</span></a><span class='Operator'>-&GT;</span>relfrozenxid<span class='Delimiter'>, </span><a href="vacuum.c.html#LN787"><span class='Ref_to_Parameter'>frozenxid</span></a><span class='Parentheses'>)</span> <span class='Operator'>|| 
</span>         <a href="../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="../../include/access/transam.h.html#LN178"><span class='Ref_to_Proto'>ReadNewTransactionId</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                               <a href="vacuum.c.html#LN794"><span class='Ref_To_Local'>pgcform</span></a><span class='Operator'>-&GT;</span>relfrozenxid<span class='Parentheses'>)))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="vacuum.c.html#LN794"><span class='Ref_To_Local'>pgcform</span></a><span class='Operator'>-&GT;</span>relfrozenxid <span class='Operator'>= </span><a href="vacuum.c.html#LN787"><span class='Ref_to_Parameter'>frozenxid</span></a><span class='Delimiter'>; 
</span>        <a href="vacuum.c.html#LN795"><span class='Ref_To_Local'>dirty</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Similarly for relminmxid */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/access/multixact.h.html#LN26"><span class='Ref_to_Macro'>MultiXactIdIsValid</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN788"><span class='Ref_to_Parameter'>minmulti</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>        <a href="vacuum.c.html#LN794"><span class='Ref_To_Local'>pgcform</span></a><span class='Operator'>-&GT;</span>relminmxid <span class='Operator'>!= </span><a href="vacuum.c.html#LN788"><span class='Ref_to_Parameter'>minmulti</span></a> <span class='Operator'>&& 
</span>        <span class='Parentheses'>(</span><a href="../../include/access/multixact.h.html#LN114"><span class='Ref_to_Proto'>MultiXactIdPrecedes</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN794"><span class='Ref_To_Local'>pgcform</span></a><span class='Operator'>-&GT;</span>relminmxid<span class='Delimiter'>, </span><a href="vacuum.c.html#LN788"><span class='Ref_to_Parameter'>minmulti</span></a><span class='Parentheses'>)</span> <span class='Operator'>|| 
</span>         <a href="../../include/access/multixact.h.html#LN114"><span class='Ref_to_Proto'>MultiXactIdPrecedes</span></a><span class='Parentheses'>(</span><a href="../../include/access/multixact.h.html#LN109"><span class='Ref_to_Proto'>ReadNextMultiXactId</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, </span><a href="vacuum.c.html#LN794"><span class='Ref_To_Local'>pgcform</span></a><span class='Operator'>-&GT;</span>relminmxid<span class='Parentheses'>)))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="vacuum.c.html#LN794"><span class='Ref_To_Local'>pgcform</span></a><span class='Operator'>-&GT;</span>relminmxid <span class='Operator'>= </span><a href="vacuum.c.html#LN788"><span class='Ref_to_Parameter'>minmulti</span></a><span class='Delimiter'>; 
</span>        <a href="vacuum.c.html#LN795"><span class='Ref_To_Local'>dirty</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* If anything changed, write out the tuple. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN795"><span class='Ref_To_Local'>dirty</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/access/heapam.h.html#LN168"><span class='Ref_to_Proto'>heap_inplace_update</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN792"><span class='Ref_To_Local'>rd</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN793"><span class='Ref_To_Local'>ctup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/access/heapam.h.html#LN96"><span class='Ref_to_Macro'>heap_close</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN792"><span class='Ref_To_Local'>rd</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN37"><span class='Ref_to_Const'>RowExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end vac_update_relstats &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 *  vac_update_datfrozenxid() -- update pg_database.datfrozenxid for our DB 
 * 
 *      Update pg_database's datfrozenxid entry for our database to be the 
 *      minimum of the pg_class.relfrozenxid values. 
 * 
 *      Similarly, update our datminmxid to be the minimum of the 
 *      pg_class.relminmxid values. 
 * 
 *      If we are able to advance either pg_database value, also try to 
 *      truncate pg_xact and pg_multixact. 
 * 
 *      We violate transaction semantics here by overwriting the database's 
 *      existing pg_database tuple with the new values.  This is reasonably 
 *      safe since the new values are correct whether or not this transaction 
 *      commits.  As with vac_update_relstats, this avoids leaving dead tuples 
 *      behind after a VACUUM. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN921"></a><span class='Declare_Function'>vac_update_datfrozenxid</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN923"></a>    <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>tuple</span><span class='Delimiter'>; 
</span><a name="LN924"></a>    <a href="../../include/catalog/pg_database.h.html#LN56"><span class='Ref_to_Typedef'>Form_pg_database</span></a> <span class='Declare_Local'>dbform</span><span class='Delimiter'>; 
</span><a name="LN925"></a>    <a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>relation</span><span class='Delimiter'>; 
</span><a name="LN926"></a>    <a href="../../include/access/genam.h.html#LN86"><span class='Ref_to_Typedef'>SysScanDesc</span></a> <span class='Declare_Local'>scan</span><span class='Delimiter'>; 
</span><a name="LN927"></a>    <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>classTup</span><span class='Delimiter'>; 
</span><a name="LN928"></a>    <a href="../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>newFrozenXid</span><span class='Delimiter'>; 
</span><a name="LN929"></a>    <a href="../../include/c.h.html#LN406"><span class='Ref_to_Typedef'>MultiXactId</span></a> <span class='Declare_Local'>newMinMulti</span><span class='Delimiter'>; 
</span><a name="LN930"></a>    <a href="../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>lastSaneFrozenXid</span><span class='Delimiter'>; 
</span><a name="LN931"></a>    <a href="../../include/c.h.html#LN406"><span class='Ref_to_Typedef'>MultiXactId</span></a> <span class='Declare_Local'>lastSaneMinMulti</span><span class='Delimiter'>; 
</span><a name="LN932"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>bogus</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN933"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>dirty</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Initialize the "min" calculation with GetOldestXmin, which is a 
     * reasonable approximation to the minimum relfrozenxid for not-yet- 
     * committed pg_class entries for new tables; see AddNewRelationTuple(). 
     * So we cannot produce a wrong minimum by starting with this. 
     */ 
</span>    <a href="vacuum.c.html#LN928"><span class='Ref_To_Local'>newFrozenXid</span></a> <span class='Operator'>= </span><a href="../../include/storage/procarray.h.html#LN91"><span class='Ref_to_Proto'>GetOldestXmin</span></a><span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><a href="../../include/storage/procarray.h.html#LN52"><span class='Ref_to_Const'>PROCARRAY_FLAGS_VACUUM</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Similarly, initialize the MultiXact "min" with the value that would be 
     * used on pg_class for new tables.  See AddNewRelationTuple(). 
     */ 
</span>    <a href="vacuum.c.html#LN929"><span class='Ref_To_Local'>newMinMulti</span></a> <span class='Operator'>= </span><a href="../../include/access/multixact.h.html#LN137"><span class='Ref_to_Proto'>GetOldestMultiXactId</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Identify the latest relfrozenxid and relminmxid values that we could 
     * validly see during the scan.  These are conservative values, but it's 
     * not really worth trying to be more exact. 
     */ 
</span>    <a href="vacuum.c.html#LN930"><span class='Ref_To_Local'>lastSaneFrozenXid</span></a> <span class='Operator'>= </span><a href="../../include/access/transam.h.html#LN178"><span class='Ref_to_Proto'>ReadNewTransactionId</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="vacuum.c.html#LN931"><span class='Ref_To_Local'>lastSaneMinMulti</span></a> <span class='Operator'>= </span><a href="../../include/access/multixact.h.html#LN109"><span class='Ref_to_Proto'>ReadNextMultiXactId</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We must seqscan pg_class to find the minimum Xid, because there is no 
     * index that can help us here. 
     */ 
</span>    <a href="vacuum.c.html#LN925"><span class='Ref_To_Local'>relation</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN91"><span class='Ref_to_Proto'>heap_open</span></a><span class='Parentheses'>(</span><a href="../../include/catalog/pg_class.h.html#LN28"><span class='Ref_to_Const'>RelationRelationId</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN35"><span class='Ref_to_Const'>AccessShareLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="vacuum.c.html#LN926"><span class='Ref_To_Local'>scan</span></a> <span class='Operator'>= </span><a href="../../include/access/genam.h.html#LN189"><span class='Ref_to_Proto'>systable_beginscan</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN925"><span class='Ref_To_Local'>relation</span></a><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                              <span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>while</span> <span class='Parentheses'>((</span><a href="vacuum.c.html#LN927"><span class='Ref_To_Local'>classTup</span></a> <span class='Operator'>= </span><a href="../../include/access/genam.h.html#LN194"><span class='Ref_to_Proto'>systable_getnext</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN926"><span class='Ref_To_Local'>scan</span></a><span class='Parentheses'>))</span> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span><a name="LN968"></a>        <a href="../../include/catalog/pg_class.h.html#LN94"><span class='Ref_to_Typedef'>Form_pg_class</span></a> <span class='Declare_Local'>classForm</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/catalog/pg_class.h.html#LN94"><span class='Ref_to_Typedef'>Form_pg_class</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN927"><span class='Ref_To_Local'>classTup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Only consider relations able to hold unfrozen XIDs (anything else 
         * should have InvalidTransactionId in relfrozenxid anyway.) 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN968"><span class='Ref_To_Local'>classForm</span></a><span class='Operator'>-&GT;</span>relkind <span class='Operator'>!= </span><a href="../../include/catalog/pg_class.h.html#LN159"><span class='Ref_to_Const'>RELKIND_RELATION</span></a> <span class='Operator'>&& 
</span>            <a href="vacuum.c.html#LN968"><span class='Ref_To_Local'>classForm</span></a><span class='Operator'>-&GT;</span>relkind <span class='Operator'>!= </span><a href="../../include/catalog/pg_class.h.html#LN164"><span class='Ref_to_Const'>RELKIND_MATVIEW</span></a> <span class='Operator'>&& 
</span>            <a href="vacuum.c.html#LN968"><span class='Ref_To_Local'>classForm</span></a><span class='Operator'>-&GT;</span>relkind <span class='Operator'>!= </span><a href="../../include/catalog/pg_class.h.html#LN162"><span class='Ref_to_Const'>RELKIND_TOASTVALUE</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN968"><span class='Ref_To_Local'>classForm</span></a><span class='Operator'>-&GT;</span>relfrozenxid<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../include/access/multixact.h.html#LN26"><span class='Ref_to_Macro'>MultiXactIdIsValid</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN968"><span class='Ref_To_Local'>classForm</span></a><span class='Operator'>-&GT;</span>relminmxid<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If things are working properly, no relation should have a 
         * relfrozenxid or relminmxid that is "in the future".  However, such 
         * cases have been known to arise due to bugs in pg_upgrade.  If we 
         * see any entries that are "in the future", chicken out and don't do 
         * anything.  This ensures we won't truncate clog before those 
         * relations have been scanned and cleaned up. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN930"><span class='Ref_To_Local'>lastSaneFrozenXid</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN968"><span class='Ref_To_Local'>classForm</span></a><span class='Operator'>-&GT;</span>relfrozenxid<span class='Parentheses'>) </span><span class='Operator'>|| 
</span>            <a href="../../include/access/multixact.h.html#LN114"><span class='Ref_to_Proto'>MultiXactIdPrecedes</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN931"><span class='Ref_To_Local'>lastSaneMinMulti</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN968"><span class='Ref_To_Local'>classForm</span></a><span class='Operator'>-&GT;</span>relminmxid<span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="vacuum.c.html#LN932"><span class='Ref_To_Local'>bogus</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN968"><span class='Ref_To_Local'>classForm</span></a><span class='Operator'>-&GT;</span>relfrozenxid<span class='Delimiter'>, </span><a href="vacuum.c.html#LN928"><span class='Ref_To_Local'>newFrozenXid</span></a><span class='Parentheses'>))</span> 
            <a href="vacuum.c.html#LN928"><span class='Ref_To_Local'>newFrozenXid</span></a> <span class='Operator'>= </span><a href="vacuum.c.html#LN968"><span class='Ref_To_Local'>classForm</span></a><span class='Operator'>-&GT;</span>relfrozenxid<span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/access/multixact.h.html#LN114"><span class='Ref_to_Proto'>MultiXactIdPrecedes</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN968"><span class='Ref_To_Local'>classForm</span></a><span class='Operator'>-&GT;</span>relminmxid<span class='Delimiter'>, </span><a href="vacuum.c.html#LN929"><span class='Ref_To_Local'>newMinMulti</span></a><span class='Parentheses'>))</span> 
            <a href="vacuum.c.html#LN929"><span class='Ref_To_Local'>newMinMulti</span></a> <span class='Operator'>= </span><a href="vacuum.c.html#LN968"><span class='Ref_To_Local'>classForm</span></a><span class='Operator'>-&GT;</span>relminmxid<span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while (classTup=systable_ge... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* we're done with pg_class */ 
</span>    <a href="../../include/access/genam.h.html#LN196"><span class='Ref_to_Proto'>systable_endscan</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN926"><span class='Ref_To_Local'>scan</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/access/heapam.h.html#LN96"><span class='Ref_to_Macro'>heap_close</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN925"><span class='Ref_To_Local'>relation</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN35"><span class='Ref_to_Const'>AccessShareLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* chicken out if bogus data found */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN932"><span class='Ref_To_Local'>bogus</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN928"><span class='Ref_To_Local'>newFrozenXid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../include/access/multixact.h.html#LN26"><span class='Ref_to_Macro'>MultiXactIdIsValid</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN929"><span class='Ref_To_Local'>newMinMulti</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Now fetch the pg_database tuple we need to update. */ 
</span>    <a href="vacuum.c.html#LN925"><span class='Ref_To_Local'>relation</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN91"><span class='Ref_to_Proto'>heap_open</span></a><span class='Parentheses'>(</span><a href="../../include/catalog/pg_database.h.html#LN28"><span class='Ref_to_Const'>DatabaseRelationId</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN37"><span class='Ref_to_Const'>RowExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Fetch a copy of the tuple to scribble on */ 
</span>    <a href="vacuum.c.html#LN923"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>= </span><a href="../../include/utils/syscache.h.html#LN164"><span class='Ref_to_Macro'>SearchSysCacheCopy1</span></a><span class='Parentheses'>(</span><a href="../../include/utils/syscache.h.html#LN54"><span class='Ref_to_EnumConst'>DATABASEOID</span></a><span class='Delimiter'>, </span><a href="../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="../utils/init/globals.c.html#LN76"><span class='Ref_to_Global_Var'>MyDatabaseId</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN923"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>))</span> 
        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"could not find tuple for database %u"</span><span class='Delimiter'>, </span><a href="../utils/init/globals.c.html#LN76"><span class='Ref_to_Global_Var'>MyDatabaseId</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="vacuum.c.html#LN924"><span class='Ref_To_Local'>dbform</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/catalog/pg_database.h.html#LN56"><span class='Ref_to_Typedef'>Form_pg_database</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN923"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * As in vac_update_relstats(), we ordinarily don't want to let 
     * datfrozenxid go backward; but if it's "in the future" then it must be 
     * corrupt and it seems best to overwrite it. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN924"><span class='Ref_To_Local'>dbform</span></a><span class='Operator'>-&GT;</span>datfrozenxid <span class='Operator'>!= </span><a href="vacuum.c.html#LN928"><span class='Ref_To_Local'>newFrozenXid</span></a> <span class='Operator'>&& 
</span>        <span class='Parentheses'>(</span><a href="../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN924"><span class='Ref_To_Local'>dbform</span></a><span class='Operator'>-&GT;</span>datfrozenxid<span class='Delimiter'>, </span><a href="vacuum.c.html#LN928"><span class='Ref_To_Local'>newFrozenXid</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>         <a href="../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN930"><span class='Ref_To_Local'>lastSaneFrozenXid</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN924"><span class='Ref_To_Local'>dbform</span></a><span class='Operator'>-&GT;</span>datfrozenxid<span class='Parentheses'>)))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="vacuum.c.html#LN924"><span class='Ref_To_Local'>dbform</span></a><span class='Operator'>-&GT;</span>datfrozenxid <span class='Operator'>= </span><a href="vacuum.c.html#LN928"><span class='Ref_To_Local'>newFrozenXid</span></a><span class='Delimiter'>; 
</span>        <a href="vacuum.c.html#LN933"><span class='Ref_To_Local'>dirty</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
        <a href="vacuum.c.html#LN928"><span class='Ref_To_Local'>newFrozenXid</span></a> <span class='Operator'>= </span><a href="vacuum.c.html#LN924"><span class='Ref_To_Local'>dbform</span></a><span class='Operator'>-&GT;</span>datfrozenxid<span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Ditto for datminmxid */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN924"><span class='Ref_To_Local'>dbform</span></a><span class='Operator'>-&GT;</span>datminmxid <span class='Operator'>!= </span><a href="vacuum.c.html#LN929"><span class='Ref_To_Local'>newMinMulti</span></a> <span class='Operator'>&& 
</span>        <span class='Parentheses'>(</span><a href="../../include/access/multixact.h.html#LN114"><span class='Ref_to_Proto'>MultiXactIdPrecedes</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN924"><span class='Ref_To_Local'>dbform</span></a><span class='Operator'>-&GT;</span>datminmxid<span class='Delimiter'>, </span><a href="vacuum.c.html#LN929"><span class='Ref_To_Local'>newMinMulti</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>         <a href="../../include/access/multixact.h.html#LN114"><span class='Ref_to_Proto'>MultiXactIdPrecedes</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN931"><span class='Ref_To_Local'>lastSaneMinMulti</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN924"><span class='Ref_To_Local'>dbform</span></a><span class='Operator'>-&GT;</span>datminmxid<span class='Parentheses'>)))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="vacuum.c.html#LN924"><span class='Ref_To_Local'>dbform</span></a><span class='Operator'>-&GT;</span>datminmxid <span class='Operator'>= </span><a href="vacuum.c.html#LN929"><span class='Ref_To_Local'>newMinMulti</span></a><span class='Delimiter'>; 
</span>        <a href="vacuum.c.html#LN933"><span class='Ref_To_Local'>dirty</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
        <a href="vacuum.c.html#LN929"><span class='Ref_To_Local'>newMinMulti</span></a> <span class='Operator'>= </span><a href="vacuum.c.html#LN924"><span class='Ref_To_Local'>dbform</span></a><span class='Operator'>-&GT;</span>datminmxid<span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN933"><span class='Ref_To_Local'>dirty</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/access/heapam.h.html#LN168"><span class='Ref_to_Proto'>heap_inplace_update</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN925"><span class='Ref_To_Local'>relation</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN923"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/access/htup_details.h.html#LN815"><span class='Ref_to_Proto'>heap_freetuple</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN923"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/access/heapam.h.html#LN96"><span class='Ref_to_Macro'>heap_close</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN925"><span class='Ref_To_Local'>relation</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN37"><span class='Ref_to_Const'>RowExclusiveLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we were able to advance datfrozenxid or datminmxid, see if we can 
     * truncate pg_xact and/or pg_multixact.  Also do it if the shared 
     * XID-wrap-limit info is stale, since this action will update that too. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN933"><span class='Ref_To_Local'>dirty</span></a> <span class='Operator'>|| </span><a href="../../include/access/transam.h.html#LN182"><span class='Ref_to_Proto'>ForceTransactionIdLimitUpdate</span></a><span class='Parentheses'>())</span> 
        <a href="vacuum.c.html#LN70"><span class='Ref_to_Proto'>vac_truncate_clog</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN928"><span class='Ref_To_Local'>newFrozenXid</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN929"><span class='Ref_To_Local'>newMinMulti</span></a><span class='Delimiter'>, 
</span>                          <a href="vacuum.c.html#LN930"><span class='Ref_To_Local'>lastSaneFrozenXid</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN931"><span class='Ref_To_Local'>lastSaneMinMulti</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end vac_update_datfrozenxid &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 *  vac_truncate_clog() -- attempt to truncate the commit log 
 * 
 *      Scan pg_database to determine the system-wide oldest datfrozenxid, 
 *      and use it to truncate the transaction commit log (pg_xact). 
 *      Also update the XID wrap limit info maintained by varsup.c. 
 *      Likewise for datminmxid. 
 * 
 *      The passed frozenXID and minMulti are the updated values for my own 
 *      pg_database entry. They're used to initialize the "min" calculations. 
 *      The caller also passes the "last sane" XID and MXID, since it has 
 *      those at hand already. 
 * 
 *      This routine is only invoked when we've managed to change our 
 *      DB's datfrozenxid/datminmxid values, or we found that the shared 
 *      XID-wrap-limit info is stale. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1085"></a><span class='Declare_Function'>vac_truncate_clog</span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>frozenXID</span><span class='Delimiter'>, 
</span><a name="LN1086"></a>                  <a href="../../include/c.h.html#LN406"><span class='Ref_to_Typedef'>MultiXactId</span></a> <span class='Declare_Parameter'>minMulti</span><span class='Delimiter'>, 
</span><a name="LN1087"></a>                  <a href="../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Parameter'>lastSaneFrozenXid</span><span class='Delimiter'>, 
</span><a name="LN1088"></a>                  <a href="../../include/c.h.html#LN406"><span class='Ref_to_Typedef'>MultiXactId</span></a> <span class='Declare_Parameter'>lastSaneMinMulti</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1090"></a>    <a href="../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>nextXID</span> <span class='Operator'>= </span><a href="../../include/access/transam.h.html#LN178"><span class='Ref_to_Proto'>ReadNewTransactionId</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span><a name="LN1091"></a>    <a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>relation</span><span class='Delimiter'>; 
</span><a name="LN1092"></a>    <a href="../../include/access/heapam.h.html#LN99"><span class='Ref_to_Typedef'>HeapScanDesc</span></a> <span class='Declare_Local'>scan</span><span class='Delimiter'>; 
</span><a name="LN1093"></a>    <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>tuple</span><span class='Delimiter'>; 
</span><a name="LN1094"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>oldestxid_datoid</span><span class='Delimiter'>; 
</span><a name="LN1095"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>minmulti_datoid</span><span class='Delimiter'>; 
</span><a name="LN1096"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>bogus</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN1097"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>frozenAlreadyWrapped</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* init oldest datoids to sync with my frozenXID/minMulti values */ 
</span>    <a href="vacuum.c.html#LN1094"><span class='Ref_To_Local'>oldestxid_datoid</span></a> <span class='Operator'>= </span><a href="../utils/init/globals.c.html#LN76"><span class='Ref_to_Global_Var'>MyDatabaseId</span></a><span class='Delimiter'>; 
</span>    <a href="vacuum.c.html#LN1095"><span class='Ref_To_Local'>minmulti_datoid</span></a> <span class='Operator'>= </span><a href="../utils/init/globals.c.html#LN76"><span class='Ref_to_Global_Var'>MyDatabaseId</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Scan pg_database to compute the minimum datfrozenxid/datminmxid 
     * 
     * Since vac_update_datfrozenxid updates datfrozenxid/datminmxid in-place, 
     * the values could change while we look at them.  Fetch each one just 
     * once to ensure sane behavior of the comparison logic.  (Here, as in 
     * many other places, we assume that fetching or updating an XID in shared 
     * storage is atomic.) 
     * 
     * Note: we need not worry about a race condition with new entries being 
     * inserted by CREATE DATABASE.  Any such entry will have a copy of some 
     * existing DB's datfrozenxid, and that source DB cannot be ours because 
     * of the interlock against copying a DB containing an active backend. 
     * Hence the new entry will not reduce the minimum.  Also, if two VACUUMs 
     * concurrently modify the datfrozenxid's of different databases, the 
     * worst possible outcome is that pg_xact is not truncated as aggressively 
     * as it could be. 
     */ 
</span>    <a href="vacuum.c.html#LN1091"><span class='Ref_To_Local'>relation</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN91"><span class='Ref_to_Proto'>heap_open</span></a><span class='Parentheses'>(</span><a href="../../include/catalog/pg_database.h.html#LN28"><span class='Ref_to_Const'>DatabaseRelationId</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN35"><span class='Ref_to_Const'>AccessShareLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="vacuum.c.html#LN1092"><span class='Ref_To_Local'>scan</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN110"><span class='Ref_to_Proto'>heap_beginscan_catalog</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1091"><span class='Ref_To_Local'>relation</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>while</span> <span class='Parentheses'>((</span><a href="vacuum.c.html#LN1093"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN127"><span class='Ref_to_Proto'>heap_getnext</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1092"><span class='Ref_To_Local'>scan</span></a><span class='Delimiter'>, </span><a href="../../include/access/sdir.h.html#LN25"><span class='Ref_to_EnumConst'>ForwardScanDirection</span></a><span class='Parentheses'>))</span> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1127"></a>        <span class='Keyword'>volatile </span>FormData_pg_database <span class='Operator'>*</span><span class='Declare_Local'>dbform</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/catalog/pg_database.h.html#LN56"><span class='Ref_to_Typedef'>Form_pg_database</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1093"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1128"></a>        <a href="../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>datfrozenxid</span> <span class='Operator'>= </span><a href="vacuum.c.html#LN1127"><span class='Ref_To_Local'>dbform</span></a><span class='Operator'>-&GT;</span>datfrozenxid<span class='Delimiter'>; 
</span><a name="LN1129"></a>        <a href="../../include/c.h.html#LN396"><span class='Ref_to_Typedef'>TransactionId</span></a> <span class='Declare_Local'>datminmxid</span> <span class='Operator'>= </span><a href="vacuum.c.html#LN1127"><span class='Ref_To_Local'>dbform</span></a><span class='Operator'>-&GT;</span>datminmxid<span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../include/access/transam.h.html#LN41"><span class='Ref_to_Macro'>TransactionIdIsNormal</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1128"><span class='Ref_To_Local'>datfrozenxid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../include/access/multixact.h.html#LN26"><span class='Ref_to_Macro'>MultiXactIdIsValid</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1129"><span class='Ref_To_Local'>datminmxid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If things are working properly, no database should have a 
         * datfrozenxid or datminmxid that is "in the future".  However, such 
         * cases have been known to arise due to bugs in pg_upgrade.  If we 
         * see any entries that are "in the future", chicken out and don't do 
         * anything.  This ensures we won't truncate clog before those 
         * databases have been scanned and cleaned up.  (We will issue the 
         * "already wrapped" warning if appropriate, though.) 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1087"><span class='Ref_to_Parameter'>lastSaneFrozenXid</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN1128"><span class='Ref_To_Local'>datfrozenxid</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>            <a href="../../include/access/multixact.h.html#LN114"><span class='Ref_to_Proto'>MultiXactIdPrecedes</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1088"><span class='Ref_to_Parameter'>lastSaneMinMulti</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN1129"><span class='Ref_To_Local'>datminmxid</span></a><span class='Parentheses'>))</span> 
            <a href="vacuum.c.html#LN1096"><span class='Ref_To_Local'>bogus</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1090"><span class='Ref_To_Local'>nextXID</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN1128"><span class='Ref_To_Local'>datfrozenxid</span></a><span class='Parentheses'>))</span> 
            <a href="vacuum.c.html#LN1097"><span class='Ref_To_Local'>frozenAlreadyWrapped</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/access/transam.h.html#LN168"><span class='Ref_to_Proto'>TransactionIdPrecedes</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1128"><span class='Ref_To_Local'>datfrozenxid</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN1085"><span class='Ref_to_Parameter'>frozenXID</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="vacuum.c.html#LN1085"><span class='Ref_to_Parameter'>frozenXID</span></a> <span class='Operator'>= </span><a href="vacuum.c.html#LN1128"><span class='Ref_To_Local'>datfrozenxid</span></a><span class='Delimiter'>; 
</span>            <a href="vacuum.c.html#LN1094"><span class='Ref_To_Local'>oldestxid_datoid</span></a> <span class='Operator'>= </span><a href="../../include/access/htup_details.h.html#LN694"><span class='Ref_to_Macro'>HeapTupleGetOid</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1093"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/access/multixact.h.html#LN114"><span class='Ref_to_Proto'>MultiXactIdPrecedes</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1129"><span class='Ref_To_Local'>datminmxid</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN1086"><span class='Ref_to_Parameter'>minMulti</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="vacuum.c.html#LN1086"><span class='Ref_to_Parameter'>minMulti</span></a> <span class='Operator'>= </span><a href="vacuum.c.html#LN1129"><span class='Ref_To_Local'>datminmxid</span></a><span class='Delimiter'>; 
</span>            <a href="vacuum.c.html#LN1095"><span class='Ref_To_Local'>minmulti_datoid</span></a> <span class='Operator'>= </span><a href="../../include/access/htup_details.h.html#LN694"><span class='Ref_to_Macro'>HeapTupleGetOid</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1093"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while (tuple=heap_getnext(s... &raquo; </span> 
 
    <a href="../../include/access/heapam.h.html#LN126"><span class='Ref_to_Proto'>heap_endscan</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1092"><span class='Ref_To_Local'>scan</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/access/heapam.h.html#LN96"><span class='Ref_to_Macro'>heap_close</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1091"><span class='Ref_To_Local'>relation</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN35"><span class='Ref_to_Const'>AccessShareLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Do not truncate CLOG if we seem to have suffered wraparound already; 
     * the computed minimum XID might be bogus.  This case should now be 
     * impossible due to the defenses in GetNewTransactionId, but we keep the 
     * test anyway. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN1097"><span class='Ref_To_Local'>frozenAlreadyWrapped</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN39"><span class='Ref_to_Const'>WARNING</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"some databases have not been vacuumed in over 2 billion transactions"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"You might have already suffered transaction-wraparound data loss."</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* chicken out if data is bogus in any other way */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN1096"><span class='Ref_To_Local'>bogus</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Advance the oldest value for commit timestamps before truncating, so 
     * that if a user requests a timestamp for a transaction we're truncating 
     * away right after this point, they get NULL instead of an ugly "file not 
     * found" error from slru.c.  This doesn't matter for xact/multixact 
     * because they are not subject to arbitrary lookups from users. 
     */ 
</span>    <a href="../../include/access/commit_ts.h.html#LN45"><span class='Ref_to_Proto'>AdvanceOldestCommitTsXid</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1085"><span class='Ref_to_Parameter'>frozenXID</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Truncate CLOG, multixact and CommitTs to the oldest computed value. 
     */ 
</span>    <a href="../../include/access/clog.h.html#LN50"><span class='Ref_to_Proto'>TruncateCLOG</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1085"><span class='Ref_to_Parameter'>frozenXID</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN1094"><span class='Ref_To_Local'>oldestxid_datoid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/access/commit_ts.h.html#LN42"><span class='Ref_to_Proto'>TruncateCommitTs</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1085"><span class='Ref_to_Parameter'>frozenXID</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/access/multixact.h.html#LN138"><span class='Ref_to_Proto'>TruncateMultiXact</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1086"><span class='Ref_to_Parameter'>minMulti</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN1095"><span class='Ref_To_Local'>minmulti_datoid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Update the wrap limit for GetNewTransactionId and creation of new 
     * MultiXactIds.  Note: these functions will also signal the postmaster 
     * for an(other) autovac cycle if needed.   XXX should we avoid possibly 
     * signalling twice? 
     */ 
</span>    <a href="../../include/access/transam.h.html#LN179"><span class='Ref_to_Proto'>SetTransactionIdLimit</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1085"><span class='Ref_to_Parameter'>frozenXID</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN1094"><span class='Ref_To_Local'>oldestxid_datoid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/access/multixact.h.html#LN128"><span class='Ref_to_Proto'>SetMultiXactIdLimit</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1086"><span class='Ref_to_Parameter'>minMulti</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN1095"><span class='Ref_To_Local'>minmulti_datoid</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end vac_truncate_clog &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 *  vacuum_rel() -- vacuum one heap relation 
 * 
 *      Doing one heap at a time incurs extra overhead, since we need to 
 *      check that the heap exists again just before we vacuum it.  The 
 *      reason that we do this is so that vacuuming can be spread across 
 *      many small transactions.  Otherwise, two-phase locking would require 
 *      us to lock the entire database during one pass of the vacuum cleaner. 
 * 
 *      At entry and exit, we are not inside a transaction. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN1223"></a><span class='Declare_Function'>vacuum_rel</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>relid</span><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN62"><span class='Ref_to_Struct'>RangeVar</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>relation</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>options</span><span class='Delimiter'>, </span><a href="../../include/commands/vacuum.h.html#LN135"><span class='Ref_to_Struct'>VacuumParams</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>params</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1225"></a>    <a href="../../include/storage/lockdefs.h.html#LN25"><span class='Ref_to_Typedef'>LOCKMODE</span></a>    <span class='Declare_Local'>lmode</span><span class='Delimiter'>; 
</span><a name="LN1226"></a>    <a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>onerel</span><span class='Delimiter'>; 
</span><a name="LN1227"></a>    <a href="../../include/utils/rel.h.html#LN35"><span class='Ref_to_Struct'>LockRelId</span></a>   <span class='Declare_Local'>onerelid</span><span class='Delimiter'>; 
</span><a name="LN1228"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>toast_relid</span><span class='Delimiter'>; 
</span><a name="LN1229"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>save_userid</span><span class='Delimiter'>; 
</span><a name="LN1230"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>save_sec_context</span><span class='Delimiter'>; 
</span><a name="LN1231"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>save_nestlevel</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1223"><span class='Ref_to_Parameter'>params</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Begin a transaction for vacuuming this relation */ 
</span>    <a href="../../include/access/xact.h.html#LN348"><span class='Ref_to_Proto'>StartTransactionCommand</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Functions in indexes may want a snapshot set.  Also, setting a snapshot 
     * ensures that RecentGlobalXmin is kept truly recent. 
     */ 
</span>    <a href="../../include/utils/snapmgr.h.html#LN73"><span class='Ref_to_Proto'>PushActiveSnapshot</span></a><span class='Parentheses'>(</span><a href="../../include/utils/snapmgr.h.html#LN63"><span class='Ref_to_Proto'>GetTransactionSnapshot</span></a><span class='Parentheses'>())</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1223"><span class='Ref_to_Parameter'>options</span></a> <span class='Operator'>& </span><a href="../../include/nodes/parsenodes.h.html#LN3066"><span class='Ref_to_EnumConst'>VACOPT_FULL</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * In lazy vacuum, we can set the PROC_IN_VACUUM flag, which lets 
         * other concurrent VACUUMs know that they can ignore this one while 
         * determining their OldestXmin.  (The reason we don't set it during a 
         * full VACUUM is exactly that we may have to run user-defined 
         * functions for functional indexes, and we want to make sure that if 
         * they use the snapshot set above, any tuples it requires can't get 
         * removed from other tables.  An index function that depends on the 
         * contents of other tables is arguably broken, but we won't break it 
         * here by violating transaction semantics.) 
         * 
         * We also set the VACUUM_FOR_WRAPAROUND flag, which is passed down by 
         * autovacuum; it's used to avoid canceling a vacuum that was invoked 
         * in an emergency. 
         * 
         * Note: these flags remain set until CommitTransaction or 
         * AbortTransaction.  We don't want to clear them until we reset 
         * MyPgXact-&GT;xid/xmin, else OldestXmin might appear to go backwards, 
         * which is probably Not Good. 
         */ 
</span>        <a href="../../include/storage/lwlock.h.html#LN145"><span class='Ref_to_Proto'>LWLockAcquire</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Delimiter'>, </span><a href="../../include/storage/lwlock.h.html#LN133"><span class='Ref_to_EnumConst'>LW_EXCLUSIVE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../storage/lmgr/proc.c.html#LN67"><span class='Ref_to_Global_Var'>MyPgXact</span></a><span class='Operator'>-&GT;</span><a href="../../include/storage/proc.h.html#LN217"><span class='Ref_to_Member'>vacuumFlags</span></a> <span class='Operator'>|= </span><a href="../../include/storage/proc.h.html#LN52"><span class='Ref_to_Const'>PROC_IN_VACUUM</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN1223"><span class='Ref_to_Parameter'>params</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/vacuum.h.html#LN143"><span class='Ref_to_Member'>is_wraparound</span></a><span class='Parentheses'>) 
</span>            <a href="../storage/lmgr/proc.c.html#LN67"><span class='Ref_to_Global_Var'>MyPgXact</span></a><span class='Operator'>-&GT;</span><a href="../../include/storage/proc.h.html#LN217"><span class='Ref_to_Member'>vacuumFlags</span></a> <span class='Operator'>|= </span><a href="../../include/storage/proc.h.html#LN54"><span class='Ref_to_Const'>PROC_VACUUM_FOR_WRAPAROUND</span></a><span class='Delimiter'>; 
</span>        <a href="../../include/storage/lwlock.h.html#LN148"><span class='Ref_to_Proto'>LWLockRelease</span></a><span class='Parentheses'>(</span>ProcArrayLock<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !(options&VACOPT_FULL... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Check for user-requested abort.  Note we want this to be inside a 
     * transaction, so xact.c doesn't issue useless WARNING. 
     */ 
</span>    <a href="../../include/miscadmin.h.html#LN99"><span class='Ref_to_Macro'>CHECK_FOR_INTERRUPTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Determine the type of lock we want --- hard exclusive lock for a FULL 
     * vacuum, but just ShareUpdateExclusiveLock for concurrent vacuum. Either 
     * way, we can be sure that no other backend is vacuuming the same table. 
     */ 
</span>    <a href="vacuum.c.html#LN1225"><span class='Ref_To_Local'>lmode</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1223"><span class='Ref_to_Parameter'>options</span></a> <span class='Operator'>& </span><a href="../../include/nodes/parsenodes.h.html#LN3066"><span class='Ref_to_EnumConst'>VACOPT_FULL</span></a><span class='Parentheses'>) </span><span class='Operator'>? </span><a href="../../include/storage/lockdefs.h.html#LN45"><span class='Ref_to_Const'>AccessExclusiveLock</span></a> <span class='Operator'>: </span><a href="../../include/storage/lockdefs.h.html#LN38"><span class='Ref_to_Const'>ShareUpdateExclusiveLock</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Open the relation and get the appropriate lock on it. 
     * 
     * There's a race condition here: the rel may have gone away since the 
     * last time we saw it.  If so, we don't need to vacuum it. 
     * 
     * If we've been asked not to wait for the relation lock, acquire it first 
     * in non-blocking mode, before calling try_relation_open(). 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1223"><span class='Ref_to_Parameter'>options</span></a> <span class='Operator'>& </span><a href="../../include/nodes/parsenodes.h.html#LN3067"><span class='Ref_to_EnumConst'>VACOPT_NOWAIT</span></a><span class='Parentheses'>))</span> 
        <a href="vacuum.c.html#LN1226"><span class='Ref_To_Local'>onerel</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN85"><span class='Ref_to_Proto'>try_relation_open</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1223"><span class='Ref_to_Parameter'>relid</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN1225"><span class='Ref_To_Local'>lmode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/storage/lmgr.h.html#LN40"><span class='Ref_to_Proto'>ConditionalLockRelationOid</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1223"><span class='Ref_to_Parameter'>relid</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN1225"><span class='Ref_To_Local'>lmode</span></a><span class='Parentheses'>))</span> 
        <a href="vacuum.c.html#LN1226"><span class='Ref_To_Local'>onerel</span></a> <span class='Operator'>= </span><a href="../../include/access/heapam.h.html#LN85"><span class='Ref_to_Proto'>try_relation_open</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1223"><span class='Ref_to_Parameter'>relid</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN33"><span class='Ref_to_Const'>NoLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="vacuum.c.html#LN1226"><span class='Ref_To_Local'>onerel</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/postmaster/autovacuum.h.html#LN50"><span class='Ref_to_Proto'>IsAutoVacuumWorkerProcess</span></a><span class='Parentheses'>() </span><span class='Operator'>&& </span><a href="vacuum.c.html#LN1223"><span class='Ref_to_Parameter'>params</span></a><span class='Operator'>-&GT;</span><a href="../../include/commands/vacuum.h.html#LN144"><span class='Ref_to_Member'>log_min_duration</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN25"><span class='Ref_to_Const'>LOG</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_LOCK_NOT_AVAILABLE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                   <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"skipping vacuum of \"%s\" --- lock not available"</span><span class='Delimiter'>, 
</span>                          <a href="vacuum.c.html#LN1223"><span class='Ref_to_Parameter'>relation</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN67"><span class='Ref_to_Member'>relname</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="vacuum.c.html#LN1226"><span class='Ref_To_Local'>onerel</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../include/utils/snapmgr.h.html#LN76"><span class='Ref_to_Proto'>PopActiveSnapshot</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <a href="../../include/access/xact.h.html#LN349"><span class='Ref_to_Proto'>CommitTransactionCommand</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Check permissions. 
     * 
     * We allow the user to vacuum a table if he is superuser, the table 
     * owner, or the database owner (but in the latter case, only if it's not 
     * a shared relation).  pg_class_ownercheck includes the superuser case. 
     * 
     * Note we choose to treat permissions failure as a WARNING and keep 
     * trying to vacuum the rest of the DB --- is this appropriate? 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span><a href="../../include/utils/acl.h.html#LN308"><span class='Ref_to_Proto'>pg_class_ownercheck</span></a><span class='Parentheses'>(</span><a href="../../include/utils/rel.h.html#LN416"><span class='Ref_to_Macro'>RelationGetRelid</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1226"><span class='Ref_To_Local'>onerel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="../utils/init/miscinit.c.html#LN281"><span class='Ref_to_Func'>GetUserId</span></a><span class='Parentheses'>())</span> <span class='Operator'>|| 
</span>          <span class='Parentheses'>(</span><a href="../../include/utils/acl.h.html#LN318"><span class='Ref_to_Proto'>pg_database_ownercheck</span></a><span class='Parentheses'>(</span><a href="../utils/init/globals.c.html#LN76"><span class='Ref_to_Global_Var'>MyDatabaseId</span></a><span class='Delimiter'>, </span><a href="../utils/init/miscinit.c.html#LN281"><span class='Ref_to_Func'>GetUserId</span></a><span class='Parentheses'>())</span> <span class='Operator'>&& !</span><a href="vacuum.c.html#LN1226"><span class='Ref_To_Local'>onerel</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relisshared<span class='Parentheses'>)))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN1226"><span class='Ref_To_Local'>onerel</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relisshared<span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN39"><span class='Ref_to_Const'>WARNING</span></a><span class='Delimiter'>, 
</span>                  <span class='Parentheses'>(</span><a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"skipping \"%s\" --- only superuser can vacuum it"</span><span class='Delimiter'>, 
</span>                          <a href="../../include/utils/rel.h.html#LN436"><span class='Ref_to_Macro'>RelationGetRelationName</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1226"><span class='Ref_To_Local'>onerel</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN1226"><span class='Ref_To_Local'>onerel</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relnamespace <span class='Operator'>== </span><a href="../../include/catalog/pg_namespace.h.html#LN70"><span class='Ref_to_Const'>PG_CATALOG_NAMESPACE</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN39"><span class='Ref_to_Const'>WARNING</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"skipping \"%s\" --- only superuser or database owner can vacuum it"</span><span class='Delimiter'>, 
</span>                            <a href="../../include/utils/rel.h.html#LN436"><span class='Ref_to_Macro'>RelationGetRelationName</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1226"><span class='Ref_To_Local'>onerel</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN39"><span class='Ref_to_Const'>WARNING</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"skipping \"%s\" --- only table or database owner can vacuum it"</span><span class='Delimiter'>, 
</span>                            <a href="../../include/utils/rel.h.html#LN436"><span class='Ref_to_Macro'>RelationGetRelationName</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1226"><span class='Ref_To_Local'>onerel</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>        <a href="../../include/access/heapam.h.html#LN89"><span class='Ref_to_Proto'>relation_close</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1226"><span class='Ref_To_Local'>onerel</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN1225"><span class='Ref_To_Local'>lmode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/utils/snapmgr.h.html#LN76"><span class='Ref_to_Proto'>PopActiveSnapshot</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <a href="../../include/access/xact.h.html#LN349"><span class='Ref_to_Proto'>CommitTransactionCommand</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !(pg_class_ownercheck... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Check that it's a vacuumable relation; we used to do this in 
     * get_rel_oids() but seems safer to check after we've locked the 
     * relation. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN1226"><span class='Ref_To_Local'>onerel</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relkind <span class='Operator'>!= </span><a href="../../include/catalog/pg_class.h.html#LN159"><span class='Ref_to_Const'>RELKIND_RELATION</span></a> <span class='Operator'>&& 
</span>        <a href="vacuum.c.html#LN1226"><span class='Ref_To_Local'>onerel</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relkind <span class='Operator'>!= </span><a href="../../include/catalog/pg_class.h.html#LN164"><span class='Ref_to_Const'>RELKIND_MATVIEW</span></a> <span class='Operator'>&& 
</span>        <a href="vacuum.c.html#LN1226"><span class='Ref_To_Local'>onerel</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relkind <span class='Operator'>!= </span><a href="../../include/catalog/pg_class.h.html#LN162"><span class='Ref_to_Const'>RELKIND_TOASTVALUE</span></a> <span class='Operator'>&& 
</span>        <a href="vacuum.c.html#LN1226"><span class='Ref_To_Local'>onerel</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relkind <span class='Operator'>!= </span><a href="../../include/catalog/pg_class.h.html#LN167"><span class='Ref_to_Const'>RELKIND_PARTITIONED_TABLE</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN39"><span class='Ref_to_Const'>WARNING</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"skipping \"%s\" --- cannot vacuum non-tables or special system tables"</span><span class='Delimiter'>, 
</span>                        <a href="../../include/utils/rel.h.html#LN436"><span class='Ref_to_Macro'>RelationGetRelationName</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1226"><span class='Ref_To_Local'>onerel</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>        <a href="../../include/access/heapam.h.html#LN89"><span class='Ref_to_Proto'>relation_close</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1226"><span class='Ref_To_Local'>onerel</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN1225"><span class='Ref_To_Local'>lmode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/utils/snapmgr.h.html#LN76"><span class='Ref_to_Proto'>PopActiveSnapshot</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <a href="../../include/access/xact.h.html#LN349"><span class='Ref_to_Proto'>CommitTransactionCommand</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Silently ignore tables that are temp tables of other backends --- 
     * trying to vacuum these will lead to great unhappiness, since their 
     * contents are probably not up-to-date on disk.  (We don't throw a 
     * warning here; it would just lead to chatter during a database-wide 
     * VACUUM.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/utils/rel.h.html#LN533"><span class='Ref_to_Macro'>RELATION_IS_OTHER_TEMP</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1226"><span class='Ref_To_Local'>onerel</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../include/access/heapam.h.html#LN89"><span class='Ref_to_Proto'>relation_close</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1226"><span class='Ref_To_Local'>onerel</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN1225"><span class='Ref_To_Local'>lmode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/utils/snapmgr.h.html#LN76"><span class='Ref_to_Proto'>PopActiveSnapshot</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <a href="../../include/access/xact.h.html#LN349"><span class='Ref_to_Proto'>CommitTransactionCommand</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Ignore partitioned tables as there is no work to be done.  Since we 
     * release the lock here, it's possible that any partitions added from 
     * this point on will not get processed, but that seems harmless. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN1226"><span class='Ref_To_Local'>onerel</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relkind <span class='Operator'>== </span><a href="../../include/catalog/pg_class.h.html#LN167"><span class='Ref_to_Const'>RELKIND_PARTITIONED_TABLE</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../include/access/heapam.h.html#LN89"><span class='Ref_to_Proto'>relation_close</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1226"><span class='Ref_To_Local'>onerel</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN1225"><span class='Ref_To_Local'>lmode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/utils/snapmgr.h.html#LN76"><span class='Ref_to_Proto'>PopActiveSnapshot</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>        <a href="../../include/access/xact.h.html#LN349"><span class='Ref_to_Proto'>CommitTransactionCommand</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* It's OK for other commands to look at this table */ 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Get a session-level lock too. This will protect our access to the 
     * relation across multiple transactions, so that we can vacuum the 
     * relation's TOAST table (if any) secure in the knowledge that no one is 
     * deleting the parent relation. 
     * 
     * NOTE: this cannot block, even if someone else is waiting for access, 
     * because the lock manager knows that both lock requests are from the 
     * same process. 
     */ 
</span>    <a href="vacuum.c.html#LN1227"><span class='Ref_To_Local'>onerelid</span></a> <span class='Operator'>= </span><a href="vacuum.c.html#LN1226"><span class='Ref_To_Local'>onerel</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN116"><span class='Ref_to_Member'>rd_lockInfo</span></a><span class='Operator'>.</span><a href="../../include/utils/rel.h.html#LN43"><span class='Ref_to_Member'>lockRelId</span></a><span class='Delimiter'>; 
</span>    <a href="../../include/storage/lmgr.h.html#LN49"><span class='Ref_to_Proto'>LockRelationIdForSession</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="vacuum.c.html#LN1227"><span class='Ref_To_Local'>onerelid</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN1225"><span class='Ref_To_Local'>lmode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Remember the relation's TOAST relation for later, if the caller asked 
     * us to process it.  In VACUUM FULL, though, the toast table is 
     * automatically rebuilt by cluster_rel so we shouldn't recurse to it. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1223"><span class='Ref_to_Parameter'>options</span></a> <span class='Operator'>& </span><a href="../../include/nodes/parsenodes.h.html#LN3068"><span class='Ref_to_EnumConst'>VACOPT_SKIPTOAST</span></a><span class='Parentheses'>) </span><span class='Operator'>&& !</span><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1223"><span class='Ref_to_Parameter'>options</span></a> <span class='Operator'>& </span><a href="../../include/nodes/parsenodes.h.html#LN3066"><span class='Ref_to_EnumConst'>VACOPT_FULL</span></a><span class='Parentheses'>))</span> 
        <a href="vacuum.c.html#LN1228"><span class='Ref_To_Local'>toast_relid</span></a> <span class='Operator'>= </span><a href="vacuum.c.html#LN1226"><span class='Ref_To_Local'>onerel</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>reltoastrelid<span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="vacuum.c.html#LN1228"><span class='Ref_To_Local'>toast_relid</span></a> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Switch to the table owner's userid, so that any index functions are run 
     * as that user.  Also lock down security-restricted operations and 
     * arrange to make GUC variable changes local to this command. (This is 
     * unnecessary, but harmless, for lazy VACUUM.) 
     */ 
</span>    <a href="../../include/miscadmin.h.html#LN312"><span class='Ref_to_Proto'>GetUserIdAndSecContext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="vacuum.c.html#LN1229"><span class='Ref_To_Local'>save_userid</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="vacuum.c.html#LN1230"><span class='Ref_To_Local'>save_sec_context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/miscadmin.h.html#LN313"><span class='Ref_to_Proto'>SetUserIdAndSecContext</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1226"><span class='Ref_To_Local'>onerel</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relowner<span class='Delimiter'>, 
</span>                           <a href="vacuum.c.html#LN1230"><span class='Ref_To_Local'>save_sec_context</span></a> <span class='Operator'>| </span><a href="../../include/miscadmin.h.html#LN296"><span class='Ref_to_Const'>SECURITY_RESTRICTED_OPERATION</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="vacuum.c.html#LN1231"><span class='Ref_To_Local'>save_nestlevel</span></a> <span class='Operator'>= </span><a href="../../include/utils/guc.h.html#LN354"><span class='Ref_to_Proto'>NewGUCNestLevel</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Do the actual work --- either FULL or "lazy" vacuum 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN1223"><span class='Ref_to_Parameter'>options</span></a> <span class='Operator'>& </span><a href="../../include/nodes/parsenodes.h.html#LN3066"><span class='Ref_to_EnumConst'>VACOPT_FULL</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* close relation before vacuuming, but hold lock until commit */ 
</span>        <a href="../../include/access/heapam.h.html#LN89"><span class='Ref_to_Proto'>relation_close</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1226"><span class='Ref_To_Local'>onerel</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN33"><span class='Ref_to_Const'>NoLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="vacuum.c.html#LN1226"><span class='Ref_To_Local'>onerel</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* VACUUM FULL is now a variant of CLUSTER; see cluster.c */ 
</span>        <a href="../../include/commands/cluster.h.html#LN21"><span class='Ref_to_Proto'>cluster_rel</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1223"><span class='Ref_to_Parameter'>relid</span></a><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="vacuum.c.html#LN1223"><span class='Ref_to_Parameter'>options</span></a> <span class='Operator'>& </span><a href="../../include/nodes/parsenodes.h.html#LN3064"><span class='Ref_to_EnumConst'>VACOPT_VERBOSE</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
        <a href="vacuumlazy.c.html#LN181"><span class='Ref_to_Func'>lazy_vacuum_rel</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1226"><span class='Ref_To_Local'>onerel</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN1223"><span class='Ref_to_Parameter'>options</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN1223"><span class='Ref_to_Parameter'>params</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN65"><span class='Ref_to_Global_Var'>vac_strategy</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Roll back any GUC changes executed by index functions */ 
</span>    <a href="../../include/utils/guc.h.html#LN355"><span class='Ref_to_Proto'>AtEOXact_GUC</span></a><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Delimiter'>, </span><a href="vacuum.c.html#LN1231"><span class='Ref_To_Local'>save_nestlevel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Restore userid and security context */ 
</span>    <a href="../../include/miscadmin.h.html#LN313"><span class='Ref_to_Proto'>SetUserIdAndSecContext</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1229"><span class='Ref_To_Local'>save_userid</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN1230"><span class='Ref_To_Local'>save_sec_context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* all done with this class, but hold lock until commit */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN1226"><span class='Ref_To_Local'>onerel</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/access/heapam.h.html#LN89"><span class='Ref_to_Proto'>relation_close</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1226"><span class='Ref_To_Local'>onerel</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN33"><span class='Ref_to_Const'>NoLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Complete the transaction and free all temporary memory used. 
     */ 
</span>    <a href="../../include/utils/snapmgr.h.html#LN76"><span class='Ref_to_Proto'>PopActiveSnapshot</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <a href="../../include/access/xact.h.html#LN349"><span class='Ref_to_Proto'>CommitTransactionCommand</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the relation has a secondary toast rel, vacuum that too while we 
     * still hold the session lock on the master table.  Note however that 
     * "analyze" will not get done on the toast table.  This is good, because 
     * the toaster always uses hardcoded index access and statistics are 
     * totally unimportant for toast relations. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN1228"><span class='Ref_To_Local'>toast_relid</span></a> <span class='Operator'>!= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Parentheses'>) 
</span>        <a href="vacuum.c.html#LN74"><span class='Ref_to_Proto'>vacuum_rel</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1228"><span class='Ref_To_Local'>toast_relid</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN1223"><span class='Ref_to_Parameter'>relation</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN1223"><span class='Ref_to_Parameter'>options</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN1223"><span class='Ref_to_Parameter'>params</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now release the session-level lock on the master table. 
     */ 
</span>    <a href="../../include/storage/lmgr.h.html#LN50"><span class='Ref_to_Proto'>UnlockRelationIdForSession</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="vacuum.c.html#LN1227"><span class='Ref_To_Local'>onerelid</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN1225"><span class='Ref_To_Local'>lmode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Report that we really did it. */ 
</span>    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end vacuum_rel &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * Open all the vacuumable indexes of the given relation, obtaining the 
 * specified kind of lock on each.  Return an array of Relation pointers for 
 * the indexes into *Irel, and the number of indexes into *nindexes. 
 * 
 * We consider an index vacuumable if it is marked insertable (IndexIsReady). 
 * If it isn't, probably a CREATE INDEX CONCURRENTLY command failed early in 
 * execution, and what we have is too corrupt to be processable.  We will 
 * vacuum even if the index isn't indisvalid; this is important because in a 
 * unique index, uniqueness checks will be performed anyway and had better not 
 * hit dangling index pointers. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1495"></a><span class='Declare_Function'>vac_open_indexes</span><span class='Parentheses'>(</span><a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>relation</span><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN25"><span class='Ref_to_Typedef'>LOCKMODE</span></a> <span class='Declare_Parameter'>lockmode</span><span class='Delimiter'>, 
</span><a name="LN1496"></a>                 <span class='Keyword'>int </span><span class='Operator'>*</span><span class='Declare_Parameter'>nindexes</span><span class='Delimiter'>, </span><a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>Irel</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1498"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>indexoidlist</span><span class='Delimiter'>; 
</span><a name="LN1499"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>indexoidscan</span><span class='Delimiter'>; 
</span><a name="LN1500"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1495"><span class='Ref_to_Parameter'>lockmode</span></a> <span class='Operator'>!= </span><a href="../../include/storage/lockdefs.h.html#LN33"><span class='Ref_to_Const'>NoLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="vacuum.c.html#LN1498"><span class='Ref_To_Local'>indexoidlist</span></a> <span class='Operator'>= </span><a href="../../include/utils/relcache.h.html#LN40"><span class='Ref_to_Proto'>RelationGetIndexList</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1495"><span class='Ref_to_Parameter'>relation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* allocate enough memory for all indexes */ 
</span>    <a href="vacuum.c.html#LN1500"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1498"><span class='Ref_To_Local'>indexoidlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN1500"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Operator'>*</span><a href="vacuum.c.html#LN1496"><span class='Ref_to_Parameter'>Irel</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1500"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <span class='Operator'>*</span><a href="vacuum.c.html#LN1496"><span class='Ref_to_Parameter'>Irel</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* collect just the ready indexes */ 
</span>    <a href="vacuum.c.html#LN1500"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1499"><span class='Ref_To_Local'>indexoidscan</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN1498"><span class='Ref_To_Local'>indexoidlist</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1518"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>indexoid</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN107"><span class='Ref_to_Macro'>lfirst_oid</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1499"><span class='Ref_To_Local'>indexoidscan</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1519"></a>        <a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>indrel</span><span class='Delimiter'>; 
</span> 
        <a href="vacuum.c.html#LN1519"><span class='Ref_To_Local'>indrel</span></a> <span class='Operator'>= </span><a href="../../include/access/genam.h.html#LN129"><span class='Ref_to_Proto'>index_open</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1518"><span class='Ref_To_Local'>indexoid</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN1495"><span class='Ref_to_Parameter'>lockmode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/catalog/pg_index.h.html#LN107"><span class='Ref_to_Macro'>IndexIsReady</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1519"><span class='Ref_To_Local'>indrel</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN158"><span class='Ref_to_Member'>rd_index</span></a><span class='Parentheses'>))</span> 
            <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="vacuum.c.html#LN1496"><span class='Ref_to_Parameter'>Irel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>[</span><a href="vacuum.c.html#LN1500"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="vacuum.c.html#LN1519"><span class='Ref_To_Local'>indrel</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="../../include/access/genam.h.html#LN130"><span class='Ref_to_Proto'>index_close</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1519"><span class='Ref_To_Local'>indrel</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN1495"><span class='Ref_to_Parameter'>lockmode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Operator'>*</span><a href="vacuum.c.html#LN1496"><span class='Ref_to_Parameter'>nindexes</span></a> <span class='Operator'>= </span><a href="vacuum.c.html#LN1500"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN265"><span class='Ref_to_Proto'>list_free</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1498"><span class='Ref_To_Local'>indexoidlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end vac_open_indexes &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Release the resources acquired by vac_open_indexes.  Optionally release 
 * the locks (say NoLock to keep 'em). 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1538"></a><span class='Declare_Function'>vac_close_indexes</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>nindexes</span><span class='Delimiter'>, </span><a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>Irel</span><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN25"><span class='Ref_to_Typedef'>LOCKMODE</span></a> <span class='Declare_Parameter'>lockmode</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN1538"><span class='Ref_to_Parameter'>Irel</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN1538"><span class='Ref_to_Parameter'>nindexes</span></a><span class='Operator'>--</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1545"></a>        <a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>ind</span> <span class='Operator'>= </span><a href="vacuum.c.html#LN1538"><span class='Ref_to_Parameter'>Irel</span></a><span class='Delimiter'>[</span><a href="vacuum.c.html#LN1538"><span class='Ref_to_Parameter'>nindexes</span></a><span class='Delimiter'>]; 
</span> 
        <a href="../../include/access/genam.h.html#LN130"><span class='Ref_to_Proto'>index_close</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1545"><span class='Ref_To_Local'>ind</span></a><span class='Delimiter'>, </span><a href="vacuum.c.html#LN1538"><span class='Ref_to_Parameter'>lockmode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1538"><span class='Ref_to_Parameter'>Irel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * vacuum_delay_point --- check for interrupts and cost-based delay. 
 * 
 * This should be called in each major loop of VACUUM processing, 
 * typically once per page processed. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1559"></a><span class='Declare_Function'>vacuum_delay_point</span><span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* Always check for interrupts */ 
</span>    <a href="../../include/miscadmin.h.html#LN99"><span class='Ref_to_Macro'>CHECK_FOR_INTERRUPTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Nap if appropriate */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../utils/init/globals.c.html#LN139"><span class='Ref_to_Global_Var'>VacuumCostActive</span></a> <span class='Operator'>&& !</span><a href="../utils/init/globals.c.html#LN28"><span class='Ref_to_Global_Var'>InterruptPending</span></a> <span class='Operator'>&& 
</span>        <a href="../utils/init/globals.c.html#LN138"><span class='Ref_to_Global_Var'>VacuumCostBalance</span></a> <span class='Operator'>&GT;= </span><a href="../utils/init/globals.c.html#LN131"><span class='Ref_to_Global_Var'>VacuumCostLimit</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1568"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>msec</span><span class='Delimiter'>; 
</span> 
        <a href="vacuum.c.html#LN1568"><span class='Ref_To_Local'>msec</span></a> <span class='Operator'>= </span><a href="../utils/init/globals.c.html#LN132"><span class='Ref_to_Global_Var'>VacuumCostDelay</span></a> <span class='Operator'>* </span><a href="../utils/init/globals.c.html#LN138"><span class='Ref_to_Global_Var'>VacuumCostBalance</span></a> <span class='Operator'>/ </span><a href="../utils/init/globals.c.html#LN131"><span class='Ref_to_Global_Var'>VacuumCostLimit</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="vacuum.c.html#LN1568"><span class='Ref_To_Local'>msec</span></a> <span class='Operator'>&GT; </span><a href="../utils/init/globals.c.html#LN132"><span class='Ref_to_Global_Var'>VacuumCostDelay</span></a> <span class='Operator'>* </span><span class='Number'>4</span><span class='Parentheses'>) 
</span>            <a href="vacuum.c.html#LN1568"><span class='Ref_To_Local'>msec</span></a> <span class='Operator'>= </span><a href="../utils/init/globals.c.html#LN132"><span class='Ref_to_Global_Var'>VacuumCostDelay</span></a> <span class='Operator'>* </span><span class='Number'>4</span><span class='Delimiter'>; 
</span> 
        <a href="../../port/pgsleep.c.html#LN45"><span class='Ref_to_Func'>pg_usleep</span></a><span class='Parentheses'>(</span><a href="vacuum.c.html#LN1568"><span class='Ref_To_Local'>msec</span></a> <span class='Operator'>* </span><span class='Number'>1000L</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../utils/init/globals.c.html#LN138"><span class='Ref_to_Global_Var'>VacuumCostBalance</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* update balance values for workers */ 
</span>        <a href="../../include/postmaster/autovacuum.h.html#LN64"><span class='Ref_to_Proto'>AutoVacuumUpdateDelay</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Might have gotten an interrupt while sleeping */ 
</span>        <a href="../../include/miscadmin.h.html#LN99"><span class='Ref_to_Macro'>CHECK_FOR_INTERRUPTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end vacuum_delay_point &raquo; </span> 
</pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>