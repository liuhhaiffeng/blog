<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\executor\execGrouping.c</title>
<LINK REL=StyleSheet HREF="../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\executor\execGrouping.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:38 2017
</td></tr>
<tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * execGrouping.c 
 *    executor utility routines for grouping, hashing, and aggregation 
 * 
 * Note: we currently assume that equality and hashing functions are not 
 * collation-sensitive, so the code in this file has no support for passing 
 * collation settings through from callers.  That may have to change someday. 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * 
 * IDENTIFICATION 
 *    src/backend/executor/execGrouping.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"access/hash.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/parallel.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"executor/executor.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"miscadmin.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/lsyscache.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/memutils.h"</span> 
 
<a name="LN27"></a><span class='Keyword'>static </span><a href="../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> <span class='Declare_Prototype'>TupleHashTableHash</span><span class='Parentheses'>(</span><span class='Control'>struct</span> tuplehash_hash <span class='Operator'>*</span><span class='Declare_Parameter'>tb</span><span class='Delimiter'>, </span><span class='Keyword'>const </span><a href="../../include/access/htup.h.html#LN26"><span class='Ref_to_Typedef'>MinimalTuple</span></a> <span class='Declare_Parameter'>tuple</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN28"></a><span class='Keyword'>static int</span>  <span class='Declare_Prototype'>TupleHashTableMatch</span><span class='Parentheses'>(</span><span class='Control'>struct</span> tuplehash_hash <span class='Operator'>*</span><span class='Declare_Parameter'>tb</span><span class='Delimiter'>, </span><span class='Keyword'>const </span><a href="../../include/access/htup.h.html#LN26"><span class='Ref_to_Typedef'>MinimalTuple</span></a> <span class='Declare_Parameter'>tuple1</span><span class='Delimiter'>, </span><span class='Keyword'>const </span><a href="../../include/access/htup.h.html#LN26"><span class='Ref_to_Typedef'>MinimalTuple</span></a> <span class='Declare_Parameter'>tuple2</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Define parameters for tuple hash table code generation. The interface is 
 * *also* declared in execnodes.h (to generate the types, which are externally 
 * visible). 
 */ 
</span><a name="LN35"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>SH_PREFIX</span> tuplehash 
<a name="LN36"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>SH_ELEMENT_TYPE</span> <a href="../../include/nodes/execnodes.h.html#LN563"><span class='Ref_to_Struct'>TupleHashEntryData</span></a> 
<a name="LN37"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>SH_KEY_TYPE</span> <a href="../../include/access/htup.h.html#LN26"><span class='Ref_to_Typedef'>MinimalTuple</span></a> 
<a name="LN38"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>SH_KEY</span> firstTuple 
<a name="LN39"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>SH_HASH_KEY</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>tb</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>key</span><span class='Parentheses'>) </span><a href="execGrouping.c.html#LN27"><span class='Ref_to_Proto'>TupleHashTableHash</span></a><span class='Parentheses'>(</span><a href="execGrouping.c.html#LN39"><span class='Ref_to_Parameter'>tb</span></a><span class='Delimiter'>, </span><a href="execGrouping.c.html#LN39"><span class='Ref_to_Parameter'>key</span></a><span class='Parentheses'>) 
</span><a name="LN40"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>SH_EQUAL</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>tb</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>a</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>b</span><span class='Parentheses'>) </span><a href="execGrouping.c.html#LN28"><span class='Ref_to_Proto'>TupleHashTableMatch</span></a><span class='Parentheses'>(</span><a href="execGrouping.c.html#LN40"><span class='Ref_to_Parameter'>tb</span></a><span class='Delimiter'>, </span><a href="execGrouping.c.html#LN40"><span class='Ref_to_Parameter'>a</span></a><span class='Delimiter'>, </span><a href="execGrouping.c.html#LN40"><span class='Ref_to_Parameter'>b</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span> 
<a name="LN41"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>SH_SCOPE</span> <span class='Keyword'>extern 
</span><a name="LN42"></a>#define <span class='Declare_Constant'>SH_STORE_HASH</span> 
<a name="LN43"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>SH_GET_HASH</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>tb</span><span class='Delimiter'>, </span><span class='Declare_Parameter'>a</span><span class='Parentheses'>) </span><a href="execGrouping.c.html#LN43"><span class='Ref_to_Parameter'>a</span></a><span class='Operator'>-&GT;</span>hash 
<a name="LN44"></a><span class='Keyword'>#define </span><span class='Declare_Constant'>SH_DEFINE</span> 
<span class='Keyword'>#include </span><span class='String'>"lib/simplehash.h"</span> 
 
 
<span class='Comment_Multi_Line'>/***************************************************************************** 
 *      Utility routines for grouping tuples together 
 *****************************************************************************/ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * execTuplesMatch 
 *      Return true if two tuples match in all the indicated fields. 
 * 
 * This actually implements SQL's notion of "not distinct".  Two nulls 
 * match, a null and a not-null don't match. 
 * 
 * slot1, slot2: the tuples to compare (must have same columns!) 
 * numCols: the number of attributes to be examined 
 * matchColIdx: array of attribute column numbers 
 * eqFunctions: array of fmgr lookup info for the equality functions to use 
 * evalContext: short-term memory context for executing the functions 
 * 
 * NB: evalContext is reset each time! 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN68"></a><span class='Declare_Function'>execTuplesMatch</span><span class='Parentheses'>(</span><a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>slot1</span><span class='Delimiter'>, 
</span><a name="LN69"></a>                <a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>slot2</span><span class='Delimiter'>, 
</span><a name="LN70"></a>                <span class='Keyword'>int </span><span class='Declare_Parameter'>numCols</span><span class='Delimiter'>, 
</span><a name="LN71"></a>                <a href="../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>matchColIdx</span><span class='Delimiter'>, 
</span><a name="LN72"></a>                <a href="../../include/fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>eqfunctions</span><span class='Delimiter'>, 
</span><a name="LN73"></a>                <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Parameter'>evalContext</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN75"></a>    <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldContext</span><span class='Delimiter'>; 
</span><a name="LN76"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span><a name="LN77"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Reset and switch into the temp context. */ 
</span>    <a href="../../include/utils/memutils.h.html#LN73"><span class='Ref_to_Proto'>MemoryContextReset</span></a><span class='Parentheses'>(</span><a href="execGrouping.c.html#LN73"><span class='Ref_to_Parameter'>evalContext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="execGrouping.c.html#LN75"><span class='Ref_To_Local'>oldContext</span></a> <span class='Operator'>= </span><a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="execGrouping.c.html#LN73"><span class='Ref_to_Parameter'>evalContext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We cannot report a match without checking all the fields, but we can 
     * report a non-match as soon as we find unequal fields.  So, start 
     * comparing at the last field (least significant sort key). That's the 
     * most likely to be different if we are dealing with sorted input. 
     */ 
</span>    <a href="execGrouping.c.html#LN76"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="execGrouping.c.html#LN77"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><a href="execGrouping.c.html#LN70"><span class='Ref_to_Parameter'>numCols</span></a><span class='Delimiter'>; </span><span class='Operator'>--</span><a href="execGrouping.c.html#LN77"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Delimiter'>;</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN93"></a>        <a href="../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a>  <span class='Declare_Local'>att</span> <span class='Operator'>= </span><a href="execGrouping.c.html#LN71"><span class='Ref_to_Parameter'>matchColIdx</span></a><span class='Delimiter'>[</span><a href="execGrouping.c.html#LN77"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span><a name="LN94"></a>        <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>attr1</span><span class='Delimiter'>, 
</span><a name="LN95"></a>                    <span class='Declare_Local'>attr2</span><span class='Delimiter'>; 
</span><a name="LN96"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>isNull1</span><span class='Delimiter'>, 
</span><a name="LN97"></a>                    <span class='Declare_Local'>isNull2</span><span class='Delimiter'>; 
</span> 
        <a href="execGrouping.c.html#LN94"><span class='Ref_To_Local'>attr1</span></a> <span class='Operator'>= </span><a href="../../include/executor/tuptable.h.html#LN167"><span class='Ref_to_Proto'>slot_getattr</span></a><span class='Parentheses'>(</span><a href="execGrouping.c.html#LN68"><span class='Ref_to_Parameter'>slot1</span></a><span class='Delimiter'>, </span><a href="execGrouping.c.html#LN93"><span class='Ref_To_Local'>att</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="execGrouping.c.html#LN96"><span class='Ref_To_Local'>isNull1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="execGrouping.c.html#LN95"><span class='Ref_To_Local'>attr2</span></a> <span class='Operator'>= </span><a href="../../include/executor/tuptable.h.html#LN167"><span class='Ref_to_Proto'>slot_getattr</span></a><span class='Parentheses'>(</span><a href="execGrouping.c.html#LN69"><span class='Ref_to_Parameter'>slot2</span></a><span class='Delimiter'>, </span><a href="execGrouping.c.html#LN93"><span class='Ref_To_Local'>att</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="execGrouping.c.html#LN97"><span class='Ref_To_Local'>isNull2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execGrouping.c.html#LN96"><span class='Ref_To_Local'>isNull1</span></a> <span class='Operator'>!= </span><a href="execGrouping.c.html#LN97"><span class='Ref_To_Local'>isNull2</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="execGrouping.c.html#LN76"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* one null and one not; they aren't equal */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execGrouping.c.html#LN96"><span class='Ref_To_Local'>isNull1</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* both are null, treat as equal */ 
</span> 
        <span class='Comment_Multi_Line'>/* Apply the type-specific equality function */ 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/postgres.h.html#LN398"><span class='Ref_to_Macro'>DatumGetBool</span></a><span class='Parentheses'>(</span><a href="../../include/fmgr.h.html#LN603"><span class='Ref_to_Macro'>FunctionCall2</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="execGrouping.c.html#LN72"><span class='Ref_to_Parameter'>eqfunctions</span></a><span class='Delimiter'>[</span><a href="execGrouping.c.html#LN77"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], 
</span>                                        <a href="execGrouping.c.html#LN94"><span class='Ref_To_Local'>attr1</span></a><span class='Delimiter'>, </span><a href="execGrouping.c.html#LN95"><span class='Ref_To_Local'>attr2</span></a><span class='Parentheses'>)))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="execGrouping.c.html#LN76"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* they aren't equal */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=numCols;--i&GT;=0; &raquo; </span> 
 
    <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="execGrouping.c.html#LN75"><span class='Ref_To_Local'>oldContext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="execGrouping.c.html#LN76"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end execTuplesMatch &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * execTuplesUnequal 
 *      Return true if two tuples are definitely unequal in the indicated 
 *      fields. 
 * 
 * Nulls are neither equal nor unequal to anything else.  A true result 
 * is obtained only if there are non-null fields that compare not-equal. 
 * 
 * Parameters are identical to execTuplesMatch. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN138"></a><span class='Declare_Function'>execTuplesUnequal</span><span class='Parentheses'>(</span><a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>slot1</span><span class='Delimiter'>, 
</span><a name="LN139"></a>                  <a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>slot2</span><span class='Delimiter'>, 
</span><a name="LN140"></a>                  <span class='Keyword'>int </span><span class='Declare_Parameter'>numCols</span><span class='Delimiter'>, 
</span><a name="LN141"></a>                  <a href="../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>matchColIdx</span><span class='Delimiter'>, 
</span><a name="LN142"></a>                  <a href="../../include/fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>eqfunctions</span><span class='Delimiter'>, 
</span><a name="LN143"></a>                  <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Parameter'>evalContext</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN145"></a>    <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldContext</span><span class='Delimiter'>; 
</span><a name="LN146"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span><a name="LN147"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Reset and switch into the temp context. */ 
</span>    <a href="../../include/utils/memutils.h.html#LN73"><span class='Ref_to_Proto'>MemoryContextReset</span></a><span class='Parentheses'>(</span><a href="execGrouping.c.html#LN143"><span class='Ref_to_Parameter'>evalContext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="execGrouping.c.html#LN145"><span class='Ref_To_Local'>oldContext</span></a> <span class='Operator'>= </span><a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="execGrouping.c.html#LN143"><span class='Ref_to_Parameter'>evalContext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We cannot report a match without checking all the fields, but we can 
     * report a non-match as soon as we find unequal fields.  So, start 
     * comparing at the last field (least significant sort key). That's the 
     * most likely to be different if we are dealing with sorted input. 
     */ 
</span>    <a href="execGrouping.c.html#LN146"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="execGrouping.c.html#LN147"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><a href="execGrouping.c.html#LN140"><span class='Ref_to_Parameter'>numCols</span></a><span class='Delimiter'>; </span><span class='Operator'>--</span><a href="execGrouping.c.html#LN147"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Delimiter'>;</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN163"></a>        <a href="../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a>  <span class='Declare_Local'>att</span> <span class='Operator'>= </span><a href="execGrouping.c.html#LN141"><span class='Ref_to_Parameter'>matchColIdx</span></a><span class='Delimiter'>[</span><a href="execGrouping.c.html#LN147"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span><a name="LN164"></a>        <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>attr1</span><span class='Delimiter'>, 
</span><a name="LN165"></a>                    <span class='Declare_Local'>attr2</span><span class='Delimiter'>; 
</span><a name="LN166"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>isNull1</span><span class='Delimiter'>, 
</span><a name="LN167"></a>                    <span class='Declare_Local'>isNull2</span><span class='Delimiter'>; 
</span> 
        <a href="execGrouping.c.html#LN164"><span class='Ref_To_Local'>attr1</span></a> <span class='Operator'>= </span><a href="../../include/executor/tuptable.h.html#LN167"><span class='Ref_to_Proto'>slot_getattr</span></a><span class='Parentheses'>(</span><a href="execGrouping.c.html#LN138"><span class='Ref_to_Parameter'>slot1</span></a><span class='Delimiter'>, </span><a href="execGrouping.c.html#LN163"><span class='Ref_To_Local'>att</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="execGrouping.c.html#LN166"><span class='Ref_To_Local'>isNull1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execGrouping.c.html#LN166"><span class='Ref_To_Local'>isNull1</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* can't prove anything here */ 
</span> 
        <a href="execGrouping.c.html#LN165"><span class='Ref_To_Local'>attr2</span></a> <span class='Operator'>= </span><a href="../../include/executor/tuptable.h.html#LN167"><span class='Ref_to_Proto'>slot_getattr</span></a><span class='Parentheses'>(</span><a href="execGrouping.c.html#LN139"><span class='Ref_to_Parameter'>slot2</span></a><span class='Delimiter'>, </span><a href="execGrouping.c.html#LN163"><span class='Ref_To_Local'>att</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="execGrouping.c.html#LN167"><span class='Ref_To_Local'>isNull2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execGrouping.c.html#LN167"><span class='Ref_To_Local'>isNull2</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* can't prove anything here */ 
</span> 
        <span class='Comment_Multi_Line'>/* Apply the type-specific equality function */ 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/postgres.h.html#LN398"><span class='Ref_to_Macro'>DatumGetBool</span></a><span class='Parentheses'>(</span><a href="../../include/fmgr.h.html#LN603"><span class='Ref_to_Macro'>FunctionCall2</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="execGrouping.c.html#LN142"><span class='Ref_to_Parameter'>eqfunctions</span></a><span class='Delimiter'>[</span><a href="execGrouping.c.html#LN147"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], 
</span>                                        <a href="execGrouping.c.html#LN164"><span class='Ref_To_Local'>attr1</span></a><span class='Delimiter'>, </span><a href="execGrouping.c.html#LN165"><span class='Ref_To_Local'>attr2</span></a><span class='Parentheses'>)))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="execGrouping.c.html#LN146"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* they are unequal */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=numCols;--i&GT;=0; &raquo; </span> 
 
    <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="execGrouping.c.html#LN145"><span class='Ref_To_Local'>oldContext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="execGrouping.c.html#LN146"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end execTuplesUnequal &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * execTuplesMatchPrepare 
 *      Look up the equality functions needed for execTuplesMatch or 
 *      execTuplesUnequal, given an array of equality operator OIDs. 
 * 
 * The result is a palloc'd array. 
 */ 
</span><a href="../../include/fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a> <span class='Operator'>* 
</span><a name="LN203"></a><span class='Declare_Function'>execTuplesMatchPrepare</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>numCols</span><span class='Delimiter'>, 
</span><a name="LN204"></a>                       <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>eqOperators</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN206"></a>    <a href="../../include/fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>eqFunctions</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="execGrouping.c.html#LN203"><span class='Ref_to_Parameter'>numCols</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span><a name="LN207"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="execGrouping.c.html#LN207"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="execGrouping.c.html#LN207"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="execGrouping.c.html#LN203"><span class='Ref_to_Parameter'>numCols</span></a><span class='Delimiter'>; </span><a href="execGrouping.c.html#LN207"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN211"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>eq_opr</span> <span class='Operator'>= </span><a href="execGrouping.c.html#LN204"><span class='Ref_to_Parameter'>eqOperators</span></a><span class='Delimiter'>[</span><a href="execGrouping.c.html#LN207"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span><a name="LN212"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>eq_function</span><span class='Delimiter'>; 
</span> 
        <a href="execGrouping.c.html#LN212"><span class='Ref_To_Local'>eq_function</span></a> <span class='Operator'>= </span><a href="../../include/utils/lsyscache.h.html#LN98"><span class='Ref_to_Proto'>get_opcode</span></a><span class='Parentheses'>(</span><a href="execGrouping.c.html#LN211"><span class='Ref_To_Local'>eq_opr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/fmgr.h.html#LN92"><span class='Ref_to_Proto'>fmgr_info</span></a><span class='Parentheses'>(</span><a href="execGrouping.c.html#LN212"><span class='Ref_To_Local'>eq_function</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="execGrouping.c.html#LN206"><span class='Ref_To_Local'>eqFunctions</span></a><span class='Delimiter'>[</span><a href="execGrouping.c.html#LN207"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="execGrouping.c.html#LN206"><span class='Ref_To_Local'>eqFunctions</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * execTuplesHashPrepare 
 *      Look up the equality and hashing functions needed for a TupleHashTable. 
 * 
 * This is similar to execTuplesMatchPrepare, but we also need to find the 
 * hash functions associated with the equality operators.  *eqFunctions and 
 * *hashFunctions receive the palloc'd result arrays. 
 * 
 * Note: we expect that the given operators are not cross-type comparisons. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN232"></a><span class='Declare_Function'>execTuplesHashPrepare</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>numCols</span><span class='Delimiter'>, 
</span><a name="LN233"></a>                      <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>eqOperators</span><span class='Delimiter'>, 
</span><a name="LN234"></a>                      <a href="../../include/fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>eqFunctions</span><span class='Delimiter'>, 
</span><a name="LN235"></a>                      <a href="../../include/fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>hashFunctions</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN237"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Operator'>*</span><a href="execGrouping.c.html#LN234"><span class='Ref_to_Parameter'>eqFunctions</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="execGrouping.c.html#LN232"><span class='Ref_to_Parameter'>numCols</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="execGrouping.c.html#LN235"><span class='Ref_to_Parameter'>hashFunctions</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="execGrouping.c.html#LN232"><span class='Ref_to_Parameter'>numCols</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="execGrouping.c.html#LN237"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="execGrouping.c.html#LN237"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="execGrouping.c.html#LN232"><span class='Ref_to_Parameter'>numCols</span></a><span class='Delimiter'>; </span><a href="execGrouping.c.html#LN237"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN244"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>eq_opr</span> <span class='Operator'>= </span><a href="execGrouping.c.html#LN233"><span class='Ref_to_Parameter'>eqOperators</span></a><span class='Delimiter'>[</span><a href="execGrouping.c.html#LN237"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span><a name="LN245"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>eq_function</span><span class='Delimiter'>; 
</span><a name="LN246"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>left_hash_function</span><span class='Delimiter'>; 
</span><a name="LN247"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>right_hash_function</span><span class='Delimiter'>; 
</span> 
        <a href="execGrouping.c.html#LN245"><span class='Ref_To_Local'>eq_function</span></a> <span class='Operator'>= </span><a href="../../include/utils/lsyscache.h.html#LN98"><span class='Ref_to_Proto'>get_opcode</span></a><span class='Parentheses'>(</span><a href="execGrouping.c.html#LN244"><span class='Ref_To_Local'>eq_opr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/utils/lsyscache.h.html#LN79"><span class='Ref_to_Proto'>get_op_hash_functions</span></a><span class='Parentheses'>(</span><a href="execGrouping.c.html#LN244"><span class='Ref_To_Local'>eq_opr</span></a><span class='Delimiter'>, 
</span>                                   <span class='Operator'>&</span><a href="execGrouping.c.html#LN246"><span class='Ref_To_Local'>left_hash_function</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="execGrouping.c.html#LN247"><span class='Ref_To_Local'>right_hash_function</span></a><span class='Parentheses'>))</span> 
            <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"could not find hash function for hash operator %u"</span><span class='Delimiter'>, 
</span>                 <a href="execGrouping.c.html#LN244"><span class='Ref_To_Local'>eq_opr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* We're not supporting cross-type cases here */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="execGrouping.c.html#LN246"><span class='Ref_To_Local'>left_hash_function</span></a> <span class='Operator'>== </span><a href="execGrouping.c.html#LN247"><span class='Ref_To_Local'>right_hash_function</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/fmgr.h.html#LN92"><span class='Ref_to_Proto'>fmgr_info</span></a><span class='Parentheses'>(</span><a href="execGrouping.c.html#LN245"><span class='Ref_To_Local'>eq_function</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="execGrouping.c.html#LN234"><span class='Ref_to_Parameter'>eqFunctions</span></a><span class='Parentheses'>)</span><span class='Delimiter'>[</span><a href="execGrouping.c.html#LN237"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/fmgr.h.html#LN92"><span class='Ref_to_Proto'>fmgr_info</span></a><span class='Parentheses'>(</span><a href="execGrouping.c.html#LN247"><span class='Ref_To_Local'>right_hash_function</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="execGrouping.c.html#LN235"><span class='Ref_to_Parameter'>hashFunctions</span></a><span class='Parentheses'>)</span><span class='Delimiter'>[</span><a href="execGrouping.c.html#LN237"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end execTuplesHashPrepare &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/***************************************************************************** 
 *      Utility routines for all-in-memory hash tables 
 * 
 * These routines build hash tables for grouping tuples together (eg, for 
 * hash aggregation).  There is one entry for each not-distinct set of tuples 
 * presented. 
 *****************************************************************************/ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Construct an empty TupleHashTable 
 * 
 *  numCols, keyColIdx: identify the tuple fields to use as lookup key 
 *  eqfunctions: equality comparison functions to use 
 *  hashfunctions: datatype-specific hashing functions to use 
 *  nbuckets: initial estimate of hashtable size 
 *  additionalsize: size of data stored in -&GT;additional 
 *  tablecxt: memory context in which to store table and table entries 
 *  tempcxt: short-lived context for evaluation hash and comparison functions 
 * 
 * The function arrays may be made with execTuplesHashPrepare().  Note they 
 * are not cross-type functions, but expect to see the table datatype(s) 
 * on both sides. 
 * 
 * Note that keyColIdx, eqfunctions, and hashfunctions must be allocated in 
 * storage that will live as long as the hashtable does. 
 */ 
</span><a href="../../include/nodes/execnodes.h.html#LN561"><span class='Ref_to_Typedef'>TupleHashTable</span></a> 
<a name="LN289"></a><span class='Declare_Function'>BuildTupleHashTable</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>numCols</span><span class='Delimiter'>, </span><a href="../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>keyColIdx</span><span class='Delimiter'>, 
</span><a name="LN290"></a>                    <a href="../../include/fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>eqfunctions</span><span class='Delimiter'>, 
</span><a name="LN291"></a>                    <a href="../../include/fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>hashfunctions</span><span class='Delimiter'>, 
</span><a name="LN292"></a>                    <span class='Keyword'>long </span><span class='Declare_Parameter'>nbuckets</span><span class='Delimiter'>, </span><a href="../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a> <span class='Declare_Parameter'>additionalsize</span><span class='Delimiter'>, 
</span><a name="LN293"></a>                    <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Parameter'>tablecxt</span><span class='Delimiter'>, </span><a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Parameter'>tempcxt</span><span class='Delimiter'>, 
</span><a name="LN294"></a>                    <span class='Keyword'>bool </span><span class='Declare_Parameter'>use_variable_hash_iv</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN296"></a>    <a href="../../include/nodes/execnodes.h.html#LN561"><span class='Ref_to_Typedef'>TupleHashTable</span></a> <span class='Declare_Local'>hashtable</span><span class='Delimiter'>; 
</span><a name="LN297"></a>    <a href="../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a>        <span class='Declare_Local'>entrysize</span> <span class='Operator'>= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN563"><span class='Ref_to_Struct'>TupleHashEntryData</span></a><span class='Parentheses'>) </span><span class='Operator'>+ </span><a href="execGrouping.c.html#LN292"><span class='Ref_to_Parameter'>additionalsize</span></a><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="execGrouping.c.html#LN292"><span class='Ref_to_Parameter'>nbuckets</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Limit initial table size request to not more than work_mem */ 
</span>    <a href="execGrouping.c.html#LN292"><span class='Ref_to_Parameter'>nbuckets</span></a> <span class='Operator'>= </span><a href="../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN11"><span class='Ref_to_Macro'>Min</span></a><span class='Parentheses'>(</span><a href="execGrouping.c.html#LN292"><span class='Ref_to_Parameter'>nbuckets</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><span class='Keyword'>long</span><span class='Parentheses'>)</span> <span class='Parentheses'>((</span><a href="../utils/init/globals.c.html#LN112"><span class='Ref_to_Global_Var'>work_mem</span></a> <span class='Operator'>* </span><span class='Number'>1024L</span><span class='Parentheses'>) </span><span class='Operator'>/ </span><a href="execGrouping.c.html#LN297"><span class='Ref_To_Local'>entrysize</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="execGrouping.c.html#LN296"><span class='Ref_To_Local'>hashtable</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN561"><span class='Ref_to_Typedef'>TupleHashTable</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/utils/palloc.h.html#LN70"><span class='Ref_to_Proto'>MemoryContextAlloc</span></a><span class='Parentheses'>(</span><a href="execGrouping.c.html#LN293"><span class='Ref_to_Parameter'>tablecxt</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN579"><span class='Ref_to_Struct'>TupleHashTableData</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="execGrouping.c.html#LN296"><span class='Ref_To_Local'>hashtable</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN582"><span class='Ref_to_Member'>numCols</span></a> <span class='Operator'>= </span><a href="execGrouping.c.html#LN289"><span class='Ref_to_Parameter'>numCols</span></a><span class='Delimiter'>; 
</span>    <a href="execGrouping.c.html#LN296"><span class='Ref_To_Local'>hashtable</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN583"><span class='Ref_to_Member'>keyColIdx</span></a> <span class='Operator'>= </span><a href="execGrouping.c.html#LN289"><span class='Ref_to_Parameter'>keyColIdx</span></a><span class='Delimiter'>; 
</span>    <a href="execGrouping.c.html#LN296"><span class='Ref_To_Local'>hashtable</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN584"><span class='Ref_to_Member'>tab_hash_funcs</span></a> <span class='Operator'>= </span><a href="execGrouping.c.html#LN291"><span class='Ref_to_Parameter'>hashfunctions</span></a><span class='Delimiter'>; 
</span>    <a href="execGrouping.c.html#LN296"><span class='Ref_To_Local'>hashtable</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN585"><span class='Ref_to_Member'>tab_eq_funcs</span></a> <span class='Operator'>= </span><a href="execGrouping.c.html#LN290"><span class='Ref_to_Parameter'>eqfunctions</span></a><span class='Delimiter'>; 
</span>    <a href="execGrouping.c.html#LN296"><span class='Ref_To_Local'>hashtable</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN586"><span class='Ref_to_Member'>tablecxt</span></a> <span class='Operator'>= </span><a href="execGrouping.c.html#LN293"><span class='Ref_to_Parameter'>tablecxt</span></a><span class='Delimiter'>; 
</span>    <a href="execGrouping.c.html#LN296"><span class='Ref_To_Local'>hashtable</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN587"><span class='Ref_to_Member'>tempcxt</span></a> <span class='Operator'>= </span><a href="execGrouping.c.html#LN293"><span class='Ref_to_Parameter'>tempcxt</span></a><span class='Delimiter'>; 
</span>    <a href="execGrouping.c.html#LN296"><span class='Ref_To_Local'>hashtable</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN588"><span class='Ref_to_Member'>entrysize</span></a> <span class='Operator'>= </span><a href="execGrouping.c.html#LN297"><span class='Ref_To_Local'>entrysize</span></a><span class='Delimiter'>; 
</span>    <a href="execGrouping.c.html#LN296"><span class='Ref_To_Local'>hashtable</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN589"><span class='Ref_to_Member'>tableslot</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* will be made on first lookup */ 
</span>    <a href="execGrouping.c.html#LN296"><span class='Ref_To_Local'>hashtable</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN591"><span class='Ref_to_Member'>inputslot</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="execGrouping.c.html#LN296"><span class='Ref_To_Local'>hashtable</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN592"><span class='Ref_to_Member'>in_hash_funcs</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="execGrouping.c.html#LN296"><span class='Ref_To_Local'>hashtable</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN593"><span class='Ref_to_Member'>cur_eq_funcs</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If parallelism is in use, even if the master backend is performing the 
     * scan itself, we don't want to create the hashtable exactly the same way 
     * in all workers. As hashtables are iterated over in keyspace-order, 
     * doing so in all processes in the same way is likely to lead to 
     * "unbalanced" hashtables when the table size initially is 
     * underestimated. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execGrouping.c.html#LN294"><span class='Ref_to_Parameter'>use_variable_hash_iv</span></a><span class='Parentheses'>) 
</span>        <a href="execGrouping.c.html#LN296"><span class='Ref_To_Local'>hashtable</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN594"><span class='Ref_to_Member'>hash_iv</span></a> <span class='Operator'>= </span><a href="../../include/access/hash.h.html#LN326"><span class='Ref_to_Proto'>hash_uint32</span></a><span class='Parentheses'>(</span><a href="../access/transam/parallel.c.html#LN93"><span class='Ref_to_Global_Var'>ParallelWorkerNumber</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="execGrouping.c.html#LN296"><span class='Ref_To_Local'>hashtable</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN594"><span class='Ref_to_Member'>hash_iv</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <a href="execGrouping.c.html#LN296"><span class='Ref_To_Local'>hashtable</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN581"><span class='Ref_to_Member'>hashtab</span></a> <span class='Operator'>= </span>tuplehash_create<span class='Parentheses'>(</span><a href="execGrouping.c.html#LN293"><span class='Ref_to_Parameter'>tablecxt</span></a><span class='Delimiter'>, </span><a href="execGrouping.c.html#LN292"><span class='Ref_to_Parameter'>nbuckets</span></a><span class='Delimiter'>, </span><a href="execGrouping.c.html#LN296"><span class='Ref_To_Local'>hashtable</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="execGrouping.c.html#LN296"><span class='Ref_To_Local'>hashtable</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end BuildTupleHashTable &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Find or create a hashtable entry for the tuple group containing the 
 * given tuple.  The tuple must be the same type as the hashtable entries. 
 * 
 * If isnew is NULL, we do not create new entries; we return NULL if no 
 * match is found. 
 * 
 * If isnew isn't NULL, then a new entry is created if no existing entry 
 * matches.  On return, *isnew is true if the entry is newly created, 
 * false if it existed already.  -&GT;additional_data in the new entry has 
 * been zeroed. 
 */ 
</span><a href="../../include/nodes/execnodes.h.html#LN560"><span class='Ref_to_Typedef'>TupleHashEntry</span></a> 
<a name="LN350"></a><span class='Declare_Function'>LookupTupleHashEntry</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN561"><span class='Ref_to_Typedef'>TupleHashTable</span></a> <span class='Declare_Parameter'>hashtable</span><span class='Delimiter'>, </span><a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>slot</span><span class='Delimiter'>, 
</span><a name="LN351"></a>                     <span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>isnew</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN353"></a>    <a href="../../include/nodes/execnodes.h.html#LN563"><span class='Ref_to_Struct'>TupleHashEntryData</span></a> <span class='Operator'>*</span><span class='Declare_Local'>entry</span><span class='Delimiter'>; 
</span><a name="LN354"></a>    <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldContext</span><span class='Delimiter'>; 
</span><a name="LN355"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>found</span><span class='Delimiter'>; 
</span><a name="LN356"></a>    <a href="../../include/access/htup.h.html#LN26"><span class='Ref_to_Typedef'>MinimalTuple</span></a> <span class='Declare_Local'>key</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* If first time through, clone the input slot to make table slot */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execGrouping.c.html#LN350"><span class='Ref_to_Parameter'>hashtable</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN589"><span class='Ref_to_Member'>tableslot</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN361"></a>        <a href="../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a>   <span class='Declare_Local'>tupdesc</span><span class='Delimiter'>; 
</span> 
        <a href="execGrouping.c.html#LN354"><span class='Ref_To_Local'>oldContext</span></a> <span class='Operator'>= </span><a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="execGrouping.c.html#LN350"><span class='Ref_to_Parameter'>hashtable</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN586"><span class='Ref_to_Member'>tablecxt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We copy the input tuple descriptor just for safety --- we assume 
         * all input tuples will have equivalent descriptors. 
         */ 
</span>        <a href="execGrouping.c.html#LN361"><span class='Ref_To_Local'>tupdesc</span></a> <span class='Operator'>= </span><a href="../../include/access/tupdesc.h.html#LN88"><span class='Ref_to_Proto'>CreateTupleDescCopy</span></a><span class='Parentheses'>(</span><a href="execGrouping.c.html#LN350"><span class='Ref_to_Parameter'>slot</span></a><span class='Operator'>-&GT;</span><a href="../../include/executor/tuptable.h.html#LN120"><span class='Ref_to_Member'>tts_tupleDescriptor</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="execGrouping.c.html#LN350"><span class='Ref_to_Parameter'>hashtable</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN589"><span class='Ref_to_Member'>tableslot</span></a> <span class='Operator'>= </span><a href="../../include/executor/tuptable.h.html#LN144"><span class='Ref_to_Proto'>MakeSingleTupleTableSlot</span></a><span class='Parentheses'>(</span><a href="execGrouping.c.html#LN361"><span class='Ref_To_Local'>tupdesc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="execGrouping.c.html#LN354"><span class='Ref_To_Local'>oldContext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Need to run the hash functions in short-lived context */ 
</span>    <a href="execGrouping.c.html#LN354"><span class='Ref_To_Local'>oldContext</span></a> <span class='Operator'>= </span><a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="execGrouping.c.html#LN350"><span class='Ref_to_Parameter'>hashtable</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN587"><span class='Ref_to_Member'>tempcxt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* set up data needed by hash and match functions */ 
</span>    <a href="execGrouping.c.html#LN350"><span class='Ref_to_Parameter'>hashtable</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN591"><span class='Ref_to_Member'>inputslot</span></a> <span class='Operator'>= </span><a href="execGrouping.c.html#LN350"><span class='Ref_to_Parameter'>slot</span></a><span class='Delimiter'>; 
</span>    <a href="execGrouping.c.html#LN350"><span class='Ref_to_Parameter'>hashtable</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN592"><span class='Ref_to_Member'>in_hash_funcs</span></a> <span class='Operator'>= </span><a href="execGrouping.c.html#LN350"><span class='Ref_to_Parameter'>hashtable</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN584"><span class='Ref_to_Member'>tab_hash_funcs</span></a><span class='Delimiter'>; 
</span>    <a href="execGrouping.c.html#LN350"><span class='Ref_to_Parameter'>hashtable</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN593"><span class='Ref_to_Member'>cur_eq_funcs</span></a> <span class='Operator'>= </span><a href="execGrouping.c.html#LN350"><span class='Ref_to_Parameter'>hashtable</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN585"><span class='Ref_to_Member'>tab_eq_funcs</span></a><span class='Delimiter'>; 
</span> 
    <a href="execGrouping.c.html#LN356"><span class='Ref_To_Local'>key</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>;</span>                 <span class='Comment_Single_Line'>/* flag to reference inputslot */ 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execGrouping.c.html#LN351"><span class='Ref_to_Parameter'>isnew</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="execGrouping.c.html#LN353"><span class='Ref_To_Local'>entry</span></a> <span class='Operator'>= </span>tuplehash_insert<span class='Parentheses'>(</span><a href="execGrouping.c.html#LN350"><span class='Ref_to_Parameter'>hashtable</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN581"><span class='Ref_to_Member'>hashtab</span></a><span class='Delimiter'>, </span><a href="execGrouping.c.html#LN356"><span class='Ref_To_Local'>key</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="execGrouping.c.html#LN355"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execGrouping.c.html#LN355"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* found pre-existing entry */ 
</span>            <span class='Operator'>*</span><a href="execGrouping.c.html#LN351"><span class='Ref_to_Parameter'>isnew</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* created new entry */ 
</span>            <span class='Operator'>*</span><a href="execGrouping.c.html#LN351"><span class='Ref_to_Parameter'>isnew</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* zero caller data */ 
</span>            <a href="execGrouping.c.html#LN353"><span class='Ref_To_Local'>entry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN566"><span class='Ref_to_Member'>additional</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>            <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="execGrouping.c.html#LN350"><span class='Ref_to_Parameter'>hashtable</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN586"><span class='Ref_to_Member'>tablecxt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* Copy the first tuple into the table context */ 
</span>            <a href="execGrouping.c.html#LN353"><span class='Ref_To_Local'>entry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN565"><span class='Ref_to_Member'>firstTuple</span></a> <span class='Operator'>= </span><a href="../../include/executor/tuptable.h.html#LN158"><span class='Ref_to_Proto'>ExecCopySlotMinimalTuple</span></a><span class='Parentheses'>(</span><a href="execGrouping.c.html#LN350"><span class='Ref_to_Parameter'>slot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if isnew &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="execGrouping.c.html#LN353"><span class='Ref_To_Local'>entry</span></a> <span class='Operator'>= </span>tuplehash_lookup<span class='Parentheses'>(</span><a href="execGrouping.c.html#LN350"><span class='Ref_to_Parameter'>hashtable</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN581"><span class='Ref_to_Member'>hashtab</span></a><span class='Delimiter'>, </span><a href="execGrouping.c.html#LN356"><span class='Ref_To_Local'>key</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="execGrouping.c.html#LN354"><span class='Ref_To_Local'>oldContext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="execGrouping.c.html#LN353"><span class='Ref_To_Local'>entry</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end LookupTupleHashEntry &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Search for a hashtable entry matching the given tuple.  No entry is 
 * created if there's not a match.  This is similar to the non-creating 
 * case of LookupTupleHashEntry, except that it supports cross-type 
 * comparisons, in which the given tuple is not of the same type as the 
 * table entries.  The caller must provide the hash functions to use for 
 * the input tuple, as well as the equality functions, since these may be 
 * different from the table's internal functions. 
 */ 
</span><a href="../../include/nodes/execnodes.h.html#LN560"><span class='Ref_to_Typedef'>TupleHashEntry</span></a> 
<a name="LN424"></a><span class='Declare_Function'>FindTupleHashEntry</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN561"><span class='Ref_to_Typedef'>TupleHashTable</span></a> <span class='Declare_Parameter'>hashtable</span><span class='Delimiter'>, </span><a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>slot</span><span class='Delimiter'>, 
</span><a name="LN425"></a>                   <a href="../../include/fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>eqfunctions</span><span class='Delimiter'>, 
</span><a name="LN426"></a>                   <a href="../../include/fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>hashfunctions</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN428"></a>    <a href="../../include/nodes/execnodes.h.html#LN560"><span class='Ref_to_Typedef'>TupleHashEntry</span></a> <span class='Declare_Local'>entry</span><span class='Delimiter'>; 
</span><a name="LN429"></a>    <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldContext</span><span class='Delimiter'>; 
</span><a name="LN430"></a>    <a href="../../include/access/htup.h.html#LN26"><span class='Ref_to_Typedef'>MinimalTuple</span></a> <span class='Declare_Local'>key</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Need to run the hash functions in short-lived context */ 
</span>    <a href="execGrouping.c.html#LN429"><span class='Ref_To_Local'>oldContext</span></a> <span class='Operator'>= </span><a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="execGrouping.c.html#LN424"><span class='Ref_to_Parameter'>hashtable</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN587"><span class='Ref_to_Member'>tempcxt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Set up data needed by hash and match functions */ 
</span>    <a href="execGrouping.c.html#LN424"><span class='Ref_to_Parameter'>hashtable</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN591"><span class='Ref_to_Member'>inputslot</span></a> <span class='Operator'>= </span><a href="execGrouping.c.html#LN424"><span class='Ref_to_Parameter'>slot</span></a><span class='Delimiter'>; 
</span>    <a href="execGrouping.c.html#LN424"><span class='Ref_to_Parameter'>hashtable</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN592"><span class='Ref_to_Member'>in_hash_funcs</span></a> <span class='Operator'>= </span><a href="execGrouping.c.html#LN426"><span class='Ref_to_Parameter'>hashfunctions</span></a><span class='Delimiter'>; 
</span>    <a href="execGrouping.c.html#LN424"><span class='Ref_to_Parameter'>hashtable</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN593"><span class='Ref_to_Member'>cur_eq_funcs</span></a> <span class='Operator'>= </span><a href="execGrouping.c.html#LN425"><span class='Ref_to_Parameter'>eqfunctions</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Search the hash table */ 
</span>    <a href="execGrouping.c.html#LN430"><span class='Ref_To_Local'>key</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>;</span>                 <span class='Comment_Single_Line'>/* flag to reference inputslot */ 
</span>    <a href="execGrouping.c.html#LN428"><span class='Ref_To_Local'>entry</span></a> <span class='Operator'>= </span>tuplehash_lookup<span class='Parentheses'>(</span><a href="execGrouping.c.html#LN424"><span class='Ref_to_Parameter'>hashtable</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN581"><span class='Ref_to_Member'>hashtab</span></a><span class='Delimiter'>, </span><a href="execGrouping.c.html#LN430"><span class='Ref_To_Local'>key</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="execGrouping.c.html#LN429"><span class='Ref_To_Local'>oldContext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="execGrouping.c.html#LN428"><span class='Ref_To_Local'>entry</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end FindTupleHashEntry &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Compute the hash value for a tuple 
 * 
 * The passed-in key is a pointer to TupleHashEntryData.  In an actual hash 
 * table entry, the firstTuple field points to a tuple (in MinimalTuple 
 * format).  LookupTupleHashEntry sets up a dummy TupleHashEntryData with a 
 * NULL firstTuple field --- that cues us to look at the inputslot instead. 
 * This convention avoids the need to materialize virtual input tuples unless 
 * they actually need to get copied into the table. 
 * 
 * Also, the caller must select an appropriate memory context for running 
 * the hash functions. (dynahash.c doesn't change CurrentMemoryContext.) 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a> 
<a name="LN462"></a><span class='Declare_Function'>TupleHashTableHash</span><span class='Parentheses'>(</span><span class='Control'>struct</span> tuplehash_hash <span class='Operator'>*</span><span class='Declare_Parameter'>tb</span><span class='Delimiter'>, </span><span class='Keyword'>const </span><a href="../../include/access/htup.h.html#LN26"><span class='Ref_to_Typedef'>MinimalTuple</span></a> <span class='Declare_Parameter'>tuple</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN464"></a>    <a href="../../include/nodes/execnodes.h.html#LN561"><span class='Ref_to_Typedef'>TupleHashTable</span></a> <span class='Declare_Local'>hashtable</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN561"><span class='Ref_to_Typedef'>TupleHashTable</span></a><span class='Parentheses'>) </span><a href="execGrouping.c.html#LN462"><span class='Ref_to_Parameter'>tb</span></a><span class='Operator'>-&GT;</span>private_data<span class='Delimiter'>; 
</span><a name="LN465"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numCols</span> <span class='Operator'>= </span><a href="execGrouping.c.html#LN464"><span class='Ref_To_Local'>hashtable</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN582"><span class='Ref_to_Member'>numCols</span></a><span class='Delimiter'>; 
</span><a name="LN466"></a>    <a href="../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a> <span class='Operator'>*</span><span class='Declare_Local'>keyColIdx</span> <span class='Operator'>= </span><a href="execGrouping.c.html#LN464"><span class='Ref_To_Local'>hashtable</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN583"><span class='Ref_to_Member'>keyColIdx</span></a><span class='Delimiter'>; 
</span><a name="LN467"></a>    <a href="../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>hashkey</span> <span class='Operator'>= </span><a href="execGrouping.c.html#LN464"><span class='Ref_To_Local'>hashtable</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN594"><span class='Ref_to_Member'>hash_iv</span></a><span class='Delimiter'>; 
</span><a name="LN468"></a>    <a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Local'>slot</span><span class='Delimiter'>; 
</span><a name="LN469"></a>    <a href="../../include/fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>hashfunctions</span><span class='Delimiter'>; 
</span><a name="LN470"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execGrouping.c.html#LN462"><span class='Ref_to_Parameter'>tuple</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Process the current input tuple for the table */ 
</span>        <a href="execGrouping.c.html#LN468"><span class='Ref_To_Local'>slot</span></a> <span class='Operator'>= </span><a href="execGrouping.c.html#LN464"><span class='Ref_To_Local'>hashtable</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN591"><span class='Ref_to_Member'>inputslot</span></a><span class='Delimiter'>; 
</span>        <a href="execGrouping.c.html#LN469"><span class='Ref_To_Local'>hashfunctions</span></a> <span class='Operator'>= </span><a href="execGrouping.c.html#LN464"><span class='Ref_To_Local'>hashtable</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN592"><span class='Ref_to_Member'>in_hash_funcs</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Process a tuple already stored in the table. 
         * 
         * (this case never actually occurs due to the way simplehash.h is 
         * used, as the hash-value is stored in the entries) 
         */ 
</span>        <a href="execGrouping.c.html#LN468"><span class='Ref_To_Local'>slot</span></a> <span class='Operator'>= </span><a href="execGrouping.c.html#LN464"><span class='Ref_To_Local'>hashtable</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN589"><span class='Ref_to_Member'>tableslot</span></a><span class='Delimiter'>; 
</span>        <a href="../../include/executor/tuptable.h.html#LN151"><span class='Ref_to_Proto'>ExecStoreMinimalTuple</span></a><span class='Parentheses'>(</span><a href="execGrouping.c.html#LN462"><span class='Ref_to_Parameter'>tuple</span></a><span class='Delimiter'>, </span><a href="execGrouping.c.html#LN468"><span class='Ref_To_Local'>slot</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="execGrouping.c.html#LN469"><span class='Ref_To_Local'>hashfunctions</span></a> <span class='Operator'>= </span><a href="execGrouping.c.html#LN464"><span class='Ref_To_Local'>hashtable</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN584"><span class='Ref_to_Member'>tab_hash_funcs</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="execGrouping.c.html#LN470"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="execGrouping.c.html#LN470"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="execGrouping.c.html#LN465"><span class='Ref_To_Local'>numCols</span></a><span class='Delimiter'>; </span><a href="execGrouping.c.html#LN470"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN493"></a>        <a href="../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a>  <span class='Declare_Local'>att</span> <span class='Operator'>= </span><a href="execGrouping.c.html#LN466"><span class='Ref_To_Local'>keyColIdx</span></a><span class='Delimiter'>[</span><a href="execGrouping.c.html#LN470"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span><a name="LN494"></a>        <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>attr</span><span class='Delimiter'>; 
</span><a name="LN495"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>isNull</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* rotate hashkey left 1 bit at each step */ 
</span>        <a href="execGrouping.c.html#LN467"><span class='Ref_To_Local'>hashkey</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="execGrouping.c.html#LN467"><span class='Ref_To_Local'>hashkey</span></a> <span class='Operator'>&LT;&LT; </span><span class='Number'>1</span><span class='Parentheses'>) </span><span class='Operator'>| </span><span class='Parentheses'>((</span><a href="execGrouping.c.html#LN467"><span class='Ref_To_Local'>hashkey</span></a> <span class='Operator'>& </span><span class='Number'>0x80000000</span><span class='Parentheses'>) </span><span class='Operator'>? </span><span class='Number'>1</span> <span class='Operator'>: </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="execGrouping.c.html#LN494"><span class='Ref_To_Local'>attr</span></a> <span class='Operator'>= </span><a href="../../include/executor/tuptable.h.html#LN167"><span class='Ref_to_Proto'>slot_getattr</span></a><span class='Parentheses'>(</span><a href="execGrouping.c.html#LN468"><span class='Ref_To_Local'>slot</span></a><span class='Delimiter'>, </span><a href="execGrouping.c.html#LN493"><span class='Ref_To_Local'>att</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="execGrouping.c.html#LN495"><span class='Ref_To_Local'>isNull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="execGrouping.c.html#LN495"><span class='Ref_To_Local'>isNull</span></a><span class='Parentheses'>)</span>            <span class='Comment_Single_Line'>/* treat nulls as having hash key 0 */ 
</span>        <span class='Delimiter'>{ 
</span><a name="LN504"></a>            <a href="../../include/c.h.html#LN267"><span class='Ref_to_Typedef'>uint32</span></a>      <span class='Declare_Local'>hkey</span><span class='Delimiter'>; 
</span> 
            <a href="execGrouping.c.html#LN504"><span class='Ref_To_Local'>hkey</span></a> <span class='Operator'>= </span><a href="../../include/postgres.h.html#LN491"><span class='Ref_to_Macro'>DatumGetUInt32</span></a><span class='Parentheses'>(</span><a href="../../include/fmgr.h.html#LN601"><span class='Ref_to_Macro'>FunctionCall1</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="execGrouping.c.html#LN469"><span class='Ref_To_Local'>hashfunctions</span></a><span class='Delimiter'>[</span><a href="execGrouping.c.html#LN470"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], 
</span>                                                <a href="execGrouping.c.html#LN494"><span class='Ref_To_Local'>attr</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="execGrouping.c.html#LN467"><span class='Ref_To_Local'>hashkey</span></a> <span class='Operator'>^= </span><a href="execGrouping.c.html#LN504"><span class='Ref_To_Local'>hkey</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;numCols;i++ &raquo; </span> 
 
    <span class='Control'>return</span> <a href="execGrouping.c.html#LN467"><span class='Ref_To_Local'>hashkey</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end TupleHashTableHash &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * See whether two tuples (presumably of the same hash value) match 
 * 
 * As above, the passed pointers are pointers to TupleHashEntryData. 
 * 
 * Also, the caller must select an appropriate memory context for running 
 * the compare functions.  (dynahash.c doesn't change CurrentMemoryContext.) 
 */ 
</span><span class='Keyword'>static int 
</span><a name="LN524"></a><span class='Declare_Function'>TupleHashTableMatch</span><span class='Parentheses'>(</span><span class='Control'>struct</span> tuplehash_hash <span class='Operator'>*</span><span class='Declare_Parameter'>tb</span><span class='Delimiter'>, </span><span class='Keyword'>const </span><a href="../../include/access/htup.h.html#LN26"><span class='Ref_to_Typedef'>MinimalTuple</span></a> <span class='Declare_Parameter'>tuple1</span><span class='Delimiter'>, </span><span class='Keyword'>const </span><a href="../../include/access/htup.h.html#LN26"><span class='Ref_to_Typedef'>MinimalTuple</span></a> <span class='Declare_Parameter'>tuple2</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN526"></a>    <a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Local'>slot1</span><span class='Delimiter'>; 
</span><a name="LN527"></a>    <a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Local'>slot2</span><span class='Delimiter'>; 
</span><a name="LN528"></a>    <a href="../../include/nodes/execnodes.h.html#LN561"><span class='Ref_to_Typedef'>TupleHashTable</span></a> <span class='Declare_Local'>hashtable</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN561"><span class='Ref_to_Typedef'>TupleHashTable</span></a><span class='Parentheses'>) </span><a href="execGrouping.c.html#LN524"><span class='Ref_to_Parameter'>tb</span></a><span class='Operator'>-&GT;</span>private_data<span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We assume that simplehash.h will only ever call us with the first 
     * argument being an actual table entry, and the second argument being 
     * LookupTupleHashEntry's dummy TupleHashEntryData.  The other direction 
     * could be supported too, but is not currently required. 
     */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="execGrouping.c.html#LN524"><span class='Ref_to_Parameter'>tuple1</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="execGrouping.c.html#LN526"><span class='Ref_To_Local'>slot1</span></a> <span class='Operator'>= </span><a href="execGrouping.c.html#LN528"><span class='Ref_To_Local'>hashtable</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN589"><span class='Ref_to_Member'>tableslot</span></a><span class='Delimiter'>; 
</span>    <a href="../../include/executor/tuptable.h.html#LN151"><span class='Ref_to_Proto'>ExecStoreMinimalTuple</span></a><span class='Parentheses'>(</span><a href="execGrouping.c.html#LN524"><span class='Ref_to_Parameter'>tuple1</span></a><span class='Delimiter'>, </span><a href="execGrouping.c.html#LN526"><span class='Ref_To_Local'>slot1</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="execGrouping.c.html#LN524"><span class='Ref_to_Parameter'>tuple2</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="execGrouping.c.html#LN527"><span class='Ref_To_Local'>slot2</span></a> <span class='Operator'>= </span><a href="execGrouping.c.html#LN528"><span class='Ref_To_Local'>hashtable</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN591"><span class='Ref_to_Member'>inputslot</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* For crosstype comparisons, the inputslot must be first */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execGrouping.c.html#LN67"><span class='Ref_to_Func'>execTuplesMatch</span></a><span class='Parentheses'>(</span><a href="execGrouping.c.html#LN527"><span class='Ref_To_Local'>slot2</span></a><span class='Delimiter'>, 
</span>                        <a href="execGrouping.c.html#LN526"><span class='Ref_To_Local'>slot1</span></a><span class='Delimiter'>, 
</span>                        <a href="execGrouping.c.html#LN528"><span class='Ref_To_Local'>hashtable</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN582"><span class='Ref_to_Member'>numCols</span></a><span class='Delimiter'>, 
</span>                        <a href="execGrouping.c.html#LN528"><span class='Ref_To_Local'>hashtable</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN583"><span class='Ref_to_Member'>keyColIdx</span></a><span class='Delimiter'>, 
</span>                        <a href="execGrouping.c.html#LN528"><span class='Ref_To_Local'>hashtable</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN593"><span class='Ref_to_Member'>cur_eq_funcs</span></a><span class='Delimiter'>, 
</span>                        <a href="execGrouping.c.html#LN528"><span class='Ref_To_Local'>hashtable</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN587"><span class='Ref_to_Member'>tempcxt</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <span class='Control'>return</span> <span class='Number'>1</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end TupleHashTableMatch &raquo; </span> 
</pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>