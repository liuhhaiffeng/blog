<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\executor\execSRF.c</title>
<LINK REL=StyleSheet HREF="../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\executor\execSRF.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:39 2017
</td></tr>
<tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * execSRF.c 
 *    Routines implementing the API for set-returning functions 
 * 
 * This file serves nodeFunctionscan.c and nodeProjectSet.c, providing 
 * common code for calling set-returning functions according to the 
 * ReturnSetInfo API. 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * 
 * IDENTIFICATION 
 *    src/backend/executor/execSRF.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"access/htup_details.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/objectaccess.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"executor/execdebug.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"funcapi.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"miscadmin.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/nodeFuncs.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_coerce.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"pgstat.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/acl.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/builtins.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/lsyscache.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/memutils.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/typcache.h"</span> 
 
 
<span class='Comment_Multi_Line'>/* static function decls */ 
</span><a name="LN36"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>init_sexpr</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>foid</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>input_collation</span><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, 
</span><a name="LN37"></a>           <a href="../../include/nodes/execnodes.h.html#LN660"><span class='Ref_to_Struct'>SetExprState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sexpr</span><span class='Delimiter'>, </span><a href="../../include/nodes/execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>parent</span><span class='Delimiter'>, 
</span><a name="LN38"></a>           <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Parameter'>sexprCxt</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>allowSRF</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>needDescForSRF</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN39"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>ShutdownSetExpr</span><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>arg</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN40"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>ExecEvalFuncArgs</span><span class='Parentheses'>(</span><a href="../../include/fmgr.h.html#LN37"><span class='Ref_to_Typedef'>FunctionCallInfo</span></a> <span class='Declare_Parameter'>fcinfo</span><span class='Delimiter'>, 
</span><a name="LN41"></a>                 <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>argList</span><span class='Delimiter'>, </span><a href="../../include/nodes/execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>econtext</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN42"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>ExecPrepareTuplestoreResult</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN660"><span class='Ref_to_Struct'>SetExprState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sexpr</span><span class='Delimiter'>, 
</span><a name="LN43"></a>                            <a href="../../include/nodes/execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>econtext</span><span class='Delimiter'>, 
</span><a name="LN44"></a>                            <a href="../utils/sort/tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>resultStore</span><span class='Delimiter'>, 
</span><a name="LN45"></a>                            <a href="../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a> <span class='Declare_Parameter'>resultDesc</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN46"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>tupledesc_match</span><span class='Parentheses'>(</span><a href="../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a> <span class='Declare_Parameter'>dst_tupdesc</span><span class='Delimiter'>, </span><a href="../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a> <span class='Declare_Parameter'>src_tupdesc</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Prepare function call in FROM (ROWS FROM) for execution. 
 * 
 * This is used by nodeFunctionscan.c. 
 */ 
</span><a href="../../include/nodes/execnodes.h.html#LN660"><span class='Ref_to_Struct'>SetExprState</span></a> <span class='Operator'>* 
</span><a name="LN55"></a><span class='Declare_Function'>ExecInitTableFunctionResult</span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>expr</span><span class='Delimiter'>, 
</span><a name="LN56"></a>                            <a href="../../include/nodes/execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>econtext</span><span class='Delimiter'>, </span><a href="../../include/nodes/execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>parent</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN58"></a>    <a href="../../include/nodes/execnodes.h.html#LN660"><span class='Ref_to_Struct'>SetExprState</span></a> <span class='Operator'>*</span><span class='Declare_Local'>state</span> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN660"><span class='Ref_to_Struct'>SetExprState</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="execSRF.c.html#LN58"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN700"><span class='Ref_to_Member'>funcReturnsSet</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="execSRF.c.html#LN58"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN663"><span class='Ref_to_Member'>expr</span></a> <span class='Operator'>= </span><a href="execSRF.c.html#LN55"><span class='Ref_to_Parameter'>expr</span></a><span class='Delimiter'>; 
</span>    <a href="execSRF.c.html#LN58"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN678"><span class='Ref_to_Member'>func</span></a><span class='Operator'>.</span><a href="../../include/fmgr.h.html#LN58"><span class='Ref_to_Member'>fn_oid</span></a> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Normally the passed expression tree will be a FuncExpr, since the 
     * grammar only allows a function call at the top level of a table 
     * function reference.  However, if the function doesn't return set then 
     * the planner might have replaced the function call via constant-folding 
     * or inlining.  So if we see any other kind of expression node, execute 
     * it via the general ExecEvalExpr() code.  That code path will not 
     * support set-returning functions buried in the expression, though. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN55"><span class='Ref_to_Parameter'>expr</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN75"></a>        <a href="../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>func</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="execSRF.c.html#LN55"><span class='Ref_to_Parameter'>expr</span></a><span class='Delimiter'>; 
</span> 
        <a href="execSRF.c.html#LN58"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN700"><span class='Ref_to_Member'>funcReturnsSet</span></a> <span class='Operator'>= </span><a href="execSRF.c.html#LN75"><span class='Ref_To_Local'>func</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN449"><span class='Ref_to_Member'>funcretset</span></a><span class='Delimiter'>; 
</span>        <a href="execSRF.c.html#LN58"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN664"><span class='Ref_to_Member'>args</span></a> <span class='Operator'>= </span><a href="../../include/executor/executor.h.html#LN240"><span class='Ref_to_Proto'>ExecInitExprList</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN75"><span class='Ref_To_Local'>func</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN455"><span class='Ref_to_Member'>args</span></a><span class='Delimiter'>, </span><a href="execSRF.c.html#LN56"><span class='Ref_to_Parameter'>parent</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="execSRF.c.html#LN36"><span class='Ref_to_Proto'>init_sexpr</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN75"><span class='Ref_To_Local'>func</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN447"><span class='Ref_to_Member'>funcid</span></a><span class='Delimiter'>, </span><a href="execSRF.c.html#LN75"><span class='Ref_To_Local'>func</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN454"><span class='Ref_to_Member'>inputcollid</span></a><span class='Delimiter'>, </span><a href="execSRF.c.html#LN55"><span class='Ref_to_Parameter'>expr</span></a><span class='Delimiter'>, </span><a href="execSRF.c.html#LN58"><span class='Ref_To_Local'>state</span></a><span class='Delimiter'>, </span><a href="execSRF.c.html#LN56"><span class='Ref_to_Parameter'>parent</span></a><span class='Delimiter'>, 
</span>                   <a href="execSRF.c.html#LN56"><span class='Ref_to_Parameter'>econtext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN201"><span class='Ref_to_Member'>ecxt_per_query_memory</span></a><span class='Delimiter'>, </span><a href="execSRF.c.html#LN75"><span class='Ref_To_Local'>func</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN449"><span class='Ref_to_Member'>funcretset</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="execSRF.c.html#LN58"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN671"><span class='Ref_to_Member'>elidedFuncState</span></a> <span class='Operator'>= </span><a href="execExpr.c.html#LN111"><span class='Ref_to_Func'>ExecInitExpr</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN55"><span class='Ref_to_Parameter'>expr</span></a><span class='Delimiter'>, </span><a href="execSRF.c.html#LN56"><span class='Ref_to_Parameter'>parent</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="execSRF.c.html#LN58"><span class='Ref_To_Local'>state</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ExecInitTableFunctionResult &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 *      ExecMakeTableFunctionResult 
 * 
 * Evaluate a table function, producing a materialized result in a Tuplestore 
 * object. 
 * 
 * This is used by nodeFunctionscan.c. 
 */ 
</span><a href="../utils/sort/tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>* 
</span><a name="LN100"></a><span class='Declare_Function'>ExecMakeTableFunctionResult</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN660"><span class='Ref_to_Struct'>SetExprState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>setexpr</span><span class='Delimiter'>, 
</span><a name="LN101"></a>                            <a href="../../include/nodes/execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>econtext</span><span class='Delimiter'>, 
</span><a name="LN102"></a>                            <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Parameter'>argContext</span><span class='Delimiter'>, 
</span><a name="LN103"></a>                            <a href="../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a> <span class='Declare_Parameter'>expectedDesc</span><span class='Delimiter'>, 
</span><a name="LN104"></a>                            <span class='Keyword'>bool </span><span class='Declare_Parameter'>randomAccess</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN106"></a>    <a href="../utils/sort/tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tupstore</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN107"></a>    <a href="../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a>   <span class='Declare_Local'>tupdesc</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN108"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>funcrettype</span><span class='Delimiter'>; 
</span><a name="LN109"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>returnsTuple</span><span class='Delimiter'>; 
</span><a name="LN110"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>returnsSet</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN111"></a>    <a href="../../include/fmgr.h.html#LN76"><span class='Ref_to_Struct'>FunctionCallInfoData</span></a> <span class='Declare_Local'>fcinfo</span><span class='Delimiter'>; 
</span><a name="LN112"></a>    <a href="../../include/pgstat.h.html#LN1086"><span class='Ref_to_Struct'>PgStat_FunctionCallUsage</span></a> <span class='Declare_Local'>fcusage</span><span class='Delimiter'>; 
</span><a name="LN113"></a>    <a href="../../include/nodes/execnodes.h.html#LN261"><span class='Ref_to_Struct'>ReturnSetInfo</span></a> <span class='Declare_Local'>rsinfo</span><span class='Delimiter'>; 
</span><a name="LN114"></a>    <a href="../../include/access/htup.h.html#LN61"><span class='Ref_to_Struct'>HeapTupleData</span></a> <span class='Declare_Local'>tmptup</span><span class='Delimiter'>; 
</span><a name="LN115"></a>    <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>callerContext</span><span class='Delimiter'>; 
</span><a name="LN116"></a>    <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldcontext</span><span class='Delimiter'>; 
</span><a name="LN117"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>first_time</span> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <a href="execSRF.c.html#LN115"><span class='Ref_To_Local'>callerContext</span></a> <span class='Operator'>= </span><a href="../utils/mmgr/mcxt.c.html#LN36"><span class='Ref_to_Global_Var'>CurrentMemoryContext</span></a><span class='Delimiter'>; 
</span> 
    <a href="execSRF.c.html#LN108"><span class='Ref_To_Local'>funcrettype</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="execSRF.c.html#LN100"><span class='Ref_to_Parameter'>setexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN663"><span class='Ref_to_Member'>expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="execSRF.c.html#LN109"><span class='Ref_To_Local'>returnsTuple</span></a> <span class='Operator'>= </span><a href="../../include/utils/lsyscache.h.html#LN150"><span class='Ref_to_Proto'>type_is_rowtype</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN108"><span class='Ref_To_Local'>funcrettype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Prepare a resultinfo node for communication.  We always do this even if 
     * not expecting a set result, so that we can pass expectedDesc.  In the 
     * generic-expression case, the expression doesn't actually get to see the 
     * resultinfo, but set it up anyway because we use some of the fields as 
     * our own state variables. 
     */ 
</span>    <a href="execSRF.c.html#LN113"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN263"><span class='Ref_to_Member'>type</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN492"><span class='Ref_to_EnumConst'>T_ReturnSetInfo</span></a><span class='Delimiter'>; 
</span>    <a href="execSRF.c.html#LN113"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN265"><span class='Ref_to_Member'>econtext</span></a> <span class='Operator'>= </span><a href="execSRF.c.html#LN101"><span class='Ref_to_Parameter'>econtext</span></a><span class='Delimiter'>; 
</span>    <a href="execSRF.c.html#LN113"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN266"><span class='Ref_to_Member'>expectedDesc</span></a> <span class='Operator'>= </span><a href="execSRF.c.html#LN103"><span class='Ref_to_Parameter'>expectedDesc</span></a><span class='Delimiter'>; 
</span>    <a href="execSRF.c.html#LN113"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN267"><span class='Ref_to_Member'>allowedModes</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) (</span><a href="../../include/nodes/execnodes.h.html#LN249"><span class='Ref_to_EnumConst'>SFRM_ValuePerCall</span></a> <span class='Operator'>| </span><a href="../../include/nodes/execnodes.h.html#LN250"><span class='Ref_to_EnumConst'>SFRM_Materialize</span></a> <span class='Operator'>| </span><a href="../../include/nodes/execnodes.h.html#LN252"><span class='Ref_to_EnumConst'>SFRM_Materialize_Preferred</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execSRF.c.html#LN104"><span class='Ref_to_Parameter'>randomAccess</span></a><span class='Parentheses'>) 
</span>        <a href="execSRF.c.html#LN113"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN267"><span class='Ref_to_Member'>allowedModes</span></a> <span class='Operator'>|= </span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="../../include/nodes/execnodes.h.html#LN251"><span class='Ref_to_EnumConst'>SFRM_Materialize_Random</span></a><span class='Delimiter'>; 
</span>    <a href="execSRF.c.html#LN113"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN269"><span class='Ref_to_Member'>returnMode</span></a> <span class='Operator'>= </span><a href="../../include/nodes/execnodes.h.html#LN249"><span class='Ref_to_EnumConst'>SFRM_ValuePerCall</span></a><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* isDone is filled below */ 
</span>    <a href="execSRF.c.html#LN113"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN272"><span class='Ref_to_Member'>setResult</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="execSRF.c.html#LN113"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN273"><span class='Ref_to_Member'>setDesc</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Normally the passed expression tree will be a SetExprState, since the 
     * grammar only allows a function call at the top level of a table 
     * function reference.  However, if the function doesn't return set then 
     * the planner might have replaced the function call via constant-folding 
     * or inlining.  So if we see any other kind of expression node, execute 
     * it via the general ExecEvalExpr() code; the only difference is that we 
     * don't get a chance to pass a special ReturnSetInfo to any functions 
     * buried in the expression. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="execSRF.c.html#LN100"><span class='Ref_to_Parameter'>setexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN671"><span class='Ref_to_Member'>elidedFuncState</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * This path is similar to ExecMakeFunctionResultSet. 
         */ 
</span>        <a href="execSRF.c.html#LN110"><span class='Ref_To_Local'>returnsSet</span></a> <span class='Operator'>= </span><a href="execSRF.c.html#LN100"><span class='Ref_to_Parameter'>setexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN700"><span class='Ref_to_Member'>funcReturnsSet</span></a><span class='Delimiter'>; 
</span>        <a href="../../include/fmgr.h.html#LN119"><span class='Ref_to_Macro'>InitFunctionCallInfoData</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN111"><span class='Ref_To_Local'>fcinfo</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="execSRF.c.html#LN100"><span class='Ref_to_Parameter'>setexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN678"><span class='Ref_to_Member'>func</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                 <a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN100"><span class='Ref_to_Parameter'>setexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN664"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                 <a href="execSRF.c.html#LN100"><span class='Ref_to_Parameter'>setexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN724"><span class='Ref_to_Member'>fcinfo_data</span></a><span class='Operator'>.</span><a href="../../include/fmgr.h.html#LN81"><span class='Ref_to_Member'>fncollation</span></a><span class='Delimiter'>, 
</span>                                 <span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><a href="execSRF.c.html#LN113"><span class='Ref_To_Local'>rsinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Evaluate the function's argument list. 
         * 
         * We can't do this in the per-tuple context: the argument values 
         * would disappear when we reset that context in the inner loop.  And 
         * the caller's CurrentMemoryContext is typically a query-lifespan 
         * context, so we don't want to leak memory there.  We require the 
         * caller to pass a separate memory context that can be used for this, 
         * and can be reset each time through to avoid bloat. 
         */ 
</span>        <a href="../../include/utils/memutils.h.html#LN73"><span class='Ref_to_Proto'>MemoryContextReset</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN102"><span class='Ref_to_Parameter'>argContext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="execSRF.c.html#LN116"><span class='Ref_To_Local'>oldcontext</span></a> <span class='Operator'>= </span><a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN102"><span class='Ref_to_Parameter'>argContext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="execSRF.c.html#LN40"><span class='Ref_to_Proto'>ExecEvalFuncArgs</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="execSRF.c.html#LN111"><span class='Ref_To_Local'>fcinfo</span></a><span class='Delimiter'>, </span><a href="execSRF.c.html#LN100"><span class='Ref_to_Parameter'>setexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN664"><span class='Ref_to_Member'>args</span></a><span class='Delimiter'>, </span><a href="execSRF.c.html#LN101"><span class='Ref_to_Parameter'>econtext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN116"><span class='Ref_To_Local'>oldcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If function is strict, and there are any NULL arguments, skip 
         * calling the function and act like it returned NULL (or an empty 
         * set, in the returns-set case). 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execSRF.c.html#LN100"><span class='Ref_to_Parameter'>setexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN678"><span class='Ref_to_Member'>func</span></a><span class='Operator'>.</span><a href="../../include/fmgr.h.html#LN60"><span class='Ref_to_Member'>fn_strict</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN186"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="execSRF.c.html#LN186"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="execSRF.c.html#LN186"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="execSRF.c.html#LN111"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>.</span><a href="../../include/fmgr.h.html#LN83"><span class='Ref_to_Member'>nargs</span></a><span class='Delimiter'>; </span><a href="execSRF.c.html#LN186"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execSRF.c.html#LN111"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>.</span><a href="../../include/fmgr.h.html#LN85"><span class='Ref_to_Member'>argnull</span></a><span class='Delimiter'>[</span><a href="execSRF.c.html#LN186"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>                    <span class='Control'>goto</span> <span class='Symbol_Characters'>&darr;</span><a href="execSRF.c.html#LN368"><span class='Ref_to_Label'>no_function_result</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !setexpr-&GT;elidedFuncS... &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Treat setexpr as a generic expression */ 
</span>        <a href="../../include/fmgr.h.html#LN119"><span class='Ref_to_Macro'>InitFunctionCallInfoData</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN111"><span class='Ref_To_Local'>fcinfo</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Switch to short-lived context for calling the function or expression. 
     */ 
</span>    <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN101"><span class='Ref_to_Parameter'>econtext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN202"><span class='Ref_to_Member'>ecxt_per_tuple_memory</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Loop to handle the ValuePerCall protocol (which is also the same 
     * behavior needed in the generic ExecEvalExpr path). 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>;;</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN212"></a>        <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/miscadmin.h.html#LN99"><span class='Ref_to_Macro'>CHECK_FOR_INTERRUPTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * reset per-tuple memory context before each call of the function or 
         * expression. This cleans up any local memory the function may leak 
         * when called. 
         */ 
</span>        <a href="../../include/executor/executor.h.html#LN449"><span class='Ref_to_Macro'>ResetExprContext</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN101"><span class='Ref_to_Parameter'>econtext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Call the function or expression one time */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="execSRF.c.html#LN100"><span class='Ref_to_Parameter'>setexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN671"><span class='Ref_to_Member'>elidedFuncState</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../include/pgstat.h.html#LN1293"><span class='Ref_to_Proto'>pgstat_init_function_usage</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="execSRF.c.html#LN111"><span class='Ref_To_Local'>fcinfo</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="execSRF.c.html#LN112"><span class='Ref_To_Local'>fcusage</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="execSRF.c.html#LN111"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>.</span><a href="../../include/fmgr.h.html#LN82"><span class='Ref_to_Member'>isnull</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="execSRF.c.html#LN113"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN270"><span class='Ref_to_Member'>isDone</span></a> <span class='Operator'>= </span><a href="../../include/nodes/execnodes.h.html#LN236"><span class='Ref_to_EnumConst'>ExprSingleResult</span></a><span class='Delimiter'>; 
</span>            <a href="execSRF.c.html#LN212"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/fmgr.h.html#LN136"><span class='Ref_to_Macro'>FunctionCallInvoke</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="execSRF.c.html#LN111"><span class='Ref_To_Local'>fcinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="../../include/pgstat.h.html#LN1295"><span class='Ref_to_Proto'>pgstat_end_function_usage</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="execSRF.c.html#LN112"><span class='Ref_To_Local'>fcusage</span></a><span class='Delimiter'>, 
</span>                                      <a href="execSRF.c.html#LN113"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN270"><span class='Ref_to_Member'>isDone</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/execnodes.h.html#LN237"><span class='Ref_to_EnumConst'>ExprMultipleResult</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <a href="execSRF.c.html#LN212"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= 
</span>                <a href="../../include/executor/executor.h.html#LN264"><span class='Ref_to_Func'>ExecEvalExpr</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN100"><span class='Ref_to_Parameter'>setexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN671"><span class='Ref_to_Member'>elidedFuncState</span></a><span class='Delimiter'>, </span><a href="execSRF.c.html#LN101"><span class='Ref_to_Parameter'>econtext</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="execSRF.c.html#LN111"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>.</span><a href="../../include/fmgr.h.html#LN82"><span class='Ref_to_Member'>isnull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="execSRF.c.html#LN113"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN270"><span class='Ref_to_Member'>isDone</span></a> <span class='Operator'>= </span><a href="../../include/nodes/execnodes.h.html#LN236"><span class='Ref_to_EnumConst'>ExprSingleResult</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* Which protocol does function want to use? */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execSRF.c.html#LN113"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN269"><span class='Ref_to_Member'>returnMode</span></a> <span class='Operator'>== </span><a href="../../include/nodes/execnodes.h.html#LN249"><span class='Ref_to_EnumConst'>SFRM_ValuePerCall</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Check for end of result set. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execSRF.c.html#LN113"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN270"><span class='Ref_to_Member'>isDone</span></a> <span class='Operator'>== </span><a href="../../include/nodes/execnodes.h.html#LN238"><span class='Ref_to_EnumConst'>ExprEndResult</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * If first time through, build tuplestore for result.  For a 
             * scalar function result type, also make a suitable tupdesc. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execSRF.c.html#LN117"><span class='Ref_To_Local'>first_time</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="execSRF.c.html#LN116"><span class='Ref_To_Local'>oldcontext</span></a> <span class='Operator'>= </span><a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN101"><span class='Ref_to_Parameter'>econtext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN201"><span class='Ref_to_Member'>ecxt_per_query_memory</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="execSRF.c.html#LN106"><span class='Ref_To_Local'>tupstore</span></a> <span class='Operator'>= </span><a href="../../include/utils/tuplestore.h.html#LN46"><span class='Ref_to_Proto'>tuplestore_begin_heap</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN104"><span class='Ref_to_Parameter'>randomAccess</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><a href="../utils/init/globals.c.html#LN112"><span class='Ref_to_Global_Var'>work_mem</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="execSRF.c.html#LN113"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN272"><span class='Ref_to_Member'>setResult</span></a> <span class='Operator'>= </span><a href="execSRF.c.html#LN106"><span class='Ref_To_Local'>tupstore</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="execSRF.c.html#LN109"><span class='Ref_To_Local'>returnsTuple</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <a href="execSRF.c.html#LN107"><span class='Ref_To_Local'>tupdesc</span></a> <span class='Operator'>= </span><a href="../access/common/tupdesc.c.html#LN39"><span class='Ref_to_Func'>CreateTemplateTupleDesc</span></a><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="../../include/access/tupdesc.h.html#LN114"><span class='Ref_to_Proto'>TupleDescInitEntry</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN107"><span class='Ref_To_Local'>tupdesc</span></a><span class='Delimiter'>, 
</span>                                       <span class='Parentheses'>(</span><a href="../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a><span class='Parentheses'>) </span><span class='Number'>1</span><span class='Delimiter'>, 
</span>                                       <span class='String'>"column"</span><span class='Delimiter'>, 
</span>                                       <a href="execSRF.c.html#LN108"><span class='Ref_To_Local'>funcrettype</span></a><span class='Delimiter'>, 
</span>                                       <span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, 
</span>                                       <span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="execSRF.c.html#LN113"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN273"><span class='Ref_to_Member'>setDesc</span></a> <span class='Operator'>= </span><a href="execSRF.c.html#LN107"><span class='Ref_To_Local'>tupdesc</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN116"><span class='Ref_To_Local'>oldcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Store current resultset item. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execSRF.c.html#LN109"><span class='Ref_To_Local'>returnsTuple</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="execSRF.c.html#LN111"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>.</span><a href="../../include/fmgr.h.html#LN82"><span class='Ref_to_Member'>isnull</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span><a name="LN281"></a>                    <a href="../../include/access/htup.h.html#LN22"><span class='Ref_to_Typedef'>HeapTupleHeader</span></a> <span class='Declare_Local'>td</span> <span class='Operator'>= </span><a href="../../include/fmgr.h.html#LN258"><span class='Ref_to_Macro'>DatumGetHeapTupleHeader</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN212"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execSRF.c.html#LN107"><span class='Ref_To_Local'>tupdesc</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <span class='Comment_Multi_Line'>/* 
                         * This is the first non-NULL result from the 
                         * function.  Use the type info embedded in the 
                         * rowtype Datum to look up the needed tupdesc.  Make 
                         * a copy for the query. 
                         */ 
</span>                        <a href="execSRF.c.html#LN116"><span class='Ref_To_Local'>oldcontext</span></a> <span class='Operator'>= </span><a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN101"><span class='Ref_to_Parameter'>econtext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN201"><span class='Ref_to_Member'>ecxt_per_query_memory</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                        <a href="execSRF.c.html#LN107"><span class='Ref_To_Local'>tupdesc</span></a> <span class='Operator'>= </span><a href="../../include/utils/typcache.h.html#LN156"><span class='Ref_to_Proto'>lookup_rowtype_tupdesc_copy</span></a><span class='Parentheses'>(</span><a href="../../include/access/htup_details.h.html#LN444"><span class='Ref_to_Macro'>HeapTupleHeaderGetTypeId</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN281"><span class='Ref_To_Local'>td</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                               <a href="../../include/access/htup_details.h.html#LN454"><span class='Ref_to_Macro'>HeapTupleHeaderGetTypMod</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN281"><span class='Ref_To_Local'>td</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                        <a href="execSRF.c.html#LN113"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN273"><span class='Ref_to_Member'>setDesc</span></a> <span class='Operator'>= </span><a href="execSRF.c.html#LN107"><span class='Ref_To_Local'>tupdesc</span></a><span class='Delimiter'>; 
</span>                        <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN116"><span class='Ref_To_Local'>oldcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                    <span class='Control'>else</span> 
                    <span class='Delimiter'>{ 
</span>                        <span class='Comment_Multi_Line'>/* 
                         * Verify all later returned rows have same subtype; 
                         * necessary in case the type is RECORD. 
                         */ 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/access/htup_details.h.html#LN444"><span class='Ref_to_Macro'>HeapTupleHeaderGetTypeId</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN281"><span class='Ref_To_Local'>td</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><a href="execSRF.c.html#LN107"><span class='Ref_To_Local'>tupdesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/tupdesc.h.html#LN76"><span class='Ref_to_Member'>tdtypeid</span></a> <span class='Operator'>|| 
</span>                            <a href="../../include/access/htup_details.h.html#LN454"><span class='Ref_to_Macro'>HeapTupleHeaderGetTypMod</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN281"><span class='Ref_To_Local'>td</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><a href="execSRF.c.html#LN107"><span class='Ref_To_Local'>tupdesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/tupdesc.h.html#LN77"><span class='Ref_to_Member'>tdtypmod</span></a><span class='Parentheses'>)</span> 
                            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_DATATYPE_MISMATCH<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"rows returned by function are not all of the same row type"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * tuplestore_puttuple needs a HeapTuple not a bare 
                     * HeapTupleHeader, but it doesn't need all the fields. 
                     */ 
</span>                    <a href="execSRF.c.html#LN114"><span class='Ref_To_Local'>tmptup</span></a><span class='Operator'>.</span><a href="../../include/access/htup.h.html#LN63"><span class='Ref_to_Member'>t_len</span></a> <span class='Operator'>= </span><a href="../../include/access/htup_details.h.html#LN438"><span class='Ref_to_Macro'>HeapTupleHeaderGetDatumLength</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN281"><span class='Ref_To_Local'>td</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="execSRF.c.html#LN114"><span class='Ref_To_Local'>tmptup</span></a><span class='Operator'>.</span><a href="../../include/access/htup.h.html#LN66"><span class='Ref_to_Member'>t_data</span></a> <span class='Operator'>= </span><a href="execSRF.c.html#LN281"><span class='Ref_To_Local'>td</span></a><span class='Delimiter'>; 
</span> 
                    <a href="../../include/utils/tuplestore.h.html#LN54"><span class='Ref_to_Proto'>tuplestore_puttuple</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN106"><span class='Ref_To_Local'>tupstore</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="execSRF.c.html#LN114"><span class='Ref_To_Local'>tmptup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !fcinfo.isnull &raquo; </span> 
                <span class='Control'>else</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* 
                     * NULL result from a tuple-returning function; expand it 
                     * to a row of all nulls.  We rely on the expectedDesc to 
                     * form such rows.  (Note: this would be problematic if 
                     * tuplestore_putvalues saved the tdtypeid/tdtypmod from 
                     * the provided descriptor, since that might not match 
                     * what we get from the function itself.  But it doesn't.) 
                     */ 
</span><a name="LN329"></a>                    <span class='Keyword'>int</span>         <span class='Declare_Local'>natts</span> <span class='Operator'>= </span><a href="execSRF.c.html#LN103"><span class='Ref_to_Parameter'>expectedDesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/tupdesc.h.html#LN72"><span class='Ref_to_Member'>natts</span></a><span class='Delimiter'>; 
</span><a name="LN330"></a>                    <span class='Keyword'>bool</span>       <span class='Operator'>*</span><span class='Declare_Local'>nullflags</span><span class='Delimiter'>; 
</span> 
                    <a href="execSRF.c.html#LN330"><span class='Ref_To_Local'>nullflags</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN329"><span class='Ref_To_Local'>natts</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>bool</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                    memset<span class='Parentheses'>(</span><a href="execSRF.c.html#LN330"><span class='Ref_To_Local'>nullflags</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, </span><a href="execSRF.c.html#LN329"><span class='Ref_To_Local'>natts</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>bool</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                    <a href="../../include/utils/tuplestore.h.html#LN55"><span class='Ref_to_Proto'>tuplestore_putvalues</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN106"><span class='Ref_To_Local'>tupstore</span></a><span class='Delimiter'>, </span><a href="execSRF.c.html#LN103"><span class='Ref_to_Parameter'>expectedDesc</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><a href="execSRF.c.html#LN330"><span class='Ref_To_Local'>nullflags</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if returnsTuple &raquo; </span> 
            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* Scalar-type case: just store the function result */ 
</span>                <a href="../../include/utils/tuplestore.h.html#LN55"><span class='Ref_to_Proto'>tuplestore_putvalues</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN106"><span class='Ref_To_Local'>tupstore</span></a><span class='Delimiter'>, </span><a href="execSRF.c.html#LN107"><span class='Ref_To_Local'>tupdesc</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="execSRF.c.html#LN212"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="execSRF.c.html#LN111"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>.</span><a href="../../include/fmgr.h.html#LN82"><span class='Ref_to_Member'>isnull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Are we done? 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execSRF.c.html#LN113"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN270"><span class='Ref_to_Member'>isDone</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/execnodes.h.html#LN237"><span class='Ref_to_EnumConst'>ExprMultipleResult</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if rsinfo.returnMode==SF... &raquo; </span> 
        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execSRF.c.html#LN113"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN269"><span class='Ref_to_Member'>returnMode</span></a> <span class='Operator'>== </span><a href="../../include/nodes/execnodes.h.html#LN250"><span class='Ref_to_EnumConst'>SFRM_Materialize</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* check we're on the same page as the function author */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="execSRF.c.html#LN117"><span class='Ref_To_Local'>first_time</span></a> <span class='Operator'>|| </span><a href="execSRF.c.html#LN113"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN270"><span class='Ref_to_Member'>isDone</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/execnodes.h.html#LN236"><span class='Ref_to_EnumConst'>ExprSingleResult</span></a><span class='Parentheses'>) 
</span>                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_E_R_I_E_SRF_PROTOCOL_VIOLATED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"table-function protocol for materialize mode was not followed"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* Done evaluating the set result */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_E_R_I_E_SRF_PROTOCOL_VIOLATED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"unrecognized table-function returnMode: %d"</span><span class='Delimiter'>, 
</span>                            <span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="execSRF.c.html#LN113"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN269"><span class='Ref_to_Member'>returnMode</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
        <a href="execSRF.c.html#LN117"><span class='Ref_To_Local'>first_time</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for ;; &raquo; </span> 
 
<a name="LN368"></a><span class='Label'>no_function_result</span><span class='Operator'>: 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we got nothing from the function (ie, an empty-set or NULL result), 
     * we have to create the tuplestore to return, and if it's a 
     * non-set-returning function then insert a single all-nulls row.  As 
     * above, we depend on the expectedDesc to manufacture the dummy row. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execSRF.c.html#LN113"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN272"><span class='Ref_to_Member'>setResult</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN101"><span class='Ref_to_Parameter'>econtext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN201"><span class='Ref_to_Member'>ecxt_per_query_memory</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="execSRF.c.html#LN106"><span class='Ref_To_Local'>tupstore</span></a> <span class='Operator'>= </span><a href="../../include/utils/tuplestore.h.html#LN46"><span class='Ref_to_Proto'>tuplestore_begin_heap</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN104"><span class='Ref_to_Parameter'>randomAccess</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><a href="../utils/init/globals.c.html#LN112"><span class='Ref_to_Global_Var'>work_mem</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="execSRF.c.html#LN113"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN272"><span class='Ref_to_Member'>setResult</span></a> <span class='Operator'>= </span><a href="execSRF.c.html#LN106"><span class='Ref_To_Local'>tupstore</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="execSRF.c.html#LN110"><span class='Ref_To_Local'>returnsSet</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN383"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>natts</span> <span class='Operator'>= </span><a href="execSRF.c.html#LN103"><span class='Ref_to_Parameter'>expectedDesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/tupdesc.h.html#LN72"><span class='Ref_to_Member'>natts</span></a><span class='Delimiter'>; 
</span><a name="LN384"></a>            <span class='Keyword'>bool</span>       <span class='Operator'>*</span><span class='Declare_Local'>nullflags</span><span class='Delimiter'>; 
</span> 
            <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN101"><span class='Ref_to_Parameter'>econtext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN202"><span class='Ref_to_Member'>ecxt_per_tuple_memory</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="execSRF.c.html#LN384"><span class='Ref_To_Local'>nullflags</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN383"><span class='Ref_To_Local'>natts</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>bool</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            memset<span class='Parentheses'>(</span><a href="execSRF.c.html#LN384"><span class='Ref_To_Local'>nullflags</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, </span><a href="execSRF.c.html#LN383"><span class='Ref_To_Local'>natts</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>bool</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="../../include/utils/tuplestore.h.html#LN55"><span class='Ref_to_Proto'>tuplestore_putvalues</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN106"><span class='Ref_To_Local'>tupstore</span></a><span class='Delimiter'>, </span><a href="execSRF.c.html#LN103"><span class='Ref_to_Parameter'>expectedDesc</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><a href="execSRF.c.html#LN384"><span class='Ref_To_Local'>nullflags</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If function provided a tupdesc, cross-check it.  We only really need to 
     * do this for functions returning RECORD, but might as well do it always. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execSRF.c.html#LN113"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN273"><span class='Ref_to_Member'>setDesc</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="execSRF.c.html#LN46"><span class='Ref_to_Proto'>tupledesc_match</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN103"><span class='Ref_to_Parameter'>expectedDesc</span></a><span class='Delimiter'>, </span><a href="execSRF.c.html#LN113"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN273"><span class='Ref_to_Member'>setDesc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If it is a dynamically-allocated TupleDesc, free it: it is 
         * typically allocated in a per-query context, so we must avoid 
         * leaking it across multiple usages. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execSRF.c.html#LN113"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN273"><span class='Ref_to_Member'>setDesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/tupdesc.h.html#LN79"><span class='Ref_to_Member'>tdrefcount</span></a> <span class='Operator'>== -</span><span class='Number'>1</span><span class='Parentheses'>) 
</span>            <a href="../../include/access/tupdesc.h.html#LN95"><span class='Ref_to_Proto'>FreeTupleDesc</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN113"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN273"><span class='Ref_to_Member'>setDesc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN115"><span class='Ref_To_Local'>callerContext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* All done, pass back the tuplestore */ 
</span>    <span class='Control'>return</span> <a href="execSRF.c.html#LN113"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN272"><span class='Ref_to_Member'>setResult</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ExecMakeTableFunctionResult &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * Prepare targetlist SRF function call for execution. 
 * 
 * This is used by nodeProjectSet.c. 
 */ 
</span><a href="../../include/nodes/execnodes.h.html#LN660"><span class='Ref_to_Struct'>SetExprState</span></a> <span class='Operator'>* 
</span><a name="LN423"></a><span class='Declare_Function'>ExecInitFunctionResultSet</span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>expr</span><span class='Delimiter'>, 
</span><a name="LN424"></a>                          <a href="../../include/nodes/execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>econtext</span><span class='Delimiter'>, </span><a href="../../include/nodes/execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>parent</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN426"></a>    <a href="../../include/nodes/execnodes.h.html#LN660"><span class='Ref_to_Struct'>SetExprState</span></a> <span class='Operator'>*</span><span class='Declare_Local'>state</span> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN660"><span class='Ref_to_Struct'>SetExprState</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="execSRF.c.html#LN426"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN700"><span class='Ref_to_Member'>funcReturnsSet</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <a href="execSRF.c.html#LN426"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN663"><span class='Ref_to_Member'>expr</span></a> <span class='Operator'>= </span><a href="execSRF.c.html#LN423"><span class='Ref_to_Parameter'>expr</span></a><span class='Delimiter'>; 
</span>    <a href="execSRF.c.html#LN426"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN678"><span class='Ref_to_Member'>func</span></a><span class='Operator'>.</span><a href="../../include/fmgr.h.html#LN58"><span class='Ref_to_Member'>fn_oid</span></a> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Initialize metadata.  The expression node could be either a FuncExpr or 
     * an OpExpr. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN423"><span class='Ref_to_Parameter'>expr</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN438"></a>        <a href="../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>func</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="execSRF.c.html#LN423"><span class='Ref_to_Parameter'>expr</span></a><span class='Delimiter'>; 
</span> 
        <a href="execSRF.c.html#LN426"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN664"><span class='Ref_to_Member'>args</span></a> <span class='Operator'>= </span><a href="../../include/executor/executor.h.html#LN240"><span class='Ref_to_Proto'>ExecInitExprList</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN438"><span class='Ref_To_Local'>func</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN455"><span class='Ref_to_Member'>args</span></a><span class='Delimiter'>, </span><a href="execSRF.c.html#LN424"><span class='Ref_to_Parameter'>parent</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="execSRF.c.html#LN36"><span class='Ref_to_Proto'>init_sexpr</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN438"><span class='Ref_To_Local'>func</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN447"><span class='Ref_to_Member'>funcid</span></a><span class='Delimiter'>, </span><a href="execSRF.c.html#LN438"><span class='Ref_To_Local'>func</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN454"><span class='Ref_to_Member'>inputcollid</span></a><span class='Delimiter'>, </span><a href="execSRF.c.html#LN423"><span class='Ref_to_Parameter'>expr</span></a><span class='Delimiter'>, </span><a href="execSRF.c.html#LN426"><span class='Ref_To_Local'>state</span></a><span class='Delimiter'>, </span><a href="execSRF.c.html#LN424"><span class='Ref_to_Parameter'>parent</span></a><span class='Delimiter'>, 
</span>                   <a href="execSRF.c.html#LN424"><span class='Ref_to_Parameter'>econtext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN201"><span class='Ref_to_Member'>ecxt_per_query_memory</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN423"><span class='Ref_to_Parameter'>expr</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN446"></a>        <a href="../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>op</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="execSRF.c.html#LN423"><span class='Ref_to_Parameter'>expr</span></a><span class='Delimiter'>; 
</span> 
        <a href="execSRF.c.html#LN426"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN664"><span class='Ref_to_Member'>args</span></a> <span class='Operator'>= </span><a href="../../include/executor/executor.h.html#LN240"><span class='Ref_to_Proto'>ExecInitExprList</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN446"><span class='Ref_To_Local'>op</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN500"><span class='Ref_to_Member'>args</span></a><span class='Delimiter'>, </span><a href="execSRF.c.html#LN424"><span class='Ref_to_Parameter'>parent</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="execSRF.c.html#LN36"><span class='Ref_to_Proto'>init_sexpr</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN446"><span class='Ref_To_Local'>op</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN495"><span class='Ref_to_Member'>opfuncid</span></a><span class='Delimiter'>, </span><a href="execSRF.c.html#LN446"><span class='Ref_To_Local'>op</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN499"><span class='Ref_to_Member'>inputcollid</span></a><span class='Delimiter'>, </span><a href="execSRF.c.html#LN423"><span class='Ref_to_Parameter'>expr</span></a><span class='Delimiter'>, </span><a href="execSRF.c.html#LN426"><span class='Ref_To_Local'>state</span></a><span class='Delimiter'>, </span><a href="execSRF.c.html#LN424"><span class='Ref_to_Parameter'>parent</span></a><span class='Delimiter'>, 
</span>                   <a href="execSRF.c.html#LN424"><span class='Ref_to_Parameter'>econtext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN201"><span class='Ref_to_Member'>ecxt_per_query_memory</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized node type: %d"</span><span class='Delimiter'>, 
</span>             <span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="../../include/nodes/nodes.h.html#LN513"><span class='Ref_to_Macro'>nodeTag</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN423"><span class='Ref_to_Parameter'>expr</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* shouldn't get here unless the selected function returns set */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="execSRF.c.html#LN426"><span class='Ref_To_Local'>state</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN678"><span class='Ref_to_Member'>func</span></a><span class='Operator'>.</span><a href="../../include/fmgr.h.html#LN61"><span class='Ref_to_Member'>fn_retset</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="execSRF.c.html#LN426"><span class='Ref_To_Local'>state</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ExecInitFunctionResultSet &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 *      ExecMakeFunctionResultSet 
 * 
 * Evaluate the arguments to a set-returning function and then call the 
 * function itself.  The argument expressions may not contain set-returning 
 * functions (the planner is supposed to have separated evaluation for those). 
 * 
 * This is used by nodeProjectSet.c. 
 */ 
</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN472"></a><span class='Declare_Function'>ExecMakeFunctionResultSet</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN660"><span class='Ref_to_Struct'>SetExprState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>fcache</span><span class='Delimiter'>, 
</span><a name="LN473"></a>                          <a href="../../include/nodes/execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>econtext</span><span class='Delimiter'>, 
</span><a name="LN474"></a>                          <span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>isNull</span><span class='Delimiter'>, 
</span><a name="LN475"></a>                          <a href="../../include/nodes/execnodes.h.html#LN234"><span class='Ref_to_Typedef'>ExprDoneCond</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>isDone</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN477"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>arguments</span><span class='Delimiter'>; 
</span><a name="LN478"></a>    <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span><a name="LN479"></a>    <a href="../../include/fmgr.h.html#LN37"><span class='Ref_to_Typedef'>FunctionCallInfo</span></a> <span class='Declare_Local'>fcinfo</span><span class='Delimiter'>; 
</span><a name="LN480"></a>    <a href="../../include/pgstat.h.html#LN1086"><span class='Ref_to_Struct'>PgStat_FunctionCallUsage</span></a> <span class='Declare_Local'>fcusage</span><span class='Delimiter'>; 
</span><a name="LN481"></a>    <a href="../../include/nodes/execnodes.h.html#LN261"><span class='Ref_to_Struct'>ReturnSetInfo</span></a> <span class='Declare_Local'>rsinfo</span><span class='Delimiter'>; 
</span><a name="LN482"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>callit</span><span class='Delimiter'>; 
</span><a name="LN483"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
<a name="LN485"></a><span class='Label'>restart</span><span class='Operator'>: 
</span> 
    <span class='Comment_Multi_Line'>/* Guard against stack overflow due to overly complex expressions */ 
</span>    <a href="../../include/miscadmin.h.html#LN275"><span class='Ref_to_Proto'>check_stack_depth</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If a previous call of the function returned a set result in the form of 
     * a tuplestore, continue reading rows from the tuplestore until it's 
     * empty. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execSRF.c.html#LN472"><span class='Ref_to_Parameter'>fcache</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN685"><span class='Ref_to_Member'>funcResultStore</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/utils/tuplestore.h.html#LN72"><span class='Ref_to_Proto'>tuplestore_gettupleslot</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN472"><span class='Ref_to_Parameter'>fcache</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN685"><span class='Ref_to_Member'>funcResultStore</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                                    <a href="execSRF.c.html#LN472"><span class='Ref_to_Parameter'>fcache</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN686"><span class='Ref_to_Member'>funcResultSlot</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Operator'>*</span><a href="execSRF.c.html#LN475"><span class='Ref_to_Parameter'>isDone</span></a> <span class='Operator'>= </span><a href="../../include/nodes/execnodes.h.html#LN237"><span class='Ref_to_EnumConst'>ExprMultipleResult</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execSRF.c.html#LN472"><span class='Ref_to_Parameter'>fcache</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN693"><span class='Ref_to_Member'>funcReturnsTuple</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* We must return the whole tuple as a Datum. */ 
</span>                <span class='Operator'>*</span><a href="execSRF.c.html#LN474"><span class='Ref_to_Parameter'>isNull</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                <span class='Control'>return</span> <a href="../../include/executor/tuptable.h.html#LN161"><span class='Ref_to_Proto'>ExecFetchSlotTupleDatum</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN472"><span class='Ref_to_Parameter'>fcache</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN686"><span class='Ref_to_Member'>funcResultSlot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* Extract the first column and return it as a scalar. */ 
</span>                <span class='Control'>return</span> <a href="../../include/executor/tuptable.h.html#LN167"><span class='Ref_to_Proto'>slot_getattr</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN472"><span class='Ref_to_Parameter'>fcache</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN686"><span class='Ref_to_Member'>funcResultSlot</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Delimiter'>, </span><a href="execSRF.c.html#LN474"><span class='Ref_to_Parameter'>isNull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>        <span class='Comment_Multi_Line'>/* Exhausted the tuplestore, so clean up */ 
</span>        <a href="../../include/utils/tuplestore.h.html#LN88"><span class='Ref_to_Proto'>tuplestore_end</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN472"><span class='Ref_to_Parameter'>fcache</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN685"><span class='Ref_to_Member'>funcResultStore</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="execSRF.c.html#LN472"><span class='Ref_to_Parameter'>fcache</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN685"><span class='Ref_to_Member'>funcResultStore</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="execSRF.c.html#LN475"><span class='Ref_to_Parameter'>isDone</span></a> <span class='Operator'>= </span><a href="../../include/nodes/execnodes.h.html#LN238"><span class='Ref_to_EnumConst'>ExprEndResult</span></a><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="execSRF.c.html#LN474"><span class='Ref_to_Parameter'>isNull</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if fcache-&GT;funcResultSto... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * arguments is a list of expressions to evaluate before passing to the 
     * function manager.  We skip the evaluation if it was already done in the 
     * previous call (ie, we are continuing the evaluation of a set-valued 
     * function).  Otherwise, collect the current argument values into fcinfo. 
     */ 
</span>    <a href="execSRF.c.html#LN479"><span class='Ref_To_Local'>fcinfo</span></a> <span class='Operator'>= &</span><a href="execSRF.c.html#LN472"><span class='Ref_to_Parameter'>fcache</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN724"><span class='Ref_to_Member'>fcinfo_data</span></a><span class='Delimiter'>; 
</span>    <a href="execSRF.c.html#LN477"><span class='Ref_To_Local'>arguments</span></a> <span class='Operator'>= </span><a href="execSRF.c.html#LN472"><span class='Ref_to_Parameter'>fcache</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN664"><span class='Ref_to_Member'>args</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="execSRF.c.html#LN472"><span class='Ref_to_Parameter'>fcache</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN709"><span class='Ref_to_Member'>setArgsValid</span></a><span class='Parentheses'>) 
</span>        <a href="execSRF.c.html#LN40"><span class='Ref_to_Proto'>ExecEvalFuncArgs</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN479"><span class='Ref_To_Local'>fcinfo</span></a><span class='Delimiter'>, </span><a href="execSRF.c.html#LN477"><span class='Ref_To_Local'>arguments</span></a><span class='Delimiter'>, </span><a href="execSRF.c.html#LN473"><span class='Ref_to_Parameter'>econtext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Reset flag (we may set it again below) */ 
</span>        <a href="execSRF.c.html#LN472"><span class='Ref_to_Parameter'>fcache</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN709"><span class='Ref_to_Member'>setArgsValid</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now call the function, passing the evaluated parameter values. 
     */ 
</span> 
    <span class='Comment_Multi_Line'>/* Prepare a resultinfo node for communication. */ 
</span>    <a href="execSRF.c.html#LN479"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN80"><span class='Ref_to_Member'>resultinfo</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>&</span><a href="execSRF.c.html#LN481"><span class='Ref_To_Local'>rsinfo</span></a><span class='Delimiter'>; 
</span>    <a href="execSRF.c.html#LN481"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN263"><span class='Ref_to_Member'>type</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN492"><span class='Ref_to_EnumConst'>T_ReturnSetInfo</span></a><span class='Delimiter'>; 
</span>    <a href="execSRF.c.html#LN481"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN265"><span class='Ref_to_Member'>econtext</span></a> <span class='Operator'>= </span><a href="execSRF.c.html#LN473"><span class='Ref_to_Parameter'>econtext</span></a><span class='Delimiter'>; 
</span>    <a href="execSRF.c.html#LN481"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN266"><span class='Ref_to_Member'>expectedDesc</span></a> <span class='Operator'>= </span><a href="execSRF.c.html#LN472"><span class='Ref_to_Parameter'>fcache</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN692"><span class='Ref_to_Member'>funcResultDesc</span></a><span class='Delimiter'>; 
</span>    <a href="execSRF.c.html#LN481"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN267"><span class='Ref_to_Member'>allowedModes</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) (</span><a href="../../include/nodes/execnodes.h.html#LN249"><span class='Ref_to_EnumConst'>SFRM_ValuePerCall</span></a> <span class='Operator'>| </span><a href="../../include/nodes/execnodes.h.html#LN250"><span class='Ref_to_EnumConst'>SFRM_Materialize</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* note we do not set SFRM_Materialize_Random or _Preferred */ 
</span>    <a href="execSRF.c.html#LN481"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN269"><span class='Ref_to_Member'>returnMode</span></a> <span class='Operator'>= </span><a href="../../include/nodes/execnodes.h.html#LN249"><span class='Ref_to_EnumConst'>SFRM_ValuePerCall</span></a><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* isDone is filled below */ 
</span>    <a href="execSRF.c.html#LN481"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN272"><span class='Ref_to_Member'>setResult</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="execSRF.c.html#LN481"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN273"><span class='Ref_to_Member'>setDesc</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If function is strict, and there are any NULL arguments, skip calling 
     * the function. 
     */ 
</span>    <a href="execSRF.c.html#LN482"><span class='Ref_To_Local'>callit</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execSRF.c.html#LN472"><span class='Ref_to_Parameter'>fcache</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN678"><span class='Ref_to_Member'>func</span></a><span class='Operator'>.</span><a href="../../include/fmgr.h.html#LN60"><span class='Ref_to_Member'>fn_strict</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="execSRF.c.html#LN483"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="execSRF.c.html#LN483"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="execSRF.c.html#LN479"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN83"><span class='Ref_to_Member'>nargs</span></a><span class='Delimiter'>; </span><a href="execSRF.c.html#LN483"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execSRF.c.html#LN479"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN85"><span class='Ref_to_Member'>argnull</span></a><span class='Delimiter'>[</span><a href="execSRF.c.html#LN483"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="execSRF.c.html#LN482"><span class='Ref_To_Local'>callit</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execSRF.c.html#LN482"><span class='Ref_To_Local'>callit</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../include/pgstat.h.html#LN1293"><span class='Ref_to_Proto'>pgstat_init_function_usage</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN479"><span class='Ref_To_Local'>fcinfo</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="execSRF.c.html#LN480"><span class='Ref_To_Local'>fcusage</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="execSRF.c.html#LN479"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN82"><span class='Ref_to_Member'>isnull</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <a href="execSRF.c.html#LN481"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN270"><span class='Ref_to_Member'>isDone</span></a> <span class='Operator'>= </span><a href="../../include/nodes/execnodes.h.html#LN236"><span class='Ref_to_EnumConst'>ExprSingleResult</span></a><span class='Delimiter'>; 
</span>        <a href="execSRF.c.html#LN478"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/fmgr.h.html#LN136"><span class='Ref_to_Macro'>FunctionCallInvoke</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN479"><span class='Ref_To_Local'>fcinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="execSRF.c.html#LN474"><span class='Ref_to_Parameter'>isNull</span></a> <span class='Operator'>= </span><a href="execSRF.c.html#LN479"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN82"><span class='Ref_to_Member'>isnull</span></a><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="execSRF.c.html#LN475"><span class='Ref_to_Parameter'>isDone</span></a> <span class='Operator'>= </span><a href="execSRF.c.html#LN481"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN270"><span class='Ref_to_Member'>isDone</span></a><span class='Delimiter'>; 
</span> 
        <a href="../../include/pgstat.h.html#LN1295"><span class='Ref_to_Proto'>pgstat_end_function_usage</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="execSRF.c.html#LN480"><span class='Ref_To_Local'>fcusage</span></a><span class='Delimiter'>, 
</span>                                  <a href="execSRF.c.html#LN481"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN270"><span class='Ref_to_Member'>isDone</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/execnodes.h.html#LN237"><span class='Ref_to_EnumConst'>ExprMultipleResult</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* for a strict SRF, result for NULL is an empty set */ 
</span>        <a href="execSRF.c.html#LN478"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="execSRF.c.html#LN474"><span class='Ref_to_Parameter'>isNull</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="execSRF.c.html#LN475"><span class='Ref_to_Parameter'>isDone</span></a> <span class='Operator'>= </span><a href="../../include/nodes/execnodes.h.html#LN238"><span class='Ref_to_EnumConst'>ExprEndResult</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Which protocol does function want to use? */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execSRF.c.html#LN481"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN269"><span class='Ref_to_Member'>returnMode</span></a> <span class='Operator'>== </span><a href="../../include/nodes/execnodes.h.html#LN249"><span class='Ref_to_EnumConst'>SFRM_ValuePerCall</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="execSRF.c.html#LN475"><span class='Ref_to_Parameter'>isDone</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/execnodes.h.html#LN238"><span class='Ref_to_EnumConst'>ExprEndResult</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Save the current argument values to re-use on the next call. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="execSRF.c.html#LN475"><span class='Ref_to_Parameter'>isDone</span></a> <span class='Operator'>== </span><a href="../../include/nodes/execnodes.h.html#LN237"><span class='Ref_to_EnumConst'>ExprMultipleResult</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="execSRF.c.html#LN472"><span class='Ref_to_Parameter'>fcache</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN709"><span class='Ref_to_Member'>setArgsValid</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Comment_Multi_Line'>/* Register cleanup callback if we didn't already */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="execSRF.c.html#LN472"><span class='Ref_to_Parameter'>fcache</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN717"><span class='Ref_to_Member'>shutdown_reg</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <a href="../../include/executor/executor.h.html#LN487"><span class='Ref_to_Proto'>RegisterExprContextCallback</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN473"><span class='Ref_to_Parameter'>econtext</span></a><span class='Delimiter'>, 
</span>                                                <a href="execSRF.c.html#LN39"><span class='Ref_to_Proto'>ShutdownSetExpr</span></a><span class='Delimiter'>, 
</span>                                                <a href="../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN472"><span class='Ref_to_Parameter'>fcache</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                    <a href="execSRF.c.html#LN472"><span class='Ref_to_Parameter'>fcache</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN717"><span class='Ref_to_Member'>shutdown_reg</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if rsinfo.returnMode==SF... &raquo; </span> 
    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execSRF.c.html#LN481"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN269"><span class='Ref_to_Member'>returnMode</span></a> <span class='Operator'>== </span><a href="../../include/nodes/execnodes.h.html#LN250"><span class='Ref_to_EnumConst'>SFRM_Materialize</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* check we're on the same page as the function author */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execSRF.c.html#LN481"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN270"><span class='Ref_to_Member'>isDone</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/execnodes.h.html#LN236"><span class='Ref_to_EnumConst'>ExprSingleResult</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_E_R_I_E_SRF_PROTOCOL_VIOLATED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"table-function protocol for materialize mode was not followed"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execSRF.c.html#LN481"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN272"><span class='Ref_to_Member'>setResult</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* prepare to return values from the tuplestore */ 
</span>            <a href="execSRF.c.html#LN42"><span class='Ref_to_Proto'>ExecPrepareTuplestoreResult</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN472"><span class='Ref_to_Parameter'>fcache</span></a><span class='Delimiter'>, </span><a href="execSRF.c.html#LN473"><span class='Ref_to_Parameter'>econtext</span></a><span class='Delimiter'>, 
</span>                                        <a href="execSRF.c.html#LN481"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN272"><span class='Ref_to_Member'>setResult</span></a><span class='Delimiter'>, 
</span>                                        <a href="execSRF.c.html#LN481"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN273"><span class='Ref_to_Member'>setDesc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* loop back to top to start returning from tuplestore */ 
</span>            <span class='Control'>goto</span> <span class='Symbol_Characters'>&uarr;</span><a href="execSRF.c.html#LN485"><span class='Ref_to_Label'>restart</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Comment_Multi_Line'>/* if setResult was left null, treat it as empty set */ 
</span>        <span class='Operator'>*</span><a href="execSRF.c.html#LN475"><span class='Ref_to_Parameter'>isDone</span></a> <span class='Operator'>= </span><a href="../../include/nodes/execnodes.h.html#LN238"><span class='Ref_to_EnumConst'>ExprEndResult</span></a><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="execSRF.c.html#LN474"><span class='Ref_to_Parameter'>isNull</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <a href="execSRF.c.html#LN478"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if rsinfo.returnMode==SF... &raquo; </span> 
    <span class='Control'>else</span> 
        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_E_R_I_E_SRF_PROTOCOL_VIOLATED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"unrecognized table-function returnMode: %d"</span><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="execSRF.c.html#LN481"><span class='Ref_To_Local'>rsinfo</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN269"><span class='Ref_to_Member'>returnMode</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="execSRF.c.html#LN478"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ExecMakeFunctionResultSet &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * init_sexpr - initialize a SetExprState node during first use 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN648"></a><span class='Declare_Function'>init_sexpr</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>foid</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>input_collation</span><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, 
</span><a name="LN649"></a>           <a href="../../include/nodes/execnodes.h.html#LN660"><span class='Ref_to_Struct'>SetExprState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sexpr</span><span class='Delimiter'>, </span><a href="../../include/nodes/execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>parent</span><span class='Delimiter'>, 
</span><a name="LN650"></a>           <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Parameter'>sexprCxt</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>allowSRF</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>needDescForSRF</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN652"></a>    <a href="../../include/utils/acl.h.html#LN169"><span class='Ref_to_Typedef'>AclResult</span></a>   <span class='Declare_Local'>aclresult</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Check permission to call function */ 
</span>    <a href="execSRF.c.html#LN652"><span class='Ref_To_Local'>aclresult</span></a> <span class='Operator'>= </span><a href="../../include/utils/acl.h.html#LN285"><span class='Ref_to_Proto'>pg_proc_aclcheck</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN648"><span class='Ref_to_Parameter'>foid</span></a><span class='Delimiter'>, </span><a href="../utils/init/miscinit.c.html#LN281"><span class='Ref_to_Func'>GetUserId</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, </span><a href="../../include/nodes/parsenodes.h.html#LN78"><span class='Ref_to_Const'>ACL_EXECUTE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execSRF.c.html#LN652"><span class='Ref_To_Local'>aclresult</span></a> <span class='Operator'>!= </span><a href="../../include/utils/acl.h.html#LN171"><span class='Ref_to_EnumConst'>ACLCHECK_OK</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/utils/acl.h.html#LN295"><span class='Ref_to_Proto'>aclcheck_error</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN652"><span class='Ref_To_Local'>aclresult</span></a><span class='Delimiter'>, </span><a href="../../include/utils/acl.h.html#LN184"><span class='Ref_to_EnumConst'>ACL_KIND_PROC</span></a><span class='Delimiter'>, </span><a href="../../include/utils/lsyscache.h.html#LN110"><span class='Ref_to_Proto'>get_func_name</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN648"><span class='Ref_to_Parameter'>foid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="../../include/catalog/objectaccess.h.html#LN178"><span class='Ref_to_Macro'>InvokeFunctionExecuteHook</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN648"><span class='Ref_to_Parameter'>foid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Safety check on nargs.  Under normal circumstances this should never 
     * fail, as parser should check sooner.  But possibly it might fail if 
     * server has been compiled with FUNC_MAX_ARGS smaller than some functions 
     * declared in pg_proc? 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN649"><span class='Ref_to_Parameter'>sexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN664"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT; </span><a href="../../include/pg_config_manual.h.html#LN36"><span class='Ref_to_Const'>FUNC_MAX_ARGS</span></a><span class='Parentheses'>)</span> 
        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_TOO_MANY_ARGUMENTS<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>             <a href="../utils/error/elog.c.html#LN848"><span class='Ref_to_Func'>errmsg_plural</span></a><span class='Parentheses'>(</span><span class='String'>"cannot pass more than %d argument to a function"</span><span class='Delimiter'>, 
</span>                           <span class='String'>"cannot pass more than %d arguments to a function"</span><span class='Delimiter'>, 
</span>                           <a href="../../include/pg_config_manual.h.html#LN36"><span class='Ref_to_Const'>FUNC_MAX_ARGS</span></a><span class='Delimiter'>, 
</span>                           <a href="../../include/pg_config_manual.h.html#LN36"><span class='Ref_to_Const'>FUNC_MAX_ARGS</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Set up the primary fmgr lookup information */ 
</span>    <a href="../../include/fmgr.h.html#LN99"><span class='Ref_to_Proto'>fmgr_info_cxt</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN648"><span class='Ref_to_Parameter'>foid</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="execSRF.c.html#LN649"><span class='Ref_to_Parameter'>sexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN678"><span class='Ref_to_Member'>func</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="execSRF.c.html#LN650"><span class='Ref_to_Parameter'>sexprCxt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/fmgr.h.html#LN103"><span class='Ref_to_Macro'>fmgr_info_set_expr</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="execSRF.c.html#LN649"><span class='Ref_to_Parameter'>sexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN663"><span class='Ref_to_Member'>expr</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="execSRF.c.html#LN649"><span class='Ref_to_Parameter'>sexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN678"><span class='Ref_to_Member'>func</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Initialize the function call parameter struct as well */ 
</span>    <a href="../../include/fmgr.h.html#LN119"><span class='Ref_to_Macro'>InitFunctionCallInfoData</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN649"><span class='Ref_to_Parameter'>sexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN724"><span class='Ref_to_Member'>fcinfo_data</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><span class='Parentheses'>(</span><a href="execSRF.c.html#LN649"><span class='Ref_to_Parameter'>sexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN678"><span class='Ref_to_Member'>func</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                             <a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN649"><span class='Ref_to_Parameter'>sexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN664"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                             <a href="execSRF.c.html#LN648"><span class='Ref_to_Parameter'>input_collation</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* If function returns set, check if that's allowed by caller */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execSRF.c.html#LN649"><span class='Ref_to_Parameter'>sexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN678"><span class='Ref_to_Member'>func</span></a><span class='Operator'>.</span><a href="../../include/fmgr.h.html#LN61"><span class='Ref_to_Member'>fn_retset</span></a> <span class='Operator'>&& !</span><a href="execSRF.c.html#LN650"><span class='Ref_to_Parameter'>allowSRF</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"set-valued function called in context that cannot accept a set"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="execSRF.c.html#LN649"><span class='Ref_to_Parameter'>parent</span></a> <span class='Operator'>? </span><a href="../../include/executor/executor.h.html#LN485"><span class='Ref_to_Proto'>executor_errposition</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN649"><span class='Ref_to_Parameter'>parent</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN814"><span class='Ref_to_Member'>state</span></a><span class='Delimiter'>, 
</span>                                          <a href="../../include/nodes/nodeFuncs.h.html#LN43"><span class='Ref_to_Proto'>exprLocation</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="execSRF.c.html#LN648"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>))</span> <span class='Operator'>: </span><span class='Number'>0</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Otherwise, caller should have marked the sexpr correctly */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="execSRF.c.html#LN649"><span class='Ref_to_Parameter'>sexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN678"><span class='Ref_to_Member'>func</span></a><span class='Operator'>.</span><a href="../../include/fmgr.h.html#LN61"><span class='Ref_to_Member'>fn_retset</span></a> <span class='Operator'>== </span><a href="execSRF.c.html#LN649"><span class='Ref_to_Parameter'>sexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN700"><span class='Ref_to_Member'>funcReturnsSet</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* If function returns set, prepare expected tuple descriptor */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execSRF.c.html#LN649"><span class='Ref_to_Parameter'>sexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN678"><span class='Ref_to_Member'>func</span></a><span class='Operator'>.</span><a href="../../include/fmgr.h.html#LN61"><span class='Ref_to_Member'>fn_retset</span></a> <span class='Operator'>&& </span><a href="execSRF.c.html#LN650"><span class='Ref_to_Parameter'>needDescForSRF</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN697"></a>        <a href="../../include/funcapi.h.html#LN149"><span class='Ref_to_Enum'>TypeFuncClass</span></a> <span class='Declare_Local'>functypclass</span><span class='Delimiter'>; 
</span><a name="LN698"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>funcrettype</span><span class='Delimiter'>; 
</span><a name="LN699"></a>        <a href="../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a>   <span class='Declare_Local'>tupdesc</span><span class='Delimiter'>; 
</span><a name="LN700"></a>        <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldcontext</span><span class='Delimiter'>; 
</span> 
        <a href="execSRF.c.html#LN697"><span class='Ref_To_Local'>functypclass</span></a> <span class='Operator'>= </span><a href="../../include/funcapi.h.html#LN160"><span class='Ref_to_Proto'>get_expr_result_type</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN649"><span class='Ref_to_Parameter'>sexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN678"><span class='Ref_to_Member'>func</span></a><span class='Operator'>.</span><a href="../../include/fmgr.h.html#LN65"><span class='Ref_to_Member'>fn_expr</span></a><span class='Delimiter'>, 
</span>                                            <span class='Operator'>&</span><a href="execSRF.c.html#LN698"><span class='Ref_To_Local'>funcrettype</span></a><span class='Delimiter'>, 
</span>                                            <span class='Operator'>&</span><a href="execSRF.c.html#LN699"><span class='Ref_To_Local'>tupdesc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Must save tupdesc in sexpr's context */ 
</span>        <a href="execSRF.c.html#LN700"><span class='Ref_To_Local'>oldcontext</span></a> <span class='Operator'>= </span><a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN650"><span class='Ref_to_Parameter'>sexprCxt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execSRF.c.html#LN697"><span class='Ref_To_Local'>functypclass</span></a> <span class='Operator'>== </span><a href="../../include/funcapi.h.html#LN152"><span class='Ref_to_EnumConst'>TYPEFUNC_COMPOSITE</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Composite data type, e.g. a table's row type */ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="execSRF.c.html#LN699"><span class='Ref_To_Local'>tupdesc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* Must copy it out of typcache for safety */ 
</span>            <a href="execSRF.c.html#LN649"><span class='Ref_to_Parameter'>sexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN692"><span class='Ref_to_Member'>funcResultDesc</span></a> <span class='Operator'>= </span><a href="../../include/access/tupdesc.h.html#LN88"><span class='Ref_to_Proto'>CreateTupleDescCopy</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN699"><span class='Ref_To_Local'>tupdesc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="execSRF.c.html#LN649"><span class='Ref_to_Parameter'>sexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN693"><span class='Ref_to_Member'>funcReturnsTuple</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execSRF.c.html#LN697"><span class='Ref_To_Local'>functypclass</span></a> <span class='Operator'>== </span><a href="../../include/funcapi.h.html#LN151"><span class='Ref_to_EnumConst'>TYPEFUNC_SCALAR</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Base data type, i.e. scalar */ 
</span>            <a href="execSRF.c.html#LN699"><span class='Ref_To_Local'>tupdesc</span></a> <span class='Operator'>= </span><a href="../access/common/tupdesc.c.html#LN39"><span class='Ref_to_Func'>CreateTemplateTupleDesc</span></a><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../include/access/tupdesc.h.html#LN114"><span class='Ref_to_Proto'>TupleDescInitEntry</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN699"><span class='Ref_To_Local'>tupdesc</span></a><span class='Delimiter'>, 
</span>                               <span class='Parentheses'>(</span><a href="../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a><span class='Parentheses'>) </span><span class='Number'>1</span><span class='Delimiter'>, 
</span>                               <span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                               <a href="execSRF.c.html#LN698"><span class='Ref_To_Local'>funcrettype</span></a><span class='Delimiter'>, 
</span>                               <span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, 
</span>                               <span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="execSRF.c.html#LN649"><span class='Ref_to_Parameter'>sexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN692"><span class='Ref_to_Member'>funcResultDesc</span></a> <span class='Operator'>= </span><a href="execSRF.c.html#LN699"><span class='Ref_To_Local'>tupdesc</span></a><span class='Delimiter'>; 
</span>            <a href="execSRF.c.html#LN649"><span class='Ref_to_Parameter'>sexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN693"><span class='Ref_to_Member'>funcReturnsTuple</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execSRF.c.html#LN697"><span class='Ref_To_Local'>functypclass</span></a> <span class='Operator'>== </span><a href="../../include/funcapi.h.html#LN153"><span class='Ref_to_EnumConst'>TYPEFUNC_RECORD</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* This will work if function doesn't need an expectedDesc */ 
</span>            <a href="execSRF.c.html#LN649"><span class='Ref_to_Parameter'>sexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN692"><span class='Ref_to_Member'>funcResultDesc</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>            <a href="execSRF.c.html#LN649"><span class='Ref_to_Parameter'>sexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN693"><span class='Ref_to_Member'>funcReturnsTuple</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Else, we will fail if function needs an expectedDesc */ 
</span>            <a href="execSRF.c.html#LN649"><span class='Ref_to_Parameter'>sexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN692"><span class='Ref_to_Member'>funcResultDesc</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN700"><span class='Ref_To_Local'>oldcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if sexpr-&GT;func.fn_retset... &raquo; </span> 
    <span class='Control'>else</span> 
        <a href="execSRF.c.html#LN649"><span class='Ref_to_Parameter'>sexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN692"><span class='Ref_to_Member'>funcResultDesc</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Initialize additional state */ 
</span>    <a href="execSRF.c.html#LN649"><span class='Ref_to_Parameter'>sexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN685"><span class='Ref_to_Member'>funcResultStore</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="execSRF.c.html#LN649"><span class='Ref_to_Parameter'>sexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN686"><span class='Ref_to_Member'>funcResultSlot</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="execSRF.c.html#LN649"><span class='Ref_to_Parameter'>sexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN717"><span class='Ref_to_Member'>shutdown_reg</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end init_sexpr &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * callback function in case a SetExprState needs to be shut down before it 
 * has been run to completion 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN758"></a><span class='Declare_Function'>ShutdownSetExpr</span><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>arg</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN760"></a>    <a href="../../include/nodes/execnodes.h.html#LN660"><span class='Ref_to_Struct'>SetExprState</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sexpr</span> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN575"><span class='Ref_to_Macro'>castNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN660"><span class='Ref_to_Struct'>SetExprState</span></a><span class='Delimiter'>, </span><a href="../../include/postgres.h.html#LN554"><span class='Ref_to_Macro'>DatumGetPointer</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN758"><span class='Ref_to_Parameter'>arg</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* If we have a slot, make sure it's let go of any tuplestore pointer */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execSRF.c.html#LN760"><span class='Ref_To_Local'>sexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN686"><span class='Ref_to_Member'>funcResultSlot</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/executor/tuptable.h.html#LN154"><span class='Ref_to_Proto'>ExecClearTuple</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN760"><span class='Ref_To_Local'>sexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN686"><span class='Ref_to_Member'>funcResultSlot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Release any open tuplestore */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execSRF.c.html#LN760"><span class='Ref_To_Local'>sexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN685"><span class='Ref_to_Member'>funcResultStore</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/utils/tuplestore.h.html#LN88"><span class='Ref_to_Proto'>tuplestore_end</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN760"><span class='Ref_To_Local'>sexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN685"><span class='Ref_to_Member'>funcResultStore</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="execSRF.c.html#LN760"><span class='Ref_To_Local'>sexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN685"><span class='Ref_to_Member'>funcResultStore</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Clear any active set-argument state */ 
</span>    <a href="execSRF.c.html#LN760"><span class='Ref_To_Local'>sexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN709"><span class='Ref_to_Member'>setArgsValid</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* execUtils will deregister the callback... */ 
</span>    <a href="execSRF.c.html#LN760"><span class='Ref_To_Local'>sexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN717"><span class='Ref_to_Member'>shutdown_reg</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ShutdownSetExpr &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Evaluate arguments for a function. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN782"></a><span class='Declare_Function'>ExecEvalFuncArgs</span><span class='Parentheses'>(</span><a href="../../include/fmgr.h.html#LN37"><span class='Ref_to_Typedef'>FunctionCallInfo</span></a> <span class='Declare_Parameter'>fcinfo</span><span class='Delimiter'>, 
</span><a name="LN783"></a>                 <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>argList</span><span class='Delimiter'>, 
</span><a name="LN784"></a>                 <a href="../../include/nodes/execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>econtext</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN786"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN787"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>arg</span><span class='Delimiter'>; 
</span> 
    <a href="execSRF.c.html#LN786"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN787"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>, </span><a href="execSRF.c.html#LN783"><span class='Ref_to_Parameter'>argList</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN792"></a>        <a href="../../include/nodes/execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>argstate</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN787"><span class='Ref_To_Local'>arg</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="execSRF.c.html#LN782"><span class='Ref_to_Parameter'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN84"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>[</span><a href="execSRF.c.html#LN786"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/executor/executor.h.html#LN264"><span class='Ref_to_Func'>ExecEvalExpr</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN792"><span class='Ref_To_Local'>argstate</span></a><span class='Delimiter'>, 
</span>                                      <a href="execSRF.c.html#LN784"><span class='Ref_to_Parameter'>econtext</span></a><span class='Delimiter'>, 
</span>                                      <span class='Operator'>&</span><a href="execSRF.c.html#LN782"><span class='Ref_to_Parameter'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN85"><span class='Ref_to_Member'>argnull</span></a><span class='Delimiter'>[</span><a href="execSRF.c.html#LN786"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="execSRF.c.html#LN786"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="execSRF.c.html#LN786"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>== </span><a href="execSRF.c.html#LN782"><span class='Ref_to_Parameter'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN83"><span class='Ref_to_Member'>nargs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ExecEvalFuncArgs &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 *      ExecPrepareTuplestoreResult 
 * 
 * Subroutine for ExecMakeFunctionResultSet: prepare to extract rows from a 
 * tuplestore function result.  We must set up a funcResultSlot (unless 
 * already done in a previous call cycle) and verify that the function 
 * returned the expected tuple descriptor. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN812"></a><span class='Declare_Function'>ExecPrepareTuplestoreResult</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN660"><span class='Ref_to_Struct'>SetExprState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sexpr</span><span class='Delimiter'>, 
</span><a name="LN813"></a>                            <a href="../../include/nodes/execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>econtext</span><span class='Delimiter'>, 
</span><a name="LN814"></a>                            <a href="../utils/sort/tuplestore.c.html#LN102"><span class='Ref_to_Struct'>Tuplestorestate</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>resultStore</span><span class='Delimiter'>, 
</span><a name="LN815"></a>                            <a href="../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a> <span class='Declare_Parameter'>resultDesc</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="execSRF.c.html#LN812"><span class='Ref_to_Parameter'>sexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN685"><span class='Ref_to_Member'>funcResultStore</span></a> <span class='Operator'>= </span><a href="execSRF.c.html#LN814"><span class='Ref_to_Parameter'>resultStore</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execSRF.c.html#LN812"><span class='Ref_to_Parameter'>sexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN686"><span class='Ref_to_Member'>funcResultSlot</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Create a slot so we can read data out of the tuplestore */ 
</span><a name="LN822"></a>        <a href="../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a>   <span class='Declare_Local'>slotDesc</span><span class='Delimiter'>; 
</span><a name="LN823"></a>        <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldcontext</span><span class='Delimiter'>; 
</span> 
        <a href="execSRF.c.html#LN823"><span class='Ref_To_Local'>oldcontext</span></a> <span class='Operator'>= </span><a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN812"><span class='Ref_to_Parameter'>sexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN678"><span class='Ref_to_Member'>func</span></a><span class='Operator'>.</span><a href="../../include/fmgr.h.html#LN64"><span class='Ref_to_Member'>fn_mcxt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If we were not able to determine the result rowtype from context, 
         * and the function didn't return a tupdesc, we have to fail. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execSRF.c.html#LN812"><span class='Ref_to_Parameter'>sexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN692"><span class='Ref_to_Member'>funcResultDesc</span></a><span class='Parentheses'>) 
</span>            <a href="execSRF.c.html#LN822"><span class='Ref_To_Local'>slotDesc</span></a> <span class='Operator'>= </span><a href="execSRF.c.html#LN812"><span class='Ref_to_Parameter'>sexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN692"><span class='Ref_to_Member'>funcResultDesc</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execSRF.c.html#LN815"><span class='Ref_to_Parameter'>resultDesc</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* don't assume resultDesc is long-lived */ 
</span>            <a href="execSRF.c.html#LN822"><span class='Ref_To_Local'>slotDesc</span></a> <span class='Operator'>= </span><a href="../../include/access/tupdesc.h.html#LN88"><span class='Ref_to_Proto'>CreateTupleDescCopy</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN815"><span class='Ref_to_Parameter'>resultDesc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"function returning setof record called in "</span> 
                            <span class='String'>"context that cannot accept type record"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <a href="execSRF.c.html#LN822"><span class='Ref_To_Local'>slotDesc</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* keep compiler quiet */ 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="execSRF.c.html#LN812"><span class='Ref_to_Parameter'>sexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN686"><span class='Ref_to_Member'>funcResultSlot</span></a> <span class='Operator'>= </span><a href="../../include/executor/tuptable.h.html#LN144"><span class='Ref_to_Proto'>MakeSingleTupleTableSlot</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN822"><span class='Ref_To_Local'>slotDesc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN823"><span class='Ref_To_Local'>oldcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if sexpr-&GT;funcResultSlot... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * If function provided a tupdesc, cross-check it.  We only really need to 
     * do this for functions returning RECORD, but might as well do it always. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execSRF.c.html#LN815"><span class='Ref_to_Parameter'>resultDesc</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execSRF.c.html#LN812"><span class='Ref_to_Parameter'>sexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN692"><span class='Ref_to_Member'>funcResultDesc</span></a><span class='Parentheses'>) 
</span>            <a href="execSRF.c.html#LN46"><span class='Ref_to_Proto'>tupledesc_match</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN812"><span class='Ref_to_Parameter'>sexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN692"><span class='Ref_to_Member'>funcResultDesc</span></a><span class='Delimiter'>, </span><a href="execSRF.c.html#LN815"><span class='Ref_to_Parameter'>resultDesc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If it is a dynamically-allocated TupleDesc, free it: it is 
         * typically allocated in a per-query context, so we must avoid 
         * leaking it across multiple usages. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execSRF.c.html#LN815"><span class='Ref_to_Parameter'>resultDesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/tupdesc.h.html#LN79"><span class='Ref_to_Member'>tdrefcount</span></a> <span class='Operator'>== -</span><span class='Number'>1</span><span class='Parentheses'>) 
</span>            <a href="../../include/access/tupdesc.h.html#LN95"><span class='Ref_to_Proto'>FreeTupleDesc</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN815"><span class='Ref_to_Parameter'>resultDesc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Register cleanup callback if we didn't already */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="execSRF.c.html#LN812"><span class='Ref_to_Parameter'>sexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN717"><span class='Ref_to_Member'>shutdown_reg</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../include/executor/executor.h.html#LN487"><span class='Ref_to_Proto'>RegisterExprContextCallback</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN813"><span class='Ref_to_Parameter'>econtext</span></a><span class='Delimiter'>, 
</span>                                    <a href="execSRF.c.html#LN39"><span class='Ref_to_Proto'>ShutdownSetExpr</span></a><span class='Delimiter'>, 
</span>                                    <a href="../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN812"><span class='Ref_to_Parameter'>sexpr</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="execSRF.c.html#LN812"><span class='Ref_to_Parameter'>sexpr</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN717"><span class='Ref_to_Member'>shutdown_reg</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end ExecPrepareTuplestoreResult &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Check that function result tuple type (src_tupdesc) matches or can 
 * be considered to match what the query expects (dst_tupdesc). If 
 * they don't match, ereport. 
 * 
 * We really only care about number of attributes and data type. 
 * Also, we can ignore type mismatch on columns that are dropped in the 
 * destination type, so long as the physical storage matches.  This is 
 * helpful in some cases involving out-of-date cached plans. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN890"></a><span class='Declare_Function'>tupledesc_match</span><span class='Parentheses'>(</span><a href="../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a> <span class='Declare_Parameter'>dst_tupdesc</span><span class='Delimiter'>, </span><a href="../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a> <span class='Declare_Parameter'>src_tupdesc</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN892"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execSRF.c.html#LN890"><span class='Ref_to_Parameter'>dst_tupdesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/tupdesc.h.html#LN72"><span class='Ref_to_Member'>natts</span></a> <span class='Operator'>!= </span><a href="execSRF.c.html#LN890"><span class='Ref_to_Parameter'>src_tupdesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/tupdesc.h.html#LN72"><span class='Ref_to_Member'>natts</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_DATATYPE_MISMATCH<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"function return row and query-specified return row do not match"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../../include/utils/elog.h.html#LN150"><span class='Ref_to_Func'>errdetail_plural</span></a><span class='Parentheses'>(</span><span class='String'>"Returned row contains %d attribute, but query expects %d."</span><span class='Delimiter'>, 
</span>                <span class='String'>"Returned row contains %d attributes, but query expects %d."</span><span class='Delimiter'>, 
</span>                                  <a href="execSRF.c.html#LN890"><span class='Ref_to_Parameter'>src_tupdesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/tupdesc.h.html#LN72"><span class='Ref_to_Member'>natts</span></a><span class='Delimiter'>, 
</span>                                  <a href="execSRF.c.html#LN890"><span class='Ref_to_Parameter'>src_tupdesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/tupdesc.h.html#LN72"><span class='Ref_to_Member'>natts</span></a><span class='Delimiter'>, </span><a href="execSRF.c.html#LN890"><span class='Ref_to_Parameter'>dst_tupdesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/tupdesc.h.html#LN72"><span class='Ref_to_Member'>natts</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="execSRF.c.html#LN892"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="execSRF.c.html#LN892"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="execSRF.c.html#LN890"><span class='Ref_to_Parameter'>dst_tupdesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/tupdesc.h.html#LN72"><span class='Ref_to_Member'>natts</span></a><span class='Delimiter'>; </span><a href="execSRF.c.html#LN892"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN905"></a>        <a href="../../include/catalog/pg_attribute.h.html#LN186"><span class='Ref_to_Typedef'>Form_pg_attribute</span></a> <span class='Declare_Local'>dattr</span> <span class='Operator'>= </span><a href="execSRF.c.html#LN890"><span class='Ref_to_Parameter'>dst_tupdesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/tupdesc.h.html#LN73"><span class='Ref_to_Member'>attrs</span></a><span class='Delimiter'>[</span><a href="execSRF.c.html#LN892"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span><a name="LN906"></a>        <a href="../../include/catalog/pg_attribute.h.html#LN186"><span class='Ref_to_Typedef'>Form_pg_attribute</span></a> <span class='Declare_Local'>sattr</span> <span class='Operator'>= </span><a href="execSRF.c.html#LN890"><span class='Ref_to_Parameter'>src_tupdesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/tupdesc.h.html#LN73"><span class='Ref_to_Member'>attrs</span></a><span class='Delimiter'>[</span><a href="execSRF.c.html#LN892"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/parser/parse_coerce.h.html#LN33"><span class='Ref_to_Proto'>IsBinaryCoercible</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN906"><span class='Ref_To_Local'>sattr</span></a><span class='Operator'>-&GT;</span>atttypid<span class='Delimiter'>, </span><a href="execSRF.c.html#LN905"><span class='Ref_To_Local'>dattr</span></a><span class='Operator'>-&GT;</span>atttypid<span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* no worries */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="execSRF.c.html#LN905"><span class='Ref_To_Local'>dattr</span></a><span class='Operator'>-&GT;</span>attisdropped<span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_DATATYPE_MISMATCH<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"function return row and query-specified return row do not match"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"Returned type %s at ordinal position %d, but query expects %s."</span><span class='Delimiter'>, 
</span>                               <a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN906"><span class='Ref_To_Local'>sattr</span></a><span class='Operator'>-&GT;</span>atttypid<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                               <a href="execSRF.c.html#LN892"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>, 
</span>                               <a href="../utils/adt/format_type.c.html#LN92"><span class='Ref_to_Func'>format_type_be</span></a><span class='Parentheses'>(</span><a href="execSRF.c.html#LN905"><span class='Ref_To_Local'>dattr</span></a><span class='Operator'>-&GT;</span>atttypid<span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execSRF.c.html#LN905"><span class='Ref_To_Local'>dattr</span></a><span class='Operator'>-&GT;</span>attlen <span class='Operator'>!= </span><a href="execSRF.c.html#LN906"><span class='Ref_To_Local'>sattr</span></a><span class='Operator'>-&GT;</span>attlen <span class='Operator'>|| 
</span>            <a href="execSRF.c.html#LN905"><span class='Ref_To_Local'>dattr</span></a><span class='Operator'>-&GT;</span>attalign <span class='Operator'>!= </span><a href="execSRF.c.html#LN906"><span class='Ref_To_Local'>sattr</span></a><span class='Operator'>-&GT;</span>attalign<span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_DATATYPE_MISMATCH<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"function return row and query-specified return row do not match"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN871"><span class='Ref_to_Func'>errdetail</span></a><span class='Parentheses'>(</span><span class='String'>"Physical storage mismatch on dropped attribute at ordinal position %d."</span><span class='Delimiter'>, 
</span>                               <a href="execSRF.c.html#LN892"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;dst_tupdesc-&GT;na... &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end tupledesc_match &raquo; </span> 
</pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>