<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\executor\execScan.c</title>
<LINK REL=StyleSheet HREF="../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\executor\execScan.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:39 2017
</td></tr>
<tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
</span><span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * execScan.c 
 *    This code provides support for generalized relation scans. ExecScan 
 *    is passed a node and a pointer to a function to "do the right thing" 
 *    and return a tuple from the relation. ExecScan then does the tedious 
 *    stuff - checking the qualification and projecting the tuple 
 *    appropriately. 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * 
 * IDENTIFICATION 
 *    src/backend/executor/execScan.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"executor/executor.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"miscadmin.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/memutils.h"</span> 
 
 
<a name="LN25"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>tlist_matches_tupdesc</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>ps</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>tlist</span><span class='Delimiter'>, </span><a href="../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a> <span class='Declare_Parameter'>varno</span><span class='Delimiter'>, </span><a href="../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a> <span class='Declare_Parameter'>tupdesc</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * ExecScanFetch -- fetch next potential tuple 
 * 
 * This routine is concerned with substituting a test tuple if we are 
 * inside an EvalPlanQual recheck.  If we aren't, just execute 
 * the access method's next-tuple routine. 
 */ 
</span><span class='Keyword'>static inline </span><a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>* 
</span><a name="LN36"></a><span class='Declare_Function'>ExecScanFetch</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1055"><span class='Ref_to_Struct'>ScanState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, 
</span><a name="LN37"></a>              <a href="../../include/executor/executor.h.html#LN388"><span class='Ref_to_Typedef'>ExecScanAccessMtd</span></a> <span class='Declare_Parameter'>accessMtd</span><span class='Delimiter'>, 
</span><a name="LN38"></a>              <a href="../../include/executor/executor.h.html#LN389"><span class='Ref_to_Typedef'>ExecScanRecheckMtd</span></a> <span class='Declare_Parameter'>recheckMtd</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN40"></a>    <a href="../../include/nodes/execnodes.h.html#LN402"><span class='Ref_to_Struct'>EState</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>estate</span> <span class='Operator'>= </span><a href="execScan.c.html#LN36"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN814"><span class='Ref_to_Member'>state</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execScan.c.html#LN40"><span class='Ref_To_Local'>estate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN482"><span class='Ref_to_Member'>es_epqTuple</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * We are inside an EvalPlanQual recheck.  Return the test tuple if 
         * one is available, after rechecking any access-method-specific 
         * conditions. 
         */ 
</span><a name="LN49"></a>        <a href="../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Local'>scanrelid</span> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../include/nodes/plannodes.h.html#LN325"><span class='Ref_to_Struct'>Scan</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="execScan.c.html#LN36"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN812"><span class='Ref_to_Member'>plan</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>scanrelid<span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execScan.c.html#LN49"><span class='Ref_To_Local'>scanrelid</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN53"></a>            <a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Local'>slot</span> <span class='Operator'>= </span><a href="execScan.c.html#LN36"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1060"><span class='Ref_to_Member'>ss_ScanTupleSlot</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * This is a ForeignScan or CustomScan which has pushed down a 
             * join to the remote side.  The recheck method is responsible not 
             * only for rechecking the scan/join quals but also for storing 
             * the correct tuple in the slot. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="execScan.c.html#LN38"><span class='Ref_to_Parameter'>recheckMtd</span></a><span class='Parentheses'>) (</span><a href="execScan.c.html#LN36"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="execScan.c.html#LN53"><span class='Ref_To_Local'>slot</span></a><span class='Parentheses'>))</span> 
                <a href="../../include/executor/tuptable.h.html#LN154"><span class='Ref_to_Proto'>ExecClearTuple</span></a><span class='Parentheses'>(</span><a href="execScan.c.html#LN53"><span class='Ref_To_Local'>slot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* would not be returned by scan */ 
</span>            <span class='Control'>return</span> <a href="execScan.c.html#LN53"><span class='Ref_To_Local'>slot</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execScan.c.html#LN40"><span class='Ref_To_Local'>estate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN483"><span class='Ref_to_Member'>es_epqTupleSet</span></a><span class='Delimiter'>[</span><a href="execScan.c.html#LN49"><span class='Ref_To_Local'>scanrelid</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN67"></a>            <a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Local'>slot</span> <span class='Operator'>= </span><a href="execScan.c.html#LN36"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1060"><span class='Ref_to_Member'>ss_ScanTupleSlot</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Return empty slot if we already returned a tuple */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execScan.c.html#LN40"><span class='Ref_To_Local'>estate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN484"><span class='Ref_to_Member'>es_epqScanDone</span></a><span class='Delimiter'>[</span><a href="execScan.c.html#LN49"><span class='Ref_To_Local'>scanrelid</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>                <span class='Control'>return</span> <a href="../../include/executor/tuptable.h.html#LN154"><span class='Ref_to_Proto'>ExecClearTuple</span></a><span class='Parentheses'>(</span><a href="execScan.c.html#LN67"><span class='Ref_To_Local'>slot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* Else mark to remember that we shouldn't return more */ 
</span>            <a href="execScan.c.html#LN40"><span class='Ref_To_Local'>estate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN484"><span class='Ref_to_Member'>es_epqScanDone</span></a><span class='Delimiter'>[</span><a href="execScan.c.html#LN49"><span class='Ref_To_Local'>scanrelid</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Return empty slot if we haven't got a test tuple */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execScan.c.html#LN40"><span class='Ref_To_Local'>estate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN482"><span class='Ref_to_Member'>es_epqTuple</span></a><span class='Delimiter'>[</span><a href="execScan.c.html#LN49"><span class='Ref_To_Local'>scanrelid</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>                <span class='Control'>return</span> <a href="../../include/executor/tuptable.h.html#LN154"><span class='Ref_to_Proto'>ExecClearTuple</span></a><span class='Parentheses'>(</span><a href="execScan.c.html#LN67"><span class='Ref_To_Local'>slot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Store test tuple in the plan node's scan slot */ 
</span>            <a href="../../include/executor/tuptable.h.html#LN147"><span class='Ref_to_Proto'>ExecStoreTuple</span></a><span class='Parentheses'>(</span><a href="execScan.c.html#LN40"><span class='Ref_To_Local'>estate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN482"><span class='Ref_to_Member'>es_epqTuple</span></a><span class='Delimiter'>[</span><a href="execScan.c.html#LN49"><span class='Ref_To_Local'>scanrelid</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>], 
</span>                           <a href="execScan.c.html#LN67"><span class='Ref_To_Local'>slot</span></a><span class='Delimiter'>, </span><a href="../../include/storage/buf.h.html#LN24"><span class='Ref_to_Const'>InvalidBuffer</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Check if it meets the access-method conditions */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="execScan.c.html#LN38"><span class='Ref_to_Parameter'>recheckMtd</span></a><span class='Parentheses'>) (</span><a href="execScan.c.html#LN36"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="execScan.c.html#LN67"><span class='Ref_To_Local'>slot</span></a><span class='Parentheses'>))</span> 
                <a href="../../include/executor/tuptable.h.html#LN154"><span class='Ref_to_Proto'>ExecClearTuple</span></a><span class='Parentheses'>(</span><a href="execScan.c.html#LN67"><span class='Ref_To_Local'>slot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* would not be returned by scan */ 
</span> 
            <span class='Control'>return</span> <a href="execScan.c.html#LN67"><span class='Ref_To_Local'>slot</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if estate-&GT;es_epqTupleSe... &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if estate-&GT;es_epqTuple!=... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Run the node-type-specific access method function to get the next tuple 
     */ 
</span>    <span class='Control'>return</span> <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="execScan.c.html#LN37"><span class='Ref_to_Parameter'>accessMtd</span></a><span class='Parentheses'>) (</span><a href="execScan.c.html#LN36"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ExecScanFetch &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *      ExecScan 
 * 
 *      Scans the relation using the 'access method' indicated and 
 *      returns the next qualifying tuple in the direction specified 
 *      in the global variable ExecDirection. 
 *      The access method returns the next tuple and ExecScan() is 
 *      responsible for checking the tuple returned against the qual-clause. 
 * 
 *      A 'recheck method' must also be provided that can check an 
 *      arbitrary tuple of the relation against any qual conditions 
 *      that are implemented internal to the access method. 
 * 
 *      Conditions: 
 *        -- the "cursor" maintained by the AMI is positioned at the tuple 
 *           returned previously. 
 * 
 *      Initial States: 
 *        -- the relation indicated is opened for scanning so that the 
 *           "cursor" is positioned before the first qualifying tuple. 
 * ---------------------------------------------------------------- 
 */ 
</span><a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>* 
</span><a name="LN120"></a><span class='Declare_Function'>ExecScan</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1055"><span class='Ref_to_Struct'>ScanState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, 
</span><a name="LN121"></a>         <a href="../../include/executor/executor.h.html#LN388"><span class='Ref_to_Typedef'>ExecScanAccessMtd</span></a> <span class='Declare_Parameter'>accessMtd</span><span class='Delimiter'>,</span>   <span class='Comment_Single_Line'>/* function returning a tuple */ 
</span><a name="LN122"></a>         <a href="../../include/executor/executor.h.html#LN389"><span class='Ref_to_Typedef'>ExecScanRecheckMtd</span></a> <span class='Declare_Parameter'>recheckMtd</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN124"></a>    <a href="../../include/nodes/execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Local'>econtext</span><span class='Delimiter'>; 
</span><a name="LN125"></a>    <a href="../../include/nodes/execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>qual</span><span class='Delimiter'>; 
</span><a name="LN126"></a>    <a href="../../include/nodes/execnodes.h.html#LN291"><span class='Ref_to_Struct'>ProjectionInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>projInfo</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Fetch data from node 
     */ 
</span>    <a href="execScan.c.html#LN125"><span class='Ref_To_Local'>qual</span></a> <span class='Operator'>= </span><a href="execScan.c.html#LN120"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN826"><span class='Ref_to_Member'>qual</span></a><span class='Delimiter'>; 
</span>    <a href="execScan.c.html#LN126"><span class='Ref_To_Local'>projInfo</span></a> <span class='Operator'>= </span><a href="execScan.c.html#LN120"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN843"><span class='Ref_to_Member'>ps_ProjInfo</span></a><span class='Delimiter'>; 
</span>    <a href="execScan.c.html#LN124"><span class='Ref_To_Local'>econtext</span></a> <span class='Operator'>= </span><a href="execScan.c.html#LN120"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN842"><span class='Ref_to_Member'>ps_ExprContext</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we have neither a qual to check nor a projection to do, just skip 
     * all the overhead and return the raw scan tuple. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="execScan.c.html#LN125"><span class='Ref_To_Local'>qual</span></a> <span class='Operator'>&& !</span><a href="execScan.c.html#LN126"><span class='Ref_To_Local'>projInfo</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../include/executor/executor.h.html#LN449"><span class='Ref_to_Macro'>ResetExprContext</span></a><span class='Parentheses'>(</span><a href="execScan.c.html#LN124"><span class='Ref_To_Local'>econtext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <a href="execScan.c.html#LN35"><span class='Ref_to_Func'>ExecScanFetch</span></a><span class='Parentheses'>(</span><a href="execScan.c.html#LN120"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="execScan.c.html#LN121"><span class='Ref_to_Parameter'>accessMtd</span></a><span class='Delimiter'>, </span><a href="execScan.c.html#LN122"><span class='Ref_to_Parameter'>recheckMtd</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Reset per-tuple memory context to free any expression evaluation 
     * storage allocated in the previous tuple cycle. 
     */ 
</span>    <a href="../../include/executor/executor.h.html#LN449"><span class='Ref_to_Macro'>ResetExprContext</span></a><span class='Parentheses'>(</span><a href="execScan.c.html#LN124"><span class='Ref_To_Local'>econtext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * get a tuple from the access method.  Loop until we obtain a tuple that 
     * passes the qualification. 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>;;</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN157"></a>        <a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Local'>slot</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/miscadmin.h.html#LN99"><span class='Ref_to_Macro'>CHECK_FOR_INTERRUPTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <a href="execScan.c.html#LN157"><span class='Ref_To_Local'>slot</span></a> <span class='Operator'>= </span><a href="execScan.c.html#LN35"><span class='Ref_to_Func'>ExecScanFetch</span></a><span class='Parentheses'>(</span><a href="execScan.c.html#LN120"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="execScan.c.html#LN121"><span class='Ref_to_Parameter'>accessMtd</span></a><span class='Delimiter'>, </span><a href="execScan.c.html#LN122"><span class='Ref_to_Parameter'>recheckMtd</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * if the slot returned by the accessMtd contains NULL, then it means 
         * there is nothing more to scan so we just return an empty slot, 
         * being careful to use the projection result slot so it has correct 
         * tupleDesc. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/executor/tuptable.h.html#LN137"><span class='Ref_to_Macro'>TupIsNull</span></a><span class='Parentheses'>(</span><a href="execScan.c.html#LN157"><span class='Ref_To_Local'>slot</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execScan.c.html#LN126"><span class='Ref_To_Local'>projInfo</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>return</span> <a href="../../include/executor/tuptable.h.html#LN154"><span class='Ref_to_Proto'>ExecClearTuple</span></a><span class='Parentheses'>(</span><a href="execScan.c.html#LN126"><span class='Ref_To_Local'>projInfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN295"><span class='Ref_to_Member'>pi_state</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN68"><span class='Ref_to_Member'>resultslot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <span class='Control'>return</span> <a href="execScan.c.html#LN157"><span class='Ref_To_Local'>slot</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * place the current tuple into the expr context 
         */ 
</span>        <a href="execScan.c.html#LN124"><span class='Ref_To_Local'>econtext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN196"><span class='Ref_to_Member'>ecxt_scantuple</span></a> <span class='Operator'>= </span><a href="execScan.c.html#LN157"><span class='Ref_To_Local'>slot</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * check that the current tuple satisfies the qual-clause 
         * 
         * check for non-null qual here to avoid a function call to ExecQual() 
         * when the qual is null ... saves only a few cycles, but they add up 
         * ... 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execScan.c.html#LN125"><span class='Ref_To_Local'>qual</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>|| </span><a href="../../include/executor/executor.h.html#LN344"><span class='Ref_to_Func'>ExecQual</span></a><span class='Parentheses'>(</span><a href="execScan.c.html#LN125"><span class='Ref_To_Local'>qual</span></a><span class='Delimiter'>, </span><a href="execScan.c.html#LN124"><span class='Ref_To_Local'>econtext</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Found a satisfactory scan tuple. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execScan.c.html#LN126"><span class='Ref_To_Local'>projInfo</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * Form a projection tuple, store it in the result tuple slot 
                 * and return it. 
                 */ 
</span>                <span class='Control'>return</span> <a href="../../include/executor/executor.h.html#LN307"><span class='Ref_to_Func'>ExecProject</span></a><span class='Parentheses'>(</span><a href="execScan.c.html#LN126"><span class='Ref_To_Local'>projInfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * Here, we aren't projecting, so just return scan tuple. 
                 */ 
</span>                <span class='Control'>return</span> <a href="execScan.c.html#LN157"><span class='Ref_To_Local'>slot</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if qual==NULL||ExecQual(... &raquo; </span> 
        <span class='Control'>else</span> 
            <a href="../../include/nodes/execnodes.h.html#LN857"><span class='Ref_to_Macro'>InstrCountFiltered1</span></a><span class='Parentheses'>(</span><a href="execScan.c.html#LN120"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Tuple fails qual, so free per-tuple memory and try again. 
         */ 
</span>        <a href="../../include/executor/executor.h.html#LN449"><span class='Ref_to_Macro'>ResetExprContext</span></a><span class='Parentheses'>(</span><a href="execScan.c.html#LN124"><span class='Ref_To_Local'>econtext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for ;; &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end ExecScan &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * ExecAssignScanProjectionInfo 
 *      Set up projection info for a scan node, if necessary. 
 * 
 * We can avoid a projection step if the requested tlist exactly matches 
 * the underlying tuple type.  If so, we just set ps_ProjInfo to NULL. 
 * Note that this case occurs not only for simple "SELECT * FROM ...", but 
 * also in most cases where there are joins or other processing nodes above 
 * the scan node, because the planner will preferentially generate a matching 
 * tlist. 
 * 
 * ExecAssignScanType must have been called already. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN234"></a><span class='Declare_Function'>ExecAssignScanProjectionInfo</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1055"><span class='Ref_to_Struct'>ScanState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN236"></a>    <a href="../../include/nodes/plannodes.h.html#LN325"><span class='Ref_to_Struct'>Scan</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>scan</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/plannodes.h.html#LN325"><span class='Ref_to_Struct'>Scan</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="execScan.c.html#LN234"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN812"><span class='Ref_to_Member'>plan</span></a><span class='Delimiter'>; 
</span> 
    <a href="execScan.c.html#LN245"><span class='Ref_to_Func'>ExecAssignScanProjectionInfoWithVarno</span></a><span class='Parentheses'>(</span><a href="execScan.c.html#LN234"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="execScan.c.html#LN236"><span class='Ref_To_Local'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN328"><span class='Ref_to_Member'>scanrelid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * ExecAssignScanProjectionInfoWithVarno 
 *      As above, but caller can specify varno expected in Vars in the tlist. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN246"></a><span class='Declare_Function'>ExecAssignScanProjectionInfoWithVarno</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1055"><span class='Ref_to_Struct'>ScanState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><a href="../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a> <span class='Declare_Parameter'>varno</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN248"></a>    <a href="../../include/nodes/plannodes.h.html#LN325"><span class='Ref_to_Struct'>Scan</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>scan</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/plannodes.h.html#LN325"><span class='Ref_to_Struct'>Scan</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="execScan.c.html#LN246"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN812"><span class='Ref_to_Member'>plan</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execScan.c.html#LN25"><span class='Ref_to_Proto'>tlist_matches_tupdesc</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="execScan.c.html#LN246"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Delimiter'>, 
</span>                              <a href="execScan.c.html#LN248"><span class='Ref_To_Local'>scan</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN327"><span class='Ref_to_Member'>plan</span></a><span class='Operator'>.</span><a href="../../include/nodes/plannodes.h.html#LN143"><span class='Ref_to_Member'>targetlist</span></a><span class='Delimiter'>, 
</span>                              <a href="execScan.c.html#LN246"><span class='Ref_to_Parameter'>varno</span></a><span class='Delimiter'>, 
</span>                              <a href="execScan.c.html#LN246"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1060"><span class='Ref_to_Member'>ss_ScanTupleSlot</span></a><span class='Operator'>-&GT;</span><a href="../../include/executor/tuptable.h.html#LN120"><span class='Ref_to_Member'>tts_tupleDescriptor</span></a><span class='Parentheses'>))</span> 
        <a href="execScan.c.html#LN246"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN843"><span class='Ref_to_Member'>ps_ProjInfo</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="../../include/executor/executor.h.html#LN474"><span class='Ref_to_Proto'>ExecAssignProjectionInfo</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="execScan.c.html#LN246"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Delimiter'>, 
</span>                                 <a href="execScan.c.html#LN246"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1060"><span class='Ref_to_Member'>ss_ScanTupleSlot</span></a><span class='Operator'>-&GT;</span><a href="../../include/executor/tuptable.h.html#LN120"><span class='Ref_to_Member'>tts_tupleDescriptor</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Keyword'>static bool 
</span><a name="LN261"></a><span class='Declare_Function'>tlist_matches_tupdesc</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>ps</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>tlist</span><span class='Delimiter'>, </span><a href="../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a> <span class='Declare_Parameter'>varno</span><span class='Delimiter'>, </span><a href="../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a> <span class='Declare_Parameter'>tupdesc</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN263"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numattrs</span> <span class='Operator'>= </span><a href="execScan.c.html#LN261"><span class='Ref_to_Parameter'>tupdesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/tupdesc.h.html#LN72"><span class='Ref_to_Member'>natts</span></a><span class='Delimiter'>; 
</span><a name="LN264"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>attrno</span><span class='Delimiter'>; 
</span><a name="LN265"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>hasoid</span><span class='Delimiter'>; 
</span><a name="LN266"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>tlist_item</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="execScan.c.html#LN261"><span class='Ref_to_Parameter'>tlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Check the tlist attributes */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="execScan.c.html#LN264"><span class='Ref_To_Local'>attrno</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="execScan.c.html#LN264"><span class='Ref_To_Local'>attrno</span></a> <span class='Operator'>&LT;= </span><a href="execScan.c.html#LN263"><span class='Ref_To_Local'>numattrs</span></a><span class='Delimiter'>; </span><a href="execScan.c.html#LN264"><span class='Ref_To_Local'>attrno</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN271"></a>        <a href="../../include/catalog/pg_attribute.h.html#LN186"><span class='Ref_to_Typedef'>Form_pg_attribute</span></a> <span class='Declare_Local'>att_tup</span> <span class='Operator'>= </span><a href="execScan.c.html#LN261"><span class='Ref_to_Parameter'>tupdesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/tupdesc.h.html#LN73"><span class='Ref_to_Member'>attrs</span></a><span class='Delimiter'>[</span><a href="execScan.c.html#LN264"><span class='Ref_To_Local'>attrno</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]; 
</span><a name="LN272"></a>        <a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>var</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execScan.c.html#LN266"><span class='Ref_To_Local'>tlist_item</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* tlist too short */ 
</span>        <a href="execScan.c.html#LN272"><span class='Ref_To_Local'>var</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) ((</span><a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="execScan.c.html#LN266"><span class='Ref_To_Local'>tlist_item</span></a><span class='Parentheses'>))</span><span class='Operator'>-&GT;</span>expr<span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="execScan.c.html#LN272"><span class='Ref_To_Local'>var</span></a> <span class='Operator'>|| !</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="execScan.c.html#LN272"><span class='Ref_To_Local'>var</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* tlist item not a Var */ 
</span>        <span class='Comment_Multi_Line'>/* if these Asserts fail, planner messed up */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="execScan.c.html#LN272"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN165"><span class='Ref_to_Member'>varno</span></a> <span class='Operator'>== </span><a href="execScan.c.html#LN261"><span class='Ref_to_Parameter'>varno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="execScan.c.html#LN272"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN172"><span class='Ref_to_Member'>varlevelsup</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execScan.c.html#LN272"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN167"><span class='Ref_to_Member'>varattno</span></a> <span class='Operator'>!= </span><a href="execScan.c.html#LN264"><span class='Ref_To_Local'>attrno</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* out of order */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execScan.c.html#LN271"><span class='Ref_To_Local'>att_tup</span></a><span class='Operator'>-&GT;</span>attisdropped<span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* table contains dropped columns */ 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Note: usually the Var's type should match the tupdesc exactly, but 
         * in situations involving unions of columns that have different 
         * typmods, the Var may have come from above the union and hence have 
         * typmod -1.  This is a legitimate situation since the Var still 
         * describes the column, just not as exactly as the tupdesc does. We 
         * could change the planner to prevent it, but it'd then insert 
         * projection steps just to convert from specific typmod to typmod -1, 
         * which is pretty silly. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execScan.c.html#LN272"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN169"><span class='Ref_to_Member'>vartype</span></a> <span class='Operator'>!= </span><a href="execScan.c.html#LN271"><span class='Ref_To_Local'>att_tup</span></a><span class='Operator'>-&GT;</span>atttypid <span class='Operator'>|| 
</span>            <span class='Parentheses'>(</span><a href="execScan.c.html#LN272"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN170"><span class='Ref_to_Member'>vartypmod</span></a> <span class='Operator'>!= </span><a href="execScan.c.html#LN271"><span class='Ref_To_Local'>att_tup</span></a><span class='Operator'>-&GT;</span>atttypmod <span class='Operator'>&& 
</span>             <a href="execScan.c.html#LN272"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN170"><span class='Ref_to_Member'>vartypmod</span></a> <span class='Operator'>!= -</span><span class='Number'>1</span><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* type mismatch */ 
</span> 
        <a href="execScan.c.html#LN266"><span class='Ref_To_Local'>tlist_item</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="execScan.c.html#LN266"><span class='Ref_To_Local'>tlist_item</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for attrno=1;attrno&LT;=numa... &raquo; </span> 
 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execScan.c.html#LN266"><span class='Ref_To_Local'>tlist_item</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* tlist too long */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the plan context requires a particular hasoid setting, then that has 
     * to match, too. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/executor/executor.h.html#LN187"><span class='Ref_to_Proto'>ExecContextForcesOids</span></a><span class='Parentheses'>(</span><a href="execScan.c.html#LN261"><span class='Ref_to_Parameter'>ps</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="execScan.c.html#LN265"><span class='Ref_To_Local'>hasoid</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>        <a href="execScan.c.html#LN265"><span class='Ref_To_Local'>hasoid</span></a> <span class='Operator'>!= </span><a href="execScan.c.html#LN261"><span class='Ref_to_Parameter'>tupdesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/tupdesc.h.html#LN78"><span class='Ref_to_Member'>tdhasoid</span></a><span class='Parentheses'>)</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end tlist_matches_tupdesc &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * ExecScanReScan 
 * 
 * This must be called within the ReScan function of any plan node type 
 * that uses ExecScan(). 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN326"></a><span class='Declare_Function'>ExecScanReScan</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1055"><span class='Ref_to_Struct'>ScanState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN328"></a>    <a href="../../include/nodes/execnodes.h.html#LN402"><span class='Ref_to_Struct'>EState</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>estate</span> <span class='Operator'>= </span><a href="execScan.c.html#LN326"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN814"><span class='Ref_to_Member'>state</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Rescan EvalPlanQual tuple if we're inside an EvalPlanQual recheck */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execScan.c.html#LN328"><span class='Ref_To_Local'>estate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN484"><span class='Ref_to_Member'>es_epqScanDone</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN333"></a>        <a href="../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Local'>scanrelid</span> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../include/nodes/plannodes.h.html#LN325"><span class='Ref_to_Struct'>Scan</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="execScan.c.html#LN326"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN812"><span class='Ref_to_Member'>plan</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>scanrelid<span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="execScan.c.html#LN333"><span class='Ref_To_Local'>scanrelid</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <a href="execScan.c.html#LN328"><span class='Ref_To_Local'>estate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN484"><span class='Ref_to_Member'>es_epqScanDone</span></a><span class='Delimiter'>[</span><a href="execScan.c.html#LN333"><span class='Ref_To_Local'>scanrelid</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span><a name="LN339"></a>            <a href="../../include/nodes/bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>relids</span><span class='Delimiter'>; 
</span><a name="LN340"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>rtindex</span> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * If an FDW or custom scan provider has replaced the join with a 
             * scan, there are multiple RTIs; reset the epqScanDone flag for 
             * all of them. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="execScan.c.html#LN326"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN812"><span class='Ref_to_Member'>plan</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/plannodes.h.html#LN594"><span class='Ref_to_Struct'>ForeignScan</span></a><span class='Parentheses'>))</span> 
                <a href="execScan.c.html#LN339"><span class='Ref_To_Local'>relids</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../include/nodes/plannodes.h.html#LN594"><span class='Ref_to_Struct'>ForeignScan</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="execScan.c.html#LN326"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN812"><span class='Ref_to_Member'>plan</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>fs_relids<span class='Delimiter'>; 
</span>            <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="execScan.c.html#LN326"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN812"><span class='Ref_to_Member'>plan</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/plannodes.h.html#LN623"><span class='Ref_to_Struct'>CustomScan</span></a><span class='Parentheses'>))</span> 
                <a href="execScan.c.html#LN339"><span class='Ref_To_Local'>relids</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../include/nodes/plannodes.h.html#LN623"><span class='Ref_to_Struct'>CustomScan</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="execScan.c.html#LN326"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN812"><span class='Ref_to_Member'>plan</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>custom_relids<span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unexpected scan node: %d"</span><span class='Delimiter'>, 
</span>                     <span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="../../include/nodes/nodes.h.html#LN513"><span class='Ref_to_Macro'>nodeTag</span></a><span class='Parentheses'>(</span><a href="execScan.c.html#LN326"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN812"><span class='Ref_to_Member'>plan</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>while</span> <span class='Parentheses'>((</span><a href="execScan.c.html#LN340"><span class='Ref_To_Local'>rtindex</span></a> <span class='Operator'>= </span><a href="../../include/nodes/bitmapset.h.html#LN98"><span class='Ref_to_Proto'>bms_next_member</span></a><span class='Parentheses'>(</span><a href="execScan.c.html#LN339"><span class='Ref_To_Local'>relids</span></a><span class='Delimiter'>, </span><a href="execScan.c.html#LN340"><span class='Ref_To_Local'>rtindex</span></a><span class='Parentheses'>))</span> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="execScan.c.html#LN340"><span class='Ref_To_Local'>rtindex</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="execScan.c.html#LN328"><span class='Ref_To_Local'>estate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN484"><span class='Ref_to_Member'>es_epqScanDone</span></a><span class='Delimiter'>[</span><a href="execScan.c.html#LN340"><span class='Ref_To_Local'>rtindex</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if estate-&GT;es_epqScanDon... &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end ExecScanReScan &raquo; </span> 
</pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>