<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\executor\nodeAgg.c</title>
<LINK REL=StyleSheet HREF="../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\executor\nodeAgg.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:39 2017
</td></tr>
<tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * nodeAgg.c 
 *    Routines to handle aggregate nodes. 
 * 
 *    ExecAgg normally evaluates each aggregate in the following steps: 
 * 
 *       transvalue = initcond 
 *       foreach input_tuple do 
 *          transvalue = transfunc(transvalue, input_value(s)) 
 *       result = finalfunc(transvalue, direct_argument(s)) 
 * 
 *    If a finalfunc is not supplied then the result is just the ending 
 *    value of transvalue. 
 * 
 *    Other behaviors can be selected by the "aggsplit" mode, which exists 
 *    to support partial aggregation.  It is possible to: 
 *    * Skip running the finalfunc, so that the output is always the 
 *    final transvalue state. 
 *    * Substitute the combinefunc for the transfunc, so that transvalue 
 *    states (propagated up from a child partial-aggregation step) are merged 
 *    rather than processing raw input rows.  (The statements below about 
 *    the transfunc apply equally to the combinefunc, when it's selected.) 
 *    * Apply the serializefunc to the output values (this only makes sense 
 *    when skipping the finalfunc, since the serializefunc works on the 
 *    transvalue data type). 
 *    * Apply the deserializefunc to the input values (this only makes sense 
 *    when using the combinefunc, for similar reasons). 
 *    It is the planner's responsibility to connect up Agg nodes using these 
 *    alternate behaviors in a way that makes sense, with partial aggregation 
 *    results being fed to nodes that expect them. 
 * 
 *    If a normal aggregate call specifies DISTINCT or ORDER BY, we sort the 
 *    input tuples and eliminate duplicates (if required) before performing 
 *    the above-depicted process.  (However, we don't do that for ordered-set 
 *    aggregates; their "ORDER BY" inputs are ordinary aggregate arguments 
 *    so far as this module is concerned.)  Note that partial aggregation 
 *    is not supported in these cases, since we couldn't ensure global 
 *    ordering or distinctness of the inputs. 
 * 
 *    If transfunc is marked "strict" in pg_proc and initcond is NULL, 
 *    then the first non-NULL input_value is assigned directly to transvalue, 
 *    and transfunc isn't applied until the second non-NULL input_value. 
 *    The agg's first input type and transtype must be the same in this case! 
 * 
 *    If transfunc is marked "strict" then NULL input_values are skipped, 
 *    keeping the previous transvalue.  If transfunc is not strict then it 
 *    is called for every input tuple and must deal with NULL initcond 
 *    or NULL input_values for itself. 
 * 
 *    If finalfunc is marked "strict" then it is not called when the 
 *    ending transvalue is NULL, instead a NULL result is created 
 *    automatically (this is just the usual handling of strict functions, 
 *    of course).  A non-strict finalfunc can make its own choice of 
 *    what to return for a NULL ending transvalue. 
 * 
 *    Ordered-set aggregates are treated specially in one other way: we 
 *    evaluate any "direct" arguments and pass them to the finalfunc along 
 *    with the transition value. 
 * 
 *    A finalfunc can have additional arguments beyond the transvalue and 
 *    any "direct" arguments, corresponding to the input arguments of the 
 *    aggregate.  These are always just passed as NULL.  Such arguments may be 
 *    needed to allow resolution of a polymorphic aggregate's result type. 
 * 
 *    We compute aggregate input expressions and run the transition functions 
 *    in a temporary econtext (aggstate-&GT;tmpcontext).  This is reset at least 
 *    once per input tuple, so when the transvalue datatype is 
 *    pass-by-reference, we have to be careful to copy it into a longer-lived 
 *    memory context, and free the prior value to avoid memory leakage.  We 
 *    store transvalues in another set of econtexts, aggstate-&GT;aggcontexts 
 *    (one per grouping set, see below), which are also used for the hashtable 
 *    structures in AGG_HASHED mode.  These econtexts are rescanned, not just 
 *    reset, at group boundaries so that aggregate transition functions can 
 *    register shutdown callbacks via AggRegisterCallback. 
 * 
 *    The node's regular econtext (aggstate-&GT;ss.ps.ps_ExprContext) is used to 
 *    run finalize functions and compute the output tuple; this context can be 
 *    reset once per output tuple. 
 * 
 *    The executor's AggState node is passed as the fmgr "context" value in 
 *    all transfunc and finalfunc calls.  It is not recommended that the 
 *    transition functions look at the AggState node directly, but they can 
 *    use AggCheckCallContext() to verify that they are being called by 
 *    nodeAgg.c (and not as ordinary SQL functions).  The main reason a 
 *    transition function might want to know this is so that it can avoid 
 *    palloc'ing a fixed-size pass-by-ref transition value on every call: 
 *    it can instead just scribble on and return its left input.  Ordinarily 
 *    it is completely forbidden for functions to modify pass-by-ref inputs, 
 *    but in the aggregate case we know the left input is either the initial 
 *    transition value or a previous function result, and in either case its 
 *    value need not be preserved.  See int8inc() for an example.  Notice that 
 *    advance_transition_function() is coded to avoid a data copy step when 
 *    the previous transition value pointer is returned.  It is also possible 
 *    to avoid repeated data copying when the transition value is an expanded 
 *    object: to do that, the transition function must take care to return 
 *    an expanded object that is in a child context of the memory context 
 *    returned by AggCheckCallContext().  Also, some transition functions want 
 *    to store working state in addition to the nominal transition value; they 
 *    can use the memory context returned by AggCheckCallContext() to do that. 
 * 
 *    Note: AggCheckCallContext() is available as of PostgreSQL 9.0.  The 
 *    AggState is available as context in earlier releases (back to 8.1), 
 *    but direct examination of the node is needed to use it before 9.0. 
 * 
 *    As of 9.4, aggregate transition functions can also use AggGetAggref() 
 *    to get hold of the Aggref expression node for their aggregate call. 
 *    This is mainly intended for ordered-set aggregates, which are not 
 *    supported as window functions.  (A regular aggregate function would 
 *    need some fallback logic to use this, since there's no Aggref node 
 *    for a window function.) 
 * 
 *    Grouping sets: 
 * 
 *    A list of grouping sets which is structurally equivalent to a ROLLUP 
 *    clause (e.g. (a,b,c), (a,b), (a)) can be processed in a single pass over 
 *    ordered data.  We do this by keeping a separate set of transition values 
 *    for each grouping set being concurrently processed; for each input tuple 
 *    we update them all, and on group boundaries we reset those states 
 *    (starting at the front of the list) whose grouping values have changed 
 *    (the list of grouping sets is ordered from most specific to least 
 *    specific). 
 * 
 *    Where more complex grouping sets are used, we break them down into 
 *    "phases", where each phase has a different sort order (except phase 0 
 *    which is reserved for hashing).  During each phase but the last, the 
 *    input tuples are additionally stored in a tuplesort which is keyed to the 
 *    next phase's sort order; during each phase but the first, the input 
 *    tuples are drawn from the previously sorted data.  (The sorting of the 
 *    data for the first phase is handled by the planner, as it might be 
 *    satisfied by underlying nodes.) 
 * 
 *    Hashing can be mixed with sorted grouping.  To do this, we have an 
 *    AGG_MIXED strategy that populates the hashtables during the first sorted 
 *    phase, and switches to reading them out after completing all sort phases. 
 *    We can also support AGG_HASHED with multiple hash tables and no sorting 
 *    at all. 
 * 
 *    From the perspective of aggregate transition and final functions, the 
 *    only issue regarding grouping sets is this: a single call site (flinfo) 
 *    of an aggregate function may be used for updating several different 
 *    transition values in turn. So the function must not cache in the flinfo 
 *    anything which logically belongs as part of the transition value (most 
 *    importantly, the memory context in which the transition value exists). 
 *    The support API functions (AggCheckCallContext, AggRegisterCallback) are 
 *    sensitive to the grouping set for which the aggregate function is 
 *    currently being called. 
 * 
 *    Plan structure: 
 * 
 *    What we get from the planner is actually one "real" Agg node which is 
 *    part of the plan tree proper, but which optionally has an additional list 
 *    of Agg nodes hung off the side via the "chain" field.  This is because an 
 *    Agg node happens to be a convenient representation of all the data we 
 *    need for grouping sets. 
 * 
 *    For many purposes, we treat the "real" node as if it were just the first 
 *    node in the chain.  The chain must be ordered such that hashed entries 
 *    come before sorted/plain entries; the real node is marked AGG_MIXED if 
 *    there are both types present (in which case the real node describes one 
 *    of the hashed groupings, other AGG_HASHED nodes may optionally follow in 
 *    the chain, followed in turn by AGG_SORTED or (one) AGG_PLAIN node).  If 
 *    the real node is marked AGG_HASHED or AGG_SORTED, then all the chained 
 *    nodes must be of the same type; if it is AGG_PLAIN, there can be no 
 *    chained nodes. 
 * 
 *    We collect all hashed nodes into a single "phase", numbered 0, and create 
 *    a sorted phase (numbered 1..n) for each AGG_SORTED or AGG_PLAIN node. 
 *    Phase 0 is allocated even if there are no hashes, but remains unused in 
 *    that case. 
 * 
 *    AGG_HASHED nodes actually refer to only a single grouping set each, 
 *    because for each hashed grouping we need a separate grpColIdx and 
 *    numGroups estimate.  AGG_SORTED nodes represent a "rollup", a list of 
 *    grouping sets that share a sort order.  Each AGG_SORTED node other than 
 *    the first one has an associated Sort node which describes the sort order 
 *    to be used; the first sorted node takes its input from the outer subtree, 
 *    which the planner has already arranged to provide ordered data. 
 * 
 *    Memory and ExprContext usage: 
 * 
 *    Because we're accumulating aggregate values across input rows, we need to 
 *    use more memory contexts than just simple input/output tuple contexts. 
 *    In fact, for a rollup, we need a separate context for each grouping set 
 *    so that we can reset the inner (finer-grained) aggregates on their group 
 *    boundaries while continuing to accumulate values for outer 
 *    (coarser-grained) groupings.  On top of this, we might be simultaneously 
 *    populating hashtables; however, we only need one context for all the 
 *    hashtables. 
 * 
 *    So we create an array, aggcontexts, with an ExprContext for each grouping 
 *    set in the largest rollup that we're going to process, and use the 
 *    per-tuple memory context of those ExprContexts to store the aggregate 
 *    transition values.  hashcontext is the single context created to support 
 *    all hash tables. 
 * 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * IDENTIFICATION 
 *    src/backend/executor/nodeAgg.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span> 
<span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"access/htup_details.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/objectaccess.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_aggregate.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_proc.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_type.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"executor/executor.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"executor/nodeAgg.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"miscadmin.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/makefuncs.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/nodeFuncs.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/clauses.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/tlist.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_agg.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_coerce.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/acl.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/builtins.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/lsyscache.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/memutils.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/syscache.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/tuplesort.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/datum.h"</span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * AggStatePerTransData - per aggregate state value information 
 * 
 * Working state for updating the aggregate's state value, by calling the 
 * transition function with an input row. This struct does not store the 
 * information needed to produce the final aggregate result from the transition 
 * state, that's stored in AggStatePerAggData instead. This separation allows 
 * multiple aggregate results to be produced from a single state value. 
 */ 
</span><a name="LN240"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AggStatePerTransData</span> 
<span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * These values are set up during ExecInitAgg() and do not change 
     * thereafter: 
     */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Link to an Aggref expr this state value is for. 
     * 
     * There can be multiple Aggref's sharing the same state value, as long as 
     * the inputs and transition function are identical. This points to the 
     * first one of them. 
     */ 
</span><a name="LN254"></a>    <a href="../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a>     <span class='Operator'>*</span><span class='Declare_Member'>aggref</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Nominal number of arguments for aggregate function.  For plain aggs, 
     * this excludes any ORDER BY expressions.  For ordered-set aggs, this 
     * counts both the direct and aggregated (ORDER BY) arguments. 
     */ 
</span><a name="LN261"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>numArguments</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Number of aggregated input columns.  This includes ORDER BY expressions 
     * in both the plain-agg and ordered-set cases.  Ordered-set direct args 
     * are not counted, though. 
     */ 
</span><a name="LN268"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>numInputs</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* offset of input columns in AggState-&GT;evalslot */ 
</span><a name="LN271"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>inputoff</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Number of aggregated input columns to pass to the transfn.  This 
     * includes the ORDER BY columns for ordered-set aggs, but not for plain 
     * aggs.  (This doesn't count the transition state value!) 
     */ 
</span><a name="LN278"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>numTransInputs</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Oid of the state transition or combine function */ 
</span><a name="LN281"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>transfn_oid</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Oid of the serialization function or InvalidOid */ 
</span><a name="LN284"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>serialfn_oid</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Oid of the deserialization function or InvalidOid */ 
</span><a name="LN287"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>deserialfn_oid</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Oid of state value's datatype */ 
</span><a name="LN290"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>aggtranstype</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* ExprStates of the FILTER and argument expressions. */ 
</span><a name="LN293"></a>    <a href="../../include/nodes/execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a>  <span class='Operator'>*</span><span class='Declare_Member'>aggfilter</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* state of FILTER expression, if any */ 
</span><a name="LN294"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>aggdirectargs</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* states of direct-argument expressions */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * fmgr lookup data for transition function or combine function.  Note in 
     * particular that the fn_strict flag is kept here. 
     */ 
</span><a name="LN300"></a>    <a href="../../include/fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a>    <span class='Declare_Member'>transfn</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* fmgr lookup data for serialization function */ 
</span><a name="LN303"></a>    <a href="../../include/fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a>    <span class='Declare_Member'>serialfn</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* fmgr lookup data for deserialization function */ 
</span><a name="LN306"></a>    <a href="../../include/fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a>    <span class='Declare_Member'>deserialfn</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Input collation derived for aggregate */ 
</span><a name="LN309"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>aggCollation</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* number of sorting columns */ 
</span><a name="LN312"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>numSortCols</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* number of sorting columns to consider in DISTINCT comparisons */ 
</span>    <span class='Comment_Multi_Line'>/* (this is either zero or the same as numSortCols) */ 
</span><a name="LN316"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>numDistinctCols</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* deconstructed sorting information (arrays of length numSortCols) */ 
</span><a name="LN319"></a>    <a href="../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a> <span class='Operator'>*</span><span class='Declare_Member'>sortColIdx</span><span class='Delimiter'>; 
</span><a name="LN320"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>        <span class='Operator'>*</span><span class='Declare_Member'>sortOperators</span><span class='Delimiter'>; 
</span><a name="LN321"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>        <span class='Operator'>*</span><span class='Declare_Member'>sortCollations</span><span class='Delimiter'>; 
</span><a name="LN322"></a>    <span class='Keyword'>bool</span>       <span class='Operator'>*</span><span class='Declare_Member'>sortNullsFirst</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * fmgr lookup data for input columns' equality operators --- only 
     * set/used when aggregate has DISTINCT flag.  Note that these are in 
     * order of sort column index, not parameter index. 
     */ 
</span><a name="LN329"></a>    <a href="../../include/fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>equalfns</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* array of length numDistinctCols */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * initial value from pg_aggregate entry 
     */ 
</span><a name="LN334"></a>    <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Member'>initValue</span><span class='Delimiter'>; 
</span><a name="LN335"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>initValueIsNull</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We need the len and byval info for the agg's input and transition data 
     * types in order to know how to copy/delete values. 
     * 
     * Note that the info for the input type is used only when handling 
     * DISTINCT aggs with just one argument, so there is only one input type. 
     */ 
</span><a name="LN344"></a>    <a href="../../include/c.h.html#LN254"><span class='Ref_to_Typedef'>int16</span></a>       <span class='Declare_Member'>inputtypeLen</span><span class='Delimiter'>, 
</span><a name="LN345"></a>                <span class='Declare_Member'>transtypeLen</span><span class='Delimiter'>; 
</span><a name="LN346"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>inputtypeByVal</span><span class='Delimiter'>, 
</span><a name="LN347"></a>                <span class='Declare_Member'>transtypeByVal</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Stuff for evaluation of aggregate inputs in cases where the aggregate 
     * requires sorted input.  The arguments themselves will be evaluated via 
     * AggState-&GT;evalslot/evalproj for all aggregates at once, but we only 
     * want to sort the relevant columns for individual aggregates. 
     */ 
</span><a name="LN355"></a>    <a href="../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a>   <span class='Declare_Member'>sortdesc</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* descriptor of input tuples */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Slots for holding the evaluated input arguments.  These are set up 
     * during ExecInitAgg() and then used for each input row requiring 
     * processing besides what's done in AggState-&GT;evalproj. 
     */ 
</span><a name="LN362"></a>    <a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Member'>sortslot</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* current input tuple */ 
</span><a name="LN363"></a>    <a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Member'>uniqslot</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* used for multi-column DISTINCT */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * These values are working state that is initialized at the start of an 
     * input tuple group and updated for each input tuple. 
     * 
     * For a simple (non DISTINCT/ORDER BY) aggregate, we just feed the input 
     * values straight to the transition function.  If it's DISTINCT or 
     * requires ORDER BY, we pass the input values into a Tuplesort object; 
     * then at completion of the input tuple group, we scan the sorted values, 
     * eliminate duplicates if needed, and run the transition function on the 
     * rest. 
     * 
     * We need a separate tuplesort for each grouping set. 
     */ 
</span> 
<a name="LN379"></a>    <a href="../utils/sort/tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>**</span><span class='Declare_Member'>sortstates</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* sort objects, if DISTINCT or ORDER BY */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * This field is a pre-initialized FunctionCallInfo struct used for 
     * calling this aggregate's transfn.  We save a few cycles per row by not 
     * re-initializing the unchanging fields; which isn't much, but it seems 
     * worth the extra space consumption. 
     */ 
</span><a name="LN387"></a>    <a href="../../include/fmgr.h.html#LN76"><span class='Ref_to_Struct'>FunctionCallInfoData</span></a> <span class='Declare_Member'>transfn_fcinfo</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Likewise for serialization and deserialization functions */ 
</span><a name="LN390"></a>    <a href="../../include/fmgr.h.html#LN76"><span class='Ref_to_Struct'>FunctionCallInfoData</span></a> <span class='Declare_Member'>serialfn_fcinfo</span><span class='Delimiter'>; 
</span> 
<a name="LN392"></a>    <a href="../../include/fmgr.h.html#LN76"><span class='Ref_to_Struct'>FunctionCallInfoData</span></a> <span class='Declare_Member'>deserialfn_fcinfo</span><span class='Delimiter'>; 
</span><a name="LN393"></a>}<span class='Auto_Annotations'> &laquo; end AggStatePerTransData &raquo; </span>   <span class='Declare_Typedef'>AggStatePerTransData</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * AggStatePerAggData - per-aggregate information 
 * 
 * This contains the information needed to call the final function, to produce 
 * a final aggregate result from the state value. If there are multiple 
 * identical Aggrefs in the query, they can all share the same per-agg data. 
 * 
 * These values are set up during ExecInitAgg() and do not change thereafter. 
 */ 
</span><a name="LN404"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AggStatePerAggData</span> 
<span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * Link to an Aggref expr this state value is for. 
     * 
     * There can be multiple identical Aggref's sharing the same per-agg. This 
     * points to the first one of them. 
     */ 
</span><a name="LN412"></a>    <a href="../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a>     <span class='Operator'>*</span><span class='Declare_Member'>aggref</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* index to the state value which this agg should use */ 
</span><a name="LN415"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>transno</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Optional Oid of final function (may be InvalidOid) */ 
</span><a name="LN418"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Member'>finalfn_oid</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * fmgr lookup data for final function --- only valid when finalfn_oid oid 
     * is not InvalidOid. 
     */ 
</span><a name="LN424"></a>    <a href="../../include/fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a>    <span class='Declare_Member'>finalfn</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Number of arguments to pass to the finalfn.  This is always at least 1 
     * (the transition state value) plus any ordered-set direct args. If the 
     * finalfn wants extra args then we pass nulls corresponding to the 
     * aggregated input columns. 
     */ 
</span><a name="LN432"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>numFinalArgs</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We need the len and byval info for the agg's result data type in order 
     * to know how to copy/delete values. 
     */ 
</span><a name="LN438"></a>    <a href="../../include/c.h.html#LN254"><span class='Ref_to_Typedef'>int16</span></a>       <span class='Declare_Member'>resulttypeLen</span><span class='Delimiter'>; 
</span><a name="LN439"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>resulttypeByVal</span><span class='Delimiter'>; 
</span> 
<a name="LN441"></a><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end AggStatePerAggData &raquo; </span>   <span class='Declare_Typedef'>AggStatePerAggData</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * AggStatePerGroupData - per-aggregate-per-group working state 
 * 
 * These values are working state that is initialized at the start of 
 * an input tuple group and updated for each input tuple. 
 * 
 * In AGG_PLAIN and AGG_SORTED modes, we have a single array of these 
 * structs (pointed to by aggstate-&GT;pergroup); we re-use the array for 
 * each input group, if it's AGG_SORTED mode.  In AGG_HASHED mode, the 
 * hash table contains an array of these structs for each tuple group. 
 * 
 * Logically, the sortstate field belongs in this struct, but we do not 
 * keep it here for space reasons: we don't support DISTINCT aggregates 
 * in AGG_HASHED mode, so there's no reason to use up a pointer field 
 * in every entry of the hashtable. 
 */ 
</span><a name="LN459"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AggStatePerGroupData</span> 
<span class='Delimiter'>{ 
</span><a name="LN461"></a>    <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Member'>transValue</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* current transition value */ 
</span><a name="LN462"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>transValueIsNull</span><span class='Delimiter'>; 
</span> 
<a name="LN464"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>noTransValue</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* true if transValue not set yet */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Note: noTransValue initially has the same value as transValueIsNull, 
     * and if true both are cleared to false at the same time.  They are not 
     * the same though: if transfn later returns a NULL, we want to keep that 
     * NULL and not auto-replace it with a later input value. Only the first 
     * non-NULL input will be auto-substituted. 
     */ 
</span><a name="LN473"></a><span class='Delimiter'>}</span>   <span class='Declare_Typedef'>AggStatePerGroupData</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * AggStatePerPhaseData - per-grouping-set-phase state 
 * 
 * Grouping sets are divided into "phases", where a single phase can be 
 * processed in one pass over the input. If there is more than one phase, then 
 * at the end of input from the current phase, state is reset and another pass 
 * taken over the data which has been re-sorted in the mean time. 
 * 
 * Accordingly, each phase specifies a list of grouping sets and group clause 
 * information, plus each phase after the first also has a sort order. 
 */ 
</span><a name="LN486"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AggStatePerPhaseData</span> 
<span class='Delimiter'>{ 
</span><a name="LN488"></a>    <a href="../../include/nodes/nodes.h.html#LN733"><span class='Ref_to_Enum'>AggStrategy</span></a> <span class='Declare_Member'>aggstrategy</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* strategy for this phase */ 
</span><a name="LN489"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>numsets</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* number of grouping sets (or 0) */ 
</span><a name="LN490"></a>    <span class='Keyword'>int</span>        <span class='Operator'>*</span><span class='Declare_Member'>gset_lengths</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* lengths of grouping sets */ 
</span><a name="LN491"></a>    <a href="../../include/nodes/bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a> <span class='Operator'>**</span><span class='Declare_Member'>grouped_cols</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* column groupings for rollup */ 
</span><a name="LN492"></a>    <a href="../../include/fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>eqfunctions</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* per-grouping-field equality fns */ 
</span><a name="LN493"></a>    <a href="../../include/nodes/plannodes.h.html#LN781"><span class='Ref_to_Struct'>Agg</span></a>        <span class='Operator'>*</span><span class='Declare_Member'>aggnode</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* Agg node for phase data */ 
</span><a name="LN494"></a>    <a href="../../include/nodes/plannodes.h.html#LN743"><span class='Ref_to_Struct'>Sort</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>sortnode</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* Sort node for input ordering for phase */ 
</span><a name="LN495"></a><span class='Delimiter'>}</span>   <span class='Declare_Typedef'>AggStatePerPhaseData</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* 
 * AggStatePerHashData - per-hashtable state 
 * 
 * When doing grouping sets with hashing, we have one of these for each 
 * grouping set. (When doing hashing without grouping sets, we have just one of 
 * them.) 
 */ 
</span><a name="LN504"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>AggStatePerHashData</span> 
<span class='Delimiter'>{ 
</span><a name="LN506"></a>    <a href="../../include/nodes/execnodes.h.html#LN561"><span class='Ref_to_Typedef'>TupleHashTable</span></a> <span class='Declare_Member'>hashtable</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* hash table with one entry per group */ 
</span><a name="LN507"></a>    <a href="../../include/nodes/execnodes.h.html#LN597"><span class='Ref_to_Typedef'>TupleHashIterator</span></a> <span class='Declare_Member'>hashiter</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* for iterating through hash table */ 
</span><a name="LN508"></a>    <a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Member'>hashslot</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* slot for loading hash table */ 
</span><a name="LN509"></a>    <a href="../../include/fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>hashfunctions</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* per-grouping-field hash fns */ 
</span><a name="LN510"></a>    <a href="../../include/fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a>   <span class='Operator'>*</span><span class='Declare_Member'>eqfunctions</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* per-grouping-field equality fns */ 
</span><a name="LN511"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>numCols</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* number of hash key columns */ 
</span><a name="LN512"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>numhashGrpCols</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* number of columns in hash table */ 
</span><a name="LN513"></a>    <span class='Keyword'>int</span>         <span class='Declare_Member'>largestGrpColIdx</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* largest col required for hashing */ 
</span><a name="LN514"></a>    <a href="../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a> <span class='Operator'>*</span><span class='Declare_Member'>hashGrpColIdxInput</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* hash col indices in input slot */ 
</span><a name="LN515"></a>    <a href="../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a> <span class='Operator'>*</span><span class='Declare_Member'>hashGrpColIdxHash</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* indices in hashtbl tuples */ 
</span><a name="LN516"></a>    <a href="../../include/nodes/plannodes.h.html#LN781"><span class='Ref_to_Struct'>Agg</span></a>        <span class='Operator'>*</span><span class='Declare_Member'>aggnode</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* original Agg node, for numGroups etc. */ 
</span><a name="LN517"></a><span class='Delimiter'>}</span>   <span class='Declare_Typedef'>AggStatePerHashData</span><span class='Delimiter'>; 
</span> 
 
<a name="LN520"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>select_current_set</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>setno</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>is_hash</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN521"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>initialize_phase</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>newphase</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN522"></a><span class='Keyword'>static </span><a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>fetch_input_tuple</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN523"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>initialize_aggregates</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Delimiter'>, 
</span><a name="LN524"></a>                      <a href="../../include/nodes/execnodes.h.html#LN1735"><span class='Ref_to_Typedef'>AggStatePerGroup</span></a> <span class='Declare_Parameter'>pergroup</span><span class='Delimiter'>, 
</span><a name="LN525"></a>                      <span class='Keyword'>int </span><span class='Declare_Parameter'>numReset</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN526"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>advance_transition_function</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Delimiter'>, 
</span><a name="LN527"></a>                            <a href="../../include/nodes/execnodes.h.html#LN1734"><span class='Ref_to_Typedef'>AggStatePerTrans</span></a> <span class='Declare_Parameter'>pertrans</span><span class='Delimiter'>, 
</span><a name="LN528"></a>                            <a href="../../include/nodes/execnodes.h.html#LN1735"><span class='Ref_to_Typedef'>AggStatePerGroup</span></a> <span class='Declare_Parameter'>pergroupstate</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN529"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>advance_aggregates</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/execnodes.h.html#LN1735"><span class='Ref_to_Typedef'>AggStatePerGroup</span></a> <span class='Declare_Parameter'>pergroup</span><span class='Delimiter'>, 
</span><a name="LN530"></a>                   <a href="../../include/nodes/execnodes.h.html#LN1735"><span class='Ref_to_Typedef'>AggStatePerGroup</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pergroups</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN531"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>advance_combine_function</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Delimiter'>, 
</span><a name="LN532"></a>                         <a href="../../include/nodes/execnodes.h.html#LN1734"><span class='Ref_to_Typedef'>AggStatePerTrans</span></a> <span class='Declare_Parameter'>pertrans</span><span class='Delimiter'>, 
</span><a name="LN533"></a>                         <a href="../../include/nodes/execnodes.h.html#LN1735"><span class='Ref_to_Typedef'>AggStatePerGroup</span></a> <span class='Declare_Parameter'>pergroupstate</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN534"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>combine_aggregates</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/execnodes.h.html#LN1735"><span class='Ref_to_Typedef'>AggStatePerGroup</span></a> <span class='Declare_Parameter'>pergroup</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN535"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>process_ordered_aggregate_single</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Delimiter'>, 
</span><a name="LN536"></a>                                 <a href="../../include/nodes/execnodes.h.html#LN1734"><span class='Ref_to_Typedef'>AggStatePerTrans</span></a> <span class='Declare_Parameter'>pertrans</span><span class='Delimiter'>, 
</span><a name="LN537"></a>                                 <a href="../../include/nodes/execnodes.h.html#LN1735"><span class='Ref_to_Typedef'>AggStatePerGroup</span></a> <span class='Declare_Parameter'>pergroupstate</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN538"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>process_ordered_aggregate_multi</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Delimiter'>, 
</span><a name="LN539"></a>                                <a href="../../include/nodes/execnodes.h.html#LN1734"><span class='Ref_to_Typedef'>AggStatePerTrans</span></a> <span class='Declare_Parameter'>pertrans</span><span class='Delimiter'>, 
</span><a name="LN540"></a>                                <a href="../../include/nodes/execnodes.h.html#LN1735"><span class='Ref_to_Typedef'>AggStatePerGroup</span></a> <span class='Declare_Parameter'>pergroupstate</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN541"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>finalize_aggregate</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Delimiter'>, 
</span><a name="LN542"></a>                   <a href="../../include/nodes/execnodes.h.html#LN1733"><span class='Ref_to_Typedef'>AggStatePerAgg</span></a> <span class='Declare_Parameter'>peragg</span><span class='Delimiter'>, 
</span><a name="LN543"></a>                   <a href="../../include/nodes/execnodes.h.html#LN1735"><span class='Ref_to_Typedef'>AggStatePerGroup</span></a> <span class='Declare_Parameter'>pergroupstate</span><span class='Delimiter'>, 
</span><a name="LN544"></a>                   <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>resultVal</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>resultIsNull</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN545"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>finalize_partialaggregate</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Delimiter'>, 
</span><a name="LN546"></a>                          <a href="../../include/nodes/execnodes.h.html#LN1733"><span class='Ref_to_Typedef'>AggStatePerAgg</span></a> <span class='Declare_Parameter'>peragg</span><span class='Delimiter'>, 
</span><a name="LN547"></a>                          <a href="../../include/nodes/execnodes.h.html#LN1735"><span class='Ref_to_Typedef'>AggStatePerGroup</span></a> <span class='Declare_Parameter'>pergroupstate</span><span class='Delimiter'>, 
</span><a name="LN548"></a>                          <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>resultVal</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>resultIsNull</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN549"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>prepare_projection_slot</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Delimiter'>, 
</span><a name="LN550"></a>                        <a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>slot</span><span class='Delimiter'>, 
</span><a name="LN551"></a>                        <span class='Keyword'>int </span><span class='Declare_Parameter'>currentSet</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN552"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>finalize_aggregates</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Delimiter'>, 
</span><a name="LN553"></a>                    <a href="../../include/nodes/execnodes.h.html#LN1733"><span class='Ref_to_Typedef'>AggStatePerAgg</span></a> <span class='Declare_Parameter'>peragg</span><span class='Delimiter'>, 
</span><a name="LN554"></a>                    <a href="../../include/nodes/execnodes.h.html#LN1735"><span class='Ref_to_Typedef'>AggStatePerGroup</span></a> <span class='Declare_Parameter'>pergroup</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN555"></a><span class='Keyword'>static </span><a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>project_aggregates</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN556"></a><span class='Keyword'>static </span><a href="../../include/nodes/bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>find_unaggregated_cols</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN557"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>find_unaggregated_cols_walker</span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><a href="../../include/nodes/bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>colnos</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN558"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>build_hash_table</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN559"></a><span class='Keyword'>static </span><a href="../../include/nodes/execnodes.h.html#LN563"><span class='Ref_to_Struct'>TupleHashEntryData</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>lookup_hash_entry</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN560"></a><span class='Keyword'>static </span><a href="../../include/nodes/execnodes.h.html#LN1735"><span class='Ref_to_Typedef'>AggStatePerGroup</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>lookup_hash_entries</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN561"></a><span class='Keyword'>static </span><a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>agg_retrieve_direct</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN562"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>agg_fill_hash_table</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN563"></a><span class='Keyword'>static </span><a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>agg_retrieve_hash_table</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN564"></a><span class='Keyword'>static </span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Prototype'>GetAggInitVal</span><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>textInitVal</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>transtype</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN565"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>build_pertrans_for_aggref</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1734"><span class='Ref_to_Typedef'>AggStatePerTrans</span></a> <span class='Declare_Parameter'>pertrans</span><span class='Delimiter'>, 
</span><a name="LN566"></a>                          <a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/execnodes.h.html#LN402"><span class='Ref_to_Struct'>EState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>estate</span><span class='Delimiter'>, 
</span><a name="LN567"></a>                          <a href="../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggref</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>aggtransfn</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>aggtranstype</span><span class='Delimiter'>, 
</span><a name="LN568"></a>                          <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>aggserialfn</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>aggdeserialfn</span><span class='Delimiter'>, 
</span><a name="LN569"></a>                          <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>initValue</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>initValueIsNull</span><span class='Delimiter'>, 
</span><a name="LN570"></a>                          <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>inputTypes</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>numArguments</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN571"></a><span class='Keyword'>static int </span><span class='Declare_Prototype'>find_compatible_peragg</span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>newagg</span><span class='Delimiter'>, </span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Delimiter'>, 
</span><a name="LN572"></a>                       <span class='Keyword'>int </span><span class='Declare_Parameter'>lastaggno</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>same_input_transnos</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN573"></a><span class='Keyword'>static int </span><span class='Declare_Prototype'>find_compatible_pertrans</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>newagg</span><span class='Delimiter'>, 
</span><a name="LN574"></a>                         <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>aggtransfn</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>aggtranstype</span><span class='Delimiter'>, 
</span><a name="LN575"></a>                         <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>aggserialfn</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>aggdeserialfn</span><span class='Delimiter'>, 
</span><a name="LN576"></a>                         <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>initValue</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>initValueIsNull</span><span class='Delimiter'>, 
</span><a name="LN577"></a>                         <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>transnos</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Select the current grouping set; affects current_set and 
 * curaggcontext. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN585"></a><span class='Declare_Function'>select_current_set</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>setno</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>is_hash</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN585"><span class='Ref_to_Parameter'>is_hash</span></a><span class='Parentheses'>) 
</span>        <a href="nodeAgg.c.html#LN585"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1755"><span class='Ref_to_Member'>curaggcontext</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN585"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1752"><span class='Ref_to_Member'>hashcontext</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="nodeAgg.c.html#LN585"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1755"><span class='Ref_to_Member'>curaggcontext</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN585"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1753"><span class='Ref_to_Member'>aggcontexts</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN585"><span class='Ref_to_Parameter'>setno</span></a><span class='Delimiter'>]; 
</span> 
    <a href="nodeAgg.c.html#LN585"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1760"><span class='Ref_to_Member'>current_set</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN585"><span class='Ref_to_Parameter'>setno</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Switch to phase "newphase", which must either be 0 or 1 (to reset) or 
 * current_phase + 1. Juggle the tuplesorts accordingly. 
 * 
 * Phase 0 is for hashing, which we currently handle last in the AGG_MIXED 
 * case, so when entering phase 0, all we need to do is drop open sorts. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN603"></a><span class='Declare_Function'>initialize_phase</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>newphase</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN603"><span class='Ref_to_Parameter'>newphase</span></a> <span class='Operator'>&LT;= </span><span class='Number'>1</span> <span class='Operator'>|| </span><a href="nodeAgg.c.html#LN603"><span class='Ref_to_Parameter'>newphase</span></a> <span class='Operator'>== </span><a href="nodeAgg.c.html#LN603"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1749"><span class='Ref_to_Member'>current_phase</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Whatever the previous state, we're now done with whatever input 
     * tuplesort was in use. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN603"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1767"><span class='Ref_to_Member'>sort_in</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../include/utils/tuplesort.h.html#LN106"><span class='Ref_to_Proto'>tuplesort_end</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN603"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1767"><span class='Ref_to_Member'>sort_in</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="nodeAgg.c.html#LN603"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1767"><span class='Ref_to_Member'>sort_in</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN603"><span class='Ref_to_Parameter'>newphase</span></a> <span class='Operator'>&LT;= </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Discard any existing output tuplesort. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN603"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1768"><span class='Ref_to_Member'>sort_out</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../include/utils/tuplesort.h.html#LN106"><span class='Ref_to_Proto'>tuplesort_end</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN603"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1768"><span class='Ref_to_Member'>sort_out</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="nodeAgg.c.html#LN603"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1768"><span class='Ref_to_Member'>sort_out</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * The old output tuplesort becomes the new input one, and this is the 
         * right time to actually sort it. 
         */ 
</span>        <a href="nodeAgg.c.html#LN603"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1767"><span class='Ref_to_Member'>sort_in</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN603"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1768"><span class='Ref_to_Member'>sort_out</span></a><span class='Delimiter'>; 
</span>        <a href="nodeAgg.c.html#LN603"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1768"><span class='Ref_to_Member'>sort_out</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN603"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1767"><span class='Ref_to_Member'>sort_in</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/utils/tuplesort.h.html#LN94"><span class='Ref_to_Proto'>tuplesort_performsort</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN603"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1767"><span class='Ref_to_Member'>sort_in</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If this isn't the last phase, we need to sort appropriately for the 
     * next phase in sequence. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN603"><span class='Ref_to_Parameter'>newphase</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="nodeAgg.c.html#LN603"><span class='Ref_to_Parameter'>newphase</span></a> <span class='Operator'>&LT; </span><a href="nodeAgg.c.html#LN603"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1748"><span class='Ref_to_Member'>numphases</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN646"></a>        <a href="../../include/nodes/plannodes.h.html#LN743"><span class='Ref_to_Struct'>Sort</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>sortnode</span> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN603"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1766"><span class='Ref_to_Member'>phases</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN603"><span class='Ref_to_Parameter'>newphase</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="nodeAgg.c.html#LN494"><span class='Ref_to_Member'>sortnode</span></a><span class='Delimiter'>; 
</span><a name="LN647"></a>        <a href="../../include/nodes/execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>outerNode</span> <span class='Operator'>= </span><a href="../../include/nodes/execnodes.h.html#LN854"><span class='Ref_to_Macro'>outerPlanState</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN603"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN648"></a>        <a href="../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a>   <span class='Declare_Local'>tupDesc</span> <span class='Operator'>= </span><a href="execUtils.c.html#LN467"><span class='Ref_to_Func'>ExecGetResultType</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN647"><span class='Ref_To_Local'>outerNode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="nodeAgg.c.html#LN603"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1768"><span class='Ref_to_Member'>sort_out</span></a> <span class='Operator'>= </span><a href="../../include/utils/tuplesort.h.html#LN60"><span class='Ref_to_Proto'>tuplesort_begin_heap</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN648"><span class='Ref_To_Local'>tupDesc</span></a><span class='Delimiter'>, 
</span>                                                  <a href="nodeAgg.c.html#LN646"><span class='Ref_To_Local'>sortnode</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN746"><span class='Ref_to_Member'>numCols</span></a><span class='Delimiter'>, 
</span>                                                  <a href="nodeAgg.c.html#LN646"><span class='Ref_To_Local'>sortnode</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN747"><span class='Ref_to_Member'>sortColIdx</span></a><span class='Delimiter'>, 
</span>                                                  <a href="nodeAgg.c.html#LN646"><span class='Ref_To_Local'>sortnode</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN748"><span class='Ref_to_Member'>sortOperators</span></a><span class='Delimiter'>, 
</span>                                                  <a href="nodeAgg.c.html#LN646"><span class='Ref_To_Local'>sortnode</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN749"><span class='Ref_to_Member'>collations</span></a><span class='Delimiter'>, 
</span>                                                  <a href="nodeAgg.c.html#LN646"><span class='Ref_To_Local'>sortnode</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN750"><span class='Ref_to_Member'>nullsFirst</span></a><span class='Delimiter'>, 
</span>                                                  <a href="../utils/init/globals.c.html#LN112"><span class='Ref_to_Global_Var'>work_mem</span></a><span class='Delimiter'>, 
</span>                                                  <span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="nodeAgg.c.html#LN603"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1749"><span class='Ref_to_Member'>current_phase</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN603"><span class='Ref_to_Parameter'>newphase</span></a><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN603"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1747"><span class='Ref_to_Member'>phase</span></a> <span class='Operator'>= &</span><a href="nodeAgg.c.html#LN603"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1766"><span class='Ref_to_Member'>phases</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN603"><span class='Ref_to_Parameter'>newphase</span></a><span class='Delimiter'>]; 
}</span><span class='Auto_Annotations'> &laquo; end initialize_phase &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Fetch a tuple from either the outer plan (for phase 1) or from the sorter 
 * populated by the previous phase.  Copy it to the sorter for the next phase 
 * if any. 
 * 
 * Callers cannot rely on memory for tuple in returned slot remaining valid 
 * past any subsequently fetched tuple. 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>* 
</span><a name="LN673"></a><span class='Declare_Function'>fetch_input_tuple</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN675"></a>    <a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Local'>slot</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN673"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1767"><span class='Ref_to_Member'>sort_in</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/utils/tuplesort.h.html#LN96"><span class='Ref_to_Proto'>tuplesort_gettupleslot</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN673"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1767"><span class='Ref_to_Member'>sort_in</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                                    <a href="nodeAgg.c.html#LN673"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1769"><span class='Ref_to_Member'>sort_slot</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <a href="nodeAgg.c.html#LN675"><span class='Ref_To_Local'>slot</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN673"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1769"><span class='Ref_to_Member'>sort_slot</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
        <a href="nodeAgg.c.html#LN675"><span class='Ref_To_Local'>slot</span></a> <span class='Operator'>= </span><a href="../../include/executor/executor.h.html#LN229"><span class='Ref_to_Proto'>ExecProcNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN854"><span class='Ref_to_Macro'>outerPlanState</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN673"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/executor/tuptable.h.html#LN137"><span class='Ref_to_Macro'>TupIsNull</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN675"><span class='Ref_To_Local'>slot</span></a><span class='Parentheses'>) </span><span class='Operator'>&& </span><a href="nodeAgg.c.html#LN673"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1768"><span class='Ref_to_Member'>sort_out</span></a><span class='Parentheses'>)</span> 
        <a href="../../include/utils/tuplesort.h.html#LN85"><span class='Ref_to_Proto'>tuplesort_puttupleslot</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN673"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1768"><span class='Ref_to_Member'>sort_out</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN675"><span class='Ref_To_Local'>slot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="nodeAgg.c.html#LN675"><span class='Ref_To_Local'>slot</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end fetch_input_tuple &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * (Re)Initialize an individual aggregate. 
 * 
 * This function handles only one grouping set, already set in 
 * aggstate-&GT;current_set. 
 * 
 * When called, CurrentMemoryContext should be the per-query context. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN702"></a><span class='Declare_Function'>initialize_aggregate</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/execnodes.h.html#LN1734"><span class='Ref_to_Typedef'>AggStatePerTrans</span></a> <span class='Declare_Parameter'>pertrans</span><span class='Delimiter'>, 
</span><a name="LN703"></a>                     <a href="../../include/nodes/execnodes.h.html#LN1735"><span class='Ref_to_Typedef'>AggStatePerGroup</span></a> <span class='Declare_Parameter'>pergroupstate</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * Start a fresh sort operation for each DISTINCT/ORDER BY aggregate. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN702"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN312"><span class='Ref_to_Member'>numSortCols</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * In case of rescan, maybe there could be an uncompleted sort 
         * operation?  Clean it up if so. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN702"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN379"><span class='Ref_to_Member'>sortstates</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN702"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1760"><span class='Ref_to_Member'>current_set</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>            <a href="../../include/utils/tuplesort.h.html#LN106"><span class='Ref_to_Proto'>tuplesort_end</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN702"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN379"><span class='Ref_to_Member'>sortstates</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN702"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1760"><span class='Ref_to_Member'>current_set</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
 
        <span class='Comment_Multi_Line'>/* 
         * We use a plain Datum sorter when there's a single input column; 
         * otherwise sort the full tuple.  (See comments for 
         * process_ordered_aggregate_single.) 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN702"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN268"><span class='Ref_to_Member'>numInputs</span></a> <span class='Operator'>== </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>            <a href="nodeAgg.c.html#LN702"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN379"><span class='Ref_to_Member'>sortstates</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN702"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1760"><span class='Ref_to_Member'>current_set</span></a><span class='Delimiter'>] </span><span class='Operator'>= 
</span>                <a href="../../include/utils/tuplesort.h.html#LN78"><span class='Ref_to_Proto'>tuplesort_begin_datum</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN702"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN355"><span class='Ref_to_Member'>sortdesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/tupdesc.h.html#LN73"><span class='Ref_to_Member'>attrs</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Operator'>-&GT;</span>atttypid<span class='Delimiter'>, 
</span>                                      <a href="nodeAgg.c.html#LN702"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN320"><span class='Ref_to_Member'>sortOperators</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>], 
</span>                                      <a href="nodeAgg.c.html#LN702"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN321"><span class='Ref_to_Member'>sortCollations</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>], 
</span>                                      <a href="nodeAgg.c.html#LN702"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN322"><span class='Ref_to_Member'>sortNullsFirst</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>], 
</span>                                      <a href="../utils/init/globals.c.html#LN112"><span class='Ref_to_Global_Var'>work_mem</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="nodeAgg.c.html#LN702"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN379"><span class='Ref_to_Member'>sortstates</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN702"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1760"><span class='Ref_to_Member'>current_set</span></a><span class='Delimiter'>] </span><span class='Operator'>= 
</span>                <a href="../../include/utils/tuplesort.h.html#LN60"><span class='Ref_to_Proto'>tuplesort_begin_heap</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN702"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN355"><span class='Ref_to_Member'>sortdesc</span></a><span class='Delimiter'>, 
</span>                                     <a href="nodeAgg.c.html#LN702"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN312"><span class='Ref_to_Member'>numSortCols</span></a><span class='Delimiter'>, 
</span>                                     <a href="nodeAgg.c.html#LN702"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN319"><span class='Ref_to_Member'>sortColIdx</span></a><span class='Delimiter'>, 
</span>                                     <a href="nodeAgg.c.html#LN702"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN320"><span class='Ref_to_Member'>sortOperators</span></a><span class='Delimiter'>, 
</span>                                     <a href="nodeAgg.c.html#LN702"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN321"><span class='Ref_to_Member'>sortCollations</span></a><span class='Delimiter'>, 
</span>                                     <a href="nodeAgg.c.html#LN702"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN322"><span class='Ref_to_Member'>sortNullsFirst</span></a><span class='Delimiter'>, 
</span>                                     <a href="../utils/init/globals.c.html#LN112"><span class='Ref_to_Global_Var'>work_mem</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if pertrans-&GT;numSortCols... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * (Re)set transValue to the initial value. 
     * 
     * Note that when the initial value is pass-by-ref, we must copy it (into 
     * the aggcontext) since we will pfree the transValue later. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN702"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN335"><span class='Ref_to_Member'>initValueIsNull</span></a><span class='Parentheses'>) 
</span>        <a href="nodeAgg.c.html#LN703"><span class='Ref_to_Parameter'>pergroupstate</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN461"><span class='Ref_to_Member'>transValue</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN702"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN334"><span class='Ref_to_Member'>initValue</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span><a name="LN751"></a>        <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldContext</span><span class='Delimiter'>; 
</span> 
        <a href="nodeAgg.c.html#LN751"><span class='Ref_To_Local'>oldContext</span></a> <span class='Operator'>= </span><a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>( 
</span>                             <a href="nodeAgg.c.html#LN702"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1755"><span class='Ref_to_Member'>curaggcontext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN202"><span class='Ref_to_Member'>ecxt_per_tuple_memory</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="nodeAgg.c.html#LN703"><span class='Ref_to_Parameter'>pergroupstate</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN461"><span class='Ref_to_Member'>transValue</span></a> <span class='Operator'>= </span><a href="../../include/utils/datum.h.html#LN30"><span class='Ref_to_Proto'>datumCopy</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN702"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN334"><span class='Ref_to_Member'>initValue</span></a><span class='Delimiter'>, 
</span>                                              <a href="nodeAgg.c.html#LN702"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN347"><span class='Ref_to_Member'>transtypeByVal</span></a><span class='Delimiter'>, 
</span>                                              <a href="nodeAgg.c.html#LN702"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN345"><span class='Ref_to_Member'>transtypeLen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN751"><span class='Ref_To_Local'>oldContext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="nodeAgg.c.html#LN703"><span class='Ref_to_Parameter'>pergroupstate</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN462"><span class='Ref_to_Member'>transValueIsNull</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN702"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN335"><span class='Ref_to_Member'>initValueIsNull</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the initial value for the transition state doesn't exist in the 
     * pg_aggregate table then we will let the first non-NULL value returned 
     * from the outer procNode become the initial value. (This is useful for 
     * aggregates like max() and min().) The noTransValue flag signals that we 
     * still need to do this. 
     */ 
</span>    <a href="nodeAgg.c.html#LN703"><span class='Ref_to_Parameter'>pergroupstate</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN464"><span class='Ref_to_Member'>noTransValue</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN702"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN335"><span class='Ref_to_Member'>initValueIsNull</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end initialize_aggregate &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Initialize all aggregate transition states for a new group of input values. 
 * 
 * If there are multiple grouping sets, we initialize only the first numReset 
 * of them (the grouping sets are ordered so that the most specific one, which 
 * is reset most often, is first). As a convenience, if numReset is 0, we 
 * reinitialize all sets. numReset is -1 to initialize a hashtable entry, in 
 * which case the caller must have used select_current_set appropriately. 
 * 
 * When called, CurrentMemoryContext should be the per-query context. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN784"></a><span class='Declare_Function'>initialize_aggregates</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Delimiter'>, 
</span><a name="LN785"></a>                      <a href="../../include/nodes/execnodes.h.html#LN1735"><span class='Ref_to_Typedef'>AggStatePerGroup</span></a> <span class='Declare_Parameter'>pergroup</span><span class='Delimiter'>, 
</span><a name="LN786"></a>                      <span class='Keyword'>int </span><span class='Declare_Parameter'>numReset</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN788"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>transno</span><span class='Delimiter'>; 
</span><a name="LN789"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numGroupingSets</span> <span class='Operator'>= </span><a href="../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN10"><span class='Ref_to_Macro'>Max</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN784"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1747"><span class='Ref_to_Member'>phase</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN489"><span class='Ref_to_Member'>numsets</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN790"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>setno</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN791"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numTrans</span> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN784"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1744"><span class='Ref_to_Member'>numtrans</span></a><span class='Delimiter'>; 
</span><a name="LN792"></a>    <a href="../../include/nodes/execnodes.h.html#LN1734"><span class='Ref_to_Typedef'>AggStatePerTrans</span></a> <span class='Declare_Local'>transstates</span> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN784"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1751"><span class='Ref_to_Member'>pertrans</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN786"><span class='Ref_to_Parameter'>numReset</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="nodeAgg.c.html#LN786"><span class='Ref_to_Parameter'>numReset</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN789"><span class='Ref_To_Local'>numGroupingSets</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN788"><span class='Ref_To_Local'>transno</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN788"><span class='Ref_To_Local'>transno</span></a> <span class='Operator'>&LT; </span><a href="nodeAgg.c.html#LN791"><span class='Ref_To_Local'>numTrans</span></a><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN788"><span class='Ref_To_Local'>transno</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN799"></a>        <a href="../../include/nodes/execnodes.h.html#LN1734"><span class='Ref_to_Typedef'>AggStatePerTrans</span></a> <span class='Declare_Local'>pertrans</span> <span class='Operator'>= &</span><a href="nodeAgg.c.html#LN792"><span class='Ref_To_Local'>transstates</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN788"><span class='Ref_To_Local'>transno</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN786"><span class='Ref_to_Parameter'>numReset</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN803"></a>            <a href="../../include/nodes/execnodes.h.html#LN1735"><span class='Ref_to_Typedef'>AggStatePerGroup</span></a> <span class='Declare_Local'>pergroupstate</span><span class='Delimiter'>; 
</span> 
            <a href="nodeAgg.c.html#LN803"><span class='Ref_To_Local'>pergroupstate</span></a> <span class='Operator'>= &</span><a href="nodeAgg.c.html#LN785"><span class='Ref_to_Parameter'>pergroup</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN788"><span class='Ref_To_Local'>transno</span></a><span class='Delimiter'>]; 
</span> 
            <a href="nodeAgg.c.html#LN701"><span class='Ref_to_Func'>initialize_aggregate</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN784"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN799"><span class='Ref_To_Local'>pertrans</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN803"><span class='Ref_To_Local'>pergroupstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN790"><span class='Ref_To_Local'>setno</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN790"><span class='Ref_To_Local'>setno</span></a> <span class='Operator'>&LT; </span><a href="nodeAgg.c.html#LN786"><span class='Ref_to_Parameter'>numReset</span></a><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN790"><span class='Ref_To_Local'>setno</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN813"></a>                <a href="../../include/nodes/execnodes.h.html#LN1735"><span class='Ref_to_Typedef'>AggStatePerGroup</span></a> <span class='Declare_Local'>pergroupstate</span><span class='Delimiter'>; 
</span> 
                <a href="nodeAgg.c.html#LN813"><span class='Ref_To_Local'>pergroupstate</span></a> <span class='Operator'>= &</span><a href="nodeAgg.c.html#LN785"><span class='Ref_to_Parameter'>pergroup</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN788"><span class='Ref_To_Local'>transno</span></a> <span class='Operator'>+ </span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN790"><span class='Ref_To_Local'>setno</span></a> <span class='Operator'>* </span><a href="nodeAgg.c.html#LN791"><span class='Ref_To_Local'>numTrans</span></a><span class='Parentheses'>)</span><span class='Delimiter'>]; 
</span> 
                <a href="nodeAgg.c.html#LN520"><span class='Ref_to_Proto'>select_current_set</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN784"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN790"><span class='Ref_To_Local'>setno</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="nodeAgg.c.html#LN701"><span class='Ref_to_Func'>initialize_aggregate</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN784"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN799"><span class='Ref_To_Local'>pertrans</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN813"><span class='Ref_To_Local'>pergroupstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for transno=0;transno&LT;num... &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end initialize_aggregates &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Given new input value(s), advance the transition function of one aggregate 
 * state within one grouping set only (already set in aggstate-&GT;current_set) 
 * 
 * The new values (and null flags) have been preloaded into argument positions 
 * 1 and up in pertrans-&GT;transfn_fcinfo, so that we needn't copy them again to 
 * pass to the transition function.  We also expect that the static fields of 
 * the fcinfo are already initialized; that was done by ExecInitAgg(). 
 * 
 * It doesn't matter which memory context this is called in. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN837"></a><span class='Declare_Function'>advance_transition_function</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Delimiter'>, 
</span><a name="LN838"></a>                            <a href="../../include/nodes/execnodes.h.html#LN1734"><span class='Ref_to_Typedef'>AggStatePerTrans</span></a> <span class='Declare_Parameter'>pertrans</span><span class='Delimiter'>, 
</span><a name="LN839"></a>                            <a href="../../include/nodes/execnodes.h.html#LN1735"><span class='Ref_to_Typedef'>AggStatePerGroup</span></a> <span class='Declare_Parameter'>pergroupstate</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN841"></a>    <a href="../../include/fmgr.h.html#LN37"><span class='Ref_to_Typedef'>FunctionCallInfo</span></a> <span class='Declare_Local'>fcinfo</span> <span class='Operator'>= &</span><a href="nodeAgg.c.html#LN838"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN387"><span class='Ref_to_Member'>transfn_fcinfo</span></a><span class='Delimiter'>; 
</span><a name="LN842"></a>    <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldContext</span><span class='Delimiter'>; 
</span><a name="LN843"></a>    <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>newVal</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN838"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN300"><span class='Ref_to_Member'>transfn</span></a><span class='Operator'>.</span><a href="../../include/fmgr.h.html#LN60"><span class='Ref_to_Member'>fn_strict</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * For a strict transfn, nothing happens when there's a NULL input; we 
         * just keep the prior transValue. 
         */ 
</span><a name="LN851"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>numTransInputs</span> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN838"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN278"><span class='Ref_to_Member'>numTransInputs</span></a><span class='Delimiter'>; 
</span><a name="LN852"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN852"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN852"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT;= </span><a href="nodeAgg.c.html#LN851"><span class='Ref_To_Local'>numTransInputs</span></a><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN852"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN841"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN85"><span class='Ref_to_Member'>argnull</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN852"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>                <span class='Control'>return</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN839"><span class='Ref_to_Parameter'>pergroupstate</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN464"><span class='Ref_to_Member'>noTransValue</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * transValue has not been initialized. This is the first non-NULL 
             * input value. We use it as the initial value for transValue. (We 
             * already checked that the agg's input type is binary-compatible 
             * with its transtype, so straight copy here is OK.) 
             * 
             * We must copy the datum into aggcontext if it is pass-by-ref. We 
             * do not need to pfree the old transValue, since it's NULL. 
             */ 
</span>            <a href="nodeAgg.c.html#LN842"><span class='Ref_To_Local'>oldContext</span></a> <span class='Operator'>= </span><a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>( 
</span>                             <a href="nodeAgg.c.html#LN837"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1755"><span class='Ref_to_Member'>curaggcontext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN202"><span class='Ref_to_Member'>ecxt_per_tuple_memory</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="nodeAgg.c.html#LN839"><span class='Ref_to_Parameter'>pergroupstate</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN461"><span class='Ref_to_Member'>transValue</span></a> <span class='Operator'>= </span><a href="../../include/utils/datum.h.html#LN30"><span class='Ref_to_Proto'>datumCopy</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN841"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN84"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>[</span><span class='Number'>1</span><span class='Delimiter'>], 
</span>                                                  <a href="nodeAgg.c.html#LN838"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN347"><span class='Ref_to_Member'>transtypeByVal</span></a><span class='Delimiter'>, 
</span>                                                  <a href="nodeAgg.c.html#LN838"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN345"><span class='Ref_to_Member'>transtypeLen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="nodeAgg.c.html#LN839"><span class='Ref_to_Parameter'>pergroupstate</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN462"><span class='Ref_to_Member'>transValueIsNull</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="nodeAgg.c.html#LN839"><span class='Ref_to_Parameter'>pergroupstate</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN464"><span class='Ref_to_Member'>noTransValue</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN842"><span class='Ref_To_Local'>oldContext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if pergroupstate-&GT;noTran... &raquo; </span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN839"><span class='Ref_to_Parameter'>pergroupstate</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN462"><span class='Ref_to_Member'>transValueIsNull</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Don't call a strict function with NULL inputs.  Note it is 
             * possible to get here despite the above tests, if the transfn is 
             * strict *and* returned a NULL on a prior cycle. If that happens 
             * we will propagate the NULL all the way to the end. 
             */ 
</span>            <span class='Control'>return</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if pertrans-&GT;transfn.fn_... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* We run the transition functions in per-input-tuple memory context */ 
</span>    <a href="nodeAgg.c.html#LN842"><span class='Ref_To_Local'>oldContext</span></a> <span class='Operator'>= </span><a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN837"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1754"><span class='Ref_to_Member'>tmpcontext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN202"><span class='Ref_to_Member'>ecxt_per_tuple_memory</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* set up aggstate-&GT;curpertrans for AggGetAggref() */ 
</span>    <a href="nodeAgg.c.html#LN837"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1756"><span class='Ref_to_Member'>curpertrans</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN838"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * OK to call the transition function 
     */ 
</span>    <a href="nodeAgg.c.html#LN841"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN84"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="nodeAgg.c.html#LN839"><span class='Ref_to_Parameter'>pergroupstate</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN461"><span class='Ref_to_Member'>transValue</span></a><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN841"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN85"><span class='Ref_to_Member'>argnull</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="nodeAgg.c.html#LN839"><span class='Ref_to_Parameter'>pergroupstate</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN462"><span class='Ref_to_Member'>transValueIsNull</span></a><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN841"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN82"><span class='Ref_to_Member'>isnull</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* just in case transfn doesn't set it */ 
</span> 
    <a href="nodeAgg.c.html#LN843"><span class='Ref_To_Local'>newVal</span></a> <span class='Operator'>= </span><a href="../../include/fmgr.h.html#LN136"><span class='Ref_to_Macro'>FunctionCallInvoke</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN841"><span class='Ref_To_Local'>fcinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="nodeAgg.c.html#LN837"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1756"><span class='Ref_to_Member'>curpertrans</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If pass-by-ref datatype, must copy the new value into aggcontext and 
     * free the prior transValue.  But if transfn returned a pointer to its 
     * first input, we don't need to do anything.  Also, if transfn returned a 
     * pointer to a R/W expanded object that is already a child of the 
     * aggcontext, assume we can adopt that value without copying it. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="nodeAgg.c.html#LN838"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN347"><span class='Ref_to_Member'>transtypeByVal</span></a> <span class='Operator'>&& 
</span>        <a href="../../include/postgres.h.html#LN554"><span class='Ref_to_Macro'>DatumGetPointer</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN843"><span class='Ref_To_Local'>newVal</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><a href="../../include/postgres.h.html#LN554"><span class='Ref_to_Macro'>DatumGetPointer</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN839"><span class='Ref_to_Parameter'>pergroupstate</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN461"><span class='Ref_to_Member'>transValue</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="nodeAgg.c.html#LN841"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN82"><span class='Ref_to_Member'>isnull</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN837"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1755"><span class='Ref_to_Member'>curaggcontext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN202"><span class='Ref_to_Member'>ecxt_per_tuple_memory</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/utils/expandeddatum.h.html#LN139"><span class='Ref_to_Macro'>DatumIsReadWriteExpandedObject</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN843"><span class='Ref_To_Local'>newVal</span></a><span class='Delimiter'>, 
</span>                                               <span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                                               <a href="nodeAgg.c.html#LN838"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN345"><span class='Ref_to_Member'>transtypeLen</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>                <a href="../../include/utils/memutils.h.html#LN81"><span class='Ref_to_Proto'>MemoryContextGetParent</span></a><span class='Parentheses'>(</span><a href="../utils/adt/expandeddatum.c.html#LN27"><span class='Ref_to_Func'>DatumGetEOHP</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN843"><span class='Ref_To_Local'>newVal</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span><a href="../../include/utils/expandeddatum.h.html#LN106"><span class='Ref_to_Member'>eoh_context</span></a><span class='Parentheses'>)</span> <span class='Operator'>== </span><a href="../utils/mmgr/mcxt.c.html#LN36"><span class='Ref_to_Global_Var'>CurrentMemoryContext</span></a><span class='Parentheses'>)</span> 
                 <span class='Comment_Multi_Line'>/* do nothing */ </span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="nodeAgg.c.html#LN843"><span class='Ref_To_Local'>newVal</span></a> <span class='Operator'>= </span><a href="../../include/utils/datum.h.html#LN30"><span class='Ref_to_Proto'>datumCopy</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN843"><span class='Ref_To_Local'>newVal</span></a><span class='Delimiter'>, 
</span>                                   <a href="nodeAgg.c.html#LN838"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN347"><span class='Ref_to_Member'>transtypeByVal</span></a><span class='Delimiter'>, 
</span>                                   <a href="nodeAgg.c.html#LN838"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN345"><span class='Ref_to_Member'>transtypeLen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="nodeAgg.c.html#LN839"><span class='Ref_to_Parameter'>pergroupstate</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN462"><span class='Ref_to_Member'>transValueIsNull</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/utils/expandeddatum.h.html#LN139"><span class='Ref_to_Macro'>DatumIsReadWriteExpandedObject</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN839"><span class='Ref_to_Parameter'>pergroupstate</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN461"><span class='Ref_to_Member'>transValue</span></a><span class='Delimiter'>, 
</span>                                               <span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                                               <a href="nodeAgg.c.html#LN838"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN345"><span class='Ref_to_Member'>transtypeLen</span></a><span class='Parentheses'>))</span> 
                <a href="../utils/adt/expandeddatum.c.html#LN134"><span class='Ref_to_Func'>DeleteExpandedObject</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN839"><span class='Ref_to_Parameter'>pergroupstate</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN461"><span class='Ref_to_Member'>transValue</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN554"><span class='Ref_to_Macro'>DatumGetPointer</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN839"><span class='Ref_to_Parameter'>pergroupstate</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN461"><span class='Ref_to_Member'>transValue</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !pertrans-&GT;transtypeB... &raquo; </span> 
 
    <a href="nodeAgg.c.html#LN839"><span class='Ref_to_Parameter'>pergroupstate</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN461"><span class='Ref_to_Member'>transValue</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN843"><span class='Ref_To_Local'>newVal</span></a><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN839"><span class='Ref_to_Parameter'>pergroupstate</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN462"><span class='Ref_to_Member'>transValueIsNull</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN841"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN82"><span class='Ref_to_Member'>isnull</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN842"><span class='Ref_To_Local'>oldContext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end advance_transition_function &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Advance each aggregate transition state for one input tuple.  The input 
 * tuple has been stored in tmpcontext-&GT;ecxt_outertuple, so that it is 
 * accessible to ExecEvalExpr. 
 * 
 * We have two sets of transition states to handle: one for sorted aggregation 
 * and one for hashed; we do them both here, to avoid multiple evaluation of 
 * the inputs. 
 * 
 * When called, CurrentMemoryContext should be the per-query context. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN961"></a><span class='Declare_Function'>advance_aggregates</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/execnodes.h.html#LN1735"><span class='Ref_to_Typedef'>AggStatePerGroup</span></a> <span class='Declare_Parameter'>pergroup</span><span class='Delimiter'>, </span><a href="../../include/nodes/execnodes.h.html#LN1735"><span class='Ref_to_Typedef'>AggStatePerGroup</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pergroups</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN963"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>transno</span><span class='Delimiter'>; 
</span><a name="LN964"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>setno</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN965"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numGroupingSets</span> <span class='Operator'>= </span><a href="../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN10"><span class='Ref_to_Macro'>Max</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN961"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1747"><span class='Ref_to_Member'>phase</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN489"><span class='Ref_to_Member'>numsets</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN966"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numHashes</span> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN961"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1775"><span class='Ref_to_Member'>num_hashes</span></a><span class='Delimiter'>; 
</span><a name="LN967"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numTrans</span> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN961"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1744"><span class='Ref_to_Member'>numtrans</span></a><span class='Delimiter'>; 
</span><a name="LN968"></a>    <a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Local'>slot</span> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN961"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1779"><span class='Ref_to_Member'>evalslot</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* compute input for all aggregates */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN961"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1780"><span class='Ref_to_Member'>evalproj</span></a><span class='Parentheses'>) 
</span>        <a href="nodeAgg.c.html#LN961"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1779"><span class='Ref_to_Member'>evalslot</span></a> <span class='Operator'>= </span><a href="../../include/executor/executor.h.html#LN307"><span class='Ref_to_Func'>ExecProject</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN961"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1780"><span class='Ref_to_Member'>evalproj</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN963"><span class='Ref_To_Local'>transno</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN963"><span class='Ref_To_Local'>transno</span></a> <span class='Operator'>&LT; </span><a href="nodeAgg.c.html#LN967"><span class='Ref_To_Local'>numTrans</span></a><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN963"><span class='Ref_To_Local'>transno</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN976"></a>        <a href="../../include/nodes/execnodes.h.html#LN1734"><span class='Ref_to_Typedef'>AggStatePerTrans</span></a> <span class='Declare_Local'>pertrans</span> <span class='Operator'>= &</span><a href="nodeAgg.c.html#LN961"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1751"><span class='Ref_to_Member'>pertrans</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN963"><span class='Ref_To_Local'>transno</span></a><span class='Delimiter'>]; 
</span><a name="LN977"></a>        <a href="../../include/nodes/execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>filter</span> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN976"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN293"><span class='Ref_to_Member'>aggfilter</span></a><span class='Delimiter'>; 
</span><a name="LN978"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>numTransInputs</span> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN976"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN278"><span class='Ref_to_Member'>numTransInputs</span></a><span class='Delimiter'>; 
</span><a name="LN979"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN980"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>inputoff</span> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN976"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN271"><span class='Ref_to_Member'>inputoff</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Skip anything FILTERed out */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN977"><span class='Ref_To_Local'>filter</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN985"></a>            <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>res</span><span class='Delimiter'>; 
</span><a name="LN986"></a>            <span class='Keyword'>bool</span>        <span class='Declare_Local'>isnull</span><span class='Delimiter'>; 
</span> 
            <a href="nodeAgg.c.html#LN985"><span class='Ref_To_Local'>res</span></a> <span class='Operator'>= </span><a href="../../include/executor/executor.h.html#LN279"><span class='Ref_to_Func'>ExecEvalExprSwitchContext</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN977"><span class='Ref_To_Local'>filter</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN961"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1754"><span class='Ref_to_Member'>tmpcontext</span></a><span class='Delimiter'>, 
</span>                                            <span class='Operator'>&</span><a href="nodeAgg.c.html#LN986"><span class='Ref_To_Local'>isnull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN986"><span class='Ref_To_Local'>isnull</span></a> <span class='Operator'>|| !</span><a href="../../include/postgres.h.html#LN398"><span class='Ref_to_Macro'>DatumGetBool</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN985"><span class='Ref_To_Local'>res</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN976"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN312"><span class='Ref_to_Member'>numSortCols</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* DISTINCT and/or ORDER BY case */ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN968"><span class='Ref_To_Local'>slot</span></a><span class='Operator'>-&GT;</span><a href="../../include/executor/tuptable.h.html#LN123"><span class='Ref_to_Member'>tts_nvalid</span></a> <span class='Operator'>&GT;= </span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN976"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN268"><span class='Ref_to_Member'>numInputs</span></a> <span class='Operator'>+ </span><a href="nodeAgg.c.html#LN980"><span class='Ref_To_Local'>inputoff</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="nodeAgg.c.html#LN961"><span class='Ref_to_Parameter'>pergroups</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * If the transfn is strict, we want to check for nullity before 
             * storing the row in the sorter, to save space if there are a lot 
             * of nulls.  Note that we must only check numTransInputs columns, 
             * not numInputs, since nullity in columns used only for sorting 
             * is not relevant here. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN976"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN300"><span class='Ref_to_Member'>transfn</span></a><span class='Operator'>.</span><a href="../../include/fmgr.h.html#LN60"><span class='Ref_to_Member'>fn_strict</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN979"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN979"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="nodeAgg.c.html#LN978"><span class='Ref_To_Local'>numTransInputs</span></a><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN979"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN968"><span class='Ref_To_Local'>slot</span></a><span class='Operator'>-&GT;</span><a href="../../include/executor/tuptable.h.html#LN125"><span class='Ref_to_Member'>tts_isnull</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN979"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>+ </span><a href="nodeAgg.c.html#LN980"><span class='Ref_To_Local'>inputoff</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>                        <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN979"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="nodeAgg.c.html#LN978"><span class='Ref_To_Local'>numTransInputs</span></a><span class='Parentheses'>) 
</span>                    <span class='Control'>continue</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN964"><span class='Ref_To_Local'>setno</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN964"><span class='Ref_To_Local'>setno</span></a> <span class='Operator'>&LT; </span><a href="nodeAgg.c.html#LN965"><span class='Ref_To_Local'>numGroupingSets</span></a><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN964"><span class='Ref_To_Local'>setno</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* OK, put the tuple into the tuplesort object */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN976"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN268"><span class='Ref_to_Member'>numInputs</span></a> <span class='Operator'>== </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>                    <a href="../../include/utils/tuplesort.h.html#LN91"><span class='Ref_to_Proto'>tuplesort_putdatum</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN976"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN379"><span class='Ref_to_Member'>sortstates</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN964"><span class='Ref_To_Local'>setno</span></a><span class='Delimiter'>], 
</span>                                       <a href="nodeAgg.c.html#LN968"><span class='Ref_To_Local'>slot</span></a><span class='Operator'>-&GT;</span><a href="../../include/executor/tuptable.h.html#LN124"><span class='Ref_to_Member'>tts_values</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN980"><span class='Ref_To_Local'>inputoff</span></a><span class='Delimiter'>], 
</span>                                       <a href="nodeAgg.c.html#LN968"><span class='Ref_To_Local'>slot</span></a><span class='Operator'>-&GT;</span><a href="../../include/executor/tuptable.h.html#LN125"><span class='Ref_to_Member'>tts_isnull</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN980"><span class='Ref_To_Local'>inputoff</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>else</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* 
                     * Copy slot contents, starting from inputoff, into sort 
                     * slot. 
                     */ 
</span>                    <a href="../../include/executor/tuptable.h.html#LN154"><span class='Ref_to_Proto'>ExecClearTuple</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN976"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN362"><span class='Ref_to_Member'>sortslot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    memcpy<span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN976"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN362"><span class='Ref_to_Member'>sortslot</span></a><span class='Operator'>-&GT;</span><a href="../../include/executor/tuptable.h.html#LN124"><span class='Ref_to_Member'>tts_values</span></a><span class='Delimiter'>, 
</span>                           <span class='Operator'>&</span><a href="nodeAgg.c.html#LN968"><span class='Ref_To_Local'>slot</span></a><span class='Operator'>-&GT;</span><a href="../../include/executor/tuptable.h.html#LN124"><span class='Ref_to_Member'>tts_values</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN980"><span class='Ref_To_Local'>inputoff</span></a><span class='Delimiter'>], 
</span>                           <a href="nodeAgg.c.html#LN976"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN268"><span class='Ref_to_Member'>numInputs</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                    memcpy<span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN976"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN362"><span class='Ref_to_Member'>sortslot</span></a><span class='Operator'>-&GT;</span><a href="../../include/executor/tuptable.h.html#LN125"><span class='Ref_to_Member'>tts_isnull</span></a><span class='Delimiter'>, 
</span>                           <span class='Operator'>&</span><a href="nodeAgg.c.html#LN968"><span class='Ref_To_Local'>slot</span></a><span class='Operator'>-&GT;</span><a href="../../include/executor/tuptable.h.html#LN125"><span class='Ref_to_Member'>tts_isnull</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN980"><span class='Ref_To_Local'>inputoff</span></a><span class='Delimiter'>], 
</span>                           <a href="nodeAgg.c.html#LN976"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN268"><span class='Ref_to_Member'>numInputs</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>bool</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                    <a href="nodeAgg.c.html#LN976"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN362"><span class='Ref_to_Member'>sortslot</span></a><span class='Operator'>-&GT;</span><a href="../../include/executor/tuptable.h.html#LN123"><span class='Ref_to_Member'>tts_nvalid</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN976"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN268"><span class='Ref_to_Member'>numInputs</span></a><span class='Delimiter'>; 
</span>                    <a href="../../include/executor/tuptable.h.html#LN155"><span class='Ref_to_Proto'>ExecStoreVirtualTuple</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN976"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN362"><span class='Ref_to_Member'>sortslot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="../../include/utils/tuplesort.h.html#LN85"><span class='Ref_to_Proto'>tuplesort_puttupleslot</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN976"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN379"><span class='Ref_to_Member'>sortstates</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN964"><span class='Ref_To_Local'>setno</span></a><span class='Delimiter'>], </span><a href="nodeAgg.c.html#LN976"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN362"><span class='Ref_to_Member'>sortslot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for setno=0;setno&LT;numGrou... &raquo; </span> 
        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if pertrans-&GT;numSortCols... &raquo; </span> 
        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* We can apply the transition function immediately */ 
</span><a name="LN1047"></a>            <a href="../../include/fmgr.h.html#LN37"><span class='Ref_to_Typedef'>FunctionCallInfo</span></a> <span class='Declare_Local'>fcinfo</span> <span class='Operator'>= &</span><a href="nodeAgg.c.html#LN976"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN387"><span class='Ref_to_Member'>transfn_fcinfo</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Load values into fcinfo */ 
</span>            <span class='Comment_Multi_Line'>/* Start from 1, since the 0th arg will be the transition value */ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN968"><span class='Ref_To_Local'>slot</span></a><span class='Operator'>-&GT;</span><a href="../../include/executor/tuptable.h.html#LN123"><span class='Ref_to_Member'>tts_nvalid</span></a> <span class='Operator'>&GT;= </span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN978"><span class='Ref_To_Local'>numTransInputs</span></a> <span class='Operator'>+ </span><a href="nodeAgg.c.html#LN980"><span class='Ref_To_Local'>inputoff</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN979"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN979"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="nodeAgg.c.html#LN978"><span class='Ref_To_Local'>numTransInputs</span></a><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN979"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="nodeAgg.c.html#LN1047"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN84"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN979"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="nodeAgg.c.html#LN968"><span class='Ref_To_Local'>slot</span></a><span class='Operator'>-&GT;</span><a href="../../include/executor/tuptable.h.html#LN124"><span class='Ref_to_Member'>tts_values</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN979"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>+ </span><a href="nodeAgg.c.html#LN980"><span class='Ref_To_Local'>inputoff</span></a><span class='Delimiter'>]; 
</span>                <a href="nodeAgg.c.html#LN1047"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN85"><span class='Ref_to_Member'>argnull</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN979"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="nodeAgg.c.html#LN968"><span class='Ref_To_Local'>slot</span></a><span class='Operator'>-&GT;</span><a href="../../include/executor/tuptable.h.html#LN125"><span class='Ref_to_Member'>tts_isnull</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN979"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>+ </span><a href="nodeAgg.c.html#LN980"><span class='Ref_To_Local'>inputoff</span></a><span class='Delimiter'>]; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN961"><span class='Ref_to_Parameter'>pergroup</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* advance transition states for ordered grouping */ 
</span> 
                <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN964"><span class='Ref_To_Local'>setno</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN964"><span class='Ref_To_Local'>setno</span></a> <span class='Operator'>&LT; </span><a href="nodeAgg.c.html#LN965"><span class='Ref_To_Local'>numGroupingSets</span></a><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN964"><span class='Ref_To_Local'>setno</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span><a name="LN1065"></a>                    <a href="../../include/nodes/execnodes.h.html#LN1735"><span class='Ref_to_Typedef'>AggStatePerGroup</span></a> <span class='Declare_Local'>pergroupstate</span><span class='Delimiter'>; 
</span> 
                    <a href="nodeAgg.c.html#LN520"><span class='Ref_to_Proto'>select_current_set</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN961"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN964"><span class='Ref_To_Local'>setno</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                    <a href="nodeAgg.c.html#LN1065"><span class='Ref_To_Local'>pergroupstate</span></a> <span class='Operator'>= &</span><a href="nodeAgg.c.html#LN961"><span class='Ref_to_Parameter'>pergroup</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN963"><span class='Ref_To_Local'>transno</span></a> <span class='Operator'>+ </span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN964"><span class='Ref_To_Local'>setno</span></a> <span class='Operator'>* </span><a href="nodeAgg.c.html#LN967"><span class='Ref_To_Local'>numTrans</span></a><span class='Parentheses'>)</span><span class='Delimiter'>]; 
</span> 
                    <a href="nodeAgg.c.html#LN526"><span class='Ref_to_Proto'>advance_transition_function</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN961"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN976"><span class='Ref_To_Local'>pertrans</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN1065"><span class='Ref_To_Local'>pergroupstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN961"><span class='Ref_to_Parameter'>pergroups</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* advance transition states for hashed grouping */ 
</span> 
                <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN964"><span class='Ref_To_Local'>setno</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN964"><span class='Ref_To_Local'>setno</span></a> <span class='Operator'>&LT; </span><a href="nodeAgg.c.html#LN966"><span class='Ref_To_Local'>numHashes</span></a><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN964"><span class='Ref_To_Local'>setno</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span><a name="LN1081"></a>                    <a href="../../include/nodes/execnodes.h.html#LN1735"><span class='Ref_to_Typedef'>AggStatePerGroup</span></a> <span class='Declare_Local'>pergroupstate</span><span class='Delimiter'>; 
</span> 
                    <a href="nodeAgg.c.html#LN520"><span class='Ref_to_Proto'>select_current_set</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN961"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN964"><span class='Ref_To_Local'>setno</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                    <a href="nodeAgg.c.html#LN1081"><span class='Ref_To_Local'>pergroupstate</span></a> <span class='Operator'>= &</span><a href="nodeAgg.c.html#LN961"><span class='Ref_to_Parameter'>pergroups</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN964"><span class='Ref_To_Local'>setno</span></a><span class='Delimiter'>][</span><a href="nodeAgg.c.html#LN963"><span class='Ref_To_Local'>transno</span></a><span class='Delimiter'>]; 
</span> 
                    <a href="nodeAgg.c.html#LN526"><span class='Ref_to_Proto'>advance_transition_function</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN961"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN976"><span class='Ref_To_Local'>pertrans</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN1081"><span class='Ref_To_Local'>pergroupstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for transno=0;transno&LT;num... &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end advance_aggregates &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * combine_aggregates replaces advance_aggregates in DO_AGGSPLIT_COMBINE 
 * mode.  The principal difference is that here we may need to apply the 
 * deserialization function before running the transfn (which, in this mode, 
 * is actually the aggregate's combinefn).  Also, we know we don't need to 
 * handle FILTER, DISTINCT, ORDER BY, or grouping sets. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1102"></a><span class='Declare_Function'>combine_aggregates</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/execnodes.h.html#LN1735"><span class='Ref_to_Typedef'>AggStatePerGroup</span></a> <span class='Declare_Parameter'>pergroup</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1104"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>transno</span><span class='Delimiter'>; 
</span><a name="LN1105"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numTrans</span> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN1102"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1744"><span class='Ref_to_Member'>numtrans</span></a><span class='Delimiter'>; 
</span><a name="LN1106"></a>    <a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Local'>slot</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* combine not supported with grouping sets */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1102"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1747"><span class='Ref_to_Member'>phase</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN489"><span class='Ref_to_Member'>numsets</span></a> <span class='Operator'>&LT;= </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* compute input for all aggregates */ 
</span>    <a href="nodeAgg.c.html#LN1106"><span class='Ref_To_Local'>slot</span></a> <span class='Operator'>= </span><a href="../../include/executor/executor.h.html#LN307"><span class='Ref_to_Func'>ExecProject</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1102"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1780"><span class='Ref_to_Member'>evalproj</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1104"><span class='Ref_To_Local'>transno</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN1104"><span class='Ref_To_Local'>transno</span></a> <span class='Operator'>&LT; </span><a href="nodeAgg.c.html#LN1105"><span class='Ref_To_Local'>numTrans</span></a><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN1104"><span class='Ref_To_Local'>transno</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1116"></a>        <a href="../../include/nodes/execnodes.h.html#LN1734"><span class='Ref_to_Typedef'>AggStatePerTrans</span></a> <span class='Declare_Local'>pertrans</span> <span class='Operator'>= &</span><a href="nodeAgg.c.html#LN1102"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1751"><span class='Ref_to_Member'>pertrans</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1104"><span class='Ref_To_Local'>transno</span></a><span class='Delimiter'>]; 
</span><a name="LN1117"></a>        <a href="../../include/nodes/execnodes.h.html#LN1735"><span class='Ref_to_Typedef'>AggStatePerGroup</span></a> <span class='Declare_Local'>pergroupstate</span> <span class='Operator'>= &</span><a href="nodeAgg.c.html#LN1102"><span class='Ref_to_Parameter'>pergroup</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1104"><span class='Ref_To_Local'>transno</span></a><span class='Delimiter'>]; 
</span><a name="LN1118"></a>        <a href="../../include/fmgr.h.html#LN37"><span class='Ref_to_Typedef'>FunctionCallInfo</span></a> <span class='Declare_Local'>fcinfo</span> <span class='Operator'>= &</span><a href="nodeAgg.c.html#LN1116"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN387"><span class='Ref_to_Member'>transfn_fcinfo</span></a><span class='Delimiter'>; 
</span><a name="LN1119"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>inputoff</span> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN1116"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN271"><span class='Ref_to_Member'>inputoff</span></a><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1106"><span class='Ref_To_Local'>slot</span></a><span class='Operator'>-&GT;</span><a href="../../include/executor/tuptable.h.html#LN123"><span class='Ref_to_Member'>tts_nvalid</span></a> <span class='Operator'>&GT; </span><a href="nodeAgg.c.html#LN1119"><span class='Ref_To_Local'>inputoff</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * deserialfn_oid will be set if we must deserialize the input state 
         * before calling the combine function 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1116"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN287"><span class='Ref_to_Member'>deserialfn_oid</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Don't call a strict deserialization function with NULL input */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1116"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN306"><span class='Ref_to_Member'>deserialfn</span></a><span class='Operator'>.</span><a href="../../include/fmgr.h.html#LN60"><span class='Ref_to_Member'>fn_strict</span></a> <span class='Operator'>&& </span><a href="nodeAgg.c.html#LN1106"><span class='Ref_To_Local'>slot</span></a><span class='Operator'>-&GT;</span><a href="../../include/executor/tuptable.h.html#LN125"><span class='Ref_to_Member'>tts_isnull</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1119"><span class='Ref_To_Local'>inputoff</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="nodeAgg.c.html#LN1118"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN84"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>[</span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="nodeAgg.c.html#LN1106"><span class='Ref_To_Local'>slot</span></a><span class='Operator'>-&GT;</span><a href="../../include/executor/tuptable.h.html#LN124"><span class='Ref_to_Member'>tts_values</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1119"><span class='Ref_To_Local'>inputoff</span></a><span class='Delimiter'>]; 
</span>                <a href="nodeAgg.c.html#LN1118"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN85"><span class='Ref_to_Member'>argnull</span></a><span class='Delimiter'>[</span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="nodeAgg.c.html#LN1106"><span class='Ref_To_Local'>slot</span></a><span class='Operator'>-&GT;</span><a href="../../include/executor/tuptable.h.html#LN125"><span class='Ref_to_Member'>tts_isnull</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1119"><span class='Ref_To_Local'>inputoff</span></a><span class='Delimiter'>]; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span><a name="LN1137"></a>                <a href="../../include/fmgr.h.html#LN37"><span class='Ref_to_Typedef'>FunctionCallInfo</span></a> <span class='Declare_Local'>dsinfo</span> <span class='Operator'>= &</span><a href="nodeAgg.c.html#LN1116"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN392"><span class='Ref_to_Member'>deserialfn_fcinfo</span></a><span class='Delimiter'>; 
</span><a name="LN1138"></a>                <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldContext</span><span class='Delimiter'>; 
</span> 
                <a href="nodeAgg.c.html#LN1137"><span class='Ref_To_Local'>dsinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN84"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="nodeAgg.c.html#LN1106"><span class='Ref_To_Local'>slot</span></a><span class='Operator'>-&GT;</span><a href="../../include/executor/tuptable.h.html#LN124"><span class='Ref_to_Member'>tts_values</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1119"><span class='Ref_To_Local'>inputoff</span></a><span class='Delimiter'>]; 
</span>                <a href="nodeAgg.c.html#LN1137"><span class='Ref_To_Local'>dsinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN85"><span class='Ref_to_Member'>argnull</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="nodeAgg.c.html#LN1106"><span class='Ref_To_Local'>slot</span></a><span class='Operator'>-&GT;</span><a href="../../include/executor/tuptable.h.html#LN125"><span class='Ref_to_Member'>tts_isnull</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1119"><span class='Ref_To_Local'>inputoff</span></a><span class='Delimiter'>]; 
</span>                <span class='Comment_Multi_Line'>/* Dummy second argument for type-safety reasons */ 
</span>                <a href="nodeAgg.c.html#LN1137"><span class='Ref_To_Local'>dsinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN84"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>[</span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="nodeAgg.c.html#LN1137"><span class='Ref_To_Local'>dsinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN85"><span class='Ref_to_Member'>argnull</span></a><span class='Delimiter'>[</span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * We run the deserialization functions in per-input-tuple 
                 * memory context. 
                 */ 
</span>                <a href="nodeAgg.c.html#LN1138"><span class='Ref_To_Local'>oldContext</span></a> <span class='Operator'>= </span><a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1102"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1754"><span class='Ref_to_Member'>tmpcontext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN202"><span class='Ref_to_Member'>ecxt_per_tuple_memory</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="nodeAgg.c.html#LN1118"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN84"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>[</span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/fmgr.h.html#LN136"><span class='Ref_to_Macro'>FunctionCallInvoke</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1137"><span class='Ref_To_Local'>dsinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="nodeAgg.c.html#LN1118"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN85"><span class='Ref_to_Member'>argnull</span></a><span class='Delimiter'>[</span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="nodeAgg.c.html#LN1137"><span class='Ref_To_Local'>dsinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN82"><span class='Ref_to_Member'>isnull</span></a><span class='Delimiter'>; 
</span> 
                <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1138"><span class='Ref_To_Local'>oldContext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if OidIsValid(pertrans-&GT;... &raquo; </span> 
        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <a href="nodeAgg.c.html#LN1118"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN84"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>[</span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="nodeAgg.c.html#LN1106"><span class='Ref_To_Local'>slot</span></a><span class='Operator'>-&GT;</span><a href="../../include/executor/tuptable.h.html#LN124"><span class='Ref_to_Member'>tts_values</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1119"><span class='Ref_To_Local'>inputoff</span></a><span class='Delimiter'>]; 
</span>            <a href="nodeAgg.c.html#LN1118"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN85"><span class='Ref_to_Member'>argnull</span></a><span class='Delimiter'>[</span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="nodeAgg.c.html#LN1106"><span class='Ref_To_Local'>slot</span></a><span class='Operator'>-&GT;</span><a href="../../include/executor/tuptable.h.html#LN125"><span class='Ref_to_Member'>tts_isnull</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1119"><span class='Ref_To_Local'>inputoff</span></a><span class='Delimiter'>]; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="nodeAgg.c.html#LN531"><span class='Ref_to_Proto'>advance_combine_function</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1102"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN1116"><span class='Ref_To_Local'>pertrans</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN1117"><span class='Ref_To_Local'>pergroupstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for transno=0;transno&LT;num... &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end combine_aggregates &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Perform combination of states between 2 aggregate states. Effectively this 
 * 'adds' two states together by whichever logic is defined in the aggregate 
 * function's combine function. 
 * 
 * Note that in this case transfn is set to the combination function. This 
 * perhaps should be changed to avoid confusion, but one field is ok for now 
 * as they'll never be needed at the same time. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1178"></a><span class='Declare_Function'>advance_combine_function</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Delimiter'>, 
</span><a name="LN1179"></a>                         <a href="../../include/nodes/execnodes.h.html#LN1734"><span class='Ref_to_Typedef'>AggStatePerTrans</span></a> <span class='Declare_Parameter'>pertrans</span><span class='Delimiter'>, 
</span><a name="LN1180"></a>                         <a href="../../include/nodes/execnodes.h.html#LN1735"><span class='Ref_to_Typedef'>AggStatePerGroup</span></a> <span class='Declare_Parameter'>pergroupstate</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1182"></a>    <a href="../../include/fmgr.h.html#LN37"><span class='Ref_to_Typedef'>FunctionCallInfo</span></a> <span class='Declare_Local'>fcinfo</span> <span class='Operator'>= &</span><a href="nodeAgg.c.html#LN1179"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN387"><span class='Ref_to_Member'>transfn_fcinfo</span></a><span class='Delimiter'>; 
</span><a name="LN1183"></a>    <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldContext</span><span class='Delimiter'>; 
</span><a name="LN1184"></a>    <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>newVal</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1179"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN300"><span class='Ref_to_Member'>transfn</span></a><span class='Operator'>.</span><a href="../../include/fmgr.h.html#LN60"><span class='Ref_to_Member'>fn_strict</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* if we're asked to merge to a NULL state, then do nothing */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1182"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN85"><span class='Ref_to_Member'>argnull</span></a><span class='Delimiter'>[</span><span class='Number'>1</span><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>            <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1180"><span class='Ref_to_Parameter'>pergroupstate</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN464"><span class='Ref_to_Member'>noTransValue</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * transValue has not yet been initialized.  If pass-by-ref 
             * datatype we must copy the combining state value into 
             * aggcontext. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="nodeAgg.c.html#LN1179"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN347"><span class='Ref_to_Member'>transtypeByVal</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="nodeAgg.c.html#LN1183"><span class='Ref_To_Local'>oldContext</span></a> <span class='Operator'>= </span><a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>( 
</span>                             <a href="nodeAgg.c.html#LN1178"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1755"><span class='Ref_to_Member'>curaggcontext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN202"><span class='Ref_to_Member'>ecxt_per_tuple_memory</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="nodeAgg.c.html#LN1180"><span class='Ref_to_Parameter'>pergroupstate</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN461"><span class='Ref_to_Member'>transValue</span></a> <span class='Operator'>= </span><a href="../../include/utils/datum.h.html#LN30"><span class='Ref_to_Proto'>datumCopy</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1182"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN84"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>[</span><span class='Number'>1</span><span class='Delimiter'>], 
</span>                                                    <a href="nodeAgg.c.html#LN1179"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN347"><span class='Ref_to_Member'>transtypeByVal</span></a><span class='Delimiter'>, 
</span>                                                      <a href="nodeAgg.c.html#LN1179"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN345"><span class='Ref_to_Member'>transtypeLen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1183"><span class='Ref_To_Local'>oldContext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
                <a href="nodeAgg.c.html#LN1180"><span class='Ref_to_Parameter'>pergroupstate</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN461"><span class='Ref_to_Member'>transValue</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN1182"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN84"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>[</span><span class='Number'>1</span><span class='Delimiter'>]; 
</span> 
            <a href="nodeAgg.c.html#LN1180"><span class='Ref_to_Parameter'>pergroupstate</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN462"><span class='Ref_to_Member'>transValueIsNull</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="nodeAgg.c.html#LN1180"><span class='Ref_to_Parameter'>pergroupstate</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN464"><span class='Ref_to_Member'>noTransValue</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if pergroupstate-&GT;noTran... &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if pertrans-&GT;transfn.fn_... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* We run the combine functions in per-input-tuple memory context */ 
</span>    <a href="nodeAgg.c.html#LN1183"><span class='Ref_To_Local'>oldContext</span></a> <span class='Operator'>= </span><a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1178"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1754"><span class='Ref_to_Member'>tmpcontext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN202"><span class='Ref_to_Member'>ecxt_per_tuple_memory</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* set up aggstate-&GT;curpertrans for AggGetAggref() */ 
</span>    <a href="nodeAgg.c.html#LN1178"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1756"><span class='Ref_to_Member'>curpertrans</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN1179"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * OK to call the combine function 
     */ 
</span>    <a href="nodeAgg.c.html#LN1182"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN84"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="nodeAgg.c.html#LN1180"><span class='Ref_to_Parameter'>pergroupstate</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN461"><span class='Ref_to_Member'>transValue</span></a><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN1182"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN85"><span class='Ref_to_Member'>argnull</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="nodeAgg.c.html#LN1180"><span class='Ref_to_Parameter'>pergroupstate</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN462"><span class='Ref_to_Member'>transValueIsNull</span></a><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN1182"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN82"><span class='Ref_to_Member'>isnull</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* just in case combine func doesn't set it */ 
</span> 
    <a href="nodeAgg.c.html#LN1184"><span class='Ref_To_Local'>newVal</span></a> <span class='Operator'>= </span><a href="../../include/fmgr.h.html#LN136"><span class='Ref_to_Macro'>FunctionCallInvoke</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1182"><span class='Ref_To_Local'>fcinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="nodeAgg.c.html#LN1178"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1756"><span class='Ref_to_Member'>curpertrans</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If pass-by-ref datatype, must copy the new value into aggcontext and 
     * free the prior transValue.  But if the combine function returned a 
     * pointer to its first input, we don't need to do anything.  Also, if the 
     * combine function returned a pointer to a R/W expanded object that is 
     * already a child of the aggcontext, assume we can adopt that value 
     * without copying it. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="nodeAgg.c.html#LN1179"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN347"><span class='Ref_to_Member'>transtypeByVal</span></a> <span class='Operator'>&& 
</span>        <a href="../../include/postgres.h.html#LN554"><span class='Ref_to_Macro'>DatumGetPointer</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1184"><span class='Ref_To_Local'>newVal</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><a href="../../include/postgres.h.html#LN554"><span class='Ref_to_Macro'>DatumGetPointer</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1180"><span class='Ref_to_Parameter'>pergroupstate</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN461"><span class='Ref_to_Member'>transValue</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="nodeAgg.c.html#LN1182"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN82"><span class='Ref_to_Member'>isnull</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1178"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1755"><span class='Ref_to_Member'>curaggcontext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN202"><span class='Ref_to_Member'>ecxt_per_tuple_memory</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/utils/expandeddatum.h.html#LN139"><span class='Ref_to_Macro'>DatumIsReadWriteExpandedObject</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1184"><span class='Ref_To_Local'>newVal</span></a><span class='Delimiter'>, 
</span>                                               <span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                                               <a href="nodeAgg.c.html#LN1179"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN345"><span class='Ref_to_Member'>transtypeLen</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>                <a href="../../include/utils/memutils.h.html#LN81"><span class='Ref_to_Proto'>MemoryContextGetParent</span></a><span class='Parentheses'>(</span><a href="../utils/adt/expandeddatum.c.html#LN27"><span class='Ref_to_Func'>DatumGetEOHP</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1184"><span class='Ref_To_Local'>newVal</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span><a href="../../include/utils/expandeddatum.h.html#LN106"><span class='Ref_to_Member'>eoh_context</span></a><span class='Parentheses'>)</span> <span class='Operator'>== </span><a href="../utils/mmgr/mcxt.c.html#LN36"><span class='Ref_to_Global_Var'>CurrentMemoryContext</span></a><span class='Parentheses'>)</span> 
                 <span class='Comment_Multi_Line'>/* do nothing */ </span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="nodeAgg.c.html#LN1184"><span class='Ref_To_Local'>newVal</span></a> <span class='Operator'>= </span><a href="../../include/utils/datum.h.html#LN30"><span class='Ref_to_Proto'>datumCopy</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1184"><span class='Ref_To_Local'>newVal</span></a><span class='Delimiter'>, 
</span>                                   <a href="nodeAgg.c.html#LN1179"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN347"><span class='Ref_to_Member'>transtypeByVal</span></a><span class='Delimiter'>, 
</span>                                   <a href="nodeAgg.c.html#LN1179"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN345"><span class='Ref_to_Member'>transtypeLen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="nodeAgg.c.html#LN1180"><span class='Ref_to_Parameter'>pergroupstate</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN462"><span class='Ref_to_Member'>transValueIsNull</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/utils/expandeddatum.h.html#LN139"><span class='Ref_to_Macro'>DatumIsReadWriteExpandedObject</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1180"><span class='Ref_to_Parameter'>pergroupstate</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN461"><span class='Ref_to_Member'>transValue</span></a><span class='Delimiter'>, 
</span>                                               <span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                                               <a href="nodeAgg.c.html#LN1179"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN345"><span class='Ref_to_Member'>transtypeLen</span></a><span class='Parentheses'>))</span> 
                <a href="../utils/adt/expandeddatum.c.html#LN134"><span class='Ref_to_Func'>DeleteExpandedObject</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1180"><span class='Ref_to_Parameter'>pergroupstate</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN461"><span class='Ref_to_Member'>transValue</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN554"><span class='Ref_to_Macro'>DatumGetPointer</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1180"><span class='Ref_to_Parameter'>pergroupstate</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN461"><span class='Ref_to_Member'>transValue</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !pertrans-&GT;transtypeB... &raquo; </span> 
 
    <a href="nodeAgg.c.html#LN1180"><span class='Ref_to_Parameter'>pergroupstate</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN461"><span class='Ref_to_Member'>transValue</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN1184"><span class='Ref_To_Local'>newVal</span></a><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN1180"><span class='Ref_to_Parameter'>pergroupstate</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN462"><span class='Ref_to_Member'>transValueIsNull</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN1182"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN82"><span class='Ref_to_Member'>isnull</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1183"><span class='Ref_To_Local'>oldContext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end advance_combine_function &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * Run the transition function for a DISTINCT or ORDER BY aggregate 
 * with only one input.  This is called after we have completed 
 * entering all the input values into the sort object.  We complete the 
 * sort, read out the values in sorted order, and run the transition 
 * function on each value (applying DISTINCT if appropriate). 
 * 
 * Note that the strictness of the transition function was checked when 
 * entering the values into the sort, so we don't check it again here; 
 * we just apply standard SQL DISTINCT logic. 
 * 
 * The one-input case is handled separately from the multi-input case 
 * for performance reasons: for single by-value inputs, such as the 
 * common case of count(distinct id), the tuplesort_getdatum code path 
 * is around 300% faster.  (The speedup for by-reference types is less 
 * but still noticeable.) 
 * 
 * This function handles only one grouping set (already set in 
 * aggstate-&GT;current_set). 
 * 
 * When called, CurrentMemoryContext should be the per-query context. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1299"></a><span class='Declare_Function'>process_ordered_aggregate_single</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Delimiter'>, 
</span><a name="LN1300"></a>                                 <a href="../../include/nodes/execnodes.h.html#LN1734"><span class='Ref_to_Typedef'>AggStatePerTrans</span></a> <span class='Declare_Parameter'>pertrans</span><span class='Delimiter'>, 
</span><a name="LN1301"></a>                                 <a href="../../include/nodes/execnodes.h.html#LN1735"><span class='Ref_to_Typedef'>AggStatePerGroup</span></a> <span class='Declare_Parameter'>pergroupstate</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1303"></a>    <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>oldVal</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN1304"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>oldIsNull</span> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span><a name="LN1305"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>haveOldVal</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN1306"></a>    <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>workcontext</span> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN1299"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1754"><span class='Ref_to_Member'>tmpcontext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN202"><span class='Ref_to_Member'>ecxt_per_tuple_memory</span></a><span class='Delimiter'>; 
</span><a name="LN1307"></a>    <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldContext</span><span class='Delimiter'>; 
</span><a name="LN1308"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>isDistinct</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1300"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN316"><span class='Ref_to_Member'>numDistinctCols</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1309"></a>    <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>newAbbrevVal</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN1310"></a>    <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>oldAbbrevVal</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN1311"></a>    <a href="../../include/fmgr.h.html#LN37"><span class='Ref_to_Typedef'>FunctionCallInfo</span></a> <span class='Declare_Local'>fcinfo</span> <span class='Operator'>= &</span><a href="nodeAgg.c.html#LN1300"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN387"><span class='Ref_to_Member'>transfn_fcinfo</span></a><span class='Delimiter'>; 
</span><a name="LN1312"></a>    <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>newVal</span><span class='Delimiter'>; 
</span><a name="LN1313"></a>    <span class='Keyword'>bool</span>       <span class='Operator'>*</span><span class='Declare_Local'>isNull</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1300"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN316"><span class='Ref_to_Member'>numDistinctCols</span></a> <span class='Operator'>&LT; </span><span class='Number'>2</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/utils/tuplesort.h.html#LN94"><span class='Ref_to_Proto'>tuplesort_performsort</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1300"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN379"><span class='Ref_to_Member'>sortstates</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1299"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1760"><span class='Ref_to_Member'>current_set</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Load the column into argument 1 (arg 0 will be transition value) */ 
</span>    <a href="nodeAgg.c.html#LN1312"><span class='Ref_To_Local'>newVal</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN1311"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN84"><span class='Ref_to_Member'>arg</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN1313"><span class='Ref_To_Local'>isNull</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN1311"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN85"><span class='Ref_to_Member'>argnull</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Note: if input type is pass-by-ref, the datums returned by the sort are 
     * freshly palloc'd in the per-query context, so we must be careful to 
     * pfree them when they are no longer needed. 
     */ 
</span> 
    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="../../include/utils/tuplesort.h.html#LN100"><span class='Ref_to_Proto'>tuplesort_getdatum</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1300"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN379"><span class='Ref_to_Member'>sortstates</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1299"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1760"><span class='Ref_to_Member'>current_set</span></a><span class='Delimiter'>], 
</span>                              <span class='Boolean'>true</span><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN1312"><span class='Ref_To_Local'>newVal</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN1313"><span class='Ref_To_Local'>isNull</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nodeAgg.c.html#LN1309"><span class='Ref_To_Local'>newAbbrevVal</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Clear and select the working context for evaluation of the equality 
         * function and transition function. 
         */ 
</span>        <a href="../../include/utils/memutils.h.html#LN73"><span class='Ref_to_Proto'>MemoryContextReset</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1306"><span class='Ref_To_Local'>workcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="nodeAgg.c.html#LN1307"><span class='Ref_To_Local'>oldContext</span></a> <span class='Operator'>= </span><a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1306"><span class='Ref_To_Local'>workcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If DISTINCT mode, and not distinct from prior, skip it. 
         * 
         * Note: we assume equality functions don't care about collation. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1308"><span class='Ref_To_Local'>isDistinct</span></a> <span class='Operator'>&& 
</span>            <a href="nodeAgg.c.html#LN1305"><span class='Ref_To_Local'>haveOldVal</span></a> <span class='Operator'>&& 
</span>            <span class='Parentheses'>((</span><a href="nodeAgg.c.html#LN1304"><span class='Ref_To_Local'>oldIsNull</span></a> <span class='Operator'>&& *</span><a href="nodeAgg.c.html#LN1313"><span class='Ref_To_Local'>isNull</span></a><span class='Parentheses'>)</span> <span class='Operator'>|| 
</span>             <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="nodeAgg.c.html#LN1304"><span class='Ref_To_Local'>oldIsNull</span></a> <span class='Operator'>&& !*</span><a href="nodeAgg.c.html#LN1313"><span class='Ref_To_Local'>isNull</span></a> <span class='Operator'>&& 
</span>              <a href="nodeAgg.c.html#LN1310"><span class='Ref_To_Local'>oldAbbrevVal</span></a> <span class='Operator'>== </span><a href="nodeAgg.c.html#LN1309"><span class='Ref_To_Local'>newAbbrevVal</span></a> <span class='Operator'>&& 
</span>              <a href="../../include/postgres.h.html#LN398"><span class='Ref_to_Macro'>DatumGetBool</span></a><span class='Parentheses'>(</span><a href="../../include/fmgr.h.html#LN603"><span class='Ref_to_Macro'>FunctionCall2</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nodeAgg.c.html#LN1300"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN329"><span class='Ref_to_Member'>equalfns</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>], 
</span>                                         <a href="nodeAgg.c.html#LN1303"><span class='Ref_To_Local'>oldVal</span></a><span class='Delimiter'>, </span><span class='Operator'>*</span><a href="nodeAgg.c.html#LN1312"><span class='Ref_To_Local'>newVal</span></a><span class='Parentheses'>)))))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* equal to prior, so forget this one */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="nodeAgg.c.html#LN1300"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN346"><span class='Ref_to_Member'>inputtypeByVal</span></a> <span class='Operator'>&& !*</span><a href="nodeAgg.c.html#LN1313"><span class='Ref_To_Local'>isNull</span></a><span class='Parentheses'>) 
</span>                <a href="../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN554"><span class='Ref_to_Macro'>DatumGetPointer</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="nodeAgg.c.html#LN1312"><span class='Ref_To_Local'>newVal</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <a href="nodeAgg.c.html#LN526"><span class='Ref_to_Proto'>advance_transition_function</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1299"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN1300"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN1301"><span class='Ref_to_Parameter'>pergroupstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* forget the old value, if any */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="nodeAgg.c.html#LN1304"><span class='Ref_To_Local'>oldIsNull</span></a> <span class='Operator'>&& !</span><a href="nodeAgg.c.html#LN1300"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN346"><span class='Ref_to_Member'>inputtypeByVal</span></a><span class='Parentheses'>) 
</span>                <a href="../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN554"><span class='Ref_to_Macro'>DatumGetPointer</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1303"><span class='Ref_To_Local'>oldVal</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* and remember the new one for subsequent equality checks */ 
</span>            <a href="nodeAgg.c.html#LN1303"><span class='Ref_To_Local'>oldVal</span></a> <span class='Operator'>= *</span><a href="nodeAgg.c.html#LN1312"><span class='Ref_To_Local'>newVal</span></a><span class='Delimiter'>; 
</span>            <a href="nodeAgg.c.html#LN1310"><span class='Ref_To_Local'>oldAbbrevVal</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN1309"><span class='Ref_To_Local'>newAbbrevVal</span></a><span class='Delimiter'>; 
</span>            <a href="nodeAgg.c.html#LN1304"><span class='Ref_To_Local'>oldIsNull</span></a> <span class='Operator'>= *</span><a href="nodeAgg.c.html#LN1313"><span class='Ref_To_Local'>isNull</span></a><span class='Delimiter'>; 
</span>            <a href="nodeAgg.c.html#LN1305"><span class='Ref_To_Local'>haveOldVal</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1307"><span class='Ref_To_Local'>oldContext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while tuplesort_getdatum(pe... &raquo; </span> 
 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="nodeAgg.c.html#LN1304"><span class='Ref_To_Local'>oldIsNull</span></a> <span class='Operator'>&& !</span><a href="nodeAgg.c.html#LN1300"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN346"><span class='Ref_to_Member'>inputtypeByVal</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN554"><span class='Ref_to_Macro'>DatumGetPointer</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1303"><span class='Ref_To_Local'>oldVal</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/utils/tuplesort.h.html#LN106"><span class='Ref_to_Proto'>tuplesort_end</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1300"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN379"><span class='Ref_to_Member'>sortstates</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1299"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1760"><span class='Ref_to_Member'>current_set</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN1300"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN379"><span class='Ref_to_Member'>sortstates</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1299"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1760"><span class='Ref_to_Member'>current_set</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end process_ordered_aggregate_single &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Run the transition function for a DISTINCT or ORDER BY aggregate 
 * with more than one input.  This is called after we have completed 
 * entering all the input values into the sort object.  We complete the 
 * sort, read out the values in sorted order, and run the transition 
 * function on each value (applying DISTINCT if appropriate). 
 * 
 * This function handles only one grouping set (already set in 
 * aggstate-&GT;current_set). 
 * 
 * When called, CurrentMemoryContext should be the per-query context. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1392"></a><span class='Declare_Function'>process_ordered_aggregate_multi</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Delimiter'>, 
</span><a name="LN1393"></a>                                <a href="../../include/nodes/execnodes.h.html#LN1734"><span class='Ref_to_Typedef'>AggStatePerTrans</span></a> <span class='Declare_Parameter'>pertrans</span><span class='Delimiter'>, 
</span><a name="LN1394"></a>                                <a href="../../include/nodes/execnodes.h.html#LN1735"><span class='Ref_to_Typedef'>AggStatePerGroup</span></a> <span class='Declare_Parameter'>pergroupstate</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1396"></a>    <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>workcontext</span> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN1392"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1754"><span class='Ref_to_Member'>tmpcontext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN202"><span class='Ref_to_Member'>ecxt_per_tuple_memory</span></a><span class='Delimiter'>; 
</span><a name="LN1397"></a>    <a href="../../include/fmgr.h.html#LN37"><span class='Ref_to_Typedef'>FunctionCallInfo</span></a> <span class='Declare_Local'>fcinfo</span> <span class='Operator'>= &</span><a href="nodeAgg.c.html#LN1393"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN387"><span class='Ref_to_Member'>transfn_fcinfo</span></a><span class='Delimiter'>; 
</span><a name="LN1398"></a>    <a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Local'>slot1</span> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN1393"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN362"><span class='Ref_to_Member'>sortslot</span></a><span class='Delimiter'>; 
</span><a name="LN1399"></a>    <a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Local'>slot2</span> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN1393"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN363"><span class='Ref_to_Member'>uniqslot</span></a><span class='Delimiter'>; 
</span><a name="LN1400"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numTransInputs</span> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN1393"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN278"><span class='Ref_to_Member'>numTransInputs</span></a><span class='Delimiter'>; 
</span><a name="LN1401"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numDistinctCols</span> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN1393"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN316"><span class='Ref_to_Member'>numDistinctCols</span></a><span class='Delimiter'>; 
</span><a name="LN1402"></a>    <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>newAbbrevVal</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN1403"></a>    <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>oldAbbrevVal</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN1404"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>haveOldValue</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN1405"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/utils/tuplesort.h.html#LN94"><span class='Ref_to_Proto'>tuplesort_performsort</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1393"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN379"><span class='Ref_to_Member'>sortstates</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1392"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1760"><span class='Ref_to_Member'>current_set</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/executor/tuptable.h.html#LN154"><span class='Ref_to_Proto'>ExecClearTuple</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1398"><span class='Ref_To_Local'>slot1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1399"><span class='Ref_To_Local'>slot2</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/executor/tuptable.h.html#LN154"><span class='Ref_to_Proto'>ExecClearTuple</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1399"><span class='Ref_To_Local'>slot2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="../../include/utils/tuplesort.h.html#LN96"><span class='Ref_to_Proto'>tuplesort_gettupleslot</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1393"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN379"><span class='Ref_to_Member'>sortstates</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1392"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1760"><span class='Ref_to_Member'>current_set</span></a><span class='Delimiter'>], 
</span>                                  <span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN1398"><span class='Ref_To_Local'>slot1</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nodeAgg.c.html#LN1402"><span class='Ref_To_Local'>newAbbrevVal</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Extract the first numTransInputs columns as datums to pass to the 
         * transfn.  (This will help execTuplesMatch too, so we do it 
         * immediately.) 
         */ 
</span>        <a href="../../include/executor/tuptable.h.html#LN169"><span class='Ref_to_Proto'>slot_getsomeattrs</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1398"><span class='Ref_To_Local'>slot1</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN1400"><span class='Ref_To_Local'>numTransInputs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1401"><span class='Ref_To_Local'>numDistinctCols</span></a> <span class='Operator'>== </span><span class='Number'>0</span> <span class='Operator'>|| 
</span>            <span class='Operator'>!</span><a href="nodeAgg.c.html#LN1404"><span class='Ref_To_Local'>haveOldValue</span></a> <span class='Operator'>|| 
</span>            <a href="nodeAgg.c.html#LN1402"><span class='Ref_To_Local'>newAbbrevVal</span></a> <span class='Operator'>!= </span><a href="nodeAgg.c.html#LN1403"><span class='Ref_To_Local'>oldAbbrevVal</span></a> <span class='Operator'>|| 
</span>            <span class='Operator'>!</span><a href="execGrouping.c.html#LN67"><span class='Ref_to_Func'>execTuplesMatch</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1398"><span class='Ref_To_Local'>slot1</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN1399"><span class='Ref_To_Local'>slot2</span></a><span class='Delimiter'>, 
</span>                             <a href="nodeAgg.c.html#LN1401"><span class='Ref_To_Local'>numDistinctCols</span></a><span class='Delimiter'>, 
</span>                             <a href="nodeAgg.c.html#LN1393"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN319"><span class='Ref_to_Member'>sortColIdx</span></a><span class='Delimiter'>, 
</span>                             <a href="nodeAgg.c.html#LN1393"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN329"><span class='Ref_to_Member'>equalfns</span></a><span class='Delimiter'>, 
</span>                             <a href="nodeAgg.c.html#LN1396"><span class='Ref_To_Local'>workcontext</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Load values into fcinfo */ 
</span>            <span class='Comment_Multi_Line'>/* Start from 1, since the 0th arg will be the transition value */ 
</span>            <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1405"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN1405"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="nodeAgg.c.html#LN1400"><span class='Ref_To_Local'>numTransInputs</span></a><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN1405"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="nodeAgg.c.html#LN1397"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN84"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1405"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="nodeAgg.c.html#LN1398"><span class='Ref_To_Local'>slot1</span></a><span class='Operator'>-&GT;</span><a href="../../include/executor/tuptable.h.html#LN124"><span class='Ref_to_Member'>tts_values</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1405"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>                <a href="nodeAgg.c.html#LN1397"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN85"><span class='Ref_to_Member'>argnull</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1405"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="nodeAgg.c.html#LN1398"><span class='Ref_To_Local'>slot1</span></a><span class='Operator'>-&GT;</span><a href="../../include/executor/tuptable.h.html#LN125"><span class='Ref_to_Member'>tts_isnull</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1405"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>            <span class='Delimiter'>} 
</span> 
            <a href="nodeAgg.c.html#LN526"><span class='Ref_to_Proto'>advance_transition_function</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1392"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN1393"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN1394"><span class='Ref_to_Parameter'>pergroupstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1401"><span class='Ref_To_Local'>numDistinctCols</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* swap the slot pointers to retain the current tuple */ 
</span><a name="LN1445"></a>                <a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tmpslot</span> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN1399"><span class='Ref_To_Local'>slot2</span></a><span class='Delimiter'>; 
</span> 
                <a href="nodeAgg.c.html#LN1399"><span class='Ref_To_Local'>slot2</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN1398"><span class='Ref_To_Local'>slot1</span></a><span class='Delimiter'>; 
</span>                <a href="nodeAgg.c.html#LN1398"><span class='Ref_To_Local'>slot1</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN1445"><span class='Ref_To_Local'>tmpslot</span></a><span class='Delimiter'>; 
</span>                <span class='Comment_Multi_Line'>/* avoid execTuplesMatch() calls by reusing abbreviated keys */ 
</span>                <a href="nodeAgg.c.html#LN1403"><span class='Ref_To_Local'>oldAbbrevVal</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN1402"><span class='Ref_To_Local'>newAbbrevVal</span></a><span class='Delimiter'>; 
</span>                <a href="nodeAgg.c.html#LN1404"><span class='Ref_To_Local'>haveOldValue</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if numDistinctCols==0||!... &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* Reset context each time, unless execTuplesMatch did it for us */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1401"><span class='Ref_To_Local'>numDistinctCols</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <a href="../../include/utils/memutils.h.html#LN73"><span class='Ref_to_Proto'>MemoryContextReset</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1396"><span class='Ref_To_Local'>workcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/executor/tuptable.h.html#LN154"><span class='Ref_to_Proto'>ExecClearTuple</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1398"><span class='Ref_To_Local'>slot1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while tuplesort_gettupleslo... &raquo; </span> 
 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1399"><span class='Ref_To_Local'>slot2</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/executor/tuptable.h.html#LN154"><span class='Ref_to_Proto'>ExecClearTuple</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1399"><span class='Ref_To_Local'>slot2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/utils/tuplesort.h.html#LN106"><span class='Ref_to_Proto'>tuplesort_end</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1393"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN379"><span class='Ref_to_Member'>sortstates</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1392"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1760"><span class='Ref_to_Member'>current_set</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN1393"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN379"><span class='Ref_to_Member'>sortstates</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1392"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1760"><span class='Ref_to_Member'>current_set</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end process_ordered_aggregate_multi &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Compute the final value of one aggregate. 
 * 
 * This function handles only one grouping set (already set in 
 * aggstate-&GT;current_set). 
 * 
 * The finalfunction will be run, and the result delivered, in the 
 * output-tuple context; caller's CurrentMemoryContext does not matter. 
 * 
 * The finalfn uses the state as set in the transno. This also might be 
 * being used by another aggregate function, so it's important that we do 
 * nothing destructive here. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1483"></a><span class='Declare_Function'>finalize_aggregate</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Delimiter'>, 
</span><a name="LN1484"></a>                   <a href="../../include/nodes/execnodes.h.html#LN1733"><span class='Ref_to_Typedef'>AggStatePerAgg</span></a> <span class='Declare_Parameter'>peragg</span><span class='Delimiter'>, 
</span><a name="LN1485"></a>                   <a href="../../include/nodes/execnodes.h.html#LN1735"><span class='Ref_to_Typedef'>AggStatePerGroup</span></a> <span class='Declare_Parameter'>pergroupstate</span><span class='Delimiter'>, 
</span><a name="LN1486"></a>                   <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>resultVal</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>resultIsNull</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1488"></a>    <a href="../../include/fmgr.h.html#LN76"><span class='Ref_to_Struct'>FunctionCallInfoData</span></a> <span class='Declare_Local'>fcinfo</span><span class='Delimiter'>; 
</span><a name="LN1489"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>anynull</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN1490"></a>    <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldContext</span><span class='Delimiter'>; 
</span><a name="LN1491"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN1492"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span><a name="LN1493"></a>    <a href="../../include/nodes/execnodes.h.html#LN1734"><span class='Ref_to_Typedef'>AggStatePerTrans</span></a> <span class='Declare_Local'>pertrans</span> <span class='Operator'>= &</span><a href="nodeAgg.c.html#LN1483"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1751"><span class='Ref_to_Member'>pertrans</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1484"><span class='Ref_to_Parameter'>peragg</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN415"><span class='Ref_to_Member'>transno</span></a><span class='Delimiter'>]; 
</span> 
    <a href="nodeAgg.c.html#LN1490"><span class='Ref_To_Local'>oldContext</span></a> <span class='Operator'>= </span><a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1483"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1741"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN842"><span class='Ref_to_Member'>ps_ExprContext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN202"><span class='Ref_to_Member'>ecxt_per_tuple_memory</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Evaluate any direct arguments.  We do this even if there's no finalfn 
     * (which is unlikely anyway), so that side-effects happen as expected. 
     * The direct arguments go into arg positions 1 and up, leaving position 0 
     * for the transition state value. 
     */ 
</span>    <a href="nodeAgg.c.html#LN1491"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1492"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN1493"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN294"><span class='Ref_to_Member'>aggdirectargs</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1506"></a>        <a href="../../include/nodes/execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>expr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1492"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="nodeAgg.c.html#LN1488"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>.</span><a href="../../include/fmgr.h.html#LN84"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1491"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/executor/executor.h.html#LN264"><span class='Ref_to_Func'>ExecEvalExpr</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1506"><span class='Ref_To_Local'>expr</span></a><span class='Delimiter'>, 
</span>                                     <a href="nodeAgg.c.html#LN1483"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1741"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN842"><span class='Ref_to_Member'>ps_ExprContext</span></a><span class='Delimiter'>, 
</span>                                     <span class='Operator'>&</span><a href="nodeAgg.c.html#LN1488"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>.</span><a href="../../include/fmgr.h.html#LN85"><span class='Ref_to_Member'>argnull</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1491"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="nodeAgg.c.html#LN1489"><span class='Ref_To_Local'>anynull</span></a> <span class='Operator'>|= </span><a href="nodeAgg.c.html#LN1488"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>.</span><a href="../../include/fmgr.h.html#LN85"><span class='Ref_to_Member'>argnull</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1491"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>        <a href="nodeAgg.c.html#LN1491"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Apply the agg's finalfn if one is provided, else return transValue. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1484"><span class='Ref_to_Parameter'>peragg</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN418"><span class='Ref_to_Member'>finalfn_oid</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1520"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>numFinalArgs</span> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN1484"><span class='Ref_to_Parameter'>peragg</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN432"><span class='Ref_to_Member'>numFinalArgs</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* set up aggstate-&GT;curpertrans for AggGetAggref() */ 
</span>        <a href="nodeAgg.c.html#LN1483"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1756"><span class='Ref_to_Member'>curpertrans</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN1493"><span class='Ref_To_Local'>pertrans</span></a><span class='Delimiter'>; 
</span> 
        <a href="../../include/fmgr.h.html#LN119"><span class='Ref_to_Macro'>InitFunctionCallInfoData</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1488"><span class='Ref_To_Local'>fcinfo</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nodeAgg.c.html#LN1484"><span class='Ref_to_Parameter'>peragg</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN424"><span class='Ref_to_Member'>finalfn</span></a><span class='Delimiter'>, 
</span>                                 <a href="nodeAgg.c.html#LN1520"><span class='Ref_To_Local'>numFinalArgs</span></a><span class='Delimiter'>, 
</span>                                 <a href="nodeAgg.c.html#LN1493"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN309"><span class='Ref_to_Member'>aggCollation</span></a><span class='Delimiter'>, 
</span>                                 <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeAgg.c.html#LN1483"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Fill in the transition state value */ 
</span>        <a href="nodeAgg.c.html#LN1488"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>.</span><a href="../../include/fmgr.h.html#LN84"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/utils/expandeddatum.h.html#LN143"><span class='Ref_to_Macro'>MakeExpandedObjectReadOnly</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1485"><span class='Ref_to_Parameter'>pergroupstate</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN461"><span class='Ref_to_Member'>transValue</span></a><span class='Delimiter'>, 
</span>                                             <a href="nodeAgg.c.html#LN1485"><span class='Ref_to_Parameter'>pergroupstate</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN462"><span class='Ref_to_Member'>transValueIsNull</span></a><span class='Delimiter'>, 
</span>                                                   <a href="nodeAgg.c.html#LN1493"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN345"><span class='Ref_to_Member'>transtypeLen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="nodeAgg.c.html#LN1488"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>.</span><a href="../../include/fmgr.h.html#LN85"><span class='Ref_to_Member'>argnull</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="nodeAgg.c.html#LN1485"><span class='Ref_to_Parameter'>pergroupstate</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN462"><span class='Ref_to_Member'>transValueIsNull</span></a><span class='Delimiter'>; 
</span>        <a href="nodeAgg.c.html#LN1489"><span class='Ref_To_Local'>anynull</span></a> <span class='Operator'>|= </span><a href="nodeAgg.c.html#LN1485"><span class='Ref_to_Parameter'>pergroupstate</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN462"><span class='Ref_to_Member'>transValueIsNull</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Fill any remaining argument positions with nulls */ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN1491"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="nodeAgg.c.html#LN1520"><span class='Ref_To_Local'>numFinalArgs</span></a><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN1491"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="nodeAgg.c.html#LN1488"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>.</span><a href="../../include/fmgr.h.html#LN84"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1491"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <a href="nodeAgg.c.html#LN1488"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>.</span><a href="../../include/fmgr.h.html#LN85"><span class='Ref_to_Member'>argnull</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1491"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <a href="nodeAgg.c.html#LN1489"><span class='Ref_To_Local'>anynull</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1488"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>.</span><a href="../../include/fmgr.h.html#LN78"><span class='Ref_to_Member'>flinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN60"><span class='Ref_to_Member'>fn_strict</span></a> <span class='Operator'>&& </span><a href="nodeAgg.c.html#LN1489"><span class='Ref_To_Local'>anynull</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* don't call a strict function with NULL inputs */ 
</span>            <span class='Operator'>*</span><a href="nodeAgg.c.html#LN1486"><span class='Ref_to_Parameter'>resultVal</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <span class='Operator'>*</span><a href="nodeAgg.c.html#LN1486"><span class='Ref_to_Parameter'>resultIsNull</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Operator'>*</span><a href="nodeAgg.c.html#LN1486"><span class='Ref_to_Parameter'>resultVal</span></a> <span class='Operator'>= </span><a href="../../include/fmgr.h.html#LN136"><span class='Ref_to_Macro'>FunctionCallInvoke</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nodeAgg.c.html#LN1488"><span class='Ref_To_Local'>fcinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Operator'>*</span><a href="nodeAgg.c.html#LN1486"><span class='Ref_to_Parameter'>resultIsNull</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN1488"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>.</span><a href="../../include/fmgr.h.html#LN82"><span class='Ref_to_Member'>isnull</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <a href="nodeAgg.c.html#LN1483"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1756"><span class='Ref_to_Member'>curpertrans</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if OidIsValid(peragg-&GT;fi... &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Don't need MakeExpandedObjectReadOnly; datumCopy will copy it */ 
</span>        <span class='Operator'>*</span><a href="nodeAgg.c.html#LN1486"><span class='Ref_to_Parameter'>resultVal</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN1485"><span class='Ref_to_Parameter'>pergroupstate</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN461"><span class='Ref_to_Member'>transValue</span></a><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="nodeAgg.c.html#LN1486"><span class='Ref_to_Parameter'>resultIsNull</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN1485"><span class='Ref_to_Parameter'>pergroupstate</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN462"><span class='Ref_to_Member'>transValueIsNull</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If result is pass-by-ref, make sure it is in the right context. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="nodeAgg.c.html#LN1484"><span class='Ref_to_Parameter'>peragg</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN439"><span class='Ref_to_Member'>resulttypeByVal</span></a> <span class='Operator'>&& !*</span><a href="nodeAgg.c.html#LN1486"><span class='Ref_to_Parameter'>resultIsNull</span></a> <span class='Operator'>&& 
</span>        <span class='Operator'>!</span><a href="../../include/utils/memutils.h.html#LN91"><span class='Ref_to_Proto'>MemoryContextContains</span></a><span class='Parentheses'>(</span><a href="../utils/mmgr/mcxt.c.html#LN36"><span class='Ref_to_Global_Var'>CurrentMemoryContext</span></a><span class='Delimiter'>, 
</span>                               <a href="../../include/postgres.h.html#LN554"><span class='Ref_to_Macro'>DatumGetPointer</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="nodeAgg.c.html#LN1486"><span class='Ref_to_Parameter'>resultVal</span></a><span class='Parentheses'>)))</span> 
        <span class='Operator'>*</span><a href="nodeAgg.c.html#LN1486"><span class='Ref_to_Parameter'>resultVal</span></a> <span class='Operator'>= </span><a href="../../include/utils/datum.h.html#LN30"><span class='Ref_to_Proto'>datumCopy</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="nodeAgg.c.html#LN1486"><span class='Ref_to_Parameter'>resultVal</span></a><span class='Delimiter'>, 
</span>                               <a href="nodeAgg.c.html#LN1484"><span class='Ref_to_Parameter'>peragg</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN439"><span class='Ref_to_Member'>resulttypeByVal</span></a><span class='Delimiter'>, 
</span>                               <a href="nodeAgg.c.html#LN1484"><span class='Ref_to_Parameter'>peragg</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN438"><span class='Ref_to_Member'>resulttypeLen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1490"><span class='Ref_To_Local'>oldContext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end finalize_aggregate &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Compute the output value of one partial aggregate. 
 * 
 * The serialization function will be run, and the result delivered, in the 
 * output-tuple context; caller's CurrentMemoryContext does not matter. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1585"></a><span class='Declare_Function'>finalize_partialaggregate</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Delimiter'>, 
</span><a name="LN1586"></a>                          <a href="../../include/nodes/execnodes.h.html#LN1733"><span class='Ref_to_Typedef'>AggStatePerAgg</span></a> <span class='Declare_Parameter'>peragg</span><span class='Delimiter'>, 
</span><a name="LN1587"></a>                          <a href="../../include/nodes/execnodes.h.html#LN1735"><span class='Ref_to_Typedef'>AggStatePerGroup</span></a> <span class='Declare_Parameter'>pergroupstate</span><span class='Delimiter'>, 
</span><a name="LN1588"></a>                          <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>resultVal</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>resultIsNull</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1590"></a>    <a href="../../include/nodes/execnodes.h.html#LN1734"><span class='Ref_to_Typedef'>AggStatePerTrans</span></a> <span class='Declare_Local'>pertrans</span> <span class='Operator'>= &</span><a href="nodeAgg.c.html#LN1585"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1751"><span class='Ref_to_Member'>pertrans</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1586"><span class='Ref_to_Parameter'>peragg</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN415"><span class='Ref_to_Member'>transno</span></a><span class='Delimiter'>]; 
</span><a name="LN1591"></a>    <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldContext</span><span class='Delimiter'>; 
</span> 
    <a href="nodeAgg.c.html#LN1591"><span class='Ref_To_Local'>oldContext</span></a> <span class='Operator'>= </span><a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1585"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1741"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN842"><span class='Ref_to_Member'>ps_ExprContext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN202"><span class='Ref_to_Member'>ecxt_per_tuple_memory</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * serialfn_oid will be set if we must serialize the transvalue before 
     * returning it 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1590"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN284"><span class='Ref_to_Member'>serialfn_oid</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Don't call a strict serialization function with NULL input. */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1590"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN303"><span class='Ref_to_Member'>serialfn</span></a><span class='Operator'>.</span><a href="../../include/fmgr.h.html#LN60"><span class='Ref_to_Member'>fn_strict</span></a> <span class='Operator'>&& </span><a href="nodeAgg.c.html#LN1587"><span class='Ref_to_Parameter'>pergroupstate</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN462"><span class='Ref_to_Member'>transValueIsNull</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Operator'>*</span><a href="nodeAgg.c.html#LN1588"><span class='Ref_to_Parameter'>resultVal</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <span class='Operator'>*</span><a href="nodeAgg.c.html#LN1588"><span class='Ref_to_Parameter'>resultIsNull</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span><a name="LN1609"></a>            <a href="../../include/fmgr.h.html#LN37"><span class='Ref_to_Typedef'>FunctionCallInfo</span></a> <span class='Declare_Local'>fcinfo</span> <span class='Operator'>= &</span><a href="nodeAgg.c.html#LN1590"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN390"><span class='Ref_to_Member'>serialfn_fcinfo</span></a><span class='Delimiter'>; 
</span> 
            <a href="nodeAgg.c.html#LN1609"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN84"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/utils/expandeddatum.h.html#LN143"><span class='Ref_to_Macro'>MakeExpandedObjectReadOnly</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1587"><span class='Ref_to_Parameter'>pergroupstate</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN461"><span class='Ref_to_Member'>transValue</span></a><span class='Delimiter'>, 
</span>                                             <a href="nodeAgg.c.html#LN1587"><span class='Ref_to_Parameter'>pergroupstate</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN462"><span class='Ref_to_Member'>transValueIsNull</span></a><span class='Delimiter'>, 
</span>                                                     <a href="nodeAgg.c.html#LN1590"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN345"><span class='Ref_to_Member'>transtypeLen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="nodeAgg.c.html#LN1609"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN85"><span class='Ref_to_Member'>argnull</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="nodeAgg.c.html#LN1587"><span class='Ref_to_Parameter'>pergroupstate</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN462"><span class='Ref_to_Member'>transValueIsNull</span></a><span class='Delimiter'>; 
</span> 
            <span class='Operator'>*</span><a href="nodeAgg.c.html#LN1588"><span class='Ref_to_Parameter'>resultVal</span></a> <span class='Operator'>= </span><a href="../../include/fmgr.h.html#LN136"><span class='Ref_to_Macro'>FunctionCallInvoke</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1609"><span class='Ref_To_Local'>fcinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Operator'>*</span><a href="nodeAgg.c.html#LN1588"><span class='Ref_to_Parameter'>resultIsNull</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN1609"><span class='Ref_To_Local'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN82"><span class='Ref_to_Member'>isnull</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if OidIsValid(pertrans-&GT;... &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Don't need MakeExpandedObjectReadOnly; datumCopy will copy it */ 
</span>        <span class='Operator'>*</span><a href="nodeAgg.c.html#LN1588"><span class='Ref_to_Parameter'>resultVal</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN1587"><span class='Ref_to_Parameter'>pergroupstate</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN461"><span class='Ref_to_Member'>transValue</span></a><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="nodeAgg.c.html#LN1588"><span class='Ref_to_Parameter'>resultIsNull</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN1587"><span class='Ref_to_Parameter'>pergroupstate</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN462"><span class='Ref_to_Member'>transValueIsNull</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* If result is pass-by-ref, make sure it is in the right context. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="nodeAgg.c.html#LN1586"><span class='Ref_to_Parameter'>peragg</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN439"><span class='Ref_to_Member'>resulttypeByVal</span></a> <span class='Operator'>&& !*</span><a href="nodeAgg.c.html#LN1588"><span class='Ref_to_Parameter'>resultIsNull</span></a> <span class='Operator'>&& 
</span>        <span class='Operator'>!</span><a href="../../include/utils/memutils.h.html#LN91"><span class='Ref_to_Proto'>MemoryContextContains</span></a><span class='Parentheses'>(</span><a href="../utils/mmgr/mcxt.c.html#LN36"><span class='Ref_to_Global_Var'>CurrentMemoryContext</span></a><span class='Delimiter'>, 
</span>                               <a href="../../include/postgres.h.html#LN554"><span class='Ref_to_Macro'>DatumGetPointer</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="nodeAgg.c.html#LN1588"><span class='Ref_to_Parameter'>resultVal</span></a><span class='Parentheses'>)))</span> 
        <span class='Operator'>*</span><a href="nodeAgg.c.html#LN1588"><span class='Ref_to_Parameter'>resultVal</span></a> <span class='Operator'>= </span><a href="../../include/utils/datum.h.html#LN30"><span class='Ref_to_Proto'>datumCopy</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="nodeAgg.c.html#LN1588"><span class='Ref_to_Parameter'>resultVal</span></a><span class='Delimiter'>, 
</span>                               <a href="nodeAgg.c.html#LN1586"><span class='Ref_to_Parameter'>peragg</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN439"><span class='Ref_to_Member'>resulttypeByVal</span></a><span class='Delimiter'>, 
</span>                               <a href="nodeAgg.c.html#LN1586"><span class='Ref_to_Parameter'>peragg</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN438"><span class='Ref_to_Member'>resulttypeLen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1591"><span class='Ref_To_Local'>oldContext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end finalize_partialaggregate &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Prepare to finalize and project based on the specified representative tuple 
 * slot and grouping set. 
 * 
 * In the specified tuple slot, force to null all attributes that should be 
 * read as null in the context of the current grouping set.  Also stash the 
 * current group bitmap where GroupingExpr can get at it. 
 * 
 * This relies on three conditions: 
 * 
 * 1) Nothing is ever going to try and extract the whole tuple from this slot, 
 * only reference it in evaluations, which will only access individual 
 * attributes. 
 * 
 * 2) No system columns are going to need to be nulled. (If a system column is 
 * referenced in a group clause, it is actually projected in the outer plan 
 * tlist.) 
 * 
 * 3) Within a given phase, we never need to recover the value of an attribute 
 * once it has been set to null. 
 * 
 * Poking into the slot this way is a bit ugly, but the consensus is that the 
 * alternative was worse. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1663"></a><span class='Declare_Function'>prepare_projection_slot</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Delimiter'>, </span><a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>slot</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>currentSet</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1663"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1747"><span class='Ref_to_Member'>phase</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN491"><span class='Ref_to_Member'>grouped_cols</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1667"></a>        <a href="../../include/nodes/bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>grouped_cols</span> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN1663"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1747"><span class='Ref_to_Member'>phase</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN491"><span class='Ref_to_Member'>grouped_cols</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1663"><span class='Ref_to_Parameter'>currentSet</span></a><span class='Delimiter'>]; 
</span> 
        <a href="nodeAgg.c.html#LN1663"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1761"><span class='Ref_to_Member'>grouped_cols</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN1667"><span class='Ref_To_Local'>grouped_cols</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1663"><span class='Ref_to_Parameter'>slot</span></a><span class='Operator'>-&GT;</span><a href="../../include/executor/tuptable.h.html#LN115"><span class='Ref_to_Member'>tts_isempty</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Force all values to be NULL if working on an empty input tuple 
             * (i.e. an empty grouping set for which no input rows were 
             * supplied). 
             */ 
</span>            <a href="../../include/executor/tuptable.h.html#LN156"><span class='Ref_to_Proto'>ExecStoreAllNullTuple</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1663"><span class='Ref_to_Parameter'>slot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1663"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1762"><span class='Ref_to_Member'>all_grouped_cols</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1682"></a>            <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* all_grouped_cols is arranged in desc order */ 
</span>            <a href="../../include/executor/tuptable.h.html#LN169"><span class='Ref_to_Proto'>slot_getsomeattrs</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1663"><span class='Ref_to_Parameter'>slot</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN111"><span class='Ref_to_Macro'>linitial_int</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1663"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1762"><span class='Ref_to_Member'>all_grouped_cols</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
            <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1682"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN1663"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1762"><span class='Ref_to_Member'>all_grouped_cols</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN1689"></a>                <span class='Keyword'>int</span>         <span class='Declare_Local'>attnum</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN106"><span class='Ref_to_Macro'>lfirst_int</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1682"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/nodes/bitmapset.h.html#LN75"><span class='Ref_to_Proto'>bms_is_member</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1689"><span class='Ref_To_Local'>attnum</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN1667"><span class='Ref_To_Local'>grouped_cols</span></a><span class='Parentheses'>))</span> 
                    <a href="nodeAgg.c.html#LN1663"><span class='Ref_to_Parameter'>slot</span></a><span class='Operator'>-&GT;</span><a href="../../include/executor/tuptable.h.html#LN125"><span class='Ref_to_Member'>tts_isnull</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1689"><span class='Ref_To_Local'>attnum</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if aggstate-&GT;phase-&GT;grou... &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end prepare_projection_slot &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Compute the final value of all aggregates for one group. 
 * 
 * This function handles only one grouping set at a time, which the caller must 
 * have selected.  It's also the caller's responsibility to adjust the supplied 
 * pergroup parameter to point to the current set's transvalues. 
 * 
 * Results are stored in the output econtext aggvalues/aggnulls. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1708"></a><span class='Declare_Function'>finalize_aggregates</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Delimiter'>, 
</span><a name="LN1709"></a>                    <a href="../../include/nodes/execnodes.h.html#LN1733"><span class='Ref_to_Typedef'>AggStatePerAgg</span></a> <span class='Declare_Parameter'>peraggs</span><span class='Delimiter'>, 
</span><a name="LN1710"></a>                    <a href="../../include/nodes/execnodes.h.html#LN1735"><span class='Ref_to_Typedef'>AggStatePerGroup</span></a> <span class='Declare_Parameter'>pergroup</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1712"></a>    <a href="../../include/nodes/execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Local'>econtext</span> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN1708"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1741"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN842"><span class='Ref_to_Member'>ps_ExprContext</span></a><span class='Delimiter'>; 
</span><a name="LN1713"></a>    <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>aggvalues</span> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN1712"><span class='Ref_To_Local'>econtext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN212"><span class='Ref_to_Member'>ecxt_aggvalues</span></a><span class='Delimiter'>; 
</span><a name="LN1714"></a>    <span class='Keyword'>bool</span>       <span class='Operator'>*</span><span class='Declare_Local'>aggnulls</span> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN1712"><span class='Ref_To_Local'>econtext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN213"><span class='Ref_to_Member'>ecxt_aggnulls</span></a><span class='Delimiter'>; 
</span><a name="LN1715"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>aggno</span><span class='Delimiter'>; 
</span><a name="LN1716"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>transno</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If there were any DISTINCT and/or ORDER BY aggregates, sort their 
     * inputs and run the transition functions. 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1716"><span class='Ref_To_Local'>transno</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN1716"><span class='Ref_To_Local'>transno</span></a> <span class='Operator'>&LT; </span><a href="nodeAgg.c.html#LN1708"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1744"><span class='Ref_to_Member'>numtrans</span></a><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN1716"><span class='Ref_To_Local'>transno</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1724"></a>        <a href="../../include/nodes/execnodes.h.html#LN1734"><span class='Ref_to_Typedef'>AggStatePerTrans</span></a> <span class='Declare_Local'>pertrans</span> <span class='Operator'>= &</span><a href="nodeAgg.c.html#LN1708"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1751"><span class='Ref_to_Member'>pertrans</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1716"><span class='Ref_To_Local'>transno</span></a><span class='Delimiter'>]; 
</span><a name="LN1725"></a>        <a href="../../include/nodes/execnodes.h.html#LN1735"><span class='Ref_to_Typedef'>AggStatePerGroup</span></a> <span class='Declare_Local'>pergroupstate</span><span class='Delimiter'>; 
</span> 
        <a href="nodeAgg.c.html#LN1725"><span class='Ref_To_Local'>pergroupstate</span></a> <span class='Operator'>= &</span><a href="nodeAgg.c.html#LN1710"><span class='Ref_to_Parameter'>pergroup</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1716"><span class='Ref_To_Local'>transno</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1724"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN312"><span class='Ref_to_Member'>numSortCols</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1708"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1745"><span class='Ref_to_Member'>aggstrategy</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/nodes.h.html#LN737"><span class='Ref_to_EnumConst'>AGG_HASHED</span></a> <span class='Operator'>&& 
</span>                   <a href="nodeAgg.c.html#LN1708"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1745"><span class='Ref_to_Member'>aggstrategy</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/nodes.h.html#LN738"><span class='Ref_to_EnumConst'>AGG_MIXED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1724"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN268"><span class='Ref_to_Member'>numInputs</span></a> <span class='Operator'>== </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>                <a href="nodeAgg.c.html#LN535"><span class='Ref_to_Proto'>process_ordered_aggregate_single</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1708"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Delimiter'>, 
</span>                                                 <a href="nodeAgg.c.html#LN1724"><span class='Ref_To_Local'>pertrans</span></a><span class='Delimiter'>, 
</span>                                                 <a href="nodeAgg.c.html#LN1725"><span class='Ref_To_Local'>pergroupstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="nodeAgg.c.html#LN538"><span class='Ref_to_Proto'>process_ordered_aggregate_multi</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1708"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Delimiter'>, 
</span>                                                <a href="nodeAgg.c.html#LN1724"><span class='Ref_To_Local'>pertrans</span></a><span class='Delimiter'>, 
</span>                                                <a href="nodeAgg.c.html#LN1725"><span class='Ref_To_Local'>pergroupstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for transno=0;transno&LT;agg... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Run the final functions. 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1715"><span class='Ref_To_Local'>aggno</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN1715"><span class='Ref_To_Local'>aggno</span></a> <span class='Operator'>&LT; </span><a href="nodeAgg.c.html#LN1708"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1743"><span class='Ref_to_Member'>numaggs</span></a><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN1715"><span class='Ref_To_Local'>aggno</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1750"></a>        <a href="../../include/nodes/execnodes.h.html#LN1733"><span class='Ref_to_Typedef'>AggStatePerAgg</span></a> <span class='Declare_Local'>peragg</span> <span class='Operator'>= &</span><a href="nodeAgg.c.html#LN1709"><span class='Ref_to_Parameter'>peraggs</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1715"><span class='Ref_To_Local'>aggno</span></a><span class='Delimiter'>]; 
</span><a name="LN1751"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>transno</span> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN1750"><span class='Ref_To_Local'>peragg</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN415"><span class='Ref_to_Member'>transno</span></a><span class='Delimiter'>; 
</span><a name="LN1752"></a>        <a href="../../include/nodes/execnodes.h.html#LN1735"><span class='Ref_to_Typedef'>AggStatePerGroup</span></a> <span class='Declare_Local'>pergroupstate</span><span class='Delimiter'>; 
</span> 
        <a href="nodeAgg.c.html#LN1752"><span class='Ref_To_Local'>pergroupstate</span></a> <span class='Operator'>= &</span><a href="nodeAgg.c.html#LN1710"><span class='Ref_to_Parameter'>pergroup</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1751"><span class='Ref_To_Local'>transno</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN767"><span class='Ref_to_Macro'>DO_AGGSPLIT_SKIPFINAL</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1708"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1746"><span class='Ref_to_Member'>aggsplit</span></a><span class='Parentheses'>))</span> 
            <a href="nodeAgg.c.html#LN545"><span class='Ref_to_Proto'>finalize_partialaggregate</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1708"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN1750"><span class='Ref_To_Local'>peragg</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN1752"><span class='Ref_To_Local'>pergroupstate</span></a><span class='Delimiter'>, 
</span>                                      <span class='Operator'>&</span><a href="nodeAgg.c.html#LN1713"><span class='Ref_To_Local'>aggvalues</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1715"><span class='Ref_To_Local'>aggno</span></a><span class='Delimiter'>], </span><span class='Operator'>&</span><a href="nodeAgg.c.html#LN1714"><span class='Ref_To_Local'>aggnulls</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1715"><span class='Ref_To_Local'>aggno</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="nodeAgg.c.html#LN541"><span class='Ref_to_Proto'>finalize_aggregate</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1708"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN1750"><span class='Ref_To_Local'>peragg</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN1752"><span class='Ref_To_Local'>pergroupstate</span></a><span class='Delimiter'>, 
</span>                               <span class='Operator'>&</span><a href="nodeAgg.c.html#LN1713"><span class='Ref_To_Local'>aggvalues</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1715"><span class='Ref_To_Local'>aggno</span></a><span class='Delimiter'>], </span><span class='Operator'>&</span><a href="nodeAgg.c.html#LN1714"><span class='Ref_To_Local'>aggnulls</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1715"><span class='Ref_To_Local'>aggno</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end finalize_aggregates &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Project the result of a group (whose aggs have already been calculated by 
 * finalize_aggregates). Returns the result slot, or NULL if no row is 
 * projected (suppressed by qual). 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>* 
</span><a name="LN1771"></a><span class='Declare_Function'>project_aggregates</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1773"></a>    <a href="../../include/nodes/execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Local'>econtext</span> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN1771"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1741"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN842"><span class='Ref_to_Member'>ps_ExprContext</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Check the qual (HAVING clause); if the group does not match, ignore it. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/executor/executor.h.html#LN344"><span class='Ref_to_Func'>ExecQual</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1771"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1741"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN826"><span class='Ref_to_Member'>qual</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN1773"><span class='Ref_To_Local'>econtext</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Form and return projection tuple using the aggregate results and 
         * the representative input tuple. 
         */ 
</span>        <span class='Control'>return</span> <a href="../../include/executor/executor.h.html#LN307"><span class='Ref_to_Func'>ExecProject</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1771"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1741"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN843"><span class='Ref_to_Member'>ps_ProjInfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
        <a href="../../include/nodes/execnodes.h.html#LN857"><span class='Ref_to_Macro'>InstrCountFiltered1</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1771"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end project_aggregates &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * find_unaggregated_cols 
 *    Construct a bitmapset of the column numbers of un-aggregated Vars 
 *    appearing in our targetlist and qual (HAVING clause) 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a> <span class='Operator'>* 
</span><a name="LN1798"></a><span class='Declare_Function'>find_unaggregated_cols</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1800"></a>    <a href="../../include/nodes/plannodes.h.html#LN781"><span class='Ref_to_Struct'>Agg</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>node</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/plannodes.h.html#LN781"><span class='Ref_to_Struct'>Agg</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeAgg.c.html#LN1798"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1741"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN812"><span class='Ref_to_Member'>plan</span></a><span class='Delimiter'>; 
</span><a name="LN1801"></a>    <a href="../../include/nodes/bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>colnos</span><span class='Delimiter'>; 
</span> 
    <a href="nodeAgg.c.html#LN1801"><span class='Ref_To_Local'>colnos</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="nodeAgg.c.html#LN557"><span class='Ref_to_Proto'>find_unaggregated_cols_walker</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeAgg.c.html#LN1800"><span class='Ref_To_Local'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN783"><span class='Ref_to_Member'>plan</span></a><span class='Operator'>.</span><a href="../../include/nodes/plannodes.h.html#LN143"><span class='Ref_to_Member'>targetlist</span></a><span class='Delimiter'>, 
</span>                                         <span class='Operator'>&</span><a href="nodeAgg.c.html#LN1801"><span class='Ref_To_Local'>colnos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="nodeAgg.c.html#LN557"><span class='Ref_to_Proto'>find_unaggregated_cols_walker</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeAgg.c.html#LN1800"><span class='Ref_To_Local'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN783"><span class='Ref_to_Member'>plan</span></a><span class='Operator'>.</span><a href="../../include/nodes/plannodes.h.html#LN144"><span class='Ref_to_Member'>qual</span></a><span class='Delimiter'>, 
</span>                                         <span class='Operator'>&</span><a href="nodeAgg.c.html#LN1801"><span class='Ref_To_Local'>colnos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="nodeAgg.c.html#LN1801"><span class='Ref_To_Local'>colnos</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Keyword'>static bool 
</span><a name="LN1812"></a><span class='Declare_Function'>find_unaggregated_cols_walker</span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><a href="../../include/nodes/bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>colnos</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1812"><span class='Ref_to_Parameter'>node</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1812"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1818"></a>        <a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>var</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeAgg.c.html#LN1812"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* setrefs.c should have set the varno to OUTER_VAR */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1818"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN165"><span class='Ref_to_Member'>varno</span></a> <span class='Operator'>== </span><a href="../../include/nodes/primnodes.h.html#LN153"><span class='Ref_to_Const'>OUTER_VAR</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1818"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN172"><span class='Ref_to_Member'>varlevelsup</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="nodeAgg.c.html#LN1812"><span class='Ref_to_Parameter'>colnos</span></a> <span class='Operator'>= </span><a href="../../include/nodes/bitmapset.h.html#LN89"><span class='Ref_to_Proto'>bms_add_member</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="nodeAgg.c.html#LN1812"><span class='Ref_to_Parameter'>colnos</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN1818"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN167"><span class='Ref_to_Member'>varattno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1812"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a><span class='Parentheses'>) </span><span class='Operator'>||</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1812"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN337"><span class='Ref_to_Struct'>GroupingFunc</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* do not descend into aggregate exprs */ 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <a href="../../include/nodes/nodeFuncs.h.html#LN52"><span class='Ref_to_Proto'>expression_tree_walker</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1812"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN557"><span class='Ref_to_Proto'>find_unaggregated_cols_walker</span></a><span class='Delimiter'>, 
</span>                                  <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeAgg.c.html#LN1812"><span class='Ref_to_Parameter'>colnos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end find_unaggregated_cols_walker &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Initialize the hash table(s) to empty. 
 * 
 * To implement hashed aggregation, we need a hashtable that stores a 
 * representative tuple and an array of AggStatePerGroup structs for each 
 * distinct set of GROUP BY column values.  We compute the hash key from the 
 * GROUP BY columns.  The per-group data is allocated in lookup_hash_entry(), 
 * for each entry. 
 * 
 * We have a separate hashtable and associated perhash data structure for each 
 * grouping set for which we're doing hashing. 
 * 
 * The hash tables always live in the hashcontext's per-tuple memory context 
 * (there is only one of these for all tables together, since they are all 
 * reset at the same time). 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1852"></a><span class='Declare_Function'>build_hash_table</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1854"></a>    <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>tmpmem</span> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN1852"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1754"><span class='Ref_to_Member'>tmpcontext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN202"><span class='Ref_to_Member'>ecxt_per_tuple_memory</span></a><span class='Delimiter'>; 
</span><a name="LN1855"></a>    <a href="../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a>        <span class='Declare_Local'>additionalsize</span><span class='Delimiter'>; 
</span><a name="LN1856"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1852"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1745"><span class='Ref_to_Member'>aggstrategy</span></a> <span class='Operator'>== </span><a href="../../include/nodes/nodes.h.html#LN737"><span class='Ref_to_EnumConst'>AGG_HASHED</span></a> <span class='Operator'>|| </span><a href="nodeAgg.c.html#LN1852"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1745"><span class='Ref_to_Member'>aggstrategy</span></a> <span class='Operator'>== </span><a href="../../include/nodes/nodes.h.html#LN738"><span class='Ref_to_EnumConst'>AGG_MIXED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="nodeAgg.c.html#LN1855"><span class='Ref_To_Local'>additionalsize</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN1852"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1744"><span class='Ref_to_Member'>numtrans</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN459"><span class='Ref_to_Struct'>AggStatePerGroupData</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1856"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN1856"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="nodeAgg.c.html#LN1852"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1775"><span class='Ref_to_Member'>num_hashes</span></a><span class='Delimiter'>; </span><span class='Operator'>++</span><a href="nodeAgg.c.html#LN1856"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1864"></a>        <a href="../../include/nodes/execnodes.h.html#LN1737"><span class='Ref_to_Typedef'>AggStatePerHash</span></a> <span class='Declare_Local'>perhash</span> <span class='Operator'>= &</span><a href="nodeAgg.c.html#LN1852"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1776"><span class='Ref_to_Member'>perhash</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1856"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1864"><span class='Ref_To_Local'>perhash</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN516"><span class='Ref_to_Member'>aggnode</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN789"><span class='Ref_to_Member'>numGroups</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="nodeAgg.c.html#LN1864"><span class='Ref_To_Local'>perhash</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN506"><span class='Ref_to_Member'>hashtable</span></a> <span class='Operator'>= </span><a href="../../include/executor/executor.h.html#LN132"><span class='Ref_to_Proto'>BuildTupleHashTable</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1864"><span class='Ref_To_Local'>perhash</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN511"><span class='Ref_to_Member'>numCols</span></a><span class='Delimiter'>, 
</span>                                                 <a href="nodeAgg.c.html#LN1864"><span class='Ref_To_Local'>perhash</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN515"><span class='Ref_to_Member'>hashGrpColIdxHash</span></a><span class='Delimiter'>, 
</span>                                                 <a href="nodeAgg.c.html#LN1864"><span class='Ref_To_Local'>perhash</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN510"><span class='Ref_to_Member'>eqfunctions</span></a><span class='Delimiter'>, 
</span>                                                 <a href="nodeAgg.c.html#LN1864"><span class='Ref_To_Local'>perhash</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN509"><span class='Ref_to_Member'>hashfunctions</span></a><span class='Delimiter'>, 
</span>                                                 <a href="nodeAgg.c.html#LN1864"><span class='Ref_To_Local'>perhash</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN516"><span class='Ref_to_Member'>aggnode</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN789"><span class='Ref_to_Member'>numGroups</span></a><span class='Delimiter'>, 
</span>                                                 <a href="nodeAgg.c.html#LN1855"><span class='Ref_To_Local'>additionalsize</span></a><span class='Delimiter'>, 
</span>                                <a href="nodeAgg.c.html#LN1852"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1752"><span class='Ref_to_Member'>hashcontext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN202"><span class='Ref_to_Member'>ecxt_per_tuple_memory</span></a><span class='Delimiter'>, 
</span>                                                 <a href="nodeAgg.c.html#LN1854"><span class='Ref_To_Local'>tmpmem</span></a><span class='Delimiter'>, 
</span>                                  <a href="../../include/nodes/nodes.h.html#LN767"><span class='Ref_to_Macro'>DO_AGGSPLIT_SKIPFINAL</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1852"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1746"><span class='Ref_to_Member'>aggsplit</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end build_hash_table &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Compute columns that actually need to be stored in hashtable entries.  The 
 * incoming tuples from the child plan node will contain grouping columns, 
 * other columns referenced in our targetlist and qual, columns used to 
 * compute the aggregate functions, and perhaps just junk columns we don't use 
 * at all.  Only columns of the first two types need to be stored in the 
 * hashtable, and getting rid of the others can make the table entries 
 * significantly smaller.  The hashtable only contains the relevant columns, 
 * and is packed/unpacked in lookup_hash_entry() / agg_retrieve_hash_table() 
 * into the format of the normal input descriptor. 
 * 
 * Additional columns, in addition to the columns grouped by, come from two 
 * sources: Firstly functionally dependent columns that we don't need to group 
 * by themselves, and secondly ctids for row-marks. 
 * 
 * To eliminate duplicates, we build a bitmapset of the needed columns, and 
 * then build an array of the columns included in the hashtable.  Note that 
 * the array is preserved over ExecReScanAgg, so we allocate it in the 
 * per-query context (unlike the hash table itself). 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1901"></a><span class='Declare_Function'>find_hash_columns</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1903"></a>    <a href="../../include/nodes/bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>base_colnos</span><span class='Delimiter'>; 
</span><a name="LN1904"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>outerTlist</span> <span class='Operator'>= </span><a href="../../include/nodes/execnodes.h.html#LN854"><span class='Ref_to_Macro'>outerPlanState</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1901"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>plan<span class='Operator'>-&GT;</span>targetlist<span class='Delimiter'>; 
</span><a name="LN1905"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numHashes</span> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN1901"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1775"><span class='Ref_to_Member'>num_hashes</span></a><span class='Delimiter'>; 
</span><a name="LN1906"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>j</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Find Vars that will be needed in tlist and qual */ 
</span>    <a href="nodeAgg.c.html#LN1903"><span class='Ref_To_Local'>base_colnos</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN556"><span class='Ref_to_Proto'>find_unaggregated_cols</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1901"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1906"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN1906"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>&LT; </span><a href="nodeAgg.c.html#LN1905"><span class='Ref_To_Local'>numHashes</span></a><span class='Delimiter'>; </span><span class='Operator'>++</span><a href="nodeAgg.c.html#LN1906"><span class='Ref_To_Local'>j</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1913"></a>        <a href="../../include/nodes/execnodes.h.html#LN1737"><span class='Ref_to_Typedef'>AggStatePerHash</span></a> <span class='Declare_Local'>perhash</span> <span class='Operator'>= &</span><a href="nodeAgg.c.html#LN1901"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1776"><span class='Ref_to_Member'>perhash</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1906"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>]; 
</span><a name="LN1914"></a>        <a href="../../include/nodes/bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>colnos</span> <span class='Operator'>= </span><a href="../../include/nodes/bitmapset.h.html#LN65"><span class='Ref_to_Proto'>bms_copy</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1903"><span class='Ref_To_Local'>base_colnos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1915"></a>        <a href="../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a> <span class='Operator'>*</span><span class='Declare_Local'>grpColIdx</span> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN1913"><span class='Ref_To_Local'>perhash</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN516"><span class='Ref_to_Member'>aggnode</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN787"><span class='Ref_to_Member'>grpColIdx</span></a><span class='Delimiter'>; 
</span><a name="LN1916"></a>        <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>hashTlist</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN1917"></a>        <a href="../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a>   <span class='Declare_Local'>hashDesc</span><span class='Delimiter'>; 
</span><a name="LN1918"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
        <a href="nodeAgg.c.html#LN1913"><span class='Ref_To_Local'>perhash</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN513"><span class='Ref_to_Member'>largestGrpColIdx</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If we're doing grouping sets, then some Vars might be referenced in 
         * tlist/qual for the benefit of other grouping sets, but not needed 
         * when hashing; i.e. prepare_projection_slot will null them out, so 
         * there'd be no point storing them.  Use prepare_projection_slot's 
         * logic to determine which. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1901"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1766"><span class='Ref_to_Member'>phases</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="nodeAgg.c.html#LN491"><span class='Ref_to_Member'>grouped_cols</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1931"></a>            <a href="../../include/nodes/bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>grouped_cols</span> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN1901"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1766"><span class='Ref_to_Member'>phases</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="nodeAgg.c.html#LN491"><span class='Ref_to_Member'>grouped_cols</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1906"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>]; 
</span><a name="LN1932"></a>            <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
            <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1932"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN1901"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1762"><span class='Ref_to_Member'>all_grouped_cols</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN1936"></a>                <span class='Keyword'>int</span>         <span class='Declare_Local'>attnum</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN106"><span class='Ref_to_Macro'>lfirst_int</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1932"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/nodes/bitmapset.h.html#LN75"><span class='Ref_to_Proto'>bms_is_member</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1936"><span class='Ref_To_Local'>attnum</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN1931"><span class='Ref_To_Local'>grouped_cols</span></a><span class='Parentheses'>))</span> 
                    <a href="nodeAgg.c.html#LN1914"><span class='Ref_To_Local'>colnos</span></a> <span class='Operator'>= </span><a href="../../include/nodes/bitmapset.h.html#LN90"><span class='Ref_to_Proto'>bms_del_member</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1914"><span class='Ref_To_Local'>colnos</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN1936"><span class='Ref_To_Local'>attnum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>        <span class='Comment_Multi_Line'>/* Add in all the grouping columns */ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1918"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN1918"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="nodeAgg.c.html#LN1913"><span class='Ref_To_Local'>perhash</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN511"><span class='Ref_to_Member'>numCols</span></a><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN1918"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>            <a href="nodeAgg.c.html#LN1914"><span class='Ref_To_Local'>colnos</span></a> <span class='Operator'>= </span><a href="../../include/nodes/bitmapset.h.html#LN89"><span class='Ref_to_Proto'>bms_add_member</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1914"><span class='Ref_To_Local'>colnos</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN1915"><span class='Ref_To_Local'>grpColIdx</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1918"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="nodeAgg.c.html#LN1913"><span class='Ref_To_Local'>perhash</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN514"><span class='Ref_to_Member'>hashGrpColIdxInput</span></a> <span class='Operator'>= 
</span>            <a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/bitmapset.h.html#LN81"><span class='Ref_to_Proto'>bms_num_members</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1914"><span class='Ref_To_Local'>colnos</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="nodeAgg.c.html#LN1913"><span class='Ref_To_Local'>perhash</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN515"><span class='Ref_to_Member'>hashGrpColIdxHash</span></a> <span class='Operator'>= 
</span>            <a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1913"><span class='Ref_To_Local'>perhash</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN511"><span class='Ref_to_Member'>numCols</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * First build mapping for columns directly hashed. These are the 
         * first, because they'll be accessed when computing hash values and 
         * comparing tuples for exact matches. We also build simple mapping 
         * for execGrouping, so it knows where to find the to-be-hashed / 
         * compared columns in the input. 
         */ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1918"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN1918"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="nodeAgg.c.html#LN1913"><span class='Ref_To_Local'>perhash</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN511"><span class='Ref_to_Member'>numCols</span></a><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN1918"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="nodeAgg.c.html#LN1913"><span class='Ref_To_Local'>perhash</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN514"><span class='Ref_to_Member'>hashGrpColIdxInput</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1918"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="nodeAgg.c.html#LN1915"><span class='Ref_To_Local'>grpColIdx</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1918"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>            <a href="nodeAgg.c.html#LN1913"><span class='Ref_To_Local'>perhash</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN515"><span class='Ref_to_Member'>hashGrpColIdxHash</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1918"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="nodeAgg.c.html#LN1918"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>            <a href="nodeAgg.c.html#LN1913"><span class='Ref_To_Local'>perhash</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN512"><span class='Ref_to_Member'>numhashGrpCols</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* delete already mapped columns */ 
</span>            <a href="../../include/nodes/bitmapset.h.html#LN90"><span class='Ref_to_Proto'>bms_del_member</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1914"><span class='Ref_To_Local'>colnos</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN1915"><span class='Ref_To_Local'>grpColIdx</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1918"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* and add the remaining columns */ 
</span>        <span class='Control'>while</span> <span class='Parentheses'>((</span><a href="nodeAgg.c.html#LN1918"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><a href="../../include/nodes/bitmapset.h.html#LN97"><span class='Ref_to_Proto'>bms_first_member</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1914"><span class='Ref_To_Local'>colnos</span></a><span class='Parentheses'>))</span> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <a href="nodeAgg.c.html#LN1913"><span class='Ref_To_Local'>perhash</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN514"><span class='Ref_to_Member'>hashGrpColIdxInput</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1913"><span class='Ref_To_Local'>perhash</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN512"><span class='Ref_to_Member'>numhashGrpCols</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="nodeAgg.c.html#LN1918"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>; 
</span>            <a href="nodeAgg.c.html#LN1913"><span class='Ref_To_Local'>perhash</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN512"><span class='Ref_to_Member'>numhashGrpCols</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* and build a tuple descriptor for the hashtable */ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1918"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN1918"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="nodeAgg.c.html#LN1913"><span class='Ref_To_Local'>perhash</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN512"><span class='Ref_to_Member'>numhashGrpCols</span></a><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN1918"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1977"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>varNumber</span> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN1913"><span class='Ref_To_Local'>perhash</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN514"><span class='Ref_to_Member'>hashGrpColIdxInput</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN1918"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
            <a href="nodeAgg.c.html#LN1916"><span class='Ref_To_Local'>hashTlist</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1916"><span class='Ref_To_Local'>hashTlist</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN223"><span class='Ref_to_Proto'>list_nth</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1904"><span class='Ref_To_Local'>outerTlist</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN1977"><span class='Ref_To_Local'>varNumber</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="nodeAgg.c.html#LN1913"><span class='Ref_To_Local'>perhash</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN513"><span class='Ref_to_Member'>largestGrpColIdx</span></a> <span class='Operator'>= 
</span>                <a href="../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN10"><span class='Ref_to_Macro'>Max</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1977"><span class='Ref_To_Local'>varNumber</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN1913"><span class='Ref_To_Local'>perhash</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN513"><span class='Ref_to_Member'>largestGrpColIdx</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="nodeAgg.c.html#LN1917"><span class='Ref_To_Local'>hashDesc</span></a> <span class='Operator'>= </span><a href="../../include/executor/executor.h.html#LN405"><span class='Ref_to_Proto'>ExecTypeFromTL</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1916"><span class='Ref_To_Local'>hashTlist</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/executor/tuptable.h.html#LN146"><span class='Ref_to_Proto'>ExecSetSlotDescriptor</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1913"><span class='Ref_To_Local'>perhash</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN508"><span class='Ref_to_Member'>hashslot</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN1917"><span class='Ref_To_Local'>hashDesc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/nodes/pg_list.h.html#LN265"><span class='Ref_to_Proto'>list_free</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1916"><span class='Ref_To_Local'>hashTlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/nodes/bitmapset.h.html#LN68"><span class='Ref_to_Proto'>bms_free</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1914"><span class='Ref_To_Local'>colnos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for j=0;j&LT;numHashes;++j &raquo; </span> 
 
    <a href="../../include/nodes/bitmapset.h.html#LN68"><span class='Ref_to_Proto'>bms_free</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN1903"><span class='Ref_To_Local'>base_colnos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end find_hash_columns &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Estimate per-hash-table-entry overhead for the planner. 
 * 
 * Note that the estimate does not include space for pass-by-reference 
 * transition data values, nor for the representative tuple of each group. 
 * Nor does this account of the target fill-factor and growth policy of the 
 * hash table. 
 */ 
</span><a href="../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a> 
<a name="LN2003"></a><span class='Declare_Function'>hash_agg_entry_size</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>numAggs</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2005"></a>    <a href="../../include/c.h.html#LN355"><span class='Ref_to_Typedef'>Size</span></a>        <span class='Declare_Local'>entrysize</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* This must match build_hash_table */ 
</span>    <a href="nodeAgg.c.html#LN2005"><span class='Ref_To_Local'>entrysize</span></a> <span class='Operator'>= </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN563"><span class='Ref_to_Struct'>TupleHashEntryData</span></a><span class='Parentheses'>) </span><span class='Operator'>+ 
</span>        <a href="nodeAgg.c.html#LN2003"><span class='Ref_to_Parameter'>numAggs</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN459"><span class='Ref_to_Struct'>AggStatePerGroupData</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN2005"><span class='Ref_To_Local'>entrysize</span></a> <span class='Operator'>= </span><a href="../../include/c.h.html#LN587"><span class='Ref_to_Macro'>MAXALIGN</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2005"><span class='Ref_To_Local'>entrysize</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="nodeAgg.c.html#LN2005"><span class='Ref_To_Local'>entrysize</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Find or create a hashtable entry for the tuple group containing the current 
 * tuple (already set in tmpcontext's outertuple slot), in the current grouping 
 * set (which the caller must have selected - note that initialize_aggregate 
 * depends on this). 
 * 
 * When called, CurrentMemoryContext should be the per-query context. 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/execnodes.h.html#LN563"><span class='Ref_to_Struct'>TupleHashEntryData</span></a> <span class='Operator'>* 
</span><a name="LN2024"></a><span class='Declare_Function'>lookup_hash_entry</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2026"></a>    <a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Local'>inputslot</span> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2024"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1754"><span class='Ref_to_Member'>tmpcontext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN198"><span class='Ref_to_Member'>ecxt_outertuple</span></a><span class='Delimiter'>; 
</span><a name="LN2027"></a>    <a href="../../include/nodes/execnodes.h.html#LN1737"><span class='Ref_to_Typedef'>AggStatePerHash</span></a> <span class='Declare_Local'>perhash</span> <span class='Operator'>= &</span><a href="nodeAgg.c.html#LN2024"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1776"><span class='Ref_to_Member'>perhash</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN2024"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1760"><span class='Ref_to_Member'>current_set</span></a><span class='Delimiter'>]; 
</span><a name="LN2028"></a>    <a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Local'>hashslot</span> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2027"><span class='Ref_To_Local'>perhash</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN508"><span class='Ref_to_Member'>hashslot</span></a><span class='Delimiter'>; 
</span><a name="LN2029"></a>    <a href="../../include/nodes/execnodes.h.html#LN563"><span class='Ref_to_Struct'>TupleHashEntryData</span></a> <span class='Operator'>*</span><span class='Declare_Local'>entry</span><span class='Delimiter'>; 
</span><a name="LN2030"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>isnew</span><span class='Delimiter'>; 
</span><a name="LN2031"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* transfer just the needed columns into hashslot */ 
</span>    <a href="../../include/executor/tuptable.h.html#LN169"><span class='Ref_to_Proto'>slot_getsomeattrs</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2026"><span class='Ref_To_Local'>inputslot</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN2027"><span class='Ref_To_Local'>perhash</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN513"><span class='Ref_to_Member'>largestGrpColIdx</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/executor/tuptable.h.html#LN154"><span class='Ref_to_Proto'>ExecClearTuple</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2028"><span class='Ref_To_Local'>hashslot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2031"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN2031"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="nodeAgg.c.html#LN2027"><span class='Ref_To_Local'>perhash</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN512"><span class='Ref_to_Member'>numhashGrpCols</span></a><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN2031"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2039"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>varNumber</span> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2027"><span class='Ref_To_Local'>perhash</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN514"><span class='Ref_to_Member'>hashGrpColIdxInput</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN2031"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
        <a href="nodeAgg.c.html#LN2028"><span class='Ref_To_Local'>hashslot</span></a><span class='Operator'>-&GT;</span><a href="../../include/executor/tuptable.h.html#LN124"><span class='Ref_to_Member'>tts_values</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN2031"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="nodeAgg.c.html#LN2026"><span class='Ref_To_Local'>inputslot</span></a><span class='Operator'>-&GT;</span><a href="../../include/executor/tuptable.h.html#LN124"><span class='Ref_to_Member'>tts_values</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN2039"><span class='Ref_To_Local'>varNumber</span></a><span class='Delimiter'>]; 
</span>        <a href="nodeAgg.c.html#LN2028"><span class='Ref_To_Local'>hashslot</span></a><span class='Operator'>-&GT;</span><a href="../../include/executor/tuptable.h.html#LN125"><span class='Ref_to_Member'>tts_isnull</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN2031"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="nodeAgg.c.html#LN2026"><span class='Ref_To_Local'>inputslot</span></a><span class='Operator'>-&GT;</span><a href="../../include/executor/tuptable.h.html#LN125"><span class='Ref_to_Member'>tts_isnull</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN2039"><span class='Ref_To_Local'>varNumber</span></a><span class='Delimiter'>]; 
</span>    <span class='Delimiter'>} 
</span>    <a href="../../include/executor/tuptable.h.html#LN155"><span class='Ref_to_Proto'>ExecStoreVirtualTuple</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2028"><span class='Ref_To_Local'>hashslot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* find or create the hashtable entry using the filtered tuple */ 
</span>    <a href="nodeAgg.c.html#LN2029"><span class='Ref_To_Local'>entry</span></a> <span class='Operator'>= </span><a href="../../include/executor/executor.h.html#LN138"><span class='Ref_to_Proto'>LookupTupleHashEntry</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2027"><span class='Ref_To_Local'>perhash</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN506"><span class='Ref_to_Member'>hashtable</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN2028"><span class='Ref_To_Local'>hashslot</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nodeAgg.c.html#LN2030"><span class='Ref_To_Local'>isnew</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2030"><span class='Ref_To_Local'>isnew</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="nodeAgg.c.html#LN2029"><span class='Ref_To_Local'>entry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN566"><span class='Ref_to_Member'>additional</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1735"><span class='Ref_to_Typedef'>AggStatePerGroup</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/utils/palloc.h.html#LN70"><span class='Ref_to_Proto'>MemoryContextAlloc</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2027"><span class='Ref_To_Local'>perhash</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN506"><span class='Ref_to_Member'>hashtable</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN586"><span class='Ref_to_Member'>tablecxt</span></a><span class='Delimiter'>, 
</span>                          <span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN459"><span class='Ref_to_Struct'>AggStatePerGroupData</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="nodeAgg.c.html#LN2024"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1744"><span class='Ref_to_Member'>numtrans</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* initialize aggregates for new tuple group */ 
</span>        <a href="nodeAgg.c.html#LN523"><span class='Ref_to_Proto'>initialize_aggregates</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2024"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1735"><span class='Ref_to_Typedef'>AggStatePerGroup</span></a><span class='Parentheses'>) </span><a href="nodeAgg.c.html#LN2029"><span class='Ref_To_Local'>entry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN566"><span class='Ref_to_Member'>additional</span></a><span class='Delimiter'>, 
</span>                              <span class='Operator'>-</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="nodeAgg.c.html#LN2029"><span class='Ref_To_Local'>entry</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end lookup_hash_entry &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Look up hash entries for the current tuple in all hashed grouping sets, 
 * returning an array of pergroup pointers suitable for advance_aggregates. 
 * 
 * Be aware that lookup_hash_entry can reset the tmpcontext. 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/execnodes.h.html#LN1735"><span class='Ref_to_Typedef'>AggStatePerGroup</span></a> <span class='Operator'>* 
</span><a name="LN2069"></a><span class='Declare_Function'>lookup_hash_entries</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2071"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numHashes</span> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2069"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1775"><span class='Ref_to_Member'>num_hashes</span></a><span class='Delimiter'>; 
</span><a name="LN2072"></a>    <a href="../../include/nodes/execnodes.h.html#LN1735"><span class='Ref_to_Typedef'>AggStatePerGroup</span></a> <span class='Operator'>*</span><span class='Declare_Local'>pergroup</span> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2069"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1777"><span class='Ref_to_Member'>hash_pergroup</span></a><span class='Delimiter'>; 
</span><a name="LN2073"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>setno</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2073"><span class='Ref_To_Local'>setno</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN2073"><span class='Ref_To_Local'>setno</span></a> <span class='Operator'>&LT; </span><a href="nodeAgg.c.html#LN2071"><span class='Ref_To_Local'>numHashes</span></a><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN2073"><span class='Ref_To_Local'>setno</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="nodeAgg.c.html#LN520"><span class='Ref_to_Proto'>select_current_set</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2069"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN2073"><span class='Ref_To_Local'>setno</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="nodeAgg.c.html#LN2072"><span class='Ref_To_Local'>pergroup</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN2073"><span class='Ref_To_Local'>setno</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="nodeAgg.c.html#LN559"><span class='Ref_to_Proto'>lookup_hash_entry</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2069"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN566"><span class='Ref_to_Member'>additional</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="nodeAgg.c.html#LN2072"><span class='Ref_To_Local'>pergroup</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * ExecAgg - 
 * 
 *    ExecAgg receives tuples from its outer subplan and aggregates over 
 *    the appropriate attribute for each aggregate function use (Aggref 
 *    node) appearing in the targetlist or qual of the node.  The number 
 *    of tuples to aggregate over depends on whether grouped or plain 
 *    aggregation is selected.  In grouped aggregation, we produce a result 
 *    row for each group; in plain aggregation there's a single result row 
 *    for the whole query.  In either case, the value of each aggregate is 
 *    stored in the expression context to be used when ExecProject evaluates 
 *    the result tuple. 
 */ 
</span><a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>* 
</span><a name="LN2098"></a><span class='Declare_Function'>ExecAgg</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2100"></a>    <a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Local'>result</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="nodeAgg.c.html#LN2098"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1758"><span class='Ref_to_Member'>agg_done</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Dispatch based on strategy */ 
</span>        <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2098"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1747"><span class='Ref_to_Member'>phase</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN488"><span class='Ref_to_Member'>aggstrategy</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN737"><span class='Ref_to_EnumConst'>AGG_HASHED</span></a><span class='Operator'>: 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="nodeAgg.c.html#LN2098"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1774"><span class='Ref_to_Member'>table_filled</span></a><span class='Parentheses'>) 
</span>                    <a href="nodeAgg.c.html#LN562"><span class='Ref_to_Proto'>agg_fill_hash_table</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2098"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Comment_Multi_Line'>/* FALLTHROUGH */ 
</span>            <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN738"><span class='Ref_to_EnumConst'>AGG_MIXED</span></a><span class='Operator'>: 
</span>                <a href="nodeAgg.c.html#LN2100"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN563"><span class='Ref_to_Proto'>agg_retrieve_hash_table</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2098"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN735"><span class='Ref_to_EnumConst'>AGG_PLAIN</span></a><span class='Operator'>: 
</span>            <span class='Control'>case</span> <a href="../../include/nodes/nodes.h.html#LN736"><span class='Ref_to_EnumConst'>AGG_SORTED</span></a><span class='Operator'>: 
</span>                <a href="nodeAgg.c.html#LN2100"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN561"><span class='Ref_to_Proto'>agg_retrieve_direct</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2098"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/executor/tuptable.h.html#LN137"><span class='Ref_to_Macro'>TupIsNull</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2100"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <a href="nodeAgg.c.html#LN2100"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !node-&GT;agg_done &raquo; </span> 
 
    <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ExecAgg &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * ExecAgg for non-hashed case 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>* 
</span><a name="LN2131"></a><span class='Declare_Function'>agg_retrieve_direct</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2133"></a>    <a href="../../include/nodes/plannodes.h.html#LN781"><span class='Ref_to_Struct'>Agg</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>node</span> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1747"><span class='Ref_to_Member'>phase</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN493"><span class='Ref_to_Member'>aggnode</span></a><span class='Delimiter'>; 
</span><a name="LN2134"></a>    <a href="../../include/nodes/execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Local'>econtext</span><span class='Delimiter'>; 
</span><a name="LN2135"></a>    <a href="../../include/nodes/execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tmpcontext</span><span class='Delimiter'>; 
</span><a name="LN2136"></a>    <a href="../../include/nodes/execnodes.h.html#LN1733"><span class='Ref_to_Typedef'>AggStatePerAgg</span></a> <span class='Declare_Local'>peragg</span><span class='Delimiter'>; 
</span><a name="LN2137"></a>    <a href="../../include/nodes/execnodes.h.html#LN1735"><span class='Ref_to_Typedef'>AggStatePerGroup</span></a> <span class='Declare_Local'>pergroup</span><span class='Delimiter'>; 
</span><a name="LN2138"></a>    <a href="../../include/nodes/execnodes.h.html#LN1735"><span class='Ref_to_Typedef'>AggStatePerGroup</span></a> <span class='Operator'>*</span><span class='Declare_Local'>hash_pergroups</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN2139"></a>    <a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Local'>outerslot</span><span class='Delimiter'>; 
</span><a name="LN2140"></a>    <a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Local'>firstSlot</span><span class='Delimiter'>; 
</span><a name="LN2141"></a>    <a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span><a name="LN2142"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>hasGroupingSets</span> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1747"><span class='Ref_to_Member'>phase</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN489"><span class='Ref_to_Member'>numsets</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN2143"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numGroupingSets</span> <span class='Operator'>= </span><a href="../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN10"><span class='Ref_to_Macro'>Max</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1747"><span class='Ref_to_Member'>phase</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN489"><span class='Ref_to_Member'>numsets</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2144"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>currentSet</span><span class='Delimiter'>; 
</span><a name="LN2145"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>nextSetSize</span><span class='Delimiter'>; 
</span><a name="LN2146"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numReset</span><span class='Delimiter'>; 
</span><a name="LN2147"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * get state info from node 
     * 
     * econtext is the per-output-tuple expression context 
     * 
     * tmpcontext is the per-input-tuple expression context 
     */ 
</span>    <a href="nodeAgg.c.html#LN2134"><span class='Ref_To_Local'>econtext</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1741"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN842"><span class='Ref_to_Member'>ps_ExprContext</span></a><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN2135"><span class='Ref_To_Local'>tmpcontext</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1754"><span class='Ref_to_Member'>tmpcontext</span></a><span class='Delimiter'>; 
</span> 
    <a href="nodeAgg.c.html#LN2136"><span class='Ref_To_Local'>peragg</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1750"><span class='Ref_to_Member'>peragg</span></a><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN2137"><span class='Ref_To_Local'>pergroup</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1771"><span class='Ref_to_Member'>pergroup</span></a><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN2140"><span class='Ref_To_Local'>firstSlot</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1741"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1060"><span class='Ref_to_Member'>ss_ScanTupleSlot</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We loop retrieving groups until we find one matching 
     * aggstate-&GT;ss.ps.qual 
     * 
     * For grouping sets, we have the invariant that aggstate-&GT;projected_set 
     * is either -1 (initial call) or the index (starting from 0) in 
     * gset_lengths for the group we just completed (either by projecting a 
     * row or by discarding it in the qual). 
     */ 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1758"><span class='Ref_to_Member'>agg_done</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Clear the per-output-tuple context for each group, as well as 
         * aggcontext (which contains any pass-by-ref transvalues of the old 
         * group).  Some aggregate functions store working state in child 
         * contexts; those now get reset automatically without us needing to 
         * do anything special. 
         * 
         * We use ReScanExprContext not just ResetExprContext because we want 
         * any registered shutdown callbacks to be called.  That allows 
         * aggregate functions to ensure they've cleaned up any non-memory 
         * resources. 
         */ 
</span>        <a href="execUtils.c.html#LN374"><span class='Ref_to_Func'>ReScanExprContext</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2134"><span class='Ref_To_Local'>econtext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Determine how many grouping sets need to be reset at this boundary. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1759"><span class='Ref_to_Member'>projected_set</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span> <span class='Operator'>&& 
</span>            <a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1759"><span class='Ref_to_Member'>projected_set</span></a> <span class='Operator'>&LT; </span><a href="nodeAgg.c.html#LN2143"><span class='Ref_To_Local'>numGroupingSets</span></a><span class='Parentheses'>) 
</span>            <a href="nodeAgg.c.html#LN2146"><span class='Ref_To_Local'>numReset</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1759"><span class='Ref_to_Member'>projected_set</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="nodeAgg.c.html#LN2146"><span class='Ref_To_Local'>numReset</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2143"><span class='Ref_To_Local'>numGroupingSets</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * numReset can change on a phase boundary, but that's OK; we want to 
         * reset the contexts used in _this_ phase, and later, after possibly 
         * changing phase, initialize the right number of aggregates for the 
         * _new_ phase. 
         */ 
</span> 
        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2147"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN2147"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="nodeAgg.c.html#LN2146"><span class='Ref_To_Local'>numReset</span></a><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN2147"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="execUtils.c.html#LN374"><span class='Ref_to_Func'>ReScanExprContext</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1753"><span class='Ref_to_Member'>aggcontexts</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN2147"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Check if input is complete and there are no more groups to project 
         * in this phase; move to next phase or mark as done. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1757"><span class='Ref_to_Member'>input_done</span></a> <span class='Operator'>== </span><span class='Boolean'>true </span><span class='Operator'>&& 
</span>            <a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1759"><span class='Ref_to_Member'>projected_set</span></a> <span class='Operator'>&GT;= </span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2143"><span class='Ref_To_Local'>numGroupingSets</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1749"><span class='Ref_to_Member'>current_phase</span></a> <span class='Operator'>&LT; </span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1748"><span class='Ref_to_Member'>numphases</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="nodeAgg.c.html#LN521"><span class='Ref_to_Proto'>initialize_phase</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1749"><span class='Ref_to_Member'>current_phase</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1757"><span class='Ref_to_Member'>input_done</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                <a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1759"><span class='Ref_to_Member'>projected_set</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>                <a href="nodeAgg.c.html#LN2143"><span class='Ref_To_Local'>numGroupingSets</span></a> <span class='Operator'>= </span><a href="../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN10"><span class='Ref_to_Macro'>Max</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1747"><span class='Ref_to_Member'>phase</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN489"><span class='Ref_to_Member'>numsets</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="nodeAgg.c.html#LN2133"><span class='Ref_To_Local'>node</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1747"><span class='Ref_to_Member'>phase</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN493"><span class='Ref_to_Member'>aggnode</span></a><span class='Delimiter'>; 
</span>                <a href="nodeAgg.c.html#LN2146"><span class='Ref_To_Local'>numReset</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2143"><span class='Ref_To_Local'>numGroupingSets</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1745"><span class='Ref_to_Member'>aggstrategy</span></a> <span class='Operator'>== </span><a href="../../include/nodes/nodes.h.html#LN738"><span class='Ref_to_EnumConst'>AGG_MIXED</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * Mixed mode; we've output all the grouped stuff and have 
                 * full hashtables, so switch to outputting those. 
                 */ 
</span>                <a href="nodeAgg.c.html#LN521"><span class='Ref_to_Proto'>initialize_phase</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1774"><span class='Ref_to_Member'>table_filled</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <a href="../../include/nodes/execnodes.h.html#LN608"><span class='Ref_to_Macro'>ResetTupleHashIterator</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1776"><span class='Ref_to_Member'>perhash</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="nodeAgg.c.html#LN506"><span class='Ref_to_Member'>hashtable</span></a><span class='Delimiter'>, 
</span>                                       <span class='Operator'>&</span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1776"><span class='Ref_to_Member'>perhash</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="nodeAgg.c.html#LN507"><span class='Ref_to_Member'>hashiter</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="nodeAgg.c.html#LN520"><span class='Ref_to_Proto'>select_current_set</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>return</span> <a href="nodeAgg.c.html#LN563"><span class='Ref_to_Proto'>agg_retrieve_hash_table</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1758"><span class='Ref_to_Member'>agg_done</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if aggstate-&GT;input_done=... &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* 
         * Get the number of columns in the next grouping set after the last 
         * projected one (if any). This is the number of columns to compare to 
         * see if we reached the boundary of that set too. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1759"><span class='Ref_to_Member'>projected_set</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span> <span class='Operator'>&& 
</span>            <a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1759"><span class='Ref_to_Member'>projected_set</span></a> <span class='Operator'>&LT; </span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2143"><span class='Ref_To_Local'>numGroupingSets</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>))</span> 
            <a href="nodeAgg.c.html#LN2145"><span class='Ref_To_Local'>nextSetSize</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1747"><span class='Ref_to_Member'>phase</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN490"><span class='Ref_to_Member'>gset_lengths</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1759"><span class='Ref_to_Member'>projected_set</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>]; 
</span>        <span class='Control'>else</span> 
            <a href="nodeAgg.c.html#LN2145"><span class='Ref_To_Local'>nextSetSize</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/*---------- 
         * If a subgroup for the current grouping set is present, project it. 
         * 
         * We have a new group if: 
         *  - we're out of input but haven't projected all grouping sets 
         *    (checked above) 
         * OR 
         *    - we already projected a row that wasn't from the last grouping 
         *      set 
         *    AND 
         *    - the next grouping set has at least one grouping column (since 
         *      empty grouping sets project only once input is exhausted) 
         *    AND 
         *    - the previous and pending rows differ on the grouping columns 
         *      of the next grouping set 
         *---------- 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1757"><span class='Ref_to_Member'>input_done</span></a> <span class='Operator'>|| 
</span>            <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2133"><span class='Ref_To_Local'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN784"><span class='Ref_to_Member'>aggstrategy</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/nodes.h.html#LN735"><span class='Ref_to_EnumConst'>AGG_PLAIN</span></a> <span class='Operator'>&& 
</span>             <a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1759"><span class='Ref_to_Member'>projected_set</span></a> <span class='Operator'>!= -</span><span class='Number'>1</span> <span class='Operator'>&& 
</span>             <a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1759"><span class='Ref_to_Member'>projected_set</span></a> <span class='Operator'>&LT; </span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2143"><span class='Ref_To_Local'>numGroupingSets</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>             <a href="nodeAgg.c.html#LN2145"><span class='Ref_To_Local'>nextSetSize</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span> <span class='Operator'>&& 
</span>             <span class='Operator'>!</span><a href="execGrouping.c.html#LN67"><span class='Ref_to_Func'>execTuplesMatch</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2134"><span class='Ref_To_Local'>econtext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN198"><span class='Ref_to_Member'>ecxt_outertuple</span></a><span class='Delimiter'>, 
</span>                              <a href="nodeAgg.c.html#LN2135"><span class='Ref_To_Local'>tmpcontext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN198"><span class='Ref_to_Member'>ecxt_outertuple</span></a><span class='Delimiter'>, 
</span>                              <a href="nodeAgg.c.html#LN2145"><span class='Ref_To_Local'>nextSetSize</span></a><span class='Delimiter'>, 
</span>                              <a href="nodeAgg.c.html#LN2133"><span class='Ref_To_Local'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN787"><span class='Ref_to_Member'>grpColIdx</span></a><span class='Delimiter'>, 
</span>                              <a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1747"><span class='Ref_to_Member'>phase</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN492"><span class='Ref_to_Member'>eqfunctions</span></a><span class='Delimiter'>, 
</span>                              <a href="nodeAgg.c.html#LN2135"><span class='Ref_To_Local'>tmpcontext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN202"><span class='Ref_to_Member'>ecxt_per_tuple_memory</span></a><span class='Parentheses'>)))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1759"><span class='Ref_to_Member'>projected_set</span></a> <span class='Operator'>+= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1759"><span class='Ref_to_Member'>projected_set</span></a> <span class='Operator'>&LT; </span><a href="nodeAgg.c.html#LN2143"><span class='Ref_To_Local'>numGroupingSets</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2145"><span class='Ref_To_Local'>nextSetSize</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span> <span class='Operator'>|| </span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1757"><span class='Ref_to_Member'>input_done</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * We no longer care what group we just projected, the next 
             * projection will always be the first (or only) grouping set 
             * (unless the input proves to be empty). 
             */ 
</span>            <a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1759"><span class='Ref_to_Member'>projected_set</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * If we don't already have the first tuple of the new group, 
             * fetch it from the outer plan. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1772"><span class='Ref_to_Member'>grp_firstTuple</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="nodeAgg.c.html#LN2139"><span class='Ref_To_Local'>outerslot</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN522"><span class='Ref_to_Proto'>fetch_input_tuple</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/executor/tuptable.h.html#LN137"><span class='Ref_to_Macro'>TupIsNull</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2139"><span class='Ref_To_Local'>outerslot</span></a><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* 
                     * Make a copy of the first input tuple; we will use this 
                     * for comparisons (in group mode) and for projection. 
                     */ 
</span>                    <a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1772"><span class='Ref_to_Member'>grp_firstTuple</span></a> <span class='Operator'>= </span><a href="../../include/executor/tuptable.h.html#LN157"><span class='Ref_to_Proto'>ExecCopySlotTuple</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2139"><span class='Ref_To_Local'>outerslot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>else</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* outer plan produced no tuples at all */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2142"><span class='Ref_To_Local'>hasGroupingSets</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <span class='Comment_Multi_Line'>/* 
                         * If there was no input at all, we need to project 
                         * rows only if there are grouping sets of size 0. 
                         * Note that this implies that there can't be any 
                         * references to ungrouped Vars, which would otherwise 
                         * cause issues with the empty output slot. 
                         * 
                         * XXX: This is no longer true, we currently deal with 
                         * this in finalize_aggregates(). 
                         */ 
</span>                        <a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1757"><span class='Ref_to_Member'>input_done</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
                        <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1747"><span class='Ref_to_Member'>phase</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN490"><span class='Ref_to_Member'>gset_lengths</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1759"><span class='Ref_to_Member'>projected_set</span></a><span class='Delimiter'>] </span><span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                        <span class='Delimiter'>{ 
</span>                            <a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1759"><span class='Ref_to_Member'>projected_set</span></a> <span class='Operator'>+= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>                            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1759"><span class='Ref_to_Member'>projected_set</span></a> <span class='Operator'>&GT;= </span><a href="nodeAgg.c.html#LN2143"><span class='Ref_To_Local'>numGroupingSets</span></a><span class='Parentheses'>) 
</span>                            <span class='Delimiter'>{ 
</span>                                <span class='Comment_Multi_Line'>/* 
                                 * We can't set agg_done here because we might 
                                 * have more phases to do, even though the 
                                 * input is empty. So we need to restart the 
                                 * whole outer loop. 
                                 */ 
</span>                                <span class='Control'>break</span><span class='Delimiter'>; 
</span>                            <span class='Delimiter'>} 
</span>                        <span class='Delimiter'>} 
</span> 
                        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1759"><span class='Ref_to_Member'>projected_set</span></a> <span class='Operator'>&GT;= </span><a href="nodeAgg.c.html#LN2143"><span class='Ref_To_Local'>numGroupingSets</span></a><span class='Parentheses'>) 
</span>                            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if hasGroupingSets &raquo; </span> 
                    <span class='Control'>else</span> 
                    <span class='Delimiter'>{ 
</span>                        <a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1758"><span class='Ref_to_Member'>agg_done</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                        <span class='Comment_Multi_Line'>/* If we are grouping, we should produce no tuples too */ 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2133"><span class='Ref_To_Local'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN784"><span class='Ref_to_Member'>aggstrategy</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/nodes.h.html#LN735"><span class='Ref_to_EnumConst'>AGG_PLAIN</span></a><span class='Parentheses'>) 
</span>                            <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if aggstate-&GT;grp_firstTu... &raquo; </span> 
 
            <span class='Comment_Multi_Line'>/* 
             * Initialize working state for a new input tuple group. 
             */ 
</span>            <a href="nodeAgg.c.html#LN523"><span class='Ref_to_Proto'>initialize_aggregates</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN2137"><span class='Ref_To_Local'>pergroup</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN2146"><span class='Ref_To_Local'>numReset</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1772"><span class='Ref_to_Member'>grp_firstTuple</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * Store the copied first input tuple in the tuple table slot 
                 * reserved for it.  The tuple will be deleted when it is 
                 * cleared from the slot. 
                 */ 
</span>                <a href="../../include/executor/tuptable.h.html#LN147"><span class='Ref_to_Proto'>ExecStoreTuple</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1772"><span class='Ref_to_Member'>grp_firstTuple</span></a><span class='Delimiter'>, 
</span>                               <a href="nodeAgg.c.html#LN2140"><span class='Ref_To_Local'>firstSlot</span></a><span class='Delimiter'>, 
</span>                               <a href="../../include/storage/buf.h.html#LN24"><span class='Ref_to_Const'>InvalidBuffer</span></a><span class='Delimiter'>, 
</span>                               <span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1772"><span class='Ref_to_Member'>grp_firstTuple</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>;</span>        <span class='Comment_Multi_Line'>/* don't keep two 
                                                         * pointers */ 
</span> 
                <span class='Comment_Multi_Line'>/* set up for first advance_aggregates call */ 
</span>                <a href="nodeAgg.c.html#LN2135"><span class='Ref_To_Local'>tmpcontext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN198"><span class='Ref_to_Member'>ecxt_outertuple</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2140"><span class='Ref_To_Local'>firstSlot</span></a><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * Process each outer-plan tuple, and then fetch the next one, 
                 * until we exhaust the outer plan or cross a group boundary. 
                 */ 
</span>                <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>;;</span><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* 
                     * During phase 1 only of a mixed agg, we need to update 
                     * hashtables as well in advance_aggregates. 
                     */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1745"><span class='Ref_to_Member'>aggstrategy</span></a> <span class='Operator'>== </span><a href="../../include/nodes/nodes.h.html#LN738"><span class='Ref_to_EnumConst'>AGG_MIXED</span></a> <span class='Operator'>&& 
</span>                        <a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1749"><span class='Ref_to_Member'>current_phase</span></a> <span class='Operator'>== </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <a href="nodeAgg.c.html#LN2138"><span class='Ref_To_Local'>hash_pergroups</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN560"><span class='Ref_to_Proto'>lookup_hash_entries</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                    <span class='Control'>else</span> 
                        <a href="nodeAgg.c.html#LN2138"><span class='Ref_To_Local'>hash_pergroups</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN766"><span class='Ref_to_Macro'>DO_AGGSPLIT_COMBINE</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1746"><span class='Ref_to_Member'>aggsplit</span></a><span class='Parentheses'>))</span> 
                        <a href="nodeAgg.c.html#LN534"><span class='Ref_to_Proto'>combine_aggregates</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN2137"><span class='Ref_To_Local'>pergroup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>else</span> 
                        <a href="nodeAgg.c.html#LN529"><span class='Ref_to_Proto'>advance_aggregates</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN2137"><span class='Ref_To_Local'>pergroup</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN2138"><span class='Ref_To_Local'>hash_pergroups</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                    <span class='Comment_Multi_Line'>/* Reset per-input-tuple context after each tuple */ 
</span>                    <a href="../../include/executor/executor.h.html#LN449"><span class='Ref_to_Macro'>ResetExprContext</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2135"><span class='Ref_To_Local'>tmpcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                    <a href="nodeAgg.c.html#LN2139"><span class='Ref_To_Local'>outerslot</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN522"><span class='Ref_to_Proto'>fetch_input_tuple</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/executor/tuptable.h.html#LN137"><span class='Ref_to_Macro'>TupIsNull</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2139"><span class='Ref_To_Local'>outerslot</span></a><span class='Parentheses'>))</span> 
                    <span class='Delimiter'>{ 
</span>                        <span class='Comment_Multi_Line'>/* no more outer-plan tuples available */ 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2142"><span class='Ref_To_Local'>hasGroupingSets</span></a><span class='Parentheses'>) 
</span>                        <span class='Delimiter'>{ 
</span>                            <a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1757"><span class='Ref_to_Member'>input_done</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                            <span class='Control'>break</span><span class='Delimiter'>; 
</span>                        <span class='Delimiter'>} 
</span>                        <span class='Control'>else</span> 
                        <span class='Delimiter'>{ 
</span>                            <a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1758"><span class='Ref_to_Member'>agg_done</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                            <span class='Control'>break</span><span class='Delimiter'>; 
</span>                        <span class='Delimiter'>} 
</span>                    <span class='Delimiter'>} 
</span>                    <span class='Comment_Multi_Line'>/* set up for next advance_aggregates call */ 
</span>                    <a href="nodeAgg.c.html#LN2135"><span class='Ref_To_Local'>tmpcontext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN198"><span class='Ref_to_Member'>ecxt_outertuple</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2139"><span class='Ref_To_Local'>outerslot</span></a><span class='Delimiter'>; 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * If we are grouping, check whether we've crossed a group 
                     * boundary. 
                     */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2133"><span class='Ref_To_Local'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN784"><span class='Ref_to_Member'>aggstrategy</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/nodes.h.html#LN735"><span class='Ref_to_EnumConst'>AGG_PLAIN</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="execGrouping.c.html#LN67"><span class='Ref_to_Func'>execTuplesMatch</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2140"><span class='Ref_To_Local'>firstSlot</span></a><span class='Delimiter'>, 
</span>                                             <a href="nodeAgg.c.html#LN2139"><span class='Ref_To_Local'>outerslot</span></a><span class='Delimiter'>, 
</span>                                             <a href="nodeAgg.c.html#LN2133"><span class='Ref_To_Local'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN786"><span class='Ref_to_Member'>numCols</span></a><span class='Delimiter'>, 
</span>                                             <a href="nodeAgg.c.html#LN2133"><span class='Ref_To_Local'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN787"><span class='Ref_to_Member'>grpColIdx</span></a><span class='Delimiter'>, 
</span>                                             <a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1747"><span class='Ref_to_Member'>phase</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN492"><span class='Ref_to_Member'>eqfunctions</span></a><span class='Delimiter'>, 
</span>                                          <a href="nodeAgg.c.html#LN2135"><span class='Ref_To_Local'>tmpcontext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN202"><span class='Ref_to_Member'>ecxt_per_tuple_memory</span></a><span class='Parentheses'>))</span> 
                        <span class='Delimiter'>{ 
</span>                            <a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1772"><span class='Ref_to_Member'>grp_firstTuple</span></a> <span class='Operator'>= </span><a href="../../include/executor/tuptable.h.html#LN157"><span class='Ref_to_Proto'>ExecCopySlotTuple</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2139"><span class='Ref_To_Local'>outerslot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                            <span class='Control'>break</span><span class='Delimiter'>; 
</span>                        <span class='Delimiter'>} 
</span>                    <span class='Delimiter'>} 
</span>                <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for ;; &raquo; </span> 
            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if aggstate-&GT;grp_firstTu... &raquo; </span> 
 
            <span class='Comment_Multi_Line'>/* 
             * Use the representative input tuple for any references to 
             * non-aggregated input columns in aggregate direct args, the node 
             * qual, and the tlist.  (If we are not grouping, and there are no 
             * input rows at all, we will come here with an empty firstSlot 
             * ... but if not grouping, there can't be any references to 
             * non-aggregated input columns, so no problem.) 
             */ 
</span>            <a href="nodeAgg.c.html#LN2134"><span class='Ref_To_Local'>econtext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN198"><span class='Ref_to_Member'>ecxt_outertuple</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2140"><span class='Ref_To_Local'>firstSlot</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1759"><span class='Ref_to_Member'>projected_set</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="nodeAgg.c.html#LN2144"><span class='Ref_To_Local'>currentSet</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1759"><span class='Ref_to_Member'>projected_set</span></a><span class='Delimiter'>; 
</span> 
        <a href="nodeAgg.c.html#LN549"><span class='Ref_to_Proto'>prepare_projection_slot</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN2134"><span class='Ref_To_Local'>econtext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN198"><span class='Ref_to_Member'>ecxt_outertuple</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN2144"><span class='Ref_To_Local'>currentSet</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="nodeAgg.c.html#LN520"><span class='Ref_to_Proto'>select_current_set</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN2144"><span class='Ref_To_Local'>currentSet</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="nodeAgg.c.html#LN552"><span class='Ref_to_Proto'>finalize_aggregates</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Delimiter'>, 
</span>                            <a href="nodeAgg.c.html#LN2136"><span class='Ref_To_Local'>peragg</span></a><span class='Delimiter'>, 
</span>                            <a href="nodeAgg.c.html#LN2137"><span class='Ref_To_Local'>pergroup</span></a> <span class='Operator'>+ </span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2144"><span class='Ref_To_Local'>currentSet</span></a> <span class='Operator'>* </span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1744"><span class='Ref_to_Member'>numtrans</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If there's no row to project right now, we must continue rather 
         * than returning a null since there might be more groups. 
         */ 
</span>        <a href="nodeAgg.c.html#LN2141"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN555"><span class='Ref_to_Proto'>project_aggregates</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2131"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2141"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <a href="nodeAgg.c.html#LN2141"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while !aggstate-&GT;agg_done &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* No more groups */ 
</span>    <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end agg_retrieve_direct &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * ExecAgg for hashed case: read input and build hash table 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2485"></a><span class='Declare_Function'>agg_fill_hash_table</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2487"></a>    <a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Local'>outerslot</span><span class='Delimiter'>; 
</span><a name="LN2488"></a>    <a href="../../include/nodes/execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tmpcontext</span> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2485"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1754"><span class='Ref_to_Member'>tmpcontext</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Process each outer-plan tuple, and then fetch the next one, until we 
     * exhaust the outer plan. 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>;;</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2496"></a>        <a href="../../include/nodes/execnodes.h.html#LN1735"><span class='Ref_to_Typedef'>AggStatePerGroup</span></a> <span class='Operator'>*</span><span class='Declare_Local'>pergroups</span><span class='Delimiter'>; 
</span> 
        <a href="nodeAgg.c.html#LN2487"><span class='Ref_To_Local'>outerslot</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN522"><span class='Ref_to_Proto'>fetch_input_tuple</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2485"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/executor/tuptable.h.html#LN137"><span class='Ref_to_Macro'>TupIsNull</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2487"><span class='Ref_To_Local'>outerslot</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* set up for lookup_hash_entries and advance_aggregates */ 
</span>        <a href="nodeAgg.c.html#LN2488"><span class='Ref_To_Local'>tmpcontext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN198"><span class='Ref_to_Member'>ecxt_outertuple</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2487"><span class='Ref_To_Local'>outerslot</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Find or build hashtable entries */ 
</span>        <a href="nodeAgg.c.html#LN2496"><span class='Ref_To_Local'>pergroups</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN560"><span class='Ref_to_Proto'>lookup_hash_entries</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2485"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Advance the aggregates */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN766"><span class='Ref_to_Macro'>DO_AGGSPLIT_COMBINE</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2485"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1746"><span class='Ref_to_Member'>aggsplit</span></a><span class='Parentheses'>))</span> 
            <a href="nodeAgg.c.html#LN534"><span class='Ref_to_Proto'>combine_aggregates</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2485"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN2496"><span class='Ref_To_Local'>pergroups</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="nodeAgg.c.html#LN529"><span class='Ref_to_Proto'>advance_aggregates</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2485"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN2496"><span class='Ref_To_Local'>pergroups</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Reset per-input-tuple context after each tuple, but note that the 
         * hash lookups do this too 
         */ 
</span>        <a href="../../include/executor/executor.h.html#LN449"><span class='Ref_to_Macro'>ResetExprContext</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2485"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1754"><span class='Ref_to_Member'>tmpcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for ;; &raquo; </span> 
 
    <a href="nodeAgg.c.html#LN2485"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1774"><span class='Ref_to_Member'>table_filled</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* Initialize to walk the first hash table */ 
</span>    <a href="nodeAgg.c.html#LN520"><span class='Ref_to_Proto'>select_current_set</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2485"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/nodes/execnodes.h.html#LN608"><span class='Ref_to_Macro'>ResetTupleHashIterator</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2485"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1776"><span class='Ref_to_Member'>perhash</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="nodeAgg.c.html#LN506"><span class='Ref_to_Member'>hashtable</span></a><span class='Delimiter'>, 
</span>                           <span class='Operator'>&</span><a href="nodeAgg.c.html#LN2485"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1776"><span class='Ref_to_Member'>perhash</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="nodeAgg.c.html#LN507"><span class='Ref_to_Member'>hashiter</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end agg_fill_hash_table &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * ExecAgg for hashed case: retrieving groups from hash table 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>* 
</span><a name="LN2532"></a><span class='Declare_Function'>agg_retrieve_hash_table</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2534"></a>    <a href="../../include/nodes/execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Local'>econtext</span><span class='Delimiter'>; 
</span><a name="LN2535"></a>    <a href="../../include/nodes/execnodes.h.html#LN1733"><span class='Ref_to_Typedef'>AggStatePerAgg</span></a> <span class='Declare_Local'>peragg</span><span class='Delimiter'>; 
</span><a name="LN2536"></a>    <a href="../../include/nodes/execnodes.h.html#LN1735"><span class='Ref_to_Typedef'>AggStatePerGroup</span></a> <span class='Declare_Local'>pergroup</span><span class='Delimiter'>; 
</span><a name="LN2537"></a>    <a href="../../include/nodes/execnodes.h.html#LN563"><span class='Ref_to_Struct'>TupleHashEntryData</span></a> <span class='Operator'>*</span><span class='Declare_Local'>entry</span><span class='Delimiter'>; 
</span><a name="LN2538"></a>    <a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Local'>firstSlot</span><span class='Delimiter'>; 
</span><a name="LN2539"></a>    <a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span><a name="LN2540"></a>    <a href="../../include/nodes/execnodes.h.html#LN1737"><span class='Ref_to_Typedef'>AggStatePerHash</span></a> <span class='Declare_Local'>perhash</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * get state info from node. 
     * 
     * econtext is the per-output-tuple expression context. 
     */ 
</span>    <a href="nodeAgg.c.html#LN2534"><span class='Ref_To_Local'>econtext</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2532"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1741"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN842"><span class='Ref_to_Member'>ps_ExprContext</span></a><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN2535"><span class='Ref_To_Local'>peragg</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2532"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1750"><span class='Ref_to_Member'>peragg</span></a><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN2538"><span class='Ref_To_Local'>firstSlot</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2532"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1741"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1060"><span class='Ref_to_Member'>ss_ScanTupleSlot</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Note that perhash (and therefore anything accessed through it) can 
     * change inside the loop, as we change between grouping sets. 
     */ 
</span>    <a href="nodeAgg.c.html#LN2540"><span class='Ref_To_Local'>perhash</span></a> <span class='Operator'>= &</span><a href="nodeAgg.c.html#LN2532"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1776"><span class='Ref_to_Member'>perhash</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN2532"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1760"><span class='Ref_to_Member'>current_set</span></a><span class='Delimiter'>]; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We loop retrieving groups until we find one satisfying 
     * aggstate-&GT;ss.ps.qual 
     */ 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="nodeAgg.c.html#LN2532"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1758"><span class='Ref_to_Member'>agg_done</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2563"></a>        <a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Local'>hashslot</span> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2540"><span class='Ref_To_Local'>perhash</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN508"><span class='Ref_to_Member'>hashslot</span></a><span class='Delimiter'>; 
</span><a name="LN2564"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Find the next entry in the hash table 
         */ 
</span>        <a href="nodeAgg.c.html#LN2537"><span class='Ref_To_Local'>entry</span></a> <span class='Operator'>= </span><a href="../../include/nodes/execnodes.h.html#LN610"><span class='Ref_to_Macro'>ScanTupleHashTable</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2540"><span class='Ref_To_Local'>perhash</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN506"><span class='Ref_to_Member'>hashtable</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nodeAgg.c.html#LN2540"><span class='Ref_To_Local'>perhash</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN507"><span class='Ref_to_Member'>hashiter</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2537"><span class='Ref_To_Local'>entry</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN2572"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>nextset</span> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2532"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1760"><span class='Ref_to_Member'>current_set</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2572"><span class='Ref_To_Local'>nextset</span></a> <span class='Operator'>&LT; </span><a href="nodeAgg.c.html#LN2532"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1775"><span class='Ref_to_Member'>num_hashes</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * Switch to next grouping set, reinitialize, and restart the 
                 * loop. 
                 */ 
</span>                <a href="nodeAgg.c.html#LN520"><span class='Ref_to_Proto'>select_current_set</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2532"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN2572"><span class='Ref_To_Local'>nextset</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="nodeAgg.c.html#LN2540"><span class='Ref_To_Local'>perhash</span></a> <span class='Operator'>= &</span><a href="nodeAgg.c.html#LN2532"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1776"><span class='Ref_to_Member'>perhash</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN2532"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1760"><span class='Ref_to_Member'>current_set</span></a><span class='Delimiter'>]; 
</span> 
                <a href="../../include/nodes/execnodes.h.html#LN608"><span class='Ref_to_Macro'>ResetTupleHashIterator</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2540"><span class='Ref_To_Local'>perhash</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN506"><span class='Ref_to_Member'>hashtable</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nodeAgg.c.html#LN2540"><span class='Ref_To_Local'>perhash</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN507"><span class='Ref_to_Member'>hashiter</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>continue</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* No more hashtables, so done */ 
</span>                <a href="nodeAgg.c.html#LN2532"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1758"><span class='Ref_to_Member'>agg_done</span></a> <span class='Operator'>= </span><span class='Boolean'>TRUE</span><span class='Delimiter'>; 
</span>                <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if entry==NULL &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* 
         * Clear the per-output-tuple context for each group 
         * 
         * We intentionally don't use ReScanExprContext here; if any aggs have 
         * registered shutdown callbacks, they mustn't be called yet, since we 
         * might not be done with that agg. 
         */ 
</span>        <a href="../../include/executor/executor.h.html#LN449"><span class='Ref_to_Macro'>ResetExprContext</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2534"><span class='Ref_To_Local'>econtext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Transform representative tuple back into one with the right 
         * columns. 
         */ 
</span>        <a href="../../include/executor/tuptable.h.html#LN151"><span class='Ref_to_Proto'>ExecStoreMinimalTuple</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2537"><span class='Ref_To_Local'>entry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN565"><span class='Ref_to_Member'>firstTuple</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN2563"><span class='Ref_To_Local'>hashslot</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/executor/tuptable.h.html#LN168"><span class='Ref_to_Proto'>slot_getallattrs</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2563"><span class='Ref_To_Local'>hashslot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/executor/tuptable.h.html#LN154"><span class='Ref_to_Proto'>ExecClearTuple</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2538"><span class='Ref_To_Local'>firstSlot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        memset<span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2538"><span class='Ref_To_Local'>firstSlot</span></a><span class='Operator'>-&GT;</span><a href="../../include/executor/tuptable.h.html#LN125"><span class='Ref_to_Member'>tts_isnull</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, 
</span>               <a href="nodeAgg.c.html#LN2538"><span class='Ref_To_Local'>firstSlot</span></a><span class='Operator'>-&GT;</span><a href="../../include/executor/tuptable.h.html#LN120"><span class='Ref_to_Member'>tts_tupleDescriptor</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/tupdesc.h.html#LN72"><span class='Ref_to_Member'>natts</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>bool</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2564"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN2564"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="nodeAgg.c.html#LN2540"><span class='Ref_To_Local'>perhash</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN512"><span class='Ref_to_Member'>numhashGrpCols</span></a><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN2564"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN2618"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>varNumber</span> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2540"><span class='Ref_To_Local'>perhash</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN514"><span class='Ref_to_Member'>hashGrpColIdxInput</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN2564"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
            <a href="nodeAgg.c.html#LN2538"><span class='Ref_To_Local'>firstSlot</span></a><span class='Operator'>-&GT;</span><a href="../../include/executor/tuptable.h.html#LN124"><span class='Ref_to_Member'>tts_values</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN2618"><span class='Ref_To_Local'>varNumber</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="nodeAgg.c.html#LN2563"><span class='Ref_To_Local'>hashslot</span></a><span class='Operator'>-&GT;</span><a href="../../include/executor/tuptable.h.html#LN124"><span class='Ref_to_Member'>tts_values</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN2564"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>            <a href="nodeAgg.c.html#LN2538"><span class='Ref_To_Local'>firstSlot</span></a><span class='Operator'>-&GT;</span><a href="../../include/executor/tuptable.h.html#LN125"><span class='Ref_to_Member'>tts_isnull</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN2618"><span class='Ref_To_Local'>varNumber</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="nodeAgg.c.html#LN2563"><span class='Ref_To_Local'>hashslot</span></a><span class='Operator'>-&GT;</span><a href="../../include/executor/tuptable.h.html#LN125"><span class='Ref_to_Member'>tts_isnull</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN2564"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>        <span class='Delimiter'>} 
</span>        <a href="../../include/executor/tuptable.h.html#LN155"><span class='Ref_to_Proto'>ExecStoreVirtualTuple</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2538"><span class='Ref_To_Local'>firstSlot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="nodeAgg.c.html#LN2536"><span class='Ref_To_Local'>pergroup</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1735"><span class='Ref_to_Typedef'>AggStatePerGroup</span></a><span class='Parentheses'>) </span><a href="nodeAgg.c.html#LN2537"><span class='Ref_To_Local'>entry</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN566"><span class='Ref_to_Member'>additional</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Use the representative input tuple for any references to 
         * non-aggregated input columns in the qual and tlist. 
         */ 
</span>        <a href="nodeAgg.c.html#LN2534"><span class='Ref_To_Local'>econtext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN198"><span class='Ref_to_Member'>ecxt_outertuple</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2538"><span class='Ref_To_Local'>firstSlot</span></a><span class='Delimiter'>; 
</span> 
        <a href="nodeAgg.c.html#LN549"><span class='Ref_to_Proto'>prepare_projection_slot</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2532"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Delimiter'>, 
</span>                                <a href="nodeAgg.c.html#LN2534"><span class='Ref_To_Local'>econtext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN198"><span class='Ref_to_Member'>ecxt_outertuple</span></a><span class='Delimiter'>, 
</span>                                <a href="nodeAgg.c.html#LN2532"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1760"><span class='Ref_to_Member'>current_set</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="nodeAgg.c.html#LN552"><span class='Ref_to_Proto'>finalize_aggregates</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2532"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN2535"><span class='Ref_To_Local'>peragg</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN2536"><span class='Ref_To_Local'>pergroup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="nodeAgg.c.html#LN2539"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN555"><span class='Ref_to_Proto'>project_aggregates</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2532"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2539"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <a href="nodeAgg.c.html#LN2539"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while !aggstate-&GT;agg_done &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* No more groups */ 
</span>    <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end agg_retrieve_hash_table &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* ----------------- 
 * ExecInitAgg 
 * 
 *  Creates the run-time information for the agg node produced by the 
 *  planner and initializes its outer subtree. 
 * 
 * ----------------- 
 */ 
</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>* 
</span><a name="LN2657"></a><span class='Declare_Function'>ExecInitAgg</span><span class='Parentheses'>(</span><a href="../../include/nodes/plannodes.h.html#LN781"><span class='Ref_to_Struct'>Agg</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><a href="../../include/nodes/execnodes.h.html#LN402"><span class='Ref_to_Struct'>EState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>estate</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>eflags</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2659"></a>    <a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>aggstate</span><span class='Delimiter'>; 
</span><a name="LN2660"></a>    <a href="../../include/nodes/execnodes.h.html#LN1733"><span class='Ref_to_Typedef'>AggStatePerAgg</span></a> <span class='Declare_Local'>peraggs</span><span class='Delimiter'>; 
</span><a name="LN2661"></a>    <a href="../../include/nodes/execnodes.h.html#LN1734"><span class='Ref_to_Typedef'>AggStatePerTrans</span></a> <span class='Declare_Local'>pertransstates</span><span class='Delimiter'>; 
</span><a name="LN2662"></a>    <a href="../../include/nodes/plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>outerPlan</span><span class='Delimiter'>; 
</span><a name="LN2663"></a>    <a href="../../include/nodes/execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Local'>econtext</span><span class='Delimiter'>; 
</span><a name="LN2664"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numaggs</span><span class='Delimiter'>, 
</span><a name="LN2665"></a>                <span class='Declare_Local'>transno</span><span class='Delimiter'>, 
</span><a name="LN2666"></a>                <span class='Declare_Local'>aggno</span><span class='Delimiter'>; 
</span><a name="LN2667"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>phase</span><span class='Delimiter'>; 
</span><a name="LN2668"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>phaseidx</span><span class='Delimiter'>; 
</span><a name="LN2669"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>combined_inputeval</span><span class='Delimiter'>; 
</span><a name="LN2670"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span><a name="LN2671"></a>    <a href="../../include/nodes/bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>all_grouped_cols</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN2672"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numGroupingSets</span> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span><a name="LN2673"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numPhases</span><span class='Delimiter'>; 
</span><a name="LN2674"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numHashes</span><span class='Delimiter'>; 
</span><a name="LN2675"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>column_offset</span><span class='Delimiter'>; 
</span><a name="LN2676"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN2677"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>j</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN2678"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>use_hashing</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2657"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN784"><span class='Ref_to_Member'>aggstrategy</span></a> <span class='Operator'>== </span><a href="../../include/nodes/nodes.h.html#LN737"><span class='Ref_to_EnumConst'>AGG_HASHED</span></a> <span class='Operator'>|| 
</span>                               <a href="nodeAgg.c.html#LN2657"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN784"><span class='Ref_to_Member'>aggstrategy</span></a> <span class='Operator'>== </span><a href="../../include/nodes/nodes.h.html#LN738"><span class='Ref_to_EnumConst'>AGG_MIXED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* check for unsupported flags */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2657"><span class='Ref_to_Parameter'>eflags</span></a> <span class='Operator'>& </span><span class='Parentheses'>(</span><a href="../../include/executor/executor.h.html#LN59"><span class='Ref_to_Const'>EXEC_FLAG_BACKWARD</span></a> <span class='Operator'>| </span><a href="../../include/executor/executor.h.html#LN60"><span class='Ref_to_Const'>EXEC_FLAG_MARK</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * create state structure 
     */ 
</span>    <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1741"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN812"><span class='Ref_to_Member'>plan</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeAgg.c.html#LN2657"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1741"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN814"><span class='Ref_to_Member'>state</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2657"><span class='Ref_to_Parameter'>estate</span></a><span class='Delimiter'>; 
</span> 
    <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1742"><span class='Ref_to_Member'>aggs</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1743"><span class='Ref_to_Member'>numaggs</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1744"><span class='Ref_to_Member'>numtrans</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1745"><span class='Ref_to_Member'>aggstrategy</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2657"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN784"><span class='Ref_to_Member'>aggstrategy</span></a><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1746"><span class='Ref_to_Member'>aggsplit</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2657"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN785"><span class='Ref_to_Member'>aggsplit</span></a><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1765"><span class='Ref_to_Member'>maxsets</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1759"><span class='Ref_to_Member'>projected_set</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1760"><span class='Ref_to_Member'>current_set</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1750"><span class='Ref_to_Member'>peragg</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1751"><span class='Ref_to_Member'>pertrans</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1756"><span class='Ref_to_Member'>curpertrans</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1757"><span class='Ref_to_Member'>input_done</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1758"><span class='Ref_to_Member'>agg_done</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1771"><span class='Ref_to_Member'>pergroup</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1772"><span class='Ref_to_Member'>grp_firstTuple</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1767"><span class='Ref_to_Member'>sort_in</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1768"><span class='Ref_to_Member'>sort_out</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * phases[0] always exists, but is dummy in sorted/plain mode 
     */ 
</span>    <a href="nodeAgg.c.html#LN2673"><span class='Ref_To_Local'>numPhases</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2678"><span class='Ref_To_Local'>use_hashing</span></a> <span class='Operator'>? </span><span class='Number'>1</span> <span class='Operator'>: </span><span class='Number'>2</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN2674"><span class='Ref_To_Local'>numHashes</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2678"><span class='Ref_To_Local'>use_hashing</span></a> <span class='Operator'>? </span><span class='Number'>1</span> <span class='Operator'>: </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Calculate the maximum number of grouping sets in any phase; this 
     * determines the size of some allocations.  Also calculate the number of 
     * phases, since all hashed/mixed nodes contribute to only a single phase. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2657"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN792"><span class='Ref_to_Member'>groupingSets</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="nodeAgg.c.html#LN2672"><span class='Ref_To_Local'>numGroupingSets</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2657"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN792"><span class='Ref_to_Member'>groupingSets</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2670"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN2657"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN793"><span class='Ref_to_Member'>chain</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN2726"></a>            <a href="../../include/nodes/plannodes.h.html#LN781"><span class='Ref_to_Struct'>Agg</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>agg</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2670"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="nodeAgg.c.html#LN2672"><span class='Ref_To_Local'>numGroupingSets</span></a> <span class='Operator'>= </span><a href="../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN10"><span class='Ref_to_Macro'>Max</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2672"><span class='Ref_To_Local'>numGroupingSets</span></a><span class='Delimiter'>, 
</span>                                  <a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2726"><span class='Ref_To_Local'>agg</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN792"><span class='Ref_to_Member'>groupingSets</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * additional AGG_HASHED aggs become part of phase 0, but all 
             * others add an extra phase. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2726"><span class='Ref_To_Local'>agg</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN784"><span class='Ref_to_Member'>aggstrategy</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/nodes.h.html#LN737"><span class='Ref_to_EnumConst'>AGG_HASHED</span></a><span class='Parentheses'>) 
</span>                <span class='Operator'>++</span><a href="nodeAgg.c.html#LN2673"><span class='Ref_To_Local'>numPhases</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <span class='Operator'>++</span><a href="nodeAgg.c.html#LN2674"><span class='Ref_To_Local'>numHashes</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if node-&GT;groupingSets &raquo; </span> 
 
    <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1765"><span class='Ref_to_Member'>maxsets</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2672"><span class='Ref_To_Local'>numGroupingSets</span></a><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1748"><span class='Ref_to_Member'>numphases</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2673"><span class='Ref_To_Local'>numPhases</span></a><span class='Delimiter'>; 
</span> 
    <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1753"><span class='Ref_to_Member'>aggcontexts</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>**</span><span class='Parentheses'>) 
</span>        <a href="../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="nodeAgg.c.html#LN2672"><span class='Ref_To_Local'>numGroupingSets</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Create expression contexts.  We need three or more, one for 
     * per-input-tuple processing, one for per-output-tuple processing, one 
     * for all the hashtables, and one for each grouping set.  The per-tuple 
     * memory context of the per-grouping-set ExprContexts (aggcontexts) 
     * replaces the standalone memory context formerly used to hold transition 
     * values.  We cheat a little by using ExecAssignExprContext() to build 
     * all of them. 
     * 
     * NOTE: the details of what is stored in aggcontexts and what is stored 
     * in the regular per-query memory context are driven by a simple 
     * decision: we want to reset the aggcontext at group boundaries (if not 
     * hashing) and in ExecReScanAgg to recover no-longer-wanted space. 
     */ 
</span>    <a href="execUtils.c.html#LN416"><span class='Ref_to_Func'>ExecAssignExprContext</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2657"><span class='Ref_to_Parameter'>estate</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1741"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1754"><span class='Ref_to_Member'>tmpcontext</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1741"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN842"><span class='Ref_to_Member'>ps_ExprContext</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2676"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN2676"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="nodeAgg.c.html#LN2672"><span class='Ref_To_Local'>numGroupingSets</span></a><span class='Delimiter'>; </span><span class='Operator'>++</span><a href="nodeAgg.c.html#LN2676"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="execUtils.c.html#LN416"><span class='Ref_to_Func'>ExecAssignExprContext</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2657"><span class='Ref_to_Parameter'>estate</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1741"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1753"><span class='Ref_to_Member'>aggcontexts</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN2676"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1741"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN842"><span class='Ref_to_Member'>ps_ExprContext</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2678"><span class='Ref_To_Local'>use_hashing</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="execUtils.c.html#LN416"><span class='Ref_to_Func'>ExecAssignExprContext</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2657"><span class='Ref_to_Parameter'>estate</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1741"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1752"><span class='Ref_to_Member'>hashcontext</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1741"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN842"><span class='Ref_to_Member'>ps_ExprContext</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="execUtils.c.html#LN416"><span class='Ref_to_Func'>ExecAssignExprContext</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2657"><span class='Ref_to_Parameter'>estate</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1741"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * tuple table initialization. 
     * 
     * For hashtables, we create some additional slots below. 
     */ 
</span>    <a href="../../include/executor/executor.h.html#LN401"><span class='Ref_to_Proto'>ExecInitScanTupleSlot</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2657"><span class='Ref_to_Parameter'>estate</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1741"><span class='Ref_to_Member'>ss</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/executor/executor.h.html#LN400"><span class='Ref_to_Proto'>ExecInitResultTupleSlot</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2657"><span class='Ref_to_Parameter'>estate</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1741"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1769"><span class='Ref_to_Member'>sort_slot</span></a> <span class='Operator'>= </span><a href="../../include/executor/executor.h.html#LN402"><span class='Ref_to_Proto'>ExecInitExtraTupleSlot</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2657"><span class='Ref_to_Parameter'>estate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * initialize child expressions 
     * 
     * We rely on the parser to have checked that no aggs contain other agg 
     * calls in their arguments.  This would make no sense under SQL semantics 
     * (and it's forbidden by the spec).  Because it is true, we don't need to 
     * worry about evaluating the aggs in any particular order. 
     * 
     * Note: execExpr.c finds Aggrefs for us, and adds their AggrefExprState 
     * nodes to aggstate-&GT;aggs.  Aggrefs in the qual are found here; Aggrefs 
     * in the targetlist are found during ExecAssignProjectionInfo, below. 
     */ 
</span>    <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1741"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN826"><span class='Ref_to_Member'>qual</span></a> <span class='Operator'>= 
</span>        <a href="execExpr.c.html#LN158"><span class='Ref_to_Func'>ExecInitQual</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2657"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN783"><span class='Ref_to_Member'>plan</span></a><span class='Operator'>.</span><a href="../../include/nodes/plannodes.h.html#LN144"><span class='Ref_to_Member'>qual</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Initialize child nodes. 
     * 
     * If we are doing a hashed aggregation then the child plan does not need 
     * to handle REWIND efficiently; see ExecReScanAgg. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2657"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN784"><span class='Ref_to_Member'>aggstrategy</span></a> <span class='Operator'>== </span><a href="../../include/nodes/nodes.h.html#LN737"><span class='Ref_to_EnumConst'>AGG_HASHED</span></a><span class='Parentheses'>) 
</span>        <a href="nodeAgg.c.html#LN2657"><span class='Ref_to_Parameter'>eflags</span></a> <span class='Operator'>&= ~</span><a href="../../include/executor/executor.h.html#LN58"><span class='Ref_to_Const'>EXEC_FLAG_REWIND</span></a><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN2662"><span class='Ref_To_Local'>outerPlan</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2662"><span class='Ref_To_Local'>outerPlan</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2657"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/nodes/execnodes.h.html#LN854"><span class='Ref_to_Macro'>outerPlanState</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Parentheses'>) </span><span class='Operator'>= </span><a href="execProcnode.c.html#LN138"><span class='Ref_to_Func'>ExecInitNode</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2662"><span class='Ref_To_Local'>outerPlan</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN2657"><span class='Ref_to_Parameter'>estate</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN2657"><span class='Ref_to_Parameter'>eflags</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * initialize source tuple type. 
     */ 
</span>    <a href="../../include/executor/executor.h.html#LN478"><span class='Ref_to_Proto'>ExecAssignScanTypeFromOuterPlan</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1741"><span class='Ref_to_Member'>ss</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2657"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN793"><span class='Ref_to_Member'>chain</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/executor/tuptable.h.html#LN146"><span class='Ref_to_Proto'>ExecSetSlotDescriptor</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1769"><span class='Ref_to_Member'>sort_slot</span></a><span class='Delimiter'>, 
</span>                         <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1741"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1060"><span class='Ref_to_Member'>ss_ScanTupleSlot</span></a><span class='Operator'>-&GT;</span><a href="../../include/executor/tuptable.h.html#LN120"><span class='Ref_to_Member'>tts_tupleDescriptor</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Initialize result tuple type and projection info. 
     */ 
</span>    <a href="execUtils.c.html#LN438"><span class='Ref_to_Func'>ExecAssignResultTypeFromTL</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1741"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/executor/executor.h.html#LN474"><span class='Ref_to_Proto'>ExecAssignProjectionInfo</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1741"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We should now have found all Aggrefs in the targetlist and quals. 
     */ 
</span>    <a href="nodeAgg.c.html#LN2664"><span class='Ref_To_Local'>numaggs</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1743"><span class='Ref_to_Member'>numaggs</span></a><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2664"><span class='Ref_To_Local'>numaggs</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1742"><span class='Ref_to_Member'>aggs</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2664"><span class='Ref_To_Local'>numaggs</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * This is not an error condition: we might be using the Agg node just 
         * to do hash-based grouping.  Even in the regular case, 
         * constant-expression simplification could optimize away all of the 
         * Aggrefs in the targetlist and qual.  So keep going, but force local 
         * copy of numaggs positive so that palloc()s below don't choke. 
         */ 
</span>        <a href="nodeAgg.c.html#LN2664"><span class='Ref_To_Local'>numaggs</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * For each phase, prepare grouping set data and fmgr lookup data for 
     * compare functions.  Accumulate all_grouped_cols in passing. 
     */ 
</span>    <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1766"><span class='Ref_to_Member'>phases</span></a> <span class='Operator'>= </span><a href="../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2673"><span class='Ref_To_Local'>numPhases</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN486"><span class='Ref_to_Struct'>AggStatePerPhaseData</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1775"><span class='Ref_to_Member'>num_hashes</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2674"><span class='Ref_To_Local'>numHashes</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2674"><span class='Ref_To_Local'>numHashes</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1776"><span class='Ref_to_Member'>perhash</span></a> <span class='Operator'>= </span><a href="../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN504"><span class='Ref_to_Struct'>AggStatePerHashData</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="nodeAgg.c.html#LN2674"><span class='Ref_To_Local'>numHashes</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1766"><span class='Ref_to_Member'>phases</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="nodeAgg.c.html#LN489"><span class='Ref_to_Member'>numsets</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1766"><span class='Ref_to_Member'>phases</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="nodeAgg.c.html#LN490"><span class='Ref_to_Member'>gset_lengths</span></a> <span class='Operator'>= </span><a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2674"><span class='Ref_To_Local'>numHashes</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1766"><span class='Ref_to_Member'>phases</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="nodeAgg.c.html#LN491"><span class='Ref_to_Member'>grouped_cols</span></a> <span class='Operator'>= </span><a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2674"><span class='Ref_To_Local'>numHashes</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/nodes/bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a> <span class='Operator'>*</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="nodeAgg.c.html#LN2667"><span class='Ref_To_Local'>phase</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2668"><span class='Ref_To_Local'>phaseidx</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN2668"><span class='Ref_To_Local'>phaseidx</span></a> <span class='Operator'>&LT;= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2657"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN793"><span class='Ref_to_Member'>chain</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; </span><span class='Operator'>++</span><a href="nodeAgg.c.html#LN2668"><span class='Ref_To_Local'>phaseidx</span></a><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span><a name="LN2863"></a>        <a href="../../include/nodes/plannodes.h.html#LN781"><span class='Ref_to_Struct'>Agg</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>aggnode</span><span class='Delimiter'>; 
</span><a name="LN2864"></a>        <a href="../../include/nodes/plannodes.h.html#LN743"><span class='Ref_to_Struct'>Sort</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>sortnode</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2668"><span class='Ref_To_Local'>phaseidx</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="nodeAgg.c.html#LN2863"><span class='Ref_To_Local'>aggnode</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN226"><span class='Ref_to_Macro'>list_nth_node</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/plannodes.h.html#LN781"><span class='Ref_to_Struct'>Agg</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN2657"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN793"><span class='Ref_to_Member'>chain</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN2668"><span class='Ref_To_Local'>phaseidx</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="nodeAgg.c.html#LN2864"><span class='Ref_To_Local'>sortnode</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN575"><span class='Ref_to_Macro'>castNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/plannodes.h.html#LN743"><span class='Ref_to_Struct'>Sort</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN2863"><span class='Ref_To_Local'>aggnode</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN783"><span class='Ref_to_Member'>plan</span></a><span class='Operator'>.</span><a href="../../include/nodes/plannodes.h.html#LN145"><span class='Ref_to_Member'>lefttree</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <a href="nodeAgg.c.html#LN2863"><span class='Ref_To_Local'>aggnode</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2657"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span>            <a href="nodeAgg.c.html#LN2864"><span class='Ref_To_Local'>sortnode</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2667"><span class='Ref_To_Local'>phase</span></a> <span class='Operator'>&LT;= </span><span class='Number'>1</span> <span class='Operator'>|| </span><a href="nodeAgg.c.html#LN2864"><span class='Ref_To_Local'>sortnode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2863"><span class='Ref_To_Local'>aggnode</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN784"><span class='Ref_to_Member'>aggstrategy</span></a> <span class='Operator'>== </span><a href="../../include/nodes/nodes.h.html#LN737"><span class='Ref_to_EnumConst'>AGG_HASHED</span></a> 
            <span class='Operator'>|| </span><a href="nodeAgg.c.html#LN2863"><span class='Ref_To_Local'>aggnode</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN784"><span class='Ref_to_Member'>aggstrategy</span></a> <span class='Operator'>== </span><a href="../../include/nodes/nodes.h.html#LN738"><span class='Ref_to_EnumConst'>AGG_MIXED</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN2882"></a>            <a href="../../include/nodes/execnodes.h.html#LN1736"><span class='Ref_to_Typedef'>AggStatePerPhase</span></a> <span class='Declare_Local'>phasedata</span> <span class='Operator'>= &</span><a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1766"><span class='Ref_to_Member'>phases</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]; 
</span><a name="LN2883"></a>            <a href="../../include/nodes/execnodes.h.html#LN1737"><span class='Ref_to_Typedef'>AggStatePerHash</span></a> <span class='Declare_Local'>perhash</span><span class='Delimiter'>; 
</span><a name="LN2884"></a>            <a href="../../include/nodes/bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>cols</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2667"><span class='Ref_To_Local'>phase</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="nodeAgg.c.html#LN2676"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2882"><span class='Ref_To_Local'>phasedata</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN489"><span class='Ref_to_Member'>numsets</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <a href="nodeAgg.c.html#LN2883"><span class='Ref_To_Local'>perhash</span></a> <span class='Operator'>= &</span><a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1776"><span class='Ref_to_Member'>perhash</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN2676"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
            <span class='Comment_Multi_Line'>/* phase 0 always points to the "real" Agg in the hash case */ 
</span>            <a href="nodeAgg.c.html#LN2882"><span class='Ref_To_Local'>phasedata</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN493"><span class='Ref_to_Member'>aggnode</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2657"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span>            <a href="nodeAgg.c.html#LN2882"><span class='Ref_To_Local'>phasedata</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN488"><span class='Ref_to_Member'>aggstrategy</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2657"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN784"><span class='Ref_to_Member'>aggstrategy</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* but the actual Agg node representing this hash is saved here */ 
</span>            <a href="nodeAgg.c.html#LN2883"><span class='Ref_To_Local'>perhash</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN516"><span class='Ref_to_Member'>aggnode</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2863"><span class='Ref_To_Local'>aggnode</span></a><span class='Delimiter'>; 
</span> 
            <a href="nodeAgg.c.html#LN2882"><span class='Ref_To_Local'>phasedata</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN490"><span class='Ref_to_Member'>gset_lengths</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN2676"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="nodeAgg.c.html#LN2883"><span class='Ref_To_Local'>perhash</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN511"><span class='Ref_to_Member'>numCols</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2863"><span class='Ref_To_Local'>aggnode</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN786"><span class='Ref_to_Member'>numCols</span></a><span class='Delimiter'>; 
</span> 
            <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2677"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN2677"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>&LT; </span><a href="nodeAgg.c.html#LN2863"><span class='Ref_To_Local'>aggnode</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN786"><span class='Ref_to_Member'>numCols</span></a><span class='Delimiter'>; </span><span class='Operator'>++</span><a href="nodeAgg.c.html#LN2677"><span class='Ref_To_Local'>j</span></a><span class='Parentheses'>) 
</span>                <a href="nodeAgg.c.html#LN2884"><span class='Ref_To_Local'>cols</span></a> <span class='Operator'>= </span><a href="../../include/nodes/bitmapset.h.html#LN89"><span class='Ref_to_Proto'>bms_add_member</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2884"><span class='Ref_To_Local'>cols</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN2863"><span class='Ref_To_Local'>aggnode</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN787"><span class='Ref_to_Member'>grpColIdx</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN2677"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="nodeAgg.c.html#LN2882"><span class='Ref_To_Local'>phasedata</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN491"><span class='Ref_to_Member'>grouped_cols</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN2676"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="nodeAgg.c.html#LN2884"><span class='Ref_To_Local'>cols</span></a><span class='Delimiter'>; 
</span> 
            <a href="nodeAgg.c.html#LN2671"><span class='Ref_To_Local'>all_grouped_cols</span></a> <span class='Operator'>= </span><a href="../../include/nodes/bitmapset.h.html#LN91"><span class='Ref_to_Proto'>bms_add_members</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2671"><span class='Ref_To_Local'>all_grouped_cols</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN2884"><span class='Ref_To_Local'>cols</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if aggnode-&GT;aggstrategy=... &raquo; </span> 
        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span><a name="LN2909"></a>            <a href="../../include/nodes/execnodes.h.html#LN1736"><span class='Ref_to_Typedef'>AggStatePerPhase</span></a> <span class='Declare_Local'>phasedata</span> <span class='Operator'>= &</span><a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1766"><span class='Ref_to_Member'>phases</span></a><span class='Delimiter'>[</span><span class='Operator'>++</span><a href="nodeAgg.c.html#LN2667"><span class='Ref_To_Local'>phase</span></a><span class='Delimiter'>]; 
</span><a name="LN2910"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>num_sets</span><span class='Delimiter'>; 
</span> 
            <a href="nodeAgg.c.html#LN2909"><span class='Ref_To_Local'>phasedata</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN489"><span class='Ref_to_Member'>numsets</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2910"><span class='Ref_To_Local'>num_sets</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2863"><span class='Ref_To_Local'>aggnode</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN792"><span class='Ref_to_Member'>groupingSets</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2910"><span class='Ref_To_Local'>num_sets</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="nodeAgg.c.html#LN2909"><span class='Ref_To_Local'>phasedata</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN490"><span class='Ref_to_Member'>gset_lengths</span></a> <span class='Operator'>= </span><a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2910"><span class='Ref_To_Local'>num_sets</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <a href="nodeAgg.c.html#LN2909"><span class='Ref_To_Local'>phasedata</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN491"><span class='Ref_to_Member'>grouped_cols</span></a> <span class='Operator'>= </span><a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2910"><span class='Ref_To_Local'>num_sets</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/nodes/bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a> <span class='Operator'>*</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
                <a href="nodeAgg.c.html#LN2676"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>                <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2670"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN2863"><span class='Ref_To_Local'>aggnode</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN792"><span class='Ref_to_Member'>groupingSets</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span><a name="LN2922"></a>                    <span class='Keyword'>int</span>         <span class='Declare_Local'>current_length</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2670"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span><a name="LN2923"></a>                    <a href="../../include/nodes/bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>cols</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
                    <span class='Comment_Multi_Line'>/* planner forces this to be correct */ 
</span>                    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2677"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN2677"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>&LT; </span><a href="nodeAgg.c.html#LN2922"><span class='Ref_To_Local'>current_length</span></a><span class='Delimiter'>; </span><span class='Operator'>++</span><a href="nodeAgg.c.html#LN2677"><span class='Ref_To_Local'>j</span></a><span class='Parentheses'>) 
</span>                        <a href="nodeAgg.c.html#LN2923"><span class='Ref_To_Local'>cols</span></a> <span class='Operator'>= </span><a href="../../include/nodes/bitmapset.h.html#LN89"><span class='Ref_to_Proto'>bms_add_member</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2923"><span class='Ref_To_Local'>cols</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN2863"><span class='Ref_To_Local'>aggnode</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN787"><span class='Ref_to_Member'>grpColIdx</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN2677"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                    <a href="nodeAgg.c.html#LN2909"><span class='Ref_To_Local'>phasedata</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN491"><span class='Ref_to_Member'>grouped_cols</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN2676"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="nodeAgg.c.html#LN2923"><span class='Ref_To_Local'>cols</span></a><span class='Delimiter'>; 
</span>                    <a href="nodeAgg.c.html#LN2909"><span class='Ref_To_Local'>phasedata</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN490"><span class='Ref_to_Member'>gset_lengths</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN2676"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="nodeAgg.c.html#LN2922"><span class='Ref_To_Local'>current_length</span></a><span class='Delimiter'>; 
</span> 
                    <span class='Operator'>++</span><a href="nodeAgg.c.html#LN2676"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
                <a href="nodeAgg.c.html#LN2671"><span class='Ref_To_Local'>all_grouped_cols</span></a> <span class='Operator'>= </span><a href="../../include/nodes/bitmapset.h.html#LN91"><span class='Ref_to_Proto'>bms_add_members</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2671"><span class='Ref_To_Local'>all_grouped_cols</span></a><span class='Delimiter'>, 
</span>                                                 <a href="nodeAgg.c.html#LN2909"><span class='Ref_To_Local'>phasedata</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN491"><span class='Ref_to_Member'>grouped_cols</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if num_sets &raquo; </span> 
            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2668"><span class='Ref_To_Local'>phaseidx</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="nodeAgg.c.html#LN2909"><span class='Ref_To_Local'>phasedata</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN490"><span class='Ref_to_Member'>gset_lengths</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>                <a href="nodeAgg.c.html#LN2909"><span class='Ref_To_Local'>phasedata</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN491"><span class='Ref_to_Member'>grouped_cols</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * If we are grouping, precompute fmgr lookup data for inner loop. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2863"><span class='Ref_To_Local'>aggnode</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN784"><span class='Ref_to_Member'>aggstrategy</span></a> <span class='Operator'>== </span><a href="../../include/nodes/nodes.h.html#LN736"><span class='Ref_to_EnumConst'>AGG_SORTED</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2863"><span class='Ref_To_Local'>aggnode</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN786"><span class='Ref_to_Member'>numCols</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="nodeAgg.c.html#LN2909"><span class='Ref_To_Local'>phasedata</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN492"><span class='Ref_to_Member'>eqfunctions</span></a> <span class='Operator'>= 
</span>                    <a href="../../include/executor/executor.h.html#LN126"><span class='Ref_to_Proto'>execTuplesMatchPrepare</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2863"><span class='Ref_To_Local'>aggnode</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN786"><span class='Ref_to_Member'>numCols</span></a><span class='Delimiter'>, 
</span>                                           <a href="nodeAgg.c.html#LN2863"><span class='Ref_To_Local'>aggnode</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN788"><span class='Ref_to_Member'>grpOperators</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <a href="nodeAgg.c.html#LN2909"><span class='Ref_To_Local'>phasedata</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN493"><span class='Ref_to_Member'>aggnode</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2863"><span class='Ref_To_Local'>aggnode</span></a><span class='Delimiter'>; 
</span>            <a href="nodeAgg.c.html#LN2909"><span class='Ref_To_Local'>phasedata</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN488"><span class='Ref_to_Member'>aggstrategy</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2863"><span class='Ref_To_Local'>aggnode</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN784"><span class='Ref_to_Member'>aggstrategy</span></a><span class='Delimiter'>; 
</span>            <a href="nodeAgg.c.html#LN2909"><span class='Ref_To_Local'>phasedata</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN494"><span class='Ref_to_Member'>sortnode</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2864"><span class='Ref_To_Local'>sortnode</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for phaseidx=0;phaseidx&LT;=... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Convert all_grouped_cols to a descending-order list. 
     */ 
</span>    <a href="nodeAgg.c.html#LN2676"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Control'>while</span> <span class='Parentheses'>((</span><a href="nodeAgg.c.html#LN2676"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><a href="../../include/nodes/bitmapset.h.html#LN98"><span class='Ref_to_Proto'>bms_next_member</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2671"><span class='Ref_To_Local'>all_grouped_cols</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN2676"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>))</span> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1762"><span class='Ref_to_Member'>all_grouped_cols</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN216"><span class='Ref_to_Proto'>lcons_int</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2676"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1762"><span class='Ref_to_Member'>all_grouped_cols</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Set up aggregate-result storage in the output expr context, and also 
     * allocate my private per-agg working storage 
     */ 
</span>    <a href="nodeAgg.c.html#LN2663"><span class='Ref_To_Local'>econtext</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1741"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN842"><span class='Ref_to_Member'>ps_ExprContext</span></a><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN2663"><span class='Ref_To_Local'>econtext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN212"><span class='Ref_to_Member'>ecxt_aggvalues</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="nodeAgg.c.html#LN2664"><span class='Ref_To_Local'>numaggs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN2663"><span class='Ref_To_Local'>econtext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN213"><span class='Ref_to_Member'>ecxt_aggnulls</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>bool</span><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="nodeAgg.c.html#LN2664"><span class='Ref_To_Local'>numaggs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="nodeAgg.c.html#LN2660"><span class='Ref_To_Local'>peraggs</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1733"><span class='Ref_to_Typedef'>AggStatePerAgg</span></a><span class='Parentheses'>) </span><a href="../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN404"><span class='Ref_to_Struct'>AggStatePerAggData</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="nodeAgg.c.html#LN2664"><span class='Ref_To_Local'>numaggs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN2661"><span class='Ref_To_Local'>pertransstates</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1734"><span class='Ref_to_Typedef'>AggStatePerTrans</span></a><span class='Parentheses'>) </span><a href="../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN240"><span class='Ref_to_Struct'>AggStatePerTransData</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="nodeAgg.c.html#LN2664"><span class='Ref_To_Local'>numaggs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1750"><span class='Ref_to_Member'>peragg</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2660"><span class='Ref_To_Local'>peraggs</span></a><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1751"><span class='Ref_to_Member'>pertrans</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2661"><span class='Ref_To_Local'>pertransstates</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Hashing can only appear in the initial phase. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2678"><span class='Ref_To_Local'>use_hashing</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2676"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN2676"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="nodeAgg.c.html#LN2674"><span class='Ref_To_Local'>numHashes</span></a><span class='Delimiter'>; </span><span class='Operator'>++</span><a href="nodeAgg.c.html#LN2676"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1776"><span class='Ref_to_Member'>perhash</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN2676"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="nodeAgg.c.html#LN508"><span class='Ref_to_Member'>hashslot</span></a> <span class='Operator'>= </span><a href="../../include/executor/executor.h.html#LN402"><span class='Ref_to_Proto'>ExecInitExtraTupleSlot</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2657"><span class='Ref_to_Parameter'>estate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="../../include/executor/executor.h.html#LN128"><span class='Ref_to_Proto'>execTuplesHashPrepare</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1776"><span class='Ref_to_Member'>perhash</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN2676"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="nodeAgg.c.html#LN511"><span class='Ref_to_Member'>numCols</span></a><span class='Delimiter'>, 
</span>                                  <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1776"><span class='Ref_to_Member'>perhash</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN2676"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="nodeAgg.c.html#LN516"><span class='Ref_to_Member'>aggnode</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN788"><span class='Ref_to_Member'>grpOperators</span></a><span class='Delimiter'>, 
</span>                                  <span class='Operator'>&</span><a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1776"><span class='Ref_to_Member'>perhash</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN2676"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="nodeAgg.c.html#LN510"><span class='Ref_to_Member'>eqfunctions</span></a><span class='Delimiter'>, 
</span>                                  <span class='Operator'>&</span><a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1776"><span class='Ref_to_Member'>perhash</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN2676"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="nodeAgg.c.html#LN509"><span class='Ref_to_Member'>hashfunctions</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* this is an array of pointers, not structures */ 
</span>        <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1777"><span class='Ref_to_Member'>hash_pergroup</span></a> <span class='Operator'>= </span><a href="../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1735"><span class='Ref_to_Typedef'>AggStatePerGroup</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="nodeAgg.c.html#LN2674"><span class='Ref_To_Local'>numHashes</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="nodeAgg.c.html#LN1900"><span class='Ref_to_Func'>find_hash_columns</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="nodeRecursiveunion.c.html#LN30"><span class='Ref_to_Func'>build_hash_table</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1774"><span class='Ref_to_Member'>table_filled</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2657"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN784"><span class='Ref_to_Member'>aggstrategy</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/nodes.h.html#LN737"><span class='Ref_to_EnumConst'>AGG_HASHED</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3010"></a>        <a href="../../include/nodes/execnodes.h.html#LN1735"><span class='Ref_to_Typedef'>AggStatePerGroup</span></a> <span class='Declare_Local'>pergroup</span><span class='Delimiter'>; 
</span> 
        <a href="nodeAgg.c.html#LN3010"><span class='Ref_To_Local'>pergroup</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1735"><span class='Ref_to_Typedef'>AggStatePerGroup</span></a><span class='Parentheses'>) </span><a href="../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN459"><span class='Ref_to_Struct'>AggStatePerGroupData</span></a><span class='Parentheses'>) 
</span>                                              <span class='Operator'>* </span><a href="nodeAgg.c.html#LN2664"><span class='Ref_To_Local'>numaggs</span></a> 
                                              <span class='Operator'>* </span><a href="nodeAgg.c.html#LN2672"><span class='Ref_To_Local'>numGroupingSets</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1771"><span class='Ref_to_Member'>pergroup</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN3010"><span class='Ref_To_Local'>pergroup</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Initialize current phase-dependent values to initial phase. The initial 
     * phase is 1 (first sort pass) for all strategies that use sorting (if 
     * hashing is being done too, then phase 0 is processed last); but if only 
     * hashing is being done, then phase 0 is all there is. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2657"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN784"><span class='Ref_to_Member'>aggstrategy</span></a> <span class='Operator'>== </span><a href="../../include/nodes/nodes.h.html#LN737"><span class='Ref_to_EnumConst'>AGG_HASHED</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1749"><span class='Ref_to_Member'>current_phase</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="nodeAgg.c.html#LN521"><span class='Ref_to_Proto'>initialize_phase</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="nodeAgg.c.html#LN520"><span class='Ref_to_Proto'>select_current_set</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1749"><span class='Ref_to_Member'>current_phase</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>        <a href="nodeAgg.c.html#LN521"><span class='Ref_to_Proto'>initialize_phase</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="nodeAgg.c.html#LN520"><span class='Ref_to_Proto'>select_current_set</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* ----------------- 
     * Perform lookups of aggregate function info, and initialize the 
     * unchanging fields of the per-agg and per-trans data. 
     * 
     * We try to optimize by detecting duplicate aggregate functions so that 
     * their state and final values are re-used, rather than needlessly being 
     * re-calculated independently. We also detect aggregates that are not 
     * the same, but which can share the same transition state. 
     * 
     * Scenarios: 
     * 
     * 1. An aggregate function appears more than once in query: 
     * 
     *    SELECT SUM(x) FROM ... HAVING SUM(x) &GT; 0 
     * 
     *    Since the aggregates are the identical, we only need to calculate 
     *    the calculate it once. Both aggregates will share the same 'aggno' 
     *    value. 
     * 
     * 2. Two different aggregate functions appear in the query, but the 
     *    aggregates have the same transition function and initial value, but 
     *    different final function: 
     * 
     *    SELECT SUM(x), AVG(x) FROM ... 
     * 
     *    In this case we must create a new peragg for the varying aggregate, 
     *    and need to call the final functions separately, but can share the 
     *    same transition state. 
     * 
     * For either of these optimizations to be valid, the aggregate's 
     * arguments must be the same, including any modifiers such as ORDER BY, 
     * DISTINCT and FILTER, and they mustn't contain any volatile functions. 
     * ----------------- 
     */ 
</span>    <a href="nodeAgg.c.html#LN2666"><span class='Ref_To_Local'>aggno</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN2665"><span class='Ref_To_Local'>transno</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2670"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1742"><span class='Ref_to_Member'>aggs</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3076"></a>        <a href="../../include/nodes/execnodes.h.html#LN630"><span class='Ref_to_Struct'>AggrefExprState</span></a> <span class='Operator'>*</span><span class='Declare_Local'>aggrefstate</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN630"><span class='Ref_to_Struct'>AggrefExprState</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2670"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN3077"></a>        <a href="../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>aggref</span> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN3076"><span class='Ref_To_Local'>aggrefstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN633"><span class='Ref_to_Member'>aggref</span></a><span class='Delimiter'>; 
</span><a name="LN3078"></a>        <a href="../../include/nodes/execnodes.h.html#LN1733"><span class='Ref_to_Typedef'>AggStatePerAgg</span></a> <span class='Declare_Local'>peragg</span><span class='Delimiter'>; 
</span><a name="LN3079"></a>        <a href="../../include/nodes/execnodes.h.html#LN1734"><span class='Ref_to_Typedef'>AggStatePerTrans</span></a> <span class='Declare_Local'>pertrans</span><span class='Delimiter'>; 
</span><a name="LN3080"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>existing_aggno</span><span class='Delimiter'>; 
</span><a name="LN3081"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>existing_transno</span><span class='Delimiter'>; 
</span><a name="LN3082"></a>        <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>same_input_transnos</span><span class='Delimiter'>; 
</span><a name="LN3083"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>inputTypes</span><span class='Delimiter'>[</span><a href="../../include/pg_config_manual.h.html#LN36"><span class='Ref_to_Const'>FUNC_MAX_ARGS</span></a><span class='Delimiter'>]; 
</span><a name="LN3084"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>numArguments</span><span class='Delimiter'>; 
</span><a name="LN3085"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>numDirectArgs</span><span class='Delimiter'>; 
</span><a name="LN3086"></a>        <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>aggTuple</span><span class='Delimiter'>; 
</span><a name="LN3087"></a>        <a href="../../include/catalog/pg_aggregate.h.html#LN86"><span class='Ref_to_Typedef'>Form_pg_aggregate</span></a> <span class='Declare_Local'>aggform</span><span class='Delimiter'>; 
</span><a name="LN3088"></a>        <a href="../../include/utils/acl.h.html#LN169"><span class='Ref_to_Typedef'>AclResult</span></a>   <span class='Declare_Local'>aclresult</span><span class='Delimiter'>; 
</span><a name="LN3089"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>transfn_oid</span><span class='Delimiter'>, 
</span><a name="LN3090"></a>                    <span class='Declare_Local'>finalfn_oid</span><span class='Delimiter'>; 
</span><a name="LN3091"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>serialfn_oid</span><span class='Delimiter'>, 
</span><a name="LN3092"></a>                    <span class='Declare_Local'>deserialfn_oid</span><span class='Delimiter'>; 
</span><a name="LN3093"></a>        <a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>finalfnexpr</span><span class='Delimiter'>; 
</span><a name="LN3094"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>aggtranstype</span><span class='Delimiter'>; 
</span><a name="LN3095"></a>        <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>textInitVal</span><span class='Delimiter'>; 
</span><a name="LN3096"></a>        <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>initValue</span><span class='Delimiter'>; 
</span><a name="LN3097"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>initValueIsNull</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Planner should have assigned aggregate to correct level */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3077"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN308"><span class='Ref_to_Member'>agglevelsup</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* ... and the split mode should match */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3077"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN309"><span class='Ref_to_Member'>aggsplit</span></a> <span class='Operator'>== </span><a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1746"><span class='Ref_to_Member'>aggsplit</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 1. Check for already processed aggs which can be re-used */ 
</span>        <a href="nodeAgg.c.html#LN3080"><span class='Ref_To_Local'>existing_aggno</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN571"><span class='Ref_to_Proto'>find_compatible_peragg</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3077"><span class='Ref_To_Local'>aggref</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN2666"><span class='Ref_To_Local'>aggno</span></a><span class='Delimiter'>, 
</span>                                                <span class='Operator'>&</span><a href="nodeAgg.c.html#LN3082"><span class='Ref_To_Local'>same_input_transnos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3080"><span class='Ref_To_Local'>existing_aggno</span></a> <span class='Operator'>!= -</span><span class='Number'>1</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Existing compatible agg found. so just point the Aggref to the 
             * same per-agg struct. 
             */ 
</span>            <a href="nodeAgg.c.html#LN3076"><span class='Ref_To_Local'>aggrefstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN634"><span class='Ref_to_Member'>aggno</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN3080"><span class='Ref_To_Local'>existing_aggno</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* Mark Aggref state node with assigned index in the result array */ 
</span>        <a href="nodeAgg.c.html#LN3078"><span class='Ref_To_Local'>peragg</span></a> <span class='Operator'>= &</span><a href="nodeAgg.c.html#LN2660"><span class='Ref_To_Local'>peraggs</span></a><span class='Delimiter'>[</span><span class='Operator'>++</span><a href="nodeAgg.c.html#LN2666"><span class='Ref_To_Local'>aggno</span></a><span class='Delimiter'>]; 
</span>        <a href="nodeAgg.c.html#LN3078"><span class='Ref_To_Local'>peragg</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN412"><span class='Ref_to_Member'>aggref</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN3077"><span class='Ref_To_Local'>aggref</span></a><span class='Delimiter'>; 
</span>        <a href="nodeAgg.c.html#LN3076"><span class='Ref_To_Local'>aggrefstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN634"><span class='Ref_to_Member'>aggno</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2666"><span class='Ref_To_Local'>aggno</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Fetch the pg_aggregate row */ 
</span>        <a href="nodeAgg.c.html#LN3086"><span class='Ref_To_Local'>aggTuple</span></a> <span class='Operator'>= </span><a href="../../include/utils/syscache.h.html#LN155"><span class='Ref_to_Macro'>SearchSysCache1</span></a><span class='Parentheses'>(</span><a href="../../include/utils/syscache.h.html#LN33"><span class='Ref_to_EnumConst'>AGGFNOID</span></a><span class='Delimiter'>, 
</span>                                   <a href="../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3077"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN293"><span class='Ref_to_Member'>aggfnoid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3086"><span class='Ref_To_Local'>aggTuple</span></a><span class='Parentheses'>))</span> 
            <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cache lookup failed for aggregate %u"</span><span class='Delimiter'>, 
</span>                 <a href="nodeAgg.c.html#LN3077"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN293"><span class='Ref_to_Member'>aggfnoid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="nodeAgg.c.html#LN3087"><span class='Ref_To_Local'>aggform</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/catalog/pg_aggregate.h.html#LN86"><span class='Ref_to_Typedef'>Form_pg_aggregate</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3086"><span class='Ref_To_Local'>aggTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Check permission to call aggregate function */ 
</span>        <a href="nodeAgg.c.html#LN3088"><span class='Ref_To_Local'>aclresult</span></a> <span class='Operator'>= </span><a href="../../include/utils/acl.h.html#LN285"><span class='Ref_to_Proto'>pg_proc_aclcheck</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3077"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN293"><span class='Ref_to_Member'>aggfnoid</span></a><span class='Delimiter'>, </span><a href="../utils/init/miscinit.c.html#LN281"><span class='Ref_to_Func'>GetUserId</span></a><span class='Parentheses'>()</span><span class='Delimiter'>, 
</span>                                     <a href="../../include/nodes/parsenodes.h.html#LN78"><span class='Ref_to_Const'>ACL_EXECUTE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3088"><span class='Ref_To_Local'>aclresult</span></a> <span class='Operator'>!= </span><a href="../../include/utils/acl.h.html#LN171"><span class='Ref_to_EnumConst'>ACLCHECK_OK</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/utils/acl.h.html#LN295"><span class='Ref_to_Proto'>aclcheck_error</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3088"><span class='Ref_To_Local'>aclresult</span></a><span class='Delimiter'>, </span><a href="../../include/utils/acl.h.html#LN184"><span class='Ref_to_EnumConst'>ACL_KIND_PROC</span></a><span class='Delimiter'>, 
</span>                           <a href="../../include/utils/lsyscache.h.html#LN110"><span class='Ref_to_Proto'>get_func_name</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3077"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN293"><span class='Ref_to_Member'>aggfnoid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="../../include/catalog/objectaccess.h.html#LN178"><span class='Ref_to_Macro'>InvokeFunctionExecuteHook</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3077"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN293"><span class='Ref_to_Member'>aggfnoid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* planner recorded transition state type in the Aggref itself */ 
</span>        <a href="nodeAgg.c.html#LN3094"><span class='Ref_To_Local'>aggtranstype</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN3077"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN297"><span class='Ref_to_Member'>aggtranstype</span></a><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3094"><span class='Ref_To_Local'>aggtranstype</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If this aggregation is performing state combines, then instead of 
         * using the transition function, we'll use the combine function 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN766"><span class='Ref_to_Macro'>DO_AGGSPLIT_COMBINE</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1746"><span class='Ref_to_Member'>aggsplit</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="nodeAgg.c.html#LN3089"><span class='Ref_To_Local'>transfn_oid</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN3087"><span class='Ref_To_Local'>aggform</span></a><span class='Operator'>-&GT;</span>aggcombinefn<span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* If not set then the planner messed up */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3089"><span class='Ref_To_Local'>transfn_oid</span></a><span class='Parentheses'>))</span> 
                <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"combinefn not set for aggregate function"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
            <a href="nodeAgg.c.html#LN3089"><span class='Ref_To_Local'>transfn_oid</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN3087"><span class='Ref_To_Local'>aggform</span></a><span class='Operator'>-&GT;</span>aggtransfn<span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Final function only required if we're finalizing the aggregates */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN767"><span class='Ref_to_Macro'>DO_AGGSPLIT_SKIPFINAL</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1746"><span class='Ref_to_Member'>aggsplit</span></a><span class='Parentheses'>))</span> 
            <a href="nodeAgg.c.html#LN3078"><span class='Ref_To_Local'>peragg</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN418"><span class='Ref_to_Member'>finalfn_oid</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN3090"><span class='Ref_To_Local'>finalfn_oid</span></a> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="nodeAgg.c.html#LN3078"><span class='Ref_To_Local'>peragg</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN418"><span class='Ref_to_Member'>finalfn_oid</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN3090"><span class='Ref_To_Local'>finalfn_oid</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN3087"><span class='Ref_To_Local'>aggform</span></a><span class='Operator'>-&GT;</span>aggfinalfn<span class='Delimiter'>; 
</span> 
        <a href="nodeAgg.c.html#LN3091"><span class='Ref_To_Local'>serialfn_oid</span></a> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>        <a href="nodeAgg.c.html#LN3092"><span class='Ref_To_Local'>deserialfn_oid</span></a> <span class='Operator'>= </span><a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Check if serialization/deserialization is required.  We only do it 
         * for aggregates that have transtype INTERNAL. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3094"><span class='Ref_To_Local'>aggtranstype</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN697"><span class='Ref_to_Const'>INTERNALOID</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * The planner should only have generated a serialize agg node if 
             * every aggregate with an INTERNAL state has a serialization 
             * function.  Verify that. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN768"><span class='Ref_to_Macro'>DO_AGGSPLIT_SERIALIZE</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1746"><span class='Ref_to_Member'>aggsplit</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* serialization only valid when not running finalfn */ 
</span>                <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN767"><span class='Ref_to_Macro'>DO_AGGSPLIT_SKIPFINAL</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1746"><span class='Ref_to_Member'>aggsplit</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3087"><span class='Ref_To_Local'>aggform</span></a><span class='Operator'>-&GT;</span>aggserialfn<span class='Parentheses'>))</span> 
                    <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"serialfunc not provided for serialization aggregation"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="nodeAgg.c.html#LN3091"><span class='Ref_To_Local'>serialfn_oid</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN3087"><span class='Ref_To_Local'>aggform</span></a><span class='Operator'>-&GT;</span>aggserialfn<span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* Likewise for deserialization functions */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN769"><span class='Ref_to_Macro'>DO_AGGSPLIT_DESERIALIZE</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1746"><span class='Ref_to_Member'>aggsplit</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* deserialization only valid when combining states */ 
</span>                <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN766"><span class='Ref_to_Macro'>DO_AGGSPLIT_COMBINE</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1746"><span class='Ref_to_Member'>aggsplit</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3087"><span class='Ref_To_Local'>aggform</span></a><span class='Operator'>-&GT;</span>aggdeserialfn<span class='Parentheses'>))</span> 
                    <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"deserialfunc not provided for deserialization aggregation"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="nodeAgg.c.html#LN3092"><span class='Ref_To_Local'>deserialfn_oid</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN3087"><span class='Ref_To_Local'>aggform</span></a><span class='Operator'>-&GT;</span>aggdeserialfn<span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if aggtranstype==INTERNA... &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* Check that aggregate owner has permission to call component fns */ 
</span>        <span class='Delimiter'>{ 
</span><a name="LN3201"></a>            <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>procTuple</span><span class='Delimiter'>; 
</span><a name="LN3202"></a>            <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>aggOwner</span><span class='Delimiter'>; 
</span> 
            <a href="nodeAgg.c.html#LN3201"><span class='Ref_To_Local'>procTuple</span></a> <span class='Operator'>= </span><a href="../../include/utils/syscache.h.html#LN155"><span class='Ref_to_Macro'>SearchSysCache1</span></a><span class='Parentheses'>(</span><a href="../../include/utils/syscache.h.html#LN76"><span class='Ref_to_EnumConst'>PROCOID</span></a><span class='Delimiter'>, 
</span>                                        <a href="../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3077"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN293"><span class='Ref_to_Member'>aggfnoid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3201"><span class='Ref_To_Local'>procTuple</span></a><span class='Parentheses'>))</span> 
                <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cache lookup failed for function %u"</span><span class='Delimiter'>, 
</span>                     <a href="nodeAgg.c.html#LN3077"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN293"><span class='Ref_to_Member'>aggfnoid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="nodeAgg.c.html#LN3202"><span class='Ref_To_Local'>aggOwner</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../include/catalog/pg_proc.h.html#LN82"><span class='Ref_to_Typedef'>Form_pg_proc</span></a><span class='Parentheses'>) </span><a href="../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3201"><span class='Ref_To_Local'>procTuple</span></a><span class='Parentheses'>))</span><span class='Operator'>-&GT;</span>proowner<span class='Delimiter'>; 
</span>            <a href="../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3201"><span class='Ref_To_Local'>procTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="nodeAgg.c.html#LN3088"><span class='Ref_To_Local'>aclresult</span></a> <span class='Operator'>= </span><a href="../../include/utils/acl.h.html#LN285"><span class='Ref_to_Proto'>pg_proc_aclcheck</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3089"><span class='Ref_To_Local'>transfn_oid</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN3202"><span class='Ref_To_Local'>aggOwner</span></a><span class='Delimiter'>, 
</span>                                         <a href="../../include/nodes/parsenodes.h.html#LN78"><span class='Ref_to_Const'>ACL_EXECUTE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3088"><span class='Ref_To_Local'>aclresult</span></a> <span class='Operator'>!= </span><a href="../../include/utils/acl.h.html#LN171"><span class='Ref_to_EnumConst'>ACLCHECK_OK</span></a><span class='Parentheses'>) 
</span>                <a href="../../include/utils/acl.h.html#LN295"><span class='Ref_to_Proto'>aclcheck_error</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3088"><span class='Ref_To_Local'>aclresult</span></a><span class='Delimiter'>, </span><a href="../../include/utils/acl.h.html#LN184"><span class='Ref_to_EnumConst'>ACL_KIND_PROC</span></a><span class='Delimiter'>, 
</span>                               <a href="../../include/utils/lsyscache.h.html#LN110"><span class='Ref_to_Proto'>get_func_name</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3089"><span class='Ref_To_Local'>transfn_oid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="../../include/catalog/objectaccess.h.html#LN178"><span class='Ref_to_Macro'>InvokeFunctionExecuteHook</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3089"><span class='Ref_To_Local'>transfn_oid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3090"><span class='Ref_To_Local'>finalfn_oid</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <a href="nodeAgg.c.html#LN3088"><span class='Ref_To_Local'>aclresult</span></a> <span class='Operator'>= </span><a href="../../include/utils/acl.h.html#LN285"><span class='Ref_to_Proto'>pg_proc_aclcheck</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3090"><span class='Ref_To_Local'>finalfn_oid</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN3202"><span class='Ref_To_Local'>aggOwner</span></a><span class='Delimiter'>, 
</span>                                             <a href="../../include/nodes/parsenodes.h.html#LN78"><span class='Ref_to_Const'>ACL_EXECUTE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3088"><span class='Ref_To_Local'>aclresult</span></a> <span class='Operator'>!= </span><a href="../../include/utils/acl.h.html#LN171"><span class='Ref_to_EnumConst'>ACLCHECK_OK</span></a><span class='Parentheses'>) 
</span>                    <a href="../../include/utils/acl.h.html#LN295"><span class='Ref_to_Proto'>aclcheck_error</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3088"><span class='Ref_To_Local'>aclresult</span></a><span class='Delimiter'>, </span><a href="../../include/utils/acl.h.html#LN184"><span class='Ref_to_EnumConst'>ACL_KIND_PROC</span></a><span class='Delimiter'>, 
</span>                                   <a href="../../include/utils/lsyscache.h.html#LN110"><span class='Ref_to_Proto'>get_func_name</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3090"><span class='Ref_To_Local'>finalfn_oid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <a href="../../include/catalog/objectaccess.h.html#LN178"><span class='Ref_to_Macro'>InvokeFunctionExecuteHook</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3090"><span class='Ref_To_Local'>finalfn_oid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3091"><span class='Ref_To_Local'>serialfn_oid</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <a href="nodeAgg.c.html#LN3088"><span class='Ref_To_Local'>aclresult</span></a> <span class='Operator'>= </span><a href="../../include/utils/acl.h.html#LN285"><span class='Ref_to_Proto'>pg_proc_aclcheck</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3091"><span class='Ref_To_Local'>serialfn_oid</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN3202"><span class='Ref_To_Local'>aggOwner</span></a><span class='Delimiter'>, 
</span>                                             <a href="../../include/nodes/parsenodes.h.html#LN78"><span class='Ref_to_Const'>ACL_EXECUTE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3088"><span class='Ref_To_Local'>aclresult</span></a> <span class='Operator'>!= </span><a href="../../include/utils/acl.h.html#LN171"><span class='Ref_to_EnumConst'>ACLCHECK_OK</span></a><span class='Parentheses'>) 
</span>                    <a href="../../include/utils/acl.h.html#LN295"><span class='Ref_to_Proto'>aclcheck_error</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3088"><span class='Ref_To_Local'>aclresult</span></a><span class='Delimiter'>, </span><a href="../../include/utils/acl.h.html#LN184"><span class='Ref_to_EnumConst'>ACL_KIND_PROC</span></a><span class='Delimiter'>, 
</span>                                   <a href="../../include/utils/lsyscache.h.html#LN110"><span class='Ref_to_Proto'>get_func_name</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3091"><span class='Ref_To_Local'>serialfn_oid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <a href="../../include/catalog/objectaccess.h.html#LN178"><span class='Ref_to_Macro'>InvokeFunctionExecuteHook</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3091"><span class='Ref_To_Local'>serialfn_oid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3092"><span class='Ref_To_Local'>deserialfn_oid</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <a href="nodeAgg.c.html#LN3088"><span class='Ref_To_Local'>aclresult</span></a> <span class='Operator'>= </span><a href="../../include/utils/acl.h.html#LN285"><span class='Ref_to_Proto'>pg_proc_aclcheck</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3092"><span class='Ref_To_Local'>deserialfn_oid</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN3202"><span class='Ref_To_Local'>aggOwner</span></a><span class='Delimiter'>, 
</span>                                             <a href="../../include/nodes/parsenodes.h.html#LN78"><span class='Ref_to_Const'>ACL_EXECUTE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3088"><span class='Ref_To_Local'>aclresult</span></a> <span class='Operator'>!= </span><a href="../../include/utils/acl.h.html#LN171"><span class='Ref_to_EnumConst'>ACLCHECK_OK</span></a><span class='Parentheses'>) 
</span>                    <a href="../../include/utils/acl.h.html#LN295"><span class='Ref_to_Proto'>aclcheck_error</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3088"><span class='Ref_To_Local'>aclresult</span></a><span class='Delimiter'>, </span><a href="../../include/utils/acl.h.html#LN184"><span class='Ref_to_EnumConst'>ACL_KIND_PROC</span></a><span class='Delimiter'>, 
</span>                                   <a href="../../include/utils/lsyscache.h.html#LN110"><span class='Ref_to_Proto'>get_func_name</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3092"><span class='Ref_To_Local'>deserialfn_oid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <a href="../../include/catalog/objectaccess.h.html#LN178"><span class='Ref_to_Macro'>InvokeFunctionExecuteHook</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3092"><span class='Ref_To_Local'>deserialfn_oid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Get actual datatypes of the (nominal) aggregate inputs.  These 
         * could be different from the agg's declared input types, when the 
         * agg accepts ANY or a polymorphic type. 
         */ 
</span>        <a href="nodeAgg.c.html#LN3084"><span class='Ref_To_Local'>numArguments</span></a> <span class='Operator'>= </span><a href="../../include/parser/parse_agg.h.html#LN30"><span class='Ref_to_Proto'>get_aggregate_argtypes</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3077"><span class='Ref_To_Local'>aggref</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN3083"><span class='Ref_To_Local'>inputTypes</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Count the "direct" arguments, if any */ 
</span>        <a href="nodeAgg.c.html#LN3085"><span class='Ref_To_Local'>numDirectArgs</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3077"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN299"><span class='Ref_to_Member'>aggdirectargs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Detect how many arguments to pass to the finalfn */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3087"><span class='Ref_To_Local'>aggform</span></a><span class='Operator'>-&GT;</span>aggfinalextra<span class='Parentheses'>) 
</span>            <a href="nodeAgg.c.html#LN3078"><span class='Ref_To_Local'>peragg</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN432"><span class='Ref_to_Member'>numFinalArgs</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN3084"><span class='Ref_To_Local'>numArguments</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="nodeAgg.c.html#LN3078"><span class='Ref_To_Local'>peragg</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN432"><span class='Ref_to_Member'>numFinalArgs</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN3085"><span class='Ref_To_Local'>numDirectArgs</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * build expression trees using actual argument & result types for the 
         * finalfn, if it exists and is required. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3090"><span class='Ref_To_Local'>finalfn_oid</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="../../include/parser/parse_agg.h.html#LN59"><span class='Ref_to_Proto'>build_aggregate_finalfn_expr</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3083"><span class='Ref_To_Local'>inputTypes</span></a><span class='Delimiter'>, 
</span>                                         <a href="nodeAgg.c.html#LN3078"><span class='Ref_To_Local'>peragg</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN432"><span class='Ref_to_Member'>numFinalArgs</span></a><span class='Delimiter'>, 
</span>                                         <a href="nodeAgg.c.html#LN3094"><span class='Ref_To_Local'>aggtranstype</span></a><span class='Delimiter'>, 
</span>                                         <a href="nodeAgg.c.html#LN3077"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN294"><span class='Ref_to_Member'>aggtype</span></a><span class='Delimiter'>, 
</span>                                         <a href="nodeAgg.c.html#LN3077"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN296"><span class='Ref_to_Member'>inputcollid</span></a><span class='Delimiter'>, 
</span>                                         <a href="nodeAgg.c.html#LN3090"><span class='Ref_To_Local'>finalfn_oid</span></a><span class='Delimiter'>, 
</span>                                         <span class='Operator'>&</span><a href="nodeAgg.c.html#LN3093"><span class='Ref_To_Local'>finalfnexpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../include/fmgr.h.html#LN92"><span class='Ref_to_Proto'>fmgr_info</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3090"><span class='Ref_To_Local'>finalfn_oid</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nodeAgg.c.html#LN3078"><span class='Ref_To_Local'>peragg</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN424"><span class='Ref_to_Member'>finalfn</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../include/fmgr.h.html#LN103"><span class='Ref_to_Macro'>fmgr_info_set_expr</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeAgg.c.html#LN3093"><span class='Ref_To_Local'>finalfnexpr</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nodeAgg.c.html#LN3078"><span class='Ref_To_Local'>peragg</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN424"><span class='Ref_to_Member'>finalfn</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* get info about the output value's datatype */ 
</span>        <a href="../../include/utils/lsyscache.h.html#LN135"><span class='Ref_to_Proto'>get_typlenbyval</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3077"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN294"><span class='Ref_to_Member'>aggtype</span></a><span class='Delimiter'>, 
</span>                        <span class='Operator'>&</span><a href="nodeAgg.c.html#LN3078"><span class='Ref_To_Local'>peragg</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN438"><span class='Ref_to_Member'>resulttypeLen</span></a><span class='Delimiter'>, 
</span>                        <span class='Operator'>&</span><a href="nodeAgg.c.html#LN3078"><span class='Ref_To_Local'>peragg</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN439"><span class='Ref_to_Member'>resulttypeByVal</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * initval is potentially null, so don't try to access it as a struct 
         * field. Must do it the hard way with SysCacheGetAttr. 
         */ 
</span>        <a href="nodeAgg.c.html#LN3095"><span class='Ref_To_Local'>textInitVal</span></a> <span class='Operator'>= </span><a href="../../include/utils/syscache.h.html#LN133"><span class='Ref_to_Proto'>SysCacheGetAttr</span></a><span class='Parentheses'>(</span><a href="../../include/utils/syscache.h.html#LN33"><span class='Ref_to_EnumConst'>AGGFNOID</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN3086"><span class='Ref_To_Local'>aggTuple</span></a><span class='Delimiter'>, 
</span>                                      <a href="../../include/catalog/pg_aggregate.h.html#LN112"><span class='Ref_to_Const'>Anum_pg_aggregate_agginitval</span></a><span class='Delimiter'>, 
</span>                                      <span class='Operator'>&</span><a href="nodeAgg.c.html#LN3097"><span class='Ref_To_Local'>initValueIsNull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3097"><span class='Ref_To_Local'>initValueIsNull</span></a><span class='Parentheses'>) 
</span>            <a href="nodeAgg.c.html#LN3096"><span class='Ref_To_Local'>initValue</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="nodeAgg.c.html#LN3096"><span class='Ref_To_Local'>initValue</span></a> <span class='Operator'>= </span><a href="nodeWindowAgg.c.html#LN189"><span class='Ref_to_Proto'>GetAggInitVal</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3095"><span class='Ref_To_Local'>textInitVal</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN3094"><span class='Ref_To_Local'>aggtranstype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * 2. Build working state for invoking the transition function, or 
         * look up previously initialized working state, if we can share it. 
         * 
         * find_compatible_peragg() already collected a list of per-Trans's 
         * with the same inputs. Check if any of them have the same transition 
         * function and initial value. 
         */ 
</span>        <a href="nodeAgg.c.html#LN3081"><span class='Ref_To_Local'>existing_transno</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN573"><span class='Ref_to_Proto'>find_compatible_pertrans</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN3077"><span class='Ref_To_Local'>aggref</span></a><span class='Delimiter'>, 
</span>                                                    <a href="nodeAgg.c.html#LN3089"><span class='Ref_To_Local'>transfn_oid</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN3094"><span class='Ref_To_Local'>aggtranstype</span></a><span class='Delimiter'>, 
</span>                                                <a href="nodeAgg.c.html#LN3091"><span class='Ref_To_Local'>serialfn_oid</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN3092"><span class='Ref_To_Local'>deserialfn_oid</span></a><span class='Delimiter'>, 
</span>                                                  <a href="nodeAgg.c.html#LN3096"><span class='Ref_To_Local'>initValue</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN3097"><span class='Ref_To_Local'>initValueIsNull</span></a><span class='Delimiter'>, 
</span>                                                    <a href="nodeAgg.c.html#LN3082"><span class='Ref_To_Local'>same_input_transnos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3081"><span class='Ref_To_Local'>existing_transno</span></a> <span class='Operator'>!= -</span><span class='Number'>1</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Existing compatible trans found, so just point the 'peragg' to 
             * the same per-trans struct. 
             */ 
</span>            <a href="nodeAgg.c.html#LN3079"><span class='Ref_To_Local'>pertrans</span></a> <span class='Operator'>= &</span><a href="nodeAgg.c.html#LN2661"><span class='Ref_To_Local'>pertransstates</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN3081"><span class='Ref_To_Local'>existing_transno</span></a><span class='Delimiter'>]; 
</span>            <a href="nodeAgg.c.html#LN3078"><span class='Ref_To_Local'>peragg</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN415"><span class='Ref_to_Member'>transno</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN3081"><span class='Ref_To_Local'>existing_transno</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <a href="nodeAgg.c.html#LN3079"><span class='Ref_To_Local'>pertrans</span></a> <span class='Operator'>= &</span><a href="nodeAgg.c.html#LN2661"><span class='Ref_To_Local'>pertransstates</span></a><span class='Delimiter'>[</span><span class='Operator'>++</span><a href="nodeAgg.c.html#LN2665"><span class='Ref_To_Local'>transno</span></a><span class='Delimiter'>]; 
</span>            <a href="nodeAgg.c.html#LN565"><span class='Ref_to_Proto'>build_pertrans_for_aggref</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3079"><span class='Ref_To_Local'>pertrans</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN2657"><span class='Ref_to_Parameter'>estate</span></a><span class='Delimiter'>, 
</span>                                      <a href="nodeAgg.c.html#LN3077"><span class='Ref_To_Local'>aggref</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN3089"><span class='Ref_To_Local'>transfn_oid</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN3094"><span class='Ref_To_Local'>aggtranstype</span></a><span class='Delimiter'>, 
</span>                                      <a href="nodeAgg.c.html#LN3091"><span class='Ref_To_Local'>serialfn_oid</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN3092"><span class='Ref_To_Local'>deserialfn_oid</span></a><span class='Delimiter'>, 
</span>                                      <a href="nodeAgg.c.html#LN3096"><span class='Ref_To_Local'>initValue</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN3097"><span class='Ref_To_Local'>initValueIsNull</span></a><span class='Delimiter'>, 
</span>                                      <a href="nodeAgg.c.html#LN3083"><span class='Ref_To_Local'>inputTypes</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN3084"><span class='Ref_To_Local'>numArguments</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="nodeAgg.c.html#LN3078"><span class='Ref_To_Local'>peragg</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN415"><span class='Ref_to_Member'>transno</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2665"><span class='Ref_To_Local'>transno</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <a href="../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3086"><span class='Ref_To_Local'>aggTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Update numaggs to match the number of unique aggregates found. Also set 
     * numstates to the number of unique aggregate states found. 
     */ 
</span>    <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1743"><span class='Ref_to_Member'>numaggs</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2666"><span class='Ref_To_Local'>aggno</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1744"><span class='Ref_to_Member'>numtrans</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2665"><span class='Ref_To_Local'>transno</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Build a single projection computing the aggregate arguments for all 
     * aggregates at once, that's considerably faster than doing it separately 
     * for each. 
     * 
     * First create a targetlist combining the targetlist of all the 
     * transitions. 
     */ 
</span>    <a href="nodeAgg.c.html#LN2669"><span class='Ref_To_Local'>combined_inputeval</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN2675"><span class='Ref_To_Local'>column_offset</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2665"><span class='Ref_To_Local'>transno</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN2665"><span class='Ref_To_Local'>transno</span></a> <span class='Operator'>&LT; </span><a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1744"><span class='Ref_to_Member'>numtrans</span></a><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN2665"><span class='Ref_To_Local'>transno</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3351"></a>        <a href="../../include/nodes/execnodes.h.html#LN1734"><span class='Ref_to_Typedef'>AggStatePerTrans</span></a> <span class='Declare_Local'>pertrans</span> <span class='Operator'>= &</span><a href="nodeAgg.c.html#LN2661"><span class='Ref_To_Local'>pertransstates</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN2665"><span class='Ref_To_Local'>transno</span></a><span class='Delimiter'>]; 
</span><a name="LN3352"></a>        <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>arg</span><span class='Delimiter'>; 
</span> 
        <a href="nodeAgg.c.html#LN3351"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN271"><span class='Ref_to_Member'>inputoff</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN2675"><span class='Ref_To_Local'>column_offset</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Adjust resno in a copied target entries, to point into the combined 
         * slot. 
         */ 
</span>        <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3352"><span class='Ref_To_Local'>arg</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN3351"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN254"><span class='Ref_to_Member'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN300"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN3362"></a>            <a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>source_tle</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN108"><span class='Ref_to_Macro'>lfirst_node</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN3352"><span class='Ref_To_Local'>arg</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN3363"></a>            <a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle</span><span class='Delimiter'>; 
</span> 
            <a href="nodeAgg.c.html#LN3363"><span class='Ref_To_Local'>tle</span></a> <span class='Operator'>= </span><a href="../../include/nodes/makefuncs.h.html#LN45"><span class='Ref_to_Proto'>flatCopyTargetEntry</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3362"><span class='Ref_To_Local'>source_tle</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="nodeAgg.c.html#LN3363"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1367"><span class='Ref_to_Member'>resno</span></a> <span class='Operator'>+= </span><a href="nodeAgg.c.html#LN2675"><span class='Ref_To_Local'>column_offset</span></a><span class='Delimiter'>; 
</span> 
            <a href="nodeAgg.c.html#LN2669"><span class='Ref_To_Local'>combined_inputeval</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2669"><span class='Ref_To_Local'>combined_inputeval</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN3363"><span class='Ref_To_Local'>tle</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="nodeAgg.c.html#LN2675"><span class='Ref_To_Local'>column_offset</span></a> <span class='Operator'>+= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3351"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN254"><span class='Ref_to_Member'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN300"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for transno=0;transno&LT;agg... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* and then create a projection for that targetlist */ 
</span>    <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1781"><span class='Ref_to_Member'>evaldesc</span></a> <span class='Operator'>= </span><a href="../../include/executor/executor.h.html#LN405"><span class='Ref_to_Proto'>ExecTypeFromTL</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2669"><span class='Ref_To_Local'>combined_inputeval</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1779"><span class='Ref_to_Member'>evalslot</span></a> <span class='Operator'>= </span><a href="../../include/executor/executor.h.html#LN402"><span class='Ref_to_Proto'>ExecInitExtraTupleSlot</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2657"><span class='Ref_to_Parameter'>estate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1780"><span class='Ref_to_Member'>evalproj</span></a> <span class='Operator'>= </span><a href="../../include/executor/executor.h.html#LN241"><span class='Ref_to_Proto'>ExecBuildProjectionInfo</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2669"><span class='Ref_To_Local'>combined_inputeval</span></a><span class='Delimiter'>, 
</span>                                                 <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1754"><span class='Ref_to_Member'>tmpcontext</span></a><span class='Delimiter'>, 
</span>                                                 <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1779"><span class='Ref_to_Member'>evalslot</span></a><span class='Delimiter'>, 
</span>                                                 <span class='Operator'>&</span><a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1741"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Delimiter'>, 
</span>                                                 <span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/executor/tuptable.h.html#LN146"><span class='Ref_to_Proto'>ExecSetSlotDescriptor</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1779"><span class='Ref_to_Member'>evalslot</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1781"><span class='Ref_to_Member'>evaldesc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="nodeAgg.c.html#LN2659"><span class='Ref_To_Local'>aggstate</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ExecInitAgg &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Build the state needed to calculate a state value for an aggregate. 
 * 
 * This initializes all the fields in 'pertrans'. 'aggref' is the aggregate 
 * to initialize the state for. 'aggtransfn', 'aggtranstype', and the rest 
 * of the arguments could be calculated from 'aggref', but the caller has 
 * calculated them already, so might as well pass them. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN3396"></a><span class='Declare_Function'>build_pertrans_for_aggref</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1734"><span class='Ref_to_Typedef'>AggStatePerTrans</span></a> <span class='Declare_Parameter'>pertrans</span><span class='Delimiter'>, 
</span><a name="LN3397"></a>                          <a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/execnodes.h.html#LN402"><span class='Ref_to_Struct'>EState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>estate</span><span class='Delimiter'>, 
</span><a name="LN3398"></a>                          <a href="../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggref</span><span class='Delimiter'>, 
</span><a name="LN3399"></a>                          <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>aggtransfn</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>aggtranstype</span><span class='Delimiter'>, 
</span><a name="LN3400"></a>                          <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>aggserialfn</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>aggdeserialfn</span><span class='Delimiter'>, 
</span><a name="LN3401"></a>                          <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>initValue</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>initValueIsNull</span><span class='Delimiter'>, 
</span><a name="LN3402"></a>                          <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>inputTypes</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>numArguments</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3404"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numGroupingSets</span> <span class='Operator'>= </span><a href="../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN10"><span class='Ref_to_Macro'>Max</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3397"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1765"><span class='Ref_to_Member'>maxsets</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN3405"></a>    <a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>serialfnexpr</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN3406"></a>    <a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>deserialfnexpr</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN3407"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span><a name="LN3408"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numInputs</span><span class='Delimiter'>; 
</span><a name="LN3409"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numDirectArgs</span><span class='Delimiter'>; 
</span><a name="LN3410"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>sortlist</span><span class='Delimiter'>; 
</span><a name="LN3411"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numSortCols</span><span class='Delimiter'>; 
</span><a name="LN3412"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numDistinctCols</span><span class='Delimiter'>; 
</span><a name="LN3413"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>naggs</span><span class='Delimiter'>; 
</span><a name="LN3414"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Begin filling in the pertrans data */ 
</span>    <a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN254"><span class='Ref_to_Member'>aggref</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN3398"><span class='Ref_to_Parameter'>aggref</span></a><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN309"><span class='Ref_to_Member'>aggCollation</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN3398"><span class='Ref_to_Parameter'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN296"><span class='Ref_to_Member'>inputcollid</span></a><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN281"><span class='Ref_to_Member'>transfn_oid</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN3399"><span class='Ref_to_Parameter'>aggtransfn</span></a><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN284"><span class='Ref_to_Member'>serialfn_oid</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN3400"><span class='Ref_to_Parameter'>aggserialfn</span></a><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN287"><span class='Ref_to_Member'>deserialfn_oid</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN3400"><span class='Ref_to_Parameter'>aggdeserialfn</span></a><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN334"><span class='Ref_to_Member'>initValue</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN3401"><span class='Ref_to_Parameter'>initValue</span></a><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN335"><span class='Ref_to_Member'>initValueIsNull</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN3401"><span class='Ref_to_Parameter'>initValueIsNull</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Count the "direct" arguments, if any */ 
</span>    <a href="nodeAgg.c.html#LN3409"><span class='Ref_To_Local'>numDirectArgs</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3398"><span class='Ref_to_Parameter'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN299"><span class='Ref_to_Member'>aggdirectargs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Count the number of aggregated input columns */ 
</span>    <a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN268"><span class='Ref_to_Member'>numInputs</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN3408"><span class='Ref_To_Local'>numInputs</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3398"><span class='Ref_to_Parameter'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN300"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN290"><span class='Ref_to_Member'>aggtranstype</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN3399"><span class='Ref_to_Parameter'>aggtranstype</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Detect how many arguments to pass to the transfn */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/catalog/pg_aggregate.h.html#LN128"><span class='Ref_to_Macro'>AGGKIND_IS_ORDERED_SET</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3398"><span class='Ref_to_Parameter'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN307"><span class='Ref_to_Member'>aggkind</span></a><span class='Parentheses'>))</span> 
        <a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN278"><span class='Ref_to_Member'>numTransInputs</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN3408"><span class='Ref_To_Local'>numInputs</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN278"><span class='Ref_to_Member'>numTransInputs</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN3402"><span class='Ref_to_Parameter'>numArguments</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * When combining states, we have no use at all for the aggregate 
     * function's transfn. Instead we use the combinefn.  In this case, the 
     * transfn and transfn_oid fields of pertrans refer to the combine 
     * function rather than the transition function. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN766"><span class='Ref_to_Macro'>DO_AGGSPLIT_COMBINE</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3397"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1746"><span class='Ref_to_Member'>aggsplit</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN3447"></a>        <a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>combinefnexpr</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/parser/parse_agg.h.html#LN48"><span class='Ref_to_Proto'>build_aggregate_combinefn_expr</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3399"><span class='Ref_to_Parameter'>aggtranstype</span></a><span class='Delimiter'>, 
</span>                                       <a href="nodeAgg.c.html#LN3398"><span class='Ref_to_Parameter'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN296"><span class='Ref_to_Member'>inputcollid</span></a><span class='Delimiter'>, 
</span>                                       <a href="nodeAgg.c.html#LN3399"><span class='Ref_to_Parameter'>aggtransfn</span></a><span class='Delimiter'>, 
</span>                                       <span class='Operator'>&</span><a href="nodeAgg.c.html#LN3447"><span class='Ref_To_Local'>combinefnexpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/fmgr.h.html#LN92"><span class='Ref_to_Proto'>fmgr_info</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3399"><span class='Ref_to_Parameter'>aggtransfn</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN300"><span class='Ref_to_Member'>transfn</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/fmgr.h.html#LN103"><span class='Ref_to_Macro'>fmgr_info_set_expr</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeAgg.c.html#LN3447"><span class='Ref_To_Local'>combinefnexpr</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN300"><span class='Ref_to_Member'>transfn</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/fmgr.h.html#LN119"><span class='Ref_to_Macro'>InitFunctionCallInfoData</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN387"><span class='Ref_to_Member'>transfn_fcinfo</span></a><span class='Delimiter'>, 
</span>                                 <span class='Operator'>&</span><a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN300"><span class='Ref_to_Member'>transfn</span></a><span class='Delimiter'>, 
</span>                                 <span class='Number'>2</span><span class='Delimiter'>, 
</span>                                 <a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN309"><span class='Ref_to_Member'>aggCollation</span></a><span class='Delimiter'>, 
</span>                                 <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeAgg.c.html#LN3397"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Ensure that a combine function to combine INTERNAL states is not 
         * strict. This should have been checked during CREATE AGGREGATE, but 
         * the strict property could have been changed since then. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN300"><span class='Ref_to_Member'>transfn</span></a><span class='Operator'>.</span><a href="../../include/fmgr.h.html#LN60"><span class='Ref_to_Member'>fn_strict</span></a> <span class='Operator'>&& </span><a href="nodeAgg.c.html#LN3399"><span class='Ref_to_Parameter'>aggtranstype</span></a> <span class='Operator'>== </span><a href="../../include/catalog/pg_type.h.html#LN697"><span class='Ref_to_Const'>INTERNALOID</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_INVALID_FUNCTION_DEFINITION<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                     <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"combine function for aggregate %u must be declared as STRICT"</span><span class='Delimiter'>, 
</span>                            <a href="nodeAgg.c.html#LN3398"><span class='Ref_to_Parameter'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN293"><span class='Ref_to_Member'>aggfnoid</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if DO_AGGSPLIT_COMBINE(a... &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span><a name="LN3475"></a>        <a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>transfnexpr</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Set up infrastructure for calling the transfn.  Note that invtrans 
         * is not needed here. 
         */ 
</span>        <a href="../../include/parser/parse_agg.h.html#LN37"><span class='Ref_to_Proto'>build_aggregate_transfn_expr</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3402"><span class='Ref_to_Parameter'>inputTypes</span></a><span class='Delimiter'>, 
</span>                                     <a href="nodeAgg.c.html#LN3402"><span class='Ref_to_Parameter'>numArguments</span></a><span class='Delimiter'>, 
</span>                                     <a href="nodeAgg.c.html#LN3409"><span class='Ref_To_Local'>numDirectArgs</span></a><span class='Delimiter'>, 
</span>                                     <a href="nodeAgg.c.html#LN3398"><span class='Ref_to_Parameter'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN305"><span class='Ref_to_Member'>aggvariadic</span></a><span class='Delimiter'>, 
</span>                                     <a href="nodeAgg.c.html#LN3399"><span class='Ref_to_Parameter'>aggtranstype</span></a><span class='Delimiter'>, 
</span>                                     <a href="nodeAgg.c.html#LN3398"><span class='Ref_to_Parameter'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN296"><span class='Ref_to_Member'>inputcollid</span></a><span class='Delimiter'>, 
</span>                                     <a href="nodeAgg.c.html#LN3399"><span class='Ref_to_Parameter'>aggtransfn</span></a><span class='Delimiter'>, 
</span>                                     <a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, 
</span>                                     <span class='Operator'>&</span><a href="nodeAgg.c.html#LN3475"><span class='Ref_To_Local'>transfnexpr</span></a><span class='Delimiter'>, 
</span>                                     <span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/fmgr.h.html#LN92"><span class='Ref_to_Proto'>fmgr_info</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3399"><span class='Ref_to_Parameter'>aggtransfn</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN300"><span class='Ref_to_Member'>transfn</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/fmgr.h.html#LN103"><span class='Ref_to_Macro'>fmgr_info_set_expr</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeAgg.c.html#LN3475"><span class='Ref_To_Local'>transfnexpr</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN300"><span class='Ref_to_Member'>transfn</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/fmgr.h.html#LN119"><span class='Ref_to_Macro'>InitFunctionCallInfoData</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN387"><span class='Ref_to_Member'>transfn_fcinfo</span></a><span class='Delimiter'>, 
</span>                                 <span class='Operator'>&</span><a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN300"><span class='Ref_to_Member'>transfn</span></a><span class='Delimiter'>, 
</span>                                 <a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN278"><span class='Ref_to_Member'>numTransInputs</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>, 
</span>                                 <a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN309"><span class='Ref_to_Member'>aggCollation</span></a><span class='Delimiter'>, 
</span>                                 <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeAgg.c.html#LN3397"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If the transfn is strict and the initval is NULL, make sure input 
         * type and transtype are the same (or at least binary-compatible), so 
         * that it's OK to use the first aggregated input value as the initial 
         * transValue.  This should have been checked at agg definition time, 
         * but we must check again in case the transfn's strictness property 
         * has been changed. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN300"><span class='Ref_to_Member'>transfn</span></a><span class='Operator'>.</span><a href="../../include/fmgr.h.html#LN60"><span class='Ref_to_Member'>fn_strict</span></a> <span class='Operator'>&& </span><a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN335"><span class='Ref_to_Member'>initValueIsNull</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3402"><span class='Ref_to_Parameter'>numArguments</span></a> <span class='Operator'>&LT;= </span><a href="nodeAgg.c.html#LN3409"><span class='Ref_To_Local'>numDirectArgs</span></a> <span class='Operator'>|| 
</span>                <span class='Operator'>!</span><a href="../../include/parser/parse_coerce.h.html#LN33"><span class='Ref_to_Proto'>IsBinaryCoercible</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3402"><span class='Ref_to_Parameter'>inputTypes</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN3409"><span class='Ref_To_Local'>numDirectArgs</span></a><span class='Delimiter'>], 
</span>                                   <a href="nodeAgg.c.html#LN3399"><span class='Ref_to_Parameter'>aggtranstype</span></a><span class='Parentheses'>))</span> 
                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_INVALID_FUNCTION_DEFINITION<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"aggregate %u needs to have compatible input type and transition type"</span><span class='Delimiter'>, 
</span>                                <a href="nodeAgg.c.html#LN3398"><span class='Ref_to_Parameter'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN293"><span class='Ref_to_Member'>aggfnoid</span></a><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* get info about the state value's datatype */ 
</span>    <a href="../../include/utils/lsyscache.h.html#LN135"><span class='Ref_to_Proto'>get_typlenbyval</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3399"><span class='Ref_to_Parameter'>aggtranstype</span></a><span class='Delimiter'>, 
</span>                    <span class='Operator'>&</span><a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN345"><span class='Ref_to_Member'>transtypeLen</span></a><span class='Delimiter'>, 
</span>                    <span class='Operator'>&</span><a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN347"><span class='Ref_to_Member'>transtypeByVal</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3400"><span class='Ref_to_Parameter'>aggserialfn</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../include/parser/parse_agg.h.html#LN53"><span class='Ref_to_Proto'>build_aggregate_serialfn_expr</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3400"><span class='Ref_to_Parameter'>aggserialfn</span></a><span class='Delimiter'>, 
</span>                                      <span class='Operator'>&</span><a href="nodeAgg.c.html#LN3405"><span class='Ref_To_Local'>serialfnexpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/fmgr.h.html#LN92"><span class='Ref_to_Proto'>fmgr_info</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3400"><span class='Ref_to_Parameter'>aggserialfn</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN303"><span class='Ref_to_Member'>serialfn</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/fmgr.h.html#LN103"><span class='Ref_to_Macro'>fmgr_info_set_expr</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeAgg.c.html#LN3405"><span class='Ref_To_Local'>serialfnexpr</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN303"><span class='Ref_to_Member'>serialfn</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/fmgr.h.html#LN119"><span class='Ref_to_Macro'>InitFunctionCallInfoData</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN390"><span class='Ref_to_Member'>serialfn_fcinfo</span></a><span class='Delimiter'>, 
</span>                                 <span class='Operator'>&</span><a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN303"><span class='Ref_to_Member'>serialfn</span></a><span class='Delimiter'>, 
</span>                                 <span class='Number'>1</span><span class='Delimiter'>, 
</span>                                 <a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, 
</span>                                 <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeAgg.c.html#LN3397"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3400"><span class='Ref_to_Parameter'>aggdeserialfn</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../include/parser/parse_agg.h.html#LN56"><span class='Ref_to_Proto'>build_aggregate_deserialfn_expr</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3400"><span class='Ref_to_Parameter'>aggdeserialfn</span></a><span class='Delimiter'>, 
</span>                                        <span class='Operator'>&</span><a href="nodeAgg.c.html#LN3406"><span class='Ref_To_Local'>deserialfnexpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/fmgr.h.html#LN92"><span class='Ref_to_Proto'>fmgr_info</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3400"><span class='Ref_to_Parameter'>aggdeserialfn</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN306"><span class='Ref_to_Member'>deserialfn</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/fmgr.h.html#LN103"><span class='Ref_to_Macro'>fmgr_info_set_expr</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeAgg.c.html#LN3406"><span class='Ref_To_Local'>deserialfnexpr</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN306"><span class='Ref_to_Member'>deserialfn</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/fmgr.h.html#LN119"><span class='Ref_to_Macro'>InitFunctionCallInfoData</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN392"><span class='Ref_to_Member'>deserialfn_fcinfo</span></a><span class='Delimiter'>, 
</span>                                 <span class='Operator'>&</span><a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN306"><span class='Ref_to_Member'>deserialfn</span></a><span class='Delimiter'>, 
</span>                                 <span class='Number'>2</span><span class='Delimiter'>, 
</span>                                 <a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, 
</span>                                 <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeAgg.c.html#LN3397"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Initialize the input and FILTER expressions */ 
</span>    <a href="nodeAgg.c.html#LN3413"><span class='Ref_To_Local'>naggs</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN3397"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1743"><span class='Ref_to_Member'>numaggs</span></a><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN293"><span class='Ref_to_Member'>aggfilter</span></a> <span class='Operator'>= </span><a href="execExpr.c.html#LN111"><span class='Ref_to_Func'>ExecInitExpr</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3398"><span class='Ref_to_Parameter'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN303"><span class='Ref_to_Member'>aggfilter</span></a><span class='Delimiter'>, 
</span>                                       <span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeAgg.c.html#LN3397"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN294"><span class='Ref_to_Member'>aggdirectargs</span></a> <span class='Operator'>= </span><a href="../../include/executor/executor.h.html#LN240"><span class='Ref_to_Proto'>ExecInitExprList</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3398"><span class='Ref_to_Parameter'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN299"><span class='Ref_to_Member'>aggdirectargs</span></a><span class='Delimiter'>, 
</span>                                               <span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeAgg.c.html#LN3397"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Complain if the aggregate's arguments contain any aggregates; nested 
     * agg functions are semantically nonsensical.  (This should have been 
     * caught earlier, but we defend against it here anyway.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3413"><span class='Ref_To_Local'>naggs</span></a> <span class='Operator'>!= </span><a href="nodeAgg.c.html#LN3397"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1743"><span class='Ref_to_Member'>numaggs</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_GROUPING_ERROR<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                 <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"aggregate function calls cannot be nested"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we're doing either DISTINCT or ORDER BY for a plain agg, then we 
     * have a list of SortGroupClause nodes; fish out the data in them and 
     * stick them into arrays.  We ignore ORDER BY for an ordered-set agg, 
     * however; the agg's transfn and finalfn are responsible for that. 
     * 
     * Note that by construction, if there is a DISTINCT clause then the ORDER 
     * BY clause is a prefix of it (see transformDistinctClause). 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/catalog/pg_aggregate.h.html#LN128"><span class='Ref_to_Macro'>AGGKIND_IS_ORDERED_SET</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3398"><span class='Ref_to_Parameter'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN307"><span class='Ref_to_Member'>aggkind</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="nodeAgg.c.html#LN3410"><span class='Ref_To_Local'>sortlist</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>        <a href="nodeAgg.c.html#LN3411"><span class='Ref_To_Local'>numSortCols</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN3412"><span class='Ref_To_Local'>numDistinctCols</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3398"><span class='Ref_to_Parameter'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN302"><span class='Ref_to_Member'>aggdistinct</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="nodeAgg.c.html#LN3410"><span class='Ref_To_Local'>sortlist</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN3398"><span class='Ref_to_Parameter'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN302"><span class='Ref_to_Member'>aggdistinct</span></a><span class='Delimiter'>; 
</span>        <a href="nodeAgg.c.html#LN3411"><span class='Ref_To_Local'>numSortCols</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN3412"><span class='Ref_To_Local'>numDistinctCols</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3410"><span class='Ref_To_Local'>sortlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3411"><span class='Ref_To_Local'>numSortCols</span></a> <span class='Operator'>&GT;= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3398"><span class='Ref_to_Parameter'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN301"><span class='Ref_to_Member'>aggorder</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="nodeAgg.c.html#LN3410"><span class='Ref_To_Local'>sortlist</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN3398"><span class='Ref_to_Parameter'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN301"><span class='Ref_to_Member'>aggorder</span></a><span class='Delimiter'>; 
</span>        <a href="nodeAgg.c.html#LN3411"><span class='Ref_To_Local'>numSortCols</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3410"><span class='Ref_To_Local'>sortlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="nodeAgg.c.html#LN3412"><span class='Ref_To_Local'>numDistinctCols</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN312"><span class='Ref_to_Member'>numSortCols</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN3411"><span class='Ref_To_Local'>numSortCols</span></a><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN316"><span class='Ref_to_Member'>numDistinctCols</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN3412"><span class='Ref_To_Local'>numDistinctCols</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3411"><span class='Ref_To_Local'>numSortCols</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Get a tupledesc and slot corresponding to the aggregated inputs 
         * (including sort expressions) of the agg. 
         */ 
</span>        <a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN355"><span class='Ref_to_Member'>sortdesc</span></a> <span class='Operator'>= </span><a href="../../include/executor/executor.h.html#LN405"><span class='Ref_to_Proto'>ExecTypeFromTL</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3398"><span class='Ref_to_Parameter'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN300"><span class='Ref_to_Member'>args</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN362"><span class='Ref_to_Member'>sortslot</span></a> <span class='Operator'>= </span><a href="../../include/executor/executor.h.html#LN402"><span class='Ref_to_Proto'>ExecInitExtraTupleSlot</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3397"><span class='Ref_to_Parameter'>estate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/executor/tuptable.h.html#LN146"><span class='Ref_to_Proto'>ExecSetSlotDescriptor</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN362"><span class='Ref_to_Member'>sortslot</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN355"><span class='Ref_to_Member'>sortdesc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We don't implement DISTINCT or ORDER BY aggs in the HASHED case 
         * (yet) 
         */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3397"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1745"><span class='Ref_to_Member'>aggstrategy</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/nodes.h.html#LN737"><span class='Ref_to_EnumConst'>AGG_HASHED</span></a> <span class='Operator'>&& </span><a href="nodeAgg.c.html#LN3397"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1745"><span class='Ref_to_Member'>aggstrategy</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/nodes.h.html#LN738"><span class='Ref_to_EnumConst'>AGG_MIXED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* If we have only one input, we need its len/byval info. */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3408"><span class='Ref_To_Local'>numInputs</span></a> <span class='Operator'>== </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../include/utils/lsyscache.h.html#LN135"><span class='Ref_to_Proto'>get_typlenbyval</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3402"><span class='Ref_to_Parameter'>inputTypes</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN3409"><span class='Ref_To_Local'>numDirectArgs</span></a><span class='Delimiter'>], 
</span>                            <span class='Operator'>&</span><a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN344"><span class='Ref_to_Member'>inputtypeLen</span></a><span class='Delimiter'>, 
</span>                            <span class='Operator'>&</span><a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN346"><span class='Ref_to_Member'>inputtypeByVal</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3412"><span class='Ref_To_Local'>numDistinctCols</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* we will need an extra slot to store prior values */ 
</span>            <a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN363"><span class='Ref_to_Member'>uniqslot</span></a> <span class='Operator'>= </span><a href="../../include/executor/executor.h.html#LN402"><span class='Ref_to_Proto'>ExecInitExtraTupleSlot</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3397"><span class='Ref_to_Parameter'>estate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../include/executor/tuptable.h.html#LN146"><span class='Ref_to_Proto'>ExecSetSlotDescriptor</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN363"><span class='Ref_to_Member'>uniqslot</span></a><span class='Delimiter'>, 
</span>                                  <a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN355"><span class='Ref_to_Member'>sortdesc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* Extract the sort information for use later */ 
</span>        <a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN319"><span class='Ref_to_Member'>sortColIdx</span></a> <span class='Operator'>= 
</span>            <span class='Parentheses'>(</span><a href="../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3411"><span class='Ref_To_Local'>numSortCols</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN320"><span class='Ref_to_Member'>sortOperators</span></a> <span class='Operator'>= 
</span>            <span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3411"><span class='Ref_To_Local'>numSortCols</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN321"><span class='Ref_to_Member'>sortCollations</span></a> <span class='Operator'>= 
</span>            <span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3411"><span class='Ref_To_Local'>numSortCols</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN322"><span class='Ref_to_Member'>sortNullsFirst</span></a> <span class='Operator'>= 
</span>            <span class='Parentheses'>(</span><span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3411"><span class='Ref_To_Local'>numSortCols</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>bool</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <a href="nodeAgg.c.html#LN3414"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3407"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN3410"><span class='Ref_To_Local'>sortlist</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN3645"></a>            <a href="../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sortcl</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3407"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN3646"></a>            <a href="../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle</span> <span class='Operator'>= </span><a href="../../include/optimizer/tlist.h.html#LN37"><span class='Ref_to_Proto'>get_sortgroupclause_tle</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3645"><span class='Ref_To_Local'>sortcl</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN3398"><span class='Ref_to_Parameter'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN300"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* the parser should have made sure of this */ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3645"><span class='Ref_To_Local'>sortcl</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1166"><span class='Ref_to_Member'>sortop</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
            <a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN319"><span class='Ref_to_Member'>sortColIdx</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN3414"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="nodeAgg.c.html#LN3646"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1367"><span class='Ref_to_Member'>resno</span></a><span class='Delimiter'>; 
</span>            <a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN320"><span class='Ref_to_Member'>sortOperators</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN3414"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="nodeAgg.c.html#LN3645"><span class='Ref_To_Local'>sortcl</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1166"><span class='Ref_to_Member'>sortop</span></a><span class='Delimiter'>; 
</span>            <a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN321"><span class='Ref_to_Member'>sortCollations</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN3414"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/nodes/nodeFuncs.h.html#LN38"><span class='Ref_to_Proto'>exprCollation</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeAgg.c.html#LN3646"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN322"><span class='Ref_to_Member'>sortNullsFirst</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN3414"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="nodeAgg.c.html#LN3645"><span class='Ref_To_Local'>sortcl</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1167"><span class='Ref_to_Member'>nulls_first</span></a><span class='Delimiter'>; 
</span>            <a href="nodeAgg.c.html#LN3414"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3414"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>== </span><a href="nodeAgg.c.html#LN3411"><span class='Ref_To_Local'>numSortCols</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if numSortCols&GT;0 &raquo; </span> 
 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3398"><span class='Ref_to_Parameter'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN302"><span class='Ref_to_Member'>aggdistinct</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3402"><span class='Ref_to_Parameter'>numArguments</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We need the equal function for each DISTINCT comparison we will 
         * make. 
         */ 
</span>        <a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN329"><span class='Ref_to_Member'>equalfns</span></a> <span class='Operator'>= 
</span>            <span class='Parentheses'>(</span><a href="../../include/fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3412"><span class='Ref_To_Local'>numDistinctCols</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/fmgr.h.html#LN55"><span class='Ref_to_Struct'>FmgrInfo</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <a href="nodeAgg.c.html#LN3414"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3407"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN3398"><span class='Ref_to_Parameter'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN302"><span class='Ref_to_Member'>aggdistinct</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN3674"></a>            <a href="../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sortcl</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3407"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="../../include/fmgr.h.html#LN92"><span class='Ref_to_Proto'>fmgr_info</span></a><span class='Parentheses'>(</span><a href="../../include/utils/lsyscache.h.html#LN98"><span class='Ref_to_Proto'>get_opcode</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3674"><span class='Ref_To_Local'>sortcl</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/parsenodes.h.html#LN1165"><span class='Ref_to_Member'>eqop</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN329"><span class='Ref_to_Member'>equalfns</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN3414"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="nodeAgg.c.html#LN3414"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3414"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>== </span><a href="nodeAgg.c.html#LN3412"><span class='Ref_To_Local'>numDistinctCols</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if aggref-&GT;aggdistinct &raquo; </span> 
 
    <a href="nodeAgg.c.html#LN3396"><span class='Ref_to_Parameter'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN379"><span class='Ref_to_Member'>sortstates</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../utils/sort/tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>**</span><span class='Parentheses'>) 
</span>        <a href="../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../utils/sort/tuplesort.c.html#LN270"><span class='Ref_to_Struct'>Tuplesortstate</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="nodeAgg.c.html#LN3404"><span class='Ref_To_Local'>numGroupingSets</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end build_pertrans_for_aggref &raquo; </span> 
 
 
<span class='Keyword'>static </span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN3688"></a><span class='Declare_Function'>GetAggInitVal</span><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>textInitVal</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>transtype</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3690"></a>    <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>typinput</span><span class='Delimiter'>, 
</span><a name="LN3691"></a>                <span class='Declare_Local'>typioparam</span><span class='Delimiter'>; 
</span><a name="LN3692"></a>    <span class='Keyword'>char</span>       <span class='Operator'>*</span><span class='Declare_Local'>strInitVal</span><span class='Delimiter'>; 
</span><a name="LN3693"></a>    <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>initVal</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/utils/lsyscache.h.html#LN161"><span class='Ref_to_Proto'>getTypeInputInfo</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3688"><span class='Ref_to_Parameter'>transtype</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nodeAgg.c.html#LN3690"><span class='Ref_To_Local'>typinput</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nodeAgg.c.html#LN3691"><span class='Ref_To_Local'>typioparam</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN3692"><span class='Ref_To_Local'>strInitVal</span></a> <span class='Operator'>= </span><a href="../../include/utils/builtins.h.html#LN91"><span class='Ref_to_Macro'>TextDatumGetCString</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3688"><span class='Ref_to_Parameter'>textInitVal</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="nodeAgg.c.html#LN3693"><span class='Ref_To_Local'>initVal</span></a> <span class='Operator'>= </span><a href="../../include/fmgr.h.html#LN644"><span class='Ref_to_Proto'>OidInputFunctionCall</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3690"><span class='Ref_To_Local'>typinput</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN3692"><span class='Ref_To_Local'>strInitVal</span></a><span class='Delimiter'>, 
</span>                                   <a href="nodeAgg.c.html#LN3691"><span class='Ref_To_Local'>typioparam</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3692"><span class='Ref_To_Local'>strInitVal</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="nodeAgg.c.html#LN3693"><span class='Ref_To_Local'>initVal</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * find_compatible_peragg - search for a previously initialized per-Agg struct 
 * 
 * Searches the previously looked at aggregates to find one which is compatible 
 * with this one, with the same input parameters. If no compatible aggregate 
 * can be found, returns -1. 
 * 
 * As a side-effect, this also collects a list of existing per-Trans structs 
 * with matching inputs. If no identical Aggref is found, the list is passed 
 * later to find_compatible_perstate, to see if we can at least reuse the 
 * state value of another aggregate. 
 */ 
</span><span class='Keyword'>static int 
</span><a name="LN3716"></a><span class='Declare_Function'>find_compatible_peragg</span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>newagg</span><span class='Delimiter'>, </span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Delimiter'>, 
</span><a name="LN3717"></a>                       <span class='Keyword'>int </span><span class='Declare_Parameter'>lastaggno</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>same_input_transnos</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3719"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>aggno</span><span class='Delimiter'>; 
</span><a name="LN3720"></a>    <a href="../../include/nodes/execnodes.h.html#LN1733"><span class='Ref_to_Typedef'>AggStatePerAgg</span></a> <span class='Declare_Local'>peraggs</span><span class='Delimiter'>; 
</span> 
    <span class='Operator'>*</span><a href="nodeAgg.c.html#LN3717"><span class='Ref_to_Parameter'>same_input_transnos</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* we mustn't reuse the aggref if it contains volatile function calls */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/optimizer/clauses.h.html#LN60"><span class='Ref_to_Proto'>contain_volatile_functions</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeAgg.c.html#LN3716"><span class='Ref_to_Parameter'>newagg</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
    <a href="nodeAgg.c.html#LN3720"><span class='Ref_To_Local'>peraggs</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN3716"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1750"><span class='Ref_to_Member'>peragg</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Search through the list of already seen aggregates. If we find an 
     * existing aggregate with the same aggregate function and input 
     * parameters as an existing one, then we can re-use that one. While 
     * searching, we'll also collect a list of Aggrefs with the same input 
     * parameters. If no matching Aggref is found, the caller can potentially 
     * still re-use the transition state of one of them. 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3719"><span class='Ref_To_Local'>aggno</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN3719"><span class='Ref_To_Local'>aggno</span></a> <span class='Operator'>&LT;= </span><a href="nodeAgg.c.html#LN3717"><span class='Ref_to_Parameter'>lastaggno</span></a><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN3719"><span class='Ref_To_Local'>aggno</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3740"></a>        <a href="../../include/nodes/execnodes.h.html#LN1733"><span class='Ref_to_Typedef'>AggStatePerAgg</span></a> <span class='Declare_Local'>peragg</span><span class='Delimiter'>; 
</span><a name="LN3741"></a>        <a href="../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>existingRef</span><span class='Delimiter'>; 
</span> 
        <a href="nodeAgg.c.html#LN3740"><span class='Ref_To_Local'>peragg</span></a> <span class='Operator'>= &</span><a href="nodeAgg.c.html#LN3720"><span class='Ref_To_Local'>peraggs</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN3719"><span class='Ref_To_Local'>aggno</span></a><span class='Delimiter'>]; 
</span>        <a href="nodeAgg.c.html#LN3741"><span class='Ref_To_Local'>existingRef</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN3740"><span class='Ref_To_Local'>peragg</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN412"><span class='Ref_to_Member'>aggref</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* all of the following must be the same or it's no match */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3716"><span class='Ref_to_Parameter'>newagg</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN296"><span class='Ref_to_Member'>inputcollid</span></a> <span class='Operator'>!= </span><a href="nodeAgg.c.html#LN3741"><span class='Ref_To_Local'>existingRef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN296"><span class='Ref_to_Member'>inputcollid</span></a> <span class='Operator'>|| 
</span>            <a href="nodeAgg.c.html#LN3716"><span class='Ref_to_Parameter'>newagg</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN297"><span class='Ref_to_Member'>aggtranstype</span></a> <span class='Operator'>!= </span><a href="nodeAgg.c.html#LN3741"><span class='Ref_To_Local'>existingRef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN297"><span class='Ref_to_Member'>aggtranstype</span></a> <span class='Operator'>|| 
</span>            <a href="nodeAgg.c.html#LN3716"><span class='Ref_to_Parameter'>newagg</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN304"><span class='Ref_to_Member'>aggstar</span></a> <span class='Operator'>!= </span><a href="nodeAgg.c.html#LN3741"><span class='Ref_To_Local'>existingRef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN304"><span class='Ref_to_Member'>aggstar</span></a> <span class='Operator'>|| 
</span>            <a href="nodeAgg.c.html#LN3716"><span class='Ref_to_Parameter'>newagg</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN305"><span class='Ref_to_Member'>aggvariadic</span></a> <span class='Operator'>!= </span><a href="nodeAgg.c.html#LN3741"><span class='Ref_To_Local'>existingRef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN305"><span class='Ref_to_Member'>aggvariadic</span></a> <span class='Operator'>|| 
</span>            <a href="nodeAgg.c.html#LN3716"><span class='Ref_to_Parameter'>newagg</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN307"><span class='Ref_to_Member'>aggkind</span></a> <span class='Operator'>!= </span><a href="nodeAgg.c.html#LN3741"><span class='Ref_To_Local'>existingRef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN307"><span class='Ref_to_Member'>aggkind</span></a> <span class='Operator'>|| 
</span>            <span class='Operator'>!</span><a href="../../include/nodes/nodes.h.html#LN626"><span class='Ref_to_Proto'>equal</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3716"><span class='Ref_to_Parameter'>newagg</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN299"><span class='Ref_to_Member'>aggdirectargs</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN3741"><span class='Ref_To_Local'>existingRef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN299"><span class='Ref_to_Member'>aggdirectargs</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>            <span class='Operator'>!</span><a href="../../include/nodes/nodes.h.html#LN626"><span class='Ref_to_Proto'>equal</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3716"><span class='Ref_to_Parameter'>newagg</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN300"><span class='Ref_to_Member'>args</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN3741"><span class='Ref_To_Local'>existingRef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN300"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>            <span class='Operator'>!</span><a href="../../include/nodes/nodes.h.html#LN626"><span class='Ref_to_Proto'>equal</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3716"><span class='Ref_to_Parameter'>newagg</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN301"><span class='Ref_to_Member'>aggorder</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN3741"><span class='Ref_To_Local'>existingRef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN301"><span class='Ref_to_Member'>aggorder</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>            <span class='Operator'>!</span><a href="../../include/nodes/nodes.h.html#LN626"><span class='Ref_to_Proto'>equal</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3716"><span class='Ref_to_Parameter'>newagg</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN302"><span class='Ref_to_Member'>aggdistinct</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN3741"><span class='Ref_To_Local'>existingRef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN302"><span class='Ref_to_Member'>aggdistinct</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>            <span class='Operator'>!</span><a href="../../include/nodes/nodes.h.html#LN626"><span class='Ref_to_Proto'>equal</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3716"><span class='Ref_to_Parameter'>newagg</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN303"><span class='Ref_to_Member'>aggfilter</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN3741"><span class='Ref_To_Local'>existingRef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN303"><span class='Ref_to_Member'>aggfilter</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* if it's the same aggregate function then report exact match */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3716"><span class='Ref_to_Parameter'>newagg</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN293"><span class='Ref_to_Member'>aggfnoid</span></a> <span class='Operator'>== </span><a href="nodeAgg.c.html#LN3741"><span class='Ref_To_Local'>existingRef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN293"><span class='Ref_to_Member'>aggfnoid</span></a> <span class='Operator'>&& 
</span>            <a href="nodeAgg.c.html#LN3716"><span class='Ref_to_Parameter'>newagg</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN294"><span class='Ref_to_Member'>aggtype</span></a> <span class='Operator'>== </span><a href="nodeAgg.c.html#LN3741"><span class='Ref_To_Local'>existingRef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN294"><span class='Ref_to_Member'>aggtype</span></a> <span class='Operator'>&& 
</span>            <a href="nodeAgg.c.html#LN3716"><span class='Ref_to_Parameter'>newagg</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN295"><span class='Ref_to_Member'>aggcollid</span></a> <span class='Operator'>== </span><a href="nodeAgg.c.html#LN3741"><span class='Ref_To_Local'>existingRef</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN295"><span class='Ref_to_Member'>aggcollid</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../include/nodes/pg_list.h.html#LN265"><span class='Ref_to_Proto'>list_free</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="nodeAgg.c.html#LN3717"><span class='Ref_to_Parameter'>same_input_transnos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Operator'>*</span><a href="nodeAgg.c.html#LN3717"><span class='Ref_to_Parameter'>same_input_transnos</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>return</span> <a href="nodeAgg.c.html#LN3719"><span class='Ref_To_Local'>aggno</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Not identical, but it had the same inputs. Return it to the caller, 
         * in case we can re-use its per-trans state. 
         */ 
</span>        <span class='Operator'>*</span><a href="nodeAgg.c.html#LN3717"><span class='Ref_to_Parameter'>same_input_transnos</span></a> <span class='Operator'>= </span><a href="../nodes/list.c.html#LN144"><span class='Ref_to_Func'>lappend_int</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="nodeAgg.c.html#LN3717"><span class='Ref_to_Parameter'>same_input_transnos</span></a><span class='Delimiter'>, 
</span>                                           <a href="nodeAgg.c.html#LN3740"><span class='Ref_To_Local'>peragg</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN415"><span class='Ref_to_Member'>transno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for aggno=0;aggno&LT;=lastag... &raquo; </span> 
 
    <span class='Control'>return</span> <span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end find_compatible_peragg &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * find_compatible_pertrans - search for a previously initialized per-Trans 
 * struct 
 * 
 * Searches the list of transnos for a per-Trans struct with the same 
 * transition state and initial condition. (The inputs have already been 
 * verified to match.) 
 */ 
</span><span class='Keyword'>static int 
</span><a name="LN3789"></a><span class='Declare_Function'>find_compatible_pertrans</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggstate</span><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>newagg</span><span class='Delimiter'>, 
</span><a name="LN3790"></a>                         <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>aggtransfn</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>aggtranstype</span><span class='Delimiter'>, 
</span><a name="LN3791"></a>                         <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>aggserialfn</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>aggdeserialfn</span><span class='Delimiter'>, 
</span><a name="LN3792"></a>                         <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>initValue</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>initValueIsNull</span><span class='Delimiter'>, 
</span><a name="LN3793"></a>                         <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>transnos</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3795"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3795"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN3793"><span class='Ref_to_Parameter'>transnos</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3799"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>transno</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN106"><span class='Ref_to_Macro'>lfirst_int</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3795"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN3800"></a>        <a href="../../include/nodes/execnodes.h.html#LN1734"><span class='Ref_to_Typedef'>AggStatePerTrans</span></a> <span class='Declare_Local'>pertrans</span> <span class='Operator'>= &</span><a href="nodeAgg.c.html#LN3789"><span class='Ref_to_Parameter'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1751"><span class='Ref_to_Member'>pertrans</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN3799"><span class='Ref_To_Local'>transno</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * if the transfns or transition state types are not the same then the 
         * state can't be shared. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3790"><span class='Ref_to_Parameter'>aggtransfn</span></a> <span class='Operator'>!= </span><a href="nodeAgg.c.html#LN3800"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN281"><span class='Ref_to_Member'>transfn_oid</span></a> <span class='Operator'>|| 
</span>            <a href="nodeAgg.c.html#LN3790"><span class='Ref_to_Parameter'>aggtranstype</span></a> <span class='Operator'>!= </span><a href="nodeAgg.c.html#LN3800"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN290"><span class='Ref_to_Member'>aggtranstype</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * The serialization and deserialization functions must match, if 
         * present, as we're unable to share the trans state for aggregates 
         * which will serialize or deserialize into different formats. 
         * Remember that these will be InvalidOid if they're not required for 
         * this agg node. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3791"><span class='Ref_to_Parameter'>aggserialfn</span></a> <span class='Operator'>!= </span><a href="nodeAgg.c.html#LN3800"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN284"><span class='Ref_to_Member'>serialfn_oid</span></a> <span class='Operator'>|| 
</span>            <a href="nodeAgg.c.html#LN3791"><span class='Ref_to_Parameter'>aggdeserialfn</span></a> <span class='Operator'>!= </span><a href="nodeAgg.c.html#LN3800"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN287"><span class='Ref_to_Member'>deserialfn_oid</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Check that the initial condition matches, too. */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3792"><span class='Ref_to_Parameter'>initValueIsNull</span></a> <span class='Operator'>&& </span><a href="nodeAgg.c.html#LN3800"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN335"><span class='Ref_to_Member'>initValueIsNull</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <a href="nodeAgg.c.html#LN3799"><span class='Ref_To_Local'>transno</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="nodeAgg.c.html#LN3792"><span class='Ref_to_Parameter'>initValueIsNull</span></a> <span class='Operator'>&& !</span><a href="nodeAgg.c.html#LN3800"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN335"><span class='Ref_to_Member'>initValueIsNull</span></a> <span class='Operator'>&& 
</span>            <a href="../../include/utils/datum.h.html#LN45"><span class='Ref_to_Proto'>datumIsEqual</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3792"><span class='Ref_to_Parameter'>initValue</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN3800"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN334"><span class='Ref_to_Member'>initValue</span></a><span class='Delimiter'>, 
</span>                         <a href="nodeAgg.c.html#LN3800"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN347"><span class='Ref_to_Member'>transtypeByVal</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN3800"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN345"><span class='Ref_to_Member'>transtypeLen</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>return</span> <a href="nodeAgg.c.html#LN3799"><span class='Ref_To_Local'>transno</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end find_compatible_pertrans &raquo; </span> 
 
<span class='Keyword'>void 
</span><a name="LN3836"></a><span class='Declare_Function'>ExecEndAgg</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3838"></a>    <a href="../../include/nodes/execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>outerPlan</span><span class='Delimiter'>; 
</span><a name="LN3839"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>transno</span><span class='Delimiter'>; 
</span><a name="LN3840"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numGroupingSets</span> <span class='Operator'>= </span><a href="../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN10"><span class='Ref_to_Macro'>Max</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3836"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1765"><span class='Ref_to_Member'>maxsets</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN3841"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>setno</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Make sure we have closed any open tuplesorts */ 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3836"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1767"><span class='Ref_to_Member'>sort_in</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/utils/tuplesort.h.html#LN106"><span class='Ref_to_Proto'>tuplesort_end</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3836"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1767"><span class='Ref_to_Member'>sort_in</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3836"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1768"><span class='Ref_to_Member'>sort_out</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/utils/tuplesort.h.html#LN106"><span class='Ref_to_Proto'>tuplesort_end</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3836"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1768"><span class='Ref_to_Member'>sort_out</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3839"><span class='Ref_To_Local'>transno</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN3839"><span class='Ref_To_Local'>transno</span></a> <span class='Operator'>&LT; </span><a href="nodeAgg.c.html#LN3836"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1744"><span class='Ref_to_Member'>numtrans</span></a><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN3839"><span class='Ref_To_Local'>transno</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3852"></a>        <a href="../../include/nodes/execnodes.h.html#LN1734"><span class='Ref_to_Typedef'>AggStatePerTrans</span></a> <span class='Declare_Local'>pertrans</span> <span class='Operator'>= &</span><a href="nodeAgg.c.html#LN3836"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1751"><span class='Ref_to_Member'>pertrans</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN3839"><span class='Ref_To_Local'>transno</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3841"><span class='Ref_To_Local'>setno</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN3841"><span class='Ref_To_Local'>setno</span></a> <span class='Operator'>&LT; </span><a href="nodeAgg.c.html#LN3840"><span class='Ref_To_Local'>numGroupingSets</span></a><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN3841"><span class='Ref_To_Local'>setno</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3852"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN379"><span class='Ref_to_Member'>sortstates</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN3841"><span class='Ref_To_Local'>setno</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>                <a href="../../include/utils/tuplesort.h.html#LN106"><span class='Ref_to_Proto'>tuplesort_end</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3852"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN379"><span class='Ref_to_Member'>sortstates</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN3841"><span class='Ref_To_Local'>setno</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* And ensure any agg shutdown callbacks have been called */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3841"><span class='Ref_To_Local'>setno</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN3841"><span class='Ref_To_Local'>setno</span></a> <span class='Operator'>&LT; </span><a href="nodeAgg.c.html#LN3840"><span class='Ref_To_Local'>numGroupingSets</span></a><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN3841"><span class='Ref_To_Local'>setno</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <a href="execUtils.c.html#LN374"><span class='Ref_to_Func'>ReScanExprContext</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3836"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1753"><span class='Ref_to_Member'>aggcontexts</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN3841"><span class='Ref_To_Local'>setno</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3836"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1752"><span class='Ref_to_Member'>hashcontext</span></a><span class='Parentheses'>) 
</span>        <a href="execUtils.c.html#LN374"><span class='Ref_to_Func'>ReScanExprContext</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3836"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1752"><span class='Ref_to_Member'>hashcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We don't actually free any ExprContexts here (see comment in 
     * ExecFreeExprContext), just unlinking the output one from the plan node 
     * suffices. 
     */ 
</span>    <a href="../../include/executor/executor.h.html#LN476"><span class='Ref_to_Proto'>ExecFreeExprContext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nodeAgg.c.html#LN3836"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1741"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* clean up tuple table */ 
</span>    <a href="../../include/executor/tuptable.h.html#LN154"><span class='Ref_to_Proto'>ExecClearTuple</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3836"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1741"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1060"><span class='Ref_to_Member'>ss_ScanTupleSlot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="nodeAgg.c.html#LN3838"><span class='Ref_To_Local'>outerPlan</span></a> <span class='Operator'>= </span><a href="../../include/nodes/execnodes.h.html#LN854"><span class='Ref_to_Macro'>outerPlanState</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3836"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/executor/executor.h.html#LN231"><span class='Ref_to_Proto'>ExecEndNode</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3838"><span class='Ref_To_Local'>outerPlan</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ExecEndAgg &raquo; </span> 
 
<span class='Keyword'>void 
</span><a name="LN3882"></a><span class='Declare_Function'>ExecReScanAgg</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3884"></a>    <a href="../../include/nodes/execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Local'>econtext</span> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN3882"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1741"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN842"><span class='Ref_to_Member'>ps_ExprContext</span></a><span class='Delimiter'>; 
</span><a name="LN3885"></a>    <a href="../../include/nodes/execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>outerPlan</span> <span class='Operator'>= </span><a href="../../include/nodes/execnodes.h.html#LN854"><span class='Ref_to_Macro'>outerPlanState</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3882"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN3886"></a>    <a href="../../include/nodes/plannodes.h.html#LN781"><span class='Ref_to_Struct'>Agg</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>aggnode</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/plannodes.h.html#LN781"><span class='Ref_to_Struct'>Agg</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeAgg.c.html#LN3882"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1741"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN812"><span class='Ref_to_Member'>plan</span></a><span class='Delimiter'>; 
</span><a name="LN3887"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>transno</span><span class='Delimiter'>; 
</span><a name="LN3888"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numGroupingSets</span> <span class='Operator'>= </span><a href="../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN10"><span class='Ref_to_Macro'>Max</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3882"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1765"><span class='Ref_to_Member'>maxsets</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN3889"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>setno</span><span class='Delimiter'>; 
</span> 
    <a href="nodeAgg.c.html#LN3882"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1758"><span class='Ref_to_Member'>agg_done</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3882"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1745"><span class='Ref_to_Member'>aggstrategy</span></a> <span class='Operator'>== </span><a href="../../include/nodes/nodes.h.html#LN737"><span class='Ref_to_EnumConst'>AGG_HASHED</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * In the hashed case, if we haven't yet built the hash table then we 
         * can just return; nothing done yet, so nothing to undo. If subnode's 
         * chgParam is not NULL then it will be re-scanned by ExecProcNode, 
         * else no reason to re-scan it at all. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="nodeAgg.c.html#LN3882"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1774"><span class='Ref_to_Member'>table_filled</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If we do have the hash table, and the subplan does not have any 
         * parameter changes, and none of our own parameter changes affect 
         * input expressions of the aggregated functions, then we can just 
         * rescan the existing hash table; no need to build it again. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3885"><span class='Ref_To_Local'>outerPlan</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN836"><span class='Ref_to_Member'>chgParam</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>&& 
</span>            <span class='Operator'>!</span><a href="../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3882"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1741"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN836"><span class='Ref_to_Member'>chgParam</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN3886"><span class='Ref_To_Local'>aggnode</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN790"><span class='Ref_to_Member'>aggParams</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="../../include/nodes/execnodes.h.html#LN608"><span class='Ref_to_Macro'>ResetTupleHashIterator</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3882"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1776"><span class='Ref_to_Member'>perhash</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="nodeAgg.c.html#LN506"><span class='Ref_to_Member'>hashtable</span></a><span class='Delimiter'>, 
</span>                                   <span class='Operator'>&</span><a href="nodeAgg.c.html#LN3882"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1776"><span class='Ref_to_Member'>perhash</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="nodeAgg.c.html#LN507"><span class='Ref_to_Member'>hashiter</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="nodeAgg.c.html#LN520"><span class='Ref_to_Proto'>select_current_set</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3882"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if node-&GT;aggstrategy==AG... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* Make sure we have closed any open tuplesorts */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3887"><span class='Ref_To_Local'>transno</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN3887"><span class='Ref_To_Local'>transno</span></a> <span class='Operator'>&LT; </span><a href="nodeAgg.c.html#LN3882"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1744"><span class='Ref_to_Member'>numtrans</span></a><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN3887"><span class='Ref_To_Local'>transno</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3889"><span class='Ref_To_Local'>setno</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN3889"><span class='Ref_To_Local'>setno</span></a> <span class='Operator'>&LT; </span><a href="nodeAgg.c.html#LN3888"><span class='Ref_To_Local'>numGroupingSets</span></a><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN3889"><span class='Ref_To_Local'>setno</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN3925"></a>            <a href="../../include/nodes/execnodes.h.html#LN1734"><span class='Ref_to_Typedef'>AggStatePerTrans</span></a> <span class='Declare_Local'>pertrans</span> <span class='Operator'>= &</span><a href="nodeAgg.c.html#LN3882"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1751"><span class='Ref_to_Member'>pertrans</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN3887"><span class='Ref_To_Local'>transno</span></a><span class='Delimiter'>]; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3925"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN379"><span class='Ref_to_Member'>sortstates</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN3889"><span class='Ref_To_Local'>setno</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="../../include/utils/tuplesort.h.html#LN106"><span class='Ref_to_Proto'>tuplesort_end</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3925"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN379"><span class='Ref_to_Member'>sortstates</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN3889"><span class='Ref_To_Local'>setno</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="nodeAgg.c.html#LN3925"><span class='Ref_To_Local'>pertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN379"><span class='Ref_to_Member'>sortstates</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN3889"><span class='Ref_To_Local'>setno</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We don't need to ReScanExprContext the output tuple context here; 
     * ExecReScan already did it. But we do need to reset our per-grouping-set 
     * contexts, which may have transvalues stored in them. (We use rescan 
     * rather than just reset because transfns may have registered callbacks 
     * that need to be run now.) For the AGG_HASHED case, see below. 
     */ 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3889"><span class='Ref_To_Local'>setno</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN3889"><span class='Ref_To_Local'>setno</span></a> <span class='Operator'>&LT; </span><a href="nodeAgg.c.html#LN3888"><span class='Ref_To_Local'>numGroupingSets</span></a><span class='Delimiter'>; </span><a href="nodeAgg.c.html#LN3889"><span class='Ref_To_Local'>setno</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="execUtils.c.html#LN374"><span class='Ref_to_Func'>ReScanExprContext</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3882"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1753"><span class='Ref_to_Member'>aggcontexts</span></a><span class='Delimiter'>[</span><a href="nodeAgg.c.html#LN3889"><span class='Ref_To_Local'>setno</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Release first tuple of group, if we have made a copy */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3882"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1772"><span class='Ref_to_Member'>grp_firstTuple</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../include/access/htup_details.h.html#LN815"><span class='Ref_to_Proto'>heap_freetuple</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3882"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1772"><span class='Ref_to_Member'>grp_firstTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="nodeAgg.c.html#LN3882"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1772"><span class='Ref_to_Member'>grp_firstTuple</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="../../include/executor/tuptable.h.html#LN154"><span class='Ref_to_Proto'>ExecClearTuple</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3882"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1741"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1060"><span class='Ref_to_Member'>ss_ScanTupleSlot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Forget current agg values */ 
</span>    <a href="../../include/c.h.html#LN856"><span class='Ref_to_Macro'>MemSet</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3884"><span class='Ref_To_Local'>econtext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN212"><span class='Ref_to_Member'>ecxt_aggvalues</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="nodeAgg.c.html#LN3882"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1743"><span class='Ref_to_Member'>numaggs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/c.h.html#LN856"><span class='Ref_to_Macro'>MemSet</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3884"><span class='Ref_To_Local'>econtext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN213"><span class='Ref_to_Member'>ecxt_aggnulls</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>bool</span><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="nodeAgg.c.html#LN3882"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1743"><span class='Ref_to_Member'>numaggs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * With AGG_HASHED/MIXED, the hash table is allocated in a sub-context of 
     * the hashcontext. This used to be an issue, but now, resetting a context 
     * automatically deletes sub-contexts too. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3882"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1745"><span class='Ref_to_Member'>aggstrategy</span></a> <span class='Operator'>== </span><a href="../../include/nodes/nodes.h.html#LN737"><span class='Ref_to_EnumConst'>AGG_HASHED</span></a> <span class='Operator'>|| </span><a href="nodeAgg.c.html#LN3882"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1745"><span class='Ref_to_Member'>aggstrategy</span></a> <span class='Operator'>== </span><a href="../../include/nodes/nodes.h.html#LN738"><span class='Ref_to_EnumConst'>AGG_MIXED</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="execUtils.c.html#LN374"><span class='Ref_to_Func'>ReScanExprContext</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3882"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1752"><span class='Ref_to_Member'>hashcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* Rebuild an empty hash table */ 
</span>        <a href="nodeRecursiveunion.c.html#LN30"><span class='Ref_to_Func'>build_hash_table</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3882"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="nodeAgg.c.html#LN3882"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1774"><span class='Ref_to_Member'>table_filled</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* iterator will be reset when the table is filled */ 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3882"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1745"><span class='Ref_to_Member'>aggstrategy</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/nodes.h.html#LN737"><span class='Ref_to_EnumConst'>AGG_HASHED</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Reset the per-group state (in particular, mark transvalues null) 
         */ 
</span>        <a href="../../include/c.h.html#LN856"><span class='Ref_to_Macro'>MemSet</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3882"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1771"><span class='Ref_to_Member'>pergroup</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, 
</span>             <span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN459"><span class='Ref_to_Struct'>AggStatePerGroupData</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="nodeAgg.c.html#LN3882"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1743"><span class='Ref_to_Member'>numaggs</span></a> <span class='Operator'>* </span><a href="nodeAgg.c.html#LN3888"><span class='Ref_To_Local'>numGroupingSets</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* reset to phase 1 */ 
</span>        <a href="nodeAgg.c.html#LN521"><span class='Ref_to_Proto'>initialize_phase</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3882"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="nodeAgg.c.html#LN3882"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1757"><span class='Ref_to_Member'>input_done</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <a href="nodeAgg.c.html#LN3882"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1759"><span class='Ref_to_Member'>projected_set</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3885"><span class='Ref_To_Local'>outerPlan</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN836"><span class='Ref_to_Member'>chgParam</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="execAmi.c.html#LN73"><span class='Ref_to_Func'>ExecReScan</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN3885"><span class='Ref_To_Local'>outerPlan</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ExecReScanAgg &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/*********************************************************************** 
 * API exposed to aggregate functions 
 ***********************************************************************/ 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * AggCheckCallContext - test if a SQL function is being called as an aggregate 
 * 
 * The transition and/or final functions of an aggregate may want to verify 
 * that they are being called as aggregates, rather than as plain SQL 
 * functions.  They should use this function to do so.  The return value 
 * is nonzero if being called as an aggregate, or zero if not.  (Specific 
 * nonzero values are AGG_CONTEXT_AGGREGATE or AGG_CONTEXT_WINDOW, but more 
 * values could conceivably appear in future.) 
 * 
 * If aggcontext isn't NULL, the function also stores at *aggcontext the 
 * identity of the memory context that aggregate transition values are being 
 * stored in.  Note that the same aggregate call site (flinfo) may be called 
 * interleaved on different transition values in different contexts, so it's 
 * not kosher to cache aggcontext under fn_extra.  It is, however, kosher to 
 * cache it in the transvalue itself (for internal-type transvalues). 
 */ 
</span><span class='Keyword'>int 
</span><a name="LN4017"></a><span class='Declare_Function'>AggCheckCallContext</span><span class='Parentheses'>(</span><a href="../../include/fmgr.h.html#LN37"><span class='Ref_to_Typedef'>FunctionCallInfo</span></a> <span class='Declare_Parameter'>fcinfo</span><span class='Delimiter'>, </span><a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggcontext</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN4017"><span class='Ref_to_Parameter'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN79"><span class='Ref_to_Member'>context</span></a> <span class='Operator'>&& </span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN4017"><span class='Ref_to_Parameter'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN79"><span class='Ref_to_Member'>context</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN4017"><span class='Ref_to_Parameter'>aggcontext</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN4023"></a>            <a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>aggstate</span> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeAgg.c.html#LN4017"><span class='Ref_to_Parameter'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN79"><span class='Ref_to_Member'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN4024"></a>            <a href="../../include/nodes/execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Local'>cxt</span> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN4023"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1755"><span class='Ref_to_Member'>curaggcontext</span></a><span class='Delimiter'>; 
</span> 
            <span class='Operator'>*</span><a href="nodeAgg.c.html#LN4017"><span class='Ref_to_Parameter'>aggcontext</span></a> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN4024"><span class='Ref_To_Local'>cxt</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN202"><span class='Ref_to_Member'>ecxt_per_tuple_memory</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>return</span> <a href="../../include/fmgr.h.html#LN692"><span class='Ref_to_Const'>AGG_CONTEXT_AGGREGATE</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN4017"><span class='Ref_to_Parameter'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN79"><span class='Ref_to_Member'>context</span></a> <span class='Operator'>&& </span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN4017"><span class='Ref_to_Parameter'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN79"><span class='Ref_to_Member'>context</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/execnodes.h.html#LN1792"><span class='Ref_to_Struct'>WindowAggState</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN4017"><span class='Ref_to_Parameter'>aggcontext</span></a><span class='Parentheses'>) 
</span>            <span class='Operator'>*</span><a href="nodeAgg.c.html#LN4017"><span class='Ref_to_Parameter'>aggcontext</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../include/nodes/execnodes.h.html#LN1792"><span class='Ref_to_Struct'>WindowAggState</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeAgg.c.html#LN4017"><span class='Ref_to_Parameter'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN79"><span class='Ref_to_Member'>context</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>curaggcontext<span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <a href="../../include/fmgr.h.html#LN693"><span class='Ref_to_Const'>AGG_CONTEXT_WINDOW</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* this is just to prevent "uninitialized variable" warnings */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN4017"><span class='Ref_to_Parameter'>aggcontext</span></a><span class='Parentheses'>) 
</span>        <span class='Operator'>*</span><a href="nodeAgg.c.html#LN4017"><span class='Ref_to_Parameter'>aggcontext</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Number'>0</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end AggCheckCallContext &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * AggGetAggref - allow an aggregate support function to get its Aggref 
 * 
 * If the function is being called as an aggregate support function, 
 * return the Aggref node for the aggregate call.  Otherwise, return NULL. 
 * 
 * Note that if an aggregate is being used as a window function, this will 
 * return NULL.  We could provide a similar function to return the relevant 
 * WindowFunc node in such cases, but it's not needed yet. 
 */ 
</span><a href="../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a> <span class='Operator'>* 
</span><a name="LN4054"></a><span class='Declare_Function'>AggGetAggref</span><span class='Parentheses'>(</span><a href="../../include/fmgr.h.html#LN37"><span class='Ref_to_Typedef'>FunctionCallInfo</span></a> <span class='Declare_Parameter'>fcinfo</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN4054"><span class='Ref_to_Parameter'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN79"><span class='Ref_to_Member'>context</span></a> <span class='Operator'>&& </span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN4054"><span class='Ref_to_Parameter'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN79"><span class='Ref_to_Member'>context</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN4058"></a>        <a href="../../include/nodes/execnodes.h.html#LN1734"><span class='Ref_to_Typedef'>AggStatePerTrans</span></a> <span class='Declare_Local'>curpertrans</span><span class='Delimiter'>; 
</span> 
        <a href="nodeAgg.c.html#LN4058"><span class='Ref_To_Local'>curpertrans</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeAgg.c.html#LN4054"><span class='Ref_to_Parameter'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN79"><span class='Ref_to_Member'>context</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>curpertrans<span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN4058"><span class='Ref_To_Local'>curpertrans</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <a href="nodeAgg.c.html#LN4058"><span class='Ref_To_Local'>curpertrans</span></a><span class='Operator'>-&GT;</span><a href="nodeAgg.c.html#LN254"><span class='Ref_to_Member'>aggref</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * AggGetTempMemoryContext - fetch short-term memory context for aggregates 
 * 
 * This is useful in agg final functions; the context returned is one that 
 * the final function can safely reset as desired.  This isn't useful for 
 * transition functions, since the context returned MAY (we don't promise) 
 * be the same as the context those are called in. 
 * 
 * As above, this is currently not useful for aggs called as window functions. 
 */ 
</span><a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> 
<a name="LN4079"></a><span class='Declare_Function'>AggGetTempMemoryContext</span><span class='Parentheses'>(</span><a href="../../include/fmgr.h.html#LN37"><span class='Ref_to_Typedef'>FunctionCallInfo</span></a> <span class='Declare_Parameter'>fcinfo</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN4079"><span class='Ref_to_Parameter'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN79"><span class='Ref_to_Member'>context</span></a> <span class='Operator'>&& </span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN4079"><span class='Ref_to_Parameter'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN79"><span class='Ref_to_Member'>context</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN4083"></a>        <a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>aggstate</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeAgg.c.html#LN4079"><span class='Ref_to_Parameter'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN79"><span class='Ref_to_Member'>context</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>return</span> <a href="nodeAgg.c.html#LN4083"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1754"><span class='Ref_to_Member'>tmpcontext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN202"><span class='Ref_to_Member'>ecxt_per_tuple_memory</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * AggRegisterCallback - register a cleanup callback for an aggregate 
 * 
 * This is useful for aggs to register shutdown callbacks, which will ensure 
 * that non-memory resources are freed.  The callback will occur just before 
 * the associated aggcontext (as returned by AggCheckCallContext) is reset, 
 * either between groups or as a result of rescanning the query.  The callback 
 * will NOT be called on error paths.  The typical use-case is for freeing of 
 * tuplestores or tuplesorts maintained in aggcontext, or pins held by slots 
 * created by the agg functions.  (The callback will not be called until after 
 * the result of the finalfn is no longer needed, so it's safe for the finalfn 
 * to return data that will be freed by the callback.) 
 * 
 * As above, this is currently not useful for aggs called as window functions. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN4106"></a><span class='Declare_Function'>AggRegisterCallback</span><span class='Parentheses'>(</span><a href="../../include/fmgr.h.html#LN37"><span class='Ref_to_Typedef'>FunctionCallInfo</span></a> <span class='Declare_Parameter'>fcinfo</span><span class='Delimiter'>, 
</span><a name="LN4107"></a>                    <a href="../../include/nodes/execnodes.h.html#LN159"><span class='Ref_to_Typedef'>ExprContextCallbackFunction</span></a> <span class='Declare_Parameter'>func</span><span class='Delimiter'>, 
</span><a name="LN4108"></a>                    <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Declare_Parameter'>arg</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN4106"><span class='Ref_to_Parameter'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN79"><span class='Ref_to_Member'>context</span></a> <span class='Operator'>&& </span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN4106"><span class='Ref_to_Parameter'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN79"><span class='Ref_to_Member'>context</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN4112"></a>        <a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>aggstate</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1739"><span class='Ref_to_Struct'>AggState</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeAgg.c.html#LN4106"><span class='Ref_to_Parameter'>fcinfo</span></a><span class='Operator'>-&GT;</span><a href="../../include/fmgr.h.html#LN79"><span class='Ref_to_Member'>context</span></a><span class='Delimiter'>; 
</span><a name="LN4113"></a>        <a href="../../include/nodes/execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Local'>cxt</span> <span class='Operator'>= </span><a href="nodeAgg.c.html#LN4112"><span class='Ref_To_Local'>aggstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1755"><span class='Ref_to_Member'>curaggcontext</span></a><span class='Delimiter'>; 
</span> 
        <a href="../../include/executor/executor.h.html#LN487"><span class='Ref_to_Proto'>RegisterExprContextCallback</span></a><span class='Parentheses'>(</span><a href="nodeAgg.c.html#LN4113"><span class='Ref_To_Local'>cxt</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN4107"><span class='Ref_to_Parameter'>func</span></a><span class='Delimiter'>, </span><a href="nodeAgg.c.html#LN4108"><span class='Ref_to_Parameter'>arg</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"aggregate function cannot register a callback in this context"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * aggregate_dummy - dummy execution routine for aggregate functions 
 * 
 * This function is listed as the implementation (prosrc field) of pg_proc 
 * entries for aggregate functions.  Its only purpose is to throw an error 
 * if someone mistakenly executes such a function in the normal way. 
 * 
 * Perhaps someday we could assign real meaning to the prosrc field of 
 * an aggregate? 
 */ 
</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> 
<a name="LN4134"></a><span class='Declare_Function'>aggregate_dummy</span><span class='Parentheses'>(</span><a href="../../include/fmgr.h.html#LN157"><span class='Ref_to_Const'>PG_FUNCTION_ARGS</span></a><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"aggregate function %u called as normal function"</span><span class='Delimiter'>, 
</span>         fcinfo<span class='Operator'>-&GT;</span>flinfo<span class='Operator'>-&GT;</span>fn_oid<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* keep compiler quiet */ 
</span><span class='Delimiter'>} 
</span></pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>