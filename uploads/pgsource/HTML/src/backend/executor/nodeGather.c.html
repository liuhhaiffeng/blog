<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\executor\nodeGather.c</title>
<LINK REL=StyleSheet HREF="../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\executor\nodeGather.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:39 2017
</td></tr>
<tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * nodeGather.c 
 *    Support routines for scanning a plan via multiple workers. 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * A Gather executor launches parallel workers to run multiple copies of a 
 * plan.  It can also run the plan itself, if the workers are not available 
 * or have not started up yet.  It then merges all of the results it produces 
 * and the results from the workers into a single output stream.  Therefore, 
 * it will normally be used with a plan where running multiple copies of the 
 * same plan does not produce duplicate output, such as parallel-aware 
 * SeqScan. 
 * 
 * Alternatively, a Gather node can be configured to use just one worker 
 * and the single-copy flag can be set.  In this case, the Gather node will 
 * run the plan in one worker and will not execute the plan itself.  In 
 * this case, it simply returns whatever tuples were returned by the worker. 
 * If a worker cannot be obtained, then it will run the plan itself and 
 * return the results.  Therefore, a plan used with a single-copy Gather 
 * node need not be parallel-aware. 
 * 
 * IDENTIFICATION 
 *    src/backend/executor/nodeGather.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span> 
<span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"access/relscan.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/xact.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"executor/execdebug.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"executor/execParallel.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"executor/nodeGather.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"executor/nodeSubplan.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"executor/tqueue.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"miscadmin.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"pgstat.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/memutils.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/rel.h"</span> 
 
 
<a name="LN45"></a><span class='Keyword'>static </span><a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>gather_getnext</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1874"><span class='Ref_to_Struct'>GatherState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>gatherstate</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN46"></a><span class='Keyword'>static </span><a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a> <span class='Declare_Prototype'>gather_readnext</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1874"><span class='Ref_to_Struct'>GatherState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>gatherstate</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN47"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>ExecShutdownGatherWorkers</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1874"><span class='Ref_to_Struct'>GatherState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *      ExecInitGather 
 * ---------------------------------------------------------------- 
 */ 
</span><a href="../../include/nodes/execnodes.h.html#LN1874"><span class='Ref_to_Struct'>GatherState</span></a> <span class='Operator'>* 
</span><a name="LN55"></a><span class='Declare_Function'>ExecInitGather</span><span class='Parentheses'>(</span><a href="../../include/nodes/plannodes.h.html#LN831"><span class='Ref_to_Struct'>Gather</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><a href="../../include/nodes/execnodes.h.html#LN402"><span class='Ref_to_Struct'>EState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>estate</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>eflags</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN57"></a>    <a href="../../include/nodes/execnodes.h.html#LN1874"><span class='Ref_to_Struct'>GatherState</span></a> <span class='Operator'>*</span><span class='Declare_Local'>gatherstate</span><span class='Delimiter'>; 
</span><a name="LN58"></a>    <a href="../../include/nodes/plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>outerNode</span><span class='Delimiter'>; 
</span><a name="LN59"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>hasoid</span><span class='Delimiter'>; 
</span><a name="LN60"></a>    <a href="../../include/access/tupdesc.h.html#LN70"><span class='Ref_to_Typedef'>TupleDesc</span></a>   <span class='Declare_Local'>tupDesc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Gather node doesn't have innerPlan node. */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../include/nodes/plannodes.h.html#LN172"><span class='Ref_to_Macro'>innerPlan</span></a><span class='Parentheses'>(</span><a href="nodeGather.c.html#LN55"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * create state structure 
     */ 
</span>    <a href="nodeGather.c.html#LN57"><span class='Ref_To_Local'>gatherstate</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1874"><span class='Ref_to_Struct'>GatherState</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="nodeGather.c.html#LN57"><span class='Ref_To_Local'>gatherstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1876"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN812"><span class='Ref_to_Member'>plan</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeGather.c.html#LN55"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span>    <a href="nodeGather.c.html#LN57"><span class='Ref_To_Local'>gatherstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1876"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN814"><span class='Ref_to_Member'>state</span></a> <span class='Operator'>= </span><a href="nodeGather.c.html#LN55"><span class='Ref_to_Parameter'>estate</span></a><span class='Delimiter'>; 
</span>    <a href="nodeGather.c.html#LN57"><span class='Ref_To_Local'>gatherstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1884"><span class='Ref_to_Member'>need_to_scan_locally</span></a> <span class='Operator'>= !</span><a href="nodeGather.c.html#LN55"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN835"><span class='Ref_to_Member'>single_copy</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Miscellaneous initialization 
     * 
     * create expression context for node 
     */ 
</span>    <a href="execUtils.c.html#LN416"><span class='Ref_to_Func'>ExecAssignExprContext</span></a><span class='Parentheses'>(</span><a href="nodeGather.c.html#LN55"><span class='Ref_to_Parameter'>estate</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nodeGather.c.html#LN57"><span class='Ref_To_Local'>gatherstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1876"><span class='Ref_to_Member'>ps</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * initialize child expressions 
     */ 
</span>    <a href="nodeGather.c.html#LN57"><span class='Ref_To_Local'>gatherstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1876"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN826"><span class='Ref_to_Member'>qual</span></a> <span class='Operator'>= 
</span>        <a href="execExpr.c.html#LN158"><span class='Ref_to_Func'>ExecInitQual</span></a><span class='Parentheses'>(</span><a href="nodeGather.c.html#LN55"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN833"><span class='Ref_to_Member'>plan</span></a><span class='Operator'>.</span><a href="../../include/nodes/plannodes.h.html#LN144"><span class='Ref_to_Member'>qual</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeGather.c.html#LN57"><span class='Ref_To_Local'>gatherstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * tuple table initialization 
     */ 
</span>    <a href="nodeGather.c.html#LN57"><span class='Ref_To_Local'>gatherstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1883"><span class='Ref_to_Member'>funnel_slot</span></a> <span class='Operator'>= </span><a href="../../include/executor/executor.h.html#LN402"><span class='Ref_to_Proto'>ExecInitExtraTupleSlot</span></a><span class='Parentheses'>(</span><a href="nodeGather.c.html#LN55"><span class='Ref_to_Parameter'>estate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/executor/executor.h.html#LN400"><span class='Ref_to_Proto'>ExecInitResultTupleSlot</span></a><span class='Parentheses'>(</span><a href="nodeGather.c.html#LN55"><span class='Ref_to_Parameter'>estate</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nodeGather.c.html#LN57"><span class='Ref_To_Local'>gatherstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1876"><span class='Ref_to_Member'>ps</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * now initialize outer plan 
     */ 
</span>    <a href="nodeGather.c.html#LN58"><span class='Ref_To_Local'>outerNode</span></a> <span class='Operator'>= </span><a href="../../include/nodes/plannodes.h.html#LN173"><span class='Ref_to_Macro'>outerPlan</span></a><span class='Parentheses'>(</span><a href="nodeGather.c.html#LN55"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/nodes/execnodes.h.html#LN854"><span class='Ref_to_Macro'>outerPlanState</span></a><span class='Parentheses'>(</span><a href="nodeGather.c.html#LN57"><span class='Ref_To_Local'>gatherstate</span></a><span class='Parentheses'>) </span><span class='Operator'>= </span><a href="execProcnode.c.html#LN138"><span class='Ref_to_Func'>ExecInitNode</span></a><span class='Parentheses'>(</span><a href="nodeGather.c.html#LN58"><span class='Ref_To_Local'>outerNode</span></a><span class='Delimiter'>, </span><a href="nodeGather.c.html#LN55"><span class='Ref_to_Parameter'>estate</span></a><span class='Delimiter'>, </span><a href="nodeGather.c.html#LN55"><span class='Ref_to_Parameter'>eflags</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Initialize result tuple type and projection info. 
     */ 
</span>    <a href="execUtils.c.html#LN438"><span class='Ref_to_Func'>ExecAssignResultTypeFromTL</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nodeGather.c.html#LN57"><span class='Ref_To_Local'>gatherstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1876"><span class='Ref_to_Member'>ps</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/executor/executor.h.html#LN474"><span class='Ref_to_Proto'>ExecAssignProjectionInfo</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nodeGather.c.html#LN57"><span class='Ref_To_Local'>gatherstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1876"><span class='Ref_to_Member'>ps</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Initialize funnel slot to same tuple descriptor as outer plan. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/executor/executor.h.html#LN187"><span class='Ref_to_Proto'>ExecContextForcesOids</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nodeGather.c.html#LN57"><span class='Ref_To_Local'>gatherstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1876"><span class='Ref_to_Member'>ps</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nodeGather.c.html#LN59"><span class='Ref_To_Local'>hasoid</span></a><span class='Parentheses'>))</span> 
        <a href="nodeGather.c.html#LN59"><span class='Ref_To_Local'>hasoid</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="nodeGather.c.html#LN60"><span class='Ref_To_Local'>tupDesc</span></a> <span class='Operator'>= </span><a href="../../include/executor/executor.h.html#LN405"><span class='Ref_to_Proto'>ExecTypeFromTL</span></a><span class='Parentheses'>(</span><a href="nodeGather.c.html#LN58"><span class='Ref_To_Local'>outerNode</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN143"><span class='Ref_to_Member'>targetlist</span></a><span class='Delimiter'>, </span><a href="nodeGather.c.html#LN59"><span class='Ref_To_Local'>hasoid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/executor/tuptable.h.html#LN146"><span class='Ref_to_Proto'>ExecSetSlotDescriptor</span></a><span class='Parentheses'>(</span><a href="nodeGather.c.html#LN57"><span class='Ref_To_Local'>gatherstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1883"><span class='Ref_to_Member'>funnel_slot</span></a><span class='Delimiter'>, </span><a href="nodeGather.c.html#LN60"><span class='Ref_To_Local'>tupDesc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="nodeGather.c.html#LN57"><span class='Ref_To_Local'>gatherstate</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ExecInitGather &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *      ExecGather(node) 
 * 
 *      Scans the relation via multiple workers and returns 
 *      the next qualifying tuple. 
 * ---------------------------------------------------------------- 
 */ 
</span><a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>* 
</span><a name="LN123"></a><span class='Declare_Function'>ExecGather</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1874"><span class='Ref_to_Struct'>GatherState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN125"></a>    <a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Local'>fslot</span> <span class='Operator'>= </span><a href="nodeGather.c.html#LN123"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1883"><span class='Ref_to_Member'>funnel_slot</span></a><span class='Delimiter'>; 
</span><a name="LN126"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN127"></a>    <a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Local'>slot</span><span class='Delimiter'>; 
</span><a name="LN128"></a>    <a href="../../include/nodes/execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Local'>econtext</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Initialize the parallel context and workers on first execution. We do 
     * this on first execution rather than during node initialization, as it 
     * needs to allocate a large dynamic segment, so it is better to do it 
     * only if it is really needed. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="nodeGather.c.html#LN123"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1877"><span class='Ref_to_Member'>initialized</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN138"></a>        <a href="../../include/nodes/execnodes.h.html#LN402"><span class='Ref_to_Struct'>EState</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>estate</span> <span class='Operator'>= </span><a href="nodeGather.c.html#LN123"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1876"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN814"><span class='Ref_to_Member'>state</span></a><span class='Delimiter'>; 
</span><a name="LN139"></a>        <a href="../../include/nodes/plannodes.h.html#LN831"><span class='Ref_to_Struct'>Gather</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>gather</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/plannodes.h.html#LN831"><span class='Ref_to_Struct'>Gather</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeGather.c.html#LN123"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1876"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN812"><span class='Ref_to_Member'>plan</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Sometimes we might have to run without parallelism; but if parallel 
         * mode is active then we can try to fire up some workers. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeGather.c.html#LN139"><span class='Ref_To_Local'>gather</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN834"><span class='Ref_to_Member'>num_workers</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="../../include/access/xact.h.html#LN405"><span class='Ref_to_Proto'>IsInParallelMode</span></a><span class='Parentheses'>())</span> 
        <span class='Delimiter'>{ 
</span><a name="LN147"></a>            <a href="../../include/access/parallel.h.html#LN31"><span class='Ref_to_Struct'>ParallelContext</span></a> <span class='Operator'>*</span><span class='Declare_Local'>pcxt</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Initialize the workers required to execute Gather node. */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="nodeGather.c.html#LN123"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1878"><span class='Ref_to_Member'>pei</span></a><span class='Parentheses'>) 
</span>                <a href="nodeGather.c.html#LN123"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1878"><span class='Ref_to_Member'>pei</span></a> <span class='Operator'>= </span><a href="../../include/executor/execParallel.h.html#LN34"><span class='Ref_to_Proto'>ExecInitParallelPlan</span></a><span class='Parentheses'>(</span><a href="nodeGather.c.html#LN123"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1876"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN827"><span class='Ref_to_Member'>lefttree</span></a><span class='Delimiter'>, 
</span>                                                 <a href="nodeGather.c.html#LN138"><span class='Ref_To_Local'>estate</span></a><span class='Delimiter'>, 
</span>                                                 <a href="nodeGather.c.html#LN139"><span class='Ref_To_Local'>gather</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN834"><span class='Ref_to_Member'>num_workers</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Register backend workers. We might not get as many as we 
             * requested, or indeed any at all. 
             */ 
</span>            <a href="nodeGather.c.html#LN147"><span class='Ref_To_Local'>pcxt</span></a> <span class='Operator'>= </span><a href="nodeGather.c.html#LN123"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1878"><span class='Ref_to_Member'>pei</span></a><span class='Operator'>-&GT;</span><a href="../../include/executor/execParallel.h.html#LN26"><span class='Ref_to_Member'>pcxt</span></a><span class='Delimiter'>; 
</span>            <a href="../../include/access/parallel.h.html#LN56"><span class='Ref_to_Proto'>LaunchParallelWorkers</span></a><span class='Parentheses'>(</span><a href="nodeGather.c.html#LN147"><span class='Ref_To_Local'>pcxt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="nodeGather.c.html#LN123"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1881"><span class='Ref_to_Member'>nworkers_launched</span></a> <span class='Operator'>= </span><a href="nodeGather.c.html#LN147"><span class='Ref_To_Local'>pcxt</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/parallel.h.html#LN36"><span class='Ref_to_Member'>nworkers_launched</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Set up tuple queue readers to read the results. */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeGather.c.html#LN147"><span class='Ref_To_Local'>pcxt</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/parallel.h.html#LN36"><span class='Ref_to_Member'>nworkers_launched</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="nodeGather.c.html#LN123"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1879"><span class='Ref_to_Member'>nreaders</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>                <a href="nodeGather.c.html#LN123"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1880"><span class='Ref_to_Member'>nextreader</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>                <a href="nodeGather.c.html#LN123"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1882"><span class='Ref_to_Member'>reader</span></a> <span class='Operator'>= 
</span>                    <a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="nodeGather.c.html#LN147"><span class='Ref_To_Local'>pcxt</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/parallel.h.html#LN36"><span class='Ref_to_Member'>nworkers_launched</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="tqueue.c.html#LN167"><span class='Ref_to_Struct'>TupleQueueReader</span></a> <span class='Operator'>*</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nodeGather.c.html#LN126"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nodeGather.c.html#LN126"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="nodeGather.c.html#LN147"><span class='Ref_To_Local'>pcxt</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/parallel.h.html#LN36"><span class='Ref_to_Member'>nworkers_launched</span></a><span class='Delimiter'>; </span><span class='Operator'>++</span><a href="nodeGather.c.html#LN126"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <a href="../../include/storage/shm_mq.h.html#LN62"><span class='Ref_to_Proto'>shm_mq_set_handle</span></a><span class='Parentheses'>(</span><a href="nodeGather.c.html#LN123"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1878"><span class='Ref_to_Member'>pei</span></a><span class='Operator'>-&GT;</span><a href="../../include/executor/execParallel.h.html#LN29"><span class='Ref_to_Member'>tqueue</span></a><span class='Delimiter'>[</span><a href="nodeGather.c.html#LN126"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], 
</span>                                      <a href="nodeGather.c.html#LN147"><span class='Ref_To_Local'>pcxt</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/parallel.h.html#LN44"><span class='Ref_to_Member'>worker</span></a><span class='Delimiter'>[</span><a href="nodeGather.c.html#LN126"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../include/access/parallel.h.html#LN26"><span class='Ref_to_Member'>bgwhandle</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="nodeGather.c.html#LN123"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1882"><span class='Ref_to_Member'>reader</span></a><span class='Delimiter'>[</span><a href="nodeGather.c.html#LN123"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1879"><span class='Ref_to_Member'>nreaders</span></a><span class='Operator'>++</span><span class='Delimiter'>] </span><span class='Operator'>= 
</span>                        <a href="../../include/executor/tqueue.h.html#LN26"><span class='Ref_to_Proto'>CreateTupleQueueReader</span></a><span class='Parentheses'>(</span><a href="nodeGather.c.html#LN123"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1878"><span class='Ref_to_Member'>pei</span></a><span class='Operator'>-&GT;</span><a href="../../include/executor/execParallel.h.html#LN29"><span class='Ref_to_Member'>tqueue</span></a><span class='Delimiter'>[</span><a href="nodeGather.c.html#LN126"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], 
</span>                                               <a href="nodeGather.c.html#LN125"><span class='Ref_To_Local'>fslot</span></a><span class='Operator'>-&GT;</span><a href="../../include/executor/tuptable.h.html#LN120"><span class='Ref_to_Member'>tts_tupleDescriptor</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* No workers?  Then never mind. */ 
</span>                <a href="nodeGather.c.html#LN47"><span class='Ref_to_Proto'>ExecShutdownGatherWorkers</span></a><span class='Parentheses'>(</span><a href="nodeGather.c.html#LN123"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if gather-&GT;num_workers&GT;0... &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* Run plan locally if no workers or not single-copy. */ 
</span>        <a href="nodeGather.c.html#LN123"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1884"><span class='Ref_to_Member'>need_to_scan_locally</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="nodeGather.c.html#LN123"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1882"><span class='Ref_to_Member'>reader</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <span class='Operator'>|| !</span><a href="nodeGather.c.html#LN139"><span class='Ref_To_Local'>gather</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN835"><span class='Ref_to_Member'>single_copy</span></a><span class='Delimiter'>; 
</span>        <a href="nodeGather.c.html#LN123"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1877"><span class='Ref_to_Member'>initialized</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !node-&GT;initialized &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Reset per-tuple memory context to free any expression evaluation 
     * storage allocated in the previous tuple cycle.  This will also clear 
     * any previous tuple returned by a TupleQueueReader; to make sure we 
     * don't leave a dangling pointer around, clear the working slot first. 
     */ 
</span>    <a href="../../include/executor/tuptable.h.html#LN154"><span class='Ref_to_Proto'>ExecClearTuple</span></a><span class='Parentheses'>(</span><a href="nodeGather.c.html#LN125"><span class='Ref_To_Local'>fslot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="nodeGather.c.html#LN128"><span class='Ref_To_Local'>econtext</span></a> <span class='Operator'>= </span><a href="nodeGather.c.html#LN123"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1876"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN842"><span class='Ref_to_Member'>ps_ExprContext</span></a><span class='Delimiter'>; 
</span>    <a href="../../include/executor/executor.h.html#LN449"><span class='Ref_to_Macro'>ResetExprContext</span></a><span class='Parentheses'>(</span><a href="nodeGather.c.html#LN128"><span class='Ref_To_Local'>econtext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Get next tuple, either from one of our workers, or by running the plan 
     * ourselves. 
     */ 
</span>    <a href="nodeGather.c.html#LN127"><span class='Ref_To_Local'>slot</span></a> <span class='Operator'>= </span><a href="nodeGather.c.html#LN45"><span class='Ref_to_Proto'>gather_getnext</span></a><span class='Parentheses'>(</span><a href="nodeGather.c.html#LN123"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/executor/tuptable.h.html#LN137"><span class='Ref_to_Macro'>TupIsNull</span></a><span class='Parentheses'>(</span><a href="nodeGather.c.html#LN127"><span class='Ref_To_Local'>slot</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Form the result tuple using ExecProject(), and return it. 
     */ 
</span>    <a href="nodeGather.c.html#LN128"><span class='Ref_To_Local'>econtext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN198"><span class='Ref_to_Member'>ecxt_outertuple</span></a> <span class='Operator'>= </span><a href="nodeGather.c.html#LN127"><span class='Ref_To_Local'>slot</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="../../include/executor/executor.h.html#LN307"><span class='Ref_to_Func'>ExecProject</span></a><span class='Parentheses'>(</span><a href="nodeGather.c.html#LN123"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1876"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN843"><span class='Ref_to_Member'>ps_ProjInfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ExecGather &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *      ExecEndGather 
 * 
 *      frees any storage allocated through C routines. 
 * ---------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN225"></a><span class='Declare_Function'>ExecEndGather</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1874"><span class='Ref_to_Struct'>GatherState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../include/executor/executor.h.html#LN231"><span class='Ref_to_Proto'>ExecEndNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN854"><span class='Ref_to_Macro'>outerPlanState</span></a><span class='Parentheses'>(</span><a href="nodeGather.c.html#LN225"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>))</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* let children clean up first */ 
</span>    <a href="../../include/executor/nodeGather.h.html#LN21"><span class='Ref_to_Proto'>ExecShutdownGather</span></a><span class='Parentheses'>(</span><a href="nodeGather.c.html#LN225"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/executor/executor.h.html#LN476"><span class='Ref_to_Proto'>ExecFreeExprContext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nodeGather.c.html#LN225"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1876"><span class='Ref_to_Member'>ps</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/executor/tuptable.h.html#LN154"><span class='Ref_to_Proto'>ExecClearTuple</span></a><span class='Parentheses'>(</span><a href="nodeGather.c.html#LN225"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1876"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN841"><span class='Ref_to_Member'>ps_ResultTupleSlot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Read the next tuple.  We might fetch a tuple from one of the tuple queues 
 * using gather_readnext, or if no tuple queue contains a tuple and the 
 * single_copy flag is not set, we might generate one locally instead. 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>* 
</span><a name="LN239"></a><span class='Declare_Function'>gather_getnext</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1874"><span class='Ref_to_Struct'>GatherState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>gatherstate</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN241"></a>    <a href="../../include/nodes/execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>outerPlan</span> <span class='Operator'>= </span><a href="../../include/nodes/execnodes.h.html#LN854"><span class='Ref_to_Macro'>outerPlanState</span></a><span class='Parentheses'>(</span><a href="nodeGather.c.html#LN239"><span class='Ref_to_Parameter'>gatherstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN242"></a>    <a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Local'>outerTupleSlot</span><span class='Delimiter'>; 
</span><a name="LN243"></a>    <a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Local'>fslot</span> <span class='Operator'>= </span><a href="nodeGather.c.html#LN239"><span class='Ref_to_Parameter'>gatherstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1883"><span class='Ref_to_Member'>funnel_slot</span></a><span class='Delimiter'>; 
</span><a name="LN244"></a>    <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>tupleContext</span> <span class='Operator'>= </span><a href="nodeGather.c.html#LN239"><span class='Ref_to_Parameter'>gatherstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1876"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN842"><span class='Ref_to_Member'>ps_ExprContext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN202"><span class='Ref_to_Member'>ecxt_per_tuple_memory</span></a><span class='Delimiter'>; 
</span><a name="LN245"></a>    <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>tup</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="nodeGather.c.html#LN239"><span class='Ref_to_Parameter'>gatherstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1882"><span class='Ref_to_Member'>reader</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL </span><span class='Operator'>|| </span><a href="nodeGather.c.html#LN239"><span class='Ref_to_Parameter'>gatherstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1884"><span class='Ref_to_Member'>need_to_scan_locally</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeGather.c.html#LN239"><span class='Ref_to_Parameter'>gatherstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1882"><span class='Ref_to_Member'>reader</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN251"></a>            <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldContext</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Run TupleQueueReaders in per-tuple context */ 
</span>            <a href="nodeGather.c.html#LN251"><span class='Ref_To_Local'>oldContext</span></a> <span class='Operator'>= </span><a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="nodeGather.c.html#LN244"><span class='Ref_To_Local'>tupleContext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="nodeGather.c.html#LN245"><span class='Ref_To_Local'>tup</span></a> <span class='Operator'>= </span><a href="nodeGather.c.html#LN46"><span class='Ref_to_Proto'>gather_readnext</span></a><span class='Parentheses'>(</span><a href="nodeGather.c.html#LN239"><span class='Ref_to_Parameter'>gatherstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="nodeGather.c.html#LN251"><span class='Ref_To_Local'>oldContext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="nodeGather.c.html#LN245"><span class='Ref_To_Local'>tup</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <a href="../../include/executor/tuptable.h.html#LN147"><span class='Ref_to_Proto'>ExecStoreTuple</span></a><span class='Parentheses'>(</span><a href="nodeGather.c.html#LN245"><span class='Ref_To_Local'>tup</span></a><span class='Delimiter'>,</span>     <span class='Comment_Single_Line'>/* tuple to store */ 
</span>                               <a href="nodeGather.c.html#LN243"><span class='Ref_To_Local'>fslot</span></a><span class='Delimiter'>,</span>   <span class='Comment_Single_Line'>/* slot in which to store the tuple */ 
</span>                               <a href="../../include/storage/buf.h.html#LN24"><span class='Ref_to_Const'>InvalidBuffer</span></a><span class='Delimiter'>,</span>   <span class='Comment_Multi_Line'>/* buffer associated with this 
                                                 * tuple */ 
</span>                               <span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* slot should not pfree tuple */ 
</span>                <span class='Control'>return</span> <a href="nodeGather.c.html#LN243"><span class='Ref_To_Local'>fslot</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeGather.c.html#LN239"><span class='Ref_to_Parameter'>gatherstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1884"><span class='Ref_to_Member'>need_to_scan_locally</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="nodeGather.c.html#LN242"><span class='Ref_To_Local'>outerTupleSlot</span></a> <span class='Operator'>= </span><a href="../../include/executor/executor.h.html#LN229"><span class='Ref_to_Proto'>ExecProcNode</span></a><span class='Parentheses'>(</span><a href="nodeGather.c.html#LN241"><span class='Ref_To_Local'>outerPlan</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/executor/tuptable.h.html#LN137"><span class='Ref_to_Macro'>TupIsNull</span></a><span class='Parentheses'>(</span><a href="nodeGather.c.html#LN242"><span class='Ref_To_Local'>outerTupleSlot</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>return</span> <a href="nodeGather.c.html#LN242"><span class='Ref_To_Local'>outerTupleSlot</span></a><span class='Delimiter'>; 
</span> 
            <a href="nodeGather.c.html#LN239"><span class='Ref_to_Parameter'>gatherstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1884"><span class='Ref_to_Member'>need_to_scan_locally</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while gatherstate-&GT;reader!=... &raquo; </span> 
 
    <span class='Control'>return</span> <a href="../../include/executor/tuptable.h.html#LN154"><span class='Ref_to_Proto'>ExecClearTuple</span></a><span class='Parentheses'>(</span><a href="nodeGather.c.html#LN243"><span class='Ref_To_Local'>fslot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end gather_getnext &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Attempt to read a tuple from one of our parallel workers. 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a> 
<a name="LN287"></a><span class='Declare_Function'>gather_readnext</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1874"><span class='Ref_to_Struct'>GatherState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>gatherstate</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN289"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>nvisited</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>;;</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN293"></a>        <a href="tqueue.c.html#LN167"><span class='Ref_to_Struct'>TupleQueueReader</span></a> <span class='Operator'>*</span><span class='Declare_Local'>reader</span><span class='Delimiter'>; 
</span><a name="LN294"></a>        <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>tup</span><span class='Delimiter'>; 
</span><a name="LN295"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>readerdone</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Check for async events, particularly messages from workers. */ 
</span>        <a href="../../include/miscadmin.h.html#LN99"><span class='Ref_to_Macro'>CHECK_FOR_INTERRUPTS</span></a><span class='Parentheses'>()</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Attempt to read a tuple, but don't block if none is available. */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nodeGather.c.html#LN287"><span class='Ref_to_Parameter'>gatherstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1880"><span class='Ref_to_Member'>nextreader</span></a> <span class='Operator'>&LT; </span><a href="nodeGather.c.html#LN287"><span class='Ref_to_Parameter'>gatherstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1879"><span class='Ref_to_Member'>nreaders</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="nodeGather.c.html#LN293"><span class='Ref_To_Local'>reader</span></a> <span class='Operator'>= </span><a href="nodeGather.c.html#LN287"><span class='Ref_to_Parameter'>gatherstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1882"><span class='Ref_to_Member'>reader</span></a><span class='Delimiter'>[</span><a href="nodeGather.c.html#LN287"><span class='Ref_to_Parameter'>gatherstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1880"><span class='Ref_to_Member'>nextreader</span></a><span class='Delimiter'>]; 
</span>        <a href="nodeGather.c.html#LN294"><span class='Ref_To_Local'>tup</span></a> <span class='Operator'>= </span><a href="../../include/executor/tqueue.h.html#LN29"><span class='Ref_to_Proto'>TupleQueueReaderNext</span></a><span class='Parentheses'>(</span><a href="nodeGather.c.html#LN293"><span class='Ref_To_Local'>reader</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nodeGather.c.html#LN295"><span class='Ref_To_Local'>readerdone</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If this reader is done, remove it.  If all readers are done, clean 
         * up remaining worker state. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeGather.c.html#LN295"><span class='Ref_To_Local'>readerdone</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="nodeGather.c.html#LN294"><span class='Ref_To_Local'>tup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../include/executor/tqueue.h.html#LN28"><span class='Ref_to_Proto'>DestroyTupleQueueReader</span></a><span class='Parentheses'>(</span><a href="nodeGather.c.html#LN293"><span class='Ref_To_Local'>reader</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Operator'>--</span><a href="nodeGather.c.html#LN287"><span class='Ref_to_Parameter'>gatherstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1879"><span class='Ref_to_Member'>nreaders</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeGather.c.html#LN287"><span class='Ref_to_Parameter'>gatherstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1879"><span class='Ref_to_Member'>nreaders</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="nodeGather.c.html#LN47"><span class='Ref_to_Proto'>ExecShutdownGatherWorkers</span></a><span class='Parentheses'>(</span><a href="nodeGather.c.html#LN287"><span class='Ref_to_Parameter'>gatherstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <a href="../../include/c.h.html#LN1057"><span class='Ref_to_Macro'>memmove</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nodeGather.c.html#LN287"><span class='Ref_to_Parameter'>gatherstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1882"><span class='Ref_to_Member'>reader</span></a><span class='Delimiter'>[</span><a href="nodeGather.c.html#LN287"><span class='Ref_to_Parameter'>gatherstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1880"><span class='Ref_to_Member'>nextreader</span></a><span class='Delimiter'>], 
</span>                    <span class='Operator'>&</span><a href="nodeGather.c.html#LN287"><span class='Ref_to_Parameter'>gatherstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1882"><span class='Ref_to_Member'>reader</span></a><span class='Delimiter'>[</span><a href="nodeGather.c.html#LN287"><span class='Ref_to_Parameter'>gatherstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1880"><span class='Ref_to_Member'>nextreader</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>], 
</span>                    <span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="tqueue.c.html#LN167"><span class='Ref_to_Struct'>TupleQueueReader</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>                    <span class='Operator'>* </span><span class='Parentheses'>(</span><a href="nodeGather.c.html#LN287"><span class='Ref_to_Parameter'>gatherstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1879"><span class='Ref_to_Member'>nreaders</span></a> <span class='Operator'>- </span><a href="nodeGather.c.html#LN287"><span class='Ref_to_Parameter'>gatherstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1880"><span class='Ref_to_Member'>nextreader</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeGather.c.html#LN287"><span class='Ref_to_Parameter'>gatherstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1880"><span class='Ref_to_Member'>nextreader</span></a> <span class='Operator'>&GT;= </span><a href="nodeGather.c.html#LN287"><span class='Ref_to_Parameter'>gatherstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1879"><span class='Ref_to_Member'>nreaders</span></a><span class='Parentheses'>) 
</span>                <a href="nodeGather.c.html#LN287"><span class='Ref_to_Parameter'>gatherstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1880"><span class='Ref_to_Member'>nextreader</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* If we got a tuple, return it. */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeGather.c.html#LN294"><span class='Ref_To_Local'>tup</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <a href="nodeGather.c.html#LN294"><span class='Ref_To_Local'>tup</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Advance nextreader pointer in round-robin fashion.  Note that we 
         * only reach this code if we weren't able to get a tuple from the 
         * current worker.  We used to advance the nextreader pointer after 
         * every tuple, but it turns out to be much more efficient to keep 
         * reading from the same queue until that would require blocking. 
         */ 
</span>        <a href="nodeGather.c.html#LN287"><span class='Ref_to_Parameter'>gatherstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1880"><span class='Ref_to_Member'>nextreader</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeGather.c.html#LN287"><span class='Ref_to_Parameter'>gatherstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1880"><span class='Ref_to_Member'>nextreader</span></a> <span class='Operator'>&GT;= </span><a href="nodeGather.c.html#LN287"><span class='Ref_to_Parameter'>gatherstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1879"><span class='Ref_to_Member'>nreaders</span></a><span class='Parentheses'>) 
</span>            <a href="nodeGather.c.html#LN287"><span class='Ref_to_Parameter'>gatherstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1880"><span class='Ref_to_Member'>nextreader</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Have we visited every (surviving) TupleQueueReader? */ 
</span>        <a href="nodeGather.c.html#LN289"><span class='Ref_To_Local'>nvisited</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeGather.c.html#LN289"><span class='Ref_To_Local'>nvisited</span></a> <span class='Operator'>&GT;= </span><a href="nodeGather.c.html#LN287"><span class='Ref_to_Parameter'>gatherstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1879"><span class='Ref_to_Member'>nreaders</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * If (still) running plan locally, return NULL so caller can 
             * generate another tuple from the local copy of the plan. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeGather.c.html#LN287"><span class='Ref_to_Parameter'>gatherstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1884"><span class='Ref_to_Member'>need_to_scan_locally</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Nothing to do except wait for developments. */ 
</span>            <a href="../../include/storage/latch.h.html#LN163"><span class='Ref_to_Proto'>WaitLatch</span></a><span class='Parentheses'>(</span><a href="../utils/init/globals.c.html#LN51"><span class='Ref_to_Global_Var'>MyLatch</span></a><span class='Delimiter'>, </span><a href="../../include/storage/latch.h.html#LN123"><span class='Ref_to_Const'>WL_LATCH_SET</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><a href="../../include/pgstat.h.html#LN803"><span class='Ref_to_EnumConst'>WAIT_EVENT_EXECUTE_GATHER</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../include/storage/latch.h.html#LN152"><span class='Ref_to_Proto'>ResetLatch</span></a><span class='Parentheses'>(</span><a href="../utils/init/globals.c.html#LN51"><span class='Ref_to_Global_Var'>MyLatch</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="nodeGather.c.html#LN289"><span class='Ref_To_Local'>nvisited</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for ;; &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end gather_readnext &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *      ExecShutdownGatherWorkers 
 * 
 *      Destroy the parallel workers.  Collect all the stats after 
 *      workers are stopped, else some work done by workers won't be 
 *      accounted. 
 * ---------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN371"></a><span class='Declare_Function'>ExecShutdownGatherWorkers</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1874"><span class='Ref_to_Struct'>GatherState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* Shut down tuple queue readers before shutting down workers. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeGather.c.html#LN371"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1882"><span class='Ref_to_Member'>reader</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN376"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nodeGather.c.html#LN376"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nodeGather.c.html#LN376"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="nodeGather.c.html#LN371"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1879"><span class='Ref_to_Member'>nreaders</span></a><span class='Delimiter'>; </span><span class='Operator'>++</span><a href="nodeGather.c.html#LN376"><span class='Ref_To_Local'>i</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/executor/tqueue.h.html#LN28"><span class='Ref_to_Proto'>DestroyTupleQueueReader</span></a><span class='Parentheses'>(</span><a href="nodeGather.c.html#LN371"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1882"><span class='Ref_to_Member'>reader</span></a><span class='Delimiter'>[</span><a href="nodeGather.c.html#LN376"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="nodeGather.c.html#LN371"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1882"><span class='Ref_to_Member'>reader</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="nodeGather.c.html#LN371"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1882"><span class='Ref_to_Member'>reader</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Now shut down the workers. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeGather.c.html#LN371"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1878"><span class='Ref_to_Member'>pei</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="../../include/executor/execParallel.h.html#LN36"><span class='Ref_to_Proto'>ExecParallelFinish</span></a><span class='Parentheses'>(</span><a href="nodeGather.c.html#LN371"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1878"><span class='Ref_to_Member'>pei</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *      ExecShutdownGather 
 * 
 *      Destroy the setup for parallel workers including parallel context. 
 *      Collect all the stats after workers are stopped, else some work 
 *      done by workers won't be accounted. 
 * ---------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN399"></a><span class='Declare_Function'>ExecShutdownGather</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1874"><span class='Ref_to_Struct'>GatherState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="nodeGather.c.html#LN47"><span class='Ref_to_Proto'>ExecShutdownGatherWorkers</span></a><span class='Parentheses'>(</span><a href="nodeGather.c.html#LN399"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Now destroy the parallel context. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeGather.c.html#LN399"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1878"><span class='Ref_to_Member'>pei</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../include/executor/execParallel.h.html#LN37"><span class='Ref_to_Proto'>ExecParallelCleanup</span></a><span class='Parentheses'>(</span><a href="nodeGather.c.html#LN399"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1878"><span class='Ref_to_Member'>pei</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="nodeGather.c.html#LN399"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1878"><span class='Ref_to_Member'>pei</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
} 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *                      Join Support 
 * ---------------------------------------------------------------- 
 */ 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *      ExecReScanGather 
 * 
 *      Re-initialize the workers and rescans a relation via them. 
 * ---------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN423"></a><span class='Declare_Function'>ExecReScanGather</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1874"><span class='Ref_to_Struct'>GatherState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * Re-initialize the parallel workers to perform rescan of relation. We 
     * want to gracefully shutdown all the workers so that they should be able 
     * to propagate any error or other information to master backend before 
     * dying.  Parallel context will be reused for rescan. 
     */ 
</span>    <a href="nodeGather.c.html#LN47"><span class='Ref_to_Proto'>ExecShutdownGatherWorkers</span></a><span class='Parentheses'>(</span><a href="nodeGather.c.html#LN423"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="nodeGather.c.html#LN423"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1877"><span class='Ref_to_Member'>initialized</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeGather.c.html#LN423"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1878"><span class='Ref_to_Member'>pei</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/executor/execParallel.h.html#LN38"><span class='Ref_to_Proto'>ExecParallelReinitialize</span></a><span class='Parentheses'>(</span><a href="nodeGather.c.html#LN423"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1878"><span class='Ref_to_Member'>pei</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="execAmi.c.html#LN73"><span class='Ref_to_Func'>ExecReScan</span></a><span class='Parentheses'>(</span><a href="nodeGather.c.html#LN423"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1876"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN827"><span class='Ref_to_Member'>lefttree</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span></pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>