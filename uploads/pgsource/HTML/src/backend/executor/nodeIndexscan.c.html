<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\executor\nodeIndexscan.c</title>
<LINK REL=StyleSheet HREF="../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\executor\nodeIndexscan.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:39 2017
</td></tr>
<tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * nodeIndexscan.c 
 *    Routines to support indexed scans of relations 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * 
 * IDENTIFICATION 
 *    src/backend/executor/nodeIndexscan.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
/* 
 * INTERFACE ROUTINES 
 *      ExecIndexScan           scans a relation using an index 
 *      IndexNext               retrieve next tuple using index 
 *      IndexNextWithReorder    same, but recheck ORDER BY expressions 
 *      ExecInitIndexScan       creates and initializes state info. 
 *      ExecReScanIndexScan     rescans the indexed relation. 
 *      ExecEndIndexScan        releases all storage. 
 *      ExecIndexMarkPos        marks scan position. 
 *      ExecIndexRestrPos       restores scan position. 
 *      ExecIndexScanEstimate   estimates DSM space needed for parallel index scan 
 *      ExecIndexScanInitializeDSM initialize DSM for parallel indexscan 
 *      ExecIndexScanInitializeWorker attach to DSM info in parallel worker 
 */ 
</span><span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"access/nbtree.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/relscan.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_am.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"executor/execdebug.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"executor/nodeIndexscan.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"lib/pairingheap.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/nodeFuncs.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/clauses.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/array.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/datum.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/lsyscache.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/memutils.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/rel.h"</span> 
 
<span class='Comment_Multi_Line'>/* 
 * When an ordering operator is used, tuples fetched from the index that 
 * need to be reordered are queued in a pairing heap, as ReorderTuples. 
 */ 
</span><span class='Control'>typedef</span> <span class='Control'>struct</span> 
<span class='Delimiter'>{ 
</span><a name="LN50"></a>    <a href="../../include/lib/pairingheap.h.html#LN29"><span class='Ref_to_Struct'>pairingheap_node</span></a> <span class='Declare_Member'>ph_node</span><span class='Delimiter'>; 
</span><a name="LN51"></a>    <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Member'>htup</span><span class='Delimiter'>; 
</span><a name="LN52"></a>    <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>      <span class='Operator'>*</span><span class='Declare_Member'>orderbyvals</span><span class='Delimiter'>; 
</span><a name="LN53"></a>    <span class='Keyword'>bool</span>       <span class='Operator'>*</span><span class='Declare_Member'>orderbynulls</span><span class='Delimiter'>; 
</span><a name="LN54"></a>} <span class='Declare_Typedef'>ReorderTuple</span><span class='Delimiter'>; 
</span> 
<a name="LN56"></a><span class='Keyword'>static </span><a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>IndexNext</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1139"><span class='Ref_to_Struct'>IndexScanState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN57"></a><span class='Keyword'>static </span><a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>IndexNextWithReorder</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1139"><span class='Ref_to_Struct'>IndexScanState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN58"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>EvalOrderByExpressions</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1139"><span class='Ref_to_Struct'>IndexScanState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><a href="../../include/nodes/execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>econtext</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN59"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>IndexRecheck</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1139"><span class='Ref_to_Struct'>IndexScanState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>slot</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN60"></a><span class='Keyword'>static int </span><span class='Declare_Prototype'>cmp_orderbyvals</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>adist</span><span class='Delimiter'>, </span><span class='Keyword'>const bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>anulls</span><span class='Delimiter'>, 
</span><a name="LN61"></a>                <span class='Keyword'>const </span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>bdist</span><span class='Delimiter'>, </span><span class='Keyword'>const bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>bnulls</span><span class='Delimiter'>, 
</span><a name="LN62"></a>                <a href="../../include/nodes/execnodes.h.html#LN1139"><span class='Ref_to_Struct'>IndexScanState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN63"></a><span class='Keyword'>static int </span><span class='Declare_Prototype'>reorderqueue_cmp</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../include/lib/pairingheap.h.html#LN29"><span class='Ref_to_Struct'>pairingheap_node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>a</span><span class='Delimiter'>, 
</span><a name="LN64"></a>                 <span class='Keyword'>const </span><a href="../../include/lib/pairingheap.h.html#LN29"><span class='Ref_to_Struct'>pairingheap_node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>b</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>arg</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN65"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>reorderqueue_push</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1139"><span class='Ref_to_Struct'>IndexScanState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a> <span class='Declare_Parameter'>tuple</span><span class='Delimiter'>, 
</span><a name="LN66"></a>                  <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>orderbyvals</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>orderbynulls</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN67"></a><span class='Keyword'>static </span><a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a> <span class='Declare_Prototype'>reorderqueue_pop</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1139"><span class='Ref_to_Struct'>IndexScanState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *      IndexNext 
 * 
 *      Retrieve a tuple from the IndexScan node's currentRelation 
 *      using the index specified in the IndexScanState information. 
 * ---------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>* 
</span><a name="LN78"></a><span class='Declare_Function'>IndexNext</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1139"><span class='Ref_to_Struct'>IndexScanState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN80"></a>    <a href="../../include/nodes/execnodes.h.html#LN402"><span class='Ref_to_Struct'>EState</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>estate</span><span class='Delimiter'>; 
</span><a name="LN81"></a>    <a href="../../include/nodes/execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Local'>econtext</span><span class='Delimiter'>; 
</span><a name="LN82"></a>    <a href="../../include/access/sdir.h.html#LN21"><span class='Ref_to_Enum'>ScanDirection</span></a> <span class='Declare_Local'>direction</span><span class='Delimiter'>; 
</span><a name="LN83"></a>    <a href="../../include/access/genam.h.html#LN85"><span class='Ref_to_Typedef'>IndexScanDesc</span></a> <span class='Declare_Local'>scandesc</span><span class='Delimiter'>; 
</span><a name="LN84"></a>    <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>tuple</span><span class='Delimiter'>; 
</span><a name="LN85"></a>    <a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Local'>slot</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * extract necessary information from index scan node 
     */ 
</span>    <a href="nodeIndexscan.c.html#LN80"><span class='Ref_To_Local'>estate</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN78"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1141"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN814"><span class='Ref_to_Member'>state</span></a><span class='Delimiter'>; 
</span>    <a href="nodeIndexscan.c.html#LN82"><span class='Ref_To_Local'>direction</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN80"><span class='Ref_To_Local'>estate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN407"><span class='Ref_to_Member'>es_direction</span></a><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* flip direction if this is an overall backward scan */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/access/sdir.h.html#LN40"><span class='Ref_to_Macro'>ScanDirectionIsBackward</span></a><span class='Parentheses'>(((</span><a href="../../include/nodes/plannodes.h.html#LN385"><span class='Ref_to_Struct'>IndexScan</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeIndexscan.c.html#LN78"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1141"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN812"><span class='Ref_to_Member'>plan</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>indexorderdir<span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/access/sdir.h.html#LN54"><span class='Ref_to_Macro'>ScanDirectionIsForward</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN82"><span class='Ref_To_Local'>direction</span></a><span class='Parentheses'>))</span> 
            <a href="nodeIndexscan.c.html#LN82"><span class='Ref_To_Local'>direction</span></a> <span class='Operator'>= </span><a href="../../include/access/sdir.h.html#LN23"><span class='Ref_to_EnumConst'>BackwardScanDirection</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/access/sdir.h.html#LN40"><span class='Ref_to_Macro'>ScanDirectionIsBackward</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN82"><span class='Ref_To_Local'>direction</span></a><span class='Parentheses'>))</span> 
            <a href="nodeIndexscan.c.html#LN82"><span class='Ref_To_Local'>direction</span></a> <span class='Operator'>= </span><a href="../../include/access/sdir.h.html#LN25"><span class='Ref_to_EnumConst'>ForwardScanDirection</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="nodeIndexscan.c.html#LN83"><span class='Ref_To_Local'>scandesc</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN78"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1153"><span class='Ref_to_Member'>iss_ScanDesc</span></a><span class='Delimiter'>; 
</span>    <a href="nodeIndexscan.c.html#LN81"><span class='Ref_To_Local'>econtext</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN78"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1141"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN842"><span class='Ref_to_Member'>ps_ExprContext</span></a><span class='Delimiter'>; 
</span>    <a href="nodeIndexscan.c.html#LN85"><span class='Ref_To_Local'>slot</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN78"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1141"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1060"><span class='Ref_to_Member'>ss_ScanTupleSlot</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN83"><span class='Ref_To_Local'>scandesc</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * We reach here if the index scan is not parallel, or if we're 
         * executing a index scan that was intended to be parallel serially. 
         */ 
</span>        <a href="nodeIndexscan.c.html#LN83"><span class='Ref_To_Local'>scandesc</span></a> <span class='Operator'>= </span><a href="../../include/access/genam.h.html#LN139"><span class='Ref_to_Proto'>index_beginscan</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN78"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1141"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1058"><span class='Ref_to_Member'>ss_currentRelation</span></a><span class='Delimiter'>, 
</span>                                   <a href="nodeIndexscan.c.html#LN78"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1152"><span class='Ref_to_Member'>iss_RelationDesc</span></a><span class='Delimiter'>, 
</span>                                   <a href="nodeIndexscan.c.html#LN80"><span class='Ref_To_Local'>estate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN408"><span class='Ref_to_Member'>es_snapshot</span></a><span class='Delimiter'>, 
</span>                                   <a href="nodeIndexscan.c.html#LN78"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1145"><span class='Ref_to_Member'>iss_NumScanKeys</span></a><span class='Delimiter'>, 
</span>                                   <a href="nodeIndexscan.c.html#LN78"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1147"><span class='Ref_to_Member'>iss_NumOrderByKeys</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="nodeIndexscan.c.html#LN78"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1153"><span class='Ref_to_Member'>iss_ScanDesc</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN83"><span class='Ref_To_Local'>scandesc</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If no run-time keys to calculate or they are ready, go ahead and 
         * pass the scankeys to the index AM. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN78"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1149"><span class='Ref_to_Member'>iss_NumRuntimeKeys</span></a> <span class='Operator'>== </span><span class='Number'>0</span> <span class='Operator'>|| </span><a href="nodeIndexscan.c.html#LN78"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1150"><span class='Ref_to_Member'>iss_RuntimeKeysReady</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/access/genam.h.html#LN146"><span class='Ref_to_Proto'>index_rescan</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN83"><span class='Ref_To_Local'>scandesc</span></a><span class='Delimiter'>, 
</span>                         <a href="nodeIndexscan.c.html#LN78"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1144"><span class='Ref_to_Member'>iss_ScanKeys</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN78"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1145"><span class='Ref_to_Member'>iss_NumScanKeys</span></a><span class='Delimiter'>, 
</span>                         <a href="nodeIndexscan.c.html#LN78"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1146"><span class='Ref_to_Member'>iss_OrderByKeys</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN78"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1147"><span class='Ref_to_Member'>iss_NumOrderByKeys</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if scandesc==NULL &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * ok, now that we have what we need, fetch the next tuple. 
     */ 
</span>    <span class='Control'>while</span> <span class='Parentheses'>((</span><a href="nodeIndexscan.c.html#LN84"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>= </span><a href="../../include/access/genam.h.html#LN162"><span class='Ref_to_Proto'>index_getnext</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN83"><span class='Ref_To_Local'>scandesc</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN82"><span class='Ref_To_Local'>direction</span></a><span class='Parentheses'>))</span> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Store the scanned tuple in the scan tuple slot of the scan state. 
         * Note: we pass 'false' because tuples returned by amgetnext are 
         * pointers onto disk pages and must not be pfree()'d. 
         */ 
</span>        <a href="../../include/executor/tuptable.h.html#LN147"><span class='Ref_to_Proto'>ExecStoreTuple</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN84"><span class='Ref_To_Local'>tuple</span></a><span class='Delimiter'>,</span>   <span class='Comment_Single_Line'>/* tuple to store */ 
</span>                       <a href="nodeIndexscan.c.html#LN85"><span class='Ref_To_Local'>slot</span></a><span class='Delimiter'>,</span>    <span class='Comment_Single_Line'>/* slot to store in */ 
</span>                       <a href="nodeIndexscan.c.html#LN83"><span class='Ref_To_Local'>scandesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/relscan.h.html#LN119"><span class='Ref_to_Member'>xs_cbuf</span></a><span class='Delimiter'>,</span>       <span class='Comment_Single_Line'>/* buffer containing tuple */ 
</span>                       <span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* don't pfree */ 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If the index was lossy, we have to recheck the index quals using 
         * the fetched tuple. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN83"><span class='Ref_To_Local'>scandesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/relscan.h.html#LN121"><span class='Ref_to_Member'>xs_recheck</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="nodeIndexscan.c.html#LN81"><span class='Ref_To_Local'>econtext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN196"><span class='Ref_to_Member'>ecxt_scantuple</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN85"><span class='Ref_To_Local'>slot</span></a><span class='Delimiter'>; 
</span>            <a href="../../include/executor/executor.h.html#LN449"><span class='Ref_to_Macro'>ResetExprContext</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN81"><span class='Ref_To_Local'>econtext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/executor/executor.h.html#LN344"><span class='Ref_to_Func'>ExecQual</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN78"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1142"><span class='Ref_to_Member'>indexqualorig</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN81"><span class='Ref_To_Local'>econtext</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* Fails recheck, so drop it and loop back for another */ 
</span>                <a href="../../include/nodes/execnodes.h.html#LN862"><span class='Ref_to_Macro'>InstrCountFiltered2</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN78"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>continue</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>return</span> <a href="nodeIndexscan.c.html#LN85"><span class='Ref_To_Local'>slot</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while (tuple=index_getnext(... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * if we get here it means the index scan failed so we are at the end of 
     * the scan.. 
     */ 
</span>    <a href="nodeIndexscan.c.html#LN78"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1157"><span class='Ref_to_Member'>iss_ReachedEnd</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="../../include/executor/tuptable.h.html#LN154"><span class='Ref_to_Proto'>ExecClearTuple</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN85"><span class='Ref_To_Local'>slot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end IndexNext &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *      IndexNextWithReorder 
 * 
 *      Like IndexNext, but this version can also re-check ORDER BY 
 *      expressions, and reorder the tuples as necessary. 
 * ---------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>* 
</span><a name="LN178"></a><span class='Declare_Function'>IndexNextWithReorder</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1139"><span class='Ref_to_Struct'>IndexScanState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN180"></a>    <a href="../../include/nodes/execnodes.h.html#LN402"><span class='Ref_to_Struct'>EState</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>estate</span><span class='Delimiter'>; 
</span><a name="LN181"></a>    <a href="../../include/nodes/execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Local'>econtext</span><span class='Delimiter'>; 
</span><a name="LN182"></a>    <a href="../../include/access/genam.h.html#LN85"><span class='Ref_to_Typedef'>IndexScanDesc</span></a> <span class='Declare_Local'>scandesc</span><span class='Delimiter'>; 
</span><a name="LN183"></a>    <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>tuple</span><span class='Delimiter'>; 
</span><a name="LN184"></a>    <a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Local'>slot</span><span class='Delimiter'>; 
</span><a name="LN185"></a>    <a href="nodeIndexscan.c.html#LN48"><span class='Ref_to_Typedef'>ReorderTuple</span></a> <span class='Operator'>*</span><span class='Declare_Local'>topmost</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN186"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>was_exact</span><span class='Delimiter'>; 
</span><a name="LN187"></a>    <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>lastfetched_vals</span><span class='Delimiter'>; 
</span><a name="LN188"></a>    <span class='Keyword'>bool</span>       <span class='Operator'>*</span><span class='Declare_Local'>lastfetched_nulls</span><span class='Delimiter'>; 
</span><a name="LN189"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>cmp</span><span class='Delimiter'>; 
</span> 
    <a href="nodeIndexscan.c.html#LN180"><span class='Ref_To_Local'>estate</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN178"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1141"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN814"><span class='Ref_to_Member'>state</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Only forward scan is supported with reordering.  Note: we can get away 
     * with just Asserting here because the system will not try to run the 
     * plan backwards if ExecSupportsBackwardScan() says it won't work. 
     * Currently, that is guaranteed because no index AMs support both 
     * amcanorderbyop and amcanbackward; if any ever do, 
     * ExecSupportsBackwardScan() will need to consider indexorderbys 
     * explicitly. 
     */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/sdir.h.html#LN40"><span class='Ref_to_Macro'>ScanDirectionIsBackward</span></a><span class='Parentheses'>(((</span><a href="../../include/nodes/plannodes.h.html#LN385"><span class='Ref_to_Struct'>IndexScan</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeIndexscan.c.html#LN178"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1141"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN812"><span class='Ref_to_Member'>plan</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>indexorderdir<span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../include/access/sdir.h.html#LN54"><span class='Ref_to_Macro'>ScanDirectionIsForward</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN180"><span class='Ref_To_Local'>estate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN407"><span class='Ref_to_Member'>es_direction</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="nodeIndexscan.c.html#LN182"><span class='Ref_To_Local'>scandesc</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN178"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1153"><span class='Ref_to_Member'>iss_ScanDesc</span></a><span class='Delimiter'>; 
</span>    <a href="nodeIndexscan.c.html#LN181"><span class='Ref_To_Local'>econtext</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN178"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1141"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN842"><span class='Ref_to_Member'>ps_ExprContext</span></a><span class='Delimiter'>; 
</span>    <a href="nodeIndexscan.c.html#LN184"><span class='Ref_To_Local'>slot</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN178"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1141"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1060"><span class='Ref_to_Member'>ss_ScanTupleSlot</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN182"><span class='Ref_To_Local'>scandesc</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * We reach here if the index scan is not parallel, or if we're 
         * executing a index scan that was intended to be parallel serially. 
         */ 
</span>        <a href="nodeIndexscan.c.html#LN182"><span class='Ref_To_Local'>scandesc</span></a> <span class='Operator'>= </span><a href="../../include/access/genam.h.html#LN139"><span class='Ref_to_Proto'>index_beginscan</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN178"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1141"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1058"><span class='Ref_to_Member'>ss_currentRelation</span></a><span class='Delimiter'>, 
</span>                                   <a href="nodeIndexscan.c.html#LN178"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1152"><span class='Ref_to_Member'>iss_RelationDesc</span></a><span class='Delimiter'>, 
</span>                                   <a href="nodeIndexscan.c.html#LN180"><span class='Ref_To_Local'>estate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN408"><span class='Ref_to_Member'>es_snapshot</span></a><span class='Delimiter'>, 
</span>                                   <a href="nodeIndexscan.c.html#LN178"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1145"><span class='Ref_to_Member'>iss_NumScanKeys</span></a><span class='Delimiter'>, 
</span>                                   <a href="nodeIndexscan.c.html#LN178"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1147"><span class='Ref_to_Member'>iss_NumOrderByKeys</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="nodeIndexscan.c.html#LN178"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1153"><span class='Ref_to_Member'>iss_ScanDesc</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN182"><span class='Ref_To_Local'>scandesc</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If no run-time keys to calculate or they are ready, go ahead and 
         * pass the scankeys to the index AM. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN178"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1149"><span class='Ref_to_Member'>iss_NumRuntimeKeys</span></a> <span class='Operator'>== </span><span class='Number'>0</span> <span class='Operator'>|| </span><a href="nodeIndexscan.c.html#LN178"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1150"><span class='Ref_to_Member'>iss_RuntimeKeysReady</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/access/genam.h.html#LN146"><span class='Ref_to_Proto'>index_rescan</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN182"><span class='Ref_To_Local'>scandesc</span></a><span class='Delimiter'>, 
</span>                         <a href="nodeIndexscan.c.html#LN178"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1144"><span class='Ref_to_Member'>iss_ScanKeys</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN178"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1145"><span class='Ref_to_Member'>iss_NumScanKeys</span></a><span class='Delimiter'>, 
</span>                         <a href="nodeIndexscan.c.html#LN178"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1146"><span class='Ref_to_Member'>iss_OrderByKeys</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN178"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1147"><span class='Ref_to_Member'>iss_NumOrderByKeys</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if scandesc==NULL &raquo; </span> 
 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>;;</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Check the reorder queue first.  If the topmost tuple in the queue 
         * has an ORDER BY value smaller than (or equal to) the value last 
         * returned by the index, we can return it now. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/lib/pairingheap.h.html#LN95"><span class='Ref_to_Macro'>pairingheap_is_empty</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN178"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1156"><span class='Ref_to_Member'>iss_ReorderQueue</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="nodeIndexscan.c.html#LN185"><span class='Ref_To_Local'>topmost</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN48"><span class='Ref_to_Typedef'>ReorderTuple</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/lib/pairingheap.h.html#LN81"><span class='Ref_to_Proto'>pairingheap_first</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN178"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1156"><span class='Ref_to_Member'>iss_ReorderQueue</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN178"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1157"><span class='Ref_to_Member'>iss_ReachedEnd</span></a> <span class='Operator'>|| 
</span>                <a href="nodeIndexscan.c.html#LN60"><span class='Ref_to_Proto'>cmp_orderbyvals</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN185"><span class='Ref_To_Local'>topmost</span></a><span class='Operator'>-&GT;</span><a href="nodeIndexscan.c.html#LN52"><span class='Ref_to_Member'>orderbyvals</span></a><span class='Delimiter'>, 
</span>                                <a href="nodeIndexscan.c.html#LN185"><span class='Ref_To_Local'>topmost</span></a><span class='Operator'>-&GT;</span><a href="nodeIndexscan.c.html#LN53"><span class='Ref_to_Member'>orderbynulls</span></a><span class='Delimiter'>, 
</span>                                <a href="nodeIndexscan.c.html#LN182"><span class='Ref_To_Local'>scandesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/relscan.h.html#LN130"><span class='Ref_to_Member'>xs_orderbyvals</span></a><span class='Delimiter'>, 
</span>                                <a href="nodeIndexscan.c.html#LN182"><span class='Ref_To_Local'>scandesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/relscan.h.html#LN131"><span class='Ref_to_Member'>xs_orderbynulls</span></a><span class='Delimiter'>, 
</span>                                <a href="nodeIndexscan.c.html#LN178"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>) </span><span class='Operator'>&LT;= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
            <span class='Delimiter'>{ 
</span>                <a href="nodeIndexscan.c.html#LN183"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN67"><span class='Ref_to_Proto'>reorderqueue_pop</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN178"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* Pass 'true', as the tuple in the queue is a palloc'd copy */ 
</span>                <a href="../../include/executor/tuptable.h.html#LN147"><span class='Ref_to_Proto'>ExecStoreTuple</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN183"><span class='Ref_To_Local'>tuple</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN184"><span class='Ref_To_Local'>slot</span></a><span class='Delimiter'>, </span><a href="../../include/storage/buf.h.html#LN24"><span class='Ref_to_Const'>InvalidBuffer</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>return</span> <a href="nodeIndexscan.c.html#LN184"><span class='Ref_To_Local'>slot</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN178"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1157"><span class='Ref_to_Member'>iss_ReachedEnd</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Queue is empty, and no more tuples from index.  We're done. */ 
</span>            <span class='Control'>return</span> <a href="../../include/executor/tuptable.h.html#LN154"><span class='Ref_to_Proto'>ExecClearTuple</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN184"><span class='Ref_To_Local'>slot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Fetch next tuple from the index. 
         */ 
</span><a name="LN267"></a><span class='Label'>next_indextuple</span><span class='Operator'>: 
</span>        <a href="nodeIndexscan.c.html#LN183"><span class='Ref_To_Local'>tuple</span></a> <span class='Operator'>= </span><a href="../../include/access/genam.h.html#LN162"><span class='Ref_to_Proto'>index_getnext</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN182"><span class='Ref_To_Local'>scandesc</span></a><span class='Delimiter'>, </span><a href="../../include/access/sdir.h.html#LN25"><span class='Ref_to_EnumConst'>ForwardScanDirection</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="nodeIndexscan.c.html#LN183"><span class='Ref_To_Local'>tuple</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * No more tuples from the index.  But we still need to drain any 
             * remaining tuples from the queue before we're done. 
             */ 
</span>            <a href="nodeIndexscan.c.html#LN178"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1157"><span class='Ref_to_Member'>iss_ReachedEnd</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Store the scanned tuple in the scan tuple slot of the scan state. 
         * Note: we pass 'false' because tuples returned by amgetnext are 
         * pointers onto disk pages and must not be pfree()'d. 
         */ 
</span>        <a href="../../include/executor/tuptable.h.html#LN147"><span class='Ref_to_Proto'>ExecStoreTuple</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN183"><span class='Ref_To_Local'>tuple</span></a><span class='Delimiter'>,</span>   <span class='Comment_Single_Line'>/* tuple to store */ 
</span>                       <a href="nodeIndexscan.c.html#LN184"><span class='Ref_To_Local'>slot</span></a><span class='Delimiter'>,</span>    <span class='Comment_Single_Line'>/* slot to store in */ 
</span>                       <a href="nodeIndexscan.c.html#LN182"><span class='Ref_To_Local'>scandesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/relscan.h.html#LN119"><span class='Ref_to_Member'>xs_cbuf</span></a><span class='Delimiter'>,</span>       <span class='Comment_Single_Line'>/* buffer containing tuple */ 
</span>                       <span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* don't pfree */ 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If the index was lossy, we have to recheck the index quals and 
         * ORDER BY expressions using the fetched tuple. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN182"><span class='Ref_To_Local'>scandesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/relscan.h.html#LN121"><span class='Ref_to_Member'>xs_recheck</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="nodeIndexscan.c.html#LN181"><span class='Ref_To_Local'>econtext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN196"><span class='Ref_to_Member'>ecxt_scantuple</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN184"><span class='Ref_To_Local'>slot</span></a><span class='Delimiter'>; 
</span>            <a href="../../include/executor/executor.h.html#LN449"><span class='Ref_to_Macro'>ResetExprContext</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN181"><span class='Ref_To_Local'>econtext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/executor/executor.h.html#LN344"><span class='Ref_to_Func'>ExecQual</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN178"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1142"><span class='Ref_to_Member'>indexqualorig</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN181"><span class='Ref_To_Local'>econtext</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* Fails recheck, so drop it and loop back for another */ 
</span>                <a href="../../include/nodes/execnodes.h.html#LN862"><span class='Ref_to_Macro'>InstrCountFiltered2</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN178"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>goto</span> <span class='Symbol_Characters'>&uarr;</span><a href="nodeIndexscan.c.html#LN267"><span class='Ref_to_Label'>next_indextuple</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN182"><span class='Ref_To_Local'>scandesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/relscan.h.html#LN132"><span class='Ref_to_Member'>xs_recheckorderby</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="nodeIndexscan.c.html#LN181"><span class='Ref_To_Local'>econtext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN196"><span class='Ref_to_Member'>ecxt_scantuple</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN184"><span class='Ref_To_Local'>slot</span></a><span class='Delimiter'>; 
</span>            <a href="../../include/executor/executor.h.html#LN449"><span class='Ref_to_Macro'>ResetExprContext</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN181"><span class='Ref_To_Local'>econtext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="nodeIndexscan.c.html#LN58"><span class='Ref_to_Proto'>EvalOrderByExpressions</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN178"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN181"><span class='Ref_To_Local'>econtext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Was the ORDER BY value returned by the index accurate?  The 
             * recheck flag means that the index can return inaccurate values, 
             * but then again, the value returned for any particular tuple 
             * could also be exactly correct.  Compare the value returned by 
             * the index with the recalculated value.  (If the value returned 
             * by the index happened to be exact right, we can often avoid 
             * pushing the tuple to the queue, just to pop it back out again.) 
             */ 
</span>            <a href="nodeIndexscan.c.html#LN189"><span class='Ref_To_Local'>cmp</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN60"><span class='Ref_to_Proto'>cmp_orderbyvals</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN178"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1158"><span class='Ref_to_Member'>iss_OrderByValues</span></a><span class='Delimiter'>, 
</span>                                  <a href="nodeIndexscan.c.html#LN178"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1159"><span class='Ref_to_Member'>iss_OrderByNulls</span></a><span class='Delimiter'>, 
</span>                                  <a href="nodeIndexscan.c.html#LN182"><span class='Ref_To_Local'>scandesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/relscan.h.html#LN130"><span class='Ref_to_Member'>xs_orderbyvals</span></a><span class='Delimiter'>, 
</span>                                  <a href="nodeIndexscan.c.html#LN182"><span class='Ref_To_Local'>scandesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/relscan.h.html#LN131"><span class='Ref_to_Member'>xs_orderbynulls</span></a><span class='Delimiter'>, 
</span>                                  <a href="nodeIndexscan.c.html#LN178"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN189"><span class='Ref_To_Local'>cmp</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"index returned tuples in wrong order"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN189"><span class='Ref_To_Local'>cmp</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <a href="nodeIndexscan.c.html#LN186"><span class='Ref_To_Local'>was_exact</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="nodeIndexscan.c.html#LN186"><span class='Ref_To_Local'>was_exact</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="nodeIndexscan.c.html#LN187"><span class='Ref_To_Local'>lastfetched_vals</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN178"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1158"><span class='Ref_to_Member'>iss_OrderByValues</span></a><span class='Delimiter'>; 
</span>            <a href="nodeIndexscan.c.html#LN188"><span class='Ref_To_Local'>lastfetched_nulls</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN178"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1159"><span class='Ref_to_Member'>iss_OrderByNulls</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if scandesc-&GT;xs_rechecko... &raquo; </span> 
        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <a href="nodeIndexscan.c.html#LN186"><span class='Ref_To_Local'>was_exact</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <a href="nodeIndexscan.c.html#LN187"><span class='Ref_To_Local'>lastfetched_vals</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN182"><span class='Ref_To_Local'>scandesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/relscan.h.html#LN130"><span class='Ref_to_Member'>xs_orderbyvals</span></a><span class='Delimiter'>; 
</span>            <a href="nodeIndexscan.c.html#LN188"><span class='Ref_To_Local'>lastfetched_nulls</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN182"><span class='Ref_To_Local'>scandesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/relscan.h.html#LN131"><span class='Ref_to_Member'>xs_orderbynulls</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Can we return this tuple immediately, or does it need to be pushed 
         * to the reorder queue?  If the ORDER BY expression values returned 
         * by the index were inaccurate, we can't return it yet, because the 
         * next tuple from the index might need to come before this one. Also, 
         * we can't return it yet if there are any smaller tuples in the queue 
         * already. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="nodeIndexscan.c.html#LN186"><span class='Ref_To_Local'>was_exact</span></a> <span class='Operator'>|| </span><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN185"><span class='Ref_To_Local'>topmost</span></a> <span class='Operator'>&& </span><a href="nodeIndexscan.c.html#LN60"><span class='Ref_to_Proto'>cmp_orderbyvals</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN187"><span class='Ref_To_Local'>lastfetched_vals</span></a><span class='Delimiter'>, 
</span>                                                      <a href="nodeIndexscan.c.html#LN188"><span class='Ref_To_Local'>lastfetched_nulls</span></a><span class='Delimiter'>, 
</span>                                                      <a href="nodeIndexscan.c.html#LN185"><span class='Ref_To_Local'>topmost</span></a><span class='Operator'>-&GT;</span><a href="nodeIndexscan.c.html#LN52"><span class='Ref_to_Member'>orderbyvals</span></a><span class='Delimiter'>, 
</span>                                                      <a href="nodeIndexscan.c.html#LN185"><span class='Ref_To_Local'>topmost</span></a><span class='Operator'>-&GT;</span><a href="nodeIndexscan.c.html#LN53"><span class='Ref_to_Member'>orderbynulls</span></a><span class='Delimiter'>, 
</span>                                                      <a href="nodeIndexscan.c.html#LN178"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Put this tuple to the queue */ 
</span>            <a href="nodeIndexscan.c.html#LN65"><span class='Ref_to_Proto'>reorderqueue_push</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN178"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN183"><span class='Ref_To_Local'>tuple</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN187"><span class='Ref_To_Local'>lastfetched_vals</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN188"><span class='Ref_To_Local'>lastfetched_nulls</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Can return this tuple immediately. */ 
</span>            <span class='Control'>return</span> <a href="nodeIndexscan.c.html#LN184"><span class='Ref_To_Local'>slot</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for ;; &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * if we get here it means the index scan failed so we are at the end of 
     * the scan.. 
     */ 
</span>    <span class='Control'>return</span> <a href="../../include/executor/tuptable.h.html#LN154"><span class='Ref_to_Proto'>ExecClearTuple</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN184"><span class='Ref_To_Local'>slot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end IndexNextWithReorder &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Calculate the expressions in the ORDER BY clause, based on the heap tuple. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN377"></a><span class='Declare_Function'>EvalOrderByExpressions</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1139"><span class='Ref_to_Struct'>IndexScanState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><a href="../../include/nodes/execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>econtext</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN379"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN380"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span><a name="LN381"></a>    <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldContext</span><span class='Delimiter'>; 
</span> 
    <a href="nodeIndexscan.c.html#LN381"><span class='Ref_To_Local'>oldContext</span></a> <span class='Operator'>= </span><a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN377"><span class='Ref_to_Parameter'>econtext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN202"><span class='Ref_to_Member'>ecxt_per_tuple_memory</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="nodeIndexscan.c.html#LN379"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN380"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN377"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1143"><span class='Ref_to_Member'>indexorderbyorig</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN388"></a>        <a href="../../include/nodes/execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>orderby</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN380"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="nodeIndexscan.c.html#LN377"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1158"><span class='Ref_to_Member'>iss_OrderByValues</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN379"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/executor/executor.h.html#LN264"><span class='Ref_to_Func'>ExecEvalExpr</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN388"><span class='Ref_To_Local'>orderby</span></a><span class='Delimiter'>, 
</span>                                                  <a href="nodeIndexscan.c.html#LN377"><span class='Ref_to_Parameter'>econtext</span></a><span class='Delimiter'>, 
</span>                                                  <span class='Operator'>&</span><a href="nodeIndexscan.c.html#LN377"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1159"><span class='Ref_to_Member'>iss_OrderByNulls</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN379"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="nodeIndexscan.c.html#LN379"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN381"><span class='Ref_To_Local'>oldContext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end EvalOrderByExpressions &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * IndexRecheck -- access method routine to recheck a tuple in EvalPlanQual 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN403"></a><span class='Declare_Function'>IndexRecheck</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1139"><span class='Ref_to_Struct'>IndexScanState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>slot</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN405"></a>    <a href="../../include/nodes/execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Local'>econtext</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * extract necessary information from index scan node 
     */ 
</span>    <a href="nodeIndexscan.c.html#LN405"><span class='Ref_To_Local'>econtext</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN403"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1141"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN842"><span class='Ref_to_Member'>ps_ExprContext</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Does the tuple meet the indexqual condition? */ 
</span>    <a href="nodeIndexscan.c.html#LN405"><span class='Ref_To_Local'>econtext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN196"><span class='Ref_to_Member'>ecxt_scantuple</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN403"><span class='Ref_to_Parameter'>slot</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../include/executor/executor.h.html#LN449"><span class='Ref_to_Macro'>ResetExprContext</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN405"><span class='Ref_To_Local'>econtext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="../../include/executor/executor.h.html#LN344"><span class='Ref_to_Func'>ExecQual</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN403"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1142"><span class='Ref_to_Member'>indexqualorig</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN405"><span class='Ref_To_Local'>econtext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * Compare ORDER BY expression values. 
 */ 
</span><span class='Keyword'>static int 
</span><a name="LN425"></a><span class='Declare_Function'>cmp_orderbyvals</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>adist</span><span class='Delimiter'>, </span><span class='Keyword'>const bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>anulls</span><span class='Delimiter'>, 
</span><a name="LN426"></a>                <span class='Keyword'>const </span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>bdist</span><span class='Delimiter'>, </span><span class='Keyword'>const bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>bnulls</span><span class='Delimiter'>, 
</span><a name="LN427"></a>                <a href="../../include/nodes/execnodes.h.html#LN1139"><span class='Ref_to_Struct'>IndexScanState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN429"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN430"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN429"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nodeIndexscan.c.html#LN429"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="nodeIndexscan.c.html#LN427"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1147"><span class='Ref_to_Member'>iss_NumOrderByKeys</span></a><span class='Delimiter'>; </span><a href="nodeIndexscan.c.html#LN429"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN434"></a>        <a href="../../include/utils/sortsupport.h.html#LN57"><span class='Ref_to_Typedef'>SortSupport</span></a> <span class='Declare_Local'>ssup</span> <span class='Operator'>= &</span><a href="nodeIndexscan.c.html#LN427"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1160"><span class='Ref_to_Member'>iss_SortSupport</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN429"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Handle nulls.  We only need to support NULLS LAST ordering, because 
         * match_pathkeys_to_index() doesn't consider indexorderby 
         * implementation otherwise. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN425"><span class='Ref_to_Parameter'>anulls</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN429"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>&& !</span><a href="nodeIndexscan.c.html#LN426"><span class='Ref_to_Parameter'>bnulls</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN429"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Number'>1</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="nodeIndexscan.c.html#LN425"><span class='Ref_to_Parameter'>anulls</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN429"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>&& </span><a href="nodeIndexscan.c.html#LN426"><span class='Ref_to_Parameter'>bnulls</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN429"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN425"><span class='Ref_to_Parameter'>anulls</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN429"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>&& </span><a href="nodeIndexscan.c.html#LN426"><span class='Ref_to_Parameter'>bnulls</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN429"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Number'>0</span><span class='Delimiter'>; 
</span> 
        <a href="nodeIndexscan.c.html#LN430"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN434"><span class='Ref_To_Local'>ssup</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/sortsupport.h.html#LN106"><span class='Ref_to_Member'>comparator</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN425"><span class='Ref_to_Parameter'>adist</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN429"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], </span><a href="nodeIndexscan.c.html#LN426"><span class='Ref_to_Parameter'>bdist</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN429"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], </span><a href="nodeIndexscan.c.html#LN434"><span class='Ref_To_Local'>ssup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN430"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <a href="nodeIndexscan.c.html#LN430"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;node-&GT;iss_NumOr... &raquo; </span> 
 
    <span class='Control'>return</span> <span class='Number'>0</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end cmp_orderbyvals &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Pairing heap provides getting topmost (greatest) element while KNN provides 
 * ascending sort.  That's why we invert the sort order. 
 */ 
</span><span class='Keyword'>static int 
</span><a name="LN461"></a><span class='Declare_Function'>reorderqueue_cmp</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../include/lib/pairingheap.h.html#LN29"><span class='Ref_to_Struct'>pairingheap_node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>a</span><span class='Delimiter'>, </span><span class='Keyword'>const </span><a href="../../include/lib/pairingheap.h.html#LN29"><span class='Ref_to_Struct'>pairingheap_node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>b</span><span class='Delimiter'>, 
</span><a name="LN462"></a>                 <span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>arg</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN464"></a>    <a href="nodeIndexscan.c.html#LN48"><span class='Ref_to_Typedef'>ReorderTuple</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rta</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN48"><span class='Ref_to_Typedef'>ReorderTuple</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeIndexscan.c.html#LN461"><span class='Ref_to_Parameter'>a</span></a><span class='Delimiter'>; 
</span><a name="LN465"></a>    <a href="nodeIndexscan.c.html#LN48"><span class='Ref_to_Typedef'>ReorderTuple</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rtb</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN48"><span class='Ref_to_Typedef'>ReorderTuple</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeIndexscan.c.html#LN461"><span class='Ref_to_Parameter'>b</span></a><span class='Delimiter'>; 
</span><a name="LN466"></a>    <a href="../../include/nodes/execnodes.h.html#LN1139"><span class='Ref_to_Struct'>IndexScanState</span></a> <span class='Operator'>*</span><span class='Declare_Local'>node</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1139"><span class='Ref_to_Struct'>IndexScanState</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeIndexscan.c.html#LN462"><span class='Ref_to_Parameter'>arg</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Operator'>-</span><a href="nodeIndexscan.c.html#LN60"><span class='Ref_to_Proto'>cmp_orderbyvals</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN464"><span class='Ref_To_Local'>rta</span></a><span class='Operator'>-&GT;</span><a href="nodeIndexscan.c.html#LN52"><span class='Ref_to_Member'>orderbyvals</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN464"><span class='Ref_To_Local'>rta</span></a><span class='Operator'>-&GT;</span><a href="nodeIndexscan.c.html#LN53"><span class='Ref_to_Member'>orderbynulls</span></a><span class='Delimiter'>, 
</span>                            <a href="nodeIndexscan.c.html#LN465"><span class='Ref_To_Local'>rtb</span></a><span class='Operator'>-&GT;</span><a href="nodeIndexscan.c.html#LN52"><span class='Ref_to_Member'>orderbyvals</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN465"><span class='Ref_To_Local'>rtb</span></a><span class='Operator'>-&GT;</span><a href="nodeIndexscan.c.html#LN53"><span class='Ref_to_Member'>orderbynulls</span></a><span class='Delimiter'>, 
</span>                            <a href="nodeIndexscan.c.html#LN466"><span class='Ref_To_Local'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Helper function to push a tuple to the reorder queue. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN477"></a><span class='Declare_Function'>reorderqueue_push</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1139"><span class='Ref_to_Struct'>IndexScanState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a> <span class='Declare_Parameter'>tuple</span><span class='Delimiter'>, 
</span><a name="LN478"></a>                  <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>orderbyvals</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>orderbynulls</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN480"></a>    <a href="../../include/access/genam.h.html#LN85"><span class='Ref_to_Typedef'>IndexScanDesc</span></a> <span class='Declare_Local'>scandesc</span> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN477"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1153"><span class='Ref_to_Member'>iss_ScanDesc</span></a><span class='Delimiter'>; 
</span><a name="LN481"></a>    <a href="../../include/nodes/execnodes.h.html#LN402"><span class='Ref_to_Struct'>EState</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>estate</span> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN477"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1141"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN814"><span class='Ref_to_Member'>state</span></a><span class='Delimiter'>; 
</span><a name="LN482"></a>    <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldContext</span> <span class='Operator'>= </span><a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN481"><span class='Ref_To_Local'>estate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN447"><span class='Ref_to_Member'>es_query_cxt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN483"></a>    <a href="nodeIndexscan.c.html#LN48"><span class='Ref_to_Typedef'>ReorderTuple</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rt</span><span class='Delimiter'>; 
</span><a name="LN484"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <a href="nodeIndexscan.c.html#LN483"><span class='Ref_To_Local'>rt</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN48"><span class='Ref_to_Typedef'>ReorderTuple</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN48"><span class='Ref_to_Typedef'>ReorderTuple</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="nodeIndexscan.c.html#LN483"><span class='Ref_To_Local'>rt</span></a><span class='Operator'>-&GT;</span><a href="nodeIndexscan.c.html#LN51"><span class='Ref_to_Member'>htup</span></a> <span class='Operator'>= </span><a href="../access/common/heaptuple.c.html#LN606"><span class='Ref_to_Func'>heap_copytuple</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN477"><span class='Ref_to_Parameter'>tuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="nodeIndexscan.c.html#LN483"><span class='Ref_To_Local'>rt</span></a><span class='Operator'>-&GT;</span><a href="nodeIndexscan.c.html#LN52"><span class='Ref_to_Member'>orderbyvals</span></a> <span class='Operator'>= 
</span>        <span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="nodeIndexscan.c.html#LN480"><span class='Ref_To_Local'>scandesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/relscan.h.html#LN91"><span class='Ref_to_Member'>numberOfOrderBys</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="nodeIndexscan.c.html#LN483"><span class='Ref_To_Local'>rt</span></a><span class='Operator'>-&GT;</span><a href="nodeIndexscan.c.html#LN53"><span class='Ref_to_Member'>orderbynulls</span></a> <span class='Operator'>= 
</span>        <span class='Parentheses'>(</span><span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>bool</span><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="nodeIndexscan.c.html#LN480"><span class='Ref_To_Local'>scandesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/relscan.h.html#LN91"><span class='Ref_to_Member'>numberOfOrderBys</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN484"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nodeIndexscan.c.html#LN484"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="nodeIndexscan.c.html#LN477"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1147"><span class='Ref_to_Member'>iss_NumOrderByKeys</span></a><span class='Delimiter'>; </span><a href="nodeIndexscan.c.html#LN484"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="nodeIndexscan.c.html#LN478"><span class='Ref_to_Parameter'>orderbynulls</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN484"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>            <a href="nodeIndexscan.c.html#LN483"><span class='Ref_To_Local'>rt</span></a><span class='Operator'>-&GT;</span><a href="nodeIndexscan.c.html#LN52"><span class='Ref_to_Member'>orderbyvals</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN484"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../include/utils/datum.h.html#LN30"><span class='Ref_to_Proto'>datumCopy</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN478"><span class='Ref_to_Parameter'>orderbyvals</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN484"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], 
</span>                                           <a href="nodeIndexscan.c.html#LN477"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1161"><span class='Ref_to_Member'>iss_OrderByTypByVals</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN484"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], 
</span>                                           <a href="nodeIndexscan.c.html#LN477"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1162"><span class='Ref_to_Member'>iss_OrderByTypLens</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN484"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="nodeIndexscan.c.html#LN483"><span class='Ref_To_Local'>rt</span></a><span class='Operator'>-&GT;</span><a href="nodeIndexscan.c.html#LN52"><span class='Ref_to_Member'>orderbyvals</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN484"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="nodeIndexscan.c.html#LN483"><span class='Ref_To_Local'>rt</span></a><span class='Operator'>-&GT;</span><a href="nodeIndexscan.c.html#LN53"><span class='Ref_to_Member'>orderbynulls</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN484"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN478"><span class='Ref_to_Parameter'>orderbynulls</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN484"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span>    <span class='Delimiter'>} 
</span>    <a href="../../include/lib/pairingheap.h.html#LN80"><span class='Ref_to_Proto'>pairingheap_add</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN477"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1156"><span class='Ref_to_Member'>iss_ReorderQueue</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nodeIndexscan.c.html#LN483"><span class='Ref_To_Local'>rt</span></a><span class='Operator'>-&GT;</span><a href="nodeIndexscan.c.html#LN50"><span class='Ref_to_Member'>ph_node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN482"><span class='Ref_To_Local'>oldContext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end reorderqueue_push &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Helper function to pop the next tuple from the reorder queue. 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a> 
<a name="LN511"></a><span class='Declare_Function'>reorderqueue_pop</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1139"><span class='Ref_to_Struct'>IndexScanState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN513"></a>    <a href="../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span><a name="LN514"></a>    <a href="nodeIndexscan.c.html#LN48"><span class='Ref_to_Typedef'>ReorderTuple</span></a> <span class='Operator'>*</span><span class='Declare_Local'>topmost</span><span class='Delimiter'>; 
</span><a name="LN515"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <a href="nodeIndexscan.c.html#LN514"><span class='Ref_To_Local'>topmost</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN48"><span class='Ref_to_Typedef'>ReorderTuple</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/lib/pairingheap.h.html#LN82"><span class='Ref_to_Proto'>pairingheap_remove_first</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN511"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1156"><span class='Ref_to_Member'>iss_ReorderQueue</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="nodeIndexscan.c.html#LN513"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN514"><span class='Ref_To_Local'>topmost</span></a><span class='Operator'>-&GT;</span><a href="nodeIndexscan.c.html#LN51"><span class='Ref_to_Member'>htup</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN515"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nodeIndexscan.c.html#LN515"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="nodeIndexscan.c.html#LN511"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1147"><span class='Ref_to_Member'>iss_NumOrderByKeys</span></a><span class='Delimiter'>; </span><a href="nodeIndexscan.c.html#LN515"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="nodeIndexscan.c.html#LN511"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1161"><span class='Ref_to_Member'>iss_OrderByTypByVals</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN515"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>&& !</span><a href="nodeIndexscan.c.html#LN514"><span class='Ref_To_Local'>topmost</span></a><span class='Operator'>-&GT;</span><a href="nodeIndexscan.c.html#LN53"><span class='Ref_to_Member'>orderbynulls</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN515"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>            <a href="../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN554"><span class='Ref_to_Macro'>DatumGetPointer</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN514"><span class='Ref_To_Local'>topmost</span></a><span class='Operator'>-&GT;</span><a href="nodeIndexscan.c.html#LN52"><span class='Ref_to_Member'>orderbyvals</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN515"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN514"><span class='Ref_To_Local'>topmost</span></a><span class='Operator'>-&GT;</span><a href="nodeIndexscan.c.html#LN52"><span class='Ref_to_Member'>orderbyvals</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN514"><span class='Ref_To_Local'>topmost</span></a><span class='Operator'>-&GT;</span><a href="nodeIndexscan.c.html#LN53"><span class='Ref_to_Member'>orderbynulls</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN514"><span class='Ref_To_Local'>topmost</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="nodeIndexscan.c.html#LN513"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end reorderqueue_pop &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *      ExecIndexScan(node) 
 * ---------------------------------------------------------------- 
 */ 
</span><a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>* 
</span><a name="LN538"></a><span class='Declare_Function'>ExecIndexScan</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1139"><span class='Ref_to_Struct'>IndexScanState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * If we have runtime keys and they've not already been set up, do it now. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN538"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1149"><span class='Ref_to_Member'>iss_NumRuntimeKeys</span></a> <span class='Operator'>!= </span><span class='Number'>0</span> <span class='Operator'>&& !</span><a href="nodeIndexscan.c.html#LN538"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1150"><span class='Ref_to_Member'>iss_RuntimeKeysReady</span></a><span class='Parentheses'>) 
</span>        <a href="execAmi.c.html#LN73"><span class='Ref_to_Func'>ExecReScan</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeIndexscan.c.html#LN538"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN538"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1147"><span class='Ref_to_Member'>iss_NumOrderByKeys</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="execScan.c.html#LN119"><span class='Ref_to_Func'>ExecScan</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nodeIndexscan.c.html#LN538"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1141"><span class='Ref_to_Member'>ss</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/executor/executor.h.html#LN388"><span class='Ref_to_Typedef'>ExecScanAccessMtd</span></a><span class='Parentheses'>) </span><a href="nodeIndexscan.c.html#LN57"><span class='Ref_to_Proto'>IndexNextWithReorder</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/executor/executor.h.html#LN389"><span class='Ref_to_Typedef'>ExecScanRecheckMtd</span></a><span class='Parentheses'>) </span><a href="nodeIndexscan.c.html#LN59"><span class='Ref_to_Proto'>IndexRecheck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <span class='Control'>return</span> <a href="execScan.c.html#LN119"><span class='Ref_to_Func'>ExecScan</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nodeIndexscan.c.html#LN538"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1141"><span class='Ref_to_Member'>ss</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/executor/executor.h.html#LN388"><span class='Ref_to_Typedef'>ExecScanAccessMtd</span></a><span class='Parentheses'>) </span><a href="nodeIndexscan.c.html#LN56"><span class='Ref_to_Proto'>IndexNext</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/executor/executor.h.html#LN389"><span class='Ref_to_Typedef'>ExecScanRecheckMtd</span></a><span class='Parentheses'>) </span><a href="nodeIndexscan.c.html#LN59"><span class='Ref_to_Proto'>IndexRecheck</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *      ExecReScanIndexScan(node) 
 * 
 *      Recalculates the values of any scan keys whose value depends on 
 *      information known at runtime, then rescans the indexed relation. 
 * 
 *      Updating the scan key was formerly done separately in 
 *      ExecUpdateIndexScanKeys. Integrating it into ReScan makes 
 *      rescans of indices and relations/general streams more uniform. 
 * ---------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN568"></a><span class='Declare_Function'>ExecReScanIndexScan</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1139"><span class='Ref_to_Struct'>IndexScanState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN570"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>reset_parallel_scan</span> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we are here to just update the scan keys, then don't reset parallel 
     * scan.  We don't want each of the participating process in the parallel 
     * scan to update the shared parallel scan state at the start of the scan. 
     * It is quite possible that one of the participants has already begun 
     * scanning the index when another has yet to start it. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN568"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1149"><span class='Ref_to_Member'>iss_NumRuntimeKeys</span></a> <span class='Operator'>!= </span><span class='Number'>0</span> <span class='Operator'>&& !</span><a href="nodeIndexscan.c.html#LN568"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1150"><span class='Ref_to_Member'>iss_RuntimeKeysReady</span></a><span class='Parentheses'>) 
</span>        <a href="nodeIndexscan.c.html#LN570"><span class='Ref_To_Local'>reset_parallel_scan</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we are doing runtime key calculations (ie, any of the index key 
     * values weren't simple Consts), compute the new key values.  But first, 
     * reset the context so we don't leak memory as each outer tuple is 
     * scanned.  Note this assumes that we will recalculate *all* runtime keys 
     * on each call. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN568"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1149"><span class='Ref_to_Member'>iss_NumRuntimeKeys</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN591"></a>        <a href="../../include/nodes/execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Local'>econtext</span> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN568"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1151"><span class='Ref_to_Member'>iss_RuntimeContext</span></a><span class='Delimiter'>; 
</span> 
        <a href="../../include/executor/executor.h.html#LN449"><span class='Ref_to_Macro'>ResetExprContext</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN591"><span class='Ref_To_Local'>econtext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/executor/nodeIndexscan.h.html#LN38"><span class='Ref_to_Proto'>ExecIndexEvalRuntimeKeys</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN591"><span class='Ref_To_Local'>econtext</span></a><span class='Delimiter'>, 
</span>                                 <a href="nodeIndexscan.c.html#LN568"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1148"><span class='Ref_to_Member'>iss_RuntimeKeys</span></a><span class='Delimiter'>, 
</span>                                 <a href="nodeIndexscan.c.html#LN568"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1149"><span class='Ref_to_Member'>iss_NumRuntimeKeys</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="nodeIndexscan.c.html#LN568"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1150"><span class='Ref_to_Member'>iss_RuntimeKeysReady</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* flush the reorder queue */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN568"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1156"><span class='Ref_to_Member'>iss_ReorderQueue</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>while</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/lib/pairingheap.h.html#LN95"><span class='Ref_to_Macro'>pairingheap_is_empty</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN568"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1156"><span class='Ref_to_Member'>iss_ReorderQueue</span></a><span class='Parentheses'>))</span> 
            <a href="nodeIndexscan.c.html#LN67"><span class='Ref_to_Proto'>reorderqueue_pop</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN568"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Reset (parallel) index scan.  For parallel-aware nodes, the scan 
     * descriptor is initialized during actual execution of node and we can 
     * reach here before that (ex. during execution of nest loop join).  So, 
     * avoid updating the scan descriptor at that time. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN568"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1153"><span class='Ref_to_Member'>iss_ScanDesc</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../include/access/genam.h.html#LN146"><span class='Ref_to_Proto'>index_rescan</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN568"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1153"><span class='Ref_to_Member'>iss_ScanDesc</span></a><span class='Delimiter'>, 
</span>                     <a href="nodeIndexscan.c.html#LN568"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1144"><span class='Ref_to_Member'>iss_ScanKeys</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN568"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1145"><span class='Ref_to_Member'>iss_NumScanKeys</span></a><span class='Delimiter'>, 
</span>                     <a href="nodeIndexscan.c.html#LN568"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1146"><span class='Ref_to_Member'>iss_OrderByKeys</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN568"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1147"><span class='Ref_to_Member'>iss_NumOrderByKeys</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN570"><span class='Ref_To_Local'>reset_parallel_scan</span></a> <span class='Operator'>&& </span><a href="nodeIndexscan.c.html#LN568"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1153"><span class='Ref_to_Member'>iss_ScanDesc</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/relscan.h.html#LN138"><span class='Ref_to_Member'>parallel_scan</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/access/genam.h.html#LN155"><span class='Ref_to_Proto'>index_parallelrescan</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN568"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1153"><span class='Ref_to_Member'>iss_ScanDesc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="nodeIndexscan.c.html#LN568"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1157"><span class='Ref_to_Member'>iss_ReachedEnd</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <a href="execScan.c.html#LN325"><span class='Ref_to_Func'>ExecScanReScan</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nodeIndexscan.c.html#LN568"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1141"><span class='Ref_to_Member'>ss</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ExecReScanIndexScan &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * ExecIndexEvalRuntimeKeys 
 *      Evaluate any runtime key values, and update the scankeys. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN633"></a><span class='Declare_Function'>ExecIndexEvalRuntimeKeys</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>econtext</span><span class='Delimiter'>, 
</span><a name="LN634"></a>                         <a href="../../include/nodes/execnodes.h.html#LN1096"><span class='Ref_to_Typedef'>IndexRuntimeKeyInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>runtimeKeys</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>numRuntimeKeys</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN636"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>j</span><span class='Delimiter'>; 
</span><a name="LN637"></a>    <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldContext</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* We want to keep the key values in per-tuple memory */ 
</span>    <a href="nodeIndexscan.c.html#LN637"><span class='Ref_To_Local'>oldContext</span></a> <span class='Operator'>= </span><a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN633"><span class='Ref_to_Parameter'>econtext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN202"><span class='Ref_to_Member'>ecxt_per_tuple_memory</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN636"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nodeIndexscan.c.html#LN636"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>&LT; </span><a href="nodeIndexscan.c.html#LN634"><span class='Ref_to_Parameter'>numRuntimeKeys</span></a><span class='Delimiter'>; </span><a href="nodeIndexscan.c.html#LN636"><span class='Ref_To_Local'>j</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN644"></a>        <a href="../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a>     <span class='Declare_Local'>scan_key</span> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN634"><span class='Ref_to_Parameter'>runtimeKeys</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN636"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1098"><span class='Ref_to_Member'>scan_key</span></a><span class='Delimiter'>; 
</span><a name="LN645"></a>        <a href="../../include/nodes/execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>key_expr</span> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN634"><span class='Ref_to_Parameter'>runtimeKeys</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN636"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1099"><span class='Ref_to_Member'>key_expr</span></a><span class='Delimiter'>; 
</span><a name="LN646"></a>        <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>scanvalue</span><span class='Delimiter'>; 
</span><a name="LN647"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>isNull</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * For each run-time key, extract the run-time expression and evaluate 
         * it with respect to the current context.  We then stick the result 
         * into the proper scan key. 
         * 
         * Note: the result of the eval could be a pass-by-ref value that's 
         * stored in some outer scan's tuple, not in 
         * econtext-&GT;ecxt_per_tuple_memory.  We assume that the outer tuple 
         * will stay put throughout our scan.  If this is wrong, we could copy 
         * the result into our context explicitly, but I think that's not 
         * necessary. 
         * 
         * It's also entirely possible that the result of the eval is a 
         * toasted value.  In this case we should forcibly detoast it, to 
         * avoid repeat detoastings each time the value is examined by an 
         * index support function. 
         */ 
</span>        <a href="nodeIndexscan.c.html#LN646"><span class='Ref_To_Local'>scanvalue</span></a> <span class='Operator'>= </span><a href="../../include/executor/executor.h.html#LN264"><span class='Ref_to_Func'>ExecEvalExpr</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN645"><span class='Ref_To_Local'>key_expr</span></a><span class='Delimiter'>, 
</span>                                 <a href="nodeIndexscan.c.html#LN633"><span class='Ref_to_Parameter'>econtext</span></a><span class='Delimiter'>, 
</span>                                 <span class='Operator'>&</span><a href="nodeIndexscan.c.html#LN647"><span class='Ref_To_Local'>isNull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN647"><span class='Ref_To_Local'>isNull</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="nodeIndexscan.c.html#LN644"><span class='Ref_To_Local'>scan_key</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/skey.h.html#LN71"><span class='Ref_to_Member'>sk_argument</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN646"><span class='Ref_To_Local'>scanvalue</span></a><span class='Delimiter'>; 
</span>            <a href="nodeIndexscan.c.html#LN644"><span class='Ref_To_Local'>scan_key</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>|= </span><a href="../../include/access/skey.h.html#LN114"><span class='Ref_to_Const'>SK_ISNULL</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN634"><span class='Ref_to_Parameter'>runtimeKeys</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN636"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1100"><span class='Ref_to_Member'>key_toastable</span></a><span class='Parentheses'>) 
</span>                <a href="nodeIndexscan.c.html#LN646"><span class='Ref_To_Local'>scanvalue</span></a> <span class='Operator'>= </span><a href="../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><a href="../../include/fmgr.h.html#LN204"><span class='Ref_to_Macro'>PG_DETOAST_DATUM</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN646"><span class='Ref_To_Local'>scanvalue</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="nodeIndexscan.c.html#LN644"><span class='Ref_To_Local'>scan_key</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/skey.h.html#LN71"><span class='Ref_to_Member'>sk_argument</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN646"><span class='Ref_To_Local'>scanvalue</span></a><span class='Delimiter'>; 
</span>            <a href="nodeIndexscan.c.html#LN644"><span class='Ref_To_Local'>scan_key</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>&= ~</span><a href="../../include/access/skey.h.html#LN114"><span class='Ref_to_Const'>SK_ISNULL</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for j=0;j&LT;numRuntimeKeys;... &raquo; </span> 
 
    <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN637"><span class='Ref_To_Local'>oldContext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ExecIndexEvalRuntimeKeys &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * ExecIndexEvalArrayKeys 
 *      Evaluate any array key values, and set up to iterate through arrays. 
 * 
 * Returns TRUE if there are array elements to consider; FALSE means there 
 * is at least one null or empty array, so no match is possible.  On TRUE 
 * result, the scankeys are initialized with the first elements of the arrays. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN695"></a><span class='Declare_Function'>ExecIndexEvalArrayKeys</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>econtext</span><span class='Delimiter'>, 
</span><a name="LN696"></a>                       <a href="../../include/nodes/execnodes.h.html#LN1103"><span class='Ref_to_Typedef'>IndexArrayKeyInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>arrayKeys</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>numArrayKeys</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN698"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>result</span> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span><a name="LN699"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>j</span><span class='Delimiter'>; 
</span><a name="LN700"></a>    <a href="../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldContext</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* We want to keep the arrays in per-tuple memory */ 
</span>    <a href="nodeIndexscan.c.html#LN700"><span class='Ref_To_Local'>oldContext</span></a> <span class='Operator'>= </span><a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN695"><span class='Ref_to_Parameter'>econtext</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN202"><span class='Ref_to_Member'>ecxt_per_tuple_memory</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN699"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nodeIndexscan.c.html#LN699"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>&LT; </span><a href="nodeIndexscan.c.html#LN696"><span class='Ref_to_Parameter'>numArrayKeys</span></a><span class='Delimiter'>; </span><a href="nodeIndexscan.c.html#LN699"><span class='Ref_To_Local'>j</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN707"></a>        <a href="../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a>     <span class='Declare_Local'>scan_key</span> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN696"><span class='Ref_to_Parameter'>arrayKeys</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN699"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1105"><span class='Ref_to_Member'>scan_key</span></a><span class='Delimiter'>; 
</span><a name="LN708"></a>        <a href="../../include/nodes/execnodes.h.html#LN52"><span class='Ref_to_Struct'>ExprState</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>array_expr</span> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN696"><span class='Ref_to_Parameter'>arrayKeys</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN699"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1106"><span class='Ref_to_Member'>array_expr</span></a><span class='Delimiter'>; 
</span><a name="LN709"></a>        <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>arraydatum</span><span class='Delimiter'>; 
</span><a name="LN710"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>isNull</span><span class='Delimiter'>; 
</span><a name="LN711"></a>        <a href="../../include/utils/array.h.html#LN75"><span class='Ref_to_Typedef'>ArrayType</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>arrayval</span><span class='Delimiter'>; 
</span><a name="LN712"></a>        <a href="../../include/c.h.html#LN254"><span class='Ref_to_Typedef'>int16</span></a>       <span class='Declare_Local'>elmlen</span><span class='Delimiter'>; 
</span><a name="LN713"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>elmbyval</span><span class='Delimiter'>; 
</span><a name="LN714"></a>        <span class='Keyword'>char</span>        <span class='Declare_Local'>elmalign</span><span class='Delimiter'>; 
</span><a name="LN715"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>num_elems</span><span class='Delimiter'>; 
</span><a name="LN716"></a>        <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>elem_values</span><span class='Delimiter'>; 
</span><a name="LN717"></a>        <span class='Keyword'>bool</span>       <span class='Operator'>*</span><span class='Declare_Local'>elem_nulls</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Compute and deconstruct the array expression. (Notes in 
         * ExecIndexEvalRuntimeKeys() apply here too.) 
         */ 
</span>        <a href="nodeIndexscan.c.html#LN709"><span class='Ref_To_Local'>arraydatum</span></a> <span class='Operator'>= </span><a href="../../include/executor/executor.h.html#LN264"><span class='Ref_to_Func'>ExecEvalExpr</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN708"><span class='Ref_To_Local'>array_expr</span></a><span class='Delimiter'>, 
</span>                                  <a href="nodeIndexscan.c.html#LN695"><span class='Ref_to_Parameter'>econtext</span></a><span class='Delimiter'>, 
</span>                                  <span class='Operator'>&</span><a href="nodeIndexscan.c.html#LN710"><span class='Ref_To_Local'>isNull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN710"><span class='Ref_To_Local'>isNull</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="nodeIndexscan.c.html#LN698"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>;</span>              <span class='Comment_Single_Line'>/* no point in evaluating more */ 
</span>        <span class='Delimiter'>} 
</span>        <a href="nodeIndexscan.c.html#LN711"><span class='Ref_To_Local'>arrayval</span></a> <span class='Operator'>= </span><a href="../../include/utils/array.h.html#LN241"><span class='Ref_to_Macro'>DatumGetArrayTypeP</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN709"><span class='Ref_To_Local'>arraydatum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* We could cache this data, but not clear it's worth it */ 
</span>        <a href="../../include/utils/lsyscache.h.html#LN136"><span class='Ref_to_Proto'>get_typlenbyvalalign</span></a><span class='Parentheses'>(</span><a href="../../include/utils/array.h.html#LN272"><span class='Ref_to_Macro'>ARR_ELEMTYPE</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN711"><span class='Ref_To_Local'>arrayval</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                             <span class='Operator'>&</span><a href="nodeIndexscan.c.html#LN712"><span class='Ref_To_Local'>elmlen</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nodeIndexscan.c.html#LN713"><span class='Ref_To_Local'>elmbyval</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nodeIndexscan.c.html#LN714"><span class='Ref_To_Local'>elmalign</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../include/utils/array.h.html#LN382"><span class='Ref_to_Proto'>deconstruct_array</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN711"><span class='Ref_To_Local'>arrayval</span></a><span class='Delimiter'>, 
</span>                          <a href="../../include/utils/array.h.html#LN272"><span class='Ref_to_Macro'>ARR_ELEMTYPE</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN711"><span class='Ref_To_Local'>arrayval</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                          <a href="nodeIndexscan.c.html#LN712"><span class='Ref_To_Local'>elmlen</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN713"><span class='Ref_To_Local'>elmbyval</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN714"><span class='Ref_To_Local'>elmalign</span></a><span class='Delimiter'>, 
</span>                          <span class='Operator'>&</span><a href="nodeIndexscan.c.html#LN716"><span class='Ref_To_Local'>elem_values</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nodeIndexscan.c.html#LN717"><span class='Ref_To_Local'>elem_nulls</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nodeIndexscan.c.html#LN715"><span class='Ref_To_Local'>num_elems</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN715"><span class='Ref_To_Local'>num_elems</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="nodeIndexscan.c.html#LN698"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>;</span>              <span class='Comment_Single_Line'>/* no point in evaluating more */ 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Note: we expect the previous array data, if any, to be 
         * automatically freed by resetting the per-tuple context; hence no 
         * pfree's here. 
         */ 
</span>        <a href="nodeIndexscan.c.html#LN696"><span class='Ref_to_Parameter'>arrayKeys</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN699"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1109"><span class='Ref_to_Member'>elem_values</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN716"><span class='Ref_To_Local'>elem_values</span></a><span class='Delimiter'>; 
</span>        <a href="nodeIndexscan.c.html#LN696"><span class='Ref_to_Parameter'>arrayKeys</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN699"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1110"><span class='Ref_to_Member'>elem_nulls</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN717"><span class='Ref_To_Local'>elem_nulls</span></a><span class='Delimiter'>; 
</span>        <a href="nodeIndexscan.c.html#LN696"><span class='Ref_to_Parameter'>arrayKeys</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN699"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1108"><span class='Ref_to_Member'>num_elems</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN715"><span class='Ref_To_Local'>num_elems</span></a><span class='Delimiter'>; 
</span>        <a href="nodeIndexscan.c.html#LN707"><span class='Ref_To_Local'>scan_key</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/skey.h.html#LN71"><span class='Ref_to_Member'>sk_argument</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN716"><span class='Ref_To_Local'>elem_values</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN717"><span class='Ref_To_Local'>elem_nulls</span></a><span class='Delimiter'>[</span><span class='Number'>0</span><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>            <a href="nodeIndexscan.c.html#LN707"><span class='Ref_To_Local'>scan_key</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>|= </span><a href="../../include/access/skey.h.html#LN114"><span class='Ref_to_Const'>SK_ISNULL</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="nodeIndexscan.c.html#LN707"><span class='Ref_To_Local'>scan_key</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>&= ~</span><a href="../../include/access/skey.h.html#LN114"><span class='Ref_to_Const'>SK_ISNULL</span></a><span class='Delimiter'>; 
</span>        <a href="nodeIndexscan.c.html#LN696"><span class='Ref_to_Parameter'>arrayKeys</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN699"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1107"><span class='Ref_to_Member'>next_elem</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for j=0;j&LT;numArrayKeys;j+... &raquo; </span> 
 
    <a href="../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN700"><span class='Ref_To_Local'>oldContext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="nodeIndexscan.c.html#LN698"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ExecIndexEvalArrayKeys &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * ExecIndexAdvanceArrayKeys 
 *      Advance to the next set of array key values, if any. 
 * 
 * Returns TRUE if there is another set of values to consider, FALSE if not. 
 * On TRUE result, the scankeys are initialized with the next set of values. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN774"></a><span class='Declare_Function'>ExecIndexAdvanceArrayKeys</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1103"><span class='Ref_to_Typedef'>IndexArrayKeyInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>arrayKeys</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>numArrayKeys</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN776"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>found</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN777"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>j</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Note we advance the rightmost array key most quickly, since it will 
     * correspond to the lowest-order index column among the available 
     * qualifications.  This is hypothesized to result in better locality of 
     * access in the index. 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN777"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN774"><span class='Ref_to_Parameter'>numArrayKeys</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="nodeIndexscan.c.html#LN777"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nodeIndexscan.c.html#LN777"><span class='Ref_To_Local'>j</span></a><span class='Operator'>--</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN787"></a>        <a href="../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a>     <span class='Declare_Local'>scan_key</span> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN774"><span class='Ref_to_Parameter'>arrayKeys</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN777"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1105"><span class='Ref_to_Member'>scan_key</span></a><span class='Delimiter'>; 
</span><a name="LN788"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>next_elem</span> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN774"><span class='Ref_to_Parameter'>arrayKeys</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN777"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1107"><span class='Ref_to_Member'>next_elem</span></a><span class='Delimiter'>; 
</span><a name="LN789"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>num_elems</span> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN774"><span class='Ref_to_Parameter'>arrayKeys</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN777"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1108"><span class='Ref_to_Member'>num_elems</span></a><span class='Delimiter'>; 
</span><a name="LN790"></a>        <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>elem_values</span> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN774"><span class='Ref_to_Parameter'>arrayKeys</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN777"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1109"><span class='Ref_to_Member'>elem_values</span></a><span class='Delimiter'>; 
</span><a name="LN791"></a>        <span class='Keyword'>bool</span>       <span class='Operator'>*</span><span class='Declare_Local'>elem_nulls</span> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN774"><span class='Ref_to_Parameter'>arrayKeys</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN777"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1110"><span class='Ref_to_Member'>elem_nulls</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN788"><span class='Ref_To_Local'>next_elem</span></a> <span class='Operator'>&GT;= </span><a href="nodeIndexscan.c.html#LN789"><span class='Ref_To_Local'>num_elems</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="nodeIndexscan.c.html#LN788"><span class='Ref_To_Local'>next_elem</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <a href="nodeIndexscan.c.html#LN776"><span class='Ref_To_Local'>found</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* need to advance next array key */ 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
            <a href="nodeIndexscan.c.html#LN776"><span class='Ref_To_Local'>found</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <a href="nodeIndexscan.c.html#LN787"><span class='Ref_To_Local'>scan_key</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/skey.h.html#LN71"><span class='Ref_to_Member'>sk_argument</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN790"><span class='Ref_To_Local'>elem_values</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN788"><span class='Ref_To_Local'>next_elem</span></a><span class='Delimiter'>]; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN791"><span class='Ref_To_Local'>elem_nulls</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN788"><span class='Ref_To_Local'>next_elem</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>            <a href="nodeIndexscan.c.html#LN787"><span class='Ref_To_Local'>scan_key</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>|= </span><a href="../../include/access/skey.h.html#LN114"><span class='Ref_to_Const'>SK_ISNULL</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="nodeIndexscan.c.html#LN787"><span class='Ref_To_Local'>scan_key</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>&= ~</span><a href="../../include/access/skey.h.html#LN114"><span class='Ref_to_Const'>SK_ISNULL</span></a><span class='Delimiter'>; 
</span>        <a href="nodeIndexscan.c.html#LN774"><span class='Ref_to_Parameter'>arrayKeys</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN777"><span class='Ref_To_Local'>j</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1107"><span class='Ref_to_Member'>next_elem</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN788"><span class='Ref_To_Local'>next_elem</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN776"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for j=numArrayKeys-1;j&GT;=0... &raquo; </span> 
 
    <span class='Control'>return</span> <a href="nodeIndexscan.c.html#LN776"><span class='Ref_To_Local'>found</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ExecIndexAdvanceArrayKeys &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *      ExecEndIndexScan 
 * ---------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN819"></a><span class='Declare_Function'>ExecEndIndexScan</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1139"><span class='Ref_to_Struct'>IndexScanState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN821"></a>    <a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>indexRelationDesc</span><span class='Delimiter'>; 
</span><a name="LN822"></a>    <a href="../../include/access/genam.h.html#LN85"><span class='Ref_to_Typedef'>IndexScanDesc</span></a> <span class='Declare_Local'>indexScanDesc</span><span class='Delimiter'>; 
</span><a name="LN823"></a>    <a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>relation</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * extract information from the node 
     */ 
</span>    <a href="nodeIndexscan.c.html#LN821"><span class='Ref_To_Local'>indexRelationDesc</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN819"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1152"><span class='Ref_to_Member'>iss_RelationDesc</span></a><span class='Delimiter'>; 
</span>    <a href="nodeIndexscan.c.html#LN822"><span class='Ref_To_Local'>indexScanDesc</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN819"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1153"><span class='Ref_to_Member'>iss_ScanDesc</span></a><span class='Delimiter'>; 
</span>    <a href="nodeIndexscan.c.html#LN823"><span class='Ref_To_Local'>relation</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN819"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1141"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1058"><span class='Ref_to_Member'>ss_currentRelation</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Free the exprcontext(s) ... now dead code, see ExecFreeExprContext 
     */ 
</span><span class='Directive'>#ifdef</span> NOT_USED 
    <a href="../../include/executor/executor.h.html#LN476"><span class='Ref_to_Proto'>ExecFreeExprContext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nodeIndexscan.c.html#LN819"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1141"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN819"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1151"><span class='Ref_to_Member'>iss_RuntimeContext</span></a><span class='Parentheses'>) 
</span>        <a href="execUtils.c.html#LN347"><span class='Ref_to_Func'>FreeExprContext</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN819"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1151"><span class='Ref_to_Member'>iss_RuntimeContext</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
    <span class='Comment_Multi_Line'>/* 
     * clear out tuple table slots 
     */ 
</span>    <a href="../../include/executor/tuptable.h.html#LN154"><span class='Ref_to_Proto'>ExecClearTuple</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN819"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1141"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN841"><span class='Ref_to_Member'>ps_ResultTupleSlot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/executor/tuptable.h.html#LN154"><span class='Ref_to_Proto'>ExecClearTuple</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN819"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1141"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1060"><span class='Ref_to_Member'>ss_ScanTupleSlot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * close the index relation (no-op if we didn't open it) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN822"><span class='Ref_To_Local'>indexScanDesc</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/access/genam.h.html#LN149"><span class='Ref_to_Proto'>index_endscan</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN822"><span class='Ref_To_Local'>indexScanDesc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN821"><span class='Ref_To_Local'>indexRelationDesc</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/access/genam.h.html#LN130"><span class='Ref_to_Proto'>index_close</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN821"><span class='Ref_To_Local'>indexRelationDesc</span></a><span class='Delimiter'>, </span><a href="../../include/storage/lockdefs.h.html#LN33"><span class='Ref_to_Const'>NoLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * close the heap relation. 
     */ 
</span>    <a href="../../include/executor/executor.h.html#LN483"><span class='Ref_to_Proto'>ExecCloseScanRelation</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN823"><span class='Ref_To_Local'>relation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ExecEndIndexScan &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *      ExecIndexMarkPos 
 * ---------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN866"></a><span class='Declare_Function'>ExecIndexMarkPos</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1139"><span class='Ref_to_Struct'>IndexScanState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../include/access/genam.h.html#LN150"><span class='Ref_to_Proto'>index_markpos</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN866"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1153"><span class='Ref_to_Member'>iss_ScanDesc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *      ExecIndexRestrPos 
 * ---------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN876"></a><span class='Declare_Function'>ExecIndexRestrPos</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1139"><span class='Ref_to_Struct'>IndexScanState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../include/access/genam.h.html#LN151"><span class='Ref_to_Proto'>index_restrpos</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN876"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1153"><span class='Ref_to_Member'>iss_ScanDesc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *      ExecInitIndexScan 
 * 
 *      Initializes the index scan's state information, creates 
 *      scan keys, and opens the base and index relations. 
 * 
 *      Note: index scans have 2 sets of state information because 
 *            we have to keep track of the base relation and the 
 *            index relation. 
 * ---------------------------------------------------------------- 
 */ 
</span><a href="../../include/nodes/execnodes.h.html#LN1139"><span class='Ref_to_Struct'>IndexScanState</span></a> <span class='Operator'>* 
</span><a name="LN893"></a><span class='Declare_Function'>ExecInitIndexScan</span><span class='Parentheses'>(</span><a href="../../include/nodes/plannodes.h.html#LN385"><span class='Ref_to_Struct'>IndexScan</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><a href="../../include/nodes/execnodes.h.html#LN402"><span class='Ref_to_Struct'>EState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>estate</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>eflags</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN895"></a>    <a href="../../include/nodes/execnodes.h.html#LN1139"><span class='Ref_to_Struct'>IndexScanState</span></a> <span class='Operator'>*</span><span class='Declare_Local'>indexstate</span><span class='Delimiter'>; 
</span><a name="LN896"></a>    <a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a>    <span class='Declare_Local'>currentRelation</span><span class='Delimiter'>; 
</span><a name="LN897"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>relistarget</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * create state structure 
     */ 
</span>    <a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1139"><span class='Ref_to_Struct'>IndexScanState</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1141"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN812"><span class='Ref_to_Member'>plan</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeIndexscan.c.html#LN893"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span>    <a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1141"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN814"><span class='Ref_to_Member'>state</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN893"><span class='Ref_to_Parameter'>estate</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Miscellaneous initialization 
     * 
     * create expression context for node 
     */ 
</span>    <a href="execUtils.c.html#LN416"><span class='Ref_to_Func'>ExecAssignExprContext</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN893"><span class='Ref_to_Parameter'>estate</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1141"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * initialize child expressions 
     * 
     * Note: we don't initialize all of the indexqual expression, only the 
     * sub-parts corresponding to runtime keys (see below).  Likewise for 
     * indexorderby, if any.  But the indexqualorig expression is always 
     * initialized even though it will only be used in some uncommon cases --- 
     * would be nice to improve that.  (Problem is that any SubPlans present 
     * in the expression must be found now...) 
     */ 
</span>    <a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1141"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN826"><span class='Ref_to_Member'>qual</span></a> <span class='Operator'>= 
</span>        <a href="execExpr.c.html#LN158"><span class='Ref_to_Func'>ExecInitQual</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN893"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN387"><span class='Ref_to_Member'>scan</span></a><span class='Operator'>.</span><a href="../../include/nodes/plannodes.h.html#LN327"><span class='Ref_to_Member'>plan</span></a><span class='Operator'>.</span><a href="../../include/nodes/plannodes.h.html#LN144"><span class='Ref_to_Member'>qual</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1142"><span class='Ref_to_Member'>indexqualorig</span></a> <span class='Operator'>= 
</span>        <a href="execExpr.c.html#LN158"><span class='Ref_to_Func'>ExecInitQual</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN893"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN390"><span class='Ref_to_Member'>indexqualorig</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1143"><span class='Ref_to_Member'>indexorderbyorig</span></a> <span class='Operator'>= 
</span>        <a href="../../include/executor/executor.h.html#LN240"><span class='Ref_to_Proto'>ExecInitExprList</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN893"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN392"><span class='Ref_to_Member'>indexorderbyorig</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * tuple table initialization 
     */ 
</span>    <a href="../../include/executor/executor.h.html#LN400"><span class='Ref_to_Proto'>ExecInitResultTupleSlot</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN893"><span class='Ref_to_Parameter'>estate</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1141"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/executor/executor.h.html#LN401"><span class='Ref_to_Proto'>ExecInitScanTupleSlot</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN893"><span class='Ref_to_Parameter'>estate</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1141"><span class='Ref_to_Member'>ss</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * open the base relation and acquire appropriate lock on it. 
     */ 
</span>    <a href="nodeIndexscan.c.html#LN896"><span class='Ref_To_Local'>currentRelation</span></a> <span class='Operator'>= </span><a href="../../include/executor/executor.h.html#LN482"><span class='Ref_to_Proto'>ExecOpenScanRelation</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN893"><span class='Ref_to_Parameter'>estate</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN893"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN387"><span class='Ref_to_Member'>scan</span></a><span class='Operator'>.</span><a href="../../include/nodes/plannodes.h.html#LN328"><span class='Ref_to_Member'>scanrelid</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN893"><span class='Ref_to_Parameter'>eflags</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1141"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1058"><span class='Ref_to_Member'>ss_currentRelation</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN896"><span class='Ref_To_Local'>currentRelation</span></a><span class='Delimiter'>; 
</span>    <a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1141"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1059"><span class='Ref_to_Member'>ss_currentScanDesc</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* no heap scan here */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * get the scan type from the relation descriptor. 
     */ 
</span>    <a href="../../include/executor/executor.h.html#LN477"><span class='Ref_to_Proto'>ExecAssignScanType</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1141"><span class='Ref_to_Member'>ss</span></a><span class='Delimiter'>, </span><a href="../../include/utils/rel.h.html#LN428"><span class='Ref_to_Macro'>RelationGetDescr</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN896"><span class='Ref_To_Local'>currentRelation</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Initialize result tuple type and projection info. 
     */ 
</span>    <a href="execUtils.c.html#LN438"><span class='Ref_to_Func'>ExecAssignResultTypeFromTL</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1141"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="execScan.c.html#LN233"><span class='Ref_to_Func'>ExecAssignScanProjectionInfo</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1141"><span class='Ref_to_Member'>ss</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we are just doing EXPLAIN (ie, aren't going to run the plan), stop 
     * here.  This allows an index-advisor plugin to EXPLAIN a plan containing 
     * references to nonexistent indexes. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN893"><span class='Ref_to_Parameter'>eflags</span></a> <span class='Operator'>& </span><a href="../../include/executor/executor.h.html#LN57"><span class='Ref_to_Const'>EXEC_FLAG_EXPLAIN_ONLY</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Open the index relation. 
     * 
     * If the parent table is one of the target relations of the query, then 
     * InitPlan already opened and write-locked the index, so we can avoid 
     * taking another lock here.  Otherwise we need a normal reader's lock. 
     */ 
</span>    <a href="nodeIndexscan.c.html#LN897"><span class='Ref_To_Local'>relistarget</span></a> <span class='Operator'>= </span><a href="../../include/executor/executor.h.html#LN480"><span class='Ref_to_Proto'>ExecRelationIsTargetRelation</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN893"><span class='Ref_to_Parameter'>estate</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN893"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN387"><span class='Ref_to_Member'>scan</span></a><span class='Operator'>.</span><a href="../../include/nodes/plannodes.h.html#LN328"><span class='Ref_to_Member'>scanrelid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1152"><span class='Ref_to_Member'>iss_RelationDesc</span></a> <span class='Operator'>= </span><a href="../../include/access/genam.h.html#LN129"><span class='Ref_to_Proto'>index_open</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN893"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN388"><span class='Ref_to_Member'>indexid</span></a><span class='Delimiter'>, 
</span>                                     <a href="nodeIndexscan.c.html#LN897"><span class='Ref_To_Local'>relistarget</span></a> <span class='Operator'>? </span><a href="../../include/storage/lockdefs.h.html#LN33"><span class='Ref_to_Const'>NoLock</span></a> <span class='Operator'>: </span><a href="../../include/storage/lockdefs.h.html#LN35"><span class='Ref_to_Const'>AccessShareLock</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Initialize index-specific scan state 
     */ 
</span>    <a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1150"><span class='Ref_to_Member'>iss_RuntimeKeysReady</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1148"><span class='Ref_to_Member'>iss_RuntimeKeys</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1149"><span class='Ref_to_Member'>iss_NumRuntimeKeys</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * build the index scan keys from the index qualification 
     */ 
</span>    <a href="../../include/executor/nodeIndexscan.h.html#LN33"><span class='Ref_to_Proto'>ExecIndexBuildScanKeys</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Delimiter'>, 
</span>                           <a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1152"><span class='Ref_to_Member'>iss_RelationDesc</span></a><span class='Delimiter'>, 
</span>                           <a href="nodeIndexscan.c.html#LN893"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN389"><span class='Ref_to_Member'>indexqual</span></a><span class='Delimiter'>, 
</span>                           <span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                           <span class='Operator'>&</span><a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1144"><span class='Ref_to_Member'>iss_ScanKeys</span></a><span class='Delimiter'>, 
</span>                           <span class='Operator'>&</span><a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1145"><span class='Ref_to_Member'>iss_NumScanKeys</span></a><span class='Delimiter'>, 
</span>                           <span class='Operator'>&</span><a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1148"><span class='Ref_to_Member'>iss_RuntimeKeys</span></a><span class='Delimiter'>, 
</span>                           <span class='Operator'>&</span><a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1149"><span class='Ref_to_Member'>iss_NumRuntimeKeys</span></a><span class='Delimiter'>, 
</span>                           <span class='Null_Value'>NULL</span><span class='Delimiter'>,</span>    <span class='Comment_Single_Line'>/* no ArrayKeys */ 
</span>                           <span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * any ORDER BY exprs have to be turned into scankeys in the same way 
     */ 
</span>    <a href="../../include/executor/nodeIndexscan.h.html#LN33"><span class='Ref_to_Proto'>ExecIndexBuildScanKeys</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Delimiter'>, 
</span>                           <a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1152"><span class='Ref_to_Member'>iss_RelationDesc</span></a><span class='Delimiter'>, 
</span>                           <a href="nodeIndexscan.c.html#LN893"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN391"><span class='Ref_to_Member'>indexorderby</span></a><span class='Delimiter'>, 
</span>                           <span class='Boolean'>true</span><span class='Delimiter'>, 
</span>                           <span class='Operator'>&</span><a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1146"><span class='Ref_to_Member'>iss_OrderByKeys</span></a><span class='Delimiter'>, 
</span>                           <span class='Operator'>&</span><a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1147"><span class='Ref_to_Member'>iss_NumOrderByKeys</span></a><span class='Delimiter'>, 
</span>                           <span class='Operator'>&</span><a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1148"><span class='Ref_to_Member'>iss_RuntimeKeys</span></a><span class='Delimiter'>, 
</span>                           <span class='Operator'>&</span><a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1149"><span class='Ref_to_Member'>iss_NumRuntimeKeys</span></a><span class='Delimiter'>, 
</span>                           <span class='Null_Value'>NULL</span><span class='Delimiter'>,</span>    <span class='Comment_Single_Line'>/* no ArrayKeys */ 
</span>                           <span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Initialize sort support, if we need to re-check ORDER BY exprs */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1147"><span class='Ref_to_Member'>iss_NumOrderByKeys</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1012"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>numOrderByKeys</span> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1147"><span class='Ref_to_Member'>iss_NumOrderByKeys</span></a><span class='Delimiter'>; 
</span><a name="LN1013"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span><a name="LN1014"></a>        <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lco</span><span class='Delimiter'>; 
</span><a name="LN1015"></a>        <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lcx</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Prepare sort support, and look up the data type for each ORDER BY 
         * expression. 
         */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1012"><span class='Ref_To_Local'>numOrderByKeys</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN893"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN393"><span class='Ref_to_Member'>indexorderbyops</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1012"><span class='Ref_To_Local'>numOrderByKeys</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN893"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN392"><span class='Ref_to_Member'>indexorderbyorig</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1160"><span class='Ref_to_Member'>iss_SortSupport</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/utils/sortsupport.h.html#LN59"><span class='Ref_to_Struct'>SortSupportData</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>            <a href="../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1012"><span class='Ref_To_Local'>numOrderByKeys</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/utils/sortsupport.h.html#LN59"><span class='Ref_to_Struct'>SortSupportData</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1161"><span class='Ref_to_Member'>iss_OrderByTypByVals</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Parentheses'>) 
</span>            <a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1012"><span class='Ref_To_Local'>numOrderByKeys</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>bool</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1162"><span class='Ref_to_Member'>iss_OrderByTypLens</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN254"><span class='Ref_to_Typedef'>int16</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>            <a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1012"><span class='Ref_To_Local'>numOrderByKeys</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/c.h.html#LN254"><span class='Ref_to_Typedef'>int16</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="nodeIndexscan.c.html#LN1013"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="../../include/nodes/pg_list.h.html#LN179"><span class='Ref_to_Macro'>forboth</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1014"><span class='Ref_To_Local'>lco</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN893"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN393"><span class='Ref_to_Member'>indexorderbyops</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN1015"><span class='Ref_To_Local'>lcx</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN893"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN392"><span class='Ref_to_Member'>indexorderbyorig</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1032"></a>            <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>orderbyop</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN107"><span class='Ref_to_Macro'>lfirst_oid</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1014"><span class='Ref_To_Local'>lco</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1033"></a>            <a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>orderbyexpr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1015"><span class='Ref_To_Local'>lcx</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1034"></a>            <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>orderbyType</span> <span class='Operator'>= </span><a href="../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1033"><span class='Ref_To_Local'>orderbyexpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1035"></a>            <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>orderbyColl</span> <span class='Operator'>= </span><a href="../../include/nodes/nodeFuncs.h.html#LN38"><span class='Ref_to_Proto'>exprCollation</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1033"><span class='Ref_To_Local'>orderbyexpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1036"></a>            <a href="../../include/utils/sortsupport.h.html#LN57"><span class='Ref_to_Typedef'>SortSupport</span></a> <span class='Declare_Local'>orderbysort</span> <span class='Operator'>= &</span><a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1160"><span class='Ref_to_Member'>iss_SortSupport</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN1013"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]; 
</span> 
            <span class='Comment_Multi_Line'>/* Initialize sort support */ 
</span>            <a href="nodeIndexscan.c.html#LN1036"><span class='Ref_To_Local'>orderbysort</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/sortsupport.h.html#LN65"><span class='Ref_to_Member'>ssup_cxt</span></a> <span class='Operator'>= </span><a href="../utils/mmgr/mcxt.c.html#LN36"><span class='Ref_to_Global_Var'>CurrentMemoryContext</span></a><span class='Delimiter'>; 
</span>            <a href="nodeIndexscan.c.html#LN1036"><span class='Ref_To_Local'>orderbysort</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/sortsupport.h.html#LN66"><span class='Ref_to_Member'>ssup_collation</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN1035"><span class='Ref_To_Local'>orderbyColl</span></a><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* See cmp_orderbyvals() comments on NULLS LAST */ 
</span>            <a href="nodeIndexscan.c.html#LN1036"><span class='Ref_To_Local'>orderbysort</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/sortsupport.h.html#LN74"><span class='Ref_to_Member'>ssup_nulls_first</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* ssup_attno is unused here and elsewhere */ 
</span>            <a href="nodeIndexscan.c.html#LN1036"><span class='Ref_To_Local'>orderbysort</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/sortsupport.h.html#LN80"><span class='Ref_to_Member'>ssup_attno</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* No abbreviation */ 
</span>            <a href="nodeIndexscan.c.html#LN1036"><span class='Ref_To_Local'>orderbysort</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/sortsupport.h.html#LN155"><span class='Ref_to_Member'>abbreviate</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="../utils/sort/sortsupport.c.html#LN131"><span class='Ref_to_Func'>PrepareSortSupportFromOrderingOp</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1032"><span class='Ref_To_Local'>orderbyop</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN1036"><span class='Ref_To_Local'>orderbysort</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="../../include/utils/lsyscache.h.html#LN135"><span class='Ref_to_Proto'>get_typlenbyval</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1034"><span class='Ref_To_Local'>orderbyType</span></a><span class='Delimiter'>, 
</span>                            <span class='Operator'>&</span><a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1162"><span class='Ref_to_Member'>iss_OrderByTypLens</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN1013"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], 
</span>                            <span class='Operator'>&</span><a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1161"><span class='Ref_to_Member'>iss_OrderByTypByVals</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN1013"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="nodeIndexscan.c.html#LN1013"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* allocate arrays to hold the re-calculated distances */ 
</span>        <a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1158"><span class='Ref_to_Member'>iss_OrderByValues</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>            <a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1012"><span class='Ref_To_Local'>numOrderByKeys</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1159"><span class='Ref_to_Member'>iss_OrderByNulls</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Parentheses'>) 
</span>            <a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1012"><span class='Ref_To_Local'>numOrderByKeys</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>bool</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* and initialize the reorder queue */ 
</span>        <a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1156"><span class='Ref_to_Member'>iss_ReorderQueue</span></a> <span class='Operator'>= </span><a href="../lib/pairingheap.c.html#LN40"><span class='Ref_to_Func'>pairingheap_allocate</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN63"><span class='Ref_to_Proto'>reorderqueue_cmp</span></a><span class='Delimiter'>, 
</span>                                                            <a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if indexstate-&GT;iss_NumOr... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * If we have runtime keys, we need an ExprContext to evaluate them. The 
     * node's standard context won't do because we want to reset that context 
     * for every tuple.  So, build another context just like the other one... 
     * -tgl 7/11/00 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1149"><span class='Ref_to_Member'>iss_NumRuntimeKeys</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1074"></a>        <a href="../../include/nodes/execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Local'>stdecontext</span> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1141"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN842"><span class='Ref_to_Member'>ps_ExprContext</span></a><span class='Delimiter'>; 
</span> 
        <a href="execUtils.c.html#LN416"><span class='Ref_to_Func'>ExecAssignExprContext</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN893"><span class='Ref_to_Parameter'>estate</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1141"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1151"><span class='Ref_to_Member'>iss_RuntimeContext</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1141"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN842"><span class='Ref_to_Member'>ps_ExprContext</span></a><span class='Delimiter'>; 
</span>        <a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1141"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN842"><span class='Ref_to_Member'>ps_ExprContext</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN1074"><span class='Ref_To_Local'>stdecontext</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1151"><span class='Ref_to_Member'>iss_RuntimeContext</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * all done. 
     */ 
</span>    <span class='Control'>return</span> <a href="nodeIndexscan.c.html#LN895"><span class='Ref_To_Local'>indexstate</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ExecInitIndexScan &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * ExecIndexBuildScanKeys 
 *      Build the index scan keys from the index qualification expressions 
 * 
 * The index quals are passed to the index AM in the form of a ScanKey array. 
 * This routine sets up the ScanKeys, fills in all constant fields of the 
 * ScanKeys, and prepares information about the keys that have non-constant 
 * comparison values.  We divide index qual expressions into five types: 
 * 
 * 1. Simple operator with constant comparison value ("indexkey op constant"). 
 * For these, we just fill in a ScanKey containing the constant value. 
 * 
 * 2. Simple operator with non-constant value ("indexkey op expression"). 
 * For these, we create a ScanKey with everything filled in except the 
 * expression value, and set up an IndexRuntimeKeyInfo struct to drive 
 * evaluation of the expression at the right times. 
 * 
 * 3. RowCompareExpr ("(indexkey, indexkey, ...) op (expr, expr, ...)"). 
 * For these, we create a header ScanKey plus a subsidiary ScanKey array, 
 * as specified in access/skey.h.  The elements of the row comparison 
 * can have either constant or non-constant comparison values. 
 * 
 * 4. ScalarArrayOpExpr ("indexkey op ANY (array-expression)").  If the index 
 * supports amsearcharray, we handle these the same as simple operators, 
 * setting the SK_SEARCHARRAY flag to tell the AM to handle them.  Otherwise, 
 * we create a ScanKey with everything filled in except the comparison value, 
 * and set up an IndexArrayKeyInfo struct to drive processing of the qual. 
 * (Note that if we use an IndexArrayKeyInfo struct, the array expression is 
 * always treated as requiring runtime evaluation, even if it's a constant.) 
 * 
 * 5. NullTest ("indexkey IS NULL/IS NOT NULL").  We just fill in the 
 * ScanKey properly. 
 * 
 * This code is also used to prepare ORDER BY expressions for amcanorderbyop 
 * indexes.  The behavior is exactly the same, except that we have to look up 
 * the operator differently.  Note that only cases 1 and 2 are currently 
 * possible for ORDER BY. 
 * 
 * Input params are: 
 * 
 * planstate: executor state node we are working for 
 * index: the index we are building scan keys for 
 * quals: indexquals (or indexorderbys) expressions 
 * isorderby: true if processing ORDER BY exprs, false if processing quals 
 * *runtimeKeys: ptr to pre-existing IndexRuntimeKeyInfos, or NULL if none 
 * *numRuntimeKeys: number of pre-existing runtime keys 
 * 
 * Output params are: 
 * 
 * *scanKeys: receives ptr to array of ScanKeys 
 * *numScanKeys: receives number of scankeys 
 * *runtimeKeys: receives ptr to array of IndexRuntimeKeyInfos, or NULL if none 
 * *numRuntimeKeys: receives number of runtime keys 
 * *arrayKeys: receives ptr to array of IndexArrayKeyInfos, or NULL if none 
 * *numArrayKeys: receives number of array keys 
 * 
 * Caller may pass NULL for arrayKeys and numArrayKeys to indicate that 
 * IndexArrayKeyInfos are not supported. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1152"></a><span class='Declare_Function'>ExecIndexBuildScanKeys</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>planstate</span><span class='Delimiter'>, </span><a href="../../include/utils/relcache.h.html#LN20"><span class='Ref_to_Typedef'>Relation</span></a> <span class='Declare_Parameter'>index</span><span class='Delimiter'>, 
</span><a name="LN1153"></a>                       <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>quals</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>isorderby</span><span class='Delimiter'>, 
</span><a name="LN1154"></a>                       <a href="../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>scanKeys</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Operator'>*</span><span class='Declare_Parameter'>numScanKeys</span><span class='Delimiter'>, 
</span><a name="LN1155"></a>                       <a href="../../include/nodes/execnodes.h.html#LN1096"><span class='Ref_to_Typedef'>IndexRuntimeKeyInfo</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>runtimeKeys</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Operator'>*</span><span class='Declare_Parameter'>numRuntimeKeys</span><span class='Delimiter'>, 
</span><a name="LN1156"></a>                       <a href="../../include/nodes/execnodes.h.html#LN1103"><span class='Ref_to_Typedef'>IndexArrayKeyInfo</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>arrayKeys</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Operator'>*</span><span class='Declare_Parameter'>numArrayKeys</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1158"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>qual_cell</span><span class='Delimiter'>; 
</span><a name="LN1159"></a>    <a href="../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a>     <span class='Declare_Local'>scan_keys</span><span class='Delimiter'>; 
</span><a name="LN1160"></a>    <a href="../../include/nodes/execnodes.h.html#LN1096"><span class='Ref_to_Typedef'>IndexRuntimeKeyInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>runtime_keys</span><span class='Delimiter'>; 
</span><a name="LN1161"></a>    <a href="../../include/nodes/execnodes.h.html#LN1103"><span class='Ref_to_Typedef'>IndexArrayKeyInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>array_keys</span><span class='Delimiter'>; 
</span><a name="LN1162"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>n_scan_keys</span><span class='Delimiter'>; 
</span><a name="LN1163"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>n_runtime_keys</span><span class='Delimiter'>; 
</span><a name="LN1164"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>max_runtime_keys</span><span class='Delimiter'>; 
</span><a name="LN1165"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>n_array_keys</span><span class='Delimiter'>; 
</span><a name="LN1166"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>j</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Allocate array for ScanKey structs: one per qual */ 
</span>    <a href="nodeIndexscan.c.html#LN1162"><span class='Ref_To_Local'>n_scan_keys</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1153"><span class='Ref_to_Parameter'>quals</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="nodeIndexscan.c.html#LN1159"><span class='Ref_To_Local'>scan_keys</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a><span class='Parentheses'>) </span><a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1162"><span class='Ref_To_Local'>n_scan_keys</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/access/skey.h.html#LN63"><span class='Ref_to_Struct'>ScanKeyData</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * runtime_keys array is dynamically resized as needed.  We handle it this 
     * way so that the same runtime keys array can be shared between 
     * indexquals and indexorderbys, which will be processed in separate calls 
     * of this function.  Caller must be sure to pass in NULL/0 for first 
     * call. 
     */ 
</span>    <a href="nodeIndexscan.c.html#LN1160"><span class='Ref_To_Local'>runtime_keys</span></a> <span class='Operator'>= *</span><a href="nodeIndexscan.c.html#LN1155"><span class='Ref_to_Parameter'>runtimeKeys</span></a><span class='Delimiter'>; 
</span>    <a href="nodeIndexscan.c.html#LN1163"><span class='Ref_To_Local'>n_runtime_keys</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN1164"><span class='Ref_To_Local'>max_runtime_keys</span></a> <span class='Operator'>= *</span><a href="nodeIndexscan.c.html#LN1155"><span class='Ref_to_Parameter'>numRuntimeKeys</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Allocate array_keys as large as it could possibly need to be */ 
</span>    <a href="nodeIndexscan.c.html#LN1161"><span class='Ref_To_Local'>array_keys</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1103"><span class='Ref_to_Typedef'>IndexArrayKeyInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>        <a href="../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1162"><span class='Ref_To_Local'>n_scan_keys</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1103"><span class='Ref_to_Typedef'>IndexArrayKeyInfo</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="nodeIndexscan.c.html#LN1165"><span class='Ref_To_Local'>n_array_keys</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * for each opclause in the given qual, convert the opclause into a single 
     * scan key 
     */ 
</span>    <a href="nodeIndexscan.c.html#LN1166"><span class='Ref_To_Local'>j</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1158"><span class='Ref_To_Local'>qual_cell</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN1153"><span class='Ref_to_Parameter'>quals</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1194"></a>        <a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>clause</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1158"><span class='Ref_To_Local'>qual_cell</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1195"></a>        <a href="../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a>     <span class='Declare_Local'>this_scan_key</span> <span class='Operator'>= &</span><a href="nodeIndexscan.c.html#LN1159"><span class='Ref_To_Local'>scan_keys</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN1166"><span class='Ref_To_Local'>j</span></a><span class='Operator'>++</span><span class='Delimiter'>]; 
</span><a name="LN1196"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>opno</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* operator's OID */ 
</span><a name="LN1197"></a>        <a href="../../include/c.h.html#LN394"><span class='Ref_to_Typedef'>RegProcedure</span></a> <span class='Declare_Local'>opfuncid</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* operator proc id used in scan */ 
</span><a name="LN1198"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>opfamily</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* opfamily of index column */ 
</span><a name="LN1199"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>op_strategy</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* operator's strategy number */ 
</span><a name="LN1200"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>op_lefttype</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* operator's declared input types */ 
</span><a name="LN1201"></a>        <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>op_righttype</span><span class='Delimiter'>; 
</span><a name="LN1202"></a>        <a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>leftop</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* expr on lhs of operator */ 
</span><a name="LN1203"></a>        <a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>rightop</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* expr on rhs ... */ 
</span><a name="LN1204"></a>        <a href="../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a>  <span class='Declare_Local'>varattno</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* att number used in scan */ 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1194"><span class='Ref_To_Local'>clause</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* indexkey op const or indexkey op expression */ 
</span><a name="LN1209"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>flags</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN1210"></a>            <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>scanvalue</span><span class='Delimiter'>; 
</span> 
            <a href="nodeIndexscan.c.html#LN1196"><span class='Ref_To_Local'>opno</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeIndexscan.c.html#LN1194"><span class='Ref_To_Local'>clause</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>opno<span class='Delimiter'>; 
</span>            <a href="nodeIndexscan.c.html#LN1197"><span class='Ref_To_Local'>opfuncid</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeIndexscan.c.html#LN1194"><span class='Ref_To_Local'>clause</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>opfuncid<span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * leftop should be the index key Var, possibly relabeled 
             */ 
</span>            <a href="nodeIndexscan.c.html#LN1202"><span class='Ref_To_Local'>leftop</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/optimizer/clauses.h.html#LN32"><span class='Ref_to_Proto'>get_leftop</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1194"><span class='Ref_To_Local'>clause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1202"><span class='Ref_To_Local'>leftop</span></a> <span class='Operator'>&& </span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1202"><span class='Ref_To_Local'>leftop</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a><span class='Parentheses'>))</span> 
                <a href="nodeIndexscan.c.html#LN1202"><span class='Ref_To_Local'>leftop</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeIndexscan.c.html#LN1202"><span class='Ref_To_Local'>leftop</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>arg<span class='Delimiter'>; 
</span> 
            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1202"><span class='Ref_To_Local'>leftop</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1202"><span class='Ref_To_Local'>leftop</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>                  <span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeIndexscan.c.html#LN1202"><span class='Ref_To_Local'>leftop</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>varno <span class='Operator'>== </span><a href="../../include/nodes/primnodes.h.html#LN154"><span class='Ref_to_Const'>INDEX_VAR</span></a><span class='Parentheses'>))</span> 
                <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"indexqual doesn't have key on left side"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="nodeIndexscan.c.html#LN1204"><span class='Ref_To_Local'>varattno</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeIndexscan.c.html#LN1202"><span class='Ref_To_Local'>leftop</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>varattno<span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1204"><span class='Ref_To_Local'>varattno</span></a> <span class='Operator'>&LT; </span><span class='Number'>1</span> <span class='Operator'>|| </span><a href="nodeIndexscan.c.html#LN1204"><span class='Ref_To_Local'>varattno</span></a> <span class='Operator'>&GT; </span><a href="nodeIndexscan.c.html#LN1152"><span class='Ref_to_Parameter'>index</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN158"><span class='Ref_to_Member'>rd_index</span></a><span class='Operator'>-&GT;</span>indnatts<span class='Parentheses'>) 
</span>                <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"bogus index qualification"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * We have to look up the operator's strategy number.  This 
             * provides a cross-check that the operator does match the index. 
             */ 
</span>            <a href="nodeIndexscan.c.html#LN1198"><span class='Ref_To_Local'>opfamily</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN1152"><span class='Ref_to_Parameter'>index</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN181"><span class='Ref_to_Member'>rd_opfamily</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN1204"><span class='Ref_To_Local'>varattno</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]; 
</span> 
            <a href="../../include/utils/lsyscache.h.html#LN66"><span class='Ref_to_Proto'>get_op_opfamily_properties</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1196"><span class='Ref_To_Local'>opno</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN1198"><span class='Ref_To_Local'>opfamily</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN1153"><span class='Ref_to_Parameter'>isorderby</span></a><span class='Delimiter'>, 
</span>                                       <span class='Operator'>&</span><a href="nodeIndexscan.c.html#LN1199"><span class='Ref_To_Local'>op_strategy</span></a><span class='Delimiter'>, 
</span>                                       <span class='Operator'>&</span><a href="nodeIndexscan.c.html#LN1200"><span class='Ref_To_Local'>op_lefttype</span></a><span class='Delimiter'>, 
</span>                                       <span class='Operator'>&</span><a href="nodeIndexscan.c.html#LN1201"><span class='Ref_To_Local'>op_righttype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1153"><span class='Ref_to_Parameter'>isorderby</span></a><span class='Parentheses'>) 
</span>                <a href="nodeIndexscan.c.html#LN1209"><span class='Ref_To_Local'>flags</span></a> <span class='Operator'>|= </span><a href="../../include/access/skey.h.html#LN123"><span class='Ref_to_Const'>SK_ORDER_BY</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * rightop is the constant or variable comparison value 
             */ 
</span>            <a href="nodeIndexscan.c.html#LN1203"><span class='Ref_To_Local'>rightop</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/optimizer/clauses.h.html#LN33"><span class='Ref_to_Proto'>get_rightop</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1194"><span class='Ref_To_Local'>clause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1203"><span class='Ref_To_Local'>rightop</span></a> <span class='Operator'>&& </span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1203"><span class='Ref_To_Local'>rightop</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a><span class='Parentheses'>))</span> 
                <a href="nodeIndexscan.c.html#LN1203"><span class='Ref_To_Local'>rightop</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeIndexscan.c.html#LN1203"><span class='Ref_To_Local'>rightop</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>arg<span class='Delimiter'>; 
</span> 
            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1203"><span class='Ref_To_Local'>rightop</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1203"><span class='Ref_To_Local'>rightop</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* OK, simple constant comparison value */ 
</span>                <a href="nodeIndexscan.c.html#LN1210"><span class='Ref_To_Local'>scanvalue</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeIndexscan.c.html#LN1203"><span class='Ref_To_Local'>rightop</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>constvalue<span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(((</span><a href="../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeIndexscan.c.html#LN1203"><span class='Ref_To_Local'>rightop</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>constisnull<span class='Parentheses'>)</span> 
                    <a href="nodeIndexscan.c.html#LN1209"><span class='Ref_To_Local'>flags</span></a> <span class='Operator'>|= </span><a href="../../include/access/skey.h.html#LN114"><span class='Ref_to_Const'>SK_ISNULL</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* Need to treat this one as a runtime key */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1163"><span class='Ref_To_Local'>n_runtime_keys</span></a> <span class='Operator'>&GT;= </span><a href="nodeIndexscan.c.html#LN1164"><span class='Ref_To_Local'>max_runtime_keys</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1164"><span class='Ref_To_Local'>max_runtime_keys</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <a href="nodeIndexscan.c.html#LN1164"><span class='Ref_To_Local'>max_runtime_keys</span></a> <span class='Operator'>= </span><span class='Number'>8</span><span class='Delimiter'>; 
</span>                        <a href="nodeIndexscan.c.html#LN1160"><span class='Ref_To_Local'>runtime_keys</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1096"><span class='Ref_to_Typedef'>IndexRuntimeKeyInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>                            <a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1164"><span class='Ref_To_Local'>max_runtime_keys</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1096"><span class='Ref_to_Typedef'>IndexRuntimeKeyInfo</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                    <span class='Control'>else</span> 
                    <span class='Delimiter'>{ 
</span>                        <a href="nodeIndexscan.c.html#LN1164"><span class='Ref_To_Local'>max_runtime_keys</span></a> <span class='Operator'>*= </span><span class='Number'>2</span><span class='Delimiter'>; 
</span>                        <a href="nodeIndexscan.c.html#LN1160"><span class='Ref_To_Local'>runtime_keys</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1096"><span class='Ref_to_Typedef'>IndexRuntimeKeyInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>                            <a href="../../include/common/fe_memutils.h.html#LN36"><span class='Ref_to_Proto'>repalloc</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1160"><span class='Ref_To_Local'>runtime_keys</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN1164"><span class='Ref_To_Local'>max_runtime_keys</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1096"><span class='Ref_to_Typedef'>IndexRuntimeKeyInfo</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                <span class='Delimiter'>} 
</span>                <a href="nodeIndexscan.c.html#LN1160"><span class='Ref_To_Local'>runtime_keys</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN1163"><span class='Ref_To_Local'>n_runtime_keys</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1098"><span class='Ref_to_Member'>scan_key</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN1195"><span class='Ref_To_Local'>this_scan_key</span></a><span class='Delimiter'>; 
</span>                <a href="nodeIndexscan.c.html#LN1160"><span class='Ref_To_Local'>runtime_keys</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN1163"><span class='Ref_To_Local'>n_runtime_keys</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1099"><span class='Ref_to_Member'>key_expr</span></a> <span class='Operator'>= 
</span>                    <a href="execExpr.c.html#LN111"><span class='Ref_to_Func'>ExecInitExpr</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1203"><span class='Ref_To_Local'>rightop</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN1152"><span class='Ref_to_Parameter'>planstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="nodeIndexscan.c.html#LN1160"><span class='Ref_To_Local'>runtime_keys</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN1163"><span class='Ref_To_Local'>n_runtime_keys</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1100"><span class='Ref_to_Member'>key_toastable</span></a> <span class='Operator'>= 
</span>                    <a href="../../include/utils/lsyscache.h.html#LN183"><span class='Ref_to_Macro'>TypeIsToastable</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1201"><span class='Ref_To_Local'>op_righttype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="nodeIndexscan.c.html#LN1163"><span class='Ref_To_Local'>n_runtime_keys</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>                <a href="nodeIndexscan.c.html#LN1210"><span class='Ref_To_Local'>scanvalue</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
            <span class='Comment_Multi_Line'>/* 
             * initialize the scan key's fields appropriately 
             */ 
</span>            <a href="../access/common/scankey.c.html#LN30"><span class='Ref_to_Func'>ScanKeyEntryInitialize</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1195"><span class='Ref_To_Local'>this_scan_key</span></a><span class='Delimiter'>, 
</span>                                   <a href="nodeIndexscan.c.html#LN1209"><span class='Ref_To_Local'>flags</span></a><span class='Delimiter'>, 
</span>                                   <a href="nodeIndexscan.c.html#LN1204"><span class='Ref_To_Local'>varattno</span></a><span class='Delimiter'>,</span>    <span class='Comment_Single_Line'>/* attribute number to scan */ 
</span>                                   <a href="nodeIndexscan.c.html#LN1199"><span class='Ref_To_Local'>op_strategy</span></a><span class='Delimiter'>, </span><span class='Comment_Single_Line'>/* op's strategy */ 
</span>                                   <a href="nodeIndexscan.c.html#LN1201"><span class='Ref_To_Local'>op_righttype</span></a><span class='Delimiter'>,</span>        <span class='Comment_Single_Line'>/* strategy subtype */ 
</span>                                   <span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeIndexscan.c.html#LN1194"><span class='Ref_To_Local'>clause</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>inputcollid<span class='Delimiter'>,</span>    <span class='Comment_Single_Line'>/* collation */ 
</span>                                   <a href="nodeIndexscan.c.html#LN1197"><span class='Ref_To_Local'>opfuncid</span></a><span class='Delimiter'>,</span>    <span class='Comment_Single_Line'>/* reg proc to use */ 
</span>                                   <a href="nodeIndexscan.c.html#LN1210"><span class='Ref_To_Local'>scanvalue</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* constant */ 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if IsA(clause,OpExpr) &raquo; </span> 
        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1194"><span class='Ref_To_Local'>clause</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN1026"><span class='Ref_to_Struct'>RowCompareExpr</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* (indexkey, indexkey, ...) op (expression, expression, ...) */ 
</span><a name="LN1306"></a>            <a href="../../include/nodes/primnodes.h.html#LN1026"><span class='Ref_to_Struct'>RowCompareExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rc</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN1026"><span class='Ref_to_Struct'>RowCompareExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeIndexscan.c.html#LN1194"><span class='Ref_To_Local'>clause</span></a><span class='Delimiter'>; 
</span><a name="LN1307"></a>            <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>largs_cell</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1306"><span class='Ref_To_Local'>rc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1033"><span class='Ref_to_Member'>largs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1308"></a>            <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>rargs_cell</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1306"><span class='Ref_To_Local'>rc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1034"><span class='Ref_to_Member'>rargs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1309"></a>            <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>opnos_cell</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1306"><span class='Ref_To_Local'>rc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1030"><span class='Ref_to_Member'>opnos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1310"></a>            <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>collids_cell</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1306"><span class='Ref_To_Local'>rc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1032"><span class='Ref_to_Member'>inputcollids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1311"></a>            <a href="../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a>     <span class='Declare_Local'>first_sub_key</span><span class='Delimiter'>; 
</span><a name="LN1312"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>n_sub_key</span><span class='Delimiter'>; 
</span> 
            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="nodeIndexscan.c.html#LN1153"><span class='Ref_to_Parameter'>isorderby</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="nodeIndexscan.c.html#LN1311"><span class='Ref_To_Local'>first_sub_key</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a><span class='Parentheses'>) 
</span>                <a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1306"><span class='Ref_To_Local'>rc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1030"><span class='Ref_to_Member'>opnos</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/access/skey.h.html#LN63"><span class='Ref_to_Struct'>ScanKeyData</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="nodeIndexscan.c.html#LN1312"><span class='Ref_To_Local'>n_sub_key</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Scan RowCompare columns and generate subsidiary ScanKey items */ 
</span>            <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1309"><span class='Ref_To_Local'>opnos_cell</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN1323"></a>                <a href="../../include/access/skey.h.html#LN74"><span class='Ref_to_Typedef'>ScanKey</span></a>     <span class='Declare_Local'>this_sub_key</span> <span class='Operator'>= &</span><a href="nodeIndexscan.c.html#LN1311"><span class='Ref_To_Local'>first_sub_key</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN1312"><span class='Ref_To_Local'>n_sub_key</span></a><span class='Delimiter'>]; 
</span><a name="LN1324"></a>                <span class='Keyword'>int</span>         <span class='Declare_Local'>flags</span> <span class='Operator'>= </span><a href="../../include/access/skey.h.html#LN117"><span class='Ref_to_Const'>SK_ROW_MEMBER</span></a><span class='Delimiter'>; 
</span><a name="LN1325"></a>                <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>scanvalue</span><span class='Delimiter'>; 
</span><a name="LN1326"></a>                <a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>inputcollation</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * leftop should be the index key Var, possibly relabeled 
                 */ 
</span>                <a href="nodeIndexscan.c.html#LN1202"><span class='Ref_To_Local'>leftop</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1307"><span class='Ref_To_Local'>largs_cell</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="nodeIndexscan.c.html#LN1307"><span class='Ref_To_Local'>largs_cell</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1307"><span class='Ref_To_Local'>largs_cell</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1202"><span class='Ref_To_Local'>leftop</span></a> <span class='Operator'>&& </span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1202"><span class='Ref_To_Local'>leftop</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a><span class='Parentheses'>))</span> 
                    <a href="nodeIndexscan.c.html#LN1202"><span class='Ref_To_Local'>leftop</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeIndexscan.c.html#LN1202"><span class='Ref_To_Local'>leftop</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>arg<span class='Delimiter'>; 
</span> 
                <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1202"><span class='Ref_To_Local'>leftop</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1202"><span class='Ref_To_Local'>leftop</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>                      <span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeIndexscan.c.html#LN1202"><span class='Ref_To_Local'>leftop</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>varno <span class='Operator'>== </span><a href="../../include/nodes/primnodes.h.html#LN154"><span class='Ref_to_Const'>INDEX_VAR</span></a><span class='Parentheses'>))</span> 
                    <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"indexqual doesn't have key on left side"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="nodeIndexscan.c.html#LN1204"><span class='Ref_To_Local'>varattno</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeIndexscan.c.html#LN1202"><span class='Ref_To_Local'>leftop</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>varattno<span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * We have to look up the operator's associated btree support 
                 * function 
                 */ 
</span>                <a href="nodeIndexscan.c.html#LN1196"><span class='Ref_To_Local'>opno</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN107"><span class='Ref_to_Macro'>lfirst_oid</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1309"><span class='Ref_To_Local'>opnos_cell</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="nodeIndexscan.c.html#LN1309"><span class='Ref_To_Local'>opnos_cell</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1309"><span class='Ref_To_Local'>opnos_cell</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1152"><span class='Ref_to_Parameter'>index</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN113"><span class='Ref_to_Member'>rd_rel</span></a><span class='Operator'>-&GT;</span>relam <span class='Operator'>!= </span><a href="../../include/catalog/pg_am.h.html#LN69"><span class='Ref_to_Const'>BTREE_AM_OID</span></a> <span class='Operator'>|| 
</span>                    <a href="nodeIndexscan.c.html#LN1204"><span class='Ref_To_Local'>varattno</span></a> <span class='Operator'>&LT; </span><span class='Number'>1</span> <span class='Operator'>|| </span><a href="nodeIndexscan.c.html#LN1204"><span class='Ref_To_Local'>varattno</span></a> <span class='Operator'>&GT; </span><a href="nodeIndexscan.c.html#LN1152"><span class='Ref_to_Parameter'>index</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN158"><span class='Ref_to_Member'>rd_index</span></a><span class='Operator'>-&GT;</span>indnatts<span class='Parentheses'>) 
</span>                    <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"bogus RowCompare index qualification"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="nodeIndexscan.c.html#LN1198"><span class='Ref_To_Local'>opfamily</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN1152"><span class='Ref_to_Parameter'>index</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN181"><span class='Ref_to_Member'>rd_opfamily</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN1204"><span class='Ref_To_Local'>varattno</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]; 
</span> 
                <a href="../../include/utils/lsyscache.h.html#LN66"><span class='Ref_to_Proto'>get_op_opfamily_properties</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1196"><span class='Ref_To_Local'>opno</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN1198"><span class='Ref_To_Local'>opfamily</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN1153"><span class='Ref_to_Parameter'>isorderby</span></a><span class='Delimiter'>, 
</span>                                           <span class='Operator'>&</span><a href="nodeIndexscan.c.html#LN1199"><span class='Ref_To_Local'>op_strategy</span></a><span class='Delimiter'>, 
</span>                                           <span class='Operator'>&</span><a href="nodeIndexscan.c.html#LN1200"><span class='Ref_To_Local'>op_lefttype</span></a><span class='Delimiter'>, 
</span>                                           <span class='Operator'>&</span><a href="nodeIndexscan.c.html#LN1201"><span class='Ref_To_Local'>op_righttype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1199"><span class='Ref_To_Local'>op_strategy</span></a> <span class='Operator'>!= </span><a href="nodeIndexscan.c.html#LN1306"><span class='Ref_To_Local'>rc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1029"><span class='Ref_to_Member'>rctype</span></a><span class='Parentheses'>) 
</span>                    <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"RowCompare index qualification contains wrong operator"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="nodeIndexscan.c.html#LN1197"><span class='Ref_To_Local'>opfuncid</span></a> <span class='Operator'>= </span><a href="../../include/utils/lsyscache.h.html#LN83"><span class='Ref_to_Proto'>get_opfamily_proc</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1198"><span class='Ref_To_Local'>opfamily</span></a><span class='Delimiter'>, 
</span>                                             <a href="nodeIndexscan.c.html#LN1200"><span class='Ref_To_Local'>op_lefttype</span></a><span class='Delimiter'>, 
</span>                                             <a href="nodeIndexscan.c.html#LN1201"><span class='Ref_To_Local'>op_righttype</span></a><span class='Delimiter'>, 
</span>                                             <a href="../../include/access/nbtree.h.html#LN228"><span class='Ref_to_Const'>BTORDER_PROC</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="nodeIndexscan.c.html#LN1326"><span class='Ref_To_Local'>inputcollation</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN107"><span class='Ref_to_Macro'>lfirst_oid</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1310"><span class='Ref_To_Local'>collids_cell</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="nodeIndexscan.c.html#LN1310"><span class='Ref_To_Local'>collids_cell</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1310"><span class='Ref_To_Local'>collids_cell</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * rightop is the constant or variable comparison value 
                 */ 
</span>                <a href="nodeIndexscan.c.html#LN1203"><span class='Ref_To_Local'>rightop</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1308"><span class='Ref_To_Local'>rargs_cell</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="nodeIndexscan.c.html#LN1308"><span class='Ref_To_Local'>rargs_cell</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1308"><span class='Ref_To_Local'>rargs_cell</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1203"><span class='Ref_To_Local'>rightop</span></a> <span class='Operator'>&& </span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1203"><span class='Ref_To_Local'>rightop</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a><span class='Parentheses'>))</span> 
                    <a href="nodeIndexscan.c.html#LN1203"><span class='Ref_To_Local'>rightop</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeIndexscan.c.html#LN1203"><span class='Ref_To_Local'>rightop</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>arg<span class='Delimiter'>; 
</span> 
                <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1203"><span class='Ref_To_Local'>rightop</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1203"><span class='Ref_To_Local'>rightop</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* OK, simple constant comparison value */ 
</span>                    <a href="nodeIndexscan.c.html#LN1325"><span class='Ref_To_Local'>scanvalue</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeIndexscan.c.html#LN1203"><span class='Ref_To_Local'>rightop</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>constvalue<span class='Delimiter'>; 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(((</span><a href="../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeIndexscan.c.html#LN1203"><span class='Ref_To_Local'>rightop</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>constisnull<span class='Parentheses'>)</span> 
                        <a href="nodeIndexscan.c.html#LN1324"><span class='Ref_To_Local'>flags</span></a> <span class='Operator'>|= </span><a href="../../include/access/skey.h.html#LN114"><span class='Ref_to_Const'>SK_ISNULL</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>else</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* Need to treat this one as a runtime key */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1163"><span class='Ref_To_Local'>n_runtime_keys</span></a> <span class='Operator'>&GT;= </span><a href="nodeIndexscan.c.html#LN1164"><span class='Ref_To_Local'>max_runtime_keys</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1164"><span class='Ref_To_Local'>max_runtime_keys</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                        <span class='Delimiter'>{ 
</span>                            <a href="nodeIndexscan.c.html#LN1164"><span class='Ref_To_Local'>max_runtime_keys</span></a> <span class='Operator'>= </span><span class='Number'>8</span><span class='Delimiter'>; 
</span>                            <a href="nodeIndexscan.c.html#LN1160"><span class='Ref_To_Local'>runtime_keys</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1096"><span class='Ref_to_Typedef'>IndexRuntimeKeyInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>                                <a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1164"><span class='Ref_To_Local'>max_runtime_keys</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1096"><span class='Ref_to_Typedef'>IndexRuntimeKeyInfo</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                        <span class='Delimiter'>} 
</span>                        <span class='Control'>else</span> 
                        <span class='Delimiter'>{ 
</span>                            <a href="nodeIndexscan.c.html#LN1164"><span class='Ref_To_Local'>max_runtime_keys</span></a> <span class='Operator'>*= </span><span class='Number'>2</span><span class='Delimiter'>; 
</span>                            <a href="nodeIndexscan.c.html#LN1160"><span class='Ref_To_Local'>runtime_keys</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1096"><span class='Ref_to_Typedef'>IndexRuntimeKeyInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>                                <a href="../../include/common/fe_memutils.h.html#LN36"><span class='Ref_to_Proto'>repalloc</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1160"><span class='Ref_To_Local'>runtime_keys</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN1164"><span class='Ref_To_Local'>max_runtime_keys</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1096"><span class='Ref_to_Typedef'>IndexRuntimeKeyInfo</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                        <span class='Delimiter'>} 
</span>                    <span class='Delimiter'>} 
</span>                    <a href="nodeIndexscan.c.html#LN1160"><span class='Ref_To_Local'>runtime_keys</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN1163"><span class='Ref_To_Local'>n_runtime_keys</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1098"><span class='Ref_to_Member'>scan_key</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN1323"><span class='Ref_To_Local'>this_sub_key</span></a><span class='Delimiter'>; 
</span>                    <a href="nodeIndexscan.c.html#LN1160"><span class='Ref_To_Local'>runtime_keys</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN1163"><span class='Ref_To_Local'>n_runtime_keys</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1099"><span class='Ref_to_Member'>key_expr</span></a> <span class='Operator'>= 
</span>                        <a href="execExpr.c.html#LN111"><span class='Ref_to_Func'>ExecInitExpr</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1203"><span class='Ref_To_Local'>rightop</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN1152"><span class='Ref_to_Parameter'>planstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="nodeIndexscan.c.html#LN1160"><span class='Ref_To_Local'>runtime_keys</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN1163"><span class='Ref_To_Local'>n_runtime_keys</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1100"><span class='Ref_to_Member'>key_toastable</span></a> <span class='Operator'>= 
</span>                        <a href="../../include/utils/lsyscache.h.html#LN183"><span class='Ref_to_Macro'>TypeIsToastable</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1201"><span class='Ref_To_Local'>op_righttype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="nodeIndexscan.c.html#LN1163"><span class='Ref_To_Local'>n_runtime_keys</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>                    <a href="nodeIndexscan.c.html#LN1325"><span class='Ref_To_Local'>scanvalue</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
                <span class='Comment_Multi_Line'>/* 
                 * initialize the subsidiary scan key's fields appropriately 
                 */ 
</span>                <a href="../access/common/scankey.c.html#LN30"><span class='Ref_to_Func'>ScanKeyEntryInitialize</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1323"><span class='Ref_To_Local'>this_sub_key</span></a><span class='Delimiter'>, 
</span>                                       <a href="nodeIndexscan.c.html#LN1324"><span class='Ref_To_Local'>flags</span></a><span class='Delimiter'>, 
</span>                                       <a href="nodeIndexscan.c.html#LN1204"><span class='Ref_To_Local'>varattno</span></a><span class='Delimiter'>,</span>        <span class='Comment_Single_Line'>/* attribute number */ 
</span>                                       <a href="nodeIndexscan.c.html#LN1199"><span class='Ref_To_Local'>op_strategy</span></a><span class='Delimiter'>,</span>     <span class='Comment_Single_Line'>/* op's strategy */ 
</span>                                       <a href="nodeIndexscan.c.html#LN1201"><span class='Ref_To_Local'>op_righttype</span></a><span class='Delimiter'>,</span>    <span class='Comment_Single_Line'>/* strategy subtype */ 
</span>                                       <a href="nodeIndexscan.c.html#LN1326"><span class='Ref_To_Local'>inputcollation</span></a><span class='Delimiter'>,</span>  <span class='Comment_Single_Line'>/* collation */ 
</span>                                       <a href="nodeIndexscan.c.html#LN1197"><span class='Ref_To_Local'>opfuncid</span></a><span class='Delimiter'>,</span>        <span class='Comment_Single_Line'>/* reg proc to use */ 
</span>                                       <a href="nodeIndexscan.c.html#LN1325"><span class='Ref_To_Local'>scanvalue</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* constant */ 
</span>                <a href="nodeIndexscan.c.html#LN1312"><span class='Ref_To_Local'>n_sub_key</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end while opnos_cell!=NULL &raquo; </span> 
 
            <span class='Comment_Multi_Line'>/* Mark the last subsidiary scankey correctly */ 
</span>            <a href="nodeIndexscan.c.html#LN1311"><span class='Ref_To_Local'>first_sub_key</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN1312"><span class='Ref_To_Local'>n_sub_key</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>|= </span><a href="../../include/access/skey.h.html#LN118"><span class='Ref_to_Const'>SK_ROW_END</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * We don't use ScanKeyEntryInitialize for the header because it 
             * isn't going to contain a valid sk_func pointer. 
             */ 
</span>            <a href="../../include/c.h.html#LN856"><span class='Ref_to_Macro'>MemSet</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1195"><span class='Ref_To_Local'>this_scan_key</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/access/skey.h.html#LN63"><span class='Ref_to_Struct'>ScanKeyData</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="nodeIndexscan.c.html#LN1195"><span class='Ref_To_Local'>this_scan_key</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/skey.h.html#LN65"><span class='Ref_to_Member'>sk_flags</span></a> <span class='Operator'>= </span><a href="../../include/access/skey.h.html#LN116"><span class='Ref_to_Const'>SK_ROW_HEADER</span></a><span class='Delimiter'>; 
</span>            <a href="nodeIndexscan.c.html#LN1195"><span class='Ref_To_Local'>this_scan_key</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/skey.h.html#LN66"><span class='Ref_to_Member'>sk_attno</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN1311"><span class='Ref_To_Local'>first_sub_key</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/skey.h.html#LN66"><span class='Ref_to_Member'>sk_attno</span></a><span class='Delimiter'>; 
</span>            <a href="nodeIndexscan.c.html#LN1195"><span class='Ref_To_Local'>this_scan_key</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/skey.h.html#LN67"><span class='Ref_to_Member'>sk_strategy</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN1306"><span class='Ref_To_Local'>rc</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1029"><span class='Ref_to_Member'>rctype</span></a><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* sk_subtype, sk_collation, sk_func not used in a header */ 
</span>            <a href="nodeIndexscan.c.html#LN1195"><span class='Ref_To_Local'>this_scan_key</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/skey.h.html#LN71"><span class='Ref_to_Member'>sk_argument</span></a> <span class='Operator'>= </span><a href="../../include/postgres.h.html#LN561"><span class='Ref_to_Macro'>PointerGetDatum</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1311"><span class='Ref_To_Local'>first_sub_key</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if IsA(clause,RowCompare... &raquo; </span> 
        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1194"><span class='Ref_To_Local'>clause</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN534"><span class='Ref_to_Struct'>ScalarArrayOpExpr</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* indexkey op ANY (array-expression) */ 
</span><a name="LN1449"></a>            <a href="../../include/nodes/primnodes.h.html#LN534"><span class='Ref_to_Struct'>ScalarArrayOpExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>saop</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN534"><span class='Ref_to_Struct'>ScalarArrayOpExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeIndexscan.c.html#LN1194"><span class='Ref_To_Local'>clause</span></a><span class='Delimiter'>; 
</span><a name="LN1450"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>flags</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN1451"></a>            <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>scanvalue</span><span class='Delimiter'>; 
</span> 
            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="nodeIndexscan.c.html#LN1153"><span class='Ref_to_Parameter'>isorderby</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1449"><span class='Ref_To_Local'>saop</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN539"><span class='Ref_to_Member'>useOr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="nodeIndexscan.c.html#LN1196"><span class='Ref_To_Local'>opno</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN1449"><span class='Ref_To_Local'>saop</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN537"><span class='Ref_to_Member'>opno</span></a><span class='Delimiter'>; 
</span>            <a href="nodeIndexscan.c.html#LN1197"><span class='Ref_To_Local'>opfuncid</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN1449"><span class='Ref_To_Local'>saop</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN538"><span class='Ref_to_Member'>opfuncid</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * leftop should be the index key Var, possibly relabeled 
             */ 
</span>            <a href="nodeIndexscan.c.html#LN1202"><span class='Ref_To_Local'>leftop</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1449"><span class='Ref_To_Local'>saop</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN541"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1202"><span class='Ref_To_Local'>leftop</span></a> <span class='Operator'>&& </span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1202"><span class='Ref_To_Local'>leftop</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a><span class='Parentheses'>))</span> 
                <a href="nodeIndexscan.c.html#LN1202"><span class='Ref_To_Local'>leftop</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeIndexscan.c.html#LN1202"><span class='Ref_To_Local'>leftop</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>arg<span class='Delimiter'>; 
</span> 
            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1202"><span class='Ref_To_Local'>leftop</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1202"><span class='Ref_To_Local'>leftop</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>                  <span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeIndexscan.c.html#LN1202"><span class='Ref_To_Local'>leftop</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>varno <span class='Operator'>== </span><a href="../../include/nodes/primnodes.h.html#LN154"><span class='Ref_to_Const'>INDEX_VAR</span></a><span class='Parentheses'>))</span> 
                <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"indexqual doesn't have key on left side"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="nodeIndexscan.c.html#LN1204"><span class='Ref_To_Local'>varattno</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeIndexscan.c.html#LN1202"><span class='Ref_To_Local'>leftop</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>varattno<span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1204"><span class='Ref_To_Local'>varattno</span></a> <span class='Operator'>&LT; </span><span class='Number'>1</span> <span class='Operator'>|| </span><a href="nodeIndexscan.c.html#LN1204"><span class='Ref_To_Local'>varattno</span></a> <span class='Operator'>&GT; </span><a href="nodeIndexscan.c.html#LN1152"><span class='Ref_to_Parameter'>index</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN158"><span class='Ref_to_Member'>rd_index</span></a><span class='Operator'>-&GT;</span>indnatts<span class='Parentheses'>) 
</span>                <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"bogus index qualification"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * We have to look up the operator's strategy number.  This 
             * provides a cross-check that the operator does match the index. 
             */ 
</span>            <a href="nodeIndexscan.c.html#LN1198"><span class='Ref_To_Local'>opfamily</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN1152"><span class='Ref_to_Parameter'>index</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN181"><span class='Ref_to_Member'>rd_opfamily</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN1204"><span class='Ref_To_Local'>varattno</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]; 
</span> 
            <a href="../../include/utils/lsyscache.h.html#LN66"><span class='Ref_to_Proto'>get_op_opfamily_properties</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1196"><span class='Ref_To_Local'>opno</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN1198"><span class='Ref_To_Local'>opfamily</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN1153"><span class='Ref_to_Parameter'>isorderby</span></a><span class='Delimiter'>, 
</span>                                       <span class='Operator'>&</span><a href="nodeIndexscan.c.html#LN1199"><span class='Ref_To_Local'>op_strategy</span></a><span class='Delimiter'>, 
</span>                                       <span class='Operator'>&</span><a href="nodeIndexscan.c.html#LN1200"><span class='Ref_To_Local'>op_lefttype</span></a><span class='Delimiter'>, 
</span>                                       <span class='Operator'>&</span><a href="nodeIndexscan.c.html#LN1201"><span class='Ref_To_Local'>op_righttype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * rightop is the constant or variable array value 
             */ 
</span>            <a href="nodeIndexscan.c.html#LN1203"><span class='Ref_To_Local'>rightop</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/nodes/pg_list.h.html#LN115"><span class='Ref_to_Macro'>lsecond</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1449"><span class='Ref_To_Local'>saop</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN541"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1203"><span class='Ref_To_Local'>rightop</span></a> <span class='Operator'>&& </span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1203"><span class='Ref_To_Local'>rightop</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a><span class='Parentheses'>))</span> 
                <a href="nodeIndexscan.c.html#LN1203"><span class='Ref_To_Local'>rightop</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeIndexscan.c.html#LN1203"><span class='Ref_To_Local'>rightop</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>arg<span class='Delimiter'>; 
</span> 
            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1203"><span class='Ref_To_Local'>rightop</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1152"><span class='Ref_to_Parameter'>index</span></a><span class='Operator'>-&GT;</span><a href="../../include/utils/rel.h.html#LN180"><span class='Ref_to_Member'>rd_amroutine</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/amapi.h.html#LN182"><span class='Ref_to_Member'>amsearcharray</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* Index AM will handle this like a simple operator */ 
</span>                <a href="nodeIndexscan.c.html#LN1450"><span class='Ref_To_Local'>flags</span></a> <span class='Operator'>|= </span><a href="../../include/access/skey.h.html#LN119"><span class='Ref_to_Const'>SK_SEARCHARRAY</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1203"><span class='Ref_To_Local'>rightop</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* OK, simple constant comparison value */ 
</span>                    <a href="nodeIndexscan.c.html#LN1451"><span class='Ref_To_Local'>scanvalue</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeIndexscan.c.html#LN1203"><span class='Ref_To_Local'>rightop</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>constvalue<span class='Delimiter'>; 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(((</span><a href="../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeIndexscan.c.html#LN1203"><span class='Ref_To_Local'>rightop</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>constisnull<span class='Parentheses'>)</span> 
                        <a href="nodeIndexscan.c.html#LN1450"><span class='Ref_To_Local'>flags</span></a> <span class='Operator'>|= </span><a href="../../include/access/skey.h.html#LN114"><span class='Ref_to_Const'>SK_ISNULL</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>else</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* Need to treat this one as a runtime key */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1163"><span class='Ref_To_Local'>n_runtime_keys</span></a> <span class='Operator'>&GT;= </span><a href="nodeIndexscan.c.html#LN1164"><span class='Ref_To_Local'>max_runtime_keys</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1164"><span class='Ref_To_Local'>max_runtime_keys</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                        <span class='Delimiter'>{ 
</span>                            <a href="nodeIndexscan.c.html#LN1164"><span class='Ref_To_Local'>max_runtime_keys</span></a> <span class='Operator'>= </span><span class='Number'>8</span><span class='Delimiter'>; 
</span>                            <a href="nodeIndexscan.c.html#LN1160"><span class='Ref_To_Local'>runtime_keys</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1096"><span class='Ref_to_Typedef'>IndexRuntimeKeyInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>                                <a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1164"><span class='Ref_To_Local'>max_runtime_keys</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1096"><span class='Ref_to_Typedef'>IndexRuntimeKeyInfo</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                        <span class='Delimiter'>} 
</span>                        <span class='Control'>else</span> 
                        <span class='Delimiter'>{ 
</span>                            <a href="nodeIndexscan.c.html#LN1164"><span class='Ref_To_Local'>max_runtime_keys</span></a> <span class='Operator'>*= </span><span class='Number'>2</span><span class='Delimiter'>; 
</span>                            <a href="nodeIndexscan.c.html#LN1160"><span class='Ref_To_Local'>runtime_keys</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1096"><span class='Ref_to_Typedef'>IndexRuntimeKeyInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>                                <a href="../../include/common/fe_memutils.h.html#LN36"><span class='Ref_to_Proto'>repalloc</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1160"><span class='Ref_To_Local'>runtime_keys</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN1164"><span class='Ref_To_Local'>max_runtime_keys</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1096"><span class='Ref_to_Typedef'>IndexRuntimeKeyInfo</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                        <span class='Delimiter'>} 
</span>                    <span class='Delimiter'>} 
</span>                    <a href="nodeIndexscan.c.html#LN1160"><span class='Ref_To_Local'>runtime_keys</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN1163"><span class='Ref_To_Local'>n_runtime_keys</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1098"><span class='Ref_to_Member'>scan_key</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN1195"><span class='Ref_To_Local'>this_scan_key</span></a><span class='Delimiter'>; 
</span>                    <a href="nodeIndexscan.c.html#LN1160"><span class='Ref_To_Local'>runtime_keys</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN1163"><span class='Ref_To_Local'>n_runtime_keys</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1099"><span class='Ref_to_Member'>key_expr</span></a> <span class='Operator'>= 
</span>                        <a href="execExpr.c.html#LN111"><span class='Ref_to_Func'>ExecInitExpr</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1203"><span class='Ref_To_Local'>rightop</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN1152"><span class='Ref_to_Parameter'>planstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                    <span class='Comment_Multi_Line'>/* 
                     * Careful here: the runtime expression is not of 
                     * op_righttype, but rather is an array of same; so 
                     * TypeIsToastable() isn't helpful.  However, we can 
                     * assume that all array types are toastable. 
                     */ 
</span>                    <a href="nodeIndexscan.c.html#LN1160"><span class='Ref_To_Local'>runtime_keys</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN1163"><span class='Ref_To_Local'>n_runtime_keys</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1100"><span class='Ref_to_Member'>key_toastable</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                    <a href="nodeIndexscan.c.html#LN1163"><span class='Ref_To_Local'>n_runtime_keys</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>                    <a href="nodeIndexscan.c.html#LN1451"><span class='Ref_To_Local'>scanvalue</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if index-&GT;rd_amroutine-&GT;... &raquo; </span> 
            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* Executor has to expand the array value */ 
</span>                <a href="nodeIndexscan.c.html#LN1161"><span class='Ref_To_Local'>array_keys</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN1165"><span class='Ref_To_Local'>n_array_keys</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1105"><span class='Ref_to_Member'>scan_key</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN1195"><span class='Ref_To_Local'>this_scan_key</span></a><span class='Delimiter'>; 
</span>                <a href="nodeIndexscan.c.html#LN1161"><span class='Ref_To_Local'>array_keys</span></a><span class='Delimiter'>[</span><a href="nodeIndexscan.c.html#LN1165"><span class='Ref_To_Local'>n_array_keys</span></a><span class='Delimiter'>]</span><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1106"><span class='Ref_to_Member'>array_expr</span></a> <span class='Operator'>= 
</span>                    <a href="execExpr.c.html#LN111"><span class='Ref_to_Func'>ExecInitExpr</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1203"><span class='Ref_To_Local'>rightop</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN1152"><span class='Ref_to_Parameter'>planstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Comment_Multi_Line'>/* the remaining fields were zeroed by palloc0 */ 
</span>                <a href="nodeIndexscan.c.html#LN1165"><span class='Ref_To_Local'>n_array_keys</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>                <a href="nodeIndexscan.c.html#LN1451"><span class='Ref_To_Local'>scanvalue</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * initialize the scan key's fields appropriately 
             */ 
</span>            <a href="../access/common/scankey.c.html#LN30"><span class='Ref_to_Func'>ScanKeyEntryInitialize</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1195"><span class='Ref_To_Local'>this_scan_key</span></a><span class='Delimiter'>, 
</span>                                   <a href="nodeIndexscan.c.html#LN1450"><span class='Ref_To_Local'>flags</span></a><span class='Delimiter'>, 
</span>                                   <a href="nodeIndexscan.c.html#LN1204"><span class='Ref_To_Local'>varattno</span></a><span class='Delimiter'>,</span>    <span class='Comment_Single_Line'>/* attribute number to scan */ 
</span>                                   <a href="nodeIndexscan.c.html#LN1199"><span class='Ref_To_Local'>op_strategy</span></a><span class='Delimiter'>, </span><span class='Comment_Single_Line'>/* op's strategy */ 
</span>                                   <a href="nodeIndexscan.c.html#LN1201"><span class='Ref_To_Local'>op_righttype</span></a><span class='Delimiter'>,</span>        <span class='Comment_Single_Line'>/* strategy subtype */ 
</span>                                   <a href="nodeIndexscan.c.html#LN1449"><span class='Ref_To_Local'>saop</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN540"><span class='Ref_to_Member'>inputcollid</span></a><span class='Delimiter'>,</span>   <span class='Comment_Single_Line'>/* collation */ 
</span>                                   <a href="nodeIndexscan.c.html#LN1197"><span class='Ref_To_Local'>opfuncid</span></a><span class='Delimiter'>,</span>    <span class='Comment_Single_Line'>/* reg proc to use */ 
</span>                                   <a href="nodeIndexscan.c.html#LN1451"><span class='Ref_To_Local'>scanvalue</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* constant */ 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if IsA(clause,ScalarArra... &raquo; </span> 
        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1194"><span class='Ref_To_Local'>clause</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN1175"><span class='Ref_to_Struct'>NullTest</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* indexkey IS NULL or indexkey IS NOT NULL */ 
</span><a name="LN1568"></a>            <a href="../../include/nodes/primnodes.h.html#LN1175"><span class='Ref_to_Struct'>NullTest</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>ntest</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/primnodes.h.html#LN1175"><span class='Ref_to_Struct'>NullTest</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeIndexscan.c.html#LN1194"><span class='Ref_To_Local'>clause</span></a><span class='Delimiter'>; 
</span><a name="LN1569"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>flags</span><span class='Delimiter'>; 
</span> 
            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="nodeIndexscan.c.html#LN1153"><span class='Ref_to_Parameter'>isorderby</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * argument should be the index key Var, possibly relabeled 
             */ 
</span>            <a href="nodeIndexscan.c.html#LN1202"><span class='Ref_To_Local'>leftop</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN1568"><span class='Ref_To_Local'>ntest</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1178"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1202"><span class='Ref_To_Local'>leftop</span></a> <span class='Operator'>&& </span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1202"><span class='Ref_To_Local'>leftop</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a><span class='Parentheses'>))</span> 
                <a href="nodeIndexscan.c.html#LN1202"><span class='Ref_To_Local'>leftop</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeIndexscan.c.html#LN1202"><span class='Ref_To_Local'>leftop</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>arg<span class='Delimiter'>; 
</span> 
            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1202"><span class='Ref_To_Local'>leftop</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1202"><span class='Ref_To_Local'>leftop</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>                  <span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeIndexscan.c.html#LN1202"><span class='Ref_To_Local'>leftop</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>varno <span class='Operator'>== </span><a href="../../include/nodes/primnodes.h.html#LN154"><span class='Ref_to_Const'>INDEX_VAR</span></a><span class='Parentheses'>))</span> 
                <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"NullTest indexqual has wrong key"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="nodeIndexscan.c.html#LN1204"><span class='Ref_To_Local'>varattno</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeIndexscan.c.html#LN1202"><span class='Ref_To_Local'>leftop</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>varattno<span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * initialize the scan key's fields appropriately 
             */ 
</span>            <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1568"><span class='Ref_To_Local'>ntest</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1179"><span class='Ref_to_Member'>nulltesttype</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>case</span> <a href="../../include/nodes/primnodes.h.html#LN1172"><span class='Ref_to_EnumConst'>IS_NULL</span></a><span class='Operator'>: 
</span>                    <a href="nodeIndexscan.c.html#LN1569"><span class='Ref_To_Local'>flags</span></a> <span class='Operator'>= </span><a href="../../include/access/skey.h.html#LN114"><span class='Ref_to_Const'>SK_ISNULL</span></a> <span class='Operator'>| </span><a href="../../include/access/skey.h.html#LN120"><span class='Ref_to_Const'>SK_SEARCHNULL</span></a><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Control'>case</span> <a href="../../include/nodes/primnodes.h.html#LN1172"><span class='Ref_to_EnumConst'>IS_NOT_NULL</span></a><span class='Operator'>: 
</span>                    <a href="nodeIndexscan.c.html#LN1569"><span class='Ref_To_Local'>flags</span></a> <span class='Operator'>= </span><a href="../../include/access/skey.h.html#LN114"><span class='Ref_to_Const'>SK_ISNULL</span></a> <span class='Operator'>| </span><a href="../../include/access/skey.h.html#LN121"><span class='Ref_to_Const'>SK_SEARCHNOTNULL</span></a><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Control'>default</span><span class='Operator'>: 
</span>                    <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized nulltesttype: %d"</span><span class='Delimiter'>, 
</span>                         <span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="nodeIndexscan.c.html#LN1568"><span class='Ref_To_Local'>ntest</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/primnodes.h.html#LN1179"><span class='Ref_to_Member'>nulltesttype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="nodeIndexscan.c.html#LN1569"><span class='Ref_To_Local'>flags</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* keep compiler quiet */ 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <a href="../access/common/scankey.c.html#LN30"><span class='Ref_to_Func'>ScanKeyEntryInitialize</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1195"><span class='Ref_To_Local'>this_scan_key</span></a><span class='Delimiter'>, 
</span>                                   <a href="nodeIndexscan.c.html#LN1569"><span class='Ref_To_Local'>flags</span></a><span class='Delimiter'>, 
</span>                                   <a href="nodeIndexscan.c.html#LN1204"><span class='Ref_To_Local'>varattno</span></a><span class='Delimiter'>,</span>    <span class='Comment_Single_Line'>/* attribute number to scan */ 
</span>                                   <a href="../../include/access/stratnum.h.html#LN23"><span class='Ref_to_Const'>InvalidStrategy</span></a><span class='Delimiter'>,</span>     <span class='Comment_Single_Line'>/* no strategy */ 
</span>                                   <a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>,</span>  <span class='Comment_Single_Line'>/* no strategy subtype */ 
</span>                                   <a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>,</span>  <span class='Comment_Single_Line'>/* no collation */ 
</span>                                   <a href="../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>,</span>  <span class='Comment_Single_Line'>/* no reg proc for this */ 
</span>                                   <span class='Parentheses'>(</span><a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a><span class='Parentheses'>) </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* constant */ 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if IsA(clause,NullTest) &raquo; </span> 
        <span class='Control'>else</span> 
            <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unsupported indexqual type: %d"</span><span class='Delimiter'>, 
</span>                 <span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="../../include/nodes/nodes.h.html#LN513"><span class='Ref_to_Macro'>nodeTag</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1194"><span class='Ref_To_Local'>clause</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1163"><span class='Ref_To_Local'>n_runtime_keys</span></a> <span class='Operator'>&LT;= </span><a href="nodeIndexscan.c.html#LN1164"><span class='Ref_To_Local'>max_runtime_keys</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Get rid of any unused arrays */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1165"><span class='Ref_To_Local'>n_array_keys</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1161"><span class='Ref_To_Local'>array_keys</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="nodeIndexscan.c.html#LN1161"><span class='Ref_To_Local'>array_keys</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Return info to our caller. 
     */ 
</span>    <span class='Operator'>*</span><a href="nodeIndexscan.c.html#LN1154"><span class='Ref_to_Parameter'>scanKeys</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN1159"><span class='Ref_To_Local'>scan_keys</span></a><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="nodeIndexscan.c.html#LN1154"><span class='Ref_to_Parameter'>numScanKeys</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN1162"><span class='Ref_To_Local'>n_scan_keys</span></a><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="nodeIndexscan.c.html#LN1155"><span class='Ref_to_Parameter'>runtimeKeys</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN1160"><span class='Ref_To_Local'>runtime_keys</span></a><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="nodeIndexscan.c.html#LN1155"><span class='Ref_to_Parameter'>numRuntimeKeys</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN1163"><span class='Ref_To_Local'>n_runtime_keys</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1156"><span class='Ref_to_Parameter'>arrayKeys</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Operator'>*</span><a href="nodeIndexscan.c.html#LN1156"><span class='Ref_to_Parameter'>arrayKeys</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN1161"><span class='Ref_To_Local'>array_keys</span></a><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="nodeIndexscan.c.html#LN1156"><span class='Ref_to_Parameter'>numArrayKeys</span></a> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN1165"><span class='Ref_To_Local'>n_array_keys</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1165"><span class='Ref_To_Local'>n_array_keys</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"ScalarArrayOpExpr index qual found where not allowed"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ExecIndexBuildScanKeys &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *                      Parallel Scan Support 
 * ---------------------------------------------------------------- 
 */ 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *      ExecIndexScanEstimate 
 * 
 *      estimates the space required to serialize indexscan node. 
 * ---------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1658"></a><span class='Declare_Function'>ExecIndexScanEstimate</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1139"><span class='Ref_to_Struct'>IndexScanState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, 
</span><a name="LN1659"></a>                      <a href="../../include/access/parallel.h.html#LN31"><span class='Ref_to_Struct'>ParallelContext</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pcxt</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1661"></a>    <a href="../../include/nodes/execnodes.h.html#LN402"><span class='Ref_to_Struct'>EState</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>estate</span> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN1658"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1141"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN814"><span class='Ref_to_Member'>state</span></a><span class='Delimiter'>; 
</span> 
    <a href="nodeIndexscan.c.html#LN1658"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1163"><span class='Ref_to_Member'>iss_PscanLen</span></a> <span class='Operator'>= </span><a href="../../include/access/genam.h.html#LN152"><span class='Ref_to_Proto'>index_parallelscan_estimate</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1658"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1152"><span class='Ref_to_Member'>iss_RelationDesc</span></a><span class='Delimiter'>, 
</span>                                                     <a href="nodeIndexscan.c.html#LN1661"><span class='Ref_To_Local'>estate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN408"><span class='Ref_to_Member'>es_snapshot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/storage/shm_toc.h.html#LN50"><span class='Ref_to_Macro'>shm_toc_estimate_chunk</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nodeIndexscan.c.html#LN1659"><span class='Ref_to_Parameter'>pcxt</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/parallel.h.html#LN40"><span class='Ref_to_Member'>estimator</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN1658"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1163"><span class='Ref_to_Member'>iss_PscanLen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/storage/shm_toc.h.html#LN52"><span class='Ref_to_Macro'>shm_toc_estimate_keys</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nodeIndexscan.c.html#LN1659"><span class='Ref_to_Parameter'>pcxt</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/parallel.h.html#LN40"><span class='Ref_to_Member'>estimator</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *      ExecIndexScanInitializeDSM 
 * 
 *      Set up a parallel index scan descriptor. 
 * ---------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1676"></a><span class='Declare_Function'>ExecIndexScanInitializeDSM</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1139"><span class='Ref_to_Struct'>IndexScanState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, 
</span><a name="LN1677"></a>                           <a href="../../include/access/parallel.h.html#LN31"><span class='Ref_to_Struct'>ParallelContext</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pcxt</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1679"></a>    <a href="../../include/nodes/execnodes.h.html#LN402"><span class='Ref_to_Struct'>EState</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>estate</span> <span class='Operator'>= </span><a href="nodeIndexscan.c.html#LN1676"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1141"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN814"><span class='Ref_to_Member'>state</span></a><span class='Delimiter'>; 
</span><a name="LN1680"></a>    <a href="../../include/access/genam.h.html#LN88"><span class='Ref_to_Typedef'>ParallelIndexScanDesc</span></a> <span class='Declare_Local'>piscan</span><span class='Delimiter'>; 
</span> 
    <a href="nodeIndexscan.c.html#LN1680"><span class='Ref_To_Local'>piscan</span></a> <span class='Operator'>= </span><a href="../../include/storage/shm_toc.h.html#LN31"><span class='Ref_to_Proto'>shm_toc_allocate</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1677"><span class='Ref_to_Parameter'>pcxt</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/parallel.h.html#LN43"><span class='Ref_to_Member'>toc</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN1676"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1163"><span class='Ref_to_Member'>iss_PscanLen</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/access/genam.h.html#LN153"><span class='Ref_to_Proto'>index_parallelscan_initialize</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1676"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1141"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1058"><span class='Ref_to_Member'>ss_currentRelation</span></a><span class='Delimiter'>, 
</span>                                  <a href="nodeIndexscan.c.html#LN1676"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1152"><span class='Ref_to_Member'>iss_RelationDesc</span></a><span class='Delimiter'>, 
</span>                                  <a href="nodeIndexscan.c.html#LN1679"><span class='Ref_To_Local'>estate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN408"><span class='Ref_to_Member'>es_snapshot</span></a><span class='Delimiter'>, 
</span>                                  <a href="nodeIndexscan.c.html#LN1680"><span class='Ref_To_Local'>piscan</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/storage/shm_toc.h.html#LN33"><span class='Ref_to_Proto'>shm_toc_insert</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1677"><span class='Ref_to_Parameter'>pcxt</span></a><span class='Operator'>-&GT;</span><a href="../../include/access/parallel.h.html#LN43"><span class='Ref_to_Member'>toc</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN1676"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1141"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN812"><span class='Ref_to_Member'>plan</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN142"><span class='Ref_to_Member'>plan_node_id</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN1680"><span class='Ref_To_Local'>piscan</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="nodeIndexscan.c.html#LN1676"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1153"><span class='Ref_to_Member'>iss_ScanDesc</span></a> <span class='Operator'>= 
</span>        <a href="../../include/access/genam.h.html#LN156"><span class='Ref_to_Proto'>index_beginscan_parallel</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1676"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1141"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1058"><span class='Ref_to_Member'>ss_currentRelation</span></a><span class='Delimiter'>, 
</span>                                 <a href="nodeIndexscan.c.html#LN1676"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1152"><span class='Ref_to_Member'>iss_RelationDesc</span></a><span class='Delimiter'>, 
</span>                                 <a href="nodeIndexscan.c.html#LN1676"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1145"><span class='Ref_to_Member'>iss_NumScanKeys</span></a><span class='Delimiter'>, 
</span>                                 <a href="nodeIndexscan.c.html#LN1676"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1147"><span class='Ref_to_Member'>iss_NumOrderByKeys</span></a><span class='Delimiter'>, 
</span>                                 <a href="nodeIndexscan.c.html#LN1680"><span class='Ref_To_Local'>piscan</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If no run-time keys to calculate or they are ready, go ahead and pass 
     * the scankeys to the index AM. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1676"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1149"><span class='Ref_to_Member'>iss_NumRuntimeKeys</span></a> <span class='Operator'>== </span><span class='Number'>0</span> <span class='Operator'>|| </span><a href="nodeIndexscan.c.html#LN1676"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1150"><span class='Ref_to_Member'>iss_RuntimeKeysReady</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/access/genam.h.html#LN146"><span class='Ref_to_Proto'>index_rescan</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1676"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1153"><span class='Ref_to_Member'>iss_ScanDesc</span></a><span class='Delimiter'>, 
</span>                     <a href="nodeIndexscan.c.html#LN1676"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1144"><span class='Ref_to_Member'>iss_ScanKeys</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN1676"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1145"><span class='Ref_to_Member'>iss_NumScanKeys</span></a><span class='Delimiter'>, 
</span>                     <a href="nodeIndexscan.c.html#LN1676"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1146"><span class='Ref_to_Member'>iss_OrderByKeys</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN1676"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1147"><span class='Ref_to_Member'>iss_NumOrderByKeys</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ExecIndexScanInitializeDSM &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *      ExecIndexScanInitializeWorker 
 * 
 *      Copy relevant information from TOC into planstate. 
 * ---------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1712"></a><span class='Declare_Function'>ExecIndexScanInitializeWorker</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1139"><span class='Ref_to_Struct'>IndexScanState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><a href="../storage/ipc/shm_toc.c.html#LN25"><span class='Ref_to_Struct'>shm_toc</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>toc</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1714"></a>    <a href="../../include/access/genam.h.html#LN88"><span class='Ref_to_Typedef'>ParallelIndexScanDesc</span></a> <span class='Declare_Local'>piscan</span><span class='Delimiter'>; 
</span> 
    <a href="nodeIndexscan.c.html#LN1714"><span class='Ref_To_Local'>piscan</span></a> <span class='Operator'>= </span><a href="../../include/storage/shm_toc.h.html#LN34"><span class='Ref_to_Proto'>shm_toc_lookup</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1712"><span class='Ref_to_Parameter'>toc</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN1712"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1141"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1057"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN812"><span class='Ref_to_Member'>plan</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN142"><span class='Ref_to_Member'>plan_node_id</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="nodeIndexscan.c.html#LN1712"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1153"><span class='Ref_to_Member'>iss_ScanDesc</span></a> <span class='Operator'>= 
</span>        <a href="../../include/access/genam.h.html#LN156"><span class='Ref_to_Proto'>index_beginscan_parallel</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1712"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1141"><span class='Ref_to_Member'>ss</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN1058"><span class='Ref_to_Member'>ss_currentRelation</span></a><span class='Delimiter'>, 
</span>                                 <a href="nodeIndexscan.c.html#LN1712"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1152"><span class='Ref_to_Member'>iss_RelationDesc</span></a><span class='Delimiter'>, 
</span>                                 <a href="nodeIndexscan.c.html#LN1712"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1145"><span class='Ref_to_Member'>iss_NumScanKeys</span></a><span class='Delimiter'>, 
</span>                                 <a href="nodeIndexscan.c.html#LN1712"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1147"><span class='Ref_to_Member'>iss_NumOrderByKeys</span></a><span class='Delimiter'>, 
</span>                                 <a href="nodeIndexscan.c.html#LN1714"><span class='Ref_To_Local'>piscan</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If no run-time keys to calculate or they are ready, go ahead and pass 
     * the scankeys to the index AM. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1712"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1149"><span class='Ref_to_Member'>iss_NumRuntimeKeys</span></a> <span class='Operator'>== </span><span class='Number'>0</span> <span class='Operator'>|| </span><a href="nodeIndexscan.c.html#LN1712"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1150"><span class='Ref_to_Member'>iss_RuntimeKeysReady</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/access/genam.h.html#LN146"><span class='Ref_to_Proto'>index_rescan</span></a><span class='Parentheses'>(</span><a href="nodeIndexscan.c.html#LN1712"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1153"><span class='Ref_to_Member'>iss_ScanDesc</span></a><span class='Delimiter'>, 
</span>                     <a href="nodeIndexscan.c.html#LN1712"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1144"><span class='Ref_to_Member'>iss_ScanKeys</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN1712"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1145"><span class='Ref_to_Member'>iss_NumScanKeys</span></a><span class='Delimiter'>, 
</span>                     <a href="nodeIndexscan.c.html#LN1712"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1146"><span class='Ref_to_Member'>iss_OrderByKeys</span></a><span class='Delimiter'>, </span><a href="nodeIndexscan.c.html#LN1712"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1147"><span class='Ref_to_Member'>iss_NumOrderByKeys</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ExecIndexScanInitializeWorker &raquo; </span> 
</pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>