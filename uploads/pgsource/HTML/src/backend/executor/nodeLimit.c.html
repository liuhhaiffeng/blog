<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\executor\nodeLimit.c</title>
<LINK REL=StyleSheet HREF="../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\executor\nodeLimit.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:39 2017
</td></tr>
<tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * nodeLimit.c 
 *    Routines to handle limiting of query results where appropriate 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * 
 * IDENTIFICATION 
 *    src/backend/executor/nodeLimit.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
/* 
 * INTERFACE ROUTINES 
 *      ExecLimit       - extract a limited range of tuples 
 *      ExecInitLimit   - initialize node and subnodes.. 
 *      ExecEndLimit    - shutdown node and subnodes 
 */ 
</span> 
<span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"executor/executor.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"executor/nodeLimit.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/nodeFuncs.h"</span> 
 
<a name="LN27"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>recompute_limits</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1996"><span class='Ref_to_Struct'>LimitState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN28"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>pass_down_bound</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1996"><span class='Ref_to_Struct'>LimitState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><a href="../../include/nodes/execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>child_node</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *      ExecLimit 
 * 
 *      This is a very simple node which just performs LIMIT/OFFSET 
 *      filtering on the stream of tuples returned by a subplan. 
 * ---------------------------------------------------------------- 
 */ 
</span><a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span>                <span class='Comment_Single_Line'>/* return: a tuple or NULL */ 
</span><a name="LN39"></a><span class='Declare_Function'>ExecLimit</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1996"><span class='Ref_to_Struct'>LimitState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN41"></a>    <a href="../../include/access/sdir.h.html#LN21"><span class='Ref_to_Enum'>ScanDirection</span></a> <span class='Declare_Local'>direction</span><span class='Delimiter'>; 
</span><a name="LN42"></a>    <a href="../../include/executor/tuptable.h.html#LN112"><span class='Ref_to_Struct'>TupleTableSlot</span></a> <span class='Operator'>*</span><span class='Declare_Local'>slot</span><span class='Delimiter'>; 
</span><a name="LN43"></a>    <a href="../../include/nodes/execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>outerPlan</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * get information from the node 
     */ 
</span>    <a href="nodeLimit.c.html#LN41"><span class='Ref_To_Local'>direction</span></a> <span class='Operator'>= </span><a href="nodeLimit.c.html#LN39"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1998"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN814"><span class='Ref_to_Member'>state</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN407"><span class='Ref_to_Member'>es_direction</span></a><span class='Delimiter'>; 
</span>    <a href="nodeLimit.c.html#LN43"><span class='Ref_To_Local'>outerPlan</span></a> <span class='Operator'>= </span><a href="../../include/nodes/execnodes.h.html#LN854"><span class='Ref_to_Macro'>outerPlanState</span></a><span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN39"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * The main logic is a simple state machine. 
     */ 
</span>    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN39"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2004"><span class='Ref_to_Member'>lstate</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../include/nodes/execnodes.h.html#LN1987"><span class='Ref_to_EnumConst'>LIMIT_INITIAL</span></a><span class='Operator'>: 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * First call for this node, so compute limit/offset. (We can't do 
             * this any earlier, because parameters from upper nodes will not 
             * be set during ExecInitLimit.)  This also sets position = 0 and 
             * changes the state to LIMIT_RESCAN. 
             */ 
</span>            <a href="nodeLimit.c.html#LN27"><span class='Ref_to_Proto'>recompute_limits</span></a><span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN39"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* FALL THRU */ 
</span> 
        <span class='Control'>case</span> <a href="../../include/nodes/execnodes.h.html#LN1988"><span class='Ref_to_EnumConst'>LIMIT_RESCAN</span></a><span class='Operator'>: 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * If backwards scan, just return NULL without changing state. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/sdir.h.html#LN54"><span class='Ref_to_Macro'>ScanDirectionIsForward</span></a><span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN41"><span class='Ref_To_Local'>direction</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Check for empty window; if so, treat like empty subplan. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN39"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2002"><span class='Ref_to_Member'>count</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span> <span class='Operator'>&& !</span><a href="nodeLimit.c.html#LN39"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2003"><span class='Ref_to_Member'>noCount</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="nodeLimit.c.html#LN39"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2004"><span class='Ref_to_Member'>lstate</span></a> <span class='Operator'>= </span><a href="../../include/nodes/execnodes.h.html#LN1989"><span class='Ref_to_EnumConst'>LIMIT_EMPTY</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Fetch rows from subplan until we reach position &GT; offset. 
             */ 
</span>            <span class='Control'>for</span> <span class='Parentheses'>(</span><span class='Delimiter'>;;</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="nodeLimit.c.html#LN42"><span class='Ref_To_Local'>slot</span></a> <span class='Operator'>= </span><a href="../../include/executor/executor.h.html#LN229"><span class='Ref_to_Proto'>ExecProcNode</span></a><span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN43"><span class='Ref_To_Local'>outerPlan</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/executor/tuptable.h.html#LN137"><span class='Ref_to_Macro'>TupIsNull</span></a><span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN42"><span class='Ref_To_Local'>slot</span></a><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* 
                     * The subplan returns too few tuples for us to produce 
                     * any output at all. 
                     */ 
</span>                    <a href="nodeLimit.c.html#LN39"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2004"><span class='Ref_to_Member'>lstate</span></a> <span class='Operator'>= </span><a href="../../include/nodes/execnodes.h.html#LN1989"><span class='Ref_to_EnumConst'>LIMIT_EMPTY</span></a><span class='Delimiter'>; 
</span>                    <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <a href="nodeLimit.c.html#LN39"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2006"><span class='Ref_to_Member'>subSlot</span></a> <span class='Operator'>= </span><a href="nodeLimit.c.html#LN42"><span class='Ref_To_Local'>slot</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>++</span><a href="nodeLimit.c.html#LN39"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2005"><span class='Ref_to_Member'>position</span></a> <span class='Operator'>&GT; </span><a href="nodeLimit.c.html#LN39"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2001"><span class='Ref_to_Member'>offset</span></a><span class='Parentheses'>) 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Okay, we have the first tuple of the window. 
             */ 
</span>            <a href="nodeLimit.c.html#LN39"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2004"><span class='Ref_to_Member'>lstate</span></a> <span class='Operator'>= </span><a href="../../include/nodes/execnodes.h.html#LN1990"><span class='Ref_to_EnumConst'>LIMIT_INWINDOW</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="../../include/nodes/execnodes.h.html#LN1989"><span class='Ref_to_EnumConst'>LIMIT_EMPTY</span></a><span class='Operator'>: 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * The subplan is known to return no tuples (or not more than 
             * OFFSET tuples, in general).  So we return no tuples. 
             */ 
</span>            <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="../../include/nodes/execnodes.h.html#LN1990"><span class='Ref_to_EnumConst'>LIMIT_INWINDOW</span></a><span class='Operator'>: 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/access/sdir.h.html#LN54"><span class='Ref_to_Macro'>ScanDirectionIsForward</span></a><span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN41"><span class='Ref_To_Local'>direction</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * Forwards scan, so check for stepping off end of window. If 
                 * we are at the end of the window, return NULL without 
                 * advancing the subplan or the position variable; but change 
                 * the state machine state to record having done so. 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="nodeLimit.c.html#LN39"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2003"><span class='Ref_to_Member'>noCount</span></a> <span class='Operator'>&& 
</span>                    <a href="nodeLimit.c.html#LN39"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2005"><span class='Ref_to_Member'>position</span></a> <span class='Operator'>- </span><a href="nodeLimit.c.html#LN39"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2001"><span class='Ref_to_Member'>offset</span></a> <span class='Operator'>&GT;= </span><a href="nodeLimit.c.html#LN39"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2002"><span class='Ref_to_Member'>count</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <a href="nodeLimit.c.html#LN39"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2004"><span class='Ref_to_Member'>lstate</span></a> <span class='Operator'>= </span><a href="../../include/nodes/execnodes.h.html#LN1992"><span class='Ref_to_EnumConst'>LIMIT_WINDOWEND</span></a><span class='Delimiter'>; 
</span>                    <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * Get next tuple from subplan, if any. 
                 */ 
</span>                <a href="nodeLimit.c.html#LN42"><span class='Ref_To_Local'>slot</span></a> <span class='Operator'>= </span><a href="../../include/executor/executor.h.html#LN229"><span class='Ref_to_Proto'>ExecProcNode</span></a><span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN43"><span class='Ref_To_Local'>outerPlan</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/executor/tuptable.h.html#LN137"><span class='Ref_to_Macro'>TupIsNull</span></a><span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN42"><span class='Ref_To_Local'>slot</span></a><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span>                    <a href="nodeLimit.c.html#LN39"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2004"><span class='Ref_to_Member'>lstate</span></a> <span class='Operator'>= </span><a href="../../include/nodes/execnodes.h.html#LN1991"><span class='Ref_to_EnumConst'>LIMIT_SUBPLANEOF</span></a><span class='Delimiter'>; 
</span>                    <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <a href="nodeLimit.c.html#LN39"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2006"><span class='Ref_to_Member'>subSlot</span></a> <span class='Operator'>= </span><a href="nodeLimit.c.html#LN42"><span class='Ref_To_Local'>slot</span></a><span class='Delimiter'>; 
</span>                <a href="nodeLimit.c.html#LN39"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2005"><span class='Ref_to_Member'>position</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if ScanDirectionIsForwar... &raquo; </span> 
            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * Backwards scan, so check for stepping off start of window. 
                 * As above, change only state-machine status if so. 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN39"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2005"><span class='Ref_to_Member'>position</span></a> <span class='Operator'>&LT;= </span><a href="nodeLimit.c.html#LN39"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2001"><span class='Ref_to_Member'>offset</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <a href="nodeLimit.c.html#LN39"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2004"><span class='Ref_to_Member'>lstate</span></a> <span class='Operator'>= </span><a href="../../include/nodes/execnodes.h.html#LN1993"><span class='Ref_to_EnumConst'>LIMIT_WINDOWSTART</span></a><span class='Delimiter'>; 
</span>                    <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * Get previous tuple from subplan; there should be one! 
                 */ 
</span>                <a href="nodeLimit.c.html#LN42"><span class='Ref_To_Local'>slot</span></a> <span class='Operator'>= </span><a href="../../include/executor/executor.h.html#LN229"><span class='Ref_to_Proto'>ExecProcNode</span></a><span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN43"><span class='Ref_To_Local'>outerPlan</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/executor/tuptable.h.html#LN137"><span class='Ref_to_Macro'>TupIsNull</span></a><span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN42"><span class='Ref_To_Local'>slot</span></a><span class='Parentheses'>))</span> 
                    <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"LIMIT subplan failed to run backwards"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="nodeLimit.c.html#LN39"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2006"><span class='Ref_to_Member'>subSlot</span></a> <span class='Operator'>= </span><a href="nodeLimit.c.html#LN42"><span class='Ref_To_Local'>slot</span></a><span class='Delimiter'>; 
</span>                <a href="nodeLimit.c.html#LN39"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2005"><span class='Ref_to_Member'>position</span></a><span class='Operator'>--</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="../../include/nodes/execnodes.h.html#LN1991"><span class='Ref_to_EnumConst'>LIMIT_SUBPLANEOF</span></a><span class='Operator'>: 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/access/sdir.h.html#LN54"><span class='Ref_to_Macro'>ScanDirectionIsForward</span></a><span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN41"><span class='Ref_To_Local'>direction</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Backing up from subplan EOF, so re-fetch previous tuple; there 
             * should be one!  Note previous tuple must be in window. 
             */ 
</span>            <a href="nodeLimit.c.html#LN42"><span class='Ref_To_Local'>slot</span></a> <span class='Operator'>= </span><a href="../../include/executor/executor.h.html#LN229"><span class='Ref_to_Proto'>ExecProcNode</span></a><span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN43"><span class='Ref_To_Local'>outerPlan</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/executor/tuptable.h.html#LN137"><span class='Ref_to_Macro'>TupIsNull</span></a><span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN42"><span class='Ref_To_Local'>slot</span></a><span class='Parentheses'>))</span> 
                <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"LIMIT subplan failed to run backwards"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="nodeLimit.c.html#LN39"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2006"><span class='Ref_to_Member'>subSlot</span></a> <span class='Operator'>= </span><a href="nodeLimit.c.html#LN42"><span class='Ref_To_Local'>slot</span></a><span class='Delimiter'>; 
</span>            <a href="nodeLimit.c.html#LN39"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2004"><span class='Ref_to_Member'>lstate</span></a> <span class='Operator'>= </span><a href="../../include/nodes/execnodes.h.html#LN1990"><span class='Ref_to_EnumConst'>LIMIT_INWINDOW</span></a><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* position does not change 'cause we didn't advance it before */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="../../include/nodes/execnodes.h.html#LN1992"><span class='Ref_to_EnumConst'>LIMIT_WINDOWEND</span></a><span class='Operator'>: 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/access/sdir.h.html#LN54"><span class='Ref_to_Macro'>ScanDirectionIsForward</span></a><span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN41"><span class='Ref_To_Local'>direction</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Backing up from window end: simply re-return the last tuple 
             * fetched from the subplan. 
             */ 
</span>            <a href="nodeLimit.c.html#LN42"><span class='Ref_To_Local'>slot</span></a> <span class='Operator'>= </span><a href="nodeLimit.c.html#LN39"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2006"><span class='Ref_to_Member'>subSlot</span></a><span class='Delimiter'>; 
</span>            <a href="nodeLimit.c.html#LN39"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2004"><span class='Ref_to_Member'>lstate</span></a> <span class='Operator'>= </span><a href="../../include/nodes/execnodes.h.html#LN1990"><span class='Ref_to_EnumConst'>LIMIT_INWINDOW</span></a><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* position does not change 'cause we didn't advance it before */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="../../include/nodes/execnodes.h.html#LN1993"><span class='Ref_to_EnumConst'>LIMIT_WINDOWSTART</span></a><span class='Operator'>: 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/access/sdir.h.html#LN54"><span class='Ref_to_Macro'>ScanDirectionIsForward</span></a><span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN41"><span class='Ref_To_Local'>direction</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Advancing after having backed off window start: simply 
             * re-return the last tuple fetched from the subplan. 
             */ 
</span>            <a href="nodeLimit.c.html#LN42"><span class='Ref_To_Local'>slot</span></a> <span class='Operator'>= </span><a href="nodeLimit.c.html#LN39"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2006"><span class='Ref_to_Member'>subSlot</span></a><span class='Delimiter'>; 
</span>            <a href="nodeLimit.c.html#LN39"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2004"><span class='Ref_to_Member'>lstate</span></a> <span class='Operator'>= </span><a href="../../include/nodes/execnodes.h.html#LN1990"><span class='Ref_to_EnumConst'>LIMIT_INWINDOW</span></a><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* position does not change 'cause we didn't change it before */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>default</span><span class='Operator'>: 
</span>            <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"impossible LIMIT state: %d"</span><span class='Delimiter'>, 
</span>                 <span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="nodeLimit.c.html#LN39"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2004"><span class='Ref_to_Member'>lstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="nodeLimit.c.html#LN42"><span class='Ref_To_Local'>slot</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* keep compiler quiet */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch node-&GT;lstate &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* Return the current tuple */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/executor/tuptable.h.html#LN137"><span class='Ref_to_Macro'>TupIsNull</span></a><span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN42"><span class='Ref_To_Local'>slot</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="nodeLimit.c.html#LN42"><span class='Ref_To_Local'>slot</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ExecLimit &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Evaluate the limit/offset expressions --- done at startup or rescan. 
 * 
 * This is also a handy place to reset the current-position state info. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN231"></a><span class='Declare_Function'>recompute_limits</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1996"><span class='Ref_to_Struct'>LimitState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN233"></a>    <a href="../../include/nodes/execnodes.h.html#LN191"><span class='Ref_to_Struct'>ExprContext</span></a> <span class='Operator'>*</span><span class='Declare_Local'>econtext</span> <span class='Operator'>= </span><a href="nodeLimit.c.html#LN231"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1998"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN842"><span class='Ref_to_Member'>ps_ExprContext</span></a><span class='Delimiter'>; 
</span><a name="LN234"></a>    <a href="../../include/postgres.h.html#LN371"><span class='Ref_to_Typedef'>Datum</span></a>       <span class='Declare_Local'>val</span><span class='Delimiter'>; 
</span><a name="LN235"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>isNull</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN231"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1999"><span class='Ref_to_Member'>limitOffset</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="nodeLimit.c.html#LN234"><span class='Ref_To_Local'>val</span></a> <span class='Operator'>= </span><a href="../../include/executor/executor.h.html#LN279"><span class='Ref_to_Func'>ExecEvalExprSwitchContext</span></a><span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN231"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1999"><span class='Ref_to_Member'>limitOffset</span></a><span class='Delimiter'>, 
</span>                                        <a href="nodeLimit.c.html#LN233"><span class='Ref_To_Local'>econtext</span></a><span class='Delimiter'>, 
</span>                                        <span class='Operator'>&</span><a href="nodeLimit.c.html#LN235"><span class='Ref_To_Local'>isNull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* Interpret NULL offset as no offset */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN235"><span class='Ref_To_Local'>isNull</span></a><span class='Parentheses'>) 
</span>            <a href="nodeLimit.c.html#LN231"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2001"><span class='Ref_to_Member'>offset</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <a href="nodeLimit.c.html#LN231"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2001"><span class='Ref_to_Member'>offset</span></a> <span class='Operator'>= </span><a href="../../include/postgres.h.html#LN610"><span class='Ref_to_Macro'>DatumGetInt64</span></a><span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN234"><span class='Ref_To_Local'>val</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN231"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2001"><span class='Ref_to_Member'>offset</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                 <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_INVALID_ROW_COUNT_IN_RESULT_OFFSET_CLAUSE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                  <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"OFFSET must not be negative"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* No OFFSET supplied */ 
</span>        <a href="nodeLimit.c.html#LN231"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2001"><span class='Ref_to_Member'>offset</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN231"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2000"><span class='Ref_to_Member'>limitCount</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="nodeLimit.c.html#LN234"><span class='Ref_To_Local'>val</span></a> <span class='Operator'>= </span><a href="../../include/executor/executor.h.html#LN279"><span class='Ref_to_Func'>ExecEvalExprSwitchContext</span></a><span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN231"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2000"><span class='Ref_to_Member'>limitCount</span></a><span class='Delimiter'>, 
</span>                                        <a href="nodeLimit.c.html#LN233"><span class='Ref_To_Local'>econtext</span></a><span class='Delimiter'>, 
</span>                                        <span class='Operator'>&</span><a href="nodeLimit.c.html#LN235"><span class='Ref_To_Local'>isNull</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* Interpret NULL count as no count (LIMIT ALL) */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN235"><span class='Ref_To_Local'>isNull</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="nodeLimit.c.html#LN231"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2002"><span class='Ref_to_Member'>count</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <a href="nodeLimit.c.html#LN231"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2003"><span class='Ref_to_Member'>noCount</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <a href="nodeLimit.c.html#LN231"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2002"><span class='Ref_to_Member'>count</span></a> <span class='Operator'>= </span><a href="../../include/postgres.h.html#LN610"><span class='Ref_to_Macro'>DatumGetInt64</span></a><span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN234"><span class='Ref_To_Local'>val</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN231"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2002"><span class='Ref_to_Member'>count</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <a href="../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_INVALID_ROW_COUNT_IN_LIMIT_CLAUSE<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"LIMIT must not be negative"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <a href="nodeLimit.c.html#LN231"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2003"><span class='Ref_to_Member'>noCount</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if node-&GT;limitCount &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* No COUNT supplied */ 
</span>        <a href="nodeLimit.c.html#LN231"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2002"><span class='Ref_to_Member'>count</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="nodeLimit.c.html#LN231"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2003"><span class='Ref_to_Member'>noCount</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Reset position to start-of-scan */ 
</span>    <a href="nodeLimit.c.html#LN231"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2005"><span class='Ref_to_Member'>position</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="nodeLimit.c.html#LN231"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2006"><span class='Ref_to_Member'>subSlot</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Set state-machine state */ 
</span>    <a href="nodeLimit.c.html#LN231"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2004"><span class='Ref_to_Member'>lstate</span></a> <span class='Operator'>= </span><a href="../../include/nodes/execnodes.h.html#LN1988"><span class='Ref_to_EnumConst'>LIMIT_RESCAN</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Notify child node about limit, if useful */ 
</span>    <a href="nodeLimit.c.html#LN28"><span class='Ref_to_Proto'>pass_down_bound</span></a><span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN231"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/execnodes.h.html#LN854"><span class='Ref_to_Macro'>outerPlanState</span></a><span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN231"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end recompute_limits &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * If we have a COUNT, and our input is a Sort node, notify it that it can 
 * use bounded sort.  Also, if our input is a MergeAppend, we can apply the 
 * same bound to any Sorts that are direct children of the MergeAppend, 
 * since the MergeAppend surely need read no more than that many tuples from 
 * any one input.  We also have to be prepared to look through a Result, 
 * since the planner might stick one atop MergeAppend for projection purposes. 
 * 
 * This is a bit of a kluge, but we don't have any more-abstract way of 
 * communicating between the two nodes; and it doesn't seem worth trying 
 * to invent one without some more examples of special communication needs. 
 * 
 * Note: it is the responsibility of nodeSort.c to react properly to 
 * changes of these parameters.  If we ever do redesign this, it'd be a 
 * good idea to integrate this signaling with the parameter-change mechanism. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN316"></a><span class='Declare_Function'>pass_down_bound</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1996"><span class='Ref_to_Struct'>LimitState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><a href="../../include/nodes/execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>child_node</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN316"><span class='Ref_to_Parameter'>child_node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/execnodes.h.html#LN1697"><span class='Ref_to_Struct'>SortState</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN320"></a>        <a href="../../include/nodes/execnodes.h.html#LN1697"><span class='Ref_to_Struct'>SortState</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>sortState</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1697"><span class='Ref_to_Struct'>SortState</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeLimit.c.html#LN316"><span class='Ref_to_Parameter'>child_node</span></a><span class='Delimiter'>; 
</span><a name="LN321"></a>        <a href="../../include/c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a>       <span class='Declare_Local'>tuples_needed</span> <span class='Operator'>= </span><a href="nodeLimit.c.html#LN316"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2002"><span class='Ref_to_Member'>count</span></a> <span class='Operator'>+ </span><a href="nodeLimit.c.html#LN316"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2001"><span class='Ref_to_Member'>offset</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* negative test checks for overflow in sum */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN316"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2003"><span class='Ref_to_Member'>noCount</span></a> <span class='Operator'>|| </span><a href="nodeLimit.c.html#LN321"><span class='Ref_To_Local'>tuples_needed</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* make sure flag gets reset if needed upon rescan */ 
</span>            <a href="nodeLimit.c.html#LN320"><span class='Ref_To_Local'>sortState</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1701"><span class='Ref_to_Member'>bounded</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <a href="nodeLimit.c.html#LN320"><span class='Ref_To_Local'>sortState</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1701"><span class='Ref_to_Member'>bounded</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <a href="nodeLimit.c.html#LN320"><span class='Ref_To_Local'>sortState</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1702"><span class='Ref_to_Member'>bound</span></a> <span class='Operator'>= </span><a href="nodeLimit.c.html#LN321"><span class='Ref_To_Local'>tuples_needed</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN316"><span class='Ref_to_Parameter'>child_node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/execnodes.h.html#LN976"><span class='Ref_to_Struct'>MergeAppendState</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN337"></a>        <a href="../../include/nodes/execnodes.h.html#LN976"><span class='Ref_to_Struct'>MergeAppendState</span></a> <span class='Operator'>*</span><span class='Declare_Local'>maState</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN976"><span class='Ref_to_Struct'>MergeAppendState</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeLimit.c.html#LN316"><span class='Ref_to_Parameter'>child_node</span></a><span class='Delimiter'>; 
</span><a name="LN338"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN338"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="nodeLimit.c.html#LN338"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="nodeLimit.c.html#LN337"><span class='Ref_To_Local'>maState</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN980"><span class='Ref_to_Member'>ms_nplans</span></a><span class='Delimiter'>; </span><a href="nodeLimit.c.html#LN338"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>            <a href="nodeLimit.c.html#LN28"><span class='Ref_to_Proto'>pass_down_bound</span></a><span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN316"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="nodeLimit.c.html#LN337"><span class='Ref_To_Local'>maState</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN979"><span class='Ref_to_Member'>mergeplans</span></a><span class='Delimiter'>[</span><a href="nodeLimit.c.html#LN338"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN316"><span class='Ref_to_Parameter'>child_node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/execnodes.h.html#LN888"><span class='Ref_to_Struct'>ResultState</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * If Result supported qual checking, we'd have to punt on seeing a 
         * qual.  Note that having a resconstantqual is not a showstopper: if 
         * that fails we're not getting any rows at all. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN854"><span class='Ref_to_Macro'>outerPlanState</span></a><span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN316"><span class='Ref_to_Parameter'>child_node</span></a><span class='Parentheses'>))</span> 
            <a href="nodeLimit.c.html#LN28"><span class='Ref_to_Proto'>pass_down_bound</span></a><span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN316"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/execnodes.h.html#LN854"><span class='Ref_to_Macro'>outerPlanState</span></a><span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN316"><span class='Ref_to_Parameter'>child_node</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end pass_down_bound &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *      ExecInitLimit 
 * 
 *      This initializes the limit node state structures and 
 *      the node's subplan. 
 * ---------------------------------------------------------------- 
 */ 
</span><a href="../../include/nodes/execnodes.h.html#LN1996"><span class='Ref_to_Struct'>LimitState</span></a> <span class='Operator'>* 
</span><a name="LN363"></a><span class='Declare_Function'>ExecInitLimit</span><span class='Parentheses'>(</span><a href="../../include/nodes/plannodes.h.html#LN913"><span class='Ref_to_Struct'>Limit</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><a href="../../include/nodes/execnodes.h.html#LN402"><span class='Ref_to_Struct'>EState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>estate</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>eflags</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN365"></a>    <a href="../../include/nodes/execnodes.h.html#LN1996"><span class='Ref_to_Struct'>LimitState</span></a> <span class='Operator'>*</span><span class='Declare_Local'>limitstate</span><span class='Delimiter'>; 
</span><a name="LN366"></a>    <a href="../../include/nodes/plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>outerPlan</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* check for unsupported flags */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN363"><span class='Ref_to_Parameter'>eflags</span></a> <span class='Operator'>& </span><a href="../../include/executor/executor.h.html#LN60"><span class='Ref_to_Const'>EXEC_FLAG_MARK</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * create state structure 
     */ 
</span>    <a href="nodeLimit.c.html#LN365"><span class='Ref_To_Local'>limitstate</span></a> <span class='Operator'>= </span><a href="../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1996"><span class='Ref_to_Struct'>LimitState</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="nodeLimit.c.html#LN365"><span class='Ref_To_Local'>limitstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1998"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN812"><span class='Ref_to_Member'>plan</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeLimit.c.html#LN363"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span>    <a href="nodeLimit.c.html#LN365"><span class='Ref_To_Local'>limitstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1998"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN814"><span class='Ref_to_Member'>state</span></a> <span class='Operator'>= </span><a href="nodeLimit.c.html#LN363"><span class='Ref_to_Parameter'>estate</span></a><span class='Delimiter'>; 
</span> 
    <a href="nodeLimit.c.html#LN365"><span class='Ref_To_Local'>limitstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2004"><span class='Ref_to_Member'>lstate</span></a> <span class='Operator'>= </span><a href="../../include/nodes/execnodes.h.html#LN1987"><span class='Ref_to_EnumConst'>LIMIT_INITIAL</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Miscellaneous initialization 
     * 
     * Limit nodes never call ExecQual or ExecProject, but they need an 
     * exprcontext anyway to evaluate the limit/offset parameters in. 
     */ 
</span>    <a href="execUtils.c.html#LN416"><span class='Ref_to_Func'>ExecAssignExprContext</span></a><span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN363"><span class='Ref_to_Parameter'>estate</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nodeLimit.c.html#LN365"><span class='Ref_To_Local'>limitstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1998"><span class='Ref_to_Member'>ps</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * initialize child expressions 
     */ 
</span>    <a href="nodeLimit.c.html#LN365"><span class='Ref_To_Local'>limitstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1999"><span class='Ref_to_Member'>limitOffset</span></a> <span class='Operator'>= </span><a href="execExpr.c.html#LN111"><span class='Ref_to_Func'>ExecInitExpr</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeLimit.c.html#LN363"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN916"><span class='Ref_to_Member'>limitOffset</span></a><span class='Delimiter'>, 
</span>                                           <span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeLimit.c.html#LN365"><span class='Ref_To_Local'>limitstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="nodeLimit.c.html#LN365"><span class='Ref_To_Local'>limitstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN2000"><span class='Ref_to_Member'>limitCount</span></a> <span class='Operator'>= </span><a href="execExpr.c.html#LN111"><span class='Ref_to_Func'>ExecInitExpr</span></a><span class='Parentheses'>((</span><a href="../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeLimit.c.html#LN363"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/plannodes.h.html#LN917"><span class='Ref_to_Member'>limitCount</span></a><span class='Delimiter'>, 
</span>                                          <span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN808"><span class='Ref_to_Struct'>PlanState</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="nodeLimit.c.html#LN365"><span class='Ref_To_Local'>limitstate</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Tuple table initialization (XXX not actually used...) 
     */ 
</span>    <a href="../../include/executor/executor.h.html#LN400"><span class='Ref_to_Proto'>ExecInitResultTupleSlot</span></a><span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN363"><span class='Ref_to_Parameter'>estate</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="nodeLimit.c.html#LN365"><span class='Ref_To_Local'>limitstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1998"><span class='Ref_to_Member'>ps</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * then initialize outer plan 
     */ 
</span>    <a href="nodeLimit.c.html#LN366"><span class='Ref_To_Local'>outerPlan</span></a> <span class='Operator'>= </span><a href="nodeLimit.c.html#LN366"><span class='Ref_To_Local'>outerPlan</span></a><span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN363"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/nodes/execnodes.h.html#LN854"><span class='Ref_to_Macro'>outerPlanState</span></a><span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN365"><span class='Ref_To_Local'>limitstate</span></a><span class='Parentheses'>) </span><span class='Operator'>= </span><a href="execProcnode.c.html#LN138"><span class='Ref_to_Func'>ExecInitNode</span></a><span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN366"><span class='Ref_To_Local'>outerPlan</span></a><span class='Delimiter'>, </span><a href="nodeLimit.c.html#LN363"><span class='Ref_to_Parameter'>estate</span></a><span class='Delimiter'>, </span><a href="nodeLimit.c.html#LN363"><span class='Ref_to_Parameter'>eflags</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * limit nodes do no projections, so initialize projection info for this 
     * node appropriately 
     */ 
</span>    <a href="execUtils.c.html#LN438"><span class='Ref_to_Func'>ExecAssignResultTypeFromTL</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nodeLimit.c.html#LN365"><span class='Ref_To_Local'>limitstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1998"><span class='Ref_to_Member'>ps</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="nodeLimit.c.html#LN365"><span class='Ref_To_Local'>limitstate</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1998"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN843"><span class='Ref_to_Member'>ps_ProjInfo</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="nodeLimit.c.html#LN365"><span class='Ref_To_Local'>limitstate</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end ExecInitLimit &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* ---------------------------------------------------------------- 
 *      ExecEndLimit 
 * 
 *      This shuts down the subplan and frees resources allocated 
 *      to this node. 
 * ---------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN425"></a><span class='Declare_Function'>ExecEndLimit</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1996"><span class='Ref_to_Struct'>LimitState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="../../include/executor/executor.h.html#LN476"><span class='Ref_to_Proto'>ExecFreeExprContext</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="nodeLimit.c.html#LN425"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1998"><span class='Ref_to_Member'>ps</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/executor/executor.h.html#LN231"><span class='Ref_to_Proto'>ExecEndNode</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN854"><span class='Ref_to_Macro'>outerPlanState</span></a><span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN425"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
} 
</span> 
 
<span class='Keyword'>void 
</span><a name="LN433"></a><span class='Declare_Function'>ExecReScanLimit</span><span class='Parentheses'>(</span><a href="../../include/nodes/execnodes.h.html#LN1996"><span class='Ref_to_Struct'>LimitState</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * Recompute limit/offset in case parameters changed, and reset the state 
     * machine.  We must do this before rescanning our child node, in case 
     * it's a Sort that we are passing the parameters down to. 
     */ 
</span>    <a href="nodeLimit.c.html#LN27"><span class='Ref_to_Proto'>recompute_limits</span></a><span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN433"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * if chgParam of subnode is not null then plan will be re-scanned by 
     * first ExecProcNode. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN433"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1998"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN827"><span class='Ref_to_Member'>lefttree</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN836"><span class='Ref_to_Member'>chgParam</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="execAmi.c.html#LN73"><span class='Ref_to_Func'>ExecReScan</span></a><span class='Parentheses'>(</span><a href="nodeLimit.c.html#LN433"><span class='Ref_to_Parameter'>node</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/execnodes.h.html#LN1998"><span class='Ref_to_Member'>ps</span></a><span class='Operator'>.</span><a href="../../include/nodes/execnodes.h.html#LN827"><span class='Ref_to_Member'>lefttree</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span></pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>