<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\nodes\list.c</title>
<LINK REL=StyleSheet HREF="../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\nodes\list.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:41 2017
</td></tr>
<tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
</span><span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * list.c 
 *    implementation for PostgreSQL generic linked list package 
 * 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * 
 * IDENTIFICATION 
 *    src/backend/nodes/list.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"nodes/pg_list.h"</span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * Routines to simplify writing assertions about the type of a list; a 
 * NIL list is considered to be an empty list of any type. 
 */ 
</span><a name="LN24"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>IsPointerList</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>l</span><span class='Parentheses'>)</span>        <span class='Parentheses'>((</span><a href="list.c.html#LN24"><span class='Ref_to_Parameter'>l</span></a><span class='Parentheses'>)</span> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>|| </span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>((</span><a href="list.c.html#LN24"><span class='Ref_to_Parameter'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a><span class='Parentheses'>))</span> 
<a name="LN25"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>IsIntegerList</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>l</span><span class='Parentheses'>)</span>        <span class='Parentheses'>((</span><a href="list.c.html#LN25"><span class='Ref_to_Parameter'>l</span></a><span class='Parentheses'>)</span> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>|| </span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>((</span><a href="list.c.html#LN25"><span class='Ref_to_Parameter'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span>IntList<span class='Parentheses'>))</span> 
<a name="LN26"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>IsOidList</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>l</span><span class='Parentheses'>)</span>            <span class='Parentheses'>((</span><a href="list.c.html#LN26"><span class='Ref_to_Parameter'>l</span></a><span class='Parentheses'>)</span> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>|| </span><a href="../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>((</span><a href="list.c.html#LN26"><span class='Ref_to_Parameter'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span>OidList<span class='Parentheses'>))</span> 
 
<span class='Directive'>#ifdef</span> USE_ASSERT_CHECKING 
<span class='Comment_Multi_Line'>/* 
 * Check that the specified List is valid (so far as we can tell). 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN33"></a><span class='Declare_Function'>check_list_invariants</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="list.c.html#LN33"><span class='Ref_to_Parameter'>list</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN33"><span class='Ref_to_Parameter'>list</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN47"><span class='Ref_to_Member'>length</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN33"><span class='Ref_to_Parameter'>list</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN48"><span class='Ref_to_Member'>head</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN33"><span class='Ref_to_Parameter'>list</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN49"><span class='Ref_to_Member'>tail</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN33"><span class='Ref_to_Parameter'>list</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN46"><span class='Ref_to_Member'>type</span></a> <span class='Operator'>== </span><a href="../../include/nodes/nodes.h.html#LN290"><span class='Ref_to_EnumConst'>T_List</span></a> <span class='Operator'>|| 
</span>           <a href="list.c.html#LN33"><span class='Ref_to_Parameter'>list</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN46"><span class='Ref_to_Member'>type</span></a> <span class='Operator'>== </span><a href="../../include/nodes/nodes.h.html#LN291"><span class='Ref_to_EnumConst'>T_IntList</span></a> <span class='Operator'>|| 
</span>           <a href="list.c.html#LN33"><span class='Ref_to_Parameter'>list</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN46"><span class='Ref_to_Member'>type</span></a> <span class='Operator'>== </span><a href="../../include/nodes/nodes.h.html#LN292"><span class='Ref_to_EnumConst'>T_OidList</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="list.c.html#LN33"><span class='Ref_to_Parameter'>list</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN47"><span class='Ref_to_Member'>length</span></a> <span class='Operator'>== </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN33"><span class='Ref_to_Parameter'>list</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN48"><span class='Ref_to_Member'>head</span></a> <span class='Operator'>== </span><a href="list.c.html#LN33"><span class='Ref_to_Parameter'>list</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN49"><span class='Ref_to_Member'>tail</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="list.c.html#LN33"><span class='Ref_to_Parameter'>list</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN47"><span class='Ref_to_Member'>length</span></a> <span class='Operator'>== </span><span class='Number'>2</span><span class='Parentheses'>) 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN33"><span class='Ref_to_Parameter'>list</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN48"><span class='Ref_to_Member'>head</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN60"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>== </span><a href="list.c.html#LN33"><span class='Ref_to_Parameter'>list</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN49"><span class='Ref_to_Member'>tail</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN33"><span class='Ref_to_Parameter'>list</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN49"><span class='Ref_to_Member'>tail</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN60"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end check_list_invariants &raquo; </span> 
<span class='Directive'>#else</span> 
<a name="LN53"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>check_list_invariants</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>l</span><span class='Parentheses'>) 
</span><span class='Directive'>#endif</span>   <span class='Comment_Single_Line'>/* USE_ASSERT_CHECKING */ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Return a freshly allocated List. Since empty non-NIL lists are 
 * invalid, new_list() also allocates the head cell of the new list: 
 * the caller should be sure to fill in that cell's data. 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN62"></a><span class='Declare_Function'>new_list</span><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN25"><span class='Ref_to_Enum'>NodeTag</span></a> <span class='Declare_Parameter'>type</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN64"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>new_list</span><span class='Delimiter'>; 
</span><a name="LN65"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>new_head</span><span class='Delimiter'>; 
</span> 
    <a href="list.c.html#LN65"><span class='Ref_To_Local'>new_head</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="list.c.html#LN65"><span class='Ref_To_Local'>new_head</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="list.c.html#LN65"><span class='Ref_To_Local'>new_head</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN60"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* new_head-&GT;data is left undefined! */ 
</span> 
    <a href="list.c.html#LN64"><span class='Ref_To_Local'>new_list</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="list.c.html#LN64"><span class='Ref_To_Local'>new_list</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="list.c.html#LN64"><span class='Ref_To_Local'>new_list</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN46"><span class='Ref_to_Member'>type</span></a> <span class='Operator'>= </span><a href="list.c.html#LN62"><span class='Ref_to_Parameter'>type</span></a><span class='Delimiter'>; 
</span>    <a href="list.c.html#LN64"><span class='Ref_To_Local'>new_list</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN47"><span class='Ref_to_Member'>length</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <a href="list.c.html#LN64"><span class='Ref_To_Local'>new_list</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN48"><span class='Ref_to_Member'>head</span></a> <span class='Operator'>= </span><a href="list.c.html#LN65"><span class='Ref_To_Local'>new_head</span></a><span class='Delimiter'>; 
</span>    <a href="list.c.html#LN64"><span class='Ref_To_Local'>new_list</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN49"><span class='Ref_to_Member'>tail</span></a> <span class='Operator'>= </span><a href="list.c.html#LN65"><span class='Ref_To_Local'>new_head</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="list.c.html#LN64"><span class='Ref_To_Local'>new_list</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Allocate a new cell and make it the head of the specified 
 * list. Assumes the list it is passed is non-NIL. 
 * 
 * The data in the new head cell is undefined; the caller should be 
 * sure to fill it in 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN88"></a><span class='Declare_Function'>new_head_cell</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN90"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>new_head</span><span class='Delimiter'>; 
</span> 
    <a href="list.c.html#LN90"><span class='Ref_To_Local'>new_head</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="list.c.html#LN90"><span class='Ref_To_Local'>new_head</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="list.c.html#LN90"><span class='Ref_To_Local'>new_head</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN60"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>= </span><a href="list.c.html#LN88"><span class='Ref_to_Parameter'>list</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN48"><span class='Ref_to_Member'>head</span></a><span class='Delimiter'>; 
</span> 
    <a href="list.c.html#LN88"><span class='Ref_to_Parameter'>list</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN48"><span class='Ref_to_Member'>head</span></a> <span class='Operator'>= </span><a href="list.c.html#LN90"><span class='Ref_To_Local'>new_head</span></a><span class='Delimiter'>; 
</span>    <a href="list.c.html#LN88"><span class='Ref_to_Parameter'>list</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN47"><span class='Ref_to_Member'>length</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Allocate a new cell and make it the tail of the specified 
 * list. Assumes the list it is passed is non-NIL. 
 * 
 * The data in the new tail cell is undefined; the caller should be 
 * sure to fill it in 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN107"></a><span class='Declare_Function'>new_tail_cell</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN109"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>new_tail</span><span class='Delimiter'>; 
</span> 
    <a href="list.c.html#LN109"><span class='Ref_To_Local'>new_tail</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="list.c.html#LN109"><span class='Ref_To_Local'>new_tail</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="list.c.html#LN109"><span class='Ref_To_Local'>new_tail</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN60"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <a href="list.c.html#LN107"><span class='Ref_to_Parameter'>list</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN49"><span class='Ref_to_Member'>tail</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN60"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>= </span><a href="list.c.html#LN109"><span class='Ref_To_Local'>new_tail</span></a><span class='Delimiter'>; 
</span>    <a href="list.c.html#LN107"><span class='Ref_to_Parameter'>list</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN49"><span class='Ref_to_Member'>tail</span></a> <span class='Operator'>= </span><a href="list.c.html#LN109"><span class='Ref_To_Local'>new_tail</span></a><span class='Delimiter'>; 
</span>    <a href="list.c.html#LN107"><span class='Ref_to_Parameter'>list</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN47"><span class='Ref_to_Member'>length</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Append a pointer to the list. A pointer to the modified list is 
 * returned. Note that this function may or may not destructively 
 * modify the list; callers should always use this function's return 
 * value, rather than continuing to use the pointer passed as the 
 * first argument. 
 */ 
</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN127"></a><span class='Declare_Function'>lappend</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>datum</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN24"><span class='Ref_to_Macro'>IsPointerList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN127"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="list.c.html#LN127"><span class='Ref_to_Parameter'>list</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <a href="list.c.html#LN127"><span class='Ref_to_Parameter'>list</span></a> <span class='Operator'>= </span><a href="list.c.html#LN61"><span class='Ref_to_Func'>new_list</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN290"><span class='Ref_to_EnumConst'>T_List</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="list.c.html#LN106"><span class='Ref_to_Func'>new_tail_cell</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN127"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN127"><span class='Ref_to_Parameter'>list</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN49"><span class='Ref_to_Member'>tail</span></a><span class='Parentheses'>) </span><span class='Operator'>= </span><a href="list.c.html#LN127"><span class='Ref_to_Parameter'>datum</span></a><span class='Delimiter'>; 
</span>    <a href="list.c.html#LN32"><span class='Ref_to_Func'>check_list_invariants</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN127"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="list.c.html#LN127"><span class='Ref_to_Parameter'>list</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Append an integer to the specified list. See lappend() 
 */ 
</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN145"></a><span class='Declare_Function'>lappend_int</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>datum</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN25"><span class='Ref_to_Macro'>IsIntegerList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN145"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="list.c.html#LN145"><span class='Ref_to_Parameter'>list</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <a href="list.c.html#LN145"><span class='Ref_to_Parameter'>list</span></a> <span class='Operator'>= </span><a href="list.c.html#LN61"><span class='Ref_to_Func'>new_list</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN291"><span class='Ref_to_EnumConst'>T_IntList</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="list.c.html#LN106"><span class='Ref_to_Func'>new_tail_cell</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN145"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN106"><span class='Ref_to_Macro'>lfirst_int</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN145"><span class='Ref_to_Parameter'>list</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN49"><span class='Ref_to_Member'>tail</span></a><span class='Parentheses'>) </span><span class='Operator'>= </span><a href="list.c.html#LN145"><span class='Ref_to_Parameter'>datum</span></a><span class='Delimiter'>; 
</span>    <a href="list.c.html#LN32"><span class='Ref_to_Func'>check_list_invariants</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN145"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="list.c.html#LN145"><span class='Ref_to_Parameter'>list</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Append an OID to the specified list. See lappend() 
 */ 
</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN163"></a><span class='Declare_Function'>lappend_oid</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>datum</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN26"><span class='Ref_to_Macro'>IsOidList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN163"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="list.c.html#LN163"><span class='Ref_to_Parameter'>list</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <a href="list.c.html#LN163"><span class='Ref_to_Parameter'>list</span></a> <span class='Operator'>= </span><a href="list.c.html#LN61"><span class='Ref_to_Func'>new_list</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN292"><span class='Ref_to_EnumConst'>T_OidList</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="list.c.html#LN106"><span class='Ref_to_Func'>new_tail_cell</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN163"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN107"><span class='Ref_to_Macro'>lfirst_oid</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN163"><span class='Ref_to_Parameter'>list</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN49"><span class='Ref_to_Member'>tail</span></a><span class='Parentheses'>) </span><span class='Operator'>= </span><a href="list.c.html#LN163"><span class='Ref_to_Parameter'>datum</span></a><span class='Delimiter'>; 
</span>    <a href="list.c.html#LN32"><span class='Ref_to_Func'>check_list_invariants</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN163"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="list.c.html#LN163"><span class='Ref_to_Parameter'>list</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Add a new cell to the list, in the position after 'prev_cell'. The 
 * data in the cell is left undefined, and must be filled in by the 
 * caller. 'list' is assumed to be non-NIL, and 'prev_cell' is assumed 
 * to be non-NULL and a member of 'list'. 
 */ 
</span><span class='Keyword'>static </span><a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a> <span class='Operator'>* 
</span><a name="LN184"></a><span class='Declare_Function'>add_new_cell</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>prev_cell</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN186"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>new_cell</span><span class='Delimiter'>; 
</span> 
    <a href="list.c.html#LN186"><span class='Ref_To_Local'>new_cell</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="list.c.html#LN186"><span class='Ref_To_Local'>new_cell</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* new_cell-&GT;data is left undefined! */ 
</span>    <a href="list.c.html#LN186"><span class='Ref_To_Local'>new_cell</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN60"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>= </span><a href="list.c.html#LN184"><span class='Ref_to_Parameter'>prev_cell</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN60"><span class='Ref_to_Member'>next</span></a><span class='Delimiter'>; 
</span>    <a href="list.c.html#LN184"><span class='Ref_to_Parameter'>prev_cell</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN60"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>= </span><a href="list.c.html#LN186"><span class='Ref_To_Local'>new_cell</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="list.c.html#LN184"><span class='Ref_to_Parameter'>list</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN49"><span class='Ref_to_Member'>tail</span></a> <span class='Operator'>== </span><a href="list.c.html#LN184"><span class='Ref_to_Parameter'>prev_cell</span></a><span class='Parentheses'>) 
</span>        <a href="list.c.html#LN184"><span class='Ref_to_Parameter'>list</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN49"><span class='Ref_to_Member'>tail</span></a> <span class='Operator'>= </span><a href="list.c.html#LN186"><span class='Ref_To_Local'>new_cell</span></a><span class='Delimiter'>; 
</span> 
    <a href="list.c.html#LN184"><span class='Ref_to_Parameter'>list</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN47"><span class='Ref_to_Member'>length</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="list.c.html#LN186"><span class='Ref_To_Local'>new_cell</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Add a new cell to the specified list (which must be non-NIL); 
 * it will be placed after the list cell 'prev' (which must be 
 * non-NULL and a member of 'list'). The data placed in the new cell 
 * is 'datum'. The newly-constructed cell is returned. 
 */ 
</span><a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a> <span class='Operator'>* 
</span><a name="LN208"></a><span class='Declare_Function'>lappend_cell</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>prev</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>datum</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN210"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>new_cell</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN24"><span class='Ref_to_Macro'>IsPointerList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN208"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="list.c.html#LN210"><span class='Ref_To_Local'>new_cell</span></a> <span class='Operator'>= </span><a href="list.c.html#LN183"><span class='Ref_to_Func'>add_new_cell</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN208"><span class='Ref_to_Parameter'>list</span></a><span class='Delimiter'>, </span><a href="list.c.html#LN208"><span class='Ref_to_Parameter'>prev</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN210"><span class='Ref_To_Local'>new_cell</span></a><span class='Parentheses'>) </span><span class='Operator'>= </span><a href="list.c.html#LN208"><span class='Ref_to_Parameter'>datum</span></a><span class='Delimiter'>; 
</span>    <a href="list.c.html#LN32"><span class='Ref_to_Func'>check_list_invariants</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN208"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="list.c.html#LN210"><span class='Ref_To_Local'>new_cell</span></a><span class='Delimiter'>; 
} 
</span> 
<a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a> <span class='Operator'>* 
</span><a name="LN221"></a><span class='Declare_Function'>lappend_cell_int</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>prev</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>datum</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN223"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>new_cell</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN25"><span class='Ref_to_Macro'>IsIntegerList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN221"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="list.c.html#LN223"><span class='Ref_To_Local'>new_cell</span></a> <span class='Operator'>= </span><a href="list.c.html#LN183"><span class='Ref_to_Func'>add_new_cell</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN221"><span class='Ref_to_Parameter'>list</span></a><span class='Delimiter'>, </span><a href="list.c.html#LN221"><span class='Ref_to_Parameter'>prev</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/nodes/pg_list.h.html#LN106"><span class='Ref_to_Macro'>lfirst_int</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN223"><span class='Ref_To_Local'>new_cell</span></a><span class='Parentheses'>) </span><span class='Operator'>= </span><a href="list.c.html#LN221"><span class='Ref_to_Parameter'>datum</span></a><span class='Delimiter'>; 
</span>    <a href="list.c.html#LN32"><span class='Ref_to_Func'>check_list_invariants</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN221"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="list.c.html#LN223"><span class='Ref_To_Local'>new_cell</span></a><span class='Delimiter'>; 
} 
</span> 
<a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a> <span class='Operator'>* 
</span><a name="LN234"></a><span class='Declare_Function'>lappend_cell_oid</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>prev</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>datum</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN236"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>new_cell</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN26"><span class='Ref_to_Macro'>IsOidList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN234"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="list.c.html#LN236"><span class='Ref_To_Local'>new_cell</span></a> <span class='Operator'>= </span><a href="list.c.html#LN183"><span class='Ref_to_Func'>add_new_cell</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN234"><span class='Ref_to_Parameter'>list</span></a><span class='Delimiter'>, </span><a href="list.c.html#LN234"><span class='Ref_to_Parameter'>prev</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/nodes/pg_list.h.html#LN107"><span class='Ref_to_Macro'>lfirst_oid</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN236"><span class='Ref_To_Local'>new_cell</span></a><span class='Parentheses'>) </span><span class='Operator'>= </span><a href="list.c.html#LN234"><span class='Ref_to_Parameter'>datum</span></a><span class='Delimiter'>; 
</span>    <a href="list.c.html#LN32"><span class='Ref_to_Func'>check_list_invariants</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN234"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="list.c.html#LN236"><span class='Ref_To_Local'>new_cell</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Prepend a new element to the list. A pointer to the modified list 
 * is returned. Note that this function may or may not destructively 
 * modify the list; callers should always use this function's return 
 * value, rather than continuing to use the pointer passed as the 
 * second argument. 
 * 
 * Caution: before Postgres 8.0, the original List was unmodified and 
 * could be considered to retain its separate identity.  This is no longer 
 * the case. 
 */ 
</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN258"></a><span class='Declare_Function'>lcons</span><span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>datum</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN24"><span class='Ref_to_Macro'>IsPointerList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN258"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="list.c.html#LN258"><span class='Ref_to_Parameter'>list</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <a href="list.c.html#LN258"><span class='Ref_to_Parameter'>list</span></a> <span class='Operator'>= </span><a href="list.c.html#LN61"><span class='Ref_to_Func'>new_list</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN290"><span class='Ref_to_EnumConst'>T_List</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="list.c.html#LN87"><span class='Ref_to_Func'>new_head_cell</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN258"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN258"><span class='Ref_to_Parameter'>list</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN48"><span class='Ref_to_Member'>head</span></a><span class='Parentheses'>) </span><span class='Operator'>= </span><a href="list.c.html#LN258"><span class='Ref_to_Parameter'>datum</span></a><span class='Delimiter'>; 
</span>    <a href="list.c.html#LN32"><span class='Ref_to_Func'>check_list_invariants</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN258"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="list.c.html#LN258"><span class='Ref_to_Parameter'>list</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Prepend an integer to the list. See lcons() 
 */ 
</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN276"></a><span class='Declare_Function'>lcons_int</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>datum</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN25"><span class='Ref_to_Macro'>IsIntegerList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN276"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="list.c.html#LN276"><span class='Ref_to_Parameter'>list</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <a href="list.c.html#LN276"><span class='Ref_to_Parameter'>list</span></a> <span class='Operator'>= </span><a href="list.c.html#LN61"><span class='Ref_to_Func'>new_list</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN291"><span class='Ref_to_EnumConst'>T_IntList</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="list.c.html#LN87"><span class='Ref_to_Func'>new_head_cell</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN276"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN106"><span class='Ref_to_Macro'>lfirst_int</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN276"><span class='Ref_to_Parameter'>list</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN48"><span class='Ref_to_Member'>head</span></a><span class='Parentheses'>) </span><span class='Operator'>= </span><a href="list.c.html#LN276"><span class='Ref_to_Parameter'>datum</span></a><span class='Delimiter'>; 
</span>    <a href="list.c.html#LN32"><span class='Ref_to_Func'>check_list_invariants</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN276"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="list.c.html#LN276"><span class='Ref_to_Parameter'>list</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Prepend an OID to the list. See lcons() 
 */ 
</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN294"></a><span class='Declare_Function'>lcons_oid</span><span class='Parentheses'>(</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>datum</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN26"><span class='Ref_to_Macro'>IsOidList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN294"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="list.c.html#LN294"><span class='Ref_to_Parameter'>list</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <a href="list.c.html#LN294"><span class='Ref_to_Parameter'>list</span></a> <span class='Operator'>= </span><a href="list.c.html#LN61"><span class='Ref_to_Func'>new_list</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN292"><span class='Ref_to_EnumConst'>T_OidList</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="list.c.html#LN87"><span class='Ref_to_Func'>new_head_cell</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN294"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN107"><span class='Ref_to_Macro'>lfirst_oid</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN294"><span class='Ref_to_Parameter'>list</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN48"><span class='Ref_to_Member'>head</span></a><span class='Parentheses'>) </span><span class='Operator'>= </span><a href="list.c.html#LN294"><span class='Ref_to_Parameter'>datum</span></a><span class='Delimiter'>; 
</span>    <a href="list.c.html#LN32"><span class='Ref_to_Func'>check_list_invariants</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN294"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="list.c.html#LN294"><span class='Ref_to_Parameter'>list</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Concatenate list2 to the end of list1, and return list1. list1 is 
 * destructively changed. Callers should be sure to use the return 
 * value as the new pointer to the concatenated list: the 'list1' 
 * input pointer may or may not be the same as the returned pointer. 
 * 
 * The nodes in list2 are merely appended to the end of list1 in-place 
 * (i.e. they aren't copied; the two lists will share some of the same 
 * storage). Therefore, invoking list_free() on list2 will also 
 * invalidate a portion of list1. 
 */ 
</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN320"></a><span class='Declare_Function'>list_concat</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list1</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list2</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="list.c.html#LN320"><span class='Ref_to_Parameter'>list1</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="list.c.html#LN320"><span class='Ref_to_Parameter'>list2</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="list.c.html#LN320"><span class='Ref_to_Parameter'>list2</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="list.c.html#LN320"><span class='Ref_to_Parameter'>list1</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="list.c.html#LN320"><span class='Ref_to_Parameter'>list1</span></a> <span class='Operator'>== </span><a href="list.c.html#LN320"><span class='Ref_to_Parameter'>list2</span></a><span class='Parentheses'>) 
</span>        <a href="../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cannot list_concat() a list to itself"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN320"><span class='Ref_to_Parameter'>list1</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN46"><span class='Ref_to_Member'>type</span></a> <span class='Operator'>== </span><a href="list.c.html#LN320"><span class='Ref_to_Parameter'>list2</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN46"><span class='Ref_to_Member'>type</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="list.c.html#LN320"><span class='Ref_to_Parameter'>list1</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN47"><span class='Ref_to_Member'>length</span></a> <span class='Operator'>+= </span><a href="list.c.html#LN320"><span class='Ref_to_Parameter'>list2</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN47"><span class='Ref_to_Member'>length</span></a><span class='Delimiter'>; 
</span>    <a href="list.c.html#LN320"><span class='Ref_to_Parameter'>list1</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN49"><span class='Ref_to_Member'>tail</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN60"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>= </span><a href="list.c.html#LN320"><span class='Ref_to_Parameter'>list2</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN48"><span class='Ref_to_Member'>head</span></a><span class='Delimiter'>; 
</span>    <a href="list.c.html#LN320"><span class='Ref_to_Parameter'>list1</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN49"><span class='Ref_to_Member'>tail</span></a> <span class='Operator'>= </span><a href="list.c.html#LN320"><span class='Ref_to_Parameter'>list2</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN49"><span class='Ref_to_Member'>tail</span></a><span class='Delimiter'>; 
</span> 
    <a href="list.c.html#LN32"><span class='Ref_to_Func'>check_list_invariants</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN320"><span class='Ref_to_Parameter'>list1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="list.c.html#LN320"><span class='Ref_to_Parameter'>list1</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Truncate 'list' to contain no more than 'new_size' elements. This 
 * modifies the list in-place! Despite this, callers should use the 
 * pointer returned by this function to refer to the newly truncated 
 * list -- it may or may not be the same as the pointer that was 
 * passed. 
 * 
 * Note that any cells removed by list_truncate() are NOT pfree'd. 
 */ 
</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN349"></a><span class='Declare_Function'>list_truncate</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>new_size</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN351"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>cell</span><span class='Delimiter'>; 
</span><a name="LN352"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>n</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="list.c.html#LN349"><span class='Ref_to_Parameter'>new_size</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* truncate to zero length */ 
</span> 
    <span class='Comment_Multi_Line'>/* If asked to effectively extend the list, do nothing */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="list.c.html#LN349"><span class='Ref_to_Parameter'>new_size</span></a> <span class='Operator'>&GT;= </span><a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN349"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <a href="list.c.html#LN349"><span class='Ref_to_Parameter'>list</span></a><span class='Delimiter'>; 
</span> 
    <a href="list.c.html#LN352"><span class='Ref_To_Local'>n</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN351"><span class='Ref_To_Local'>cell</span></a><span class='Delimiter'>, </span><a href="list.c.html#LN349"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="list.c.html#LN352"><span class='Ref_To_Local'>n</span></a> <span class='Operator'>== </span><a href="list.c.html#LN349"><span class='Ref_to_Parameter'>new_size</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="list.c.html#LN351"><span class='Ref_To_Local'>cell</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN60"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>            <a href="list.c.html#LN349"><span class='Ref_to_Parameter'>list</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN49"><span class='Ref_to_Member'>tail</span></a> <span class='Operator'>= </span><a href="list.c.html#LN351"><span class='Ref_To_Local'>cell</span></a><span class='Delimiter'>; 
</span>            <a href="list.c.html#LN349"><span class='Ref_to_Parameter'>list</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN47"><span class='Ref_to_Member'>length</span></a> <span class='Operator'>= </span><a href="list.c.html#LN349"><span class='Ref_to_Parameter'>new_size</span></a><span class='Delimiter'>; 
</span>            <a href="list.c.html#LN32"><span class='Ref_to_Func'>check_list_invariants</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN349"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span> <a href="list.c.html#LN349"><span class='Ref_to_Parameter'>list</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <a href="list.c.html#LN352"><span class='Ref_To_Local'>n</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* keep the compiler quiet; never reached */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="list.c.html#LN349"><span class='Ref_to_Parameter'>list</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end list_truncate &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Locate the n'th cell (counting from 0) of the list.  It is an assertion 
 * failure if there is no such cell. 
 */ 
</span><a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a> <span class='Operator'>* 
</span><a name="LN385"></a><span class='Declare_Function'>list_nth_cell</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>n</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN387"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>match</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN385"><span class='Ref_to_Parameter'>list</span></a> <span class='Operator'>!= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN385"><span class='Ref_to_Parameter'>n</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN385"><span class='Ref_to_Parameter'>n</span></a> <span class='Operator'>&LT; </span><a href="list.c.html#LN385"><span class='Ref_to_Parameter'>list</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN47"><span class='Ref_to_Member'>length</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="list.c.html#LN32"><span class='Ref_to_Func'>check_list_invariants</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN385"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Does the caller actually mean to fetch the tail? */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="list.c.html#LN385"><span class='Ref_to_Parameter'>n</span></a> <span class='Operator'>== </span><a href="list.c.html#LN385"><span class='Ref_to_Parameter'>list</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN47"><span class='Ref_to_Member'>length</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="list.c.html#LN385"><span class='Ref_to_Parameter'>list</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN49"><span class='Ref_to_Member'>tail</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="list.c.html#LN387"><span class='Ref_To_Local'>match</span></a> <span class='Operator'>= </span><a href="list.c.html#LN385"><span class='Ref_to_Parameter'>list</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN48"><span class='Ref_to_Member'>head</span></a><span class='Delimiter'>; </span><a href="list.c.html#LN385"><span class='Ref_to_Parameter'>n</span></a><span class='Operator'>-- &GT; </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="list.c.html#LN387"><span class='Ref_To_Local'>match</span></a> <span class='Operator'>= </span><a href="list.c.html#LN387"><span class='Ref_To_Local'>match</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN60"><span class='Ref_to_Member'>next</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="list.c.html#LN387"><span class='Ref_To_Local'>match</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Return the data value contained in the n'th element of the 
 * specified list. (List elements begin at 0.) 
 */ 
</span><span class='Keyword'>void </span><span class='Operator'>* 
</span><a name="LN409"></a><span class='Declare_Function'>list_nth</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>n</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN24"><span class='Ref_to_Macro'>IsPointerList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN409"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN222"><span class='Ref_to_Proto'>list_nth_cell</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN409"><span class='Ref_to_Parameter'>list</span></a><span class='Delimiter'>, </span><a href="list.c.html#LN409"><span class='Ref_to_Parameter'>n</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Return the integer value contained in the n'th element of the 
 * specified list. 
 */ 
</span><span class='Keyword'>int 
</span><a name="LN420"></a><span class='Declare_Function'>list_nth_int</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>n</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN25"><span class='Ref_to_Macro'>IsIntegerList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN420"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="../../include/nodes/pg_list.h.html#LN106"><span class='Ref_to_Macro'>lfirst_int</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN222"><span class='Ref_to_Proto'>list_nth_cell</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN420"><span class='Ref_to_Parameter'>list</span></a><span class='Delimiter'>, </span><a href="list.c.html#LN420"><span class='Ref_to_Parameter'>n</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Return the OID value contained in the n'th element of the specified 
 * list. 
 */ 
</span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> 
<a name="LN431"></a><span class='Declare_Function'>list_nth_oid</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>n</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN26"><span class='Ref_to_Macro'>IsOidList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN431"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="../../include/nodes/pg_list.h.html#LN107"><span class='Ref_to_Macro'>lfirst_oid</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN222"><span class='Ref_to_Proto'>list_nth_cell</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN431"><span class='Ref_to_Parameter'>list</span></a><span class='Delimiter'>, </span><a href="list.c.html#LN431"><span class='Ref_to_Parameter'>n</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Return true iff 'datum' is a member of the list. Equality is 
 * determined via equal(), so callers should ensure that they pass a 
 * Node as 'datum'. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN443"></a><span class='Declare_Function'>list_member</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list</span><span class='Delimiter'>, </span><span class='Keyword'>const void </span><span class='Operator'>*</span><span class='Declare_Parameter'>datum</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN445"></a>    <span class='Keyword'>const </span><a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a> <span class='Operator'>*</span><span class='Declare_Local'>cell</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN24"><span class='Ref_to_Macro'>IsPointerList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN443"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="list.c.html#LN32"><span class='Ref_to_Func'>check_list_invariants</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN443"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN445"><span class='Ref_To_Local'>cell</span></a><span class='Delimiter'>, </span><a href="list.c.html#LN443"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN626"><span class='Ref_to_Proto'>equal</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN445"><span class='Ref_To_Local'>cell</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="list.c.html#LN443"><span class='Ref_to_Parameter'>datum</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Return true iff 'datum' is a member of the list. Equality is 
 * determined by using simple pointer comparison. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN464"></a><span class='Declare_Function'>list_member_ptr</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list</span><span class='Delimiter'>, </span><span class='Keyword'>const void </span><span class='Operator'>*</span><span class='Declare_Parameter'>datum</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN466"></a>    <span class='Keyword'>const </span><a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a> <span class='Operator'>*</span><span class='Declare_Local'>cell</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN24"><span class='Ref_to_Macro'>IsPointerList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN464"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="list.c.html#LN32"><span class='Ref_to_Func'>check_list_invariants</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN464"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN466"><span class='Ref_To_Local'>cell</span></a><span class='Delimiter'>, </span><a href="list.c.html#LN464"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN466"><span class='Ref_To_Local'>cell</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="list.c.html#LN464"><span class='Ref_to_Parameter'>datum</span></a><span class='Parentheses'>)</span> 
            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Return true iff the integer 'datum' is a member of the list. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN484"></a><span class='Declare_Function'>list_member_int</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>datum</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN486"></a>    <span class='Keyword'>const </span><a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a> <span class='Operator'>*</span><span class='Declare_Local'>cell</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN25"><span class='Ref_to_Macro'>IsIntegerList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN484"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="list.c.html#LN32"><span class='Ref_to_Func'>check_list_invariants</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN484"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN486"><span class='Ref_To_Local'>cell</span></a><span class='Delimiter'>, </span><a href="list.c.html#LN484"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN106"><span class='Ref_to_Macro'>lfirst_int</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN486"><span class='Ref_To_Local'>cell</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="list.c.html#LN484"><span class='Ref_to_Parameter'>datum</span></a><span class='Parentheses'>)</span> 
            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Return true iff the OID 'datum' is a member of the list. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN504"></a><span class='Declare_Function'>list_member_oid</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>datum</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN506"></a>    <span class='Keyword'>const </span><a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a> <span class='Operator'>*</span><span class='Declare_Local'>cell</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN26"><span class='Ref_to_Macro'>IsOidList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN504"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="list.c.html#LN32"><span class='Ref_to_Func'>check_list_invariants</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN504"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN506"><span class='Ref_To_Local'>cell</span></a><span class='Delimiter'>, </span><a href="list.c.html#LN504"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN107"><span class='Ref_to_Macro'>lfirst_oid</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN506"><span class='Ref_To_Local'>cell</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="list.c.html#LN504"><span class='Ref_to_Parameter'>datum</span></a><span class='Parentheses'>)</span> 
            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Delete 'cell' from 'list'; 'prev' is the previous element to 'cell' 
 * in 'list', if any (i.e. prev == NULL iff list-&GT;head == cell) 
 * 
 * The cell is pfree'd, as is the List header if this was the last member. 
 */ 
</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN527"></a><span class='Declare_Function'>list_delete_cell</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>cell</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>prev</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="list.c.html#LN32"><span class='Ref_to_Func'>check_list_invariants</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN527"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN527"><span class='Ref_to_Parameter'>prev</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL </span><span class='Operator'>? </span><a href="../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN527"><span class='Ref_to_Parameter'>prev</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="list.c.html#LN527"><span class='Ref_to_Parameter'>cell</span></a> <span class='Operator'>: </span><a href="../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN527"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="list.c.html#LN527"><span class='Ref_to_Parameter'>cell</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we're about to delete the last node from the list, free the whole 
     * list instead and return NIL, which is the only valid representation of 
     * a zero-length list. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="list.c.html#LN527"><span class='Ref_to_Parameter'>list</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN47"><span class='Ref_to_Member'>length</span></a> <span class='Operator'>== </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../include/nodes/pg_list.h.html#LN265"><span class='Ref_to_Proto'>list_free</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN527"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Otherwise, adjust the necessary list links, deallocate the particular 
     * node we have just removed, and return the list we were given. 
     */ 
</span>    <a href="list.c.html#LN527"><span class='Ref_to_Parameter'>list</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN47"><span class='Ref_to_Member'>length</span></a><span class='Operator'>--</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="list.c.html#LN527"><span class='Ref_to_Parameter'>prev</span></a><span class='Parentheses'>) 
</span>        <a href="list.c.html#LN527"><span class='Ref_to_Parameter'>prev</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN60"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>= </span><a href="list.c.html#LN527"><span class='Ref_to_Parameter'>cell</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN60"><span class='Ref_to_Member'>next</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="list.c.html#LN527"><span class='Ref_to_Parameter'>list</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN48"><span class='Ref_to_Member'>head</span></a> <span class='Operator'>= </span><a href="list.c.html#LN527"><span class='Ref_to_Parameter'>cell</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN60"><span class='Ref_to_Member'>next</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="list.c.html#LN527"><span class='Ref_to_Parameter'>list</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN49"><span class='Ref_to_Member'>tail</span></a> <span class='Operator'>== </span><a href="list.c.html#LN527"><span class='Ref_to_Parameter'>cell</span></a><span class='Parentheses'>) 
</span>        <a href="list.c.html#LN527"><span class='Ref_to_Parameter'>list</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN49"><span class='Ref_to_Member'>tail</span></a> <span class='Operator'>= </span><a href="list.c.html#LN527"><span class='Ref_to_Parameter'>prev</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN527"><span class='Ref_to_Parameter'>cell</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="list.c.html#LN527"><span class='Ref_to_Parameter'>list</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end list_delete_cell &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Delete the first cell in list that matches datum, if any. 
 * Equality is determined via equal(). 
 */ 
</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN566"></a><span class='Declare_Function'>list_delete</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>datum</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN568"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>cell</span><span class='Delimiter'>; 
</span><a name="LN569"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>prev</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN24"><span class='Ref_to_Macro'>IsPointerList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN566"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="list.c.html#LN32"><span class='Ref_to_Func'>check_list_invariants</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN566"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="list.c.html#LN569"><span class='Ref_To_Local'>prev</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN568"><span class='Ref_To_Local'>cell</span></a><span class='Delimiter'>, </span><a href="list.c.html#LN566"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/nodes.h.html#LN626"><span class='Ref_to_Proto'>equal</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN568"><span class='Ref_To_Local'>cell</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="list.c.html#LN566"><span class='Ref_to_Parameter'>datum</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <a href="../../include/nodes/pg_list.h.html#LN238"><span class='Ref_to_Proto'>list_delete_cell</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN566"><span class='Ref_to_Parameter'>list</span></a><span class='Delimiter'>, </span><a href="list.c.html#LN568"><span class='Ref_To_Local'>cell</span></a><span class='Delimiter'>, </span><a href="list.c.html#LN569"><span class='Ref_To_Local'>prev</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="list.c.html#LN569"><span class='Ref_To_Local'>prev</span></a> <span class='Operator'>= </span><a href="list.c.html#LN568"><span class='Ref_To_Local'>cell</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Didn't find a match: return the list unmodified */ 
</span>    <span class='Control'>return</span> <a href="list.c.html#LN566"><span class='Ref_to_Parameter'>list</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end list_delete &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* As above, but use simple pointer equality */ 
</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN589"></a><span class='Declare_Function'>list_delete_ptr</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>datum</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN591"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>cell</span><span class='Delimiter'>; 
</span><a name="LN592"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>prev</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN24"><span class='Ref_to_Macro'>IsPointerList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN589"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="list.c.html#LN32"><span class='Ref_to_Func'>check_list_invariants</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN589"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="list.c.html#LN592"><span class='Ref_To_Local'>prev</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN591"><span class='Ref_To_Local'>cell</span></a><span class='Delimiter'>, </span><a href="list.c.html#LN589"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN591"><span class='Ref_To_Local'>cell</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="list.c.html#LN589"><span class='Ref_to_Parameter'>datum</span></a><span class='Parentheses'>)</span> 
            <span class='Control'>return</span> <a href="../../include/nodes/pg_list.h.html#LN238"><span class='Ref_to_Proto'>list_delete_cell</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN589"><span class='Ref_to_Parameter'>list</span></a><span class='Delimiter'>, </span><a href="list.c.html#LN591"><span class='Ref_To_Local'>cell</span></a><span class='Delimiter'>, </span><a href="list.c.html#LN592"><span class='Ref_To_Local'>prev</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="list.c.html#LN592"><span class='Ref_To_Local'>prev</span></a> <span class='Operator'>= </span><a href="list.c.html#LN591"><span class='Ref_To_Local'>cell</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Didn't find a match: return the list unmodified */ 
</span>    <span class='Control'>return</span> <a href="list.c.html#LN589"><span class='Ref_to_Parameter'>list</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end list_delete_ptr &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* As above, but for integers */ 
</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN612"></a><span class='Declare_Function'>list_delete_int</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>datum</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN614"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>cell</span><span class='Delimiter'>; 
</span><a name="LN615"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>prev</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN25"><span class='Ref_to_Macro'>IsIntegerList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN612"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="list.c.html#LN32"><span class='Ref_to_Func'>check_list_invariants</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN612"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="list.c.html#LN615"><span class='Ref_To_Local'>prev</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN614"><span class='Ref_To_Local'>cell</span></a><span class='Delimiter'>, </span><a href="list.c.html#LN612"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN106"><span class='Ref_to_Macro'>lfirst_int</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN614"><span class='Ref_To_Local'>cell</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="list.c.html#LN612"><span class='Ref_to_Parameter'>datum</span></a><span class='Parentheses'>)</span> 
            <span class='Control'>return</span> <a href="../../include/nodes/pg_list.h.html#LN238"><span class='Ref_to_Proto'>list_delete_cell</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN612"><span class='Ref_to_Parameter'>list</span></a><span class='Delimiter'>, </span><a href="list.c.html#LN614"><span class='Ref_To_Local'>cell</span></a><span class='Delimiter'>, </span><a href="list.c.html#LN615"><span class='Ref_To_Local'>prev</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="list.c.html#LN615"><span class='Ref_To_Local'>prev</span></a> <span class='Operator'>= </span><a href="list.c.html#LN614"><span class='Ref_To_Local'>cell</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Didn't find a match: return the list unmodified */ 
</span>    <span class='Control'>return</span> <a href="list.c.html#LN612"><span class='Ref_to_Parameter'>list</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end list_delete_int &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* As above, but for OIDs */ 
</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN635"></a><span class='Declare_Function'>list_delete_oid</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>datum</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN637"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>cell</span><span class='Delimiter'>; 
</span><a name="LN638"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>prev</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN26"><span class='Ref_to_Macro'>IsOidList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN635"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="list.c.html#LN32"><span class='Ref_to_Func'>check_list_invariants</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN635"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="list.c.html#LN638"><span class='Ref_To_Local'>prev</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN637"><span class='Ref_To_Local'>cell</span></a><span class='Delimiter'>, </span><a href="list.c.html#LN635"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN107"><span class='Ref_to_Macro'>lfirst_oid</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN637"><span class='Ref_To_Local'>cell</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="list.c.html#LN635"><span class='Ref_to_Parameter'>datum</span></a><span class='Parentheses'>)</span> 
            <span class='Control'>return</span> <a href="../../include/nodes/pg_list.h.html#LN238"><span class='Ref_to_Proto'>list_delete_cell</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN635"><span class='Ref_to_Parameter'>list</span></a><span class='Delimiter'>, </span><a href="list.c.html#LN637"><span class='Ref_To_Local'>cell</span></a><span class='Delimiter'>, </span><a href="list.c.html#LN638"><span class='Ref_To_Local'>prev</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="list.c.html#LN638"><span class='Ref_To_Local'>prev</span></a> <span class='Operator'>= </span><a href="list.c.html#LN637"><span class='Ref_To_Local'>cell</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Didn't find a match: return the list unmodified */ 
</span>    <span class='Control'>return</span> <a href="list.c.html#LN635"><span class='Ref_to_Parameter'>list</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end list_delete_oid &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Delete the first element of the list. 
 * 
 * This is useful to replace the Lisp-y code "list = lnext(list);" in cases 
 * where the intent is to alter the list rather than just traverse it. 
 * Beware that the removed cell is freed, whereas the lnext() coding leaves 
 * the original list head intact if there's another pointer to it. 
 */ 
</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN665"></a><span class='Declare_Function'>list_delete_first</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="list.c.html#LN32"><span class='Ref_to_Func'>check_list_invariants</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN665"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="list.c.html#LN665"><span class='Ref_to_Parameter'>list</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>;</span>             <span class='Comment_Single_Line'>/* would an error be better? */ 
</span> 
    <span class='Control'>return</span> <a href="../../include/nodes/pg_list.h.html#LN238"><span class='Ref_to_Proto'>list_delete_cell</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN665"><span class='Ref_to_Parameter'>list</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN665"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Generate the union of two lists. This is calculated by copying 
 * list1 via list_copy(), then adding to it all the members of list2 
 * that aren't already in list1. 
 * 
 * Whether an element is already a member of the list is determined 
 * via equal(). 
 * 
 * The returned list is newly-allocated, although the content of the 
 * cells is the same (i.e. any pointed-to objects are not copied). 
 * 
 * NB: this function will NOT remove any duplicates that are present 
 * in list1 (so it only performs a "union" if list1 is known unique to 
 * start with).  Also, if you are about to write "x = list_union(x, y)" 
 * you probably want to use list_concat_unique() instead to avoid wasting 
 * the list cells of the old x list. 
 * 
 * This function could probably be implemented a lot faster if it is a 
 * performance bottleneck. 
 */ 
</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN696"></a><span class='Declare_Function'>list_union</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list1</span><span class='Delimiter'>, </span><span class='Keyword'>const </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list2</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN698"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span><a name="LN699"></a>    <span class='Keyword'>const </span><a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a> <span class='Operator'>*</span><span class='Declare_Local'>cell</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN24"><span class='Ref_to_Macro'>IsPointerList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN696"><span class='Ref_to_Parameter'>list1</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN24"><span class='Ref_to_Macro'>IsPointerList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN696"><span class='Ref_to_Parameter'>list2</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="list.c.html#LN698"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN268"><span class='Ref_to_Proto'>list_copy</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN696"><span class='Ref_to_Parameter'>list1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN699"><span class='Ref_To_Local'>cell</span></a><span class='Delimiter'>, </span><a href="list.c.html#LN696"><span class='Ref_to_Parameter'>list2</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/nodes/pg_list.h.html#LN228"><span class='Ref_to_Proto'>list_member</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN698"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN699"><span class='Ref_To_Local'>cell</span></a><span class='Parentheses'>)))</span> 
            <a href="list.c.html#LN698"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN698"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN699"><span class='Ref_To_Local'>cell</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="list.c.html#LN32"><span class='Ref_to_Func'>check_list_invariants</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN698"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="list.c.html#LN698"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * This variant of list_union() determines duplicates via simple 
 * pointer comparison. 
 */ 
</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN720"></a><span class='Declare_Function'>list_union_ptr</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list1</span><span class='Delimiter'>, </span><span class='Keyword'>const </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list2</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN722"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span><a name="LN723"></a>    <span class='Keyword'>const </span><a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a> <span class='Operator'>*</span><span class='Declare_Local'>cell</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN24"><span class='Ref_to_Macro'>IsPointerList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN720"><span class='Ref_to_Parameter'>list1</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN24"><span class='Ref_to_Macro'>IsPointerList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN720"><span class='Ref_to_Parameter'>list2</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="list.c.html#LN722"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN268"><span class='Ref_to_Proto'>list_copy</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN720"><span class='Ref_to_Parameter'>list1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN723"><span class='Ref_To_Local'>cell</span></a><span class='Delimiter'>, </span><a href="list.c.html#LN720"><span class='Ref_to_Parameter'>list2</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/nodes/pg_list.h.html#LN229"><span class='Ref_to_Proto'>list_member_ptr</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN722"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN723"><span class='Ref_To_Local'>cell</span></a><span class='Parentheses'>)))</span> 
            <a href="list.c.html#LN722"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN722"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN723"><span class='Ref_To_Local'>cell</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="list.c.html#LN32"><span class='Ref_to_Func'>check_list_invariants</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN722"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="list.c.html#LN722"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * This variant of list_union() operates upon lists of integers. 
 */ 
</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN743"></a><span class='Declare_Function'>list_union_int</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list1</span><span class='Delimiter'>, </span><span class='Keyword'>const </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list2</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN745"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span><a name="LN746"></a>    <span class='Keyword'>const </span><a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a> <span class='Operator'>*</span><span class='Declare_Local'>cell</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN25"><span class='Ref_to_Macro'>IsIntegerList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN743"><span class='Ref_to_Parameter'>list1</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN25"><span class='Ref_to_Macro'>IsIntegerList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN743"><span class='Ref_to_Parameter'>list2</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="list.c.html#LN745"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN268"><span class='Ref_to_Proto'>list_copy</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN743"><span class='Ref_to_Parameter'>list1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN746"><span class='Ref_To_Local'>cell</span></a><span class='Delimiter'>, </span><a href="list.c.html#LN743"><span class='Ref_to_Parameter'>list2</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/nodes/pg_list.h.html#LN230"><span class='Ref_to_Proto'>list_member_int</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN745"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN106"><span class='Ref_to_Macro'>lfirst_int</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN746"><span class='Ref_To_Local'>cell</span></a><span class='Parentheses'>)))</span> 
            <a href="list.c.html#LN745"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="list.c.html#LN144"><span class='Ref_to_Func'>lappend_int</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN745"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN106"><span class='Ref_to_Macro'>lfirst_int</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN746"><span class='Ref_To_Local'>cell</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="list.c.html#LN32"><span class='Ref_to_Func'>check_list_invariants</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN745"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="list.c.html#LN745"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * This variant of list_union() operates upon lists of OIDs. 
 */ 
</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN766"></a><span class='Declare_Function'>list_union_oid</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list1</span><span class='Delimiter'>, </span><span class='Keyword'>const </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list2</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN768"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span><a name="LN769"></a>    <span class='Keyword'>const </span><a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a> <span class='Operator'>*</span><span class='Declare_Local'>cell</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN26"><span class='Ref_to_Macro'>IsOidList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN766"><span class='Ref_to_Parameter'>list1</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN26"><span class='Ref_to_Macro'>IsOidList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN766"><span class='Ref_to_Parameter'>list2</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="list.c.html#LN768"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN268"><span class='Ref_to_Proto'>list_copy</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN766"><span class='Ref_to_Parameter'>list1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN769"><span class='Ref_To_Local'>cell</span></a><span class='Delimiter'>, </span><a href="list.c.html#LN766"><span class='Ref_to_Parameter'>list2</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/nodes/pg_list.h.html#LN231"><span class='Ref_to_Proto'>list_member_oid</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN768"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN107"><span class='Ref_to_Macro'>lfirst_oid</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN769"><span class='Ref_To_Local'>cell</span></a><span class='Parentheses'>)))</span> 
            <a href="list.c.html#LN768"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="list.c.html#LN162"><span class='Ref_to_Func'>lappend_oid</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN768"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN107"><span class='Ref_to_Macro'>lfirst_oid</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN769"><span class='Ref_To_Local'>cell</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="list.c.html#LN32"><span class='Ref_to_Func'>check_list_invariants</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN768"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="list.c.html#LN768"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Return a list that contains all the cells that are in both list1 and 
 * list2.  The returned list is freshly allocated via palloc(), but the 
 * cells themselves point to the same objects as the cells of the 
 * input lists. 
 * 
 * Duplicate entries in list1 will not be suppressed, so it's only a true 
 * "intersection" if list1 is known unique beforehand. 
 * 
 * This variant works on lists of pointers, and determines list 
 * membership via equal().  Note that the list1 member will be pointed 
 * to in the result. 
 */ 
</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN799"></a><span class='Declare_Function'>list_intersection</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list1</span><span class='Delimiter'>, </span><span class='Keyword'>const </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list2</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN801"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span><a name="LN802"></a>    <span class='Keyword'>const </span><a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a> <span class='Operator'>*</span><span class='Declare_Local'>cell</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="list.c.html#LN799"><span class='Ref_to_Parameter'>list1</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>|| </span><a href="list.c.html#LN799"><span class='Ref_to_Parameter'>list2</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN24"><span class='Ref_to_Macro'>IsPointerList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN799"><span class='Ref_to_Parameter'>list1</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN24"><span class='Ref_to_Macro'>IsPointerList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN799"><span class='Ref_to_Parameter'>list2</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="list.c.html#LN801"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN802"><span class='Ref_To_Local'>cell</span></a><span class='Delimiter'>, </span><a href="list.c.html#LN799"><span class='Ref_to_Parameter'>list1</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN228"><span class='Ref_to_Proto'>list_member</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN799"><span class='Ref_to_Parameter'>list2</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN802"><span class='Ref_To_Local'>cell</span></a><span class='Parentheses'>)))</span> 
            <a href="list.c.html#LN801"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN801"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN802"><span class='Ref_To_Local'>cell</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="list.c.html#LN32"><span class='Ref_to_Func'>check_list_invariants</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN801"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="list.c.html#LN801"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end list_intersection &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * As list_intersection but operates on lists of integers. 
 */ 
</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN825"></a><span class='Declare_Function'>list_intersection_int</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list1</span><span class='Delimiter'>, </span><span class='Keyword'>const </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list2</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN827"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span><a name="LN828"></a>    <span class='Keyword'>const </span><a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a> <span class='Operator'>*</span><span class='Declare_Local'>cell</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="list.c.html#LN825"><span class='Ref_to_Parameter'>list1</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>|| </span><a href="list.c.html#LN825"><span class='Ref_to_Parameter'>list2</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN25"><span class='Ref_to_Macro'>IsIntegerList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN825"><span class='Ref_to_Parameter'>list1</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN25"><span class='Ref_to_Macro'>IsIntegerList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN825"><span class='Ref_to_Parameter'>list2</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="list.c.html#LN827"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN828"><span class='Ref_To_Local'>cell</span></a><span class='Delimiter'>, </span><a href="list.c.html#LN825"><span class='Ref_to_Parameter'>list1</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN230"><span class='Ref_to_Proto'>list_member_int</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN825"><span class='Ref_to_Parameter'>list2</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN106"><span class='Ref_to_Macro'>lfirst_int</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN828"><span class='Ref_To_Local'>cell</span></a><span class='Parentheses'>)))</span> 
            <a href="list.c.html#LN827"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="list.c.html#LN144"><span class='Ref_to_Func'>lappend_int</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN827"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN106"><span class='Ref_to_Macro'>lfirst_int</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN828"><span class='Ref_To_Local'>cell</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="list.c.html#LN32"><span class='Ref_to_Func'>check_list_invariants</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN827"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="list.c.html#LN827"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end list_intersection_int &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Return a list that contains all the cells in list1 that are not in 
 * list2. The returned list is freshly allocated via palloc(), but the 
 * cells themselves point to the same objects as the cells of the 
 * input lists. 
 * 
 * This variant works on lists of pointers, and determines list 
 * membership via equal() 
 */ 
</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN857"></a><span class='Declare_Function'>list_difference</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list1</span><span class='Delimiter'>, </span><span class='Keyword'>const </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list2</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN859"></a>    <span class='Keyword'>const </span><a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a> <span class='Operator'>*</span><span class='Declare_Local'>cell</span><span class='Delimiter'>; 
</span><a name="LN860"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>result</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN24"><span class='Ref_to_Macro'>IsPointerList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN857"><span class='Ref_to_Parameter'>list1</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN24"><span class='Ref_to_Macro'>IsPointerList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN857"><span class='Ref_to_Parameter'>list2</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="list.c.html#LN857"><span class='Ref_to_Parameter'>list2</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="../../include/nodes/pg_list.h.html#LN268"><span class='Ref_to_Proto'>list_copy</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN857"><span class='Ref_to_Parameter'>list1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN859"><span class='Ref_To_Local'>cell</span></a><span class='Delimiter'>, </span><a href="list.c.html#LN857"><span class='Ref_to_Parameter'>list1</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/nodes/pg_list.h.html#LN228"><span class='Ref_to_Proto'>list_member</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN857"><span class='Ref_to_Parameter'>list2</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN859"><span class='Ref_To_Local'>cell</span></a><span class='Parentheses'>)))</span> 
            <a href="list.c.html#LN860"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN860"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN859"><span class='Ref_To_Local'>cell</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="list.c.html#LN32"><span class='Ref_to_Func'>check_list_invariants</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN860"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="list.c.html#LN860"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end list_difference &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * This variant of list_difference() determines list membership via 
 * simple pointer equality. 
 */ 
</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN883"></a><span class='Declare_Function'>list_difference_ptr</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list1</span><span class='Delimiter'>, </span><span class='Keyword'>const </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list2</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN885"></a>    <span class='Keyword'>const </span><a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a> <span class='Operator'>*</span><span class='Declare_Local'>cell</span><span class='Delimiter'>; 
</span><a name="LN886"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>result</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN24"><span class='Ref_to_Macro'>IsPointerList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN883"><span class='Ref_to_Parameter'>list1</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN24"><span class='Ref_to_Macro'>IsPointerList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN883"><span class='Ref_to_Parameter'>list2</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="list.c.html#LN883"><span class='Ref_to_Parameter'>list2</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="../../include/nodes/pg_list.h.html#LN268"><span class='Ref_to_Proto'>list_copy</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN883"><span class='Ref_to_Parameter'>list1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN885"><span class='Ref_To_Local'>cell</span></a><span class='Delimiter'>, </span><a href="list.c.html#LN883"><span class='Ref_to_Parameter'>list1</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/nodes/pg_list.h.html#LN229"><span class='Ref_to_Proto'>list_member_ptr</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN883"><span class='Ref_to_Parameter'>list2</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN885"><span class='Ref_To_Local'>cell</span></a><span class='Parentheses'>)))</span> 
            <a href="list.c.html#LN886"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN886"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN885"><span class='Ref_To_Local'>cell</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="list.c.html#LN32"><span class='Ref_to_Func'>check_list_invariants</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN886"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="list.c.html#LN886"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end list_difference_ptr &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * This variant of list_difference() operates upon lists of integers. 
 */ 
</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN908"></a><span class='Declare_Function'>list_difference_int</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list1</span><span class='Delimiter'>, </span><span class='Keyword'>const </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list2</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN910"></a>    <span class='Keyword'>const </span><a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a> <span class='Operator'>*</span><span class='Declare_Local'>cell</span><span class='Delimiter'>; 
</span><a name="LN911"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>result</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN25"><span class='Ref_to_Macro'>IsIntegerList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN908"><span class='Ref_to_Parameter'>list1</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN25"><span class='Ref_to_Macro'>IsIntegerList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN908"><span class='Ref_to_Parameter'>list2</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="list.c.html#LN908"><span class='Ref_to_Parameter'>list2</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="../../include/nodes/pg_list.h.html#LN268"><span class='Ref_to_Proto'>list_copy</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN908"><span class='Ref_to_Parameter'>list1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN910"><span class='Ref_To_Local'>cell</span></a><span class='Delimiter'>, </span><a href="list.c.html#LN908"><span class='Ref_to_Parameter'>list1</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/nodes/pg_list.h.html#LN230"><span class='Ref_to_Proto'>list_member_int</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN908"><span class='Ref_to_Parameter'>list2</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN106"><span class='Ref_to_Macro'>lfirst_int</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN910"><span class='Ref_To_Local'>cell</span></a><span class='Parentheses'>)))</span> 
            <a href="list.c.html#LN911"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="list.c.html#LN144"><span class='Ref_to_Func'>lappend_int</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN911"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN106"><span class='Ref_to_Macro'>lfirst_int</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN910"><span class='Ref_To_Local'>cell</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="list.c.html#LN32"><span class='Ref_to_Func'>check_list_invariants</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN911"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="list.c.html#LN911"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end list_difference_int &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * This variant of list_difference() operates upon lists of OIDs. 
 */ 
</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN933"></a><span class='Declare_Function'>list_difference_oid</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list1</span><span class='Delimiter'>, </span><span class='Keyword'>const </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list2</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN935"></a>    <span class='Keyword'>const </span><a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a> <span class='Operator'>*</span><span class='Declare_Local'>cell</span><span class='Delimiter'>; 
</span><a name="LN936"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>result</span> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN26"><span class='Ref_to_Macro'>IsOidList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN933"><span class='Ref_to_Parameter'>list1</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN26"><span class='Ref_to_Macro'>IsOidList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN933"><span class='Ref_to_Parameter'>list2</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="list.c.html#LN933"><span class='Ref_to_Parameter'>list2</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="../../include/nodes/pg_list.h.html#LN268"><span class='Ref_to_Proto'>list_copy</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN933"><span class='Ref_to_Parameter'>list1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN935"><span class='Ref_To_Local'>cell</span></a><span class='Delimiter'>, </span><a href="list.c.html#LN933"><span class='Ref_to_Parameter'>list1</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/nodes/pg_list.h.html#LN231"><span class='Ref_to_Proto'>list_member_oid</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN933"><span class='Ref_to_Parameter'>list2</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN107"><span class='Ref_to_Macro'>lfirst_oid</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN935"><span class='Ref_To_Local'>cell</span></a><span class='Parentheses'>)))</span> 
            <a href="list.c.html#LN936"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="list.c.html#LN162"><span class='Ref_to_Func'>lappend_oid</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN936"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN107"><span class='Ref_to_Macro'>lfirst_oid</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN935"><span class='Ref_To_Local'>cell</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="list.c.html#LN32"><span class='Ref_to_Func'>check_list_invariants</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN936"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="list.c.html#LN936"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end list_difference_oid &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Append datum to list, but only if it isn't already in the list. 
 * 
 * Whether an element is already a member of the list is determined 
 * via equal(). 
 */ 
</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN961"></a><span class='Declare_Function'>list_append_unique</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>datum</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN228"><span class='Ref_to_Proto'>list_member</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN961"><span class='Ref_to_Parameter'>list</span></a><span class='Delimiter'>, </span><a href="list.c.html#LN961"><span class='Ref_to_Parameter'>datum</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <a href="list.c.html#LN961"><span class='Ref_to_Parameter'>list</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <span class='Control'>return</span> <a href="list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN961"><span class='Ref_to_Parameter'>list</span></a><span class='Delimiter'>, </span><a href="list.c.html#LN961"><span class='Ref_to_Parameter'>datum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * This variant of list_append_unique() determines list membership via 
 * simple pointer equality. 
 */ 
</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN974"></a><span class='Declare_Function'>list_append_unique_ptr</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>datum</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN229"><span class='Ref_to_Proto'>list_member_ptr</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN974"><span class='Ref_to_Parameter'>list</span></a><span class='Delimiter'>, </span><a href="list.c.html#LN974"><span class='Ref_to_Parameter'>datum</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <a href="list.c.html#LN974"><span class='Ref_to_Parameter'>list</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <span class='Control'>return</span> <a href="list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN974"><span class='Ref_to_Parameter'>list</span></a><span class='Delimiter'>, </span><a href="list.c.html#LN974"><span class='Ref_to_Parameter'>datum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * This variant of list_append_unique() operates upon lists of integers. 
 */ 
</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN986"></a><span class='Declare_Function'>list_append_unique_int</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>datum</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN230"><span class='Ref_to_Proto'>list_member_int</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN986"><span class='Ref_to_Parameter'>list</span></a><span class='Delimiter'>, </span><a href="list.c.html#LN986"><span class='Ref_to_Parameter'>datum</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <a href="list.c.html#LN986"><span class='Ref_to_Parameter'>list</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <span class='Control'>return</span> <a href="list.c.html#LN144"><span class='Ref_to_Func'>lappend_int</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN986"><span class='Ref_to_Parameter'>list</span></a><span class='Delimiter'>, </span><a href="list.c.html#LN986"><span class='Ref_to_Parameter'>datum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * This variant of list_append_unique() operates upon lists of OIDs. 
 */ 
</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN998"></a><span class='Declare_Function'>list_append_unique_oid</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list</span><span class='Delimiter'>, </span><a href="../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>datum</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN231"><span class='Ref_to_Proto'>list_member_oid</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN998"><span class='Ref_to_Parameter'>list</span></a><span class='Delimiter'>, </span><a href="list.c.html#LN998"><span class='Ref_to_Parameter'>datum</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <a href="list.c.html#LN998"><span class='Ref_to_Parameter'>list</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <span class='Control'>return</span> <a href="list.c.html#LN162"><span class='Ref_to_Func'>lappend_oid</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN998"><span class='Ref_to_Parameter'>list</span></a><span class='Delimiter'>, </span><a href="list.c.html#LN998"><span class='Ref_to_Parameter'>datum</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Append to list1 each member of list2 that isn't already in list1. 
 * 
 * Whether an element is already a member of the list is determined 
 * via equal(). 
 * 
 * This is almost the same functionality as list_union(), but list1 is 
 * modified in-place rather than being copied.  Note also that list2's cells 
 * are not inserted in list1, so the analogy to list_concat() isn't perfect. 
 */ 
</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN1017"></a><span class='Declare_Function'>list_concat_unique</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list1</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list2</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1019"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>cell</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN24"><span class='Ref_to_Macro'>IsPointerList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN1017"><span class='Ref_to_Parameter'>list1</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN24"><span class='Ref_to_Macro'>IsPointerList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN1017"><span class='Ref_to_Parameter'>list2</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN1019"><span class='Ref_To_Local'>cell</span></a><span class='Delimiter'>, </span><a href="list.c.html#LN1017"><span class='Ref_to_Parameter'>list2</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/nodes/pg_list.h.html#LN228"><span class='Ref_to_Proto'>list_member</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN1017"><span class='Ref_to_Parameter'>list1</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN1019"><span class='Ref_To_Local'>cell</span></a><span class='Parentheses'>)))</span> 
            <a href="list.c.html#LN1017"><span class='Ref_to_Parameter'>list1</span></a> <span class='Operator'>= </span><a href="list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN1017"><span class='Ref_to_Parameter'>list1</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN1019"><span class='Ref_To_Local'>cell</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="list.c.html#LN32"><span class='Ref_to_Func'>check_list_invariants</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN1017"><span class='Ref_to_Parameter'>list1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="list.c.html#LN1017"><span class='Ref_to_Parameter'>list1</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * This variant of list_concat_unique() determines list membership via 
 * simple pointer equality. 
 */ 
</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN1039"></a><span class='Declare_Function'>list_concat_unique_ptr</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list1</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list2</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1041"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>cell</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN24"><span class='Ref_to_Macro'>IsPointerList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN1039"><span class='Ref_to_Parameter'>list1</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN24"><span class='Ref_to_Macro'>IsPointerList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN1039"><span class='Ref_to_Parameter'>list2</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN1041"><span class='Ref_To_Local'>cell</span></a><span class='Delimiter'>, </span><a href="list.c.html#LN1039"><span class='Ref_to_Parameter'>list2</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/nodes/pg_list.h.html#LN229"><span class='Ref_to_Proto'>list_member_ptr</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN1039"><span class='Ref_to_Parameter'>list1</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN1041"><span class='Ref_To_Local'>cell</span></a><span class='Parentheses'>)))</span> 
            <a href="list.c.html#LN1039"><span class='Ref_to_Parameter'>list1</span></a> <span class='Operator'>= </span><a href="list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN1039"><span class='Ref_to_Parameter'>list1</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN1041"><span class='Ref_To_Local'>cell</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="list.c.html#LN32"><span class='Ref_to_Func'>check_list_invariants</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN1039"><span class='Ref_to_Parameter'>list1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="list.c.html#LN1039"><span class='Ref_to_Parameter'>list1</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * This variant of list_concat_unique() operates upon lists of integers. 
 */ 
</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN1060"></a><span class='Declare_Function'>list_concat_unique_int</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list1</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list2</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1062"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>cell</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN25"><span class='Ref_to_Macro'>IsIntegerList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN1060"><span class='Ref_to_Parameter'>list1</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN25"><span class='Ref_to_Macro'>IsIntegerList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN1060"><span class='Ref_to_Parameter'>list2</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN1062"><span class='Ref_To_Local'>cell</span></a><span class='Delimiter'>, </span><a href="list.c.html#LN1060"><span class='Ref_to_Parameter'>list2</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/nodes/pg_list.h.html#LN230"><span class='Ref_to_Proto'>list_member_int</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN1060"><span class='Ref_to_Parameter'>list1</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN106"><span class='Ref_to_Macro'>lfirst_int</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN1062"><span class='Ref_To_Local'>cell</span></a><span class='Parentheses'>)))</span> 
            <a href="list.c.html#LN1060"><span class='Ref_to_Parameter'>list1</span></a> <span class='Operator'>= </span><a href="list.c.html#LN144"><span class='Ref_to_Func'>lappend_int</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN1060"><span class='Ref_to_Parameter'>list1</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN106"><span class='Ref_to_Macro'>lfirst_int</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN1062"><span class='Ref_To_Local'>cell</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="list.c.html#LN32"><span class='Ref_to_Func'>check_list_invariants</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN1060"><span class='Ref_to_Parameter'>list1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="list.c.html#LN1060"><span class='Ref_to_Parameter'>list1</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * This variant of list_concat_unique() operates upon lists of OIDs. 
 */ 
</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN1081"></a><span class='Declare_Function'>list_concat_unique_oid</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list1</span><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list2</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1083"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>cell</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN26"><span class='Ref_to_Macro'>IsOidList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN1081"><span class='Ref_to_Parameter'>list1</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN26"><span class='Ref_to_Macro'>IsOidList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN1081"><span class='Ref_to_Parameter'>list2</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN1083"><span class='Ref_To_Local'>cell</span></a><span class='Delimiter'>, </span><a href="list.c.html#LN1081"><span class='Ref_to_Parameter'>list2</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../include/nodes/pg_list.h.html#LN231"><span class='Ref_to_Proto'>list_member_oid</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN1081"><span class='Ref_to_Parameter'>list1</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN107"><span class='Ref_to_Macro'>lfirst_oid</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN1083"><span class='Ref_To_Local'>cell</span></a><span class='Parentheses'>)))</span> 
            <a href="list.c.html#LN1081"><span class='Ref_to_Parameter'>list1</span></a> <span class='Operator'>= </span><a href="list.c.html#LN162"><span class='Ref_to_Func'>lappend_oid</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN1081"><span class='Ref_to_Parameter'>list1</span></a><span class='Delimiter'>, </span><a href="../../include/nodes/pg_list.h.html#LN107"><span class='Ref_to_Macro'>lfirst_oid</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN1083"><span class='Ref_To_Local'>cell</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="list.c.html#LN32"><span class='Ref_to_Func'>check_list_invariants</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN1081"><span class='Ref_to_Parameter'>list1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="list.c.html#LN1081"><span class='Ref_to_Parameter'>list1</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Free all storage in a list, and optionally the pointed-to elements 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1102"></a><span class='Declare_Function'>list_free_private</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>deep</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1104"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>cell</span><span class='Delimiter'>; 
</span> 
    <a href="list.c.html#LN32"><span class='Ref_to_Func'>check_list_invariants</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN1102"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="list.c.html#LN1104"><span class='Ref_To_Local'>cell</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN1102"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="list.c.html#LN1104"><span class='Ref_To_Local'>cell</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1111"></a>        <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>tmp</span> <span class='Operator'>= </span><a href="list.c.html#LN1104"><span class='Ref_To_Local'>cell</span></a><span class='Delimiter'>; 
</span> 
        <a href="list.c.html#LN1104"><span class='Ref_To_Local'>cell</span></a> <span class='Operator'>= </span><a href="../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN1104"><span class='Ref_To_Local'>cell</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="list.c.html#LN1102"><span class='Ref_to_Parameter'>deep</span></a><span class='Parentheses'>) 
</span>            <a href="../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN1111"><span class='Ref_To_Local'>tmp</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN1111"><span class='Ref_To_Local'>tmp</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="list.c.html#LN1102"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>) 
</span>        <a href="../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN1102"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end list_free_private &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Free all the cells of the list, as well as the list itself. Any 
 * objects that are pointed-to by the cells of the list are NOT 
 * free'd. 
 * 
 * On return, the argument to this function has been freed, so the 
 * caller would be wise to set it to NIL for safety's sake. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1132"></a><span class='Declare_Function'>list_free</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="list.c.html#LN1101"><span class='Ref_to_Func'>list_free_private</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN1132"><span class='Ref_to_Parameter'>list</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Free all the cells of the list, the list itself, and all the 
 * objects pointed-to by the cells of the list (each element in the 
 * list must contain a pointer to a palloc()'d region of memory!) 
 * 
 * On return, the argument to this function has been freed, so the 
 * caller would be wise to set it to NIL for safety's sake. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1146"></a><span class='Declare_Function'>list_free_deep</span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * A "deep" free operation only makes sense on a list of pointers. 
     */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="list.c.html#LN24"><span class='Ref_to_Macro'>IsPointerList</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN1146"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="list.c.html#LN1101"><span class='Ref_to_Func'>list_free_private</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN1146"><span class='Ref_to_Parameter'>list</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Return a shallow copy of the specified list. 
 */ 
</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN1159"></a><span class='Declare_Function'>list_copy</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>oldlist</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1161"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>newlist</span><span class='Delimiter'>; 
</span><a name="LN1162"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>newlist_prev</span><span class='Delimiter'>; 
</span><a name="LN1163"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>oldlist_cur</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="list.c.html#LN1159"><span class='Ref_to_Parameter'>oldlist</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
    <a href="list.c.html#LN1161"><span class='Ref_To_Local'>newlist</span></a> <span class='Operator'>= </span><a href="list.c.html#LN61"><span class='Ref_to_Func'>new_list</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN1159"><span class='Ref_to_Parameter'>oldlist</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN46"><span class='Ref_to_Member'>type</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="list.c.html#LN1161"><span class='Ref_To_Local'>newlist</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN47"><span class='Ref_to_Member'>length</span></a> <span class='Operator'>= </span><a href="list.c.html#LN1159"><span class='Ref_to_Parameter'>oldlist</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN47"><span class='Ref_to_Member'>length</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Copy over the data in the first cell; new_list() has already allocated 
     * the head cell itself 
     */ 
</span>    <a href="list.c.html#LN1161"><span class='Ref_To_Local'>newlist</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN48"><span class='Ref_to_Member'>head</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN59"><span class='Ref_to_Member'>data</span></a> <span class='Operator'>= </span><a href="list.c.html#LN1159"><span class='Ref_to_Parameter'>oldlist</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN48"><span class='Ref_to_Member'>head</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN59"><span class='Ref_to_Member'>data</span></a><span class='Delimiter'>; 
</span> 
    <a href="list.c.html#LN1162"><span class='Ref_To_Local'>newlist_prev</span></a> <span class='Operator'>= </span><a href="list.c.html#LN1161"><span class='Ref_To_Local'>newlist</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN48"><span class='Ref_to_Member'>head</span></a><span class='Delimiter'>; 
</span>    <a href="list.c.html#LN1163"><span class='Ref_To_Local'>oldlist_cur</span></a> <span class='Operator'>= </span><a href="list.c.html#LN1159"><span class='Ref_to_Parameter'>oldlist</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN48"><span class='Ref_to_Member'>head</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN60"><span class='Ref_to_Member'>next</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="list.c.html#LN1163"><span class='Ref_To_Local'>oldlist_cur</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1181"></a>        <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>newlist_cur</span><span class='Delimiter'>; 
</span> 
        <a href="list.c.html#LN1181"><span class='Ref_To_Local'>newlist_cur</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="list.c.html#LN1181"><span class='Ref_To_Local'>newlist_cur</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="list.c.html#LN1181"><span class='Ref_To_Local'>newlist_cur</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN59"><span class='Ref_to_Member'>data</span></a> <span class='Operator'>= </span><a href="list.c.html#LN1163"><span class='Ref_To_Local'>oldlist_cur</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN59"><span class='Ref_to_Member'>data</span></a><span class='Delimiter'>; 
</span>        <a href="list.c.html#LN1162"><span class='Ref_To_Local'>newlist_prev</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN60"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>= </span><a href="list.c.html#LN1181"><span class='Ref_To_Local'>newlist_cur</span></a><span class='Delimiter'>; 
</span> 
        <a href="list.c.html#LN1162"><span class='Ref_To_Local'>newlist_prev</span></a> <span class='Operator'>= </span><a href="list.c.html#LN1181"><span class='Ref_To_Local'>newlist_cur</span></a><span class='Delimiter'>; 
</span>        <a href="list.c.html#LN1163"><span class='Ref_To_Local'>oldlist_cur</span></a> <span class='Operator'>= </span><a href="list.c.html#LN1163"><span class='Ref_To_Local'>oldlist_cur</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN60"><span class='Ref_to_Member'>next</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="list.c.html#LN1162"><span class='Ref_To_Local'>newlist_prev</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN60"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="list.c.html#LN1161"><span class='Ref_To_Local'>newlist</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN49"><span class='Ref_to_Member'>tail</span></a> <span class='Operator'>= </span><a href="list.c.html#LN1162"><span class='Ref_To_Local'>newlist_prev</span></a><span class='Delimiter'>; 
</span> 
    <a href="list.c.html#LN32"><span class='Ref_to_Func'>check_list_invariants</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN1161"><span class='Ref_To_Local'>newlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="list.c.html#LN1161"><span class='Ref_To_Local'>newlist</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end list_copy &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Return a shallow copy of the specified list, without the first N elements. 
 */ 
</span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN1202"></a><span class='Declare_Function'>list_copy_tail</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>oldlist</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>nskip</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1204"></a>    <a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>newlist</span><span class='Delimiter'>; 
</span><a name="LN1205"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>newlist_prev</span><span class='Delimiter'>; 
</span><a name="LN1206"></a>    <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>oldlist_cur</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="list.c.html#LN1202"><span class='Ref_to_Parameter'>nskip</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="list.c.html#LN1202"><span class='Ref_to_Parameter'>nskip</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>;</span>              <span class='Comment_Single_Line'>/* would it be better to elog? */ 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="list.c.html#LN1202"><span class='Ref_to_Parameter'>oldlist</span></a> <span class='Operator'>== </span><a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>|| </span><a href="list.c.html#LN1202"><span class='Ref_to_Parameter'>nskip</span></a> <span class='Operator'>&GT;= </span><a href="list.c.html#LN1202"><span class='Ref_to_Parameter'>oldlist</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN47"><span class='Ref_to_Member'>length</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <a href="../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
    <a href="list.c.html#LN1204"><span class='Ref_To_Local'>newlist</span></a> <span class='Operator'>= </span><a href="list.c.html#LN61"><span class='Ref_to_Func'>new_list</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN1202"><span class='Ref_to_Parameter'>oldlist</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN46"><span class='Ref_to_Member'>type</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="list.c.html#LN1204"><span class='Ref_To_Local'>newlist</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN47"><span class='Ref_to_Member'>length</span></a> <span class='Operator'>= </span><a href="list.c.html#LN1202"><span class='Ref_to_Parameter'>oldlist</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN47"><span class='Ref_to_Member'>length</span></a> <span class='Operator'>- </span><a href="list.c.html#LN1202"><span class='Ref_to_Parameter'>nskip</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Skip over the unwanted elements. 
     */ 
</span>    <a href="list.c.html#LN1206"><span class='Ref_To_Local'>oldlist_cur</span></a> <span class='Operator'>= </span><a href="list.c.html#LN1202"><span class='Ref_to_Parameter'>oldlist</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN48"><span class='Ref_to_Member'>head</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="list.c.html#LN1202"><span class='Ref_to_Parameter'>nskip</span></a><span class='Operator'>-- &GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="list.c.html#LN1206"><span class='Ref_To_Local'>oldlist_cur</span></a> <span class='Operator'>= </span><a href="list.c.html#LN1206"><span class='Ref_To_Local'>oldlist_cur</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN60"><span class='Ref_to_Member'>next</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Copy over the data in the first remaining cell; new_list() has already 
     * allocated the head cell itself 
     */ 
</span>    <a href="list.c.html#LN1204"><span class='Ref_To_Local'>newlist</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN48"><span class='Ref_to_Member'>head</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN59"><span class='Ref_to_Member'>data</span></a> <span class='Operator'>= </span><a href="list.c.html#LN1206"><span class='Ref_To_Local'>oldlist_cur</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN59"><span class='Ref_to_Member'>data</span></a><span class='Delimiter'>; 
</span> 
    <a href="list.c.html#LN1205"><span class='Ref_To_Local'>newlist_prev</span></a> <span class='Operator'>= </span><a href="list.c.html#LN1204"><span class='Ref_To_Local'>newlist</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN48"><span class='Ref_to_Member'>head</span></a><span class='Delimiter'>; 
</span>    <a href="list.c.html#LN1206"><span class='Ref_To_Local'>oldlist_cur</span></a> <span class='Operator'>= </span><a href="list.c.html#LN1206"><span class='Ref_To_Local'>oldlist_cur</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN60"><span class='Ref_to_Member'>next</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="list.c.html#LN1206"><span class='Ref_To_Local'>oldlist_cur</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1234"></a>        <a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>newlist_cur</span><span class='Delimiter'>; 
</span> 
        <a href="list.c.html#LN1234"><span class='Ref_To_Local'>newlist_cur</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="list.c.html#LN1234"><span class='Ref_To_Local'>newlist_cur</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="list.c.html#LN1234"><span class='Ref_To_Local'>newlist_cur</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN59"><span class='Ref_to_Member'>data</span></a> <span class='Operator'>= </span><a href="list.c.html#LN1206"><span class='Ref_To_Local'>oldlist_cur</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN59"><span class='Ref_to_Member'>data</span></a><span class='Delimiter'>; 
</span>        <a href="list.c.html#LN1205"><span class='Ref_To_Local'>newlist_prev</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN60"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>= </span><a href="list.c.html#LN1234"><span class='Ref_To_Local'>newlist_cur</span></a><span class='Delimiter'>; 
</span> 
        <a href="list.c.html#LN1205"><span class='Ref_To_Local'>newlist_prev</span></a> <span class='Operator'>= </span><a href="list.c.html#LN1234"><span class='Ref_To_Local'>newlist_cur</span></a><span class='Delimiter'>; 
</span>        <a href="list.c.html#LN1206"><span class='Ref_To_Local'>oldlist_cur</span></a> <span class='Operator'>= </span><a href="list.c.html#LN1206"><span class='Ref_To_Local'>oldlist_cur</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN60"><span class='Ref_to_Member'>next</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="list.c.html#LN1205"><span class='Ref_To_Local'>newlist_prev</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN60"><span class='Ref_to_Member'>next</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="list.c.html#LN1204"><span class='Ref_To_Local'>newlist</span></a><span class='Operator'>-&GT;</span><a href="../../include/nodes/pg_list.h.html#LN49"><span class='Ref_to_Member'>tail</span></a> <span class='Operator'>= </span><a href="list.c.html#LN1205"><span class='Ref_To_Local'>newlist_prev</span></a><span class='Delimiter'>; 
</span> 
    <a href="list.c.html#LN32"><span class='Ref_to_Func'>check_list_invariants</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN1204"><span class='Ref_To_Local'>newlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="list.c.html#LN1204"><span class='Ref_To_Local'>newlist</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end list_copy_tail &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Temporary compatibility functions 
 * 
 * In order to avoid warnings for these function definitions, we need 
 * to include a prototype here as well as in pg_list.h. That's because 
 * we don't enable list API compatibility in list.c, so we 
 * don't see the prototypes for these functions. 
 */ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Given a list, return its length. This is merely defined for the 
 * sake of backward compatibility: we can't afford to define a macro 
 * called "length", so it must be a function. New code should use the 
 * list_length() macro in order to avoid the overhead of a function 
 * call. 
 */ 
</span><a name="LN1267"></a><span class='Keyword'>int</span>         <span class='Declare_Prototype'>length</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Keyword'>int 
</span><a name="LN1270"></a><span class='Declare_Function'>length</span><span class='Parentheses'>(</span><span class='Keyword'>const </span><a href="../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>list</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <a href="../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="list.c.html#LN1270"><span class='Ref_to_Parameter'>list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span></pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>