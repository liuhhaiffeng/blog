<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\optimizer\path\allpaths.c</title>
<LINK REL=StyleSheet HREF="../../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\optimizer\path\allpaths.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:41 2017
</td></tr>
<tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * allpaths.c 
 *    Routines to find possible search paths for processing a query 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * 
 * IDENTIFICATION 
 *    src/backend/optimizer/path/allpaths.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span> 
<span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>&LT;limits.h&GT;</span> 
<span class='Keyword'>#include </span><span class='String'>&LT;math.h&GT;</span> 
 
<span class='Keyword'>#include </span><span class='String'>"access/sysattr.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/tsmapi.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_class.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_operator.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_proc.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"foreign/fdwapi.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/makefuncs.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/nodeFuncs.h"</span> 
<span class='Directive'>#ifdef</span> OPTIMIZER_DEBUG 
<span class='Keyword'>#include </span><span class='String'>"nodes/print.h"</span> 
<span class='Directive'>#endif</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/clauses.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/cost.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/geqo.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/pathnode.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/paths.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/plancat.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/planner.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/prep.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/restrictinfo.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/tlist.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/var.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_clause.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parsetree.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"rewrite/rewriteManip.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/lsyscache.h"</span> 
 
 
<span class='Comment_Multi_Line'>/* results of subquery_is_pushdown_safe */ 
</span><a name="LN49"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>pushdown_safety_info</span> 
<span class='Delimiter'>{ 
</span><a name="LN51"></a>    <span class='Keyword'>bool</span>       <span class='Operator'>*</span><span class='Declare_Member'>unsafeColumns</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* which output columns are unsafe to use */ 
</span><a name="LN52"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>unsafeVolatile</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* don't push down volatile quals */ 
</span><a name="LN53"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Member'>unsafeLeaky</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* don't push down leaky quals */ 
</span><a name="LN54"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>pushdown_safety_info</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* These parameters are set by GUC */ 
</span><a name="LN57"></a><span class='Keyword'>bool</span>        <span class='Declare_Var'>enable_geqo</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* just in case GUC doesn't set it */ 
</span><a name="LN58"></a><span class='Keyword'>int</span>         <span class='Declare_Var'>geqo_threshold</span><span class='Delimiter'>; 
</span><a name="LN59"></a><span class='Keyword'>int</span>         <span class='Declare_Var'>min_parallel_table_scan_size</span><span class='Delimiter'>; 
</span><a name="LN60"></a><span class='Keyword'>int</span>         <span class='Declare_Var'>min_parallel_index_scan_size</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* Hook for plugins to get control in set_rel_pathlist() */ 
</span><a name="LN63"></a><a href="../../../include/optimizer/paths.h.html#LN28"><span class='Ref_to_Typedef'>set_rel_pathlist_hook_type</span></a> <span class='Declare_Var'>set_rel_pathlist_hook</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
<span class='Comment_Multi_Line'>/* Hook for plugins to replace standard_join_search() */ 
</span><a name="LN66"></a><a href="../../../include/optimizer/paths.h.html#LN44"><span class='Ref_to_Typedef'>join_search_hook_type</span></a> <span class='Declare_Var'>join_search_hook</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
 
<a name="LN69"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>set_base_rel_consider_startup</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN70"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>set_base_rel_sizes</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN71"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>set_base_rel_pathlists</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN72"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>set_rel_size</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, 
</span><a name="LN73"></a>             <a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a> <span class='Declare_Parameter'>rti</span><span class='Delimiter'>, </span><a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rte</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN74"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>set_rel_pathlist</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, 
</span><a name="LN75"></a>                 <a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a> <span class='Declare_Parameter'>rti</span><span class='Delimiter'>, </span><a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rte</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN76"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>set_plain_rel_size</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, 
</span><a name="LN77"></a>                   <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rte</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN78"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>create_plain_partial_paths</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN79"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>set_rel_consider_parallel</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, 
</span><a name="LN80"></a>                          <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rte</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN81"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>set_plain_rel_pathlist</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, 
</span><a name="LN82"></a>                       <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rte</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN83"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>set_tablesample_rel_size</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, 
</span><a name="LN84"></a>                         <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rte</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN85"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>set_tablesample_rel_pathlist</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, 
</span><a name="LN86"></a>                             <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rte</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN87"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>set_foreign_size</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, 
</span><a name="LN88"></a>                 <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rte</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN89"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>set_foreign_pathlist</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, 
</span><a name="LN90"></a>                     <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rte</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN91"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>set_append_rel_size</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, 
</span><a name="LN92"></a>                    <a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a> <span class='Declare_Parameter'>rti</span><span class='Delimiter'>, </span><a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rte</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN93"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>set_append_rel_pathlist</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, 
</span><a name="LN94"></a>                        <a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a> <span class='Declare_Parameter'>rti</span><span class='Delimiter'>, </span><a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rte</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN95"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>generate_mergeappend_paths</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, 
</span><a name="LN96"></a>                           <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>live_childrels</span><span class='Delimiter'>, 
</span><a name="LN97"></a>                           <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>all_child_pathkeys</span><span class='Delimiter'>, 
</span><a name="LN98"></a>                           <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>partitioned_rels</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN99"></a><span class='Keyword'>static </span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>get_cheapest_parameterized_child_path</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN100"></a>                                      <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, 
</span><a name="LN101"></a>                                      <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Declare_Parameter'>required_outer</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN102"></a><span class='Keyword'>static </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>accumulate_append_subpath</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>subpaths</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN103"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>set_subquery_pathlist</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, 
</span><a name="LN104"></a>                      <a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a> <span class='Declare_Parameter'>rti</span><span class='Delimiter'>, </span><a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rte</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN105"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>set_function_pathlist</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, 
</span><a name="LN106"></a>                      <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rte</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN107"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>set_values_pathlist</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, 
</span><a name="LN108"></a>                    <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rte</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN109"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>set_tablefunc_pathlist</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, 
</span><a name="LN110"></a>                       <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rte</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN111"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>set_cte_pathlist</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, 
</span><a name="LN112"></a>                 <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rte</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN113"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>set_namedtuplestore_pathlist</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, 
</span><a name="LN114"></a>                             <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rte</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN115"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>set_worktable_pathlist</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, 
</span><a name="LN116"></a>                       <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rte</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN117"></a><span class='Keyword'>static </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>make_rel_from_joinlist</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>joinlist</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN118"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>subquery_is_pushdown_safe</span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>subquery</span><span class='Delimiter'>, </span><a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>topquery</span><span class='Delimiter'>, 
</span><a name="LN119"></a>                          <a href="allpaths.c.html#LN49"><span class='Ref_to_Struct'>pushdown_safety_info</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>safetyInfo</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN120"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>recurse_pushdown_safe</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>setOp</span><span class='Delimiter'>, </span><a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>topquery</span><span class='Delimiter'>, 
</span><a name="LN121"></a>                      <a href="allpaths.c.html#LN49"><span class='Ref_to_Struct'>pushdown_safety_info</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>safetyInfo</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN122"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>check_output_expressions</span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>subquery</span><span class='Delimiter'>, 
</span><a name="LN123"></a>                         <a href="allpaths.c.html#LN49"><span class='Ref_to_Struct'>pushdown_safety_info</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>safetyInfo</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN124"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>compare_tlist_datatypes</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>tlist</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>colTypes</span><span class='Delimiter'>, 
</span><a name="LN125"></a>                        <a href="allpaths.c.html#LN49"><span class='Ref_to_Struct'>pushdown_safety_info</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>safetyInfo</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN126"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>targetIsInAllPartitionLists</span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>tle</span><span class='Delimiter'>, </span><a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>query</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN127"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>qual_is_pushdown_safe</span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>subquery</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a> <span class='Declare_Parameter'>rti</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>qual</span><span class='Delimiter'>, 
</span><a name="LN128"></a>                      <a href="allpaths.c.html#LN49"><span class='Ref_to_Struct'>pushdown_safety_info</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>safetyInfo</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN129"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>subquery_push_qual</span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>subquery</span><span class='Delimiter'>, 
</span><a name="LN130"></a>                   <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rte</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a> <span class='Declare_Parameter'>rti</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>qual</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN131"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>recurse_push_qual</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>setOp</span><span class='Delimiter'>, </span><a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>topquery</span><span class='Delimiter'>, 
</span><a name="LN132"></a>                  <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rte</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a> <span class='Declare_Parameter'>rti</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>qual</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN133"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>remove_unused_subquery_outputs</span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>subquery</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN134"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>add_paths_to_append_rel</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, 
</span><a name="LN135"></a>                        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>live_childrels</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * make_one_rel 
 *    Finds all possible access paths for executing a query, returning a 
 *    single rel that represents the join of all base rels in the query. 
 */ 
</span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>* 
</span><a name="LN144"></a><span class='Declare_Function'>make_one_rel</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>joinlist</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN146"></a>    <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rel</span><span class='Delimiter'>; 
</span><a name="LN147"></a>    <a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Local'>rti</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Construct the all_baserels Relids set. 
     */ 
</span>    <a href="allpaths.c.html#LN144"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN195"><span class='Ref_to_Member'>all_baserels</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN147"><span class='Ref_To_Local'>rti</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="allpaths.c.html#LN147"><span class='Ref_To_Local'>rti</span></a> <span class='Operator'>&LT; </span><a href="allpaths.c.html#LN144"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN179"><span class='Ref_to_Member'>simple_rel_array_size</span></a><span class='Delimiter'>; </span><a href="allpaths.c.html#LN147"><span class='Ref_To_Local'>rti</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN155"></a>        <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>brel</span> <span class='Operator'>= </span><a href="allpaths.c.html#LN144"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN178"><span class='Ref_to_Member'>simple_rel_array</span></a><span class='Delimiter'>[</span><a href="allpaths.c.html#LN147"><span class='Ref_To_Local'>rti</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Comment_Multi_Line'>/* there may be empty slots corresponding to non-baserel RTEs */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN155"><span class='Ref_To_Local'>brel</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="allpaths.c.html#LN155"><span class='Ref_To_Local'>brel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a> <span class='Operator'>== </span><a href="allpaths.c.html#LN147"><span class='Ref_To_Local'>rti</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* sanity check on array */ 
</span> 
        <span class='Comment_Multi_Line'>/* ignore RTEs that are "other rels" */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN155"><span class='Ref_To_Local'>brel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN521"><span class='Ref_to_Member'>reloptkind</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/relation.h.html#LN493"><span class='Ref_to_EnumConst'>RELOPT_BASEREL</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <a href="allpaths.c.html#LN144"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN195"><span class='Ref_to_Member'>all_baserels</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN89"><span class='Ref_to_Proto'>bms_add_member</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN144"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN195"><span class='Ref_to_Member'>all_baserels</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN155"><span class='Ref_To_Local'>brel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Mark base rels as to whether we care about fast-start plans */ 
</span>    <a href="allpaths.c.html#LN69"><span class='Ref_to_Proto'>set_base_rel_consider_startup</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN144"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Compute size estimates and consider_parallel flags for each base rel, 
     * then generate access paths. 
     */ 
</span>    <a href="allpaths.c.html#LN70"><span class='Ref_to_Proto'>set_base_rel_sizes</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN144"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="allpaths.c.html#LN71"><span class='Ref_to_Proto'>set_base_rel_pathlists</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN144"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Generate access paths for the entire join tree. 
     */ 
</span>    <a href="allpaths.c.html#LN146"><span class='Ref_To_Local'>rel</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN117"><span class='Ref_to_Proto'>make_rel_from_joinlist</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN144"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN144"><span class='Ref_to_Parameter'>joinlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * The result should join all and only the query's base rels. 
     */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN66"><span class='Ref_to_Proto'>bms_equal</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN146"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN144"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN195"><span class='Ref_to_Member'>all_baserels</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="allpaths.c.html#LN146"><span class='Ref_To_Local'>rel</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end make_one_rel &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * set_base_rel_consider_startup 
 *    Set the consider_[param_]startup flags for each base-relation entry. 
 * 
 * For the moment, we only deal with consider_param_startup here; because the 
 * logic for consider_startup is pretty trivial and is the same for every base 
 * relation, we just let build_simple_rel() initialize that flag correctly to 
 * start with.  If that logic ever gets more complicated it would probably 
 * be better to move it here. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN204"></a><span class='Declare_Function'>set_base_rel_consider_startup</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * Since parameterized paths can only be used on the inside of a nestloop 
     * join plan, there is usually little value in considering fast-start 
     * plans for them.  However, for relations that are on the RHS of a SEMI 
     * or ANTI join, a fast-start plan can be useful because we're only going 
     * to care about fetching one tuple anyway. 
     * 
     * To minimize growth of planning time, we currently restrict this to 
     * cases where the RHS is a single base relation, not a join; there is no 
     * provision for consider_param_startup to get set at all on joinrels. 
     * Also we don't worry about appendrels.  costsize.c's costing rules for 
     * nestloop semi/antijoins don't consider such cases either. 
     */ 
</span><a name="LN219"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN219"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN204"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN249"><span class='Ref_to_Member'>join_info_list</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN223"></a>        <a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sjinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN219"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN224"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>varno</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="allpaths.c.html#LN223"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1920"><span class='Ref_to_Member'>jointype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN691"><span class='Ref_to_EnumConst'>JOIN_SEMI</span></a> <span class='Operator'>|| </span><a href="allpaths.c.html#LN223"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1920"><span class='Ref_to_Member'>jointype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN692"><span class='Ref_to_EnumConst'>JOIN_ANTI</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>            <a href="../../../include/nodes/bitmapset.h.html#LN80"><span class='Ref_to_Proto'>bms_get_singleton_member</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN223"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1919"><span class='Ref_to_Member'>syn_righthand</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="allpaths.c.html#LN224"><span class='Ref_To_Local'>varno</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN229"></a>            <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rel</span> <span class='Operator'>= </span><a href="../util/relnode.c.html#LN241"><span class='Ref_to_Func'>find_base_rel</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN204"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN224"><span class='Ref_To_Local'>varno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="allpaths.c.html#LN229"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN531"><span class='Ref_to_Member'>consider_param_startup</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end set_base_rel_consider_startup &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * set_base_rel_sizes 
 *    Set the size estimates (rows and widths) for each base-relation entry. 
 *    Also determine whether to consider parallel paths for base relations. 
 * 
 * We do this in a separate pass over the base rels so that rowcount 
 * estimates are available for parameterized path generation, and also so 
 * that each rel's consider_parallel flag is set correctly before we begin to 
 * generate paths. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN247"></a><span class='Declare_Function'>set_base_rel_sizes</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN249"></a>    <a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Local'>rti</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN249"><span class='Ref_To_Local'>rti</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="allpaths.c.html#LN249"><span class='Ref_To_Local'>rti</span></a> <span class='Operator'>&LT; </span><a href="allpaths.c.html#LN247"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN179"><span class='Ref_to_Member'>simple_rel_array_size</span></a><span class='Delimiter'>; </span><a href="allpaths.c.html#LN249"><span class='Ref_To_Local'>rti</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN253"></a>        <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rel</span> <span class='Operator'>= </span><a href="allpaths.c.html#LN247"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN178"><span class='Ref_to_Member'>simple_rel_array</span></a><span class='Delimiter'>[</span><a href="allpaths.c.html#LN249"><span class='Ref_To_Local'>rti</span></a><span class='Delimiter'>]; 
</span><a name="LN254"></a>        <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* there may be empty slots corresponding to non-baserel RTEs */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN253"><span class='Ref_To_Local'>rel</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="allpaths.c.html#LN253"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a> <span class='Operator'>== </span><a href="allpaths.c.html#LN249"><span class='Ref_To_Local'>rti</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* sanity check on array */ 
</span> 
        <span class='Comment_Multi_Line'>/* ignore RTEs that are "other rels" */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN253"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN521"><span class='Ref_to_Member'>reloptkind</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/relation.h.html#LN493"><span class='Ref_to_EnumConst'>RELOPT_BASEREL</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <a href="allpaths.c.html#LN254"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN247"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN187"><span class='Ref_to_Member'>simple_rte_array</span></a><span class='Delimiter'>[</span><a href="allpaths.c.html#LN249"><span class='Ref_To_Local'>rti</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If parallelism is allowable for this query in general, see whether 
         * it's allowable for this rel in particular.  We have to do this 
         * before set_rel_size(), because (a) if this rel is an inheritance 
         * parent, set_append_rel_size() will use and perhaps change the rel's 
         * consider_parallel flag, and (b) for some RTE types, set_rel_size() 
         * goes ahead and makes paths immediately. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN247"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN156"><span class='Ref_to_Member'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN128"><span class='Ref_to_Member'>parallelModeOK</span></a><span class='Parentheses'>) 
</span>            <a href="allpaths.c.html#LN79"><span class='Ref_to_Proto'>set_rel_consider_parallel</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN247"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN253"><span class='Ref_To_Local'>rel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN254"><span class='Ref_To_Local'>rte</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="allpaths.c.html#LN72"><span class='Ref_to_Proto'>set_rel_size</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN247"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN253"><span class='Ref_To_Local'>rel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN249"><span class='Ref_To_Local'>rti</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN254"><span class='Ref_To_Local'>rte</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for rti=1;rti&LT;root-&GT;simpl... &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end set_base_rel_sizes &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * set_base_rel_pathlists 
 *    Finds all paths available for scanning each base-relation entry. 
 *    Sequential scan and any available indices are considered. 
 *    Each useful path is attached to its relation's 'pathlist' field. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN290"></a><span class='Declare_Function'>set_base_rel_pathlists</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN292"></a>    <a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Local'>rti</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN292"><span class='Ref_To_Local'>rti</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="allpaths.c.html#LN292"><span class='Ref_To_Local'>rti</span></a> <span class='Operator'>&LT; </span><a href="allpaths.c.html#LN290"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN179"><span class='Ref_to_Member'>simple_rel_array_size</span></a><span class='Delimiter'>; </span><a href="allpaths.c.html#LN292"><span class='Ref_To_Local'>rti</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN296"></a>        <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rel</span> <span class='Operator'>= </span><a href="allpaths.c.html#LN290"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN178"><span class='Ref_to_Member'>simple_rel_array</span></a><span class='Delimiter'>[</span><a href="allpaths.c.html#LN292"><span class='Ref_To_Local'>rti</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Comment_Multi_Line'>/* there may be empty slots corresponding to non-baserel RTEs */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN296"><span class='Ref_To_Local'>rel</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="allpaths.c.html#LN296"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a> <span class='Operator'>== </span><a href="allpaths.c.html#LN292"><span class='Ref_To_Local'>rti</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* sanity check on array */ 
</span> 
        <span class='Comment_Multi_Line'>/* ignore RTEs that are "other rels" */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN296"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN521"><span class='Ref_to_Member'>reloptkind</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/relation.h.html#LN493"><span class='Ref_to_EnumConst'>RELOPT_BASEREL</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <a href="allpaths.c.html#LN74"><span class='Ref_to_Proto'>set_rel_pathlist</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN290"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN296"><span class='Ref_To_Local'>rel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN292"><span class='Ref_To_Local'>rti</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN290"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN187"><span class='Ref_to_Member'>simple_rte_array</span></a><span class='Delimiter'>[</span><a href="allpaths.c.html#LN292"><span class='Ref_To_Local'>rti</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end set_base_rel_pathlists &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * set_rel_size 
 *    Set size estimates for a base relation 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN317"></a><span class='Declare_Function'>set_rel_size</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, 
</span><a name="LN318"></a>             <a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a> <span class='Declare_Parameter'>rti</span><span class='Delimiter'>, </span><a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rte</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN317"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN521"><span class='Ref_to_Member'>reloptkind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/relation.h.html#LN493"><span class='Ref_to_EnumConst'>RELOPT_BASEREL</span></a> <span class='Operator'>&& 
</span>        <a href="../../../include/optimizer/plancat.h.html#LN37"><span class='Ref_to_Proto'>relation_excluded_by_constraints</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN317"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN317"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN318"><span class='Ref_to_Parameter'>rte</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * We proved we don't need to scan the rel via constraint exclusion, 
         * so set up a single dummy path for it.  Here we only check this for 
         * regular baserels; if it's an otherrel, CE was already checked in 
         * set_append_rel_size(). 
         * 
         * In this case, we go ahead and set up the relation's path right away 
         * instead of leaving it for set_rel_pathlist to do.  This is because 
         * we don't have a convention for marking a rel as dummy except by 
         * assigning a dummy path to it. 
         */ 
</span>        <a href="../../../include/optimizer/paths.h.html#LN51"><span class='Ref_to_Proto'>set_dummy_rel_pathlist</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN317"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN318"><span class='Ref_to_Parameter'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1025"><span class='Ref_to_Member'>inh</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* It's an "append relation", process accordingly */ 
</span>        <a href="allpaths.c.html#LN91"><span class='Ref_to_Proto'>set_append_rel_size</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN317"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN317"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN318"><span class='Ref_to_Parameter'>rti</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN318"><span class='Ref_to_Parameter'>rte</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN317"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN554"><span class='Ref_to_Member'>rtekind</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>case</span> <a href="../../../include/nodes/parsenodes.h.html#LN922"><span class='Ref_to_EnumConst'>RTE_RELATION</span></a><span class='Operator'>: 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN318"><span class='Ref_to_Parameter'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN948"><span class='Ref_to_Member'>relkind</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_class.h.html#LN166"><span class='Ref_to_Const'>RELKIND_FOREIGN_TABLE</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* Foreign table */ 
</span>                    <a href="allpaths.c.html#LN87"><span class='Ref_to_Proto'>set_foreign_size</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN317"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN317"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN318"><span class='Ref_to_Parameter'>rte</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN318"><span class='Ref_to_Parameter'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN948"><span class='Ref_to_Member'>relkind</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_class.h.html#LN167"><span class='Ref_to_Const'>RELKIND_PARTITIONED_TABLE</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* 
                     * A partitioned table without leaf partitions is marked 
                     * as a dummy rel. 
                     */ 
</span>                    <a href="../../../include/optimizer/paths.h.html#LN51"><span class='Ref_to_Proto'>set_dummy_rel_pathlist</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN317"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN318"><span class='Ref_to_Parameter'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN949"><span class='Ref_to_Member'>tablesample</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* Sampled relation */ 
</span>                    <a href="allpaths.c.html#LN83"><span class='Ref_to_Proto'>set_tablesample_rel_size</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN317"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN317"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN318"><span class='Ref_to_Parameter'>rte</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>else</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* Plain relation */ 
</span>                    <a href="allpaths.c.html#LN76"><span class='Ref_to_Proto'>set_plain_rel_size</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN317"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN317"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN318"><span class='Ref_to_Parameter'>rte</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../../include/nodes/parsenodes.h.html#LN923"><span class='Ref_to_EnumConst'>RTE_SUBQUERY</span></a><span class='Operator'>: 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * Subqueries don't support making a choice between 
                 * parameterized and unparameterized paths, so just go ahead 
                 * and build their paths immediately. 
                 */ 
</span>                <a href="allpaths.c.html#LN103"><span class='Ref_to_Proto'>set_subquery_pathlist</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN317"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN317"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN318"><span class='Ref_to_Parameter'>rti</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN318"><span class='Ref_to_Parameter'>rte</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../../include/nodes/parsenodes.h.html#LN925"><span class='Ref_to_EnumConst'>RTE_FUNCTION</span></a><span class='Operator'>: 
</span>                <a href="../../../include/optimizer/cost.h.html#LN182"><span class='Ref_to_Proto'>set_function_size_estimates</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN317"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN317"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../../include/nodes/parsenodes.h.html#LN926"><span class='Ref_to_EnumConst'>RTE_TABLEFUNC</span></a><span class='Operator'>: 
</span>                <a href="../../../include/optimizer/cost.h.html#LN186"><span class='Ref_to_Proto'>set_tablefunc_size_estimates</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN317"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN317"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../../include/nodes/parsenodes.h.html#LN927"><span class='Ref_to_EnumConst'>RTE_VALUES</span></a><span class='Operator'>: 
</span>                <a href="../../../include/optimizer/cost.h.html#LN183"><span class='Ref_to_Proto'>set_values_size_estimates</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN317"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN317"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../../include/nodes/parsenodes.h.html#LN928"><span class='Ref_to_EnumConst'>RTE_CTE</span></a><span class='Operator'>: 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * CTEs don't support making a choice between parameterized 
                 * and unparameterized paths, so just go ahead and build their 
                 * paths immediately. 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN318"><span class='Ref_to_Parameter'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1003"><span class='Ref_to_Member'>self_reference</span></a><span class='Parentheses'>) 
</span>                    <a href="allpaths.c.html#LN115"><span class='Ref_to_Proto'>set_worktable_pathlist</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN317"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN317"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN318"><span class='Ref_to_Parameter'>rte</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>else</span> 
                    <a href="allpaths.c.html#LN111"><span class='Ref_to_Proto'>set_cte_pathlist</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN317"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN317"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN318"><span class='Ref_to_Parameter'>rte</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../../include/nodes/parsenodes.h.html#LN929"><span class='Ref_to_EnumConst'>RTE_NAMEDTUPLESTORE</span></a><span class='Operator'>: 
</span>                <a href="allpaths.c.html#LN113"><span class='Ref_to_Proto'>set_namedtuplestore_pathlist</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN317"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN317"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN318"><span class='Ref_to_Parameter'>rte</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>default</span><span class='Operator'>: 
</span>                <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unexpected rtekind: %d"</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN317"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN554"><span class='Ref_to_Member'>rtekind</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch rel-&GT;rtekind &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * We insist that all non-dummy rels have a nonzero rowcount estimate. 
     */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="allpaths.c.html#LN317"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span> <span class='Operator'>|| </span><a href="../../../include/nodes/relation.h.html#LN1186"><span class='Ref_to_Macro'>IS_DUMMY_REL</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN317"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end set_rel_size &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * set_rel_pathlist 
 *    Build access paths for a base relation 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN420"></a><span class='Declare_Function'>set_rel_pathlist</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, 
</span><a name="LN421"></a>                 <a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a> <span class='Declare_Parameter'>rti</span><span class='Delimiter'>, </span><a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rte</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1186"><span class='Ref_to_Macro'>IS_DUMMY_REL</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN420"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* We already proved the relation empty, so nothing more to do */ 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN421"><span class='Ref_to_Parameter'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1025"><span class='Ref_to_Member'>inh</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* It's an "append relation", process accordingly */ 
</span>        <a href="allpaths.c.html#LN93"><span class='Ref_to_Proto'>set_append_rel_pathlist</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN420"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN420"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN421"><span class='Ref_to_Parameter'>rti</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN421"><span class='Ref_to_Parameter'>rte</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN420"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN554"><span class='Ref_to_Member'>rtekind</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>case</span> <a href="../../../include/nodes/parsenodes.h.html#LN922"><span class='Ref_to_EnumConst'>RTE_RELATION</span></a><span class='Operator'>: 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN421"><span class='Ref_to_Parameter'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN948"><span class='Ref_to_Member'>relkind</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_class.h.html#LN166"><span class='Ref_to_Const'>RELKIND_FOREIGN_TABLE</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* Foreign table */ 
</span>                    <a href="allpaths.c.html#LN89"><span class='Ref_to_Proto'>set_foreign_pathlist</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN420"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN420"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN421"><span class='Ref_to_Parameter'>rte</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN421"><span class='Ref_to_Parameter'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN949"><span class='Ref_to_Member'>tablesample</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* Sampled relation */ 
</span>                    <a href="allpaths.c.html#LN85"><span class='Ref_to_Proto'>set_tablesample_rel_pathlist</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN420"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN420"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN421"><span class='Ref_to_Parameter'>rte</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>else</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* Plain relation */ 
</span>                    <a href="allpaths.c.html#LN81"><span class='Ref_to_Proto'>set_plain_rel_pathlist</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN420"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN420"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN421"><span class='Ref_to_Parameter'>rte</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../../include/nodes/parsenodes.h.html#LN923"><span class='Ref_to_EnumConst'>RTE_SUBQUERY</span></a><span class='Operator'>: 
</span>                <span class='Comment_Multi_Line'>/* Subquery --- fully handled during set_rel_size */ 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../../include/nodes/parsenodes.h.html#LN925"><span class='Ref_to_EnumConst'>RTE_FUNCTION</span></a><span class='Operator'>: 
</span>                <span class='Comment_Multi_Line'>/* RangeFunction */ 
</span>                <a href="allpaths.c.html#LN105"><span class='Ref_to_Proto'>set_function_pathlist</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN420"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN420"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN421"><span class='Ref_to_Parameter'>rte</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../../include/nodes/parsenodes.h.html#LN926"><span class='Ref_to_EnumConst'>RTE_TABLEFUNC</span></a><span class='Operator'>: 
</span>                <span class='Comment_Multi_Line'>/* Table Function */ 
</span>                <a href="allpaths.c.html#LN109"><span class='Ref_to_Proto'>set_tablefunc_pathlist</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN420"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN420"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN421"><span class='Ref_to_Parameter'>rte</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../../include/nodes/parsenodes.h.html#LN927"><span class='Ref_to_EnumConst'>RTE_VALUES</span></a><span class='Operator'>: 
</span>                <span class='Comment_Multi_Line'>/* Values list */ 
</span>                <a href="allpaths.c.html#LN107"><span class='Ref_to_Proto'>set_values_pathlist</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN420"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN420"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN421"><span class='Ref_to_Parameter'>rte</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../../include/nodes/parsenodes.h.html#LN928"><span class='Ref_to_EnumConst'>RTE_CTE</span></a><span class='Operator'>: 
</span>                <span class='Comment_Multi_Line'>/* CTE reference --- fully handled during set_rel_size */ 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../../include/nodes/parsenodes.h.html#LN929"><span class='Ref_to_EnumConst'>RTE_NAMEDTUPLESTORE</span></a><span class='Operator'>: 
</span>                <span class='Comment_Multi_Line'>/* tuplestore reference --- fully handled during set_rel_size */ 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>default</span><span class='Operator'>: 
</span>                <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unexpected rtekind: %d"</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN420"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN554"><span class='Ref_to_Member'>rtekind</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch rel-&GT;rtekind &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * If this is a baserel, consider gathering any partial paths we may have 
     * created for it.  (If we tried to gather inheritance children, we could 
     * end up with a very large number of gather nodes, each trying to grab 
     * its own pool of workers, so don't do this for otherrels.  Instead, 
     * we'll consider gathering partial paths for the parent appendrel.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN420"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN521"><span class='Ref_to_Member'>reloptkind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/relation.h.html#LN493"><span class='Ref_to_EnumConst'>RELOPT_BASEREL</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/optimizer/paths.h.html#LN55"><span class='Ref_to_Proto'>generate_gather_paths</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN420"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN420"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Allow a plugin to editorialize on the set of Paths for this base 
     * relation.  It could add new paths (such as CustomPaths) by calling 
     * add_path(), or delete or modify paths added by the core code. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN63"><span class='Ref_to_Global_Var'>set_rel_pathlist_hook</span></a><span class='Parentheses'>) 
</span>        <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="allpaths.c.html#LN63"><span class='Ref_to_Global_Var'>set_rel_pathlist_hook</span></a><span class='Parentheses'>) (</span><a href="allpaths.c.html#LN420"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN420"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN421"><span class='Ref_to_Parameter'>rti</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN421"><span class='Ref_to_Parameter'>rte</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Now find the cheapest of the paths for this rel */ 
</span>    <a href="../../../include/optimizer/pathnode.h.html#LN26"><span class='Ref_to_Proto'>set_cheapest</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN420"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifdef</span> OPTIMIZER_DEBUG 
    <a href="../../../include/optimizer/paths.h.html#LN62"><span class='Ref_to_Proto'>debug_print_rel</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN420"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN420"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end set_rel_pathlist &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * set_plain_rel_size 
 *    Set size estimates for a plain relation (no subquery, no inheritance) 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN511"></a><span class='Declare_Function'>set_plain_rel_size</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, </span><a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rte</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * Test any partial indexes of rel for applicability.  We must do this 
     * first since partial unique indexes can affect size estimates. 
     */ 
</span>    <a href="../../../include/optimizer/paths.h.html#LN80"><span class='Ref_to_Proto'>check_index_predicates</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN511"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN511"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Mark rel with estimated output rows, width, etc */ 
</span>    <a href="../../../include/optimizer/cost.h.html#LN166"><span class='Ref_to_Proto'>set_baserel_size_estimates</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN511"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN511"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * If this relation could possibly be scanned from within a worker, then set 
 * its consider_parallel flag. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN528"></a><span class='Declare_Function'>set_rel_consider_parallel</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, 
</span><a name="LN529"></a>                          <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rte</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * The flag has previously been initialized to false, so we can just 
     * return if it becomes clear that we can't safely set it. 
     */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="allpaths.c.html#LN528"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN532"><span class='Ref_to_Member'>consider_parallel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Don't call this if parallelism is disallowed for the entire query. */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="allpaths.c.html#LN528"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN156"><span class='Ref_to_Member'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN128"><span class='Ref_to_Member'>parallelModeOK</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* This should only be called for baserels and appendrel children. */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN504"><span class='Ref_to_Macro'>IS_SIMPLE_REL</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN528"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Assorted checks based on rtekind. */ 
</span>    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN529"><span class='Ref_to_Parameter'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN936"><span class='Ref_to_Member'>rtekind</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/parsenodes.h.html#LN922"><span class='Ref_to_EnumConst'>RTE_RELATION</span></a><span class='Operator'>: 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Currently, parallel workers can't access the leader's temporary 
             * tables.  We could possibly relax this if the wrote all of its 
             * local buffers at the start of the query and made no changes 
             * thereafter (maybe we could allow hint bit changes), and if we 
             * taught the workers to read them.  Writing a large number of 
             * temporary buffers could be expensive, though, and we don't have 
             * the rest of the necessary infrastructure right now anyway.  So 
             * for now, bail out if we see a temporary table. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/lsyscache.h.html#LN129"><span class='Ref_to_Proto'>get_rel_persistence</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN529"><span class='Ref_to_Parameter'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN947"><span class='Ref_to_Member'>relid</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="../../../include/catalog/pg_class.h.html#LN171"><span class='Ref_to_Const'>RELPERSISTENCE_TEMP</span></a><span class='Parentheses'>)</span> 
                <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Table sampling can be pushed down to workers if the sample 
             * function and its arguments are safe. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN529"><span class='Ref_to_Parameter'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN949"><span class='Ref_to_Member'>tablesample</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN567"></a>                <span class='Keyword'>char</span>        <span class='Declare_Local'>proparallel</span> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN119"><span class='Ref_to_Proto'>func_parallel</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN529"><span class='Ref_to_Parameter'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN949"><span class='Ref_to_Member'>tablesample</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1074"><span class='Ref_to_Member'>tsmhandler</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN567"><span class='Ref_To_Local'>proparallel</span></a> <span class='Operator'>!= </span><a href="../../../include/catalog/pg_proc.h.html#LN5491"><span class='Ref_to_Const'>PROPARALLEL_SAFE</span></a><span class='Parentheses'>) 
</span>                    <span class='Control'>return</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/optimizer/clauses.h.html#LN63"><span class='Ref_to_Proto'>is_parallel_safe</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN528"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN529"><span class='Ref_to_Parameter'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN949"><span class='Ref_to_Member'>tablesample</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1075"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>))</span> 
                    <span class='Control'>return</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Ask FDWs whether they can support performing a ForeignScan 
             * within a worker.  Most often, the answer will be no.  For 
             * example, if the nature of the FDW is such that it opens a TCP 
             * connection with a remote server, each parallel worker would end 
             * up with a separate connection, and these connections might not 
             * be appropriately coordinated between workers and the leader. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN529"><span class='Ref_to_Parameter'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN948"><span class='Ref_to_Member'>relkind</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_class.h.html#LN166"><span class='Ref_to_Const'>RELKIND_FOREIGN_TABLE</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="allpaths.c.html#LN528"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN575"><span class='Ref_to_Member'>fdwroutine</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="allpaths.c.html#LN528"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN575"><span class='Ref_to_Member'>fdwroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/foreign/fdwapi.h.html#LN223"><span class='Ref_to_Member'>IsForeignScanParallelSafe</span></a><span class='Parentheses'>) 
</span>                    <span class='Control'>return</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="allpaths.c.html#LN528"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN575"><span class='Ref_to_Member'>fdwroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/foreign/fdwapi.h.html#LN223"><span class='Ref_to_Member'>IsForeignScanParallelSafe</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN528"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN528"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN529"><span class='Ref_to_Parameter'>rte</span></a><span class='Parentheses'>))</span> 
                    <span class='Control'>return</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * There are additional considerations for appendrels, which we'll 
             * deal with in set_append_rel_size and set_append_rel_pathlist. 
             * For now, just set consider_parallel based on the rel's own 
             * quals and targetlist. 
             */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="../../../include/nodes/parsenodes.h.html#LN923"><span class='Ref_to_EnumConst'>RTE_SUBQUERY</span></a><span class='Operator'>: 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * There's no intrinsic problem with scanning a subquery-in-FROM 
             * (as distinct from a SubPlan or InitPlan) in a parallel worker. 
             * If the subquery doesn't happen to have any parallel-safe paths, 
             * then flagging it as consider_parallel won't change anything, 
             * but that's true for plain tables, too.  We must set 
             * consider_parallel based on the rel's own quals and targetlist, 
             * so that if a subquery path is parallel-safe but the quals and 
             * projection we're sticking onto it are not, we correctly mark 
             * the SubqueryScanPath as not parallel-safe.  (Note that 
             * set_subquery_pathlist() might push some of these quals down 
             * into the subquery itself, but that doesn't change anything.) 
             */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="../../../include/nodes/parsenodes.h.html#LN924"><span class='Ref_to_EnumConst'>RTE_JOIN</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* Shouldn't happen; we're only considering baserels here. */ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="../../../include/nodes/parsenodes.h.html#LN925"><span class='Ref_to_EnumConst'>RTE_FUNCTION</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* Check for parallel-restricted functions. */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/optimizer/clauses.h.html#LN63"><span class='Ref_to_Proto'>is_parallel_safe</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN528"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN529"><span class='Ref_to_Parameter'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN985"><span class='Ref_to_Member'>functions</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>return</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="../../../include/nodes/parsenodes.h.html#LN926"><span class='Ref_to_EnumConst'>RTE_TABLEFUNC</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* not parallel safe */ 
</span>            <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="../../../include/nodes/parsenodes.h.html#LN927"><span class='Ref_to_EnumConst'>RTE_VALUES</span></a><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* Check for parallel-restricted functions. */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/optimizer/clauses.h.html#LN63"><span class='Ref_to_Proto'>is_parallel_safe</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN528"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN529"><span class='Ref_to_Parameter'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN996"><span class='Ref_to_Member'>values_lists</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>return</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="../../../include/nodes/parsenodes.h.html#LN928"><span class='Ref_to_EnumConst'>RTE_CTE</span></a><span class='Operator'>: 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * CTE tuplestores aren't shared among parallel workers, so we 
             * force all CTE scans to happen in the leader.  Also, populating 
             * the CTE would require executing a subplan that's not available 
             * in the worker, might be parallel-restricted, and must get 
             * executed only once. 
             */ 
</span>            <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>case</span> <a href="../../../include/nodes/parsenodes.h.html#LN929"><span class='Ref_to_EnumConst'>RTE_NAMEDTUPLESTORE</span></a><span class='Operator'>: 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * tuplestore cannot be shared, at least without more 
             * infrastructure to support that. 
             */ 
</span>            <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch rte-&GT;rtekind &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * If there's anything in baserestrictinfo that's parallel-restricted, we 
     * give up on parallelizing access to this relation.  We could consider 
     * instead postponing application of the restricted quals until we're 
     * above all the parallelism in the plan tree, but it's not clear that 
     * that would be a win in very many cases, and it might be tricky to make 
     * outer join clauses work correctly.  It would likely break equivalence 
     * classes, too. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/optimizer/clauses.h.html#LN63"><span class='Ref_to_Proto'>is_parallel_safe</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN528"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN528"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN583"><span class='Ref_to_Member'>baserestrictinfo</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Likewise, if the relation's outputs are not parallel-safe, give up. 
     * (Usually, they're just Vars, but sometimes they're not.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/optimizer/clauses.h.html#LN63"><span class='Ref_to_Proto'>is_parallel_safe</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN528"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN528"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN535"><span class='Ref_to_Member'>reltarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN882"><span class='Ref_to_Member'>exprs</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* We have a winner. */ 
</span>    <a href="allpaths.c.html#LN528"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN532"><span class='Ref_to_Member'>consider_parallel</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end set_rel_consider_parallel &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * set_plain_rel_pathlist 
 *    Build access paths for a plain relation (no subquery, no inheritance) 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN686"></a><span class='Declare_Function'>set_plain_rel_pathlist</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, </span><a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rte</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN688"></a>    <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>required_outer</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We don't support pushing join clauses into the quals of a seqscan, but 
     * it could still have required parameterization due to LATERAL refs in 
     * its tlist. 
     */ 
</span>    <a href="allpaths.c.html#LN688"><span class='Ref_To_Local'>required_outer</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN686"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN549"><span class='Ref_to_Member'>lateral_relids</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Consider sequential scan */ 
</span>    <a href="../../../include/optimizer/pathnode.h.html#LN27"><span class='Ref_to_Proto'>add_path</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN686"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="../../../include/optimizer/pathnode.h.html#LN35"><span class='Ref_to_Proto'>create_seqscan_path</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN686"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN686"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN688"><span class='Ref_To_Local'>required_outer</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* If appropriate, consider parallel sequential scan */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN686"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN532"><span class='Ref_to_Member'>consider_parallel</span></a> <span class='Operator'>&& </span><a href="allpaths.c.html#LN688"><span class='Ref_To_Local'>required_outer</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="allpaths.c.html#LN78"><span class='Ref_to_Proto'>create_plain_partial_paths</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN686"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN686"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Consider index scans */ 
</span>    <a href="../../../include/optimizer/paths.h.html#LN69"><span class='Ref_to_Proto'>create_index_paths</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN686"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN686"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Consider TID scans */ 
</span>    <a href="../../../include/optimizer/paths.h.html#LN91"><span class='Ref_to_Proto'>create_tidscan_paths</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN686"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN686"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end set_plain_rel_pathlist &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * create_plain_partial_paths 
 *    Build partial access paths for parallel scan of a plain relation 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN716"></a><span class='Declare_Function'>create_plain_partial_paths</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN718"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>parallel_workers</span><span class='Delimiter'>; 
</span> 
    <a href="allpaths.c.html#LN718"><span class='Ref_To_Local'>parallel_workers</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/paths.h.html#LN56"><span class='Ref_to_Proto'>compute_parallel_worker</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN716"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN716"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN563"><span class='Ref_to_Member'>pages</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* If any limit was set to zero, the user doesn't want a parallel scan. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN718"><span class='Ref_To_Local'>parallel_workers</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Add an unordered partial path based on a parallel sequential scan. */ 
</span>    <a href="../../../include/optimizer/pathnode.h.html#LN31"><span class='Ref_to_Proto'>add_partial_path</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN716"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="../../../include/optimizer/pathnode.h.html#LN35"><span class='Ref_to_Proto'>create_seqscan_path</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN716"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN716"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><a href="allpaths.c.html#LN718"><span class='Ref_To_Local'>parallel_workers</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * set_tablesample_rel_size 
 *    Set size estimates for a sampled relation 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN735"></a><span class='Declare_Function'>set_tablesample_rel_size</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, </span><a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rte</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN737"></a>    <a href="../../../include/nodes/parsenodes.h.html#LN1071"><span class='Ref_to_Struct'>TableSampleClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tsc</span> <span class='Operator'>= </span><a href="allpaths.c.html#LN735"><span class='Ref_to_Parameter'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN949"><span class='Ref_to_Member'>tablesample</span></a><span class='Delimiter'>; 
</span><a name="LN738"></a>    <a href="../../../include/access/tsmapi.h.html#LN54"><span class='Ref_to_Struct'>TsmRoutine</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tsm</span><span class='Delimiter'>; 
</span><a name="LN739"></a>    <a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Local'>pages</span><span class='Delimiter'>; 
</span><a name="LN740"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>tuples</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Test any partial indexes of rel for applicability.  We must do this 
     * first since partial unique indexes can affect size estimates. 
     */ 
</span>    <a href="../../../include/optimizer/paths.h.html#LN80"><span class='Ref_to_Proto'>check_index_predicates</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN735"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN735"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Call the sampling method's estimation function to estimate the number 
     * of pages it will read and the number of tuples it will return.  (Note: 
     * we assume the function returns sane values.) 
     */ 
</span>    <a href="allpaths.c.html#LN738"><span class='Ref_To_Local'>tsm</span></a> <span class='Operator'>= </span><a href="../../access/tablesample/tablesample.c.html#LN25"><span class='Ref_to_Func'>GetTsmRoutine</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN737"><span class='Ref_To_Local'>tsc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1074"><span class='Ref_to_Member'>tsmhandler</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="allpaths.c.html#LN738"><span class='Ref_To_Local'>tsm</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/tsmapi.h.html#LN66"><span class='Ref_to_Member'>SampleScanGetSampleSize</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN735"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN735"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN737"><span class='Ref_To_Local'>tsc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1075"><span class='Ref_to_Member'>args</span></a><span class='Delimiter'>, 
</span>                                 <span class='Operator'>&</span><a href="allpaths.c.html#LN739"><span class='Ref_To_Local'>pages</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="allpaths.c.html#LN740"><span class='Ref_To_Local'>tuples</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * For the moment, because we will only consider a SampleScan path for the 
     * rel, it's okay to just overwrite the pages and tuples estimates for the 
     * whole relation.  If we ever consider multiple path types for sampled 
     * rels, we'll need more complication. 
     */ 
</span>    <a href="allpaths.c.html#LN735"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN563"><span class='Ref_to_Member'>pages</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN739"><span class='Ref_To_Local'>pages</span></a><span class='Delimiter'>; 
</span>    <a href="allpaths.c.html#LN735"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN564"><span class='Ref_to_Member'>tuples</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN740"><span class='Ref_To_Local'>tuples</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Mark rel with estimated output rows, width, etc */ 
</span>    <a href="../../../include/optimizer/cost.h.html#LN166"><span class='Ref_to_Proto'>set_baserel_size_estimates</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN735"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN735"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end set_tablesample_rel_size &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * set_tablesample_rel_pathlist 
 *    Build access paths for a sampled relation 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN775"></a><span class='Declare_Function'>set_tablesample_rel_pathlist</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, </span><a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rte</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN777"></a>    <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>required_outer</span><span class='Delimiter'>; 
</span><a name="LN778"></a>    <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>path</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We don't support pushing join clauses into the quals of a samplescan, 
     * but it could still have required parameterization due to LATERAL refs 
     * in its tlist or TABLESAMPLE arguments. 
     */ 
</span>    <a href="allpaths.c.html#LN777"><span class='Ref_To_Local'>required_outer</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN775"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN549"><span class='Ref_to_Member'>lateral_relids</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Consider sampled scan */ 
</span>    <a href="allpaths.c.html#LN778"><span class='Ref_To_Local'>path</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/pathnode.h.html#LN37"><span class='Ref_to_Proto'>create_samplescan_path</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN775"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN775"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN777"><span class='Ref_To_Local'>required_outer</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the sampling method does not support repeatable scans, we must avoid 
     * plans that would scan the rel multiple times.  Ideally, we'd simply 
     * avoid putting the rel on the inside of a nestloop join; but adding such 
     * a consideration to the planner seems like a great deal of complication 
     * to support an uncommon usage of second-rate sampling methods.  Instead, 
     * if there is a risk that the query might perform an unsafe join, just 
     * wrap the SampleScan in a Materialize node.  We can check for joins by 
     * counting the membership of all_baserels (note that this correctly 
     * counts inheritance trees as single rels).  If we're inside a subquery, 
     * we can't easily check whether a join might occur in the outer query, so 
     * just assume one is possible. 
     * 
     * GetTsmRoutine is relatively expensive compared to the other tests here, 
     * so check repeatable_across_scans last, even though that's a bit odd. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="allpaths.c.html#LN775"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN158"><span class='Ref_to_Member'>query_level</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span> <span class='Operator'>|| 
</span>         <a href="../../../include/nodes/bitmapset.h.html#LN84"><span class='Ref_to_Proto'>bms_membership</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN775"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN195"><span class='Ref_to_Member'>all_baserels</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><a href="../../../include/nodes/bitmapset.h.html#LN56"><span class='Ref_to_EnumConst'>BMS_SINGLETON</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>     <span class='Operator'>!</span><span class='Parentheses'>(</span><a href="../../access/tablesample/tablesample.c.html#LN25"><span class='Ref_to_Func'>GetTsmRoutine</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN775"><span class='Ref_to_Parameter'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN949"><span class='Ref_to_Member'>tablesample</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1074"><span class='Ref_to_Member'>tsmhandler</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span><a href="../../../include/access/tsmapi.h.html#LN63"><span class='Ref_to_Member'>repeatable_across_scans</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="allpaths.c.html#LN778"><span class='Ref_To_Local'>path</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/optimizer/pathnode.h.html#LN76"><span class='Ref_to_Proto'>create_material_path</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN775"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN778"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/optimizer/pathnode.h.html#LN27"><span class='Ref_to_Proto'>add_path</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN775"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN778"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* For the moment, at least, there are no other paths to consider */ 
</span><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end set_tablesample_rel_pathlist &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * set_foreign_size 
 *      Set size estimates for a foreign table RTE 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN823"></a><span class='Declare_Function'>set_foreign_size</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, </span><a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rte</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* Mark rel with estimated output rows, width, etc */ 
</span>    <a href="../../../include/optimizer/cost.h.html#LN188"><span class='Ref_to_Proto'>set_foreign_size_estimates</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN823"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN823"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Let FDW adjust the size estimates, if it can */ 
</span>    <a href="allpaths.c.html#LN823"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN575"><span class='Ref_to_Member'>fdwroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/foreign/fdwapi.h.html#LN173"><span class='Ref_to_Member'>GetForeignRelSize</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN823"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN823"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN823"><span class='Ref_to_Parameter'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN947"><span class='Ref_to_Member'>relid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* ... but do not let it set the rows estimate to zero */ 
</span>    <a href="allpaths.c.html#LN823"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/cost.h.html#LN71"><span class='Ref_to_Proto'>clamp_row_est</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN823"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * set_foreign_pathlist 
 *      Build access paths for a foreign table RTE 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN840"></a><span class='Declare_Function'>set_foreign_pathlist</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, </span><a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rte</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* Call the FDW's GetForeignPaths function to generate path(s) */ 
</span>    <a href="allpaths.c.html#LN840"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN575"><span class='Ref_to_Member'>fdwroutine</span></a><span class='Operator'>-&GT;</span><a href="../../../include/foreign/fdwapi.h.html#LN174"><span class='Ref_to_Member'>GetForeignPaths</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN840"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN840"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN840"><span class='Ref_to_Parameter'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN947"><span class='Ref_to_Member'>relid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * set_append_rel_size 
 *    Set size estimates for a simple "append relation" 
 * 
 * The passed-in rel and RTE represent the entire append relation.  The 
 * relation's contents are computed by appending together the output of 
 * the individual member relations.  Note that in the inheritance case, 
 * the first member relation is actually the same table as is mentioned in 
 * the parent RTE ... but it has a different RTE and RelOptInfo.  This is 
 * a good thing because their outputs are not the same size. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN858"></a><span class='Declare_Function'>set_append_rel_size</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, 
</span><a name="LN859"></a>                    <a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a> <span class='Declare_Parameter'>rti</span><span class='Delimiter'>, </span><a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rte</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN861"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>parentRTindex</span> <span class='Operator'>= </span><a href="allpaths.c.html#LN859"><span class='Ref_to_Parameter'>rti</span></a><span class='Delimiter'>; 
</span><a name="LN862"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>has_live_children</span><span class='Delimiter'>; 
</span><a name="LN863"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>parent_rows</span><span class='Delimiter'>; 
</span><a name="LN864"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>parent_size</span><span class='Delimiter'>; 
</span><a name="LN865"></a>    <span class='Keyword'>double</span>     <span class='Operator'>*</span><span class='Declare_Local'>parent_attrsizes</span><span class='Delimiter'>; 
</span><a name="LN866"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>nattrs</span><span class='Delimiter'>; 
</span><a name="LN867"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN504"><span class='Ref_to_Macro'>IS_SIMPLE_REL</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN858"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Initialize to compute size estimates for whole append relation. 
     * 
     * We handle width estimates by weighting the widths of different child 
     * rels proportionally to their number of rows.  This is sensible because 
     * the use of width estimates is mainly to compute the total relation 
     * "footprint" if we have to sort or hash it.  To do this, we sum the 
     * total equivalent size (in "double" arithmetic) and then divide by the 
     * total rowcount estimate.  This is done separately for the total rel 
     * width and each attribute. 
     * 
     * Note: if you consider changing this logic, beware that child rels could 
     * have zero rows and/or width, if they were excluded by constraints. 
     */ 
</span>    <a href="allpaths.c.html#LN862"><span class='Ref_To_Local'>has_live_children</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="allpaths.c.html#LN863"><span class='Ref_To_Local'>parent_rows</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="allpaths.c.html#LN864"><span class='Ref_To_Local'>parent_size</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="allpaths.c.html#LN866"><span class='Ref_To_Local'>nattrs</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN858"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN556"><span class='Ref_to_Member'>max_attr</span></a> <span class='Operator'>- </span><a href="allpaths.c.html#LN858"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN555"><span class='Ref_to_Member'>min_attr</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <a href="allpaths.c.html#LN865"><span class='Ref_To_Local'>parent_attrsizes</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>double </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN866"><span class='Ref_To_Local'>nattrs</span></a> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN867"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN858"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN251"><span class='Ref_to_Member'>append_rel_list</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN893"></a>        <a href="../../../include/nodes/relation.h.html#LN1964"><span class='Ref_to_Struct'>AppendRelInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>appinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1964"><span class='Ref_to_Struct'>AppendRelInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN867"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN894"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>childRTindex</span><span class='Delimiter'>; 
</span><a name="LN895"></a>        <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>childRTE</span><span class='Delimiter'>; 
</span><a name="LN896"></a>        <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>childrel</span><span class='Delimiter'>; 
</span><a name="LN897"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>childquals</span><span class='Delimiter'>; 
</span><a name="LN898"></a>        <a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Local'>cq_min_security</span><span class='Delimiter'>; 
</span><a name="LN899"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>have_const_false_cq</span><span class='Delimiter'>; 
</span><a name="LN900"></a>        <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>parentvars</span><span class='Delimiter'>; 
</span><a name="LN901"></a>        <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>childvars</span><span class='Delimiter'>; 
</span><a name="LN902"></a>        <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* append_rel_list contains all append rels; ignore others */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN893"><span class='Ref_To_Local'>appinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1974"><span class='Ref_to_Member'>parent_relid</span></a> <span class='Operator'>!= </span><a href="allpaths.c.html#LN861"><span class='Ref_To_Local'>parentRTindex</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <a href="allpaths.c.html#LN894"><span class='Ref_To_Local'>childRTindex</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN893"><span class='Ref_To_Local'>appinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1975"><span class='Ref_to_Member'>child_relid</span></a><span class='Delimiter'>; 
</span>        <a href="allpaths.c.html#LN895"><span class='Ref_To_Local'>childRTE</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN858"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN187"><span class='Ref_to_Member'>simple_rte_array</span></a><span class='Delimiter'>[</span><a href="allpaths.c.html#LN894"><span class='Ref_To_Local'>childRTindex</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * The child rel's RelOptInfo was already created during 
         * add_base_rels_to_query. 
         */ 
</span>        <a href="allpaths.c.html#LN896"><span class='Ref_To_Local'>childrel</span></a> <span class='Operator'>= </span><a href="../util/relnode.c.html#LN241"><span class='Ref_to_Func'>find_base_rel</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN858"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN894"><span class='Ref_To_Local'>childRTindex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="allpaths.c.html#LN896"><span class='Ref_To_Local'>childrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN521"><span class='Ref_to_Member'>reloptkind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/relation.h.html#LN495"><span class='Ref_to_EnumConst'>RELOPT_OTHER_MEMBER_REL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We have to copy the parent's targetlist and quals to the child, 
         * with appropriate substitution of variables.  However, only the 
         * baserestrictinfo quals are needed before we can check for 
         * constraint exclusion; so do that first and then check to see if we 
         * can disregard this child. 
         * 
         * The child rel's targetlist might contain non-Var expressions, which 
         * means that substitution into the quals could produce opportunities 
         * for const-simplification, and perhaps even pseudoconstant quals. 
         * Therefore, transform each RestrictInfo separately to see if it 
         * reduces to a constant or pseudoconstant.  (We must process them 
         * separately to keep track of the security level of each qual.) 
         */ 
</span>        <a href="allpaths.c.html#LN897"><span class='Ref_To_Local'>childquals</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>        <a href="allpaths.c.html#LN898"><span class='Ref_To_Local'>cq_min_security</span></a> <span class='Operator'>= </span>UINT_MAX<span class='Delimiter'>; 
</span>        <a href="allpaths.c.html#LN899"><span class='Ref_To_Local'>have_const_false_cq</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN902"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN858"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN583"><span class='Ref_to_Member'>baserestrictinfo</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN937"></a>            <a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN902"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN938"></a>            <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>childqual</span><span class='Delimiter'>; 
</span><a name="LN939"></a>            <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc2</span><span class='Delimiter'>; 
</span> 
            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN937"><span class='Ref_To_Local'>rinfo</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="allpaths.c.html#LN938"><span class='Ref_To_Local'>childqual</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/prep.h.html#LN54"><span class='Ref_to_Proto'>adjust_appendrel_attrs</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN858"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                               <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN937"><span class='Ref_To_Local'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1746"><span class='Ref_to_Member'>clause</span></a><span class='Delimiter'>, 
</span>                                               <a href="allpaths.c.html#LN893"><span class='Ref_To_Local'>appinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="allpaths.c.html#LN938"><span class='Ref_To_Local'>childqual</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/clauses.h.html#LN80"><span class='Ref_to_Proto'>eval_const_expressions</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN858"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN938"><span class='Ref_To_Local'>childqual</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* check for flat-out constant */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN938"><span class='Ref_To_Local'>childqual</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN938"><span class='Ref_To_Local'>childqual</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span> <a href="allpaths.c.html#LN938"><span class='Ref_To_Local'>childqual</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>constisnull <span class='Operator'>|| 
</span>                    <span class='Operator'>!</span><a href="../../../include/postgres.h.html#LN398"><span class='Ref_to_Macro'>DatumGetBool</span></a><span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN938"><span class='Ref_To_Local'>childqual</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>constvalue<span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* Restriction reduces to constant FALSE or NULL */ 
</span>                    <a href="allpaths.c.html#LN899"><span class='Ref_To_Local'>have_const_false_cq</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Comment_Multi_Line'>/* Restriction reduces to constant TRUE, so drop it */ 
</span>                <span class='Control'>continue</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Comment_Multi_Line'>/* might have gotten an AND clause, if so flatten it */ 
</span>            <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN939"><span class='Ref_To_Local'>lc2</span></a><span class='Delimiter'>, </span><a href="../../../include/optimizer/clauses.h.html#LN46"><span class='Ref_to_Proto'>make_ands_implicit</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN938"><span class='Ref_To_Local'>childqual</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span><a name="LN962"></a>                <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>onecq</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN939"><span class='Ref_To_Local'>lc2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN963"></a>                <span class='Keyword'>bool</span>        <span class='Declare_Local'>pseudoconstant</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* check for pseudoconstant (no Vars or volatile functions) */ 
</span>                <a href="allpaths.c.html#LN963"><span class='Ref_To_Local'>pseudoconstant</span></a> <span class='Operator'>= 
</span>                    <span class='Operator'>!</span><a href="../../../include/optimizer/var.h.html#LN34"><span class='Ref_to_Proto'>contain_vars_of_level</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN962"><span class='Ref_To_Local'>onecq</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                    <span class='Operator'>!</span><a href="../../../include/optimizer/clauses.h.html#LN60"><span class='Ref_to_Proto'>contain_volatile_functions</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN962"><span class='Ref_To_Local'>onecq</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN963"><span class='Ref_To_Local'>pseudoconstant</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* tell createplan.c to check for gating quals */ 
</span>                    <a href="allpaths.c.html#LN858"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN302"><span class='Ref_to_Member'>hasPseudoConstantQuals</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Comment_Multi_Line'>/* reconstitute RestrictInfo with appropriate properties */ 
</span>                <a href="allpaths.c.html#LN897"><span class='Ref_To_Local'>childquals</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN897"><span class='Ref_To_Local'>childquals</span></a><span class='Delimiter'>, 
</span>                                     <a href="../../../include/optimizer/restrictinfo.h.html#LN23"><span class='Ref_to_Proto'>make_restrictinfo</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN962"><span class='Ref_To_Local'>onecq</span></a><span class='Delimiter'>, 
</span>                                                       <a href="allpaths.c.html#LN937"><span class='Ref_To_Local'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1748"><span class='Ref_to_Member'>is_pushed_down</span></a><span class='Delimiter'>, 
</span>                                                    <a href="allpaths.c.html#LN937"><span class='Ref_To_Local'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1750"><span class='Ref_to_Member'>outerjoin_delayed</span></a><span class='Delimiter'>, 
</span>                                                       <a href="allpaths.c.html#LN963"><span class='Ref_To_Local'>pseudoconstant</span></a><span class='Delimiter'>, 
</span>                                                       <a href="allpaths.c.html#LN937"><span class='Ref_To_Local'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1758"><span class='Ref_to_Member'>security_level</span></a><span class='Delimiter'>, 
</span>                                                       <span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <span class='Comment_Multi_Line'>/* track minimum security level among child quals */ 
</span>                <a href="allpaths.c.html#LN898"><span class='Ref_To_Local'>cq_min_security</span></a> <span class='Operator'>= </span><a href="../../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN11"><span class='Ref_to_Macro'>Min</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN898"><span class='Ref_To_Local'>cq_min_security</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN937"><span class='Ref_To_Local'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1758"><span class='Ref_to_Member'>security_level</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * In addition to the quals inherited from the parent, we might have 
         * securityQuals associated with this particular child node. 
         * (Currently this can only happen in appendrels originating from 
         * UNION ALL; inheritance child tables don't have their own 
         * securityQuals, see expand_inherited_rtentry().)  Pull any such 
         * securityQuals up into the baserestrictinfo for the child.  This is 
         * similar to process_security_barrier_quals() for the parent rel, 
         * except that we can't make any general deductions from such quals, 
         * since they don't hold for the whole appendrel. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN895"><span class='Ref_To_Local'>childRTE</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1032"><span class='Ref_to_Member'>securityQuals</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1000"></a>            <a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Local'>security_level</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
            <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN902"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN895"><span class='Ref_To_Local'>childRTE</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1032"><span class='Ref_to_Member'>securityQuals</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN1004"></a>                <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>qualset</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN902"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1005"></a>                <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc2</span><span class='Delimiter'>; 
</span> 
                <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1005"><span class='Ref_To_Local'>lc2</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1004"><span class='Ref_To_Local'>qualset</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span><a name="LN1009"></a>                    <a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>qual</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1005"><span class='Ref_To_Local'>lc2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                    <span class='Comment_Multi_Line'>/* not likely that we'd see constants here, so no check */ 
</span>                    <a href="allpaths.c.html#LN897"><span class='Ref_To_Local'>childquals</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN897"><span class='Ref_To_Local'>childquals</span></a><span class='Delimiter'>, 
</span>                                         <a href="../../../include/optimizer/restrictinfo.h.html#LN23"><span class='Ref_to_Proto'>make_restrictinfo</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1009"><span class='Ref_To_Local'>qual</span></a><span class='Delimiter'>, 
</span>                                                           <span class='Boolean'>true</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                                                           <a href="allpaths.c.html#LN1000"><span class='Ref_To_Local'>security_level</span></a><span class='Delimiter'>, 
</span>                                                           <span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                    <a href="allpaths.c.html#LN898"><span class='Ref_To_Local'>cq_min_security</span></a> <span class='Operator'>= </span><a href="../../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN11"><span class='Ref_to_Macro'>Min</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN898"><span class='Ref_To_Local'>cq_min_security</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1000"><span class='Ref_To_Local'>security_level</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <a href="allpaths.c.html#LN1000"><span class='Ref_To_Local'>security_level</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1000"><span class='Ref_To_Local'>security_level</span></a> <span class='Operator'>&LT;= </span><a href="allpaths.c.html#LN858"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN293"><span class='Ref_to_Member'>qual_security_level</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if childRTE-&GT;securityQua... &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* 
         * OK, we've got all the baserestrictinfo quals for this child. 
         */ 
</span>        <a href="allpaths.c.html#LN896"><span class='Ref_To_Local'>childrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN583"><span class='Ref_to_Member'>baserestrictinfo</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN897"><span class='Ref_To_Local'>childquals</span></a><span class='Delimiter'>; 
</span>        <a href="allpaths.c.html#LN896"><span class='Ref_To_Local'>childrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN586"><span class='Ref_to_Member'>baserestrict_min_security</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN898"><span class='Ref_To_Local'>cq_min_security</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN899"><span class='Ref_To_Local'>have_const_false_cq</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Some restriction clause reduced to constant FALSE or NULL after 
             * substitution, so this child need not be scanned. 
             */ 
</span>            <a href="../../../include/optimizer/paths.h.html#LN51"><span class='Ref_to_Proto'>set_dummy_rel_pathlist</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN896"><span class='Ref_To_Local'>childrel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/optimizer/plancat.h.html#LN37"><span class='Ref_to_Proto'>relation_excluded_by_constraints</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN858"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN896"><span class='Ref_To_Local'>childrel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN895"><span class='Ref_To_Local'>childRTE</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * This child need not be scanned, so we can omit it from the 
             * appendrel. 
             */ 
</span>            <a href="../../../include/optimizer/paths.h.html#LN51"><span class='Ref_to_Proto'>set_dummy_rel_pathlist</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN896"><span class='Ref_To_Local'>childrel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * CE failed, so finish copying/modifying targetlist and join quals. 
         * 
         * NB: the resulting childrel-&GT;reltarget-&GT;exprs may contain arbitrary 
         * expressions, which otherwise would not occur in a rel's targetlist. 
         * Code that might be looking at an appendrel child must cope with 
         * such.  (Normally, a rel's targetlist would only include Vars and 
         * PlaceHolderVars.)  XXX we do not bother to update the cost or width 
         * fields of childrel-&GT;reltarget; not clear if that would be useful. 
         */ 
</span>        <a href="allpaths.c.html#LN896"><span class='Ref_To_Local'>childrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN588"><span class='Ref_to_Member'>joininfo</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>            <a href="../../../include/optimizer/prep.h.html#LN54"><span class='Ref_to_Proto'>adjust_appendrel_attrs</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN858"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                   <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN858"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN588"><span class='Ref_to_Member'>joininfo</span></a><span class='Delimiter'>, 
</span>                                   <a href="allpaths.c.html#LN893"><span class='Ref_To_Local'>appinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="allpaths.c.html#LN896"><span class='Ref_To_Local'>childrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN535"><span class='Ref_to_Member'>reltarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN882"><span class='Ref_to_Member'>exprs</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>            <a href="../../../include/optimizer/prep.h.html#LN54"><span class='Ref_to_Proto'>adjust_appendrel_attrs</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN858"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                   <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN858"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN535"><span class='Ref_to_Member'>reltarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN882"><span class='Ref_to_Member'>exprs</span></a><span class='Delimiter'>, 
</span>                                   <a href="allpaths.c.html#LN893"><span class='Ref_To_Local'>appinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We have to make child entries in the EquivalenceClass data 
         * structures as well.  This is needed either if the parent 
         * participates in some eclass joins (because we will want to consider 
         * inner-indexscan joins on the individual children) or if the parent 
         * has useful pathkeys (because we should try to build MergeAppend 
         * paths that produce those sort orderings). 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN858"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN590"><span class='Ref_to_Member'>has_eclass_joins</span></a> <span class='Operator'>|| </span><a href="../../../include/optimizer/paths.h.html#LN225"><span class='Ref_to_Proto'>has_useful_pathkeys</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN858"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN858"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>))</span> 
            <a href="../../../include/optimizer/paths.h.html#LN152"><span class='Ref_to_Proto'>add_child_rel_equivalences</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN858"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN893"><span class='Ref_To_Local'>appinfo</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN858"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN896"><span class='Ref_To_Local'>childrel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="allpaths.c.html#LN896"><span class='Ref_To_Local'>childrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN590"><span class='Ref_to_Member'>has_eclass_joins</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN858"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN590"><span class='Ref_to_Member'>has_eclass_joins</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Note: we could compute appropriate attr_needed data for the child's 
         * variables, by transforming the parent's attr_needed through the 
         * translated_vars mapping.  However, currently there's no need 
         * because attr_needed is only examined for base relations not 
         * otherrels.  So we just leave the child's attr_needed empty. 
         */ 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If parallelism is allowable for this query in general, see whether 
         * it's allowable for this childrel in particular.  But if we've 
         * already decided the appendrel is not parallel-safe as a whole, 
         * there's no point in considering parallelism for this child.  For 
         * consistency, do this before calling set_rel_size() for the child. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN858"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN156"><span class='Ref_to_Member'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN128"><span class='Ref_to_Member'>parallelModeOK</span></a> <span class='Operator'>&& </span><a href="allpaths.c.html#LN858"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN532"><span class='Ref_to_Member'>consider_parallel</span></a><span class='Parentheses'>) 
</span>            <a href="allpaths.c.html#LN79"><span class='Ref_to_Proto'>set_rel_consider_parallel</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN858"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN896"><span class='Ref_To_Local'>childrel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN895"><span class='Ref_To_Local'>childRTE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Compute the child's size. 
         */ 
</span>        <a href="allpaths.c.html#LN72"><span class='Ref_to_Proto'>set_rel_size</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN858"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN896"><span class='Ref_To_Local'>childrel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN894"><span class='Ref_To_Local'>childRTindex</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN895"><span class='Ref_To_Local'>childRTE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * It is possible that constraint exclusion detected a contradiction 
         * within a child subquery, even though we didn't prove one above. If 
         * so, we can skip this child. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1186"><span class='Ref_to_Macro'>IS_DUMMY_REL</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN896"><span class='Ref_To_Local'>childrel</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* We have at least one live child. */ 
</span>        <a href="allpaths.c.html#LN862"><span class='Ref_To_Local'>has_live_children</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If any live child is not parallel-safe, treat the whole appendrel 
         * as not parallel-safe.  In future we might be able to generate plans 
         * in which some children are farmed out to workers while others are 
         * not; but we don't have that today, so it's a waste to consider 
         * partial paths anywhere in the appendrel unless it's all safe. 
         * (Child rels visited before this one will be unmarked in 
         * set_append_rel_pathlist().) 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="allpaths.c.html#LN896"><span class='Ref_To_Local'>childrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN532"><span class='Ref_to_Member'>consider_parallel</span></a><span class='Parentheses'>) 
</span>            <a href="allpaths.c.html#LN858"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN532"><span class='Ref_to_Member'>consider_parallel</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Accumulate size information from each live child. 
         */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="allpaths.c.html#LN896"><span class='Ref_To_Local'>childrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="allpaths.c.html#LN863"><span class='Ref_To_Local'>parent_rows</span></a> <span class='Operator'>+= </span><a href="allpaths.c.html#LN896"><span class='Ref_To_Local'>childrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span>        <a href="allpaths.c.html#LN864"><span class='Ref_To_Local'>parent_size</span></a> <span class='Operator'>+= </span><a href="allpaths.c.html#LN896"><span class='Ref_To_Local'>childrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN535"><span class='Ref_to_Member'>reltarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN885"><span class='Ref_to_Member'>width</span></a> <span class='Operator'>* </span><a href="allpaths.c.html#LN896"><span class='Ref_To_Local'>childrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Accumulate per-column estimates too.  We need not do anything for 
         * PlaceHolderVars in the parent list.  If child expression isn't a 
         * Var, or we didn't record a width estimate for it, we have to fall 
         * back on a datatype-based estimate. 
         * 
         * By construction, child's targetlist is 1-to-1 with parent's. 
         */ 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN179"><span class='Ref_to_Macro'>forboth</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN900"><span class='Ref_To_Local'>parentvars</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN858"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN535"><span class='Ref_to_Member'>reltarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN882"><span class='Ref_to_Member'>exprs</span></a><span class='Delimiter'>, 
</span>                <a href="allpaths.c.html#LN901"><span class='Ref_To_Local'>childvars</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN896"><span class='Ref_To_Local'>childrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN535"><span class='Ref_to_Member'>reltarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN882"><span class='Ref_to_Member'>exprs</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1146"></a>            <a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>parentvar</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN900"><span class='Ref_To_Local'>parentvars</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1147"></a>            <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>childvar</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN901"><span class='Ref_To_Local'>childvars</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1146"><span class='Ref_To_Local'>parentvar</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span><a name="LN1151"></a>                <span class='Keyword'>int</span>         <span class='Declare_Local'>pndx</span> <span class='Operator'>= </span><a href="allpaths.c.html#LN1146"><span class='Ref_To_Local'>parentvar</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN167"><span class='Ref_to_Member'>varattno</span></a> <span class='Operator'>- </span><a href="allpaths.c.html#LN858"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN555"><span class='Ref_to_Member'>min_attr</span></a><span class='Delimiter'>; 
</span><a name="LN1152"></a>                <a href="../../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Local'>child_width</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1147"><span class='Ref_To_Local'>childvar</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>                    <span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN1147"><span class='Ref_To_Local'>childvar</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>varno <span class='Operator'>== </span><a href="allpaths.c.html#LN896"><span class='Ref_To_Local'>childrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a><span class='Parentheses'>)</span> 
                <span class='Delimiter'>{ 
</span><a name="LN1157"></a>                    <span class='Keyword'>int</span>         <span class='Declare_Local'>cndx</span> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN1147"><span class='Ref_To_Local'>childvar</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>varattno <span class='Operator'>- </span><a href="allpaths.c.html#LN896"><span class='Ref_To_Local'>childrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN555"><span class='Ref_to_Member'>min_attr</span></a><span class='Delimiter'>; 
</span> 
                    <a href="allpaths.c.html#LN1152"><span class='Ref_To_Local'>child_width</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN896"><span class='Ref_To_Local'>childrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN558"><span class='Ref_to_Member'>attr_widths</span></a><span class='Delimiter'>[</span><a href="allpaths.c.html#LN1157"><span class='Ref_To_Local'>cndx</span></a><span class='Delimiter'>]; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN1152"><span class='Ref_To_Local'>child_width</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                    <a href="allpaths.c.html#LN1152"><span class='Ref_To_Local'>child_width</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN170"><span class='Ref_to_Proto'>get_typavgwidth</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1147"><span class='Ref_To_Local'>childvar</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                  <a href="../../../include/nodes/nodeFuncs.h.html#LN32"><span class='Ref_to_Proto'>exprTypmod</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1147"><span class='Ref_To_Local'>childvar</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1152"><span class='Ref_To_Local'>child_width</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="allpaths.c.html#LN865"><span class='Ref_To_Local'>parent_attrsizes</span></a><span class='Delimiter'>[</span><a href="allpaths.c.html#LN1151"><span class='Ref_To_Local'>pndx</span></a><span class='Delimiter'>] </span><span class='Operator'>+= </span><a href="allpaths.c.html#LN1152"><span class='Ref_To_Local'>child_width</span></a> <span class='Operator'>* </span><a href="allpaths.c.html#LN896"><span class='Ref_To_Local'>childrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN862"><span class='Ref_To_Local'>has_live_children</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Save the finished size estimates. 
         */ 
</span><a name="LN1175"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="allpaths.c.html#LN863"><span class='Ref_To_Local'>parent_rows</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="allpaths.c.html#LN858"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN863"><span class='Ref_To_Local'>parent_rows</span></a><span class='Delimiter'>; 
</span>        <a href="allpaths.c.html#LN858"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN535"><span class='Ref_to_Member'>reltarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN885"><span class='Ref_to_Member'>width</span></a> <span class='Operator'>= </span><a href="../../../port/rint.c.html#LN20"><span class='Ref_to_Func'>rint</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN864"><span class='Ref_To_Local'>parent_size</span></a> <span class='Operator'>/ </span><a href="allpaths.c.html#LN863"><span class='Ref_To_Local'>parent_rows</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN1175"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="allpaths.c.html#LN1175"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="allpaths.c.html#LN866"><span class='Ref_To_Local'>nattrs</span></a><span class='Delimiter'>; </span><a href="allpaths.c.html#LN1175"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>            <a href="allpaths.c.html#LN858"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN558"><span class='Ref_to_Member'>attr_widths</span></a><span class='Delimiter'>[</span><a href="allpaths.c.html#LN1175"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../../port/rint.c.html#LN20"><span class='Ref_to_Func'>rint</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN865"><span class='Ref_To_Local'>parent_attrsizes</span></a><span class='Delimiter'>[</span><a href="allpaths.c.html#LN1175"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>/ </span><a href="allpaths.c.html#LN863"><span class='Ref_To_Local'>parent_rows</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Set "raw tuples" count equal to "rows" for the appendrel; needed 
         * because some places assume rel-&GT;tuples is valid for any baserel. 
         */ 
</span>        <a href="allpaths.c.html#LN858"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN564"><span class='Ref_to_Member'>tuples</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN863"><span class='Ref_To_Local'>parent_rows</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * All children were excluded by constraints, so mark the whole 
         * appendrel dummy.  We must do this in this phase so that the rel's 
         * dummy-ness is visible when we generate paths for other rels. 
         */ 
</span>        <a href="../../../include/optimizer/paths.h.html#LN51"><span class='Ref_to_Proto'>set_dummy_rel_pathlist</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN858"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN865"><span class='Ref_To_Local'>parent_attrsizes</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end set_append_rel_size &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * set_append_rel_pathlist 
 *    Build access paths for an "append relation" 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1207"></a><span class='Declare_Function'>set_append_rel_pathlist</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, 
</span><a name="LN1208"></a>                        <a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a> <span class='Declare_Parameter'>rti</span><span class='Delimiter'>, </span><a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rte</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1210"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>parentRTindex</span> <span class='Operator'>= </span><a href="allpaths.c.html#LN1208"><span class='Ref_to_Parameter'>rti</span></a><span class='Delimiter'>; 
</span><a name="LN1211"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>live_childrels</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN1212"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Generate access paths for each member relation, and remember the 
     * non-dummy children. 
     */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1212"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1207"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN251"><span class='Ref_to_Member'>append_rel_list</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1220"></a>        <a href="../../../include/nodes/relation.h.html#LN1964"><span class='Ref_to_Struct'>AppendRelInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>appinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1964"><span class='Ref_to_Struct'>AppendRelInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1212"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1221"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>childRTindex</span><span class='Delimiter'>; 
</span><a name="LN1222"></a>        <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>childRTE</span><span class='Delimiter'>; 
</span><a name="LN1223"></a>        <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>childrel</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* append_rel_list contains all append rels; ignore others */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN1220"><span class='Ref_To_Local'>appinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1974"><span class='Ref_to_Member'>parent_relid</span></a> <span class='Operator'>!= </span><a href="allpaths.c.html#LN1210"><span class='Ref_To_Local'>parentRTindex</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Re-locate the child RTE and RelOptInfo */ 
</span>        <a href="allpaths.c.html#LN1221"><span class='Ref_To_Local'>childRTindex</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN1220"><span class='Ref_To_Local'>appinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1975"><span class='Ref_to_Member'>child_relid</span></a><span class='Delimiter'>; 
</span>        <a href="allpaths.c.html#LN1222"><span class='Ref_To_Local'>childRTE</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN1207"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN187"><span class='Ref_to_Member'>simple_rte_array</span></a><span class='Delimiter'>[</span><a href="allpaths.c.html#LN1221"><span class='Ref_To_Local'>childRTindex</span></a><span class='Delimiter'>]; 
</span>        <a href="allpaths.c.html#LN1223"><span class='Ref_To_Local'>childrel</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN1207"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN178"><span class='Ref_to_Member'>simple_rel_array</span></a><span class='Delimiter'>[</span><a href="allpaths.c.html#LN1221"><span class='Ref_To_Local'>childRTindex</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If set_append_rel_size() decided the parent appendrel was 
         * parallel-unsafe at some point after visiting this child rel, we 
         * need to propagate the unsafety marking down to the child, so that 
         * we don't generate useless partial paths for it. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="allpaths.c.html#LN1207"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN532"><span class='Ref_to_Member'>consider_parallel</span></a><span class='Parentheses'>) 
</span>            <a href="allpaths.c.html#LN1223"><span class='Ref_To_Local'>childrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN532"><span class='Ref_to_Member'>consider_parallel</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Compute the child's access paths. 
         */ 
</span>        <a href="allpaths.c.html#LN74"><span class='Ref_to_Proto'>set_rel_pathlist</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1207"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1223"><span class='Ref_To_Local'>childrel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1221"><span class='Ref_To_Local'>childRTindex</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1222"><span class='Ref_To_Local'>childRTE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If child is dummy, ignore it. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1186"><span class='Ref_to_Macro'>IS_DUMMY_REL</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1223"><span class='Ref_To_Local'>childrel</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Child is live, so add it to the live_childrels list for use below. 
         */ 
</span>        <a href="allpaths.c.html#LN1211"><span class='Ref_To_Local'>live_childrels</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1211"><span class='Ref_To_Local'>live_childrels</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1223"><span class='Ref_To_Local'>childrel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Add paths to the "append" relation. */ 
</span>    <a href="allpaths.c.html#LN134"><span class='Ref_to_Proto'>add_paths_to_append_rel</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1207"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1207"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1211"><span class='Ref_To_Local'>live_childrels</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end set_append_rel_pathlist &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * add_paths_to_append_rel 
 *      Generate paths for given "append" relation given the set of non-dummy 
 *      child rels. 
 * 
 * The function collects all parameterizations and orderings supported by the 
 * non-dummy children. For every such parameterization or ordering, it creates 
 * an append path collecting one path from each non-dummy child with given 
 * parameterization or ordering. Similarly it collects partial paths from 
 * non-dummy children to create partial append paths. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1277"></a><span class='Declare_Function'>add_paths_to_append_rel</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, 
</span><a name="LN1278"></a>                        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>live_childrels</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1280"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>subpaths</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN1281"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>subpaths_valid</span> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span><a name="LN1282"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>partial_subpaths</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN1283"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>partial_subpaths_valid</span> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span><a name="LN1284"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>all_child_pathkeys</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN1285"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>all_child_outers</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN1286"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span><a name="LN1287"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>partitioned_rels</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN1288"></a>    <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span><span class='Delimiter'>; 
</span> 
    <a href="allpaths.c.html#LN1288"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/relation.h.html#LN324"><span class='Ref_to_Macro'>planner_rt_fetch</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1277"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1277"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN1288"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN948"><span class='Ref_to_Member'>relkind</span></a> <span class='Operator'>== </span><a href="../../../include/catalog/pg_class.h.html#LN167"><span class='Ref_to_Const'>RELKIND_PARTITIONED_TABLE</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="allpaths.c.html#LN1287"><span class='Ref_To_Local'>partitioned_rels</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/planner.h.html#LN59"><span class='Ref_to_Proto'>get_partitioned_child_rels</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1277"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1277"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* The root partitioned table is included as a child rel */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1287"><span class='Ref_To_Local'>partitioned_rels</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT;= </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * For every non-dummy child, remember the cheapest path.  Also, identify 
     * all pathkeys (orderings) and parameterizations (required_outer sets) 
     * available for the non-dummy member relations. 
     */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1286"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1278"><span class='Ref_to_Parameter'>live_childrels</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1305"></a>        <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>childrel</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1286"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1306"></a>        <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lcp</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If child has an unparameterized cheapest-total path, add that to 
         * the unparameterized Append path we are constructing for the parent. 
         * If not, there's no workable unparameterized path. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN1305"><span class='Ref_To_Local'>childrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN542"><span class='Ref_to_Member'>cheapest_total_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN955"><span class='Ref_to_Member'>param_info</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <a href="allpaths.c.html#LN1280"><span class='Ref_To_Local'>subpaths</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN102"><span class='Ref_to_Proto'>accumulate_append_subpath</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1280"><span class='Ref_To_Local'>subpaths</span></a><span class='Delimiter'>, 
</span>                                              <a href="allpaths.c.html#LN1305"><span class='Ref_To_Local'>childrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN542"><span class='Ref_to_Member'>cheapest_total_path</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="allpaths.c.html#LN1281"><span class='Ref_To_Local'>subpaths_valid</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Same idea, but for a partial plan. */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN1305"><span class='Ref_To_Local'>childrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN540"><span class='Ref_to_Member'>partial_pathlist</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>            <a href="allpaths.c.html#LN1282"><span class='Ref_To_Local'>partial_subpaths</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN102"><span class='Ref_to_Proto'>accumulate_append_subpath</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1282"><span class='Ref_To_Local'>partial_subpaths</span></a><span class='Delimiter'>, 
</span>                                       <a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1305"><span class='Ref_To_Local'>childrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN540"><span class='Ref_to_Member'>partial_pathlist</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="allpaths.c.html#LN1283"><span class='Ref_To_Local'>partial_subpaths_valid</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Collect lists of all the available path orderings and 
         * parameterizations for all the children.  We use these as a 
         * heuristic to indicate which sort orderings and parameterizations we 
         * should build Append and MergeAppend paths for. 
         */ 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1306"><span class='Ref_To_Local'>lcp</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1305"><span class='Ref_To_Local'>childrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN538"><span class='Ref_to_Member'>pathlist</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1334"></a>            <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>childpath</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1306"><span class='Ref_To_Local'>lcp</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1335"></a>            <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>childkeys</span> <span class='Operator'>= </span><a href="allpaths.c.html#LN1334"><span class='Ref_To_Local'>childpath</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN967"><span class='Ref_to_Member'>pathkeys</span></a><span class='Delimiter'>; 
</span><a name="LN1336"></a>            <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>childouter</span> <span class='Operator'>= </span><a href="../../../include/nodes/relation.h.html#LN972"><span class='Ref_to_Macro'>PATH_REQ_OUTER</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1334"><span class='Ref_To_Local'>childpath</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Unsorted paths don't contribute to pathkey list */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN1335"><span class='Ref_To_Local'>childkeys</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN1341"></a>                <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lpk</span><span class='Delimiter'>; 
</span><a name="LN1342"></a>                <span class='Keyword'>bool</span>        <span class='Declare_Local'>found</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* Have we already seen this ordering? */ 
</span>                <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1341"><span class='Ref_To_Local'>lpk</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1284"><span class='Ref_To_Local'>all_child_pathkeys</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span><a name="LN1347"></a>                    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>existing_pathkeys</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1341"><span class='Ref_To_Local'>lpk</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/optimizer/paths.h.html#LN182"><span class='Ref_to_Proto'>compare_pathkeys</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1347"><span class='Ref_To_Local'>existing_pathkeys</span></a><span class='Delimiter'>, 
</span>                                         <a href="allpaths.c.html#LN1335"><span class='Ref_To_Local'>childkeys</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="../../../include/optimizer/paths.h.html#LN176"><span class='Ref_to_EnumConst'>PATHKEYS_EQUAL</span></a><span class='Parentheses'>)</span> 
                    <span class='Delimiter'>{ 
</span>                        <a href="allpaths.c.html#LN1342"><span class='Ref_To_Local'>found</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                        <span class='Control'>break</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="allpaths.c.html#LN1342"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* No, so add it to all_child_pathkeys */ 
</span>                    <a href="allpaths.c.html#LN1284"><span class='Ref_To_Local'>all_child_pathkeys</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1284"><span class='Ref_To_Local'>all_child_pathkeys</span></a><span class='Delimiter'>, 
</span>                                                 <a href="allpaths.c.html#LN1335"><span class='Ref_To_Local'>childkeys</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if childkeys!=NIL &raquo; </span> 
 
            <span class='Comment_Multi_Line'>/* Unparameterized paths don't contribute to param-set list */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN1336"><span class='Ref_To_Local'>childouter</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN1367"></a>                <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lco</span><span class='Delimiter'>; 
</span><a name="LN1368"></a>                <span class='Keyword'>bool</span>        <span class='Declare_Local'>found</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* Have we already seen this param set? */ 
</span>                <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1367"><span class='Ref_To_Local'>lco</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1285"><span class='Ref_To_Local'>all_child_outers</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span><a name="LN1373"></a>                    <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>existing_outers</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1367"><span class='Ref_To_Local'>lco</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN66"><span class='Ref_to_Proto'>bms_equal</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1373"><span class='Ref_To_Local'>existing_outers</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1336"><span class='Ref_To_Local'>childouter</span></a><span class='Parentheses'>))</span> 
                    <span class='Delimiter'>{ 
</span>                        <a href="allpaths.c.html#LN1368"><span class='Ref_To_Local'>found</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                        <span class='Control'>break</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="allpaths.c.html#LN1368"><span class='Ref_To_Local'>found</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* No, so add it to all_child_outers */ 
</span>                    <a href="allpaths.c.html#LN1285"><span class='Ref_To_Local'>all_child_outers</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1285"><span class='Ref_To_Local'>all_child_outers</span></a><span class='Delimiter'>, 
</span>                                               <a href="allpaths.c.html#LN1336"><span class='Ref_To_Local'>childouter</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if childouter &raquo; </span> 
        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we found unparameterized paths for all children, build an unordered, 
     * unparameterized Append path for the rel.  (Note: this is correct even 
     * if we have zero or one live subpath due to constraint exclusion.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN1281"><span class='Ref_To_Local'>subpaths_valid</span></a><span class='Parentheses'>) 
</span>        <a href="../../../include/optimizer/pathnode.h.html#LN27"><span class='Ref_to_Proto'>add_path</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1277"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/optimizer/pathnode.h.html#LN65"><span class='Ref_to_Proto'>create_append_path</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1277"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1280"><span class='Ref_To_Local'>subpaths</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, 
</span>                                                  <a href="allpaths.c.html#LN1287"><span class='Ref_To_Local'>partitioned_rels</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Consider an append of partial unordered, unparameterized partial paths. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN1283"><span class='Ref_To_Local'>partial_subpaths_valid</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1405"></a>        <a href="../../../include/nodes/relation.h.html#LN1174"><span class='Ref_to_Struct'>AppendPath</span></a> <span class='Operator'>*</span><span class='Declare_Local'>appendpath</span><span class='Delimiter'>; 
</span><a name="LN1406"></a>        <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span><a name="LN1407"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>parallel_workers</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Decide on the number of workers to request for this append path. 
         * For now, we just use the maximum value from among the members.  It 
         * might be useful to use a higher number if the Append node were 
         * smart enough to spread out the workers, but it currently isn't. 
         */ 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1406"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1282"><span class='Ref_To_Local'>partial_subpaths</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1417"></a>            <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>path</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1406"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="allpaths.c.html#LN1407"><span class='Ref_To_Local'>parallel_workers</span></a> <span class='Operator'>= </span><a href="../../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN10"><span class='Ref_to_Macro'>Max</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1407"><span class='Ref_To_Local'>parallel_workers</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1417"><span class='Ref_To_Local'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN959"><span class='Ref_to_Member'>parallel_workers</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1407"><span class='Ref_To_Local'>parallel_workers</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Generate a partial append path. */ 
</span>        <a href="allpaths.c.html#LN1405"><span class='Ref_To_Local'>appendpath</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/pathnode.h.html#LN65"><span class='Ref_to_Proto'>create_append_path</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1277"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1282"><span class='Ref_To_Local'>partial_subpaths</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                                        <a href="allpaths.c.html#LN1407"><span class='Ref_To_Local'>parallel_workers</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1287"><span class='Ref_To_Local'>partitioned_rels</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/optimizer/pathnode.h.html#LN31"><span class='Ref_to_Proto'>add_partial_path</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1277"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN1405"><span class='Ref_To_Local'>appendpath</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if partial_subpaths_vali... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Also build unparameterized MergeAppend paths based on the collected 
     * list of child pathkeys. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN1281"><span class='Ref_To_Local'>subpaths_valid</span></a><span class='Parentheses'>) 
</span>        <a href="allpaths.c.html#LN95"><span class='Ref_to_Proto'>generate_mergeappend_paths</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1277"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1277"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1278"><span class='Ref_to_Parameter'>live_childrels</span></a><span class='Delimiter'>, 
</span>                                   <a href="allpaths.c.html#LN1284"><span class='Ref_To_Local'>all_child_pathkeys</span></a><span class='Delimiter'>, 
</span>                                   <a href="allpaths.c.html#LN1287"><span class='Ref_To_Local'>partitioned_rels</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Build Append paths for each parameterization seen among the child rels. 
     * (This may look pretty expensive, but in most cases of practical 
     * interest, the child rels will expose mostly the same parameterizations, 
     * so that not that many cases actually get considered here.) 
     * 
     * The Append node itself cannot enforce quals, so all qual checking must 
     * be done in the child paths.  This means that to have a parameterized 
     * Append path, we must have the exact same parameterization for each 
     * child path; otherwise some children might be failing to check the 
     * moved-down quals.  To make them match up, we can try to increase the 
     * parameterization of lesser-parameterized paths. 
     */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1286"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1285"><span class='Ref_To_Local'>all_child_outers</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1453"></a>        <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>required_outer</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1286"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1454"></a>        <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lcr</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Select the child paths for an Append with this parameterization */ 
</span>        <a href="allpaths.c.html#LN1280"><span class='Ref_To_Local'>subpaths</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>        <a href="allpaths.c.html#LN1281"><span class='Ref_To_Local'>subpaths_valid</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1454"><span class='Ref_To_Local'>lcr</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1278"><span class='Ref_to_Parameter'>live_childrels</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1461"></a>            <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>childrel</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1454"><span class='Ref_To_Local'>lcr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1462"></a>            <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>subpath</span><span class='Delimiter'>; 
</span> 
            <a href="allpaths.c.html#LN1462"><span class='Ref_To_Local'>subpath</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN99"><span class='Ref_to_Proto'>get_cheapest_parameterized_child_path</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1277"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                                            <a href="allpaths.c.html#LN1461"><span class='Ref_To_Local'>childrel</span></a><span class='Delimiter'>, 
</span>                                                            <a href="allpaths.c.html#LN1453"><span class='Ref_To_Local'>required_outer</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN1462"><span class='Ref_To_Local'>subpath</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* failed to make a suitable path for this child */ 
</span>                <a href="allpaths.c.html#LN1281"><span class='Ref_To_Local'>subpaths_valid</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <a href="allpaths.c.html#LN1280"><span class='Ref_To_Local'>subpaths</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN102"><span class='Ref_to_Proto'>accumulate_append_subpath</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1280"><span class='Ref_To_Local'>subpaths</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1462"><span class='Ref_To_Local'>subpath</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN1281"><span class='Ref_To_Local'>subpaths_valid</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/optimizer/pathnode.h.html#LN27"><span class='Ref_to_Proto'>add_path</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1277"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>                     <a href="../../../include/optimizer/pathnode.h.html#LN65"><span class='Ref_to_Proto'>create_append_path</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1277"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1280"><span class='Ref_To_Local'>subpaths</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1453"><span class='Ref_To_Local'>required_outer</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, 
</span>                                        <a href="allpaths.c.html#LN1287"><span class='Ref_To_Local'>partitioned_rels</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end add_paths_to_append_rel &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * generate_mergeappend_paths 
 *      Generate MergeAppend paths for an append relation 
 * 
 * Generate a path for each ordering (pathkey list) appearing in 
 * all_child_pathkeys. 
 * 
 * We consider both cheapest-startup and cheapest-total cases, ie, for each 
 * interesting ordering, collect all the cheapest startup subpaths and all the 
 * cheapest total paths, and build a MergeAppend path for each case. 
 * 
 * We don't currently generate any parameterized MergeAppend paths.  While 
 * it would not take much more code here to do so, it's very unclear that it 
 * is worth the planning cycles to investigate such paths: there's little 
 * use for an ordered path on the inside of a nestloop.  In fact, it's likely 
 * that the current coding of add_path would reject such paths out of hand, 
 * because add_path gives no credit for sort ordering of parameterized paths, 
 * and a parameterized MergeAppend is going to be more expensive than the 
 * corresponding parameterized Append path.  If we ever try harder to support 
 * parameterized mergejoin plans, it might be worth adding support for 
 * parameterized MergeAppends to feed such joins.  (See notes in 
 * optimizer/README for why that might not ever happen, though.) 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1507"></a><span class='Declare_Function'>generate_mergeappend_paths</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, 
</span><a name="LN1508"></a>                           <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>live_childrels</span><span class='Delimiter'>, 
</span><a name="LN1509"></a>                           <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>all_child_pathkeys</span><span class='Delimiter'>, 
</span><a name="LN1510"></a>                           <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>partitioned_rels</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1512"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lcp</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1512"><span class='Ref_To_Local'>lcp</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1509"><span class='Ref_to_Parameter'>all_child_pathkeys</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1516"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>pathkeys</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1512"><span class='Ref_To_Local'>lcp</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1517"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>startup_subpaths</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN1518"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>total_subpaths</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN1519"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>startup_neq_total</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN1520"></a>        <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lcr</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Select the child paths for this ordering... */ 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1520"><span class='Ref_To_Local'>lcr</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1508"><span class='Ref_to_Parameter'>live_childrels</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1525"></a>            <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>childrel</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1520"><span class='Ref_To_Local'>lcr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1526"></a>            <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>cheapest_startup</span><span class='Delimiter'>, 
</span><a name="LN1527"></a>                       <span class='Operator'>*</span><span class='Declare_Local'>cheapest_total</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Locate the right paths, if they are available. */ 
</span>            <a href="allpaths.c.html#LN1526"><span class='Ref_To_Local'>cheapest_startup</span></a> <span class='Operator'>= 
</span>                <a href="../../../include/optimizer/paths.h.html#LN184"><span class='Ref_to_Proto'>get_cheapest_path_for_pathkeys</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1525"><span class='Ref_To_Local'>childrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN538"><span class='Ref_to_Member'>pathlist</span></a><span class='Delimiter'>, 
</span>                                               <a href="allpaths.c.html#LN1516"><span class='Ref_To_Local'>pathkeys</span></a><span class='Delimiter'>, 
</span>                                               <span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                                               <a href="../../../include/nodes/relation.h.html#LN35"><span class='Ref_to_EnumConst'>STARTUP_COST</span></a><span class='Delimiter'>, 
</span>                                               <span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="allpaths.c.html#LN1527"><span class='Ref_To_Local'>cheapest_total</span></a> <span class='Operator'>= 
</span>                <a href="../../../include/optimizer/paths.h.html#LN184"><span class='Ref_to_Proto'>get_cheapest_path_for_pathkeys</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1525"><span class='Ref_To_Local'>childrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN538"><span class='Ref_to_Member'>pathlist</span></a><span class='Delimiter'>, 
</span>                                               <a href="allpaths.c.html#LN1516"><span class='Ref_To_Local'>pathkeys</span></a><span class='Delimiter'>, 
</span>                                               <span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                                               <a href="../../../include/nodes/relation.h.html#LN35"><span class='Ref_to_EnumConst'>TOTAL_COST</span></a><span class='Delimiter'>, 
</span>                                               <span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * If we can't find any paths with the right order just use the 
             * cheapest-total path; we'll have to sort it later. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN1526"><span class='Ref_To_Local'>cheapest_startup</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>|| </span><a href="allpaths.c.html#LN1527"><span class='Ref_To_Local'>cheapest_total</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="allpaths.c.html#LN1526"><span class='Ref_To_Local'>cheapest_startup</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN1527"><span class='Ref_To_Local'>cheapest_total</span></a> <span class='Operator'>= 
</span>                    <a href="allpaths.c.html#LN1525"><span class='Ref_To_Local'>childrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN542"><span class='Ref_to_Member'>cheapest_total_path</span></a><span class='Delimiter'>; 
</span>                <span class='Comment_Multi_Line'>/* Assert we do have an unparameterized path for this child */ 
</span>                <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1527"><span class='Ref_To_Local'>cheapest_total</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN955"><span class='Ref_to_Member'>param_info</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Notice whether we actually have different paths for the 
             * "cheapest" and "total" cases; frequently there will be no point 
             * in two create_merge_append_path() calls. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN1526"><span class='Ref_To_Local'>cheapest_startup</span></a> <span class='Operator'>!= </span><a href="allpaths.c.html#LN1527"><span class='Ref_To_Local'>cheapest_total</span></a><span class='Parentheses'>) 
</span>                <a href="allpaths.c.html#LN1519"><span class='Ref_To_Local'>startup_neq_total</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
            <a href="allpaths.c.html#LN1517"><span class='Ref_To_Local'>startup_subpaths</span></a> <span class='Operator'>= 
</span>                <a href="allpaths.c.html#LN102"><span class='Ref_to_Proto'>accumulate_append_subpath</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1517"><span class='Ref_To_Local'>startup_subpaths</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1526"><span class='Ref_To_Local'>cheapest_startup</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="allpaths.c.html#LN1518"><span class='Ref_To_Local'>total_subpaths</span></a> <span class='Operator'>= 
</span>                <a href="allpaths.c.html#LN102"><span class='Ref_to_Proto'>accumulate_append_subpath</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1518"><span class='Ref_To_Local'>total_subpaths</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1527"><span class='Ref_To_Local'>cheapest_total</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* ... and build the MergeAppend paths */ 
</span>        <a href="../../../include/optimizer/pathnode.h.html#LN27"><span class='Ref_to_Proto'>add_path</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1507"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/optimizer/pathnode.h.html#LN68"><span class='Ref_to_Proto'>create_merge_append_path</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1507"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                                        <a href="allpaths.c.html#LN1507"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, 
</span>                                                        <a href="allpaths.c.html#LN1517"><span class='Ref_To_Local'>startup_subpaths</span></a><span class='Delimiter'>, 
</span>                                                        <a href="allpaths.c.html#LN1516"><span class='Ref_To_Local'>pathkeys</span></a><span class='Delimiter'>, 
</span>                                                        <span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                                                        <a href="allpaths.c.html#LN1510"><span class='Ref_to_Parameter'>partitioned_rels</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN1519"><span class='Ref_To_Local'>startup_neq_total</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/optimizer/pathnode.h.html#LN27"><span class='Ref_to_Proto'>add_path</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1507"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/optimizer/pathnode.h.html#LN68"><span class='Ref_to_Proto'>create_merge_append_path</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1507"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                                            <a href="allpaths.c.html#LN1507"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, 
</span>                                                            <a href="allpaths.c.html#LN1518"><span class='Ref_To_Local'>total_subpaths</span></a><span class='Delimiter'>, 
</span>                                                            <a href="allpaths.c.html#LN1516"><span class='Ref_To_Local'>pathkeys</span></a><span class='Delimiter'>, 
</span>                                                            <span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                                                          <a href="allpaths.c.html#LN1510"><span class='Ref_to_Parameter'>partitioned_rels</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end generate_mergeappend_paths &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * get_cheapest_parameterized_child_path 
 *      Get cheapest path for this relation that has exactly the requested 
 *      parameterization. 
 * 
 * Returns NULL if unable to create such a path. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>* 
</span><a name="LN1594"></a><span class='Declare_Function'>get_cheapest_parameterized_child_path</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, 
</span><a name="LN1595"></a>                                      <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Declare_Parameter'>required_outer</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1597"></a>    <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>cheapest</span><span class='Delimiter'>; 
</span><a name="LN1598"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Look up the cheapest existing path with no more than the needed 
     * parameterization.  If it has exactly the needed parameterization, we're 
     * done. 
     */ 
</span>    <a href="allpaths.c.html#LN1597"><span class='Ref_To_Local'>cheapest</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/paths.h.html#LN184"><span class='Ref_to_Proto'>get_cheapest_path_for_pathkeys</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1594"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN538"><span class='Ref_to_Member'>pathlist</span></a><span class='Delimiter'>, 
</span>                                              <a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>, 
</span>                                              <a href="allpaths.c.html#LN1595"><span class='Ref_to_Parameter'>required_outer</span></a><span class='Delimiter'>, 
</span>                                              <a href="../../../include/nodes/relation.h.html#LN35"><span class='Ref_to_EnumConst'>TOTAL_COST</span></a><span class='Delimiter'>, 
</span>                                              <span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1597"><span class='Ref_To_Local'>cheapest</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN66"><span class='Ref_to_Proto'>bms_equal</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN972"><span class='Ref_to_Macro'>PATH_REQ_OUTER</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1597"><span class='Ref_To_Local'>cheapest</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1595"><span class='Ref_to_Parameter'>required_outer</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <a href="allpaths.c.html#LN1597"><span class='Ref_To_Local'>cheapest</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Otherwise, we can "reparameterize" an existing path to match the given 
     * parameterization, which effectively means pushing down additional 
     * joinquals to be checked within the path's scan.  However, some existing 
     * paths might check the available joinquals already while others don't; 
     * therefore, it's not clear which existing path will be cheapest after 
     * reparameterization.  We have to go through them all and find out. 
     */ 
</span>    <a href="allpaths.c.html#LN1597"><span class='Ref_To_Local'>cheapest</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1598"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1594"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN538"><span class='Ref_to_Member'>pathlist</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1625"></a>        <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>path</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1598"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Can't use it if it needs more than requested parameterization */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN972"><span class='Ref_to_Macro'>PATH_REQ_OUTER</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1625"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1595"><span class='Ref_to_Parameter'>required_outer</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Reparameterization can only increase the path's cost, so if it's 
         * already more expensive than the current cheapest, forget it. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN1597"><span class='Ref_To_Local'>cheapest</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL </span><span class='Operator'>&& 
</span>            <a href="../../../include/optimizer/pathnode.h.html#LN22"><span class='Ref_to_Proto'>compare_path_costs</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1597"><span class='Ref_To_Local'>cheapest</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1625"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN35"><span class='Ref_to_EnumConst'>TOTAL_COST</span></a><span class='Parentheses'>) </span><span class='Operator'>&LT;= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Reparameterize if needed, then recheck cost */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN66"><span class='Ref_to_Proto'>bms_equal</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN972"><span class='Ref_to_Macro'>PATH_REQ_OUTER</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1625"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1595"><span class='Ref_to_Parameter'>required_outer</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="allpaths.c.html#LN1625"><span class='Ref_To_Local'>path</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/pathnode.h.html#LN247"><span class='Ref_to_Proto'>reparameterize_path</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1594"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1625"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1595"><span class='Ref_to_Parameter'>required_outer</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN1625"><span class='Ref_To_Local'>path</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>                <span class='Control'>continue</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* failed to reparameterize this one */ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN66"><span class='Ref_to_Proto'>bms_equal</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN972"><span class='Ref_to_Macro'>PATH_REQ_OUTER</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1625"><span class='Ref_To_Local'>path</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1595"><span class='Ref_to_Parameter'>required_outer</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN1597"><span class='Ref_To_Local'>cheapest</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL </span><span class='Operator'>&& 
</span>                <a href="../../../include/optimizer/pathnode.h.html#LN22"><span class='Ref_to_Proto'>compare_path_costs</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1597"><span class='Ref_To_Local'>cheapest</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1625"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN35"><span class='Ref_to_EnumConst'>TOTAL_COST</span></a><span class='Parentheses'>) </span><span class='Operator'>&LT;= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* We have a new best path */ 
</span>        <a href="allpaths.c.html#LN1597"><span class='Ref_To_Local'>cheapest</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN1625"><span class='Ref_To_Local'>path</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Return the best path, or NULL if we found no suitable candidate */ 
</span>    <span class='Control'>return</span> <a href="allpaths.c.html#LN1597"><span class='Ref_To_Local'>cheapest</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end get_cheapest_parameterized_child_path &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * accumulate_append_subpath 
 *      Add a subpath to the list being built for an Append or MergeAppend 
 * 
 * It's possible that the child is itself an Append or MergeAppend path, in 
 * which case we can "cut out the middleman" and just add its child paths to 
 * our own list.  (We don't try to do this earlier because we need to apply 
 * both levels of transformation to the quals.) 
 * 
 * Note that if we omit a child MergeAppend in this way, we are effectively 
 * omitting a sort step, which seems fine: if the parent is to be an Append, 
 * its result would be unsorted anyway, while if the parent is to be a 
 * MergeAppend, there's no point in a separate sort on a child. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN1675"></a><span class='Declare_Function'>accumulate_append_subpath</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>subpaths</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1675"><span class='Ref_to_Parameter'>path</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1174"><span class='Ref_to_Struct'>AppendPath</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1679"></a>        <a href="../../../include/nodes/relation.h.html#LN1174"><span class='Ref_to_Struct'>AppendPath</span></a> <span class='Operator'>*</span><span class='Declare_Local'>apath</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1174"><span class='Ref_to_Struct'>AppendPath</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN1675"><span class='Ref_to_Parameter'>path</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* list_copy is important here to avoid sharing list substructure */ 
</span>        <span class='Control'>return</span> <a href="../../../include/nodes/pg_list.h.html#LN219"><span class='Ref_to_Proto'>list_concat</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1675"><span class='Ref_to_Parameter'>subpaths</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN268"><span class='Ref_to_Proto'>list_copy</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1679"><span class='Ref_To_Local'>apath</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1179"><span class='Ref_to_Member'>subpaths</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1675"><span class='Ref_to_Parameter'>path</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1194"><span class='Ref_to_Struct'>MergeAppendPath</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1686"></a>        <a href="../../../include/nodes/relation.h.html#LN1194"><span class='Ref_to_Struct'>MergeAppendPath</span></a> <span class='Operator'>*</span><span class='Declare_Local'>mpath</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1194"><span class='Ref_to_Struct'>MergeAppendPath</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN1675"><span class='Ref_to_Parameter'>path</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* list_copy is important here to avoid sharing list substructure */ 
</span>        <span class='Control'>return</span> <a href="../../../include/nodes/pg_list.h.html#LN219"><span class='Ref_to_Proto'>list_concat</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1675"><span class='Ref_to_Parameter'>subpaths</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN268"><span class='Ref_to_Proto'>list_copy</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1686"><span class='Ref_To_Local'>mpath</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1199"><span class='Ref_to_Member'>subpaths</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
        <span class='Control'>return</span> <a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1675"><span class='Ref_to_Parameter'>subpaths</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1675"><span class='Ref_to_Parameter'>path</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end accumulate_append_subpath &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * set_dummy_rel_pathlist 
 *    Build a dummy path for a relation that's been excluded by constraints 
 * 
 * Rather than inventing a special "dummy" path type, we represent this as an 
 * AppendPath with no members (see also IS_DUMMY_PATH/IS_DUMMY_REL macros). 
 * 
 * This is exported because inheritance_planner() has need for it. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1705"></a><span class='Declare_Function'>set_dummy_rel_pathlist</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* Set dummy size estimates --- we leave attr_widths[] as zeroes */ 
</span>    <a href="allpaths.c.html#LN1705"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="allpaths.c.html#LN1705"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN535"><span class='Ref_to_Member'>reltarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN885"><span class='Ref_to_Member'>width</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Discard any pre-existing paths; no further need for them */ 
</span>    <a href="allpaths.c.html#LN1705"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN538"><span class='Ref_to_Member'>pathlist</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="allpaths.c.html#LN1705"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN540"><span class='Ref_to_Member'>partial_pathlist</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
    <a href="../../../include/optimizer/pathnode.h.html#LN27"><span class='Ref_to_Proto'>add_path</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1705"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/optimizer/pathnode.h.html#LN65"><span class='Ref_to_Proto'>create_append_path</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1705"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We set the cheapest path immediately, to ensure that IS_DUMMY_REL() 
     * will recognize the relation as dummy if anyone asks.  This is redundant 
     * when we're called from set_rel_size(), but not when called from 
     * elsewhere, and doing it twice is harmless anyway. 
     */ 
</span>    <a href="../../../include/optimizer/pathnode.h.html#LN26"><span class='Ref_to_Proto'>set_cheapest</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1705"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end set_dummy_rel_pathlist &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* quick-and-dirty test to see if any joining is needed */ 
</span><span class='Keyword'>static bool 
</span><a name="LN1728"></a><span class='Declare_Function'>has_multiple_baserels</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1730"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>num_base_rels</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN1731"></a>    <a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Local'>rti</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN1731"><span class='Ref_To_Local'>rti</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="allpaths.c.html#LN1731"><span class='Ref_To_Local'>rti</span></a> <span class='Operator'>&LT; </span><a href="allpaths.c.html#LN1728"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN179"><span class='Ref_to_Member'>simple_rel_array_size</span></a><span class='Delimiter'>; </span><a href="allpaths.c.html#LN1731"><span class='Ref_To_Local'>rti</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1735"></a>        <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>brel</span> <span class='Operator'>= </span><a href="allpaths.c.html#LN1728"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN178"><span class='Ref_to_Member'>simple_rel_array</span></a><span class='Delimiter'>[</span><a href="allpaths.c.html#LN1731"><span class='Ref_To_Local'>rti</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN1735"><span class='Ref_To_Local'>brel</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* ignore RTEs that are "other rels" */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN1735"><span class='Ref_To_Local'>brel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN521"><span class='Ref_to_Member'>reloptkind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/relation.h.html#LN493"><span class='Ref_to_EnumConst'>RELOPT_BASEREL</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>++</span><a href="allpaths.c.html#LN1730"><span class='Ref_To_Local'>num_base_rels</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>                <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end has_multiple_baserels &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * set_subquery_pathlist 
 *      Generate SubqueryScan access paths for a subquery RTE 
 * 
 * We don't currently support generating parameterized paths for subqueries 
 * by pushing join clauses down into them; it seems too expensive to re-plan 
 * the subquery multiple times to consider different alternatives. 
 * (XXX that could stand to be reconsidered, now that we use Paths.) 
 * So the paths made here will be parameterized if the subquery contains 
 * LATERAL references, otherwise not.  As long as that's true, there's no need 
 * for a separate set_subquery_size phase: just make the paths right away. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1761"></a><span class='Declare_Function'>set_subquery_pathlist</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, 
</span><a name="LN1762"></a>                      <a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a> <span class='Declare_Parameter'>rti</span><span class='Delimiter'>, </span><a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rte</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1764"></a>    <a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>parse</span> <span class='Operator'>= </span><a href="allpaths.c.html#LN1761"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Delimiter'>; 
</span><a name="LN1765"></a>    <a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>subquery</span> <span class='Operator'>= </span><a href="allpaths.c.html#LN1762"><span class='Ref_to_Parameter'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN954"><span class='Ref_to_Member'>subquery</span></a><span class='Delimiter'>; 
</span><a name="LN1766"></a>    <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>required_outer</span><span class='Delimiter'>; 
</span><a name="LN1767"></a>    <a href="allpaths.c.html#LN49"><span class='Ref_to_Struct'>pushdown_safety_info</span></a> <span class='Declare_Local'>safetyInfo</span><span class='Delimiter'>; 
</span><a name="LN1768"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>tuple_fraction</span><span class='Delimiter'>; 
</span><a name="LN1769"></a>    <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sub_final_rel</span><span class='Delimiter'>; 
</span><a name="LN1770"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Must copy the Query so that planning doesn't mess up the RTE contents 
     * (really really need to fix the planner to not scribble on its input, 
     * someday ... but see remove_unused_subquery_outputs to start with). 
     */ 
</span>    <a href="allpaths.c.html#LN1765"><span class='Ref_To_Local'>subquery</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN618"><span class='Ref_to_Macro'>copyObject</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1765"><span class='Ref_To_Local'>subquery</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If it's a LATERAL subquery, it might contain some Vars of the current 
     * query level, requiring it to be treated as parameterized, even though 
     * we don't support pushing down join quals into subqueries. 
     */ 
</span>    <a href="allpaths.c.html#LN1766"><span class='Ref_To_Local'>required_outer</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN1761"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN549"><span class='Ref_to_Member'>lateral_relids</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Zero out result area for subquery_is_pushdown_safe, so that it can set 
     * flags as needed while recursing.  In particular, we need a workspace 
     * for keeping track of unsafe-to-reference columns.  unsafeColumns[i] 
     * will be set TRUE if we find that output column i of the subquery is 
     * unsafe to use in a pushed-down qual. 
     */ 
</span>    memset<span class='Parentheses'>(</span><span class='Operator'>&</span><a href="allpaths.c.html#LN1767"><span class='Ref_To_Local'>safetyInfo</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1767"><span class='Ref_To_Local'>safetyInfo</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="allpaths.c.html#LN1767"><span class='Ref_To_Local'>safetyInfo</span></a><span class='Operator'>.</span><a href="allpaths.c.html#LN51"><span class='Ref_to_Member'>unsafeColumns</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Parentheses'>) 
</span>        <a href="../../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1765"><span class='Ref_To_Local'>subquery</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a><span class='Parentheses'>) </span><span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>)</span> <span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><span class='Keyword'>bool</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the subquery has the "security_barrier" flag, it means the subquery 
     * originated from a view that must enforce row level security.  Then we 
     * must not push down quals that contain leaky functions.  (Ideally this 
     * would be checked inside subquery_is_pushdown_safe, but since we don't 
     * currently pass the RTE to that function, we must do it here.) 
     */ 
</span>    <a href="allpaths.c.html#LN1767"><span class='Ref_To_Local'>safetyInfo</span></a><span class='Operator'>.</span><a href="allpaths.c.html#LN53"><span class='Ref_to_Member'>unsafeLeaky</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN1762"><span class='Ref_to_Parameter'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN955"><span class='Ref_to_Member'>security_barrier</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If there are any restriction clauses that have been attached to the 
     * subquery relation, consider pushing them down to become WHERE or HAVING 
     * quals of the subquery itself.  This transformation is useful because it 
     * may allow us to generate a better plan for the subquery than evaluating 
     * all the subquery output rows and then filtering them. 
     * 
     * There are several cases where we cannot push down clauses. Restrictions 
     * involving the subquery are checked by subquery_is_pushdown_safe(). 
     * Restrictions on individual clauses are checked by 
     * qual_is_pushdown_safe().  Also, we don't want to push down 
     * pseudoconstant clauses; better to have the gating node above the 
     * subquery. 
     * 
     * Non-pushed-down clauses will get evaluated as qpquals of the 
     * SubqueryScan node. 
     * 
     * XXX Are there any cases where we want to make a policy decision not to 
     * push down a pushable qual, because it'd result in a worse plan? 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN1761"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN583"><span class='Ref_to_Member'>baserestrictinfo</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>&& 
</span>        <a href="allpaths.c.html#LN118"><span class='Ref_to_Proto'>subquery_is_pushdown_safe</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1765"><span class='Ref_To_Local'>subquery</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1765"><span class='Ref_To_Local'>subquery</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="allpaths.c.html#LN1767"><span class='Ref_To_Local'>safetyInfo</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* OK to consider pushing down individual quals */ 
</span><a name="LN1830"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>upperrestrictlist</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN1831"></a>        <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1831"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1761"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN583"><span class='Ref_to_Member'>baserestrictinfo</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1835"></a>            <a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1831"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1836"></a>            <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>clause</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN1835"><span class='Ref_To_Local'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1746"><span class='Ref_to_Member'>clause</span></a><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="allpaths.c.html#LN1835"><span class='Ref_To_Local'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1754"><span class='Ref_to_Member'>pseudoconstant</span></a> <span class='Operator'>&& 
</span>                <a href="allpaths.c.html#LN127"><span class='Ref_to_Proto'>qual_is_pushdown_safe</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1765"><span class='Ref_To_Local'>subquery</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1762"><span class='Ref_to_Parameter'>rti</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1836"><span class='Ref_To_Local'>clause</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="allpaths.c.html#LN1767"><span class='Ref_To_Local'>safetyInfo</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* Push it down */ 
</span>                <a href="allpaths.c.html#LN129"><span class='Ref_to_Proto'>subquery_push_qual</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1765"><span class='Ref_To_Local'>subquery</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1762"><span class='Ref_to_Parameter'>rte</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1762"><span class='Ref_to_Parameter'>rti</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1836"><span class='Ref_To_Local'>clause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* Keep it in the upper query */ 
</span>                <a href="allpaths.c.html#LN1830"><span class='Ref_To_Local'>upperrestrictlist</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1830"><span class='Ref_To_Local'>upperrestrictlist</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1835"><span class='Ref_To_Local'>rinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>        <a href="allpaths.c.html#LN1761"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN583"><span class='Ref_to_Member'>baserestrictinfo</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN1830"><span class='Ref_To_Local'>upperrestrictlist</span></a><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* We don't bother recomputing baserestrict_min_security */ 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if rel-&GT;baserestrictinfo... &raquo; </span> 
 
    <a href="../../../include/common/fe_memutils.h.html#LN37"><span class='Ref_to_Proto'>pfree</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1767"><span class='Ref_To_Local'>safetyInfo</span></a><span class='Operator'>.</span><a href="allpaths.c.html#LN51"><span class='Ref_to_Member'>unsafeColumns</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * The upper query might not use all the subquery's output columns; if 
     * not, we can simplify. 
     */ 
</span>    <a href="allpaths.c.html#LN133"><span class='Ref_to_Proto'>remove_unused_subquery_outputs</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1765"><span class='Ref_To_Local'>subquery</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1761"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We can safely pass the outer tuple_fraction down to the subquery if the 
     * outer level has no joining, aggregation, or sorting to do. Otherwise 
     * we'd better tell the subquery to plan for full retrieval. (XXX This 
     * could probably be made more intelligent ...) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN1764"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN122"><span class='Ref_to_Member'>hasAggs</span></a> <span class='Operator'>|| 
</span>        <a href="allpaths.c.html#LN1764"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a> <span class='Operator'>|| 
</span>        <a href="allpaths.c.html#LN1764"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN147"><span class='Ref_to_Member'>groupingSets</span></a> <span class='Operator'>|| 
</span>        <a href="allpaths.c.html#LN1764"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN149"><span class='Ref_to_Member'>havingQual</span></a> <span class='Operator'>|| 
</span>        <a href="allpaths.c.html#LN1764"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN153"><span class='Ref_to_Member'>distinctClause</span></a> <span class='Operator'>|| 
</span>        <a href="allpaths.c.html#LN1764"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN155"><span class='Ref_to_Member'>sortClause</span></a> <span class='Operator'>|| 
</span>        <a href="allpaths.c.html#LN1727"><span class='Ref_to_Func'>has_multiple_baserels</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1761"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>))</span> 
        <a href="allpaths.c.html#LN1768"><span class='Ref_To_Local'>tuple_fraction</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* default case */ 
</span>    <span class='Control'>else</span> 
        <a href="allpaths.c.html#LN1768"><span class='Ref_To_Local'>tuple_fraction</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN1761"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN290"><span class='Ref_to_Member'>tuple_fraction</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* plan_params should not be in use in current query level */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1761"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN168"><span class='Ref_to_Member'>plan_params</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Generate a subroot and Paths for the subquery */ 
</span>    <a href="allpaths.c.html#LN1761"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN566"><span class='Ref_to_Member'>subroot</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/planner.h.html#LN39"><span class='Ref_to_Proto'>subquery_planner</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1761"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN156"><span class='Ref_to_Member'>glob</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1765"><span class='Ref_To_Local'>subquery</span></a><span class='Delimiter'>, 
</span>                                    <a href="allpaths.c.html#LN1761"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                    <span class='Boolean'>false</span><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1768"><span class='Ref_To_Local'>tuple_fraction</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Isolate the params needed by this specific subplan */ 
</span>    <a href="allpaths.c.html#LN1761"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN567"><span class='Ref_to_Member'>subplan_params</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN1761"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN168"><span class='Ref_to_Member'>plan_params</span></a><span class='Delimiter'>; 
</span>    <a href="allpaths.c.html#LN1761"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN168"><span class='Ref_to_Member'>plan_params</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * It's possible that constraint exclusion proved the subquery empty. If 
     * so, it's desirable to produce an unadorned dummy path so that we will 
     * recognize appropriate optimizations at this query level. 
     */ 
</span>    <a href="allpaths.c.html#LN1769"><span class='Ref_To_Local'>sub_final_rel</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/pathnode.h.html#LN270"><span class='Ref_to_Proto'>fetch_upper_rel</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1761"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN566"><span class='Ref_to_Member'>subroot</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN77"><span class='Ref_to_EnumConst'>UPPERREL_FINAL</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1186"><span class='Ref_to_Macro'>IS_DUMMY_REL</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1769"><span class='Ref_To_Local'>sub_final_rel</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../include/optimizer/paths.h.html#LN51"><span class='Ref_to_Proto'>set_dummy_rel_pathlist</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1761"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Mark rel with estimated output rows, width, etc.  Note that we have to 
     * do this before generating outer-query paths, else cost_subqueryscan is 
     * not happy. 
     */ 
</span>    <a href="../../../include/optimizer/cost.h.html#LN181"><span class='Ref_to_Proto'>set_subquery_size_estimates</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1761"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1761"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * For each Path that subquery_planner produced, make a SubqueryScanPath 
     * in the outer query. 
     */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1770"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1769"><span class='Ref_To_Local'>sub_final_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN538"><span class='Ref_to_Member'>pathlist</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1917"></a>        <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>subpath</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1770"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1918"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>pathkeys</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Convert subpath's pathkeys to outer representation */ 
</span>        <a href="allpaths.c.html#LN1918"><span class='Ref_To_Local'>pathkeys</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/paths.h.html#LN198"><span class='Ref_to_Proto'>convert_subquery_pathkeys</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1761"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                             <a href="allpaths.c.html#LN1761"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, 
</span>                                             <a href="allpaths.c.html#LN1917"><span class='Ref_To_Local'>subpath</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN967"><span class='Ref_to_Member'>pathkeys</span></a><span class='Delimiter'>, 
</span>                            <a href="../../../include/optimizer/tlist.h.html#LN55"><span class='Ref_to_Proto'>make_tlist_from_pathtarget</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1917"><span class='Ref_To_Local'>subpath</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN953"><span class='Ref_to_Member'>pathtarget</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Generate outer path using this subpath */ 
</span>        <a href="../../../include/optimizer/pathnode.h.html#LN27"><span class='Ref_to_Proto'>add_path</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1761"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>                 <a href="../../../include/optimizer/pathnode.h.html#LN89"><span class='Ref_to_Proto'>create_subqueryscan_path</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1761"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1761"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1917"><span class='Ref_To_Local'>subpath</span></a><span class='Delimiter'>, 
</span>                                          <a href="allpaths.c.html#LN1918"><span class='Ref_To_Local'>pathkeys</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1766"><span class='Ref_To_Local'>required_outer</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end set_subquery_pathlist &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * set_function_pathlist 
 *      Build the (single) access path for a function RTE 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1938"></a><span class='Declare_Function'>set_function_pathlist</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, </span><a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rte</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1940"></a>    <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>required_outer</span><span class='Delimiter'>; 
</span><a name="LN1941"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>pathkeys</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We don't support pushing join clauses into the quals of a function 
     * scan, but it could still have required parameterization due to LATERAL 
     * refs in the function expression. 
     */ 
</span>    <a href="allpaths.c.html#LN1940"><span class='Ref_To_Local'>required_outer</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN1938"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN549"><span class='Ref_to_Member'>lateral_relids</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * The result is considered unordered unless ORDINALITY was used, in which 
     * case it is ordered by the ordinal column (the last one).  See if we 
     * care, by checking for uses of that Var in equivalence classes. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN1938"><span class='Ref_to_Parameter'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN986"><span class='Ref_to_Member'>funcordinality</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1957"></a>        <a href="../../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a>  <span class='Declare_Local'>ordattno</span> <span class='Operator'>= </span><a href="allpaths.c.html#LN1938"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN556"><span class='Ref_to_Member'>max_attr</span></a><span class='Delimiter'>; 
</span><a name="LN1958"></a>        <a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>var</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN1959"></a>        <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Is there a Var for it in rel's targetlist?  If not, the query did 
         * not reference the ordinality column, or at least not in any way 
         * that would be interesting for sorting. 
         */ 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1959"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1938"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN535"><span class='Ref_to_Member'>reltarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN882"><span class='Ref_to_Member'>exprs</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1968"></a>            <a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>node</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1959"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* checking varno/varlevelsup is just paranoia */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1968"><span class='Ref_To_Local'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                <a href="allpaths.c.html#LN1968"><span class='Ref_To_Local'>node</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN167"><span class='Ref_to_Member'>varattno</span></a> <span class='Operator'>== </span><a href="allpaths.c.html#LN1957"><span class='Ref_To_Local'>ordattno</span></a> <span class='Operator'>&& 
</span>                <a href="allpaths.c.html#LN1968"><span class='Ref_To_Local'>node</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN165"><span class='Ref_to_Member'>varno</span></a> <span class='Operator'>== </span><a href="allpaths.c.html#LN1938"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a> <span class='Operator'>&& 
</span>                <a href="allpaths.c.html#LN1968"><span class='Ref_To_Local'>node</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN172"><span class='Ref_to_Member'>varlevelsup</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
            <span class='Delimiter'>{ 
</span>                <a href="allpaths.c.html#LN1958"><span class='Ref_To_Local'>var</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN1968"><span class='Ref_To_Local'>node</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Try to build pathkeys for this Var with int8 sorting.  We tell 
         * build_expression_pathkey not to build any new equivalence class; if 
         * the Var isn't already mentioned in some EC, it means that nothing 
         * cares about the ordering. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN1958"><span class='Ref_To_Local'>var</span></a><span class='Parentheses'>) 
</span>            <a href="allpaths.c.html#LN1941"><span class='Ref_To_Local'>pathkeys</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/paths.h.html#LN195"><span class='Ref_to_Proto'>build_expression_pathkey</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1938"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                                <span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN1958"><span class='Ref_To_Local'>var</span></a><span class='Delimiter'>, 
</span>                                                <span class='Null_Value'>NULL</span><span class='Delimiter'>,</span>   <span class='Comment_Single_Line'>/* below outer joins */ 
</span>                                                <a href="../../../include/catalog/pg_operator.h.html#LN180"><span class='Ref_to_Const'>Int8LessOperator</span></a><span class='Delimiter'>, 
</span>                                                <a href="allpaths.c.html#LN1938"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Delimiter'>, 
</span>                                                <span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if rte-&GT;funcordinality &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* Generate appropriate path */ 
</span>    <a href="../../../include/optimizer/pathnode.h.html#LN27"><span class='Ref_to_Proto'>add_path</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1938"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="../../../include/optimizer/pathnode.h.html#LN92"><span class='Ref_to_Proto'>create_functionscan_path</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN1938"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1938"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, 
</span>                                           <a href="allpaths.c.html#LN1941"><span class='Ref_To_Local'>pathkeys</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN1940"><span class='Ref_To_Local'>required_outer</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end set_function_pathlist &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * set_values_pathlist 
 *      Build the (single) access path for a VALUES RTE 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2006"></a><span class='Declare_Function'>set_values_pathlist</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, </span><a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rte</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2008"></a>    <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>required_outer</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We don't support pushing join clauses into the quals of a values scan, 
     * but it could still have required parameterization due to LATERAL refs 
     * in the values expressions. 
     */ 
</span>    <a href="allpaths.c.html#LN2008"><span class='Ref_To_Local'>required_outer</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN2006"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN549"><span class='Ref_to_Member'>lateral_relids</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Generate appropriate path */ 
</span>    <a href="../../../include/optimizer/pathnode.h.html#LN27"><span class='Ref_to_Proto'>add_path</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2006"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="../../../include/optimizer/pathnode.h.html#LN96"><span class='Ref_to_Proto'>create_valuesscan_path</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2006"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2006"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2008"><span class='Ref_To_Local'>required_outer</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * set_tablefunc_pathlist 
 *      Build the (single) access path for a table func RTE 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2026"></a><span class='Declare_Function'>set_tablefunc_pathlist</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, </span><a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rte</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2028"></a>    <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>required_outer</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We don't support pushing join clauses into the quals of a tablefunc 
     * scan, but it could still have required parameterization due to LATERAL 
     * refs in the function expression. 
     */ 
</span>    <a href="allpaths.c.html#LN2028"><span class='Ref_To_Local'>required_outer</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN2026"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN549"><span class='Ref_to_Member'>lateral_relids</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Generate appropriate path */ 
</span>    <a href="../../../include/optimizer/pathnode.h.html#LN27"><span class='Ref_to_Proto'>add_path</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2026"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="../../../include/optimizer/pathnode.h.html#LN98"><span class='Ref_to_Proto'>create_tablefuncscan_path</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2026"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2026"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, 
</span>                                            <a href="allpaths.c.html#LN2028"><span class='Ref_To_Local'>required_outer</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * set_cte_pathlist 
 *      Build the (single) access path for a non-self-reference CTE RTE 
 * 
 * There's no need for a separate set_cte_size phase, since we don't 
 * support join-qual-parameterized paths for CTEs. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2050"></a><span class='Declare_Function'>set_cte_pathlist</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, </span><a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rte</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2052"></a>    <a href="../../../include/nodes/plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>cteplan</span><span class='Delimiter'>; 
</span><a name="LN2053"></a>    <a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>cteroot</span><span class='Delimiter'>; 
</span><a name="LN2054"></a>    <a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Local'>levelsup</span><span class='Delimiter'>; 
</span><a name="LN2055"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>ndx</span><span class='Delimiter'>; 
</span><a name="LN2056"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span><a name="LN2057"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>plan_id</span><span class='Delimiter'>; 
</span><a name="LN2058"></a>    <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>required_outer</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Find the referenced CTE, and locate the plan previously made for it. 
     */ 
</span>    <a href="allpaths.c.html#LN2054"><span class='Ref_To_Local'>levelsup</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN2050"><span class='Ref_to_Parameter'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1002"><span class='Ref_to_Member'>ctelevelsup</span></a><span class='Delimiter'>; 
</span>    <a href="allpaths.c.html#LN2053"><span class='Ref_To_Local'>cteroot</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN2050"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN2054"><span class='Ref_To_Local'>levelsup</span></a><span class='Operator'>-- &GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="allpaths.c.html#LN2053"><span class='Ref_To_Local'>cteroot</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN2053"><span class='Ref_To_Local'>cteroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN160"><span class='Ref_to_Member'>parent_root</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="allpaths.c.html#LN2053"><span class='Ref_To_Local'>cteroot</span></a><span class='Parentheses'>)</span>           <span class='Comment_Single_Line'>/* shouldn't happen */ 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"bad levelsup for CTE \"%s\""</span><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2050"><span class='Ref_to_Parameter'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1001"><span class='Ref_to_Member'>ctename</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Note: cte_plan_ids can be shorter than cteList, if we are still working 
     * on planning the CTEs (ie, this is a side-reference from another CTE). 
     * So we mustn't use forboth here. 
     */ 
</span>    <a href="allpaths.c.html#LN2055"><span class='Ref_To_Local'>ndx</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2056"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2053"><span class='Ref_To_Local'>cteroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN132"><span class='Ref_to_Member'>cteList</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2080"></a>        <a href="../../../include/nodes/parsenodes.h.html#LN1339"><span class='Ref_to_Struct'>CommonTableExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>cte</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN1339"><span class='Ref_to_Struct'>CommonTableExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2056"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span>strcmp<span class='Parentheses'>(</span><a href="allpaths.c.html#LN2080"><span class='Ref_To_Local'>cte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1342"><span class='Ref_to_Member'>ctename</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2050"><span class='Ref_to_Parameter'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1001"><span class='Ref_to_Member'>ctename</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <a href="allpaths.c.html#LN2055"><span class='Ref_To_Local'>ndx</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN2056"><span class='Ref_To_Local'>lc</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span>             <span class='Comment_Single_Line'>/* shouldn't happen */ 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"could not find CTE \"%s\""</span><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2050"><span class='Ref_to_Parameter'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1001"><span class='Ref_to_Member'>ctename</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN2055"><span class='Ref_To_Local'>ndx</span></a> <span class='Operator'>&GT;= </span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2053"><span class='Ref_To_Local'>cteroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN229"><span class='Ref_to_Member'>cte_plan_ids</span></a><span class='Parentheses'>))</span> 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"could not find plan for CTE \"%s\""</span><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2050"><span class='Ref_to_Parameter'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1001"><span class='Ref_to_Member'>ctename</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="allpaths.c.html#LN2057"><span class='Ref_To_Local'>plan_id</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN224"><span class='Ref_to_Proto'>list_nth_int</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2053"><span class='Ref_To_Local'>cteroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN229"><span class='Ref_to_Member'>cte_plan_ids</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2055"><span class='Ref_To_Local'>ndx</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2057"><span class='Ref_To_Local'>plan_id</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="allpaths.c.html#LN2052"><span class='Ref_To_Local'>cteplan</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN223"><span class='Ref_to_Proto'>list_nth</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2050"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN156"><span class='Ref_to_Member'>glob</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN97"><span class='Ref_to_Member'>subplans</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2057"><span class='Ref_To_Local'>plan_id</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Mark rel with estimated output rows, width, etc */ 
</span>    <a href="../../../include/optimizer/cost.h.html#LN184"><span class='Ref_to_Proto'>set_cte_size_estimates</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2050"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2050"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2052"><span class='Ref_To_Local'>cteplan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN130"><span class='Ref_to_Member'>plan_rows</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We don't support pushing join clauses into the quals of a CTE scan, but 
     * it could still have required parameterization due to LATERAL refs in 
     * its tlist. 
     */ 
</span>    <a href="allpaths.c.html#LN2058"><span class='Ref_To_Local'>required_outer</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN2050"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN549"><span class='Ref_to_Member'>lateral_relids</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Generate appropriate path */ 
</span>    <a href="../../../include/optimizer/pathnode.h.html#LN27"><span class='Ref_to_Proto'>add_path</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2050"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="../../../include/optimizer/pathnode.h.html#LN100"><span class='Ref_to_Proto'>create_ctescan_path</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2050"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2050"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2058"><span class='Ref_To_Local'>required_outer</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end set_cte_pathlist &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * set_namedtuplestore_pathlist 
 *      Build the (single) access path for a named tuplestore RTE 
 * 
 * There's no need for a separate set_namedtuplestore_size phase, since we 
 * don't support join-qual-parameterized paths for tuplestores. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2116"></a><span class='Declare_Function'>set_namedtuplestore_pathlist</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, 
</span><a name="LN2117"></a>                             <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rte</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2119"></a>    <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>required_outer</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Mark rel with estimated output rows, width, etc */ 
</span>    <a href="../../../include/optimizer/cost.h.html#LN187"><span class='Ref_to_Proto'>set_namedtuplestore_size_estimates</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2116"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2116"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We don't support pushing join clauses into the quals of a tuplestore 
     * scan, but it could still have required parameterization due to LATERAL 
     * refs in its tlist. 
     */ 
</span>    <a href="allpaths.c.html#LN2119"><span class='Ref_To_Local'>required_outer</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN2116"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN549"><span class='Ref_to_Member'>lateral_relids</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Generate appropriate path */ 
</span>    <a href="../../../include/optimizer/pathnode.h.html#LN27"><span class='Ref_to_Proto'>add_path</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2116"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="../../../include/optimizer/pathnode.h.html#LN102"><span class='Ref_to_Proto'>create_namedtuplestorescan_path</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2116"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2116"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2119"><span class='Ref_To_Local'>required_outer</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Select cheapest path (pretty easy in this case...) */ 
</span>    <a href="../../../include/optimizer/pathnode.h.html#LN26"><span class='Ref_to_Proto'>set_cheapest</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2116"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end set_namedtuplestore_pathlist &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * set_worktable_pathlist 
 *      Build the (single) access path for a self-reference CTE RTE 
 * 
 * There's no need for a separate set_worktable_size phase, since we don't 
 * support join-qual-parameterized paths for CTEs. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2146"></a><span class='Declare_Function'>set_worktable_pathlist</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, </span><a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rte</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2148"></a>    <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>ctepath</span><span class='Delimiter'>; 
</span><a name="LN2149"></a>    <a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>cteroot</span><span class='Delimiter'>; 
</span><a name="LN2150"></a>    <a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Local'>levelsup</span><span class='Delimiter'>; 
</span><a name="LN2151"></a>    <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>required_outer</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We need to find the non-recursive term's path, which is in the plan 
     * level that's processing the recursive UNION, which is one level *below* 
     * where the CTE comes from. 
     */ 
</span>    <a href="allpaths.c.html#LN2150"><span class='Ref_To_Local'>levelsup</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN2146"><span class='Ref_to_Parameter'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1002"><span class='Ref_to_Member'>ctelevelsup</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN2150"><span class='Ref_To_Local'>levelsup</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span>          <span class='Comment_Single_Line'>/* shouldn't happen */ 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"bad levelsup for CTE \"%s\""</span><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2146"><span class='Ref_to_Parameter'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1001"><span class='Ref_to_Member'>ctename</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="allpaths.c.html#LN2150"><span class='Ref_To_Local'>levelsup</span></a><span class='Operator'>--</span><span class='Delimiter'>; 
</span>    <a href="allpaths.c.html#LN2149"><span class='Ref_To_Local'>cteroot</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN2146"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN2150"><span class='Ref_To_Local'>levelsup</span></a><span class='Operator'>-- &GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="allpaths.c.html#LN2149"><span class='Ref_To_Local'>cteroot</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN2149"><span class='Ref_To_Local'>cteroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN160"><span class='Ref_to_Member'>parent_root</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="allpaths.c.html#LN2149"><span class='Ref_To_Local'>cteroot</span></a><span class='Parentheses'>)</span>           <span class='Comment_Single_Line'>/* shouldn't happen */ 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"bad levelsup for CTE \"%s\""</span><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2146"><span class='Ref_to_Parameter'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1001"><span class='Ref_to_Member'>ctename</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="allpaths.c.html#LN2148"><span class='Ref_To_Local'>ctepath</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN2149"><span class='Ref_To_Local'>cteroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN308"><span class='Ref_to_Member'>non_recursive_path</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="allpaths.c.html#LN2148"><span class='Ref_To_Local'>ctepath</span></a><span class='Parentheses'>)</span>               <span class='Comment_Single_Line'>/* shouldn't happen */ 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"could not find path for CTE \"%s\""</span><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2146"><span class='Ref_to_Parameter'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1001"><span class='Ref_to_Member'>ctename</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Mark rel with estimated output rows, width, etc */ 
</span>    <a href="../../../include/optimizer/cost.h.html#LN184"><span class='Ref_to_Proto'>set_cte_size_estimates</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2146"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2146"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2148"><span class='Ref_To_Local'>ctepath</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We don't support pushing join clauses into the quals of a worktable 
     * scan, but it could still have required parameterization due to LATERAL 
     * refs in its tlist.  (I'm not sure this is actually possible given the 
     * restrictions on recursive references, but it's easy enough to support.) 
     */ 
</span>    <a href="allpaths.c.html#LN2151"><span class='Ref_To_Local'>required_outer</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN2146"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN549"><span class='Ref_to_Member'>lateral_relids</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Generate appropriate path */ 
</span>    <a href="../../../include/optimizer/pathnode.h.html#LN27"><span class='Ref_to_Proto'>add_path</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2146"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="../../../include/optimizer/pathnode.h.html#LN104"><span class='Ref_to_Proto'>create_worktablescan_path</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2146"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2146"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2151"><span class='Ref_To_Local'>required_outer</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end set_worktable_pathlist &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * generate_gather_paths 
 *      Generate parallel access paths for a relation by pushing a Gather or 
 *      Gather Merge on top of a partial path. 
 * 
 * This must not be called until after we're done creating all partial paths 
 * for the specified relation.  (Otherwise, add_partial_path might delete a 
 * path that some GatherPath or GatherMergePath has a reference to.) 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN2198"></a><span class='Declare_Function'>generate_gather_paths</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2200"></a>    <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>cheapest_partial_path</span><span class='Delimiter'>; 
</span><a name="LN2201"></a>    <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>simple_gather_path</span><span class='Delimiter'>; 
</span><a name="LN2202"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* If there are no partial paths, there's nothing to do here. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN2198"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN540"><span class='Ref_to_Member'>partial_pathlist</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * The output of Gather is always unsorted, so there's only one partial 
     * path of interest: the cheapest one.  That will be the one at the front 
     * of partial_pathlist because of the way add_partial_path works. 
     */ 
</span>    <a href="allpaths.c.html#LN2200"><span class='Ref_To_Local'>cheapest_partial_path</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2198"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN540"><span class='Ref_to_Member'>partial_pathlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="allpaths.c.html#LN2201"><span class='Ref_To_Local'>simple_gather_path</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>        <a href="../../../include/optimizer/pathnode.h.html#LN79"><span class='Ref_to_Proto'>create_gather_path</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2198"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2198"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2200"><span class='Ref_To_Local'>cheapest_partial_path</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2198"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN535"><span class='Ref_to_Member'>reltarget</span></a><span class='Delimiter'>, 
</span>                           <span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/optimizer/pathnode.h.html#LN27"><span class='Ref_to_Proto'>add_path</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2198"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2201"><span class='Ref_To_Local'>simple_gather_path</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * For each useful ordering, we can consider an order-preserving Gather 
     * Merge. 
     */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2202"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2198"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN540"><span class='Ref_to_Member'>partial_pathlist</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2225"></a>        <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>subpath</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2202"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2226"></a>        <a href="../../../include/nodes/relation.h.html#LN1274"><span class='Ref_to_Struct'>GatherMergePath</span></a> <span class='Operator'>*</span><span class='Declare_Local'>path</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN2225"><span class='Ref_To_Local'>subpath</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN967"><span class='Ref_to_Member'>pathkeys</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <a href="allpaths.c.html#LN2226"><span class='Ref_To_Local'>path</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/pathnode.h.html#LN82"><span class='Ref_to_Proto'>create_gather_merge_path</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2198"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2198"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2225"><span class='Ref_To_Local'>subpath</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2198"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN535"><span class='Ref_to_Member'>reltarget</span></a><span class='Delimiter'>, 
</span>                                        <a href="allpaths.c.html#LN2225"><span class='Ref_To_Local'>subpath</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN967"><span class='Ref_to_Member'>pathkeys</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/optimizer/pathnode.h.html#LN27"><span class='Ref_to_Proto'>add_path</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2198"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="allpaths.c.html#LN2226"><span class='Ref_To_Local'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1276"><span class='Ref_to_Member'>path</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end generate_gather_paths &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * make_rel_from_joinlist 
 *    Build access paths using a "joinlist" to guide the join path search. 
 * 
 * See comments for deconstruct_jointree() for definition of the joinlist 
 * data structure. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>* 
</span><a name="LN2245"></a><span class='Declare_Function'>make_rel_from_joinlist</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>joinlist</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2247"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>levels_needed</span><span class='Delimiter'>; 
</span><a name="LN2248"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>initial_rels</span><span class='Delimiter'>; 
</span><a name="LN2249"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>jl</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Count the number of child joinlist nodes.  This is the depth of the 
     * dynamic-programming algorithm we must employ to consider all ways of 
     * joining the child nodes. 
     */ 
</span>    <a href="allpaths.c.html#LN2247"><span class='Ref_To_Local'>levels_needed</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2245"><span class='Ref_to_Parameter'>joinlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN2247"><span class='Ref_To_Local'>levels_needed</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* nothing to do? */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Construct a list of rels corresponding to the child joinlist nodes. 
     * This may contain both base rels and rels constructed according to 
     * sub-joinlists. 
     */ 
</span>    <a href="allpaths.c.html#LN2248"><span class='Ref_To_Local'>initial_rels</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2249"><span class='Ref_To_Local'>jl</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2245"><span class='Ref_to_Parameter'>joinlist</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2269"></a>        <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>jlnode</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2249"><span class='Ref_To_Local'>jl</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2270"></a>        <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>thisrel</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2269"><span class='Ref_To_Local'>jlnode</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN1415"><span class='Ref_to_Struct'>RangeTblRef</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN2274"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>varno</span> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN1415"><span class='Ref_to_Struct'>RangeTblRef</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN2269"><span class='Ref_To_Local'>jlnode</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>rtindex<span class='Delimiter'>; 
</span> 
            <a href="allpaths.c.html#LN2270"><span class='Ref_To_Local'>thisrel</span></a> <span class='Operator'>= </span><a href="../util/relnode.c.html#LN241"><span class='Ref_to_Func'>find_base_rel</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2245"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2274"><span class='Ref_To_Local'>varno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2269"><span class='Ref_To_Local'>jlnode</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Recurse to handle subproblem */ 
</span>            <a href="allpaths.c.html#LN2270"><span class='Ref_To_Local'>thisrel</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN117"><span class='Ref_to_Proto'>make_rel_from_joinlist</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2245"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN2269"><span class='Ref_To_Local'>jlnode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized joinlist node type: %d"</span><span class='Delimiter'>, 
</span>                 <span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="../../../include/nodes/nodes.h.html#LN513"><span class='Ref_to_Macro'>nodeTag</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2269"><span class='Ref_To_Local'>jlnode</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="allpaths.c.html#LN2270"><span class='Ref_To_Local'>thisrel</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* keep compiler quiet */ 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="allpaths.c.html#LN2248"><span class='Ref_To_Local'>initial_rels</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2248"><span class='Ref_To_Local'>initial_rels</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2270"><span class='Ref_To_Local'>thisrel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN2247"><span class='Ref_To_Local'>levels_needed</span></a> <span class='Operator'>== </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Single joinlist node, so we're done. 
         */ 
</span>        <span class='Control'>return</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2248"><span class='Ref_To_Local'>initial_rels</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Consider the different orders in which we could join the rels, 
         * using a plugin, GEQO, or the regular join search code. 
         * 
         * We put the initial_rels list into a PlannerInfo field because 
         * has_legal_joinclause() needs to look at it (ugly :-(). 
         */ 
</span>        <a href="allpaths.c.html#LN2245"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN268"><span class='Ref_to_Member'>initial_rels</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN2248"><span class='Ref_To_Local'>initial_rels</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN66"><span class='Ref_to_Global_Var'>join_search_hook</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="allpaths.c.html#LN66"><span class='Ref_to_Global_Var'>join_search_hook</span></a><span class='Parentheses'>) (</span><a href="allpaths.c.html#LN2245"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2247"><span class='Ref_To_Local'>levels_needed</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2248"><span class='Ref_To_Local'>initial_rels</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN57"><span class='Ref_to_Global_Var'>enable_geqo</span></a> <span class='Operator'>&& </span><a href="allpaths.c.html#LN2247"><span class='Ref_To_Local'>levels_needed</span></a> <span class='Operator'>&GT;= </span><a href="allpaths.c.html#LN58"><span class='Ref_to_Global_Var'>geqo_threshold</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <a href="../geqo/geqo_main.c.html#LN65"><span class='Ref_to_Func'>geqo</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2245"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2247"><span class='Ref_To_Local'>levels_needed</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2248"><span class='Ref_To_Local'>initial_rels</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <span class='Control'>return</span> <a href="../../../include/optimizer/paths.h.html#LN52"><span class='Ref_to_Proto'>standard_join_search</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2245"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2247"><span class='Ref_To_Local'>levels_needed</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2248"><span class='Ref_To_Local'>initial_rels</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end make_rel_from_joinlist &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * standard_join_search 
 *    Find possible joinpaths for a query by successively finding ways 
 *    to join component relations into join relations. 
 * 
 * 'levels_needed' is the number of iterations needed, ie, the number of 
 *      independent jointree items in the query.  This is &GT; 1. 
 * 
 * 'initial_rels' is a list of RelOptInfo nodes for each independent 
 *      jointree item.  These are the components to be joined together. 
 *      Note that levels_needed == list_length(initial_rels). 
 * 
 * Returns the final level of join relations, i.e., the relation that is 
 * the result of joining all the original relations together. 
 * At least one implementation path must be provided for this relation and 
 * all required sub-relations. 
 * 
 * To support loadable plugins that modify planner behavior by changing the 
 * join searching algorithm, we provide a hook variable that lets a plugin 
 * replace or supplement this function.  Any such hook must return the same 
 * final join relation as the standard code would, but it might have a 
 * different set of implementation paths attached, and only the sub-joinrels 
 * needed for these paths need have been instantiated. 
 * 
 * Note to plugin authors: the functions invoked during standard_join_search() 
 * modify root-&GT;join_rel_list and root-&GT;join_rel_hash.  If you want to do more 
 * than one join-order search, you'll probably need to save and restore the 
 * original states of those data structures.  See geqo_eval() for an example. 
 */ 
</span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>* 
</span><a name="LN2350"></a><span class='Declare_Function'>standard_join_search</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>levels_needed</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>initial_rels</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2352"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>lev</span><span class='Delimiter'>; 
</span><a name="LN2353"></a>    <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rel</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * This function cannot be invoked recursively within any one planning 
     * problem, so join_rel_level[] can't be in use already. 
     */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2350"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN224"><span class='Ref_to_Member'>join_rel_level</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We employ a simple "dynamic programming" algorithm: we first find all 
     * ways to build joins of two jointree items, then all ways to build joins 
     * of three items (from two-item joins and single items), then four-item 
     * joins, and so on until we have considered all ways to join all the 
     * items into one rel. 
     * 
     * root-&GT;join_rel_level[j] is a list of all the j-item rels.  Initially we 
     * set root-&GT;join_rel_level[1] to represent all the single-jointree-item 
     * relations. 
     */ 
</span>    <a href="allpaths.c.html#LN2350"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN224"><span class='Ref_to_Member'>join_rel_level</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN34"><span class='Ref_to_Proto'>palloc0</span></a><span class='Parentheses'>((</span><a href="allpaths.c.html#LN2350"><span class='Ref_to_Parameter'>levels_needed</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>) </span><span class='Operator'>* </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="allpaths.c.html#LN2350"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN224"><span class='Ref_to_Member'>join_rel_level</span></a><span class='Delimiter'>[</span><span class='Number'>1</span><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="allpaths.c.html#LN2350"><span class='Ref_to_Parameter'>initial_rels</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN2352"><span class='Ref_To_Local'>lev</span></a> <span class='Operator'>= </span><span class='Number'>2</span><span class='Delimiter'>; </span><a href="allpaths.c.html#LN2352"><span class='Ref_To_Local'>lev</span></a> <span class='Operator'>&LT;= </span><a href="allpaths.c.html#LN2350"><span class='Ref_to_Parameter'>levels_needed</span></a><span class='Delimiter'>; </span><a href="allpaths.c.html#LN2352"><span class='Ref_To_Local'>lev</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2378"></a>        <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Determine all possible pairs of relations to be joined at this 
         * level, and build paths for making each one from every available 
         * pair of lower-level relations. 
         */ 
</span>        <a href="joinrels.c.html#LN52"><span class='Ref_to_Func'>join_search_one_level</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2350"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2352"><span class='Ref_To_Local'>lev</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Run generate_gather_paths() for each just-processed joinrel.  We 
         * could not do this earlier because both regular and partial paths 
         * can get added to a particular joinrel at multiple times within 
         * join_search_one_level.  After that, we're done creating paths for 
         * the joinrel, so run set_cheapest(). 
         */ 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2378"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2350"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN224"><span class='Ref_to_Member'>join_rel_level</span></a><span class='Delimiter'>[</span><a href="allpaths.c.html#LN2352"><span class='Ref_To_Local'>lev</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="allpaths.c.html#LN2353"><span class='Ref_To_Local'>rel</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2378"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Create GatherPaths for any useful partial paths for rel */ 
</span>            <a href="../../../include/optimizer/paths.h.html#LN55"><span class='Ref_to_Proto'>generate_gather_paths</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2350"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2353"><span class='Ref_To_Local'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Find and save the cheapest paths for this rel */ 
</span>            <a href="../../../include/optimizer/pathnode.h.html#LN26"><span class='Ref_to_Proto'>set_cheapest</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2353"><span class='Ref_To_Local'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
<span class='Directive'>#ifdef</span> OPTIMIZER_DEBUG 
            <a href="../../../include/optimizer/paths.h.html#LN62"><span class='Ref_to_Proto'>debug_print_rel</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2350"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2353"><span class='Ref_To_Local'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for lev=2;lev&LT;=levels_nee... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * We should have a single rel at the final level. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN2350"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN224"><span class='Ref_to_Member'>join_rel_level</span></a><span class='Delimiter'>[</span><a href="allpaths.c.html#LN2350"><span class='Ref_to_Parameter'>levels_needed</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"failed to build any %d-way joins"</span><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2350"><span class='Ref_to_Parameter'>levels_needed</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2350"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN224"><span class='Ref_to_Member'>join_rel_level</span></a><span class='Delimiter'>[</span><a href="allpaths.c.html#LN2350"><span class='Ref_to_Parameter'>levels_needed</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="allpaths.c.html#LN2353"><span class='Ref_To_Local'>rel</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2350"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN224"><span class='Ref_to_Member'>join_rel_level</span></a><span class='Delimiter'>[</span><a href="allpaths.c.html#LN2350"><span class='Ref_to_Parameter'>levels_needed</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="allpaths.c.html#LN2350"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN224"><span class='Ref_to_Member'>join_rel_level</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="allpaths.c.html#LN2353"><span class='Ref_To_Local'>rel</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end standard_join_search &raquo; </span> 
 
<span class='Comment_Multi_Line'>/***************************************************************************** 
 *          PUSHING QUALS DOWN INTO SUBQUERIES 
 *****************************************************************************/ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * subquery_is_pushdown_safe - is a subquery safe for pushing down quals? 
 * 
 * subquery is the particular component query being checked.  topquery 
 * is the top component of a set-operations tree (the same Query if no 
 * set-op is involved). 
 * 
 * Conditions checked here: 
 * 
 * 1. If the subquery has a LIMIT clause, we must not push down any quals, 
 * since that could change the set of rows returned. 
 * 
 * 2. If the subquery contains EXCEPT or EXCEPT ALL set ops we cannot push 
 * quals into it, because that could change the results. 
 * 
 * 3. If the subquery uses DISTINCT, we cannot push volatile quals into it. 
 * This is because upper-level quals should semantically be evaluated only 
 * once per distinct row, not once per original row, and if the qual is 
 * volatile then extra evaluations could change the results.  (This issue 
 * does not apply to other forms of aggregation such as GROUP BY, because 
 * when those are present we push into HAVING not WHERE, so that the quals 
 * are still applied after aggregation.) 
 * 
 * 4. If the subquery contains window functions, we cannot push volatile quals 
 * into it.  The issue here is a bit different from DISTINCT: a volatile qual 
 * might succeed for some rows of a window partition and fail for others, 
 * thereby changing the partition contents and thus the window functions' 
 * results for rows that remain. 
 * 
 * 5. If the subquery contains any set-returning functions in its targetlist, 
 * we cannot push volatile quals into it.  That would push them below the SRFs 
 * and thereby change the number of times they are evaluated.  Also, a 
 * volatile qual could succeed for some SRF output rows and fail for others, 
 * a behavior that cannot occur if it's evaluated before SRF expansion. 
 * 
 * In addition, we make several checks on the subquery's output columns to see 
 * if it is safe to reference them in pushed-down quals.  If output column k 
 * is found to be unsafe to reference, we set safetyInfo-&GT;unsafeColumns[k] 
 * to TRUE, but we don't reject the subquery overall since column k might not 
 * be referenced by some/all quals.  The unsafeColumns[] array will be 
 * consulted later by qual_is_pushdown_safe().  It's better to do it this way 
 * than to make the checks directly in qual_is_pushdown_safe(), because when 
 * the subquery involves set operations we have to check the output 
 * expressions in each arm of the set op. 
 * 
 * Note: pushing quals into a DISTINCT subquery is theoretically dubious: 
 * we're effectively assuming that the quals cannot distinguish values that 
 * the DISTINCT's equality operator sees as equal, yet there are many 
 * counterexamples to that assumption.  However use of such a qual with a 
 * DISTINCT subquery would be unsafe anyway, since there's no guarantee which 
 * "equal" value will be chosen as the output value by the DISTINCT operation. 
 * So we don't worry too much about that.  Another objection is that if the 
 * qual is expensive to evaluate, running it for each original row might cost 
 * more than we save by eliminating rows before the DISTINCT step.  But it 
 * would be very hard to estimate that at this stage, and in practice pushdown 
 * seldom seems to make things worse, so we ignore that problem too. 
 * 
 * Note: likewise, pushing quals into a subquery with window functions is a 
 * bit dubious: the quals might remove some rows of a window partition while 
 * leaving others, causing changes in the window functions' results for the 
 * surviving rows.  We insist that such a qual reference only partitioning 
 * columns, but again that only protects us if the qual does not distinguish 
 * values that the partitioning equality operator sees as equal.  The risks 
 * here are perhaps larger than for DISTINCT, since no de-duplication of rows 
 * occurs and thus there is no theoretical problem with such a qual.  But 
 * we'll do this anyway because the potential performance benefits are very 
 * large, and we've seen no field complaints about the longstanding comparable 
 * behavior with DISTINCT. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN2498"></a><span class='Declare_Function'>subquery_is_pushdown_safe</span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>subquery</span><span class='Delimiter'>, </span><a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>topquery</span><span class='Delimiter'>, 
</span><a name="LN2499"></a>                          <a href="allpaths.c.html#LN49"><span class='Ref_to_Struct'>pushdown_safety_info</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>safetyInfo</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2501"></a>    <a href="../../../include/nodes/parsenodes.h.html#LN1545"><span class='Ref_to_Struct'>SetOperationStmt</span></a> <span class='Operator'>*</span><span class='Declare_Local'>topop</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Check point 1 */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN2498"><span class='Ref_to_Parameter'>subquery</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN157"><span class='Ref_to_Member'>limitOffset</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL </span><span class='Operator'>|| </span><a href="allpaths.c.html#LN2498"><span class='Ref_to_Parameter'>subquery</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN158"><span class='Ref_to_Member'>limitCount</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Check points 3, 4, and 5 */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN2498"><span class='Ref_to_Parameter'>subquery</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN153"><span class='Ref_to_Member'>distinctClause</span></a> <span class='Operator'>|| 
</span>        <a href="allpaths.c.html#LN2498"><span class='Ref_to_Parameter'>subquery</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN123"><span class='Ref_to_Member'>hasWindowFuncs</span></a> <span class='Operator'>|| 
</span>        <a href="allpaths.c.html#LN2498"><span class='Ref_to_Parameter'>subquery</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN124"><span class='Ref_to_Member'>hasTargetSRFs</span></a><span class='Parentheses'>) 
</span>        <a href="allpaths.c.html#LN2499"><span class='Ref_to_Parameter'>safetyInfo</span></a><span class='Operator'>-&GT;</span><a href="allpaths.c.html#LN52"><span class='Ref_to_Member'>unsafeVolatile</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we're at a leaf query, check for unsafe expressions in its target 
     * list, and mark any unsafe ones in unsafeColumns[].  (Non-leaf nodes in 
     * setop trees have only simple Vars in their tlists, so no need to check 
     * them.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN2498"><span class='Ref_to_Parameter'>subquery</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN162"><span class='Ref_to_Member'>setOperations</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="allpaths.c.html#LN122"><span class='Ref_to_Proto'>check_output_expressions</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2498"><span class='Ref_to_Parameter'>subquery</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2499"><span class='Ref_to_Parameter'>safetyInfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Are we at top level, or looking at a setop component? */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN2498"><span class='Ref_to_Parameter'>subquery</span></a> <span class='Operator'>== </span><a href="allpaths.c.html#LN2498"><span class='Ref_to_Parameter'>topquery</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Top level, so check any component queries */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN2498"><span class='Ref_to_Parameter'>subquery</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN162"><span class='Ref_to_Member'>setOperations</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="allpaths.c.html#LN120"><span class='Ref_to_Proto'>recurse_pushdown_safe</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2498"><span class='Ref_to_Parameter'>subquery</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN162"><span class='Ref_to_Member'>setOperations</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2498"><span class='Ref_to_Parameter'>topquery</span></a><span class='Delimiter'>, 
</span>                                       <a href="allpaths.c.html#LN2499"><span class='Ref_to_Parameter'>safetyInfo</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Setop component must not have more components (too weird) */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN2498"><span class='Ref_to_Parameter'>subquery</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN162"><span class='Ref_to_Member'>setOperations</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* Check whether setop component output types match top level */ 
</span>        <a href="allpaths.c.html#LN2501"><span class='Ref_To_Local'>topop</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN575"><span class='Ref_to_Macro'>castNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN1545"><span class='Ref_to_Struct'>SetOperationStmt</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2498"><span class='Ref_to_Parameter'>topquery</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN162"><span class='Ref_to_Member'>setOperations</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2501"><span class='Ref_To_Local'>topop</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="allpaths.c.html#LN124"><span class='Ref_to_Proto'>compare_tlist_datatypes</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2498"><span class='Ref_to_Parameter'>subquery</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a><span class='Delimiter'>, 
</span>                                <a href="allpaths.c.html#LN2501"><span class='Ref_To_Local'>topop</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1555"><span class='Ref_to_Member'>colTypes</span></a><span class='Delimiter'>, 
</span>                                <a href="allpaths.c.html#LN2499"><span class='Ref_to_Parameter'>safetyInfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end subquery_is_pushdown_safe &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Helper routine to recurse through setOperations tree 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN2550"></a><span class='Declare_Function'>recurse_pushdown_safe</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>setOp</span><span class='Delimiter'>, </span><a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>topquery</span><span class='Delimiter'>, 
</span><a name="LN2551"></a>                      <a href="allpaths.c.html#LN49"><span class='Ref_to_Struct'>pushdown_safety_info</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>safetyInfo</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2550"><span class='Ref_to_Parameter'>setOp</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN1415"><span class='Ref_to_Struct'>RangeTblRef</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN2555"></a>        <a href="../../../include/nodes/primnodes.h.html#LN1415"><span class='Ref_to_Struct'>RangeTblRef</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rtr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1415"><span class='Ref_to_Struct'>RangeTblRef</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN2550"><span class='Ref_to_Parameter'>setOp</span></a><span class='Delimiter'>; 
</span><a name="LN2556"></a>        <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span> <span class='Operator'>= </span><a href="../../../include/parser/parsetree.h.html#LN30"><span class='Ref_to_Macro'>rt_fetch</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2555"><span class='Ref_To_Local'>rtr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1418"><span class='Ref_to_Member'>rtindex</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2550"><span class='Ref_to_Parameter'>topquery</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN134"><span class='Ref_to_Member'>rtable</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2557"></a>        <a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>subquery</span> <span class='Operator'>= </span><a href="allpaths.c.html#LN2556"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN954"><span class='Ref_to_Member'>subquery</span></a><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2557"><span class='Ref_To_Local'>subquery</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <a href="allpaths.c.html#LN118"><span class='Ref_to_Proto'>subquery_is_pushdown_safe</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2557"><span class='Ref_To_Local'>subquery</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2550"><span class='Ref_to_Parameter'>topquery</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2551"><span class='Ref_to_Parameter'>safetyInfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2550"><span class='Ref_to_Parameter'>setOp</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/parsenodes.h.html#LN1545"><span class='Ref_to_Struct'>SetOperationStmt</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN2564"></a>        <a href="../../../include/nodes/parsenodes.h.html#LN1545"><span class='Ref_to_Struct'>SetOperationStmt</span></a> <span class='Operator'>*</span><span class='Declare_Local'>op</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN1545"><span class='Ref_to_Struct'>SetOperationStmt</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN2550"><span class='Ref_to_Parameter'>setOp</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* EXCEPT is no good (point 2 for subquery_is_pushdown_safe) */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN2564"><span class='Ref_To_Local'>op</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1548"><span class='Ref_to_Member'>op</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/parsenodes.h.html#LN1475"><span class='Ref_to_EnumConst'>SETOP_EXCEPT</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* Else recurse */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="allpaths.c.html#LN120"><span class='Ref_to_Proto'>recurse_pushdown_safe</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2564"><span class='Ref_To_Local'>op</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1550"><span class='Ref_to_Member'>larg</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2550"><span class='Ref_to_Parameter'>topquery</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2551"><span class='Ref_to_Parameter'>safetyInfo</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="allpaths.c.html#LN120"><span class='Ref_to_Proto'>recurse_pushdown_safe</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2564"><span class='Ref_To_Local'>op</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1551"><span class='Ref_to_Member'>rarg</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2550"><span class='Ref_to_Parameter'>topquery</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2551"><span class='Ref_to_Parameter'>safetyInfo</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized node type: %d"</span><span class='Delimiter'>, 
</span>             <span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="../../../include/nodes/nodes.h.html#LN513"><span class='Ref_to_Macro'>nodeTag</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2550"><span class='Ref_to_Parameter'>setOp</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end recurse_pushdown_safe &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * check_output_expressions - check subquery's output expressions for safety 
 * 
 * There are several cases in which it's unsafe to push down an upper-level 
 * qual if it references a particular output column of a subquery.  We check 
 * each output column of the subquery and set unsafeColumns[k] to TRUE if 
 * that column is unsafe for a pushed-down qual to reference.  The conditions 
 * checked here are: 
 * 
 * 1. We must not push down any quals that refer to subselect outputs that 
 * return sets, else we'd introduce functions-returning-sets into the 
 * subquery's WHERE/HAVING quals. 
 * 
 * 2. We must not push down any quals that refer to subselect outputs that 
 * contain volatile functions, for fear of introducing strange results due 
 * to multiple evaluation of a volatile function. 
 * 
 * 3. If the subquery uses DISTINCT ON, we must not push down any quals that 
 * refer to non-DISTINCT output columns, because that could change the set 
 * of rows returned.  (This condition is vacuous for DISTINCT, because then 
 * there are no non-DISTINCT output columns, so we needn't check.  Note that 
 * subquery_is_pushdown_safe already reported that we can't use volatile 
 * quals if there's DISTINCT or DISTINCT ON.) 
 * 
 * 4. If the subquery has any window functions, we must not push down quals 
 * that reference any output columns that are not listed in all the subquery's 
 * window PARTITION BY clauses.  We can push down quals that use only 
 * partitioning columns because they should succeed or fail identically for 
 * every row of any one window partition, and totally excluding some 
 * partitions will not change a window function's results for remaining 
 * partitions.  (Again, this also requires nonvolatile quals, but 
 * subquery_is_pushdown_safe handles that.) 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2617"></a><span class='Declare_Function'>check_output_expressions</span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>subquery</span><span class='Delimiter'>, </span><a href="allpaths.c.html#LN49"><span class='Ref_to_Struct'>pushdown_safety_info</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>safetyInfo</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2619"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2619"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2617"><span class='Ref_to_Parameter'>subquery</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2623"></a>        <a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2619"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN2623"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1373"><span class='Ref_to_Member'>resjunk</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* ignore resjunk columns */ 
</span> 
        <span class='Comment_Multi_Line'>/* We need not check further if output col is already known unsafe */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN2617"><span class='Ref_to_Parameter'>safetyInfo</span></a><span class='Operator'>-&GT;</span><a href="allpaths.c.html#LN51"><span class='Ref_to_Member'>unsafeColumns</span></a><span class='Delimiter'>[</span><a href="allpaths.c.html#LN2623"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1367"><span class='Ref_to_Member'>resno</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Functions returning sets are unsafe (point 1) */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN2617"><span class='Ref_to_Parameter'>subquery</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN124"><span class='Ref_to_Member'>hasTargetSRFs</span></a> <span class='Operator'>&& 
</span>            <a href="../../../include/nodes/nodeFuncs.h.html#LN36"><span class='Ref_to_Proto'>expression_returns_set</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN2623"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="allpaths.c.html#LN2617"><span class='Ref_to_Parameter'>safetyInfo</span></a><span class='Operator'>-&GT;</span><a href="allpaths.c.html#LN51"><span class='Ref_to_Member'>unsafeColumns</span></a><span class='Delimiter'>[</span><a href="allpaths.c.html#LN2623"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1367"><span class='Ref_to_Member'>resno</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* Volatile functions are unsafe (point 2) */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/optimizer/clauses.h.html#LN60"><span class='Ref_to_Proto'>contain_volatile_functions</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN2623"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="allpaths.c.html#LN2617"><span class='Ref_to_Parameter'>safetyInfo</span></a><span class='Operator'>-&GT;</span><a href="allpaths.c.html#LN51"><span class='Ref_to_Member'>unsafeColumns</span></a><span class='Delimiter'>[</span><a href="allpaths.c.html#LN2623"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1367"><span class='Ref_to_Member'>resno</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* If subquery uses DISTINCT ON, check point 3 */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN2617"><span class='Ref_to_Parameter'>subquery</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN126"><span class='Ref_to_Member'>hasDistinctOn</span></a> <span class='Operator'>&& 
</span>            <span class='Operator'>!</span><a href="../../../include/parser/parse_clause.h.html#LN51"><span class='Ref_to_Proto'>targetIsInSortList</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2623"><span class='Ref_To_Local'>tle</span></a><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2617"><span class='Ref_to_Parameter'>subquery</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN153"><span class='Ref_to_Member'>distinctClause</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* non-DISTINCT column, so mark it unsafe */ 
</span>            <a href="allpaths.c.html#LN2617"><span class='Ref_to_Parameter'>safetyInfo</span></a><span class='Operator'>-&GT;</span><a href="allpaths.c.html#LN51"><span class='Ref_to_Member'>unsafeColumns</span></a><span class='Delimiter'>[</span><a href="allpaths.c.html#LN2623"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1367"><span class='Ref_to_Member'>resno</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* If subquery uses window functions, check point 4 */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN2617"><span class='Ref_to_Parameter'>subquery</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN123"><span class='Ref_to_Member'>hasWindowFuncs</span></a> <span class='Operator'>&& 
</span>            <span class='Operator'>!</span><a href="allpaths.c.html#LN126"><span class='Ref_to_Proto'>targetIsInAllPartitionLists</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2623"><span class='Ref_To_Local'>tle</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2617"><span class='Ref_to_Parameter'>subquery</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* not present in all PARTITION BY clauses, so mark it unsafe */ 
</span>            <a href="allpaths.c.html#LN2617"><span class='Ref_to_Parameter'>safetyInfo</span></a><span class='Operator'>-&GT;</span><a href="allpaths.c.html#LN51"><span class='Ref_to_Member'>unsafeColumns</span></a><span class='Delimiter'>[</span><a href="allpaths.c.html#LN2623"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1367"><span class='Ref_to_Member'>resno</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end check_output_expressions &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * For subqueries using UNION/UNION ALL/INTERSECT/INTERSECT ALL, we can 
 * push quals into each component query, but the quals can only reference 
 * subquery columns that suffer no type coercions in the set operation. 
 * Otherwise there are possible semantic gotchas.  So, we check the 
 * component queries to see if any of them have output types different from 
 * the top-level setop outputs.  unsafeColumns[k] is set true if column k 
 * has different type in any component. 
 * 
 * We don't have to care about typmods here: the only allowed difference 
 * between set-op input and output typmods is input is a specific typmod 
 * and output is -1, and that does not require a coercion. 
 * 
 * tlist is a subquery tlist. 
 * colTypes is an OID list of the top-level setop's output column types. 
 * safetyInfo-&GT;unsafeColumns[] is the result array. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2685"></a><span class='Declare_Function'>compare_tlist_datatypes</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>tlist</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>colTypes</span><span class='Delimiter'>, 
</span><a name="LN2686"></a>                        <a href="allpaths.c.html#LN49"><span class='Ref_to_Struct'>pushdown_safety_info</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>safetyInfo</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2688"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span><a name="LN2689"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>colType</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2685"><span class='Ref_to_Parameter'>colTypes</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2688"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2685"><span class='Ref_to_Parameter'>tlist</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2693"></a>        <a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2688"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN2693"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1373"><span class='Ref_to_Member'>resjunk</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* ignore resjunk columns */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN2689"><span class='Ref_To_Local'>colType</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"wrong number of tlist entries"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN2693"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Parentheses'>)</span> <span class='Operator'>!= </span><a href="../../../include/nodes/pg_list.h.html#LN107"><span class='Ref_to_Macro'>lfirst_oid</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2689"><span class='Ref_To_Local'>colType</span></a><span class='Parentheses'>))</span> 
            <a href="allpaths.c.html#LN2686"><span class='Ref_to_Parameter'>safetyInfo</span></a><span class='Operator'>-&GT;</span><a href="allpaths.c.html#LN51"><span class='Ref_to_Member'>unsafeColumns</span></a><span class='Delimiter'>[</span><a href="allpaths.c.html#LN2693"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1367"><span class='Ref_to_Member'>resno</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <a href="allpaths.c.html#LN2689"><span class='Ref_To_Local'>colType</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2689"><span class='Ref_To_Local'>colType</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN2689"><span class='Ref_To_Local'>colType</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"wrong number of tlist entries"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end compare_tlist_datatypes &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * targetIsInAllPartitionLists 
 *      True if the TargetEntry is listed in the PARTITION BY clause 
 *      of every window defined in the query. 
 * 
 * It would be safe to ignore windows not actually used by any window 
 * function, but it's not easy to get that info at this stage; and it's 
 * unlikely to be useful to spend any extra cycles getting it, since 
 * unreferenced window definitions are probably infrequent in practice. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN2718"></a><span class='Declare_Function'>targetIsInAllPartitionLists</span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>tle</span><span class='Delimiter'>, </span><a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>query</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2720"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2720"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2718"><span class='Ref_to_Parameter'>query</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN151"><span class='Ref_to_Member'>windowClause</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2724"></a>        <a href="../../../include/nodes/parsenodes.h.html#LN1252"><span class='Ref_to_Struct'>WindowClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>wc</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN1252"><span class='Ref_to_Struct'>WindowClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2720"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/parser/parse_clause.h.html#LN51"><span class='Ref_to_Proto'>targetIsInSortList</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2718"><span class='Ref_to_Parameter'>tle</span></a><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2724"><span class='Ref_To_Local'>wc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1257"><span class='Ref_to_Member'>partitionClause</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * qual_is_pushdown_safe - is a particular qual safe to push down? 
 * 
 * qual is a restriction clause applying to the given subquery (whose RTE 
 * has index rti in the parent query). 
 * 
 * Conditions checked here: 
 * 
 * 1. The qual must not contain any subselects (mainly because I'm not sure 
 * it will work correctly: sublinks will already have been transformed into 
 * subplans in the qual, but not in the subquery). 
 * 
 * 2. If unsafeVolatile is set, the qual must not contain any volatile 
 * functions. 
 * 
 * 3. If unsafeLeaky is set, the qual must not contain any leaky functions 
 * that are passed Var nodes, and therefore might reveal values from the 
 * subquery as side effects. 
 * 
 * 4. The qual must not refer to the whole-row output of the subquery 
 * (since there is no easy way to name that within the subquery itself). 
 * 
 * 5. The qual must not refer to any subquery output columns that were 
 * found to be unsafe to reference by subquery_is_pushdown_safe(). 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN2758"></a><span class='Declare_Function'>qual_is_pushdown_safe</span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>subquery</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a> <span class='Declare_Parameter'>rti</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>qual</span><span class='Delimiter'>, 
</span><a name="LN2759"></a>                      <a href="allpaths.c.html#LN49"><span class='Ref_to_Struct'>pushdown_safety_info</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>safetyInfo</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2761"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>safe</span> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span><a name="LN2762"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>vars</span><span class='Delimiter'>; 
</span><a name="LN2763"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>vl</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Refuse subselects (point 1) */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/optimizer/clauses.h.html#LN57"><span class='Ref_to_Proto'>contain_subplans</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2758"><span class='Ref_to_Parameter'>qual</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Refuse volatile quals if we found they'd be unsafe (point 2) */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN2759"><span class='Ref_to_Parameter'>safetyInfo</span></a><span class='Operator'>-&GT;</span><a href="allpaths.c.html#LN52"><span class='Ref_to_Member'>unsafeVolatile</span></a> <span class='Operator'>&& 
</span>        <a href="../../../include/optimizer/clauses.h.html#LN60"><span class='Ref_to_Proto'>contain_volatile_functions</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2758"><span class='Ref_to_Parameter'>qual</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Refuse leaky quals if told to (point 3) */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN2759"><span class='Ref_to_Parameter'>safetyInfo</span></a><span class='Operator'>-&GT;</span><a href="allpaths.c.html#LN53"><span class='Ref_to_Member'>unsafeLeaky</span></a> <span class='Operator'>&& 
</span>        <a href="../../../include/optimizer/clauses.h.html#LN65"><span class='Ref_to_Proto'>contain_leaked_vars</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2758"><span class='Ref_to_Parameter'>qual</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * It would be unsafe to push down window function calls, but at least for 
     * the moment we could never see any in a qual anyhow.  (The same applies 
     * to aggregates, which we check for in pull_var_clause below.) 
     */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/optimizer/clauses.h.html#LN52"><span class='Ref_to_Proto'>contain_window_function</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2758"><span class='Ref_to_Parameter'>qual</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Examine all Vars used in clause; since it's a restriction clause, all 
     * such Vars must refer to subselect output columns. 
     */ 
</span>    <a href="allpaths.c.html#LN2762"><span class='Ref_To_Local'>vars</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/var.h.html#LN36"><span class='Ref_to_Proto'>pull_var_clause</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2758"><span class='Ref_to_Parameter'>qual</span></a><span class='Delimiter'>, </span><a href="../../../include/optimizer/var.h.html#LN23"><span class='Ref_to_Const'>PVC_INCLUDE_PLACEHOLDERS</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2763"><span class='Ref_To_Local'>vl</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2762"><span class='Ref_To_Local'>vars</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2793"></a>        <a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>var</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2763"><span class='Ref_To_Local'>vl</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * XXX Punt if we find any PlaceHolderVars in the restriction clause. 
         * It's not clear whether a PHV could safely be pushed down, and even 
         * less clear whether such a situation could arise in any cases of 
         * practical interest anyway.  So for the moment, just refuse to push 
         * down. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2793"><span class='Ref_To_Local'>var</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="allpaths.c.html#LN2761"><span class='Ref_To_Local'>safe</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2793"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN165"><span class='Ref_to_Member'>varno</span></a> <span class='Operator'>== </span><a href="allpaths.c.html#LN2758"><span class='Ref_to_Parameter'>rti</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2793"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN167"><span class='Ref_to_Member'>varattno</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Check point 4 */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN2793"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN167"><span class='Ref_to_Member'>varattno</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="allpaths.c.html#LN2761"><span class='Ref_To_Local'>safe</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* Check point 5 */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN2759"><span class='Ref_to_Parameter'>safetyInfo</span></a><span class='Operator'>-&GT;</span><a href="allpaths.c.html#LN51"><span class='Ref_to_Member'>unsafeColumns</span></a><span class='Delimiter'>[</span><a href="allpaths.c.html#LN2793"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN167"><span class='Ref_to_Member'>varattno</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="allpaths.c.html#LN2761"><span class='Ref_To_Local'>safe</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN265"><span class='Ref_to_Proto'>list_free</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2762"><span class='Ref_To_Local'>vars</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="allpaths.c.html#LN2761"><span class='Ref_To_Local'>safe</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end qual_is_pushdown_safe &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * subquery_push_qual - push down a qual that we have determined is safe 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2835"></a><span class='Declare_Function'>subquery_push_qual</span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>subquery</span><span class='Delimiter'>, </span><a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rte</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a> <span class='Declare_Parameter'>rti</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>qual</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN2835"><span class='Ref_to_Parameter'>subquery</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN162"><span class='Ref_to_Member'>setOperations</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Recurse to push it separately to each component query */ 
</span>        <a href="allpaths.c.html#LN131"><span class='Ref_to_Proto'>recurse_push_qual</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2835"><span class='Ref_to_Parameter'>subquery</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN162"><span class='Ref_to_Member'>setOperations</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2835"><span class='Ref_to_Parameter'>subquery</span></a><span class='Delimiter'>, 
</span>                          <a href="allpaths.c.html#LN2835"><span class='Ref_to_Parameter'>rte</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2835"><span class='Ref_to_Parameter'>rti</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2835"><span class='Ref_to_Parameter'>qual</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * We need to replace Vars in the qual (which must refer to outputs of 
         * the subquery) with copies of the subquery's targetlist expressions. 
         * Note that at this point, any uplevel Vars in the qual should have 
         * been replaced with Params, so they need no work. 
         * 
         * This step also ensures that when we are pushing into a setop tree, 
         * each component query gets its own copy of the qual. 
         */ 
</span>        <a href="allpaths.c.html#LN2835"><span class='Ref_to_Parameter'>qual</span></a> <span class='Operator'>= </span><a href="../../../include/rewrite/rewriteManip.h.html#LN76"><span class='Ref_to_Proto'>ReplaceVarsFromTargetList</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2835"><span class='Ref_to_Parameter'>qual</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2835"><span class='Ref_to_Parameter'>rti</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2835"><span class='Ref_to_Parameter'>rte</span></a><span class='Delimiter'>, 
</span>                                         <a href="allpaths.c.html#LN2835"><span class='Ref_to_Parameter'>subquery</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a><span class='Delimiter'>, 
</span>                                         <a href="../../../include/rewrite/rewriteManip.h.html#LN35"><span class='Ref_to_EnumConst'>REPLACEVARS_REPORT_ERROR</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, 
</span>                                         <span class='Operator'>&</span><a href="allpaths.c.html#LN2835"><span class='Ref_to_Parameter'>subquery</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN125"><span class='Ref_to_Member'>hasSubLinks</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Now attach the qual to the proper place: normally WHERE, but if the 
         * subquery uses grouping or aggregation, put it in HAVING (since the 
         * qual really refers to the group-result rows). 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN2835"><span class='Ref_to_Parameter'>subquery</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN122"><span class='Ref_to_Member'>hasAggs</span></a> <span class='Operator'>|| </span><a href="allpaths.c.html#LN2835"><span class='Ref_to_Parameter'>subquery</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a> <span class='Operator'>|| </span><a href="allpaths.c.html#LN2835"><span class='Ref_to_Parameter'>subquery</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN147"><span class='Ref_to_Member'>groupingSets</span></a> <span class='Operator'>|| </span><a href="allpaths.c.html#LN2835"><span class='Ref_to_Parameter'>subquery</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN149"><span class='Ref_to_Member'>havingQual</span></a><span class='Parentheses'>) 
</span>            <a href="allpaths.c.html#LN2835"><span class='Ref_to_Parameter'>subquery</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN149"><span class='Ref_to_Member'>havingQual</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/clauses.h.html#LN44"><span class='Ref_to_Proto'>make_and_qual</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2835"><span class='Ref_to_Parameter'>subquery</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN149"><span class='Ref_to_Member'>havingQual</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2835"><span class='Ref_to_Parameter'>qual</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="allpaths.c.html#LN2835"><span class='Ref_to_Parameter'>subquery</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN135"><span class='Ref_to_Member'>jointree</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1470"><span class='Ref_to_Member'>quals</span></a> <span class='Operator'>= 
</span>                <a href="../../../include/optimizer/clauses.h.html#LN44"><span class='Ref_to_Proto'>make_and_qual</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2835"><span class='Ref_to_Parameter'>subquery</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN135"><span class='Ref_to_Member'>jointree</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1470"><span class='Ref_to_Member'>quals</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2835"><span class='Ref_to_Parameter'>qual</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We need not change the subquery's hasAggs or hasSubLinks flags, 
         * since we can't be pushing down any aggregates that weren't there 
         * before, and we don't push down subselects at all. 
         */ 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end subquery_push_qual &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Helper routine to recurse through setOperations tree 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2882"></a><span class='Declare_Function'>recurse_push_qual</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>setOp</span><span class='Delimiter'>, </span><a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>topquery</span><span class='Delimiter'>, 
</span><a name="LN2883"></a>                  <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rte</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a> <span class='Declare_Parameter'>rti</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>qual</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2882"><span class='Ref_to_Parameter'>setOp</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN1415"><span class='Ref_to_Struct'>RangeTblRef</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN2887"></a>        <a href="../../../include/nodes/primnodes.h.html#LN1415"><span class='Ref_to_Struct'>RangeTblRef</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rtr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1415"><span class='Ref_to_Struct'>RangeTblRef</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN2882"><span class='Ref_to_Parameter'>setOp</span></a><span class='Delimiter'>; 
</span><a name="LN2888"></a>        <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>subrte</span> <span class='Operator'>= </span><a href="../../../include/parser/parsetree.h.html#LN30"><span class='Ref_to_Macro'>rt_fetch</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2887"><span class='Ref_To_Local'>rtr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1418"><span class='Ref_to_Member'>rtindex</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2882"><span class='Ref_to_Parameter'>topquery</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN134"><span class='Ref_to_Member'>rtable</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2889"></a>        <a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>subquery</span> <span class='Operator'>= </span><a href="allpaths.c.html#LN2888"><span class='Ref_To_Local'>subrte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN954"><span class='Ref_to_Member'>subquery</span></a><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2889"><span class='Ref_To_Local'>subquery</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="allpaths.c.html#LN129"><span class='Ref_to_Proto'>subquery_push_qual</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2889"><span class='Ref_To_Local'>subquery</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2883"><span class='Ref_to_Parameter'>rte</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2883"><span class='Ref_to_Parameter'>rti</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2883"><span class='Ref_to_Parameter'>qual</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2882"><span class='Ref_to_Parameter'>setOp</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/parsenodes.h.html#LN1545"><span class='Ref_to_Struct'>SetOperationStmt</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN2896"></a>        <a href="../../../include/nodes/parsenodes.h.html#LN1545"><span class='Ref_to_Struct'>SetOperationStmt</span></a> <span class='Operator'>*</span><span class='Declare_Local'>op</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN1545"><span class='Ref_to_Struct'>SetOperationStmt</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN2882"><span class='Ref_to_Parameter'>setOp</span></a><span class='Delimiter'>; 
</span> 
        <a href="allpaths.c.html#LN131"><span class='Ref_to_Proto'>recurse_push_qual</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2896"><span class='Ref_To_Local'>op</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1550"><span class='Ref_to_Member'>larg</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2882"><span class='Ref_to_Parameter'>topquery</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2883"><span class='Ref_to_Parameter'>rte</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2883"><span class='Ref_to_Parameter'>rti</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2883"><span class='Ref_to_Parameter'>qual</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="allpaths.c.html#LN131"><span class='Ref_to_Proto'>recurse_push_qual</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2896"><span class='Ref_To_Local'>op</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1551"><span class='Ref_to_Member'>rarg</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2882"><span class='Ref_to_Parameter'>topquery</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2883"><span class='Ref_to_Parameter'>rte</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2883"><span class='Ref_to_Parameter'>rti</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2883"><span class='Ref_to_Parameter'>qual</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized node type: %d"</span><span class='Delimiter'>, 
</span>             <span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="../../../include/nodes/nodes.h.html#LN513"><span class='Ref_to_Macro'>nodeTag</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2882"><span class='Ref_to_Parameter'>setOp</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end recurse_push_qual &raquo; </span> 
 
<span class='Comment_Multi_Line'>/***************************************************************************** 
 *          SIMPLIFYING SUBQUERY TARGETLISTS 
 *****************************************************************************/ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * remove_unused_subquery_outputs 
 *      Remove subquery targetlist items we don't need 
 * 
 * It's possible, even likely, that the upper query does not read all the 
 * output columns of the subquery.  We can remove any such outputs that are 
 * not needed by the subquery itself (e.g., as sort/group columns) and do not 
 * affect semantics otherwise (e.g., volatile functions can't be removed). 
 * This is useful not only because we might be able to remove expensive-to- 
 * compute expressions, but because deletion of output columns might allow 
 * optimizations such as join removal to occur within the subquery. 
 * 
 * To avoid affecting column numbering in the targetlist, we don't physically 
 * remove unused tlist entries, but rather replace their expressions with NULL 
 * constants.  This is implemented by modifying subquery-&GT;targetList. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2929"></a><span class='Declare_Function'>remove_unused_subquery_outputs</span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>subquery</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2931"></a>    <a href="../../../include/nodes/bitmapset.h.html#LN36"><span class='Ref_to_Struct'>Bitmapset</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>attrs_used</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN2932"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Do nothing if subquery has UNION/INTERSECT/EXCEPT: in principle we 
     * could update all the child SELECTs' tlists, but it seems not worth the 
     * trouble presently. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN2929"><span class='Ref_to_Parameter'>subquery</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN162"><span class='Ref_to_Member'>setOperations</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If subquery has regular DISTINCT (not DISTINCT ON), we're wasting our 
     * time: all its output columns must be used in the distinctClause. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN2929"><span class='Ref_to_Parameter'>subquery</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN153"><span class='Ref_to_Member'>distinctClause</span></a> <span class='Operator'>&& !</span><a href="allpaths.c.html#LN2929"><span class='Ref_to_Parameter'>subquery</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN126"><span class='Ref_to_Member'>hasDistinctOn</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Collect a bitmap of all the output column numbers used by the upper 
     * query. 
     * 
     * Add all the attributes needed for joins or final output.  Note: we must 
     * look at rel's targetlist, not the attr_needed data, because attr_needed 
     * isn't computed for inheritance child rels, cf set_append_rel_size(). 
     * (XXX might be worth changing that sometime.) 
     */ 
</span>    <a href="../../../include/optimizer/var.h.html#LN31"><span class='Ref_to_Proto'>pull_varattnos</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN2929"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN535"><span class='Ref_to_Member'>reltarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN882"><span class='Ref_to_Member'>exprs</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2929"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="allpaths.c.html#LN2931"><span class='Ref_To_Local'>attrs_used</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Add all the attributes used by un-pushed-down restriction clauses. */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2932"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2929"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN583"><span class='Ref_to_Member'>baserestrictinfo</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2963"></a>        <a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2932"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/optimizer/var.h.html#LN31"><span class='Ref_to_Proto'>pull_varattnos</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN2963"><span class='Ref_To_Local'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1746"><span class='Ref_to_Member'>clause</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2929"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="allpaths.c.html#LN2931"><span class='Ref_To_Local'>attrs_used</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If there's a whole-row reference to the subquery, we can't remove 
     * anything. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN75"><span class='Ref_to_Proto'>bms_is_member</span></a><span class='Parentheses'>(</span><span class='Number'>0</span> <span class='Operator'>- </span><a href="../../../include/access/sysattr.h.html#LN27"><span class='Ref_to_Const'>FirstLowInvalidHeapAttributeNumber</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2931"><span class='Ref_To_Local'>attrs_used</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Run through the tlist and zap entries we don't need.  It's okay to 
     * modify the tlist items in-place because set_subquery_pathlist made a 
     * copy of the subquery. 
     */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2932"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN2929"><span class='Ref_to_Parameter'>subquery</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2982"></a>        <a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2932"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2983"></a>        <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>texpr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN2982"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If it has a sortgroupref number, it's used in some sort/group 
         * clause so we'd better not remove it.  Also, don't remove any 
         * resjunk columns, since their reason for being has nothing to do 
         * with anybody reading the subquery's output.  (It's likely that 
         * resjunk columns in a sub-SELECT would always have ressortgroupref 
         * set, but even if they don't, it seems imprudent to remove them.) 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN2982"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1369"><span class='Ref_to_Member'>ressortgroupref</span></a> <span class='Operator'>|| </span><a href="allpaths.c.html#LN2982"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1373"><span class='Ref_to_Member'>resjunk</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If it's used by the upper query, we can't remove it. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN75"><span class='Ref_to_Proto'>bms_is_member</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2982"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1367"><span class='Ref_to_Member'>resno</span></a> <span class='Operator'>- </span><a href="../../../include/access/sysattr.h.html#LN27"><span class='Ref_to_Const'>FirstLowInvalidHeapAttributeNumber</span></a><span class='Delimiter'>, 
</span>                          <a href="allpaths.c.html#LN2931"><span class='Ref_To_Local'>attrs_used</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If it contains a set-returning function, we can't remove it since 
         * that could change the number of rows returned by the subquery. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN2929"><span class='Ref_to_Parameter'>subquery</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN124"><span class='Ref_to_Member'>hasTargetSRFs</span></a> <span class='Operator'>&& 
</span>            <a href="../../../include/nodes/nodeFuncs.h.html#LN36"><span class='Ref_to_Proto'>expression_returns_set</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2983"><span class='Ref_To_Local'>texpr</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If it contains volatile functions, we daren't remove it for fear 
         * that the user is expecting their side-effects to happen. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/optimizer/clauses.h.html#LN60"><span class='Ref_to_Proto'>contain_volatile_functions</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2983"><span class='Ref_To_Local'>texpr</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * OK, we don't need it.  Replace the expression with a NULL constant. 
         * Preserve the exposed type of the expression, in case something 
         * looks at the rowtype of the subquery's result. 
         */ 
</span>        <a href="allpaths.c.html#LN2982"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/makefuncs.h.html#LN57"><span class='Ref_to_Proto'>makeNullConst</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2983"><span class='Ref_To_Local'>texpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                           <a href="../../../include/nodes/nodeFuncs.h.html#LN32"><span class='Ref_to_Proto'>exprTypmod</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2983"><span class='Ref_To_Local'>texpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                           <a href="../../../include/nodes/nodeFuncs.h.html#LN38"><span class='Ref_to_Proto'>exprCollation</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN2983"><span class='Ref_To_Local'>texpr</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end remove_unused_subquery_outputs &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * create_partial_bitmap_paths 
 *    Build partial bitmap heap path for the relation 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN3034"></a><span class='Declare_Function'>create_partial_bitmap_paths</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, 
</span><a name="LN3035"></a>                            <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>bitmapqual</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3037"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>parallel_workers</span><span class='Delimiter'>; 
</span><a name="LN3038"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>pages_fetched</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Compute heap pages for bitmap heap scan */ 
</span>    <a href="allpaths.c.html#LN3038"><span class='Ref_To_Local'>pages_fetched</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/cost.h.html#LN190"><span class='Ref_to_Proto'>compute_bitmap_pages</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN3034"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN3034"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN3035"><span class='Ref_to_Parameter'>bitmapqual</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>, 
</span>                                         <span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="allpaths.c.html#LN3037"><span class='Ref_To_Local'>parallel_workers</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/paths.h.html#LN56"><span class='Ref_to_Proto'>compute_parallel_worker</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN3034"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN3038"><span class='Ref_To_Local'>pages_fetched</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN3037"><span class='Ref_To_Local'>parallel_workers</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/optimizer/pathnode.h.html#LN31"><span class='Ref_to_Proto'>add_partial_path</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN3034"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/optimizer/pathnode.h.html#LN51"><span class='Ref_to_Proto'>create_bitmap_heap_path</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN3034"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN3034"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, 
</span>                    <a href="allpaths.c.html#LN3035"><span class='Ref_to_Parameter'>bitmapqual</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN3034"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN549"><span class='Ref_to_Member'>lateral_relids</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>, </span><a href="allpaths.c.html#LN3037"><span class='Ref_To_Local'>parallel_workers</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Compute the number of parallel workers that should be used to scan a 
 * relation.  We compute the parallel workers based on the size of the heap to 
 * be scanned and the size of the index to be scanned, then choose a minimum 
 * of those. 
 * 
 * "heap_pages" is the number of pages from the table that we expect to scan, or 
 * -1 if we don't expect to scan any. 
 * 
 * "index_pages" is the number of pages from the index that we expect to scan, or 
 * -1 if we don't expect to scan any. 
 */ 
</span><span class='Keyword'>int 
</span><a name="LN3066"></a><span class='Declare_Function'>compute_parallel_worker</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, </span><span class='Keyword'>double </span><span class='Declare_Parameter'>heap_pages</span><span class='Delimiter'>, </span><span class='Keyword'>double </span><span class='Declare_Parameter'>index_pages</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3068"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>parallel_workers</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the user has set the parallel_workers reloption, use that; otherwise 
     * select a default number of workers. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN3066"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN568"><span class='Ref_to_Member'>rel_parallel_workers</span></a> <span class='Operator'>!= -</span><span class='Number'>1</span><span class='Parentheses'>) 
</span>        <a href="allpaths.c.html#LN3068"><span class='Ref_To_Local'>parallel_workers</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN3066"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN568"><span class='Ref_to_Member'>rel_parallel_workers</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * If the number of pages being scanned is insufficient to justify a 
         * parallel scan, just return zero ... unless it's an inheritance 
         * child. In that case, we want to generate a parallel path here 
         * anyway.  It might not be worthwhile just for this relation, but 
         * when combined with all of its inheritance siblings it may well pay 
         * off. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN3066"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN521"><span class='Ref_to_Member'>reloptkind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/relation.h.html#LN493"><span class='Ref_to_EnumConst'>RELOPT_BASEREL</span></a> <span class='Operator'>&& 
</span>            <span class='Parentheses'>((</span><a href="allpaths.c.html#LN3066"><span class='Ref_to_Parameter'>heap_pages</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="allpaths.c.html#LN3066"><span class='Ref_to_Parameter'>heap_pages</span></a> <span class='Operator'>&LT; </span><a href="allpaths.c.html#LN59"><span class='Ref_to_Global_Var'>min_parallel_table_scan_size</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>           <span class='Parentheses'>(</span><a href="allpaths.c.html#LN3066"><span class='Ref_to_Parameter'>index_pages</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="allpaths.c.html#LN3066"><span class='Ref_to_Parameter'>index_pages</span></a> <span class='Operator'>&LT; </span><a href="allpaths.c.html#LN60"><span class='Ref_to_Global_Var'>min_parallel_index_scan_size</span></a><span class='Parentheses'>)))</span> 
            <span class='Control'>return</span> <span class='Number'>0</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN3066"><span class='Ref_to_Parameter'>heap_pages</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN3093"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>heap_parallel_threshold</span><span class='Delimiter'>; 
</span><a name="LN3094"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>heap_parallel_workers</span> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Select the number of workers based on the log of the size of 
             * the relation.  This probably needs to be a good deal more 
             * sophisticated, but we need something here for now.  Note that 
             * the upper limit of the min_parallel_table_scan_size GUC is 
             * chosen to prevent overflow here. 
             */ 
</span>            <a href="allpaths.c.html#LN3093"><span class='Ref_To_Local'>heap_parallel_threshold</span></a> <span class='Operator'>= </span><a href="../../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN10"><span class='Ref_to_Macro'>Max</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN59"><span class='Ref_to_Global_Var'>min_parallel_table_scan_size</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN3066"><span class='Ref_to_Parameter'>heap_pages</span></a> <span class='Operator'>&GT;= </span><span class='Parentheses'>(</span><a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a><span class='Parentheses'>) (</span><a href="allpaths.c.html#LN3093"><span class='Ref_To_Local'>heap_parallel_threshold</span></a> <span class='Operator'>* </span><span class='Number'>3</span><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <a href="allpaths.c.html#LN3094"><span class='Ref_To_Local'>heap_parallel_workers</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>                <a href="allpaths.c.html#LN3093"><span class='Ref_To_Local'>heap_parallel_threshold</span></a> <span class='Operator'>*= </span><span class='Number'>3</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN3093"><span class='Ref_To_Local'>heap_parallel_threshold</span></a> <span class='Operator'>&GT; </span>INT_MAX <span class='Operator'>/ </span><span class='Number'>3</span><span class='Parentheses'>) 
</span>                    <span class='Control'>break</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* avoid overflow */ 
</span>            <span class='Delimiter'>} 
</span> 
            <a href="allpaths.c.html#LN3068"><span class='Ref_To_Local'>parallel_workers</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN3094"><span class='Ref_To_Local'>heap_parallel_workers</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if heap_pages&GT;=0 &raquo; </span> 
 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN3066"><span class='Ref_to_Parameter'>index_pages</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN3117"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>index_parallel_workers</span> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span><a name="LN3118"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>index_parallel_threshold</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* same calculation as for heap_pages above */ 
</span>            <a href="allpaths.c.html#LN3118"><span class='Ref_To_Local'>index_parallel_threshold</span></a> <span class='Operator'>= </span><a href="../../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN10"><span class='Ref_to_Macro'>Max</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN60"><span class='Ref_to_Global_Var'>min_parallel_index_scan_size</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN3066"><span class='Ref_to_Parameter'>index_pages</span></a> <span class='Operator'>&GT;= </span><span class='Parentheses'>(</span><a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a><span class='Parentheses'>) (</span><a href="allpaths.c.html#LN3118"><span class='Ref_To_Local'>index_parallel_threshold</span></a> <span class='Operator'>* </span><span class='Number'>3</span><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <a href="allpaths.c.html#LN3117"><span class='Ref_To_Local'>index_parallel_workers</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>                <a href="allpaths.c.html#LN3118"><span class='Ref_To_Local'>index_parallel_threshold</span></a> <span class='Operator'>*= </span><span class='Number'>3</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN3118"><span class='Ref_To_Local'>index_parallel_threshold</span></a> <span class='Operator'>&GT; </span>INT_MAX <span class='Operator'>/ </span><span class='Number'>3</span><span class='Parentheses'>) 
</span>                    <span class='Control'>break</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* avoid overflow */ 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN3068"><span class='Ref_To_Local'>parallel_workers</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <a href="allpaths.c.html#LN3068"><span class='Ref_To_Local'>parallel_workers</span></a> <span class='Operator'>= </span><a href="../../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN11"><span class='Ref_to_Macro'>Min</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN3068"><span class='Ref_To_Local'>parallel_workers</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN3117"><span class='Ref_To_Local'>index_parallel_workers</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="allpaths.c.html#LN3068"><span class='Ref_To_Local'>parallel_workers</span></a> <span class='Operator'>= </span><a href="allpaths.c.html#LN3117"><span class='Ref_To_Local'>index_parallel_workers</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if index_pages&GT;=0 &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * In no case use more than max_parallel_workers_per_gather workers. 
     */ 
</span>    <a href="allpaths.c.html#LN3068"><span class='Ref_To_Local'>parallel_workers</span></a> <span class='Operator'>= </span><a href="../../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN11"><span class='Ref_to_Macro'>Min</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN3068"><span class='Ref_To_Local'>parallel_workers</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN115"><span class='Ref_to_Global_Var'>max_parallel_workers_per_gather</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="allpaths.c.html#LN3068"><span class='Ref_To_Local'>parallel_workers</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end compute_parallel_worker &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/***************************************************************************** 
 *          DEBUG SUPPORT 
 *****************************************************************************/ 
</span> 
<span class='Directive'>#ifdef</span> OPTIMIZER_DEBUG 
 
<span class='Keyword'>static void 
</span><a name="LN3153"></a><span class='Declare_Function'>print_relids</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Declare_Parameter'>relids</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3155"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>x</span><span class='Delimiter'>; 
</span><a name="LN3156"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>first</span> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <a href="allpaths.c.html#LN3155"><span class='Ref_To_Local'>x</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Control'>while</span> <span class='Parentheses'>((</span><a href="allpaths.c.html#LN3155"><span class='Ref_To_Local'>x</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN98"><span class='Ref_to_Proto'>bms_next_member</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN3153"><span class='Ref_to_Parameter'>relids</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN3155"><span class='Ref_To_Local'>x</span></a><span class='Parentheses'>))</span> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="allpaths.c.html#LN3156"><span class='Ref_To_Local'>first</span></a><span class='Parentheses'>) 
</span>            <a href="../../../include/port.h.html#LN173"><span class='Ref_to_Macro'>printf</span></a><span class='Parentheses'>(</span><span class='String'>" "</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN3155"><span class='Ref_To_Local'>x</span></a> <span class='Operator'>&LT; </span><a href="allpaths.c.html#LN3153"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN179"><span class='Ref_to_Member'>simple_rel_array_size</span></a> <span class='Operator'>&& 
</span>            <a href="allpaths.c.html#LN3153"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN187"><span class='Ref_to_Member'>simple_rte_array</span></a><span class='Delimiter'>[</span><a href="allpaths.c.html#LN3155"><span class='Ref_To_Local'>x</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>            <a href="../../../include/port.h.html#LN173"><span class='Ref_to_Macro'>printf</span></a><span class='Parentheses'>(</span><span class='String'>"%s"</span><span class='Delimiter'>, </span><a href="allpaths.c.html#LN3153"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN187"><span class='Ref_to_Member'>simple_rte_array</span></a><span class='Delimiter'>[</span><a href="allpaths.c.html#LN3155"><span class='Ref_To_Local'>x</span></a><span class='Delimiter'>]</span><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1023"><span class='Ref_to_Member'>eref</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN41"><span class='Ref_to_Member'>aliasname</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="../../../include/port.h.html#LN173"><span class='Ref_to_Macro'>printf</span></a><span class='Parentheses'>(</span><span class='String'>"%d"</span><span class='Delimiter'>, </span><a href="allpaths.c.html#LN3155"><span class='Ref_To_Local'>x</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="allpaths.c.html#LN3156"><span class='Ref_To_Local'>first</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
} 
</span> 
<span class='Keyword'>static void 
</span><a name="LN3173"></a><span class='Declare_Function'>print_restrictclauses</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clauses</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3175"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN3175"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN3173"><span class='Ref_to_Parameter'>clauses</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3179"></a>        <a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>c</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN3175"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/nodes/print.h.html#LN28"><span class='Ref_to_Proto'>print_expr</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN3179"><span class='Ref_To_Local'>c</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1746"><span class='Ref_to_Member'>clause</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN3173"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN134"><span class='Ref_to_Member'>rtable</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN3175"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>))</span> 
            <a href="../../../include/port.h.html#LN173"><span class='Ref_to_Macro'>printf</span></a><span class='Parentheses'>(</span><span class='String'>", "</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
} 
</span> 
<span class='Keyword'>static void 
</span><a name="LN3188"></a><span class='Declare_Function'>print_path</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>indent</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3190"></a>    <span class='Keyword'>const char </span><span class='Operator'>*</span><span class='Declare_Local'>ptype</span><span class='Delimiter'>; 
</span><a name="LN3191"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>join</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN3192"></a>    <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>subpath</span> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span><a name="LN3193"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN513"><span class='Ref_to_Macro'>nodeTag</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN3188"><span class='Ref_to_Parameter'>path</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN220"><span class='Ref_to_EnumConst'>T_Path</span></a><span class='Operator'>: 
</span>            <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN3188"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN950"><span class='Ref_to_Member'>pathtype</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN53"><span class='Ref_to_EnumConst'>T_SeqScan</span></a><span class='Operator'>: 
</span>                    <a href="allpaths.c.html#LN3190"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>= </span><span class='String'>"SeqScan"</span><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN54"><span class='Ref_to_EnumConst'>T_SampleScan</span></a><span class='Operator'>: 
</span>                    <a href="allpaths.c.html#LN3190"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>= </span><span class='String'>"SampleScan"</span><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN60"><span class='Ref_to_EnumConst'>T_SubqueryScan</span></a><span class='Operator'>: 
</span>                    <a href="allpaths.c.html#LN3190"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>= </span><span class='String'>"SubqueryScan"</span><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN61"><span class='Ref_to_EnumConst'>T_FunctionScan</span></a><span class='Operator'>: 
</span>                    <a href="allpaths.c.html#LN3190"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>= </span><span class='String'>"FunctionScan"</span><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN63"><span class='Ref_to_EnumConst'>T_TableFuncScan</span></a><span class='Operator'>: 
</span>                    <a href="allpaths.c.html#LN3190"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>= </span><span class='String'>"TableFuncScan"</span><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN62"><span class='Ref_to_EnumConst'>T_ValuesScan</span></a><span class='Operator'>: 
</span>                    <a href="allpaths.c.html#LN3190"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>= </span><span class='String'>"ValuesScan"</span><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN64"><span class='Ref_to_EnumConst'>T_CteScan</span></a><span class='Operator'>: 
</span>                    <a href="allpaths.c.html#LN3190"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>= </span><span class='String'>"CteScan"</span><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN66"><span class='Ref_to_EnumConst'>T_WorkTableScan</span></a><span class='Operator'>: 
</span>                    <a href="allpaths.c.html#LN3190"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>= </span><span class='String'>"WorkTableScan"</span><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Control'>default</span><span class='Operator'>: 
</span>                    <a href="allpaths.c.html#LN3190"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>= </span><span class='String'>"???Path"</span><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch path-&GT;pathtype &raquo; </span> 
            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN221"><span class='Ref_to_EnumConst'>T_IndexPath</span></a><span class='Operator'>: 
</span>            <a href="allpaths.c.html#LN3190"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>= </span><span class='String'>"IdxScan"</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN222"><span class='Ref_to_EnumConst'>T_BitmapHeapPath</span></a><span class='Operator'>: 
</span>            <a href="allpaths.c.html#LN3190"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>= </span><span class='String'>"BitmapHeapScan"</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN223"><span class='Ref_to_EnumConst'>T_BitmapAndPath</span></a><span class='Operator'>: 
</span>            <a href="allpaths.c.html#LN3190"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>= </span><span class='String'>"BitmapAndPath"</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN224"><span class='Ref_to_EnumConst'>T_BitmapOrPath</span></a><span class='Operator'>: 
</span>            <a href="allpaths.c.html#LN3190"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>= </span><span class='String'>"BitmapOrPath"</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN225"><span class='Ref_to_EnumConst'>T_TidPath</span></a><span class='Operator'>: 
</span>            <a href="allpaths.c.html#LN3190"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>= </span><span class='String'>"TidScan"</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN226"><span class='Ref_to_EnumConst'>T_SubqueryScanPath</span></a><span class='Operator'>: 
</span>            <a href="allpaths.c.html#LN3190"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>= </span><span class='String'>"SubqueryScanScan"</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN227"><span class='Ref_to_EnumConst'>T_ForeignPath</span></a><span class='Operator'>: 
</span>            <a href="allpaths.c.html#LN3190"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>= </span><span class='String'>"ForeignScan"</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN232"><span class='Ref_to_EnumConst'>T_AppendPath</span></a><span class='Operator'>: 
</span>            <a href="allpaths.c.html#LN3190"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>= </span><span class='String'>"Append"</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN233"><span class='Ref_to_EnumConst'>T_MergeAppendPath</span></a><span class='Operator'>: 
</span>            <a href="allpaths.c.html#LN3190"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>= </span><span class='String'>"MergeAppend"</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN234"><span class='Ref_to_EnumConst'>T_ResultPath</span></a><span class='Operator'>: 
</span>            <a href="allpaths.c.html#LN3190"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>= </span><span class='String'>"Result"</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN235"><span class='Ref_to_EnumConst'>T_MaterialPath</span></a><span class='Operator'>: 
</span>            <a href="allpaths.c.html#LN3190"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>= </span><span class='String'>"Material"</span><span class='Delimiter'>; 
</span>            <a href="allpaths.c.html#LN3192"><span class='Ref_To_Local'>subpath</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/relation.h.html#LN1222"><span class='Ref_to_Struct'>MaterialPath</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN3188"><span class='Ref_to_Parameter'>path</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>subpath<span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN236"><span class='Ref_to_EnumConst'>T_UniquePath</span></a><span class='Operator'>: 
</span>            <a href="allpaths.c.html#LN3190"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>= </span><span class='String'>"Unique"</span><span class='Delimiter'>; 
</span>            <a href="allpaths.c.html#LN3192"><span class='Ref_To_Local'>subpath</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/relation.h.html#LN1247"><span class='Ref_to_Struct'>UniquePath</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN3188"><span class='Ref_to_Parameter'>path</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>subpath<span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN237"><span class='Ref_to_EnumConst'>T_GatherPath</span></a><span class='Operator'>: 
</span>            <a href="allpaths.c.html#LN3190"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>= </span><span class='String'>"Gather"</span><span class='Delimiter'>; 
</span>            <a href="allpaths.c.html#LN3192"><span class='Ref_To_Local'>subpath</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/relation.h.html#LN1261"><span class='Ref_to_Struct'>GatherPath</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN3188"><span class='Ref_to_Parameter'>path</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>subpath<span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN239"><span class='Ref_to_EnumConst'>T_ProjectionPath</span></a><span class='Operator'>: 
</span>            <a href="allpaths.c.html#LN3190"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>= </span><span class='String'>"Projection"</span><span class='Delimiter'>; 
</span>            <a href="allpaths.c.html#LN3192"><span class='Ref_To_Local'>subpath</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/relation.h.html#LN1388"><span class='Ref_to_Struct'>ProjectionPath</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN3188"><span class='Ref_to_Parameter'>path</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>subpath<span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN240"><span class='Ref_to_EnumConst'>T_ProjectSetPath</span></a><span class='Operator'>: 
</span>            <a href="allpaths.c.html#LN3190"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>= </span><span class='String'>"ProjectSet"</span><span class='Delimiter'>; 
</span>            <a href="allpaths.c.html#LN3192"><span class='Ref_To_Local'>subpath</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/relation.h.html#LN1400"><span class='Ref_to_Struct'>ProjectSetPath</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN3188"><span class='Ref_to_Parameter'>path</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>subpath<span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN241"><span class='Ref_to_EnumConst'>T_SortPath</span></a><span class='Operator'>: 
</span>            <a href="allpaths.c.html#LN3190"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>= </span><span class='String'>"Sort"</span><span class='Delimiter'>; 
</span>            <a href="allpaths.c.html#LN3192"><span class='Ref_To_Local'>subpath</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/relation.h.html#LN1414"><span class='Ref_to_Struct'>SortPath</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN3188"><span class='Ref_to_Parameter'>path</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>subpath<span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN242"><span class='Ref_to_EnumConst'>T_GroupPath</span></a><span class='Operator'>: 
</span>            <a href="allpaths.c.html#LN3190"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>= </span><span class='String'>"Group"</span><span class='Delimiter'>; 
</span>            <a href="allpaths.c.html#LN3192"><span class='Ref_To_Local'>subpath</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/relation.h.html#LN1428"><span class='Ref_to_Struct'>GroupPath</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN3188"><span class='Ref_to_Parameter'>path</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>subpath<span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN243"><span class='Ref_to_EnumConst'>T_UpperUniquePath</span></a><span class='Operator'>: 
</span>            <a href="allpaths.c.html#LN3190"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>= </span><span class='String'>"UpperUnique"</span><span class='Delimiter'>; 
</span>            <a href="allpaths.c.html#LN3192"><span class='Ref_To_Local'>subpath</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/relation.h.html#LN1442"><span class='Ref_to_Struct'>UpperUniquePath</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN3188"><span class='Ref_to_Parameter'>path</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>subpath<span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN244"><span class='Ref_to_EnumConst'>T_AggPath</span></a><span class='Operator'>: 
</span>            <a href="allpaths.c.html#LN3190"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>= </span><span class='String'>"Agg"</span><span class='Delimiter'>; 
</span>            <a href="allpaths.c.html#LN3192"><span class='Ref_To_Local'>subpath</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/relation.h.html#LN1456"><span class='Ref_to_Struct'>AggPath</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN3188"><span class='Ref_to_Parameter'>path</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>subpath<span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN245"><span class='Ref_to_EnumConst'>T_GroupingSetsPath</span></a><span class='Operator'>: 
</span>            <a href="allpaths.c.html#LN3190"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>= </span><span class='String'>"GroupingSets"</span><span class='Delimiter'>; 
</span>            <a href="allpaths.c.html#LN3192"><span class='Ref_To_Local'>subpath</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/relation.h.html#LN1493"><span class='Ref_to_Struct'>GroupingSetsPath</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN3188"><span class='Ref_to_Parameter'>path</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>subpath<span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN246"><span class='Ref_to_EnumConst'>T_MinMaxAggPath</span></a><span class='Operator'>: 
</span>            <a href="allpaths.c.html#LN3190"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>= </span><span class='String'>"MinMaxAgg"</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN247"><span class='Ref_to_EnumConst'>T_WindowAggPath</span></a><span class='Operator'>: 
</span>            <a href="allpaths.c.html#LN3190"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>= </span><span class='String'>"WindowAgg"</span><span class='Delimiter'>; 
</span>            <a href="allpaths.c.html#LN3192"><span class='Ref_To_Local'>subpath</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/relation.h.html#LN1519"><span class='Ref_to_Struct'>WindowAggPath</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN3188"><span class='Ref_to_Parameter'>path</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>subpath<span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN248"><span class='Ref_to_EnumConst'>T_SetOpPath</span></a><span class='Operator'>: 
</span>            <a href="allpaths.c.html#LN3190"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>= </span><span class='String'>"SetOp"</span><span class='Delimiter'>; 
</span>            <a href="allpaths.c.html#LN3192"><span class='Ref_To_Local'>subpath</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/relation.h.html#LN1530"><span class='Ref_to_Struct'>SetOpPath</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN3188"><span class='Ref_to_Parameter'>path</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>subpath<span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN249"><span class='Ref_to_EnumConst'>T_RecursiveUnionPath</span></a><span class='Operator'>: 
</span>            <a href="allpaths.c.html#LN3190"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>= </span><span class='String'>"RecursiveUnion"</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN250"><span class='Ref_to_EnumConst'>T_LockRowsPath</span></a><span class='Operator'>: 
</span>            <a href="allpaths.c.html#LN3190"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>= </span><span class='String'>"LockRows"</span><span class='Delimiter'>; 
</span>            <a href="allpaths.c.html#LN3192"><span class='Ref_To_Local'>subpath</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/relation.h.html#LN1558"><span class='Ref_to_Struct'>LockRowsPath</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN3188"><span class='Ref_to_Parameter'>path</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>subpath<span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN251"><span class='Ref_to_EnumConst'>T_ModifyTablePath</span></a><span class='Operator'>: 
</span>            <a href="allpaths.c.html#LN3190"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>= </span><span class='String'>"ModifyTable"</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN252"><span class='Ref_to_EnumConst'>T_LimitPath</span></a><span class='Operator'>: 
</span>            <a href="allpaths.c.html#LN3190"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>= </span><span class='String'>"Limit"</span><span class='Delimiter'>; 
</span>            <a href="allpaths.c.html#LN3192"><span class='Ref_To_Local'>subpath</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/relation.h.html#LN1594"><span class='Ref_to_Struct'>LimitPath</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN3188"><span class='Ref_to_Parameter'>path</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>subpath<span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN229"><span class='Ref_to_EnumConst'>T_NestPath</span></a><span class='Operator'>: 
</span>            <a href="allpaths.c.html#LN3190"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>= </span><span class='String'>"NestLoop"</span><span class='Delimiter'>; 
</span>            <a href="allpaths.c.html#LN3191"><span class='Ref_To_Local'>join</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN230"><span class='Ref_to_EnumConst'>T_MergePath</span></a><span class='Operator'>: 
</span>            <a href="allpaths.c.html#LN3190"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>= </span><span class='String'>"MergeJoin"</span><span class='Delimiter'>; 
</span>            <a href="allpaths.c.html#LN3191"><span class='Ref_To_Local'>join</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN231"><span class='Ref_to_EnumConst'>T_HashPath</span></a><span class='Operator'>: 
</span>            <a href="allpaths.c.html#LN3190"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>= </span><span class='String'>"HashJoin"</span><span class='Delimiter'>; 
</span>            <a href="allpaths.c.html#LN3191"><span class='Ref_To_Local'>join</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>default</span><span class='Operator'>: 
</span>            <a href="allpaths.c.html#LN3190"><span class='Ref_To_Local'>ptype</span></a> <span class='Operator'>= </span><span class='String'>"???Path"</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch nodeTag(path) &raquo; </span> 
 
    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN3193"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="allpaths.c.html#LN3193"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="allpaths.c.html#LN3188"><span class='Ref_to_Parameter'>indent</span></a><span class='Delimiter'>; </span><a href="allpaths.c.html#LN3193"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <a href="../../../include/port.h.html#LN173"><span class='Ref_to_Macro'>printf</span></a><span class='Parentheses'>(</span><span class='String'>"\t"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/port.h.html#LN173"><span class='Ref_to_Macro'>printf</span></a><span class='Parentheses'>(</span><span class='String'>"%s"</span><span class='Delimiter'>, </span><a href="allpaths.c.html#LN3190"><span class='Ref_To_Local'>ptype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN3188"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN952"><span class='Ref_to_Member'>parent</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/port.h.html#LN173"><span class='Ref_to_Macro'>printf</span></a><span class='Parentheses'>(</span><span class='String'>"("</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="allpaths.c.html#LN3152"><span class='Ref_to_Func'>print_relids</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN3188"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN3188"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN952"><span class='Ref_to_Member'>parent</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/port.h.html#LN173"><span class='Ref_to_Macro'>printf</span></a><span class='Parentheses'>(</span><span class='String'>")"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN3188"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN955"><span class='Ref_to_Member'>param_info</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/port.h.html#LN173"><span class='Ref_to_Macro'>printf</span></a><span class='Parentheses'>(</span><span class='String'>" required_outer ("</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="allpaths.c.html#LN3152"><span class='Ref_to_Func'>print_relids</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN3188"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN3188"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN955"><span class='Ref_to_Member'>param_info</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN911"><span class='Ref_to_Member'>ppi_req_outer</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/port.h.html#LN173"><span class='Ref_to_Macro'>printf</span></a><span class='Parentheses'>(</span><span class='String'>")"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="../../../include/port.h.html#LN173"><span class='Ref_to_Macro'>printf</span></a><span class='Parentheses'>(</span><span class='String'>" rows=%.0f cost=%.2f..%.2f\n"</span><span class='Delimiter'>, 
</span>           <a href="allpaths.c.html#LN3188"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN3188"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN3188"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN3188"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN967"><span class='Ref_to_Member'>pathkeys</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN3193"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="allpaths.c.html#LN3193"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="allpaths.c.html#LN3188"><span class='Ref_to_Parameter'>indent</span></a><span class='Delimiter'>; </span><a href="allpaths.c.html#LN3193"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>            <a href="../../../include/port.h.html#LN173"><span class='Ref_to_Macro'>printf</span></a><span class='Parentheses'>(</span><span class='String'>"\t"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/port.h.html#LN173"><span class='Ref_to_Macro'>printf</span></a><span class='Parentheses'>(</span><span class='String'>"  pathkeys: "</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/nodes/print.h.html#LN29"><span class='Ref_to_Proto'>print_pathkeys</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN3188"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN967"><span class='Ref_to_Member'>pathkeys</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN3188"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN134"><span class='Ref_to_Member'>rtable</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN3191"><span class='Ref_To_Local'>join</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3370"></a>        <a href="../../../include/nodes/relation.h.html#LN1286"><span class='Ref_to_Struct'>JoinPath</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>jp</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1286"><span class='Ref_to_Struct'>JoinPath</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN3188"><span class='Ref_to_Parameter'>path</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN3193"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="allpaths.c.html#LN3193"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="allpaths.c.html#LN3188"><span class='Ref_to_Parameter'>indent</span></a><span class='Delimiter'>; </span><a href="allpaths.c.html#LN3193"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>            <a href="../../../include/port.h.html#LN173"><span class='Ref_to_Macro'>printf</span></a><span class='Parentheses'>(</span><span class='String'>"\t"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/port.h.html#LN173"><span class='Ref_to_Macro'>printf</span></a><span class='Parentheses'>(</span><span class='String'>"  clauses: "</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="allpaths.c.html#LN3172"><span class='Ref_to_Func'>print_restrictclauses</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN3188"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN3370"><span class='Ref_To_Local'>jp</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1298"><span class='Ref_to_Member'>joinrestrictinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/port.h.html#LN173"><span class='Ref_to_Macro'>printf</span></a><span class='Parentheses'>(</span><span class='String'>"\n"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN3188"><span class='Ref_to_Parameter'>path</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1348"><span class='Ref_to_Struct'>MergePath</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN3380"></a>            <a href="../../../include/nodes/relation.h.html#LN1348"><span class='Ref_to_Struct'>MergePath</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>mp</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1348"><span class='Ref_to_Struct'>MergePath</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="allpaths.c.html#LN3188"><span class='Ref_to_Parameter'>path</span></a><span class='Delimiter'>; 
</span> 
            <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN3193"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="allpaths.c.html#LN3193"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="allpaths.c.html#LN3188"><span class='Ref_to_Parameter'>indent</span></a><span class='Delimiter'>; </span><a href="allpaths.c.html#LN3193"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>                <a href="../../../include/port.h.html#LN173"><span class='Ref_to_Macro'>printf</span></a><span class='Parentheses'>(</span><span class='String'>"\t"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/port.h.html#LN173"><span class='Ref_to_Macro'>printf</span></a><span class='Parentheses'>(</span><span class='String'>"  sortouter=%d sortinner=%d materializeinner=%d\n"</span><span class='Delimiter'>, 
</span>                   <span class='Parentheses'>((</span><a href="allpaths.c.html#LN3380"><span class='Ref_To_Local'>mp</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1352"><span class='Ref_to_Member'>outersortkeys</span></a><span class='Parentheses'>) </span><span class='Operator'>? </span><span class='Number'>1</span> <span class='Operator'>: </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                   <span class='Parentheses'>((</span><a href="allpaths.c.html#LN3380"><span class='Ref_To_Local'>mp</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1353"><span class='Ref_to_Member'>innersortkeys</span></a><span class='Parentheses'>) </span><span class='Operator'>? </span><span class='Number'>1</span> <span class='Operator'>: </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                   <span class='Parentheses'>((</span><a href="allpaths.c.html#LN3380"><span class='Ref_To_Local'>mp</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1355"><span class='Ref_to_Member'>materialize_inner</span></a><span class='Parentheses'>) </span><span class='Operator'>? </span><span class='Number'>1</span> <span class='Operator'>: </span><span class='Number'>0</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="allpaths.c.html#LN3187"><span class='Ref_to_Func'>print_path</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN3188"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN3370"><span class='Ref_To_Local'>jp</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1295"><span class='Ref_to_Member'>outerjoinpath</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN3188"><span class='Ref_to_Parameter'>indent</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="allpaths.c.html#LN3187"><span class='Ref_to_Func'>print_path</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN3188"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN3370"><span class='Ref_To_Local'>jp</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1296"><span class='Ref_to_Member'>innerjoinpath</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN3188"><span class='Ref_to_Parameter'>indent</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if join &raquo; </span> 
 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN3192"><span class='Ref_To_Local'>subpath</span></a><span class='Parentheses'>) 
</span>        <a href="allpaths.c.html#LN3187"><span class='Ref_to_Func'>print_path</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN3188"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN3192"><span class='Ref_To_Local'>subpath</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN3188"><span class='Ref_to_Parameter'>indent</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end print_path &raquo; </span> 
 
<span class='Keyword'>void 
</span><a name="LN3399"></a><span class='Declare_Function'>debug_print_rel</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3401"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/port.h.html#LN173"><span class='Ref_to_Macro'>printf</span></a><span class='Parentheses'>(</span><span class='String'>"RELOPTINFO ("</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="allpaths.c.html#LN3152"><span class='Ref_to_Func'>print_relids</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN3399"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN3399"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/port.h.html#LN173"><span class='Ref_to_Macro'>printf</span></a><span class='Parentheses'>(</span><span class='String'>"): rows=%.0f width=%d\n"</span><span class='Delimiter'>, </span><a href="allpaths.c.html#LN3399"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN3399"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN535"><span class='Ref_to_Member'>reltarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN885"><span class='Ref_to_Member'>width</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN3399"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN583"><span class='Ref_to_Member'>baserestrictinfo</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/port.h.html#LN173"><span class='Ref_to_Macro'>printf</span></a><span class='Parentheses'>(</span><span class='String'>"\tbaserestrictinfo: "</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="allpaths.c.html#LN3172"><span class='Ref_to_Func'>print_restrictclauses</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN3399"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN3399"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN583"><span class='Ref_to_Member'>baserestrictinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/port.h.html#LN173"><span class='Ref_to_Macro'>printf</span></a><span class='Parentheses'>(</span><span class='String'>"\n"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN3399"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN588"><span class='Ref_to_Member'>joininfo</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/port.h.html#LN173"><span class='Ref_to_Macro'>printf</span></a><span class='Parentheses'>(</span><span class='String'>"\tjoininfo: "</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="allpaths.c.html#LN3172"><span class='Ref_to_Func'>print_restrictclauses</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN3399"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN3399"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN588"><span class='Ref_to_Member'>joininfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/port.h.html#LN173"><span class='Ref_to_Macro'>printf</span></a><span class='Parentheses'>(</span><span class='String'>"\n"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/port.h.html#LN173"><span class='Ref_to_Macro'>printf</span></a><span class='Parentheses'>(</span><span class='String'>"\tpath list:\n"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN3401"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN3399"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN538"><span class='Ref_to_Member'>pathlist</span></a><span class='Parentheses'>) 
</span>        <a href="allpaths.c.html#LN3187"><span class='Ref_to_Func'>print_path</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN3399"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN3401"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN3399"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN544"><span class='Ref_to_Member'>cheapest_parameterized_paths</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/port.h.html#LN173"><span class='Ref_to_Macro'>printf</span></a><span class='Parentheses'>(</span><span class='String'>"\n\tcheapest parameterized paths:\n"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN3401"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN3399"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN544"><span class='Ref_to_Member'>cheapest_parameterized_paths</span></a><span class='Parentheses'>) 
</span><a name="LN3428"></a>            <span class='Declare_Local'>print_path</span><span class='Parentheses'>(</span><a href="allpaths.c.html#LN3399"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN3401"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN3399"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN541"><span class='Ref_to_Member'>cheapest_startup_path</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/port.h.html#LN173"><span class='Ref_to_Macro'>printf</span></a><span class='Parentheses'>(</span><span class='String'>"\n\tcheapest startup path:\n"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="allpaths.c.html#LN3187"><span class='Ref_to_Func'>print_path</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN3399"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN3399"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN541"><span class='Ref_to_Member'>cheapest_startup_path</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="allpaths.c.html#LN3399"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN542"><span class='Ref_to_Member'>cheapest_total_path</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/port.h.html#LN173"><span class='Ref_to_Macro'>printf</span></a><span class='Parentheses'>(</span><span class='String'>"\n\tcheapest total path:\n"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="allpaths.c.html#LN3187"><span class='Ref_to_Func'>print_path</span></a><span class='Parentheses'>(</span><a href="allpaths.c.html#LN3399"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="allpaths.c.html#LN3399"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN542"><span class='Ref_to_Member'>cheapest_total_path</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="../../../include/port.h.html#LN173"><span class='Ref_to_Macro'>printf</span></a><span class='Parentheses'>(</span><span class='String'>"\n"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    fflush<span class='Parentheses'>(</span>stdout<span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end debug_print_rel &raquo; </span> 
 
<span class='Directive'>#endif</span>   <span class='Comment_Single_Line'>/* OPTIMIZER_DEBUG */ 
</span></pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>