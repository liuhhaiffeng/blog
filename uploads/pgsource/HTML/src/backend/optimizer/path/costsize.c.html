<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\optimizer\path\costsize.c</title>
<LINK REL=StyleSheet HREF="../../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\optimizer\path\costsize.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:41 2017
</td></tr>
<tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * costsize.c 
 *    Routines to compute (and set) relation sizes and path costs 
 * 
 * Path costs are measured in arbitrary units established by these basic 
 * parameters: 
 * 
 *  seq_page_cost       Cost of a sequential page fetch 
 *  random_page_cost    Cost of a non-sequential page fetch 
 *  cpu_tuple_cost      Cost of typical CPU time to process a tuple 
 *  cpu_index_tuple_cost  Cost of typical CPU time to process an index tuple 
 *  cpu_operator_cost   Cost of CPU time to execute an operator or function 
 *  parallel_tuple_cost Cost of CPU time to pass a tuple from worker to master backend 
 *  parallel_setup_cost Cost of setting up shared memory for parallelism 
 * 
 * We expect that the kernel will typically do some amount of read-ahead 
 * optimization; this in conjunction with seek costs means that seq_page_cost 
 * is normally considerably less than random_page_cost.  (However, if the 
 * database is fully cached in RAM, it is reasonable to set them equal.) 
 * 
 * We also use a rough estimate "effective_cache_size" of the number of 
 * disk pages in Postgres + OS-level disk cache.  (We can't simply use 
 * NBuffers for this purpose because that would ignore the effects of 
 * the kernel's disk cache.) 
 * 
 * Obviously, taking constants for these values is an oversimplification, 
 * but it's tough enough to get any useful estimates even at this level of 
 * detail.  Note that all of these parameters are user-settable, in case 
 * the default values are drastically off for a particular platform. 
 * 
 * seq_page_cost and random_page_cost can also be overridden for an individual 
 * tablespace, in case some data is on a fast disk and other data is on a slow 
 * disk.  Per-tablespace overrides never apply to temporary work files such as 
 * an external sort or a materialize node that overflows work_mem. 
 * 
 * We compute two separate costs for each path: 
 *      total_cost: total estimated cost to fetch all tuples 
 *      startup_cost: cost that is expended before first tuple is fetched 
 * In some scenarios, such as when there is a LIMIT or we are implementing 
 * an EXISTS(...) sub-select, it is not necessary to fetch all tuples of the 
 * path's result.  A caller can estimate the cost of fetching a partial 
 * result by interpolating between startup_cost and total_cost.  In detail: 
 *      actual_cost = startup_cost + 
 *          (total_cost - startup_cost) * tuples_to_fetch / path-&GT;rows; 
 * Note that a base relation's rows count (and, by extension, plan_rows for 
 * plan nodes below the LIMIT node) are set without regard to any LIMIT, so 
 * that this equation works properly.  (Note: while path-&GT;rows is never zero 
 * for ordinary relations, it is zero for paths for provably-empty relations, 
 * so beware of division-by-zero.)  The LIMIT is applied as a top-level 
 * plan node. 
 * 
 * For largely historical reasons, most of the routines in this module use 
 * the passed result Path only to store their results (rows, startup_cost and 
 * total_cost) into.  All the input data they need is passed as separate 
 * parameters, even though much of it could be extracted from the Path. 
 * An exception is made for the cost_XXXjoin() routines, which expect all 
 * the other fields of the passed XXXPath to be filled in, and similarly 
 * cost_index() assumes the passed IndexPath is valid except for its output 
 * values. 
 * 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * IDENTIFICATION 
 *    src/backend/optimizer/path/costsize.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span> 
<span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Directive'>#ifdef</span> _MSC_VER 
<span class='Keyword'>#include </span><span class='String'>&LT;float.h&GT;</span>              <span class='Comment_Single_Line'>/* for _isnan */ 
</span><span class='Directive'>#endif</span> 
<span class='Keyword'>#include </span><span class='String'>&LT;math.h&GT;</span> 
 
<span class='Keyword'>#include </span><span class='String'>"access/amapi.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/htup_details.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"access/tsmapi.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"executor/executor.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"executor/nodeHash.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"miscadmin.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/nodeFuncs.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/clauses.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/cost.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/pathnode.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/paths.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/placeholder.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/plancat.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/planmain.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/restrictinfo.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parsetree.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/lsyscache.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/selfuncs.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/spccache.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/tuplesort.h"</span> 
 
 
<a name="LN100"></a><span class='Keyword'>#define </span><span class='Declare_Macro'>LOG2</span><span class='Parentheses'>(</span><span class='Declare_Parameter'>x</span><span class='Parentheses'>)</span>  <span class='Parentheses'>(</span>log<span class='Parentheses'>(</span><a href="costsize.c.html#LN100"><span class='Ref_to_Parameter'>x</span></a><span class='Parentheses'>) </span><span class='Operator'>/ </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>693147180559945</span><span class='Parentheses'>)</span> 
 
 
<a name="LN103"></a><span class='Keyword'>double</span>      <span class='Declare_Var'>seq_page_cost</span> <span class='Operator'>= </span><a href="../../../include/optimizer/cost.h.html#LN23"><span class='Ref_to_Const'>DEFAULT_SEQ_PAGE_COST</span></a><span class='Delimiter'>; 
</span><a name="LN104"></a><span class='Keyword'>double</span>      <span class='Declare_Var'>random_page_cost</span> <span class='Operator'>= </span><a href="../../../include/optimizer/cost.h.html#LN24"><span class='Ref_to_Const'>DEFAULT_RANDOM_PAGE_COST</span></a><span class='Delimiter'>; 
</span><a name="LN105"></a><span class='Keyword'>double</span>      <span class='Declare_Var'>cpu_tuple_cost</span> <span class='Operator'>= </span><a href="../../../include/optimizer/cost.h.html#LN25"><span class='Ref_to_Const'>DEFAULT_CPU_TUPLE_COST</span></a><span class='Delimiter'>; 
</span><a name="LN106"></a><span class='Keyword'>double</span>      <span class='Declare_Var'>cpu_index_tuple_cost</span> <span class='Operator'>= </span><a href="../../../include/optimizer/cost.h.html#LN26"><span class='Ref_to_Const'>DEFAULT_CPU_INDEX_TUPLE_COST</span></a><span class='Delimiter'>; 
</span><a name="LN107"></a><span class='Keyword'>double</span>      <span class='Declare_Var'>cpu_operator_cost</span> <span class='Operator'>= </span><a href="../../../include/optimizer/cost.h.html#LN27"><span class='Ref_to_Const'>DEFAULT_CPU_OPERATOR_COST</span></a><span class='Delimiter'>; 
</span><a name="LN108"></a><span class='Keyword'>double</span>      <span class='Declare_Var'>parallel_tuple_cost</span> <span class='Operator'>= </span><a href="../../../include/optimizer/cost.h.html#LN28"><span class='Ref_to_Const'>DEFAULT_PARALLEL_TUPLE_COST</span></a><span class='Delimiter'>; 
</span><a name="LN109"></a><span class='Keyword'>double</span>      <span class='Declare_Var'>parallel_setup_cost</span> <span class='Operator'>= </span><a href="../../../include/optimizer/cost.h.html#LN29"><span class='Ref_to_Const'>DEFAULT_PARALLEL_SETUP_COST</span></a><span class='Delimiter'>; 
</span> 
<a name="LN111"></a><span class='Keyword'>int</span>         <span class='Declare_Var'>effective_cache_size</span> <span class='Operator'>= </span><a href="../../../include/optimizer/cost.h.html#LN31"><span class='Ref_to_Const'>DEFAULT_EFFECTIVE_CACHE_SIZE</span></a><span class='Delimiter'>; 
</span> 
<a name="LN113"></a><a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Var'>disable_cost</span> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0e10</span><span class='Delimiter'>; 
</span> 
<a name="LN115"></a><span class='Keyword'>int</span>         <span class='Declare_Var'>max_parallel_workers_per_gather</span> <span class='Operator'>= </span><span class='Number'>2</span><span class='Delimiter'>; 
</span> 
<a name="LN117"></a><span class='Keyword'>bool</span>        <span class='Declare_Var'>enable_seqscan</span> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span><a name="LN118"></a><span class='Keyword'>bool</span>        <span class='Declare_Var'>enable_indexscan</span> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span><a name="LN119"></a><span class='Keyword'>bool</span>        <span class='Declare_Var'>enable_indexonlyscan</span> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span><a name="LN120"></a><span class='Keyword'>bool</span>        <span class='Declare_Var'>enable_bitmapscan</span> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span><a name="LN121"></a><span class='Keyword'>bool</span>        <span class='Declare_Var'>enable_tidscan</span> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span><a name="LN122"></a><span class='Keyword'>bool</span>        <span class='Declare_Var'>enable_sort</span> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span><a name="LN123"></a><span class='Keyword'>bool</span>        <span class='Declare_Var'>enable_hashagg</span> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span><a name="LN124"></a><span class='Keyword'>bool</span>        <span class='Declare_Var'>enable_nestloop</span> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span><a name="LN125"></a><span class='Keyword'>bool</span>        <span class='Declare_Var'>enable_material</span> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span><a name="LN126"></a><span class='Keyword'>bool</span>        <span class='Declare_Var'>enable_mergejoin</span> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span><a name="LN127"></a><span class='Keyword'>bool</span>        <span class='Declare_Var'>enable_hashjoin</span> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span><a name="LN128"></a><span class='Keyword'>bool</span>        <span class='Declare_Var'>enable_gathermerge</span> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
<span class='Control'>typedef</span> <span class='Control'>struct</span> 
<span class='Delimiter'>{ 
</span><a name="LN132"></a>    <a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Member'>root</span><span class='Delimiter'>; 
</span><a name="LN133"></a>    <a href="../../../include/nodes/relation.h.html#LN42"><span class='Ref_to_Struct'>QualCost</span></a>    <span class='Declare_Member'>total</span><span class='Delimiter'>; 
</span><a name="LN134"></a>} <span class='Declare_Typedef'>cost_qual_eval_context</span><span class='Delimiter'>; 
</span> 
<a name="LN136"></a><span class='Keyword'>static </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>extract_nonindex_conditions</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>qual_clauses</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>indexquals</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN137"></a><span class='Keyword'>static </span><a href="../../../include/nodes/relation.h.html#LN1818"><span class='Ref_to_Struct'>MergeScanSelCache</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>cached_scansel</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN138"></a>               <a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rinfo</span><span class='Delimiter'>, 
</span><a name="LN139"></a>               <a href="../../../include/nodes/relation.h.html#LN845"><span class='Ref_to_Struct'>PathKey</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pathkey</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN140"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>cost_rescan</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Delimiter'>, 
</span><a name="LN141"></a>            <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rescan_startup_cost</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rescan_total_cost</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN142"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>cost_qual_eval_walker</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><a href="costsize.c.html#LN130"><span class='Ref_to_Typedef'>cost_qual_eval_context</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN143"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>get_restriction_qual_cost</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>baserel</span><span class='Delimiter'>, 
</span><a name="LN144"></a>                          <a href="../../../include/nodes/relation.h.html#LN907"><span class='Ref_to_Struct'>ParamPathInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>param_info</span><span class='Delimiter'>, 
</span><a name="LN145"></a>                          <a href="../../../include/nodes/relation.h.html#LN42"><span class='Ref_to_Struct'>QualCost</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>qpqual_cost</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN146"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>has_indexed_join_quals</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1311"><span class='Ref_to_Typedef'>NestPath</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>joinpath</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN147"></a><span class='Keyword'>static double </span><span class='Declare_Prototype'>approx_tuple_count</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1286"><span class='Ref_to_Struct'>JoinPath</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Delimiter'>, 
</span><a name="LN148"></a>                   <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>quals</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN149"></a><span class='Keyword'>static double </span><span class='Declare_Prototype'>calc_joinrel_size_estimate</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN150"></a>                           <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>outer_rel</span><span class='Delimiter'>, 
</span><a name="LN151"></a>                           <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>inner_rel</span><span class='Delimiter'>, 
</span><a name="LN152"></a>                           <span class='Keyword'>double </span><span class='Declare_Parameter'>outer_rows</span><span class='Delimiter'>, 
</span><a name="LN153"></a>                           <span class='Keyword'>double </span><span class='Declare_Parameter'>inner_rows</span><span class='Delimiter'>, 
</span><a name="LN154"></a>                           <a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sjinfo</span><span class='Delimiter'>, 
</span><a name="LN155"></a>                           <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>restrictlist</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN156"></a><span class='Keyword'>static </span><a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Prototype'>get_foreign_key_join_selectivity</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN157"></a>                                 <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Declare_Parameter'>outer_relids</span><span class='Delimiter'>, 
</span><a name="LN158"></a>                                 <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Declare_Parameter'>inner_relids</span><span class='Delimiter'>, 
</span><a name="LN159"></a>                                 <a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sjinfo</span><span class='Delimiter'>, 
</span><a name="LN160"></a>                                 <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>restrictlist</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN161"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>set_rel_width</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN162"></a><span class='Keyword'>static double </span><span class='Declare_Prototype'>relation_byte_size</span><span class='Parentheses'>(</span><span class='Keyword'>double </span><span class='Declare_Parameter'>tuples</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>width</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN163"></a><span class='Keyword'>static double </span><span class='Declare_Prototype'>page_size</span><span class='Parentheses'>(</span><span class='Keyword'>double </span><span class='Declare_Parameter'>tuples</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>width</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN164"></a><span class='Keyword'>static double </span><span class='Declare_Prototype'>get_parallel_divisor</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * clamp_row_est 
 *      Force a row-count estimate to a sane value. 
 */ 
</span><span class='Keyword'>double 
</span><a name="LN172"></a><span class='Declare_Function'>clamp_row_est</span><span class='Parentheses'>(</span><span class='Keyword'>double </span><span class='Declare_Parameter'>nrows</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * Force estimate to be at least one row, to make explain output look 
     * better and to avoid possible divide-by-zero when interpolating costs. 
     * Make it an integer, too. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN172"><span class='Ref_to_Parameter'>nrows</span></a> <span class='Operator'>&LT;= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="costsize.c.html#LN172"><span class='Ref_to_Parameter'>nrows</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="costsize.c.html#LN172"><span class='Ref_to_Parameter'>nrows</span></a> <span class='Operator'>= </span><a href="../../../port/rint.c.html#LN20"><span class='Ref_to_Func'>rint</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN172"><span class='Ref_to_Parameter'>nrows</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="costsize.c.html#LN172"><span class='Ref_to_Parameter'>nrows</span></a><span class='Delimiter'>; 
} 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * cost_seqscan 
 *    Determines and returns the cost of scanning a relation sequentially. 
 * 
 * 'baserel' is the relation to be scanned 
 * 'param_info' is the ParamPathInfo if this is a parameterized path, else NULL 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN196"></a><span class='Declare_Function'>cost_seqscan</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN197"></a>             <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>baserel</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN907"><span class='Ref_to_Struct'>ParamPathInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>param_info</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN199"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>startup_cost</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN200"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>cpu_run_cost</span><span class='Delimiter'>; 
</span><a name="LN201"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>disk_run_cost</span><span class='Delimiter'>; 
</span><a name="LN202"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>spc_seq_page_cost</span><span class='Delimiter'>; 
</span><a name="LN203"></a>    <a href="../../../include/nodes/relation.h.html#LN42"><span class='Ref_to_Struct'>QualCost</span></a>    <span class='Declare_Local'>qpqual_cost</span><span class='Delimiter'>; 
</span><a name="LN204"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>cpu_per_tuple</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Should only be applied to base relations */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN197"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN197"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN554"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/parsenodes.h.html#LN922"><span class='Ref_to_EnumConst'>RTE_RELATION</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Mark the path with the correct row estimate */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN197"><span class='Ref_to_Parameter'>param_info</span></a><span class='Parentheses'>) 
</span>        <a href="costsize.c.html#LN196"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN197"><span class='Ref_to_Parameter'>param_info</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN912"><span class='Ref_to_Member'>ppi_rows</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="costsize.c.html#LN196"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN197"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="costsize.c.html#LN117"><span class='Ref_to_Global_Var'>enable_seqscan</span></a><span class='Parentheses'>) 
</span>        <a href="costsize.c.html#LN199"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN113"><span class='Ref_to_Global_Var'>disable_cost</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* fetch estimated page cost for tablespace containing table */ 
</span>    <a href="../../../include/utils/spccache.h.html#LN15"><span class='Ref_to_Proto'>get_tablespace_page_costs</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN197"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN553"><span class='Ref_to_Member'>reltablespace</span></a><span class='Delimiter'>, 
</span>                              <span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                              <span class='Operator'>&</span><a href="costsize.c.html#LN202"><span class='Ref_To_Local'>spc_seq_page_cost</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * disk costs 
     */ 
</span>    <a href="costsize.c.html#LN201"><span class='Ref_To_Local'>disk_run_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN202"><span class='Ref_To_Local'>spc_seq_page_cost</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN197"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN563"><span class='Ref_to_Member'>pages</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* CPU costs */ 
</span>    <a href="costsize.c.html#LN143"><span class='Ref_to_Proto'>get_restriction_qual_cost</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN196"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN197"><span class='Ref_to_Parameter'>baserel</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN197"><span class='Ref_to_Parameter'>param_info</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="costsize.c.html#LN203"><span class='Ref_To_Local'>qpqual_cost</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN199"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN203"><span class='Ref_To_Local'>qpqual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN204"><span class='Ref_To_Local'>cpu_per_tuple</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN105"><span class='Ref_to_Global_Var'>cpu_tuple_cost</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN203"><span class='Ref_To_Local'>qpqual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN200"><span class='Ref_To_Local'>cpu_run_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN204"><span class='Ref_To_Local'>cpu_per_tuple</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN197"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN564"><span class='Ref_to_Member'>tuples</span></a><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* tlist eval costs are paid per output row, not per tuple scanned */ 
</span>    <a href="costsize.c.html#LN199"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN196"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN953"><span class='Ref_to_Member'>pathtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN884"><span class='Ref_to_Member'>cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN200"><span class='Ref_To_Local'>cpu_run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN196"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN953"><span class='Ref_to_Member'>pathtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN884"><span class='Ref_to_Member'>cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN196"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Adjust costing for parallelism, if used. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN196"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN959"><span class='Ref_to_Member'>parallel_workers</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN242"></a>        <span class='Keyword'>double</span>      <span class='Declare_Local'>parallel_divisor</span> <span class='Operator'>= </span><a href="costsize.c.html#LN164"><span class='Ref_to_Proto'>get_parallel_divisor</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN196"><span class='Ref_to_Parameter'>path</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* The CPU cost is divided among all the workers. */ 
</span>        <a href="costsize.c.html#LN200"><span class='Ref_To_Local'>cpu_run_cost</span></a> <span class='Operator'>/= </span><a href="costsize.c.html#LN242"><span class='Ref_To_Local'>parallel_divisor</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * It may be possible to amortize some of the I/O cost, but probably 
         * not very much, because most operating systems already do aggressive 
         * prefetching.  For now, we assume that the disk run cost can't be 
         * amortized at all. 
         */ 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * In the case of a parallel plan, the row count needs to represent 
         * the number of tuples processed per worker. 
         */ 
</span>        <a href="costsize.c.html#LN196"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/cost.h.html#LN71"><span class='Ref_to_Proto'>clamp_row_est</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN196"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>/ </span><a href="costsize.c.html#LN242"><span class='Ref_To_Local'>parallel_divisor</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if path-&GT;parallel_worker... &raquo; </span> 
 
    <a href="costsize.c.html#LN196"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN199"><span class='Ref_To_Local'>startup_cost</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN196"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN199"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN200"><span class='Ref_To_Local'>cpu_run_cost</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN201"><span class='Ref_To_Local'>disk_run_cost</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end cost_seqscan &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * cost_samplescan 
 *    Determines and returns the cost of scanning a relation using sampling. 
 * 
 * 'baserel' is the relation to be scanned 
 * 'param_info' is the ParamPathInfo if this is a parameterized path, else NULL 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN273"></a><span class='Declare_Function'>cost_samplescan</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN274"></a>                <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>baserel</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN907"><span class='Ref_to_Struct'>ParamPathInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>param_info</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN276"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>startup_cost</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN277"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>run_cost</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN278"></a>    <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span><span class='Delimiter'>; 
</span><a name="LN279"></a>    <a href="../../../include/nodes/parsenodes.h.html#LN1071"><span class='Ref_to_Struct'>TableSampleClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tsc</span><span class='Delimiter'>; 
</span><a name="LN280"></a>    <a href="../../../include/access/tsmapi.h.html#LN54"><span class='Ref_to_Struct'>TsmRoutine</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tsm</span><span class='Delimiter'>; 
</span><a name="LN281"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>spc_seq_page_cost</span><span class='Delimiter'>, 
</span><a name="LN282"></a>                <span class='Declare_Local'>spc_random_page_cost</span><span class='Delimiter'>, 
</span><a name="LN283"></a>                <span class='Declare_Local'>spc_page_cost</span><span class='Delimiter'>; 
</span><a name="LN284"></a>    <a href="../../../include/nodes/relation.h.html#LN42"><span class='Ref_to_Struct'>QualCost</span></a>    <span class='Declare_Local'>qpqual_cost</span><span class='Delimiter'>; 
</span><a name="LN285"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>cpu_per_tuple</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Should only be applied to base relations with tablesample clauses */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN274"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN278"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/relation.h.html#LN324"><span class='Ref_to_Macro'>planner_rt_fetch</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN274"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN273"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN278"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN936"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/parsenodes.h.html#LN922"><span class='Ref_to_EnumConst'>RTE_RELATION</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN279"><span class='Ref_To_Local'>tsc</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN278"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN949"><span class='Ref_to_Member'>tablesample</span></a><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN279"><span class='Ref_To_Local'>tsc</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN280"><span class='Ref_To_Local'>tsm</span></a> <span class='Operator'>= </span><a href="../../access/tablesample/tablesample.c.html#LN25"><span class='Ref_to_Func'>GetTsmRoutine</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN279"><span class='Ref_To_Local'>tsc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1074"><span class='Ref_to_Member'>tsmhandler</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Mark the path with the correct row estimate */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN274"><span class='Ref_to_Parameter'>param_info</span></a><span class='Parentheses'>) 
</span>        <a href="costsize.c.html#LN273"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN274"><span class='Ref_to_Parameter'>param_info</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN912"><span class='Ref_to_Member'>ppi_rows</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="costsize.c.html#LN273"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN274"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* fetch estimated page cost for tablespace containing table */ 
</span>    <a href="../../../include/utils/spccache.h.html#LN15"><span class='Ref_to_Proto'>get_tablespace_page_costs</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN274"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN553"><span class='Ref_to_Member'>reltablespace</span></a><span class='Delimiter'>, 
</span>                              <span class='Operator'>&</span><a href="costsize.c.html#LN282"><span class='Ref_To_Local'>spc_random_page_cost</span></a><span class='Delimiter'>, 
</span>                              <span class='Operator'>&</span><a href="costsize.c.html#LN281"><span class='Ref_To_Local'>spc_seq_page_cost</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* if NextSampleBlock is used, assume random access, else sequential */ 
</span>    <a href="costsize.c.html#LN283"><span class='Ref_To_Local'>spc_page_cost</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="costsize.c.html#LN280"><span class='Ref_To_Local'>tsm</span></a><span class='Operator'>-&GT;</span><a href="../../../include/access/tsmapi.h.html#LN71"><span class='Ref_to_Member'>NextSampleBlock</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) </span><span class='Operator'>? 
</span>        <a href="costsize.c.html#LN282"><span class='Ref_To_Local'>spc_random_page_cost</span></a> <span class='Operator'>: </span><a href="costsize.c.html#LN281"><span class='Ref_To_Local'>spc_seq_page_cost</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * disk costs (recall that baserel-&GT;pages has already been set to the 
     * number of pages the sampling method will visit) 
     */ 
</span>    <a href="costsize.c.html#LN277"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN283"><span class='Ref_To_Local'>spc_page_cost</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN274"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN563"><span class='Ref_to_Member'>pages</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * CPU costs (recall that baserel-&GT;tuples has already been set to the 
     * number of tuples the sampling method will select).  Note that we ignore 
     * execution cost of the TABLESAMPLE parameter expressions; they will be 
     * evaluated only once per scan, and in most usages they'll likely be 
     * simple constants anyway.  We also don't charge anything for the 
     * calculations the sampling method might do internally. 
     */ 
</span>    <a href="costsize.c.html#LN143"><span class='Ref_to_Proto'>get_restriction_qual_cost</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN273"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN274"><span class='Ref_to_Parameter'>baserel</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN274"><span class='Ref_to_Parameter'>param_info</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="costsize.c.html#LN284"><span class='Ref_To_Local'>qpqual_cost</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN276"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN284"><span class='Ref_To_Local'>qpqual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN285"><span class='Ref_To_Local'>cpu_per_tuple</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN105"><span class='Ref_to_Global_Var'>cpu_tuple_cost</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN284"><span class='Ref_To_Local'>qpqual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN277"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN285"><span class='Ref_To_Local'>cpu_per_tuple</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN274"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN564"><span class='Ref_to_Member'>tuples</span></a><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* tlist eval costs are paid per output row, not per tuple scanned */ 
</span>    <a href="costsize.c.html#LN276"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN273"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN953"><span class='Ref_to_Member'>pathtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN884"><span class='Ref_to_Member'>cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN277"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN273"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN953"><span class='Ref_to_Member'>pathtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN884"><span class='Ref_to_Member'>cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN273"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN273"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN276"><span class='Ref_To_Local'>startup_cost</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN273"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN276"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN277"><span class='Ref_To_Local'>run_cost</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end cost_samplescan &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * cost_gather 
 *    Determines and returns the cost of gather path. 
 * 
 * 'rel' is the relation to be operated upon 
 * 'param_info' is the ParamPathInfo if this is a parameterized path, else NULL 
 * 'rows' may be used to point to a row estimate; if non-NULL, it overrides 
 * both 'rel' and 'param_info'.  This is useful when the path doesn't exactly 
 * correspond to any particular RelOptInfo. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN348"></a><span class='Declare_Function'>cost_gather</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1261"><span class='Ref_to_Struct'>GatherPath</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN349"></a>            <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN907"><span class='Ref_to_Struct'>ParamPathInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>param_info</span><span class='Delimiter'>, 
</span><a name="LN350"></a>            <span class='Keyword'>double </span><span class='Operator'>*</span><span class='Declare_Parameter'>rows</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN352"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>startup_cost</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN353"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>run_cost</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Mark the path with the correct row estimate */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN350"><span class='Ref_to_Parameter'>rows</span></a><span class='Parentheses'>) 
</span>        <a href="costsize.c.html#LN348"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1263"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= *</span><a href="costsize.c.html#LN350"><span class='Ref_to_Parameter'>rows</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN349"><span class='Ref_to_Parameter'>param_info</span></a><span class='Parentheses'>) 
</span>        <a href="costsize.c.html#LN348"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1263"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN349"><span class='Ref_to_Parameter'>param_info</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN912"><span class='Ref_to_Member'>ppi_rows</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="costsize.c.html#LN348"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1263"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN349"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN352"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN348"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1264"><span class='Ref_to_Member'>subpath</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN353"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN348"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1264"><span class='Ref_to_Member'>subpath</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>- </span><a href="costsize.c.html#LN348"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1264"><span class='Ref_to_Member'>subpath</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Parallel setup and communication cost. */ 
</span>    <a href="costsize.c.html#LN352"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN109"><span class='Ref_to_Global_Var'>parallel_setup_cost</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN353"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN108"><span class='Ref_to_Global_Var'>parallel_tuple_cost</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN348"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1263"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN348"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1263"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN352"><span class='Ref_To_Local'>startup_cost</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN348"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1263"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="costsize.c.html#LN352"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN353"><span class='Ref_To_Local'>run_cost</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end cost_gather &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * cost_gather_merge 
 *    Determines and returns the cost of gather merge path. 
 * 
 * GatherMerge merges several pre-sorted input streams, using a heap that at 
 * any given instant holds the next tuple from each stream. If there are N 
 * streams, we need about N*log2(N) tuple comparisons to construct the heap at 
 * startup, and then for each output tuple, about log2(N) comparisons to 
 * replace the top heap entry with the next tuple from the same stream. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN386"></a><span class='Declare_Function'>cost_gather_merge</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1274"><span class='Ref_to_Struct'>GatherMergePath</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN387"></a>                  <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN907"><span class='Ref_to_Struct'>ParamPathInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>param_info</span><span class='Delimiter'>, 
</span><a name="LN388"></a>                  <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a> <span class='Declare_Parameter'>input_startup_cost</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a> <span class='Declare_Parameter'>input_total_cost</span><span class='Delimiter'>, 
</span><a name="LN389"></a>                  <span class='Keyword'>double </span><span class='Operator'>*</span><span class='Declare_Parameter'>rows</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN391"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>startup_cost</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN392"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>run_cost</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN393"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>comparison_cost</span><span class='Delimiter'>; 
</span><a name="LN394"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>N</span><span class='Delimiter'>; 
</span><a name="LN395"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>logN</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Mark the path with the correct row estimate */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN389"><span class='Ref_to_Parameter'>rows</span></a><span class='Parentheses'>) 
</span>        <a href="costsize.c.html#LN386"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1276"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= *</span><a href="costsize.c.html#LN389"><span class='Ref_to_Parameter'>rows</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN387"><span class='Ref_to_Parameter'>param_info</span></a><span class='Parentheses'>) 
</span>        <a href="costsize.c.html#LN386"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1276"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN387"><span class='Ref_to_Parameter'>param_info</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN912"><span class='Ref_to_Member'>ppi_rows</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="costsize.c.html#LN386"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1276"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN387"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="costsize.c.html#LN128"><span class='Ref_to_Global_Var'>enable_gathermerge</span></a><span class='Parentheses'>) 
</span>        <a href="costsize.c.html#LN391"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN113"><span class='Ref_to_Global_Var'>disable_cost</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Add one to the number of workers to account for the leader.  This might 
     * be overgenerous since the leader will do less work than other workers 
     * in typical cases, but we'll go with it for now. 
     */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN386"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1278"><span class='Ref_to_Member'>num_workers</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN394"><span class='Ref_To_Local'>N</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN386"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1278"><span class='Ref_to_Member'>num_workers</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN395"><span class='Ref_To_Local'>logN</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN100"><span class='Ref_to_Macro'>LOG2</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN394"><span class='Ref_To_Local'>N</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Assumed cost per tuple comparison */ 
</span>    <a href="costsize.c.html#LN393"><span class='Ref_To_Local'>comparison_cost</span></a> <span class='Operator'>= </span><span class='Number'>2</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>* </span><a href="costsize.c.html#LN107"><span class='Ref_to_Global_Var'>cpu_operator_cost</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Heap creation cost */ 
</span>    <a href="costsize.c.html#LN391"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN393"><span class='Ref_To_Local'>comparison_cost</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN394"><span class='Ref_To_Local'>N</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN395"><span class='Ref_To_Local'>logN</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Per-tuple heap maintenance cost */ 
</span>    <a href="costsize.c.html#LN392"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN386"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1276"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN393"><span class='Ref_To_Local'>comparison_cost</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN395"><span class='Ref_To_Local'>logN</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* small cost for heap management, like cost_merge_append */ 
</span>    <a href="costsize.c.html#LN392"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN107"><span class='Ref_to_Global_Var'>cpu_operator_cost</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN386"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1276"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Parallel setup and communication cost.  Since Gather Merge, unlike 
     * Gather, requires us to block until a tuple is available from every 
     * worker, we bump the IPC cost up a little bit as compared with Gather. 
     * For lack of a better idea, charge an extra 5%. 
     */ 
</span>    <a href="costsize.c.html#LN391"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN109"><span class='Ref_to_Global_Var'>parallel_setup_cost</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN392"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN108"><span class='Ref_to_Global_Var'>parallel_tuple_cost</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN386"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1276"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>* </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>05</span><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN386"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1276"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN391"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN388"><span class='Ref_to_Parameter'>input_startup_cost</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN386"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1276"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="costsize.c.html#LN391"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN392"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN388"><span class='Ref_to_Parameter'>input_total_cost</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end cost_gather_merge &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * cost_index 
 *    Determines and returns the cost of scanning a relation using an index. 
 * 
 * 'path' describes the indexscan under consideration, and is complete 
 *      except for the fields to be set by this routine 
 * 'loop_count' is the number of repetitions of the indexscan to factor into 
 *      estimates of caching behavior 
 * 
 * In addition to rows, startup_cost and total_cost, cost_index() sets the 
 * path's indextotalcost and indexselectivity fields.  These values will be 
 * needed if the IndexPath is used in a BitmapIndexScan. 
 * 
 * NOTE: path-&GT;indexquals must contain only clauses usable as index 
 * restrictions.  Any additional quals evaluated as qpquals may reduce the 
 * number of returned tuples, but they won't reduce the number of tuples 
 * we have to fetch from the table, so they don't reduce the scan cost. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN461"></a><span class='Declare_Function'>cost_index</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1027"><span class='Ref_to_Struct'>IndexPath</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><span class='Keyword'>double </span><span class='Declare_Parameter'>loop_count</span><span class='Delimiter'>, 
</span><a name="LN462"></a>           <span class='Keyword'>bool </span><span class='Declare_Parameter'>partial_path</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN464"></a>    <a href="../../../include/nodes/relation.h.html#LN626"><span class='Ref_to_Struct'>IndexOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>index</span> <span class='Operator'>= </span><a href="costsize.c.html#LN461"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1030"><span class='Ref_to_Member'>indexinfo</span></a><span class='Delimiter'>; 
</span><a name="LN465"></a>    <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>baserel</span> <span class='Operator'>= </span><a href="costsize.c.html#LN464"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN632"><span class='Ref_to_Member'>rel</span></a><span class='Delimiter'>; 
</span><a name="LN466"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>indexonly</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="costsize.c.html#LN461"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1029"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN950"><span class='Ref_to_Member'>pathtype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN56"><span class='Ref_to_EnumConst'>T_IndexOnlyScan</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN467"></a>    <a href="../../../include/access/amapi.h.html#LN91"><span class='Ref_to_Typedef'>amcostestimate_function</span></a> <span class='Declare_Local'>amcostestimate</span><span class='Delimiter'>; 
</span><a name="LN468"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>qpquals</span><span class='Delimiter'>; 
</span><a name="LN469"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>startup_cost</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN470"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>run_cost</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN471"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>cpu_run_cost</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN472"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>indexStartupCost</span><span class='Delimiter'>; 
</span><a name="LN473"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>indexTotalCost</span><span class='Delimiter'>; 
</span><a name="LN474"></a>    <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Local'>indexSelectivity</span><span class='Delimiter'>; 
</span><a name="LN475"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>indexCorrelation</span><span class='Delimiter'>, 
</span><a name="LN476"></a>                <span class='Declare_Local'>csquared</span><span class='Delimiter'>; 
</span><a name="LN477"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>spc_seq_page_cost</span><span class='Delimiter'>, 
</span><a name="LN478"></a>                <span class='Declare_Local'>spc_random_page_cost</span><span class='Delimiter'>; 
</span><a name="LN479"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>min_IO_cost</span><span class='Delimiter'>, 
</span><a name="LN480"></a>                <span class='Declare_Local'>max_IO_cost</span><span class='Delimiter'>; 
</span><a name="LN481"></a>    <a href="../../../include/nodes/relation.h.html#LN42"><span class='Ref_to_Struct'>QualCost</span></a>    <span class='Declare_Local'>qpqual_cost</span><span class='Delimiter'>; 
</span><a name="LN482"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>cpu_per_tuple</span><span class='Delimiter'>; 
</span><a name="LN483"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>tuples_fetched</span><span class='Delimiter'>; 
</span><a name="LN484"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>pages_fetched</span><span class='Delimiter'>; 
</span><a name="LN485"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>rand_heap_pages</span><span class='Delimiter'>; 
</span><a name="LN486"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>index_pages</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Should only be applied to base relations */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN465"><span class='Ref_To_Local'>baserel</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>           <a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN464"><span class='Ref_To_Local'>index</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN626"><span class='Ref_to_Struct'>IndexOptInfo</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN465"><span class='Ref_To_Local'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN465"><span class='Ref_To_Local'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN554"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/parsenodes.h.html#LN922"><span class='Ref_to_EnumConst'>RTE_RELATION</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Mark the path with the correct row estimate, and identify which quals 
     * will need to be enforced as qpquals.  We need not check any quals that 
     * are implied by the index's predicate, so we can use indrestrictinfo not 
     * baserestrictinfo as the list of relevant restriction clauses for the 
     * rel. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN461"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1029"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN955"><span class='Ref_to_Member'>param_info</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="costsize.c.html#LN461"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1029"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN461"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1029"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN955"><span class='Ref_to_Member'>param_info</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN912"><span class='Ref_to_Member'>ppi_rows</span></a><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* qpquals come from the rel's restriction clauses and ppi_clauses */ 
</span>        <a href="costsize.c.html#LN468"><span class='Ref_To_Local'>qpquals</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN219"><span class='Ref_to_Proto'>list_concat</span></a><span class='Parentheses'>(</span> 
                <a href="costsize.c.html#LN136"><span class='Ref_to_Proto'>extract_nonindex_conditions</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN461"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1030"><span class='Ref_to_Member'>indexinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN657"><span class='Ref_to_Member'>indrestrictinfo</span></a><span class='Delimiter'>, 
</span>                                            <a href="costsize.c.html#LN461"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1032"><span class='Ref_to_Member'>indexquals</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>              <a href="costsize.c.html#LN136"><span class='Ref_to_Proto'>extract_nonindex_conditions</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN461"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1029"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN955"><span class='Ref_to_Member'>param_info</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN913"><span class='Ref_to_Member'>ppi_clauses</span></a><span class='Delimiter'>, 
</span>                                          <a href="costsize.c.html#LN461"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1032"><span class='Ref_to_Member'>indexquals</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="costsize.c.html#LN461"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1029"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN465"><span class='Ref_To_Local'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* qpquals come from just the rel's restriction clauses */ 
</span>        <a href="costsize.c.html#LN468"><span class='Ref_To_Local'>qpquals</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN136"><span class='Ref_to_Proto'>extract_nonindex_conditions</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN461"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1030"><span class='Ref_to_Member'>indexinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN657"><span class='Ref_to_Member'>indrestrictinfo</span></a><span class='Delimiter'>, 
</span>                                              <a href="costsize.c.html#LN461"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1032"><span class='Ref_to_Member'>indexquals</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="costsize.c.html#LN118"><span class='Ref_to_Global_Var'>enable_indexscan</span></a><span class='Parentheses'>) 
</span>        <a href="costsize.c.html#LN469"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN113"><span class='Ref_to_Global_Var'>disable_cost</span></a><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* we don't need to check enable_indexonlyscan; indxpath.c does that */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Call index-access-method-specific code to estimate the processing cost 
     * for scanning the index, as well as the selectivity of the index (ie, 
     * the fraction of main-table tuples we will have to retrieve) and its 
     * correlation to the main-table tuple order.  We need a cast here because 
     * relation.h uses a weak function type to avoid including amapi.h. 
     */ 
</span>    <a href="costsize.c.html#LN467"><span class='Ref_To_Local'>amcostestimate</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/access/amapi.h.html#LN91"><span class='Ref_to_Typedef'>amcostestimate_function</span></a><span class='Parentheses'>) </span><a href="costsize.c.html#LN464"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN676"><span class='Ref_to_Member'>amcostestimate</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN467"><span class='Ref_To_Local'>amcostestimate</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN461"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN461"><span class='Ref_to_Parameter'>path</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN461"><span class='Ref_to_Parameter'>loop_count</span></a><span class='Delimiter'>, 
</span>                   <span class='Operator'>&</span><a href="costsize.c.html#LN472"><span class='Ref_To_Local'>indexStartupCost</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="costsize.c.html#LN473"><span class='Ref_To_Local'>indexTotalCost</span></a><span class='Delimiter'>, 
</span>                   <span class='Operator'>&</span><a href="costsize.c.html#LN474"><span class='Ref_To_Local'>indexSelectivity</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="costsize.c.html#LN475"><span class='Ref_To_Local'>indexCorrelation</span></a><span class='Delimiter'>, 
</span>                   <span class='Operator'>&</span><a href="costsize.c.html#LN486"><span class='Ref_To_Local'>index_pages</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Save amcostestimate's results for possible use in bitmap scan planning. 
     * We don't bother to save indexStartupCost or indexCorrelation, because a 
     * bitmap scan doesn't care about either. 
     */ 
</span>    <a href="costsize.c.html#LN461"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1037"><span class='Ref_to_Member'>indextotalcost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN473"><span class='Ref_To_Local'>indexTotalCost</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN461"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1038"><span class='Ref_to_Member'>indexselectivity</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN474"><span class='Ref_To_Local'>indexSelectivity</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* all costs for touching index itself included here */ 
</span>    <a href="costsize.c.html#LN469"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN472"><span class='Ref_To_Local'>indexStartupCost</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN470"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN473"><span class='Ref_To_Local'>indexTotalCost</span></a> <span class='Operator'>- </span><a href="costsize.c.html#LN472"><span class='Ref_To_Local'>indexStartupCost</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* estimate number of main-table tuples fetched */ 
</span>    <a href="costsize.c.html#LN483"><span class='Ref_To_Local'>tuples_fetched</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/cost.h.html#LN71"><span class='Ref_to_Proto'>clamp_row_est</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN474"><span class='Ref_To_Local'>indexSelectivity</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN465"><span class='Ref_To_Local'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN564"><span class='Ref_to_Member'>tuples</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* fetch estimated page costs for tablespace containing table */ 
</span>    <a href="../../../include/utils/spccache.h.html#LN15"><span class='Ref_to_Proto'>get_tablespace_page_costs</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN465"><span class='Ref_To_Local'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN553"><span class='Ref_to_Member'>reltablespace</span></a><span class='Delimiter'>, 
</span>                              <span class='Operator'>&</span><a href="costsize.c.html#LN478"><span class='Ref_To_Local'>spc_random_page_cost</span></a><span class='Delimiter'>, 
</span>                              <span class='Operator'>&</span><a href="costsize.c.html#LN477"><span class='Ref_To_Local'>spc_seq_page_cost</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/*---------- 
     * Estimate number of main-table pages fetched, and compute I/O cost. 
     * 
     * When the index ordering is uncorrelated with the table ordering, 
     * we use an approximation proposed by Mackert and Lohman (see 
     * index_pages_fetched() for details) to compute the number of pages 
     * fetched, and then charge spc_random_page_cost per page fetched. 
     * 
     * When the index ordering is exactly correlated with the table ordering 
     * (just after a CLUSTER, for example), the number of pages fetched should 
     * be exactly selectivity * table_size.  What's more, all but the first 
     * will be sequential fetches, not the random fetches that occur in the 
     * uncorrelated case.  So if the number of pages is more than 1, we 
     * ought to charge 
     *      spc_random_page_cost + (pages_fetched - 1) * spc_seq_page_cost 
     * For partially-correlated indexes, we ought to charge somewhere between 
     * these two estimates.  We currently interpolate linearly between the 
     * estimates based on the correlation squared (XXX is that appropriate?). 
     * 
     * If it's an index-only scan, then we will not need to fetch any heap 
     * pages for which the visibility map shows all tuples are visible. 
     * Hence, reduce the estimated number of heap fetches accordingly. 
     * We use the measured fraction of the entire heap that is all-visible, 
     * which might not be particularly relevant to the subset of the heap 
     * that this query will fetch; but it's not clear how to do better. 
     *---------- 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN461"><span class='Ref_to_Parameter'>loop_count</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * For repeated indexscans, the appropriate estimate for the 
         * uncorrelated case is to scale up the number of tuples fetched in 
         * the Mackert and Lohman formula by the number of scans, so that we 
         * estimate the number of pages fetched by all the scans; then 
         * pro-rate the costs for one scan.  In this case we assume all the 
         * fetches are random accesses. 
         */ 
</span>        <a href="costsize.c.html#LN484"><span class='Ref_To_Local'>pages_fetched</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/cost.h.html#LN72"><span class='Ref_to_Proto'>index_pages_fetched</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN483"><span class='Ref_To_Local'>tuples_fetched</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN461"><span class='Ref_to_Parameter'>loop_count</span></a><span class='Delimiter'>, 
</span>                                            <a href="costsize.c.html#LN465"><span class='Ref_To_Local'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN563"><span class='Ref_to_Member'>pages</span></a><span class='Delimiter'>, 
</span>                                            <span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN464"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN635"><span class='Ref_to_Member'>pages</span></a><span class='Delimiter'>, 
</span>                                            <a href="costsize.c.html#LN461"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN466"><span class='Ref_To_Local'>indexonly</span></a><span class='Parentheses'>) 
</span>            <a href="costsize.c.html#LN484"><span class='Ref_To_Local'>pages_fetched</span></a> <span class='Operator'>= </span>ceil<span class='Parentheses'>(</span><a href="costsize.c.html#LN484"><span class='Ref_To_Local'>pages_fetched</span></a> <span class='Operator'>* </span><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>- </span><a href="costsize.c.html#LN465"><span class='Ref_To_Local'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN565"><span class='Ref_to_Member'>allvisfrac</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <a href="costsize.c.html#LN485"><span class='Ref_To_Local'>rand_heap_pages</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN484"><span class='Ref_To_Local'>pages_fetched</span></a><span class='Delimiter'>; 
</span> 
        <a href="costsize.c.html#LN480"><span class='Ref_To_Local'>max_IO_cost</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="costsize.c.html#LN484"><span class='Ref_To_Local'>pages_fetched</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN478"><span class='Ref_To_Local'>spc_random_page_cost</span></a><span class='Parentheses'>) </span><span class='Operator'>/ </span><a href="costsize.c.html#LN461"><span class='Ref_to_Parameter'>loop_count</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * In the perfectly correlated case, the number of pages touched by 
         * each scan is selectivity * table_size, and we can use the Mackert 
         * and Lohman formula at the page level to estimate how much work is 
         * saved by caching across scans.  We still assume all the fetches are 
         * random, though, which is an overestimate that's hard to correct for 
         * without double-counting the cache effects.  (But in most cases 
         * where such a plan is actually interesting, only one page would get 
         * fetched per scan anyway, so it shouldn't matter much.) 
         */ 
</span>        <a href="costsize.c.html#LN484"><span class='Ref_To_Local'>pages_fetched</span></a> <span class='Operator'>= </span>ceil<span class='Parentheses'>(</span><a href="costsize.c.html#LN474"><span class='Ref_To_Local'>indexSelectivity</span></a> <span class='Operator'>* </span><span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN465"><span class='Ref_To_Local'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN563"><span class='Ref_to_Member'>pages</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="costsize.c.html#LN484"><span class='Ref_To_Local'>pages_fetched</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/cost.h.html#LN72"><span class='Ref_to_Proto'>index_pages_fetched</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN484"><span class='Ref_To_Local'>pages_fetched</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN461"><span class='Ref_to_Parameter'>loop_count</span></a><span class='Delimiter'>, 
</span>                                            <a href="costsize.c.html#LN465"><span class='Ref_To_Local'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN563"><span class='Ref_to_Member'>pages</span></a><span class='Delimiter'>, 
</span>                                            <span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN464"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN635"><span class='Ref_to_Member'>pages</span></a><span class='Delimiter'>, 
</span>                                            <a href="costsize.c.html#LN461"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN466"><span class='Ref_To_Local'>indexonly</span></a><span class='Parentheses'>) 
</span>            <a href="costsize.c.html#LN484"><span class='Ref_To_Local'>pages_fetched</span></a> <span class='Operator'>= </span>ceil<span class='Parentheses'>(</span><a href="costsize.c.html#LN484"><span class='Ref_To_Local'>pages_fetched</span></a> <span class='Operator'>* </span><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>- </span><a href="costsize.c.html#LN465"><span class='Ref_To_Local'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN565"><span class='Ref_to_Member'>allvisfrac</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <a href="costsize.c.html#LN479"><span class='Ref_To_Local'>min_IO_cost</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="costsize.c.html#LN484"><span class='Ref_To_Local'>pages_fetched</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN478"><span class='Ref_To_Local'>spc_random_page_cost</span></a><span class='Parentheses'>) </span><span class='Operator'>/ </span><a href="costsize.c.html#LN461"><span class='Ref_to_Parameter'>loop_count</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if loop_count&GT;1 &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Normal case: apply the Mackert and Lohman formula, and then 
         * interpolate between that and the correlation-derived result. 
         */ 
</span>        <a href="costsize.c.html#LN484"><span class='Ref_To_Local'>pages_fetched</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/cost.h.html#LN72"><span class='Ref_to_Proto'>index_pages_fetched</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN483"><span class='Ref_To_Local'>tuples_fetched</span></a><span class='Delimiter'>, 
</span>                                            <a href="costsize.c.html#LN465"><span class='Ref_To_Local'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN563"><span class='Ref_to_Member'>pages</span></a><span class='Delimiter'>, 
</span>                                            <span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN464"><span class='Ref_To_Local'>index</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN635"><span class='Ref_to_Member'>pages</span></a><span class='Delimiter'>, 
</span>                                            <a href="costsize.c.html#LN461"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN466"><span class='Ref_To_Local'>indexonly</span></a><span class='Parentheses'>) 
</span>            <a href="costsize.c.html#LN484"><span class='Ref_To_Local'>pages_fetched</span></a> <span class='Operator'>= </span>ceil<span class='Parentheses'>(</span><a href="costsize.c.html#LN484"><span class='Ref_To_Local'>pages_fetched</span></a> <span class='Operator'>* </span><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>- </span><a href="costsize.c.html#LN465"><span class='Ref_To_Local'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN565"><span class='Ref_to_Member'>allvisfrac</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <a href="costsize.c.html#LN485"><span class='Ref_To_Local'>rand_heap_pages</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN484"><span class='Ref_To_Local'>pages_fetched</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* max_IO_cost is for the perfectly uncorrelated case (csquared=0) */ 
</span>        <a href="costsize.c.html#LN480"><span class='Ref_To_Local'>max_IO_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN484"><span class='Ref_To_Local'>pages_fetched</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN478"><span class='Ref_To_Local'>spc_random_page_cost</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* min_IO_cost is for the perfectly correlated case (csquared=1) */ 
</span>        <a href="costsize.c.html#LN484"><span class='Ref_To_Local'>pages_fetched</span></a> <span class='Operator'>= </span>ceil<span class='Parentheses'>(</span><a href="costsize.c.html#LN474"><span class='Ref_To_Local'>indexSelectivity</span></a> <span class='Operator'>* </span><span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN465"><span class='Ref_To_Local'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN563"><span class='Ref_to_Member'>pages</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN466"><span class='Ref_To_Local'>indexonly</span></a><span class='Parentheses'>) 
</span>            <a href="costsize.c.html#LN484"><span class='Ref_To_Local'>pages_fetched</span></a> <span class='Operator'>= </span>ceil<span class='Parentheses'>(</span><a href="costsize.c.html#LN484"><span class='Ref_To_Local'>pages_fetched</span></a> <span class='Operator'>* </span><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>- </span><a href="costsize.c.html#LN465"><span class='Ref_To_Local'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN565"><span class='Ref_to_Member'>allvisfrac</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN484"><span class='Ref_To_Local'>pages_fetched</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="costsize.c.html#LN479"><span class='Ref_To_Local'>min_IO_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN478"><span class='Ref_To_Local'>spc_random_page_cost</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN484"><span class='Ref_To_Local'>pages_fetched</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>                <a href="costsize.c.html#LN479"><span class='Ref_To_Local'>min_IO_cost</span></a> <span class='Operator'>+= </span><span class='Parentheses'>(</span><a href="costsize.c.html#LN484"><span class='Ref_To_Local'>pages_fetched</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="costsize.c.html#LN477"><span class='Ref_To_Local'>spc_seq_page_cost</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
            <a href="costsize.c.html#LN479"><span class='Ref_To_Local'>min_IO_cost</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN462"><span class='Ref_to_Parameter'>partial_path</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * For index only scans compute workers based on number of index pages 
         * fetched; the number of heap pages we fetch might be so small as to 
         * effectively rule out parallelism, which we don't want to do. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN466"><span class='Ref_To_Local'>indexonly</span></a><span class='Parentheses'>) 
</span>            <a href="costsize.c.html#LN485"><span class='Ref_To_Local'>rand_heap_pages</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Estimate the number of parallel workers required to scan index. Use 
         * the number of heap pages computed considering heap fetches won't be 
         * sequential as for parallel scans the pages are accessed in random 
         * order. 
         */ 
</span>        <a href="costsize.c.html#LN461"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1029"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN959"><span class='Ref_to_Member'>parallel_workers</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/paths.h.html#LN56"><span class='Ref_to_Proto'>compute_parallel_worker</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN465"><span class='Ref_To_Local'>baserel</span></a><span class='Delimiter'>, 
</span>                                               <a href="costsize.c.html#LN485"><span class='Ref_To_Local'>rand_heap_pages</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN486"><span class='Ref_To_Local'>index_pages</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Fall out if workers can't be assigned for parallel scan, because in 
         * such a case this path will be rejected.  So there is no benefit in 
         * doing extra computation. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN461"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1029"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN959"><span class='Ref_to_Member'>parallel_workers</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
        <a href="costsize.c.html#LN461"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1029"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN957"><span class='Ref_to_Member'>parallel_aware</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if partial_path &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Now interpolate based on estimated index order correlation to get total 
     * disk I/O cost for main table accesses. 
     */ 
</span>    <a href="costsize.c.html#LN476"><span class='Ref_To_Local'>csquared</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN475"><span class='Ref_To_Local'>indexCorrelation</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN475"><span class='Ref_To_Local'>indexCorrelation</span></a><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN470"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN480"><span class='Ref_To_Local'>max_IO_cost</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN476"><span class='Ref_To_Local'>csquared</span></a> <span class='Operator'>* </span><span class='Parentheses'>(</span><a href="costsize.c.html#LN479"><span class='Ref_To_Local'>min_IO_cost</span></a> <span class='Operator'>- </span><a href="costsize.c.html#LN480"><span class='Ref_To_Local'>max_IO_cost</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Estimate CPU costs per tuple. 
     * 
     * What we want here is cpu_tuple_cost plus the evaluation costs of any 
     * qual clauses that we have to evaluate as qpquals. 
     */ 
</span>    <a href="../../../include/optimizer/cost.h.html#LN157"><span class='Ref_to_Proto'>cost_qual_eval</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="costsize.c.html#LN481"><span class='Ref_To_Local'>qpqual_cost</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN468"><span class='Ref_To_Local'>qpquals</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN461"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN469"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN481"><span class='Ref_To_Local'>qpqual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN482"><span class='Ref_To_Local'>cpu_per_tuple</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN105"><span class='Ref_to_Global_Var'>cpu_tuple_cost</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN481"><span class='Ref_To_Local'>qpqual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN471"><span class='Ref_To_Local'>cpu_run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN482"><span class='Ref_To_Local'>cpu_per_tuple</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN483"><span class='Ref_To_Local'>tuples_fetched</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* tlist eval costs are paid per output row, not per tuple scanned */ 
</span>    <a href="costsize.c.html#LN469"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN461"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1029"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN953"><span class='Ref_to_Member'>pathtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN884"><span class='Ref_to_Member'>cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN471"><span class='Ref_To_Local'>cpu_run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN461"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1029"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN953"><span class='Ref_to_Member'>pathtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN884"><span class='Ref_to_Member'>cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN461"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1029"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Adjust costing for parallelism, if used. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN461"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1029"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN959"><span class='Ref_to_Member'>parallel_workers</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN720"></a>        <span class='Keyword'>double</span>      <span class='Declare_Local'>parallel_divisor</span> <span class='Operator'>= </span><a href="costsize.c.html#LN164"><span class='Ref_to_Proto'>get_parallel_divisor</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="costsize.c.html#LN461"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1029"><span class='Ref_to_Member'>path</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="costsize.c.html#LN461"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1029"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/cost.h.html#LN71"><span class='Ref_to_Proto'>clamp_row_est</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN461"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1029"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>/ </span><a href="costsize.c.html#LN720"><span class='Ref_To_Local'>parallel_divisor</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* The CPU cost is divided among all the workers. */ 
</span>        <a href="costsize.c.html#LN471"><span class='Ref_To_Local'>cpu_run_cost</span></a> <span class='Operator'>/= </span><a href="costsize.c.html#LN720"><span class='Ref_To_Local'>parallel_divisor</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="costsize.c.html#LN470"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN471"><span class='Ref_To_Local'>cpu_run_cost</span></a><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN461"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1029"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN469"><span class='Ref_To_Local'>startup_cost</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN461"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1029"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN469"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN470"><span class='Ref_To_Local'>run_cost</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end cost_index &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * extract_nonindex_conditions 
 * 
 * Given a list of quals to be enforced in an indexscan, extract the ones that 
 * will have to be applied as qpquals (ie, the index machinery won't handle 
 * them).  The actual rules for this appear in create_indexscan_plan() in 
 * createplan.c, but the full rules are fairly expensive and we don't want to 
 * go to that much effort for index paths that don't get selected for the 
 * final plan.  So we approximate it as quals that don't appear directly in 
 * indexquals and also are not redundant children of the same EquivalenceClass 
 * as some indexqual.  This method neglects some infrequently-relevant 
 * considerations, specifically clauses that needn't be checked because they 
 * are implied by an indexqual.  It does not seem worth the cycles to try to 
 * factor that in at this stage, even though createplan.c will take pains to 
 * remove such unnecessary clauses from the qpquals list if this path is 
 * selected for use. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN752"></a><span class='Declare_Function'>extract_nonindex_conditions</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>qual_clauses</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>indexquals</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN754"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>result</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN755"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN755"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN752"><span class='Ref_to_Parameter'>qual_clauses</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN759"></a>        <a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rinfo</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN108"><span class='Ref_to_Macro'>lfirst_node</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN755"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN759"><span class='Ref_To_Local'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1754"><span class='Ref_to_Member'>pseudoconstant</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* we may drop pseudoconstants here */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN229"><span class='Ref_to_Proto'>list_member_ptr</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN752"><span class='Ref_to_Parameter'>indexquals</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN759"><span class='Ref_To_Local'>rinfo</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* simple duplicate */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/optimizer/paths.h.html#LN168"><span class='Ref_to_Proto'>is_redundant_derived_clause</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN759"><span class='Ref_To_Local'>rinfo</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN752"><span class='Ref_to_Parameter'>indexquals</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* derived from same EquivalenceClass */ 
</span>        <span class='Comment_Multi_Line'>/* ... skip the predicate proof attempt createplan.c will try ... */ 
</span>        <a href="costsize.c.html#LN754"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN754"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN759"><span class='Ref_To_Local'>rinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <a href="costsize.c.html#LN754"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end extract_nonindex_conditions &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * index_pages_fetched 
 *    Estimate the number of pages actually fetched after accounting for 
 *    cache effects. 
 * 
 * We use an approximation proposed by Mackert and Lohman, "Index Scans 
 * Using a Finite LRU Buffer: A Validated I/O Model", ACM Transactions 
 * on Database Systems, Vol. 14, No. 3, September 1989, Pages 401-424. 
 * The Mackert and Lohman approximation is that the number of pages 
 * fetched is 
 *  PF = 
 *      min(2TNs/(2T+Ns), T)            when T &LT;= b 
 *      2TNs/(2T+Ns)                    when T &GT; b and Ns &LT;= 2Tb/(2T-b) 
 *      b + (Ns - 2Tb/(2T-b))*(T-b)/T   when T &GT; b and Ns &GT; 2Tb/(2T-b) 
 * where 
 *      T = # pages in table 
 *      N = # tuples in table 
 *      s = selectivity = fraction of table to be scanned 
 *      b = # buffer pages available (we include kernel space here) 
 * 
 * We assume that effective_cache_size is the total number of buffer pages 
 * available for the whole query, and pro-rate that space across all the 
 * tables in the query and the index currently under consideration.  (This 
 * ignores space needed for other indexes used by the query, but since we 
 * don't know which indexes will get used, we can't estimate that very well; 
 * and in any case counting all the tables may well be an overestimate, since 
 * depending on the join plan not all the tables may be scanned concurrently.) 
 * 
 * The product Ns is the number of tuples fetched; we pass in that 
 * product rather than calculating it here.  "pages" is the number of pages 
 * in the object under consideration (either an index or a table). 
 * "index_pages" is the amount to add to the total table space, which was 
 * computed for us by query_planner. 
 * 
 * Caller is expected to have ensured that tuples_fetched is greater than zero 
 * and rounded to integer (see clamp_row_est).  The result will likewise be 
 * greater than zero and integral. 
 */ 
</span><span class='Keyword'>double 
</span><a name="LN812"></a><span class='Declare_Function'>index_pages_fetched</span><span class='Parentheses'>(</span><span class='Keyword'>double </span><span class='Declare_Parameter'>tuples_fetched</span><span class='Delimiter'>, </span><a href="../../../include/storage/block.h.html#LN30"><span class='Ref_to_Typedef'>BlockNumber</span></a> <span class='Declare_Parameter'>pages</span><span class='Delimiter'>, 
</span><a name="LN813"></a>                    <span class='Keyword'>double </span><span class='Declare_Parameter'>index_pages</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN815"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>pages_fetched</span><span class='Delimiter'>; 
</span><a name="LN816"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>total_pages</span><span class='Delimiter'>; 
</span><a name="LN817"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>T</span><span class='Delimiter'>, 
</span><a name="LN818"></a>                <span class='Declare_Local'>b</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* T is # pages in table, but don't allow it to be zero */ 
</span>    <a href="costsize.c.html#LN817"><span class='Ref_To_Local'>T</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="costsize.c.html#LN812"><span class='Ref_to_Parameter'>pages</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Parentheses'>) </span><span class='Operator'>? </span><span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN812"><span class='Ref_to_Parameter'>pages</span></a> <span class='Operator'>: </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Compute number of pages assumed to be competing for cache space */ 
</span>    <a href="costsize.c.html#LN816"><span class='Ref_To_Local'>total_pages</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN813"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN288"><span class='Ref_to_Member'>total_table_pages</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN813"><span class='Ref_to_Parameter'>index_pages</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN816"><span class='Ref_To_Local'>total_pages</span></a> <span class='Operator'>= </span><a href="../../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN10"><span class='Ref_to_Macro'>Max</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN816"><span class='Ref_To_Local'>total_pages</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN817"><span class='Ref_To_Local'>T</span></a> <span class='Operator'>&LT;= </span><a href="costsize.c.html#LN816"><span class='Ref_To_Local'>total_pages</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* b is pro-rated share of effective_cache_size */ 
</span>    <a href="costsize.c.html#LN818"><span class='Ref_To_Local'>b</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN111"><span class='Ref_to_Global_Var'>effective_cache_size</span></a> <span class='Operator'>*</span><a href="costsize.c.html#LN817"><span class='Ref_To_Local'>T</span></a> <span class='Operator'>/ </span><a href="costsize.c.html#LN816"><span class='Ref_To_Local'>total_pages</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* force it positive and integral */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN818"><span class='Ref_To_Local'>b</span></a> <span class='Operator'>&LT;= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="costsize.c.html#LN818"><span class='Ref_To_Local'>b</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="costsize.c.html#LN818"><span class='Ref_To_Local'>b</span></a> <span class='Operator'>= </span>ceil<span class='Parentheses'>(</span><a href="costsize.c.html#LN818"><span class='Ref_To_Local'>b</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* This part is the Mackert and Lohman formula */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN817"><span class='Ref_To_Local'>T</span></a> <span class='Operator'>&LT;= </span><a href="costsize.c.html#LN818"><span class='Ref_To_Local'>b</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="costsize.c.html#LN815"><span class='Ref_To_Local'>pages_fetched</span></a> <span class='Operator'>= 
</span>            <span class='Parentheses'>(</span><span class='Number'>2</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>* </span><a href="costsize.c.html#LN817"><span class='Ref_To_Local'>T</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN812"><span class='Ref_to_Parameter'>tuples_fetched</span></a><span class='Parentheses'>) </span><span class='Operator'>/ </span><span class='Parentheses'>(</span><span class='Number'>2</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>* </span><a href="costsize.c.html#LN817"><span class='Ref_To_Local'>T</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN812"><span class='Ref_to_Parameter'>tuples_fetched</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN815"><span class='Ref_To_Local'>pages_fetched</span></a> <span class='Operator'>&GT;= </span><a href="costsize.c.html#LN817"><span class='Ref_To_Local'>T</span></a><span class='Parentheses'>) 
</span>            <a href="costsize.c.html#LN815"><span class='Ref_To_Local'>pages_fetched</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN817"><span class='Ref_To_Local'>T</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="costsize.c.html#LN815"><span class='Ref_To_Local'>pages_fetched</span></a> <span class='Operator'>= </span>ceil<span class='Parentheses'>(</span><a href="costsize.c.html#LN815"><span class='Ref_To_Local'>pages_fetched</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span><a name="LN849"></a>        <span class='Keyword'>double</span>      <span class='Declare_Local'>lim</span><span class='Delimiter'>; 
</span> 
        <a href="costsize.c.html#LN849"><span class='Ref_To_Local'>lim</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Number'>2</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>* </span><a href="costsize.c.html#LN817"><span class='Ref_To_Local'>T</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN818"><span class='Ref_To_Local'>b</span></a><span class='Parentheses'>) </span><span class='Operator'>/ </span><span class='Parentheses'>(</span><span class='Number'>2</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>* </span><a href="costsize.c.html#LN817"><span class='Ref_To_Local'>T</span></a> <span class='Operator'>- </span><a href="costsize.c.html#LN818"><span class='Ref_To_Local'>b</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN812"><span class='Ref_to_Parameter'>tuples_fetched</span></a> <span class='Operator'>&LT;= </span><a href="costsize.c.html#LN849"><span class='Ref_To_Local'>lim</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="costsize.c.html#LN815"><span class='Ref_To_Local'>pages_fetched</span></a> <span class='Operator'>= 
</span>                <span class='Parentheses'>(</span><span class='Number'>2</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>* </span><a href="costsize.c.html#LN817"><span class='Ref_To_Local'>T</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN812"><span class='Ref_to_Parameter'>tuples_fetched</span></a><span class='Parentheses'>) </span><span class='Operator'>/ </span><span class='Parentheses'>(</span><span class='Number'>2</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>* </span><a href="costsize.c.html#LN817"><span class='Ref_To_Local'>T</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN812"><span class='Ref_to_Parameter'>tuples_fetched</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <a href="costsize.c.html#LN815"><span class='Ref_To_Local'>pages_fetched</span></a> <span class='Operator'>= 
</span>                <a href="costsize.c.html#LN818"><span class='Ref_To_Local'>b</span></a> <span class='Operator'>+ </span><span class='Parentheses'>(</span><a href="costsize.c.html#LN812"><span class='Ref_to_Parameter'>tuples_fetched</span></a> <span class='Operator'>- </span><a href="costsize.c.html#LN849"><span class='Ref_To_Local'>lim</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><span class='Parentheses'>(</span><a href="costsize.c.html#LN817"><span class='Ref_To_Local'>T</span></a> <span class='Operator'>- </span><a href="costsize.c.html#LN818"><span class='Ref_To_Local'>b</span></a><span class='Parentheses'>) </span><span class='Operator'>/ </span><a href="costsize.c.html#LN817"><span class='Ref_To_Local'>T</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <a href="costsize.c.html#LN815"><span class='Ref_To_Local'>pages_fetched</span></a> <span class='Operator'>= </span>ceil<span class='Parentheses'>(</span><a href="costsize.c.html#LN815"><span class='Ref_To_Local'>pages_fetched</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <a href="costsize.c.html#LN815"><span class='Ref_To_Local'>pages_fetched</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end index_pages_fetched &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * get_indexpath_pages 
 *      Determine the total size of the indexes used in a bitmap index path. 
 * 
 * Note: if the same index is used more than once in a bitmap tree, we will 
 * count it multiple times, which perhaps is the wrong thing ... but it's 
 * not completely clear, and detecting duplicates is difficult, so ignore it 
 * for now. 
 */ 
</span><span class='Keyword'>static double 
</span><a name="LN877"></a><span class='Declare_Function'>get_indexpath_pages</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>bitmapqual</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN879"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>result</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN880"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN877"><span class='Ref_to_Parameter'>bitmapqual</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1070"><span class='Ref_to_Struct'>BitmapAndPath</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN884"></a>        <a href="../../../include/nodes/relation.h.html#LN1070"><span class='Ref_to_Struct'>BitmapAndPath</span></a> <span class='Operator'>*</span><span class='Declare_Local'>apath</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1070"><span class='Ref_to_Struct'>BitmapAndPath</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN877"><span class='Ref_to_Parameter'>bitmapqual</span></a><span class='Delimiter'>; 
</span> 
        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN880"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN884"><span class='Ref_To_Local'>apath</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1073"><span class='Ref_to_Member'>bitmapquals</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="costsize.c.html#LN879"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN876"><span class='Ref_to_Func'>get_indexpath_pages</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN880"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN877"><span class='Ref_to_Parameter'>bitmapqual</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1083"><span class='Ref_to_Struct'>BitmapOrPath</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN893"></a>        <a href="../../../include/nodes/relation.h.html#LN1083"><span class='Ref_to_Struct'>BitmapOrPath</span></a> <span class='Operator'>*</span><span class='Declare_Local'>opath</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1083"><span class='Ref_to_Struct'>BitmapOrPath</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN877"><span class='Ref_to_Parameter'>bitmapqual</span></a><span class='Delimiter'>; 
</span> 
        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN880"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN893"><span class='Ref_To_Local'>opath</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1086"><span class='Ref_to_Member'>bitmapquals</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="costsize.c.html#LN879"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN876"><span class='Ref_to_Func'>get_indexpath_pages</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN880"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN877"><span class='Ref_to_Parameter'>bitmapqual</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1027"><span class='Ref_to_Struct'>IndexPath</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN902"></a>        <a href="../../../include/nodes/relation.h.html#LN1027"><span class='Ref_to_Struct'>IndexPath</span></a>  <span class='Operator'>*</span><span class='Declare_Local'>ipath</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1027"><span class='Ref_to_Struct'>IndexPath</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN877"><span class='Ref_to_Parameter'>bitmapqual</span></a><span class='Delimiter'>; 
</span> 
        <a href="costsize.c.html#LN879"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN902"><span class='Ref_To_Local'>ipath</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1030"><span class='Ref_to_Member'>indexinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN635"><span class='Ref_to_Member'>pages</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized node type: %d"</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN513"><span class='Ref_to_Macro'>nodeTag</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN877"><span class='Ref_to_Parameter'>bitmapqual</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="costsize.c.html#LN879"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end get_indexpath_pages &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * cost_bitmap_heap_scan 
 *    Determines and returns the cost of scanning a relation using a bitmap 
 *    index-then-heap plan. 
 * 
 * 'baserel' is the relation to be scanned 
 * 'param_info' is the ParamPathInfo if this is a parameterized path, else NULL 
 * 'bitmapqual' is a tree of IndexPaths, BitmapAndPaths, and BitmapOrPaths 
 * 'loop_count' is the number of repetitions of the indexscan to factor into 
 *      estimates of caching behavior 
 * 
 * Note: the component IndexPaths in bitmapqual should have been costed 
 * using the same loop_count. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN927"></a><span class='Declare_Function'>cost_bitmap_heap_scan</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>baserel</span><span class='Delimiter'>, 
</span><a name="LN928"></a>                      <a href="../../../include/nodes/relation.h.html#LN907"><span class='Ref_to_Struct'>ParamPathInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>param_info</span><span class='Delimiter'>, 
</span><a name="LN929"></a>                      <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>bitmapqual</span><span class='Delimiter'>, </span><span class='Keyword'>double </span><span class='Declare_Parameter'>loop_count</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN931"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>startup_cost</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN932"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>run_cost</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN933"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>indexTotalCost</span><span class='Delimiter'>; 
</span><a name="LN934"></a>    <a href="../../../include/nodes/relation.h.html#LN42"><span class='Ref_to_Struct'>QualCost</span></a>    <span class='Declare_Local'>qpqual_cost</span><span class='Delimiter'>; 
</span><a name="LN935"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>cpu_per_tuple</span><span class='Delimiter'>; 
</span><a name="LN936"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>cost_per_page</span><span class='Delimiter'>; 
</span><a name="LN937"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>cpu_run_cost</span><span class='Delimiter'>; 
</span><a name="LN938"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>tuples_fetched</span><span class='Delimiter'>; 
</span><a name="LN939"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>pages_fetched</span><span class='Delimiter'>; 
</span><a name="LN940"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>spc_seq_page_cost</span><span class='Delimiter'>, 
</span><a name="LN941"></a>                <span class='Declare_Local'>spc_random_page_cost</span><span class='Delimiter'>; 
</span><a name="LN942"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>T</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Should only be applied to base relations */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN927"><span class='Ref_to_Parameter'>baserel</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN927"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN927"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN554"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/parsenodes.h.html#LN922"><span class='Ref_to_EnumConst'>RTE_RELATION</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Mark the path with the correct row estimate */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN928"><span class='Ref_to_Parameter'>param_info</span></a><span class='Parentheses'>) 
</span>        <a href="costsize.c.html#LN927"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN928"><span class='Ref_to_Parameter'>param_info</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN912"><span class='Ref_to_Member'>ppi_rows</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="costsize.c.html#LN927"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN927"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="costsize.c.html#LN120"><span class='Ref_to_Global_Var'>enable_bitmapscan</span></a><span class='Parentheses'>) 
</span>        <a href="costsize.c.html#LN931"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN113"><span class='Ref_to_Global_Var'>disable_cost</span></a><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN939"><span class='Ref_To_Local'>pages_fetched</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/cost.h.html#LN190"><span class='Ref_to_Proto'>compute_bitmap_pages</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN927"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN927"><span class='Ref_to_Parameter'>baserel</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN929"><span class='Ref_to_Parameter'>bitmapqual</span></a><span class='Delimiter'>, 
</span>                                         <a href="costsize.c.html#LN929"><span class='Ref_to_Parameter'>loop_count</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="costsize.c.html#LN933"><span class='Ref_To_Local'>indexTotalCost</span></a><span class='Delimiter'>, 
</span>                                         <span class='Operator'>&</span><a href="costsize.c.html#LN938"><span class='Ref_To_Local'>tuples_fetched</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN931"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN933"><span class='Ref_To_Local'>indexTotalCost</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN942"><span class='Ref_To_Local'>T</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="costsize.c.html#LN927"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN563"><span class='Ref_to_Member'>pages</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Parentheses'>) </span><span class='Operator'>? </span><span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN927"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN563"><span class='Ref_to_Member'>pages</span></a> <span class='Operator'>: </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Fetch estimated page costs for tablespace containing table. */ 
</span>    <a href="../../../include/utils/spccache.h.html#LN15"><span class='Ref_to_Proto'>get_tablespace_page_costs</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN927"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN553"><span class='Ref_to_Member'>reltablespace</span></a><span class='Delimiter'>, 
</span>                              <span class='Operator'>&</span><a href="costsize.c.html#LN941"><span class='Ref_To_Local'>spc_random_page_cost</span></a><span class='Delimiter'>, 
</span>                              <span class='Operator'>&</span><a href="costsize.c.html#LN940"><span class='Ref_To_Local'>spc_seq_page_cost</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * For small numbers of pages we should charge spc_random_page_cost 
     * apiece, while if nearly all the table's pages are being read, it's more 
     * appropriate to charge spc_seq_page_cost apiece.  The effect is 
     * nonlinear, too. For lack of a better idea, interpolate like this to 
     * determine the cost per page. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN939"><span class='Ref_To_Local'>pages_fetched</span></a> <span class='Operator'>&GT;= </span><span class='Number'>2</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="costsize.c.html#LN936"><span class='Ref_To_Local'>cost_per_page</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN941"><span class='Ref_To_Local'>spc_random_page_cost</span></a> <span class='Operator'>- 
</span>            <span class='Parentheses'>(</span><a href="costsize.c.html#LN941"><span class='Ref_To_Local'>spc_random_page_cost</span></a> <span class='Operator'>- </span><a href="costsize.c.html#LN940"><span class='Ref_To_Local'>spc_seq_page_cost</span></a><span class='Parentheses'>) 
</span>            <span class='Operator'>* </span>sqrt<span class='Parentheses'>(</span><a href="costsize.c.html#LN939"><span class='Ref_To_Local'>pages_fetched</span></a> <span class='Operator'>/ </span><a href="costsize.c.html#LN942"><span class='Ref_To_Local'>T</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="costsize.c.html#LN936"><span class='Ref_To_Local'>cost_per_page</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN941"><span class='Ref_To_Local'>spc_random_page_cost</span></a><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN932"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN939"><span class='Ref_To_Local'>pages_fetched</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN936"><span class='Ref_To_Local'>cost_per_page</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Estimate CPU costs per tuple. 
     * 
     * Often the indexquals don't need to be rechecked at each tuple ... but 
     * not always, especially not if there are enough tuples involved that the 
     * bitmaps become lossy.  For the moment, just assume they will be 
     * rechecked always.  This means we charge the full freight for all the 
     * scan clauses. 
     */ 
</span>    <a href="costsize.c.html#LN143"><span class='Ref_to_Proto'>get_restriction_qual_cost</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN927"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN927"><span class='Ref_to_Parameter'>baserel</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN928"><span class='Ref_to_Parameter'>param_info</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="costsize.c.html#LN934"><span class='Ref_To_Local'>qpqual_cost</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN931"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN934"><span class='Ref_To_Local'>qpqual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN935"><span class='Ref_To_Local'>cpu_per_tuple</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN105"><span class='Ref_to_Global_Var'>cpu_tuple_cost</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN934"><span class='Ref_To_Local'>qpqual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN937"><span class='Ref_To_Local'>cpu_run_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN935"><span class='Ref_To_Local'>cpu_per_tuple</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN938"><span class='Ref_To_Local'>tuples_fetched</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Adjust costing for parallelism, if used. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN927"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN959"><span class='Ref_to_Member'>parallel_workers</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1004"></a>        <span class='Keyword'>double</span>      <span class='Declare_Local'>parallel_divisor</span> <span class='Operator'>= </span><a href="costsize.c.html#LN164"><span class='Ref_to_Proto'>get_parallel_divisor</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN927"><span class='Ref_to_Parameter'>path</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* The CPU cost is divided among all the workers. */ 
</span>        <a href="costsize.c.html#LN937"><span class='Ref_To_Local'>cpu_run_cost</span></a> <span class='Operator'>/= </span><a href="costsize.c.html#LN1004"><span class='Ref_To_Local'>parallel_divisor</span></a><span class='Delimiter'>; 
</span> 
        <a href="costsize.c.html#LN927"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/cost.h.html#LN71"><span class='Ref_to_Proto'>clamp_row_est</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN927"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>/ </span><a href="costsize.c.html#LN1004"><span class='Ref_To_Local'>parallel_divisor</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
 
    <a href="costsize.c.html#LN932"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN937"><span class='Ref_To_Local'>cpu_run_cost</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* tlist eval costs are paid per output row, not per tuple scanned */ 
</span>    <a href="costsize.c.html#LN931"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN927"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN953"><span class='Ref_to_Member'>pathtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN884"><span class='Ref_to_Member'>cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN932"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN927"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN953"><span class='Ref_to_Member'>pathtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN884"><span class='Ref_to_Member'>cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN927"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN927"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN931"><span class='Ref_To_Local'>startup_cost</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN927"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN931"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN932"><span class='Ref_To_Local'>run_cost</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end cost_bitmap_heap_scan &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * cost_bitmap_tree_node 
 *      Extract cost and selectivity from a bitmap tree node (index/and/or) 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1028"></a><span class='Declare_Function'>cost_bitmap_tree_node</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>cost</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>selec</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN1028"><span class='Ref_to_Parameter'>path</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1027"><span class='Ref_to_Struct'>IndexPath</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Operator'>*</span><a href="costsize.c.html#LN1028"><span class='Ref_to_Parameter'>cost</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/relation.h.html#LN1027"><span class='Ref_to_Struct'>IndexPath</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN1028"><span class='Ref_to_Parameter'>path</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>indextotalcost<span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="costsize.c.html#LN1028"><span class='Ref_to_Parameter'>selec</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/relation.h.html#LN1027"><span class='Ref_to_Struct'>IndexPath</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN1028"><span class='Ref_to_Parameter'>path</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>indexselectivity<span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Charge a small amount per retrieved tuple to reflect the costs of 
         * manipulating the bitmap.  This is mostly to make sure that a bitmap 
         * scan doesn't look to be the same cost as an indexscan to retrieve a 
         * single tuple. 
         */ 
</span>        <span class='Operator'>*</span><a href="costsize.c.html#LN1028"><span class='Ref_to_Parameter'>cost</span></a> <span class='Operator'>+= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>1</span> <span class='Operator'>* </span><a href="costsize.c.html#LN107"><span class='Ref_to_Global_Var'>cpu_operator_cost</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN1028"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN1028"><span class='Ref_to_Parameter'>path</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1070"><span class='Ref_to_Struct'>BitmapAndPath</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Operator'>*</span><a href="costsize.c.html#LN1028"><span class='Ref_to_Parameter'>cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1028"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="costsize.c.html#LN1028"><span class='Ref_to_Parameter'>selec</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/relation.h.html#LN1070"><span class='Ref_to_Struct'>BitmapAndPath</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN1028"><span class='Ref_to_Parameter'>path</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>bitmapselectivity<span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN1028"><span class='Ref_to_Parameter'>path</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1083"><span class='Ref_to_Struct'>BitmapOrPath</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Operator'>*</span><a href="costsize.c.html#LN1028"><span class='Ref_to_Parameter'>cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1028"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="costsize.c.html#LN1028"><span class='Ref_to_Parameter'>selec</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/relation.h.html#LN1083"><span class='Ref_to_Struct'>BitmapOrPath</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN1028"><span class='Ref_to_Parameter'>path</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>bitmapselectivity<span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized node type: %d"</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN513"><span class='Ref_to_Macro'>nodeTag</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN1028"><span class='Ref_to_Parameter'>path</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="costsize.c.html#LN1028"><span class='Ref_to_Parameter'>cost</span></a> <span class='Operator'>= *</span><a href="costsize.c.html#LN1028"><span class='Ref_to_Parameter'>selec</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* keep compiler quiet */ 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end cost_bitmap_tree_node &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * cost_bitmap_and_node 
 *      Estimate the cost of a BitmapAnd node 
 * 
 * Note that this considers only the costs of index scanning and bitmap 
 * creation, not the eventual heap access.  In that sense the object isn't 
 * truly a Path, but it has enough path-like properties (costs in particular) 
 * to warrant treating it as one.  We don't bother to set the path rows field, 
 * however. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1071"></a><span class='Declare_Function'>cost_bitmap_and_node</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1070"><span class='Ref_to_Struct'>BitmapAndPath</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1073"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>totalCost</span><span class='Delimiter'>; 
</span><a name="LN1074"></a>    <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Local'>selec</span><span class='Delimiter'>; 
</span><a name="LN1075"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We estimate AND selectivity on the assumption that the inputs are 
     * independent.  This is probably often wrong, but we don't have the info 
     * to do better. 
     * 
     * The runtime cost of the BitmapAnd itself is estimated at 100x 
     * cpu_operator_cost for each tbm_intersect needed.  Probably too small, 
     * definitely too simplistic? 
     */ 
</span>    <a href="costsize.c.html#LN1073"><span class='Ref_To_Local'>totalCost</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1074"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN1075"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN1071"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1073"><span class='Ref_to_Member'>bitmapquals</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1090"></a>        <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>subpath</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN1075"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1091"></a>        <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>subCost</span><span class='Delimiter'>; 
</span><a name="LN1092"></a>        <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Local'>subselec</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/optimizer/cost.h.html#LN85"><span class='Ref_to_Proto'>cost_bitmap_tree_node</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN1090"><span class='Ref_To_Local'>subpath</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="costsize.c.html#LN1091"><span class='Ref_To_Local'>subCost</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="costsize.c.html#LN1092"><span class='Ref_To_Local'>subselec</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="costsize.c.html#LN1074"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>*= </span><a href="costsize.c.html#LN1092"><span class='Ref_To_Local'>subselec</span></a><span class='Delimiter'>; 
</span> 
        <a href="costsize.c.html#LN1073"><span class='Ref_To_Local'>totalCost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1091"><span class='Ref_To_Local'>subCost</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN1075"><span class='Ref_To_Local'>l</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN1071"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1073"><span class='Ref_to_Member'>bitmapquals</span></a><span class='Parentheses'>))</span> 
            <a href="costsize.c.html#LN1073"><span class='Ref_To_Local'>totalCost</span></a> <span class='Operator'>+= </span><span class='Number'>100</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>* </span><a href="costsize.c.html#LN107"><span class='Ref_to_Global_Var'>cpu_operator_cost</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="costsize.c.html#LN1071"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1074"><span class='Ref_to_Member'>bitmapselectivity</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1074"><span class='Ref_To_Local'>selec</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1071"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1072"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* per above, not used */ 
</span>    <a href="costsize.c.html#LN1071"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1072"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1073"><span class='Ref_To_Local'>totalCost</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1071"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1072"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1073"><span class='Ref_To_Local'>totalCost</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end cost_bitmap_and_node &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * cost_bitmap_or_node 
 *      Estimate the cost of a BitmapOr node 
 * 
 * See comments for cost_bitmap_and_node. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1115"></a><span class='Declare_Function'>cost_bitmap_or_node</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1083"><span class='Ref_to_Struct'>BitmapOrPath</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1117"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>totalCost</span><span class='Delimiter'>; 
</span><a name="LN1118"></a>    <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Local'>selec</span><span class='Delimiter'>; 
</span><a name="LN1119"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We estimate OR selectivity on the assumption that the inputs are 
     * non-overlapping, since that's often the case in "x IN (list)" type 
     * situations.  Of course, we clamp to 1.0 at the end. 
     * 
     * The runtime cost of the BitmapOr itself is estimated at 100x 
     * cpu_operator_cost for each tbm_union needed.  Probably too small, 
     * definitely too simplistic?  We are aware that the tbm_unions are 
     * optimized out when the inputs are BitmapIndexScans. 
     */ 
</span>    <a href="costsize.c.html#LN1117"><span class='Ref_To_Local'>totalCost</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1118"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN1119"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN1115"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1086"><span class='Ref_to_Member'>bitmapquals</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1135"></a>        <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>subpath</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN1119"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1136"></a>        <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>subCost</span><span class='Delimiter'>; 
</span><a name="LN1137"></a>        <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Local'>subselec</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/optimizer/cost.h.html#LN85"><span class='Ref_to_Proto'>cost_bitmap_tree_node</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN1135"><span class='Ref_To_Local'>subpath</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="costsize.c.html#LN1136"><span class='Ref_To_Local'>subCost</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="costsize.c.html#LN1137"><span class='Ref_To_Local'>subselec</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="costsize.c.html#LN1118"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1137"><span class='Ref_To_Local'>subselec</span></a><span class='Delimiter'>; 
</span> 
        <a href="costsize.c.html#LN1117"><span class='Ref_To_Local'>totalCost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1136"><span class='Ref_To_Local'>subCost</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN1119"><span class='Ref_To_Local'>l</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN1115"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1086"><span class='Ref_to_Member'>bitmapquals</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>            <span class='Operator'>!</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN1135"><span class='Ref_To_Local'>subpath</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1027"><span class='Ref_to_Struct'>IndexPath</span></a><span class='Parentheses'>))</span> 
            <a href="costsize.c.html#LN1117"><span class='Ref_To_Local'>totalCost</span></a> <span class='Operator'>+= </span><span class='Number'>100</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>* </span><a href="costsize.c.html#LN107"><span class='Ref_to_Global_Var'>cpu_operator_cost</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <a href="costsize.c.html#LN1115"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1087"><span class='Ref_to_Member'>bitmapselectivity</span></a> <span class='Operator'>= </span><a href="../../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN11"><span class='Ref_to_Macro'>Min</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN1118"><span class='Ref_To_Local'>selec</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1115"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1085"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* per above, not used */ 
</span>    <a href="costsize.c.html#LN1115"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1085"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1117"><span class='Ref_To_Local'>totalCost</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1115"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1085"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1117"><span class='Ref_To_Local'>totalCost</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end cost_bitmap_or_node &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * cost_tidscan 
 *    Determines and returns the cost of scanning a relation using TIDs. 
 * 
 * 'baserel' is the relation to be scanned 
 * 'tidquals' is the list of TID-checkable quals 
 * 'param_info' is the ParamPathInfo if this is a parameterized path, else NULL 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1163"></a><span class='Declare_Function'>cost_tidscan</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN1164"></a>             <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>baserel</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>tidquals</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN907"><span class='Ref_to_Struct'>ParamPathInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>param_info</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1166"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>startup_cost</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN1167"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>run_cost</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN1168"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>isCurrentOf</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN1169"></a>    <a href="../../../include/nodes/relation.h.html#LN42"><span class='Ref_to_Struct'>QualCost</span></a>    <span class='Declare_Local'>qpqual_cost</span><span class='Delimiter'>; 
</span><a name="LN1170"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>cpu_per_tuple</span><span class='Delimiter'>; 
</span><a name="LN1171"></a>    <a href="../../../include/nodes/relation.h.html#LN42"><span class='Ref_to_Struct'>QualCost</span></a>    <span class='Declare_Local'>tid_qual_cost</span><span class='Delimiter'>; 
</span><a name="LN1172"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>ntuples</span><span class='Delimiter'>; 
</span><a name="LN1173"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span><a name="LN1174"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>spc_random_page_cost</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Should only be applied to base relations */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN1164"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN1164"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN554"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/parsenodes.h.html#LN922"><span class='Ref_to_EnumConst'>RTE_RELATION</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Mark the path with the correct row estimate */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN1164"><span class='Ref_to_Parameter'>param_info</span></a><span class='Parentheses'>) 
</span>        <a href="costsize.c.html#LN1163"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1164"><span class='Ref_to_Parameter'>param_info</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN912"><span class='Ref_to_Member'>ppi_rows</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="costsize.c.html#LN1163"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1164"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Count how many tuples we expect to retrieve */ 
</span>    <a href="costsize.c.html#LN1172"><span class='Ref_To_Local'>ntuples</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN1173"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN1164"><span class='Ref_to_Parameter'>tidquals</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN1173"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN534"><span class='Ref_to_Struct'>ScalarArrayOpExpr</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Each element of the array yields 1 tuple */ 
</span><a name="LN1193"></a>            <a href="../../../include/nodes/primnodes.h.html#LN534"><span class='Ref_to_Struct'>ScalarArrayOpExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>saop</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN534"><span class='Ref_to_Struct'>ScalarArrayOpExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN1173"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1194"></a>            <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>arraynode</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN115"><span class='Ref_to_Macro'>lsecond</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN1193"><span class='Ref_To_Local'>saop</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN541"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="costsize.c.html#LN1172"><span class='Ref_To_Local'>ntuples</span></a> <span class='Operator'>+= </span><a href="../../../include/utils/selfuncs.h.html#LN195"><span class='Ref_to_Proto'>estimate_array_length</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN1194"><span class='Ref_To_Local'>arraynode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN1173"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN1272"><span class='Ref_to_Struct'>CurrentOfExpr</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* CURRENT OF yields 1 tuple */ 
</span>            <a href="costsize.c.html#LN1168"><span class='Ref_To_Local'>isCurrentOf</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <a href="costsize.c.html#LN1172"><span class='Ref_To_Local'>ntuples</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* It's just CTID = something, count 1 tuple */ 
</span>            <a href="costsize.c.html#LN1172"><span class='Ref_To_Local'>ntuples</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We must force TID scan for WHERE CURRENT OF, because only nodeTidscan.c 
     * understands how to do it correctly.  Therefore, honor enable_tidscan 
     * only when CURRENT OF isn't present.  Also note that cost_qual_eval 
     * counts a CurrentOfExpr as having startup cost disable_cost, which we 
     * subtract off here; that's to prevent other plan types such as seqscan 
     * from winning. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN1168"><span class='Ref_To_Local'>isCurrentOf</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN1164"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN585"><span class='Ref_to_Member'>baserestrictcost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a> <span class='Operator'>&GT;= </span><a href="costsize.c.html#LN113"><span class='Ref_to_Global_Var'>disable_cost</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN1166"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>-= </span><a href="costsize.c.html#LN113"><span class='Ref_to_Global_Var'>disable_cost</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="costsize.c.html#LN121"><span class='Ref_to_Global_Var'>enable_tidscan</span></a><span class='Parentheses'>) 
</span>        <a href="costsize.c.html#LN1166"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN113"><span class='Ref_to_Global_Var'>disable_cost</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * The TID qual expressions will be computed once, any other baserestrict 
     * quals once per retrieved tuple. 
     */ 
</span>    <a href="../../../include/optimizer/cost.h.html#LN157"><span class='Ref_to_Proto'>cost_qual_eval</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="costsize.c.html#LN1171"><span class='Ref_To_Local'>tid_qual_cost</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN1164"><span class='Ref_to_Parameter'>tidquals</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN1163"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* fetch estimated page cost for tablespace containing table */ 
</span>    <a href="../../../include/utils/spccache.h.html#LN15"><span class='Ref_to_Proto'>get_tablespace_page_costs</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN1164"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN553"><span class='Ref_to_Member'>reltablespace</span></a><span class='Delimiter'>, 
</span>                              <span class='Operator'>&</span><a href="costsize.c.html#LN1174"><span class='Ref_To_Local'>spc_random_page_cost</span></a><span class='Delimiter'>, 
</span>                              <span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* disk costs --- assume each tuple on a different page */ 
</span>    <a href="costsize.c.html#LN1167"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1174"><span class='Ref_To_Local'>spc_random_page_cost</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN1172"><span class='Ref_To_Local'>ntuples</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Add scanning CPU costs */ 
</span>    <a href="costsize.c.html#LN143"><span class='Ref_to_Proto'>get_restriction_qual_cost</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN1163"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN1164"><span class='Ref_to_Parameter'>baserel</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN1164"><span class='Ref_to_Parameter'>param_info</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="costsize.c.html#LN1169"><span class='Ref_To_Local'>qpqual_cost</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* XXX currently we assume TID quals are a subset of qpquals */ 
</span>    <a href="costsize.c.html#LN1166"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1169"><span class='Ref_To_Local'>qpqual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN1171"><span class='Ref_To_Local'>tid_qual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1170"><span class='Ref_To_Local'>cpu_per_tuple</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN105"><span class='Ref_to_Global_Var'>cpu_tuple_cost</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN1169"><span class='Ref_To_Local'>qpqual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>- 
</span>        <a href="costsize.c.html#LN1171"><span class='Ref_To_Local'>tid_qual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1167"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1170"><span class='Ref_To_Local'>cpu_per_tuple</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN1172"><span class='Ref_To_Local'>ntuples</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* tlist eval costs are paid per output row, not per tuple scanned */ 
</span>    <a href="costsize.c.html#LN1166"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1163"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN953"><span class='Ref_to_Member'>pathtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN884"><span class='Ref_to_Member'>cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1167"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1163"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN953"><span class='Ref_to_Member'>pathtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN884"><span class='Ref_to_Member'>cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN1163"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN1163"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1166"><span class='Ref_To_Local'>startup_cost</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1163"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1166"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN1167"><span class='Ref_To_Local'>run_cost</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end cost_tidscan &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * cost_subqueryscan 
 *    Determines and returns the cost of scanning a subquery RTE. 
 * 
 * 'baserel' is the relation to be scanned 
 * 'param_info' is the ParamPathInfo if this is a parameterized path, else NULL 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1266"></a><span class='Declare_Function'>cost_subqueryscan</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1111"><span class='Ref_to_Struct'>SubqueryScanPath</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN1267"></a>                  <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>baserel</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN907"><span class='Ref_to_Struct'>ParamPathInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>param_info</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1269"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>startup_cost</span><span class='Delimiter'>; 
</span><a name="LN1270"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>run_cost</span><span class='Delimiter'>; 
</span><a name="LN1271"></a>    <a href="../../../include/nodes/relation.h.html#LN42"><span class='Ref_to_Struct'>QualCost</span></a>    <span class='Declare_Local'>qpqual_cost</span><span class='Delimiter'>; 
</span><a name="LN1272"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>cpu_per_tuple</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Should only be applied to base relations that are subqueries */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN1267"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN1267"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN554"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/parsenodes.h.html#LN923"><span class='Ref_to_EnumConst'>RTE_SUBQUERY</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Mark the path with the correct row estimate */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN1267"><span class='Ref_to_Parameter'>param_info</span></a><span class='Parentheses'>) 
</span>        <a href="costsize.c.html#LN1266"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1113"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1267"><span class='Ref_to_Parameter'>param_info</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN912"><span class='Ref_to_Member'>ppi_rows</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="costsize.c.html#LN1266"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1113"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1267"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Cost of path is cost of evaluating the subplan, plus cost of evaluating 
     * any restriction clauses and tlist that will be attached to the 
     * SubqueryScan node, plus cpu_tuple_cost to account for selection and 
     * projection overhead. 
     */ 
</span>    <a href="costsize.c.html#LN1266"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1113"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1266"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1114"><span class='Ref_to_Member'>subpath</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1266"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1113"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1266"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1114"><span class='Ref_to_Member'>subpath</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN143"><span class='Ref_to_Proto'>get_restriction_qual_cost</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN1266"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN1267"><span class='Ref_to_Parameter'>baserel</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN1267"><span class='Ref_to_Parameter'>param_info</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="costsize.c.html#LN1271"><span class='Ref_To_Local'>qpqual_cost</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN1269"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1271"><span class='Ref_To_Local'>qpqual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1272"><span class='Ref_To_Local'>cpu_per_tuple</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN105"><span class='Ref_to_Global_Var'>cpu_tuple_cost</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN1271"><span class='Ref_To_Local'>qpqual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1270"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1272"><span class='Ref_To_Local'>cpu_per_tuple</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN1267"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN564"><span class='Ref_to_Member'>tuples</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* tlist eval costs are paid per output row, not per tuple scanned */ 
</span>    <a href="costsize.c.html#LN1269"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1266"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1113"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN953"><span class='Ref_to_Member'>pathtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN884"><span class='Ref_to_Member'>cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1270"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1266"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1113"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN953"><span class='Ref_to_Member'>pathtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN884"><span class='Ref_to_Member'>cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN1266"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1113"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN1266"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1113"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1269"><span class='Ref_To_Local'>startup_cost</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1266"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1113"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1269"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN1270"><span class='Ref_To_Local'>run_cost</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end cost_subqueryscan &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * cost_functionscan 
 *    Determines and returns the cost of scanning a function RTE. 
 * 
 * 'baserel' is the relation to be scanned 
 * 'param_info' is the ParamPathInfo if this is a parameterized path, else NULL 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1315"></a><span class='Declare_Function'>cost_functionscan</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN1316"></a>                  <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>baserel</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN907"><span class='Ref_to_Struct'>ParamPathInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>param_info</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1318"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>startup_cost</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN1319"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>run_cost</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN1320"></a>    <a href="../../../include/nodes/relation.h.html#LN42"><span class='Ref_to_Struct'>QualCost</span></a>    <span class='Declare_Local'>qpqual_cost</span><span class='Delimiter'>; 
</span><a name="LN1321"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>cpu_per_tuple</span><span class='Delimiter'>; 
</span><a name="LN1322"></a>    <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span><span class='Delimiter'>; 
</span><a name="LN1323"></a>    <a href="../../../include/nodes/relation.h.html#LN42"><span class='Ref_to_Struct'>QualCost</span></a>    <span class='Declare_Local'>exprcost</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Should only be applied to base relations that are functions */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN1316"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1322"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/relation.h.html#LN324"><span class='Ref_to_Macro'>planner_rt_fetch</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN1316"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN1315"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN1322"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN936"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/parsenodes.h.html#LN925"><span class='Ref_to_EnumConst'>RTE_FUNCTION</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Mark the path with the correct row estimate */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN1316"><span class='Ref_to_Parameter'>param_info</span></a><span class='Parentheses'>) 
</span>        <a href="costsize.c.html#LN1315"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1316"><span class='Ref_to_Parameter'>param_info</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN912"><span class='Ref_to_Member'>ppi_rows</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="costsize.c.html#LN1315"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1316"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Estimate costs of executing the function expression(s). 
     * 
     * Currently, nodeFunctionscan.c always executes the functions to 
     * completion before returning any rows, and caches the results in a 
     * tuplestore.  So the function eval cost is all startup cost, and per-row 
     * costs are minimal. 
     * 
     * XXX in principle we ought to charge tuplestore spill costs if the 
     * number of rows is large.  However, given how phony our rowcount 
     * estimates for functions tend to be, there's not a lot of point in that 
     * refinement right now. 
     */ 
</span>    <a href="../../../include/optimizer/cost.h.html#LN158"><span class='Ref_to_Proto'>cost_qual_eval_node</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="costsize.c.html#LN1323"><span class='Ref_To_Local'>exprcost</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN1322"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN985"><span class='Ref_to_Member'>functions</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN1315"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN1318"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1323"><span class='Ref_To_Local'>exprcost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN1323"><span class='Ref_To_Local'>exprcost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Add scanning CPU costs */ 
</span>    <a href="costsize.c.html#LN143"><span class='Ref_to_Proto'>get_restriction_qual_cost</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN1315"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN1316"><span class='Ref_to_Parameter'>baserel</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN1316"><span class='Ref_to_Parameter'>param_info</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="costsize.c.html#LN1320"><span class='Ref_To_Local'>qpqual_cost</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN1318"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1320"><span class='Ref_To_Local'>qpqual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1321"><span class='Ref_To_Local'>cpu_per_tuple</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN105"><span class='Ref_to_Global_Var'>cpu_tuple_cost</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN1320"><span class='Ref_To_Local'>qpqual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1319"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1321"><span class='Ref_To_Local'>cpu_per_tuple</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN1316"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN564"><span class='Ref_to_Member'>tuples</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* tlist eval costs are paid per output row, not per tuple scanned */ 
</span>    <a href="costsize.c.html#LN1318"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1315"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN953"><span class='Ref_to_Member'>pathtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN884"><span class='Ref_to_Member'>cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1319"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1315"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN953"><span class='Ref_to_Member'>pathtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN884"><span class='Ref_to_Member'>cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN1315"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN1315"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1318"><span class='Ref_To_Local'>startup_cost</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1315"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1318"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN1319"><span class='Ref_To_Local'>run_cost</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end cost_functionscan &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * cost_tablefuncscan 
 *    Determines and returns the cost of scanning a table function. 
 * 
 * 'baserel' is the relation to be scanned 
 * 'param_info' is the ParamPathInfo if this is a parameterized path, else NULL 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1376"></a><span class='Declare_Function'>cost_tablefuncscan</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN1377"></a>                   <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>baserel</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN907"><span class='Ref_to_Struct'>ParamPathInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>param_info</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1379"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>startup_cost</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN1380"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>run_cost</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN1381"></a>    <a href="../../../include/nodes/relation.h.html#LN42"><span class='Ref_to_Struct'>QualCost</span></a>    <span class='Declare_Local'>qpqual_cost</span><span class='Delimiter'>; 
</span><a name="LN1382"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>cpu_per_tuple</span><span class='Delimiter'>; 
</span><a name="LN1383"></a>    <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span><span class='Delimiter'>; 
</span><a name="LN1384"></a>    <a href="../../../include/nodes/relation.h.html#LN42"><span class='Ref_to_Struct'>QualCost</span></a>    <span class='Declare_Local'>exprcost</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Should only be applied to base relations that are functions */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN1377"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1383"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/relation.h.html#LN324"><span class='Ref_to_Macro'>planner_rt_fetch</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN1377"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN1376"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN1383"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN936"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/parsenodes.h.html#LN926"><span class='Ref_to_EnumConst'>RTE_TABLEFUNC</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Mark the path with the correct row estimate */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN1377"><span class='Ref_to_Parameter'>param_info</span></a><span class='Parentheses'>) 
</span>        <a href="costsize.c.html#LN1376"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1377"><span class='Ref_to_Parameter'>param_info</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN912"><span class='Ref_to_Member'>ppi_rows</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="costsize.c.html#LN1376"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1377"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Estimate costs of executing the table func expression(s). 
     * 
     * XXX in principle we ought to charge tuplestore spill costs if the 
     * number of rows is large.  However, given how phony our rowcount 
     * estimates for tablefuncs tend to be, there's not a lot of point in that 
     * refinement right now. 
     */ 
</span>    <a href="../../../include/optimizer/cost.h.html#LN158"><span class='Ref_to_Proto'>cost_qual_eval_node</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="costsize.c.html#LN1384"><span class='Ref_To_Local'>exprcost</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN1383"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN991"><span class='Ref_to_Member'>tablefunc</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN1376"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN1379"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1384"><span class='Ref_To_Local'>exprcost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN1384"><span class='Ref_To_Local'>exprcost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Add scanning CPU costs */ 
</span>    <a href="costsize.c.html#LN143"><span class='Ref_to_Proto'>get_restriction_qual_cost</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN1376"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN1377"><span class='Ref_to_Parameter'>baserel</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN1377"><span class='Ref_to_Parameter'>param_info</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="costsize.c.html#LN1381"><span class='Ref_To_Local'>qpqual_cost</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN1379"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1381"><span class='Ref_To_Local'>qpqual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1382"><span class='Ref_To_Local'>cpu_per_tuple</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN105"><span class='Ref_to_Global_Var'>cpu_tuple_cost</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN1381"><span class='Ref_To_Local'>qpqual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1380"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1382"><span class='Ref_To_Local'>cpu_per_tuple</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN1377"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN564"><span class='Ref_to_Member'>tuples</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* tlist eval costs are paid per output row, not per tuple scanned */ 
</span>    <a href="costsize.c.html#LN1379"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1376"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN953"><span class='Ref_to_Member'>pathtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN884"><span class='Ref_to_Member'>cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1380"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1376"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN953"><span class='Ref_to_Member'>pathtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN884"><span class='Ref_to_Member'>cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN1376"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN1376"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1379"><span class='Ref_To_Local'>startup_cost</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1376"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1379"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN1380"><span class='Ref_To_Local'>run_cost</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end cost_tablefuncscan &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * cost_valuesscan 
 *    Determines and returns the cost of scanning a VALUES RTE. 
 * 
 * 'baserel' is the relation to be scanned 
 * 'param_info' is the ParamPathInfo if this is a parameterized path, else NULL 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1432"></a><span class='Declare_Function'>cost_valuesscan</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN1433"></a>                <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>baserel</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN907"><span class='Ref_to_Struct'>ParamPathInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>param_info</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1435"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>startup_cost</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN1436"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>run_cost</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN1437"></a>    <a href="../../../include/nodes/relation.h.html#LN42"><span class='Ref_to_Struct'>QualCost</span></a>    <span class='Declare_Local'>qpqual_cost</span><span class='Delimiter'>; 
</span><a name="LN1438"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>cpu_per_tuple</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Should only be applied to base relations that are values lists */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN1433"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN1433"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN554"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/parsenodes.h.html#LN927"><span class='Ref_to_EnumConst'>RTE_VALUES</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Mark the path with the correct row estimate */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN1433"><span class='Ref_to_Parameter'>param_info</span></a><span class='Parentheses'>) 
</span>        <a href="costsize.c.html#LN1432"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1433"><span class='Ref_to_Parameter'>param_info</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN912"><span class='Ref_to_Member'>ppi_rows</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="costsize.c.html#LN1432"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1433"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * For now, estimate list evaluation cost at one operator eval per list 
     * (probably pretty bogus, but is it worth being smarter?) 
     */ 
</span>    <a href="costsize.c.html#LN1438"><span class='Ref_To_Local'>cpu_per_tuple</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN107"><span class='Ref_to_Global_Var'>cpu_operator_cost</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Add scanning CPU costs */ 
</span>    <a href="costsize.c.html#LN143"><span class='Ref_to_Proto'>get_restriction_qual_cost</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN1432"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN1433"><span class='Ref_to_Parameter'>baserel</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN1433"><span class='Ref_to_Parameter'>param_info</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="costsize.c.html#LN1437"><span class='Ref_To_Local'>qpqual_cost</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN1435"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1437"><span class='Ref_To_Local'>qpqual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1438"><span class='Ref_To_Local'>cpu_per_tuple</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN105"><span class='Ref_to_Global_Var'>cpu_tuple_cost</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN1437"><span class='Ref_To_Local'>qpqual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1436"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1438"><span class='Ref_To_Local'>cpu_per_tuple</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN1433"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN564"><span class='Ref_to_Member'>tuples</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* tlist eval costs are paid per output row, not per tuple scanned */ 
</span>    <a href="costsize.c.html#LN1435"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1432"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN953"><span class='Ref_to_Member'>pathtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN884"><span class='Ref_to_Member'>cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1436"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1432"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN953"><span class='Ref_to_Member'>pathtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN884"><span class='Ref_to_Member'>cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN1432"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN1432"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1435"><span class='Ref_To_Local'>startup_cost</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1432"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1435"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN1436"><span class='Ref_To_Local'>run_cost</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end cost_valuesscan &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * cost_ctescan 
 *    Determines and returns the cost of scanning a CTE RTE. 
 * 
 * Note: this is used for both self-reference and regular CTEs; the 
 * possible cost differences are below the threshold of what we could 
 * estimate accurately anyway.  Note that the costs of evaluating the 
 * referenced CTE query are added into the final plan as initplan costs, 
 * and should NOT be counted here. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1482"></a><span class='Declare_Function'>cost_ctescan</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN1483"></a>             <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>baserel</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN907"><span class='Ref_to_Struct'>ParamPathInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>param_info</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1485"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>startup_cost</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN1486"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>run_cost</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN1487"></a>    <a href="../../../include/nodes/relation.h.html#LN42"><span class='Ref_to_Struct'>QualCost</span></a>    <span class='Declare_Local'>qpqual_cost</span><span class='Delimiter'>; 
</span><a name="LN1488"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>cpu_per_tuple</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Should only be applied to base relations that are CTEs */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN1483"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN1483"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN554"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/parsenodes.h.html#LN928"><span class='Ref_to_EnumConst'>RTE_CTE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Mark the path with the correct row estimate */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN1483"><span class='Ref_to_Parameter'>param_info</span></a><span class='Parentheses'>) 
</span>        <a href="costsize.c.html#LN1482"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1483"><span class='Ref_to_Parameter'>param_info</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN912"><span class='Ref_to_Member'>ppi_rows</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="costsize.c.html#LN1482"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1483"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Charge one CPU tuple cost per row for tuplestore manipulation */ 
</span>    <a href="costsize.c.html#LN1488"><span class='Ref_To_Local'>cpu_per_tuple</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN105"><span class='Ref_to_Global_Var'>cpu_tuple_cost</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Add scanning CPU costs */ 
</span>    <a href="costsize.c.html#LN143"><span class='Ref_to_Proto'>get_restriction_qual_cost</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN1482"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN1483"><span class='Ref_to_Parameter'>baserel</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN1483"><span class='Ref_to_Parameter'>param_info</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="costsize.c.html#LN1487"><span class='Ref_To_Local'>qpqual_cost</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN1485"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1487"><span class='Ref_To_Local'>qpqual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1488"><span class='Ref_To_Local'>cpu_per_tuple</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN105"><span class='Ref_to_Global_Var'>cpu_tuple_cost</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN1487"><span class='Ref_To_Local'>qpqual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1486"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1488"><span class='Ref_To_Local'>cpu_per_tuple</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN1483"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN564"><span class='Ref_to_Member'>tuples</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* tlist eval costs are paid per output row, not per tuple scanned */ 
</span>    <a href="costsize.c.html#LN1485"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1482"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN953"><span class='Ref_to_Member'>pathtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN884"><span class='Ref_to_Member'>cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1486"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1482"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN953"><span class='Ref_to_Member'>pathtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN884"><span class='Ref_to_Member'>cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN1482"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN1482"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1485"><span class='Ref_To_Local'>startup_cost</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1482"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1485"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN1486"><span class='Ref_To_Local'>run_cost</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end cost_ctescan &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * cost_namedtuplestorescan 
 *    Determines and returns the cost of scanning a named tuplestore. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1523"></a><span class='Declare_Function'>cost_namedtuplestorescan</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN1524"></a>                         <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>baserel</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN907"><span class='Ref_to_Struct'>ParamPathInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>param_info</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1526"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>startup_cost</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN1527"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>run_cost</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN1528"></a>    <a href="../../../include/nodes/relation.h.html#LN42"><span class='Ref_to_Struct'>QualCost</span></a>    <span class='Declare_Local'>qpqual_cost</span><span class='Delimiter'>; 
</span><a name="LN1529"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>cpu_per_tuple</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Should only be applied to base relations that are Tuplestores */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN1524"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN1524"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN554"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/parsenodes.h.html#LN929"><span class='Ref_to_EnumConst'>RTE_NAMEDTUPLESTORE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Mark the path with the correct row estimate */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN1524"><span class='Ref_to_Parameter'>param_info</span></a><span class='Parentheses'>) 
</span>        <a href="costsize.c.html#LN1523"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1524"><span class='Ref_to_Parameter'>param_info</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN912"><span class='Ref_to_Member'>ppi_rows</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="costsize.c.html#LN1523"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1524"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Charge one CPU tuple cost per row for tuplestore manipulation */ 
</span>    <a href="costsize.c.html#LN1529"><span class='Ref_To_Local'>cpu_per_tuple</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN105"><span class='Ref_to_Global_Var'>cpu_tuple_cost</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Add scanning CPU costs */ 
</span>    <a href="costsize.c.html#LN143"><span class='Ref_to_Proto'>get_restriction_qual_cost</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN1523"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN1524"><span class='Ref_to_Parameter'>baserel</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN1524"><span class='Ref_to_Parameter'>param_info</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="costsize.c.html#LN1528"><span class='Ref_To_Local'>qpqual_cost</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN1526"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1528"><span class='Ref_To_Local'>qpqual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1529"><span class='Ref_To_Local'>cpu_per_tuple</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN105"><span class='Ref_to_Global_Var'>cpu_tuple_cost</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN1528"><span class='Ref_To_Local'>qpqual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1527"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1529"><span class='Ref_To_Local'>cpu_per_tuple</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN1524"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN564"><span class='Ref_to_Member'>tuples</span></a><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN1523"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1526"><span class='Ref_To_Local'>startup_cost</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1523"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1526"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN1527"><span class='Ref_To_Local'>run_cost</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end cost_namedtuplestorescan &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * cost_recursive_union 
 *    Determines and returns the cost of performing a recursive union, 
 *    and also the estimated output size. 
 * 
 * We are given Paths for the nonrecursive and recursive terms. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1563"></a><span class='Declare_Function'>cost_recursive_union</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>runion</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>nrterm</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rterm</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1565"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>startup_cost</span><span class='Delimiter'>; 
</span><a name="LN1566"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>total_cost</span><span class='Delimiter'>; 
</span><a name="LN1567"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>total_rows</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* We probably have decent estimates for the non-recursive term */ 
</span>    <a href="costsize.c.html#LN1565"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1563"><span class='Ref_to_Parameter'>nrterm</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1566"><span class='Ref_To_Local'>total_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1563"><span class='Ref_to_Parameter'>nrterm</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1567"><span class='Ref_To_Local'>total_rows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1563"><span class='Ref_to_Parameter'>nrterm</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We arbitrarily assume that about 10 recursive iterations will be 
     * needed, and that we've managed to get a good fix on the cost and output 
     * size of each one of them.  These are mighty shaky assumptions but it's 
     * hard to see how to do better. 
     */ 
</span>    <a href="costsize.c.html#LN1566"><span class='Ref_To_Local'>total_cost</span></a> <span class='Operator'>+= </span><span class='Number'>10</span> <span class='Operator'>* </span><a href="costsize.c.html#LN1563"><span class='Ref_to_Parameter'>rterm</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1567"><span class='Ref_To_Local'>total_rows</span></a> <span class='Operator'>+= </span><span class='Number'>10</span> <span class='Operator'>* </span><a href="costsize.c.html#LN1563"><span class='Ref_to_Parameter'>rterm</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Also charge cpu_tuple_cost per row to account for the costs of 
     * manipulating the tuplestores.  (We don't worry about possible 
     * spill-to-disk costs.) 
     */ 
</span>    <a href="costsize.c.html#LN1566"><span class='Ref_To_Local'>total_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN105"><span class='Ref_to_Global_Var'>cpu_tuple_cost</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN1567"><span class='Ref_To_Local'>total_rows</span></a><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN1563"><span class='Ref_to_Parameter'>runion</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1565"><span class='Ref_To_Local'>startup_cost</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1563"><span class='Ref_to_Parameter'>runion</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1566"><span class='Ref_To_Local'>total_cost</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1563"><span class='Ref_to_Parameter'>runion</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1567"><span class='Ref_To_Local'>total_rows</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1563"><span class='Ref_to_Parameter'>runion</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN953"><span class='Ref_to_Member'>pathtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN885"><span class='Ref_to_Member'>width</span></a> <span class='Operator'>= </span><a href="../../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN10"><span class='Ref_to_Macro'>Max</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN1563"><span class='Ref_to_Parameter'>nrterm</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN953"><span class='Ref_to_Member'>pathtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN885"><span class='Ref_to_Member'>width</span></a><span class='Delimiter'>, 
</span>                                    <a href="costsize.c.html#LN1563"><span class='Ref_to_Parameter'>rterm</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN953"><span class='Ref_to_Member'>pathtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN885"><span class='Ref_to_Member'>width</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end cost_recursive_union &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * cost_sort 
 *    Determines and returns the cost of sorting a relation, including 
 *    the cost of reading the input data. 
 * 
 * If the total volume of data to sort is less than sort_mem, we will do 
 * an in-memory sort, which requires no I/O and about t*log2(t) tuple 
 * comparisons for t tuples. 
 * 
 * If the total volume exceeds sort_mem, we switch to a tape-style merge 
 * algorithm.  There will still be about t*log2(t) tuple comparisons in 
 * total, but we will also need to write and read each tuple once per 
 * merge pass.  We expect about ceil(logM(r)) merge passes where r is the 
 * number of initial runs formed and M is the merge order used by tuplesort.c. 
 * Since the average initial run should be about sort_mem, we have 
 *      disk traffic = 2 * relsize * ceil(logM(p / sort_mem)) 
 *      cpu = comparison_cost * t * log2(t) 
 * 
 * If the sort is bounded (i.e., only the first k result tuples are needed) 
 * and k tuples can fit into sort_mem, we use a heap method that keeps only 
 * k tuples in the heap; this will require about t*log2(k) tuple comparisons. 
 * 
 * The disk traffic is assumed to be 3/4ths sequential and 1/4th random 
 * accesses (XXX can't we refine that guess?) 
 * 
 * By default, we charge two operator evals per tuple comparison, which should 
 * be in the right ballpark in most cases.  The caller can tweak this by 
 * specifying nonzero comparison_cost; typically that's used for any extra 
 * work that has to be done to prepare the inputs to the comparison operators. 
 * 
 * 'pathkeys' is a list of sort keys 
 * 'input_cost' is the total cost for reading the input data 
 * 'tuples' is the number of tuples in the relation 
 * 'width' is the average tuple width in bytes 
 * 'comparison_cost' is the extra cost per comparison, if any 
 * 'sort_mem' is the number of kilobytes of work memory allowed for the sort 
 * 'limit_tuples' is the bound on the number of output tuples; -1 if no bound 
 * 
 * NOTE: some callers currently pass NIL for pathkeys because they 
 * can't conveniently supply the sort keys.  Since this routine doesn't 
 * currently do anything with pathkeys anyway, that doesn't matter... 
 * but if it ever does, it should react gracefully to lack of key data. 
 * (Actually, the thing we'd most likely be interested in is just the number 
 * of sort keys, which all callers *could* supply.) 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1643"></a><span class='Declare_Function'>cost_sort</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN1644"></a>          <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pathkeys</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a> <span class='Declare_Parameter'>input_cost</span><span class='Delimiter'>, </span><span class='Keyword'>double </span><span class='Declare_Parameter'>tuples</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>width</span><span class='Delimiter'>, 
</span><a name="LN1645"></a>          <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a> <span class='Declare_Parameter'>comparison_cost</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>sort_mem</span><span class='Delimiter'>, 
</span><a name="LN1646"></a>          <span class='Keyword'>double </span><span class='Declare_Parameter'>limit_tuples</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1648"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>startup_cost</span> <span class='Operator'>= </span><a href="costsize.c.html#LN1644"><span class='Ref_to_Parameter'>input_cost</span></a><span class='Delimiter'>; 
</span><a name="LN1649"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>run_cost</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN1650"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>input_bytes</span> <span class='Operator'>= </span><a href="costsize.c.html#LN162"><span class='Ref_to_Proto'>relation_byte_size</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN1644"><span class='Ref_to_Parameter'>tuples</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN1644"><span class='Ref_to_Parameter'>width</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1651"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>output_bytes</span><span class='Delimiter'>; 
</span><a name="LN1652"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>output_tuples</span><span class='Delimiter'>; 
</span><a name="LN1653"></a>    <span class='Keyword'>long</span>        <span class='Declare_Local'>sort_mem_bytes</span> <span class='Operator'>= </span><a href="costsize.c.html#LN1645"><span class='Ref_to_Parameter'>sort_mem</span></a> <span class='Operator'>* </span><span class='Number'>1024L</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="costsize.c.html#LN122"><span class='Ref_to_Global_Var'>enable_sort</span></a><span class='Parentheses'>) 
</span>        <a href="costsize.c.html#LN1648"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN113"><span class='Ref_to_Global_Var'>disable_cost</span></a><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN1643"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1644"><span class='Ref_to_Parameter'>tuples</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We want to be sure the cost of a sort is never estimated as zero, even 
     * if passed-in tuple count is zero.  Besides, mustn't do log(0)... 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN1644"><span class='Ref_to_Parameter'>tuples</span></a> <span class='Operator'>&LT; </span><span class='Number'>2</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="costsize.c.html#LN1644"><span class='Ref_to_Parameter'>tuples</span></a> <span class='Operator'>= </span><span class='Number'>2</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Include the default cost-per-comparison */ 
</span>    <a href="costsize.c.html#LN1645"><span class='Ref_to_Parameter'>comparison_cost</span></a> <span class='Operator'>+= </span><span class='Number'>2</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>* </span><a href="costsize.c.html#LN107"><span class='Ref_to_Global_Var'>cpu_operator_cost</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Do we have a useful LIMIT? */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN1646"><span class='Ref_to_Parameter'>limit_tuples</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span> <span class='Operator'>&& </span><a href="costsize.c.html#LN1646"><span class='Ref_to_Parameter'>limit_tuples</span></a> <span class='Operator'>&LT; </span><a href="costsize.c.html#LN1644"><span class='Ref_to_Parameter'>tuples</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="costsize.c.html#LN1652"><span class='Ref_To_Local'>output_tuples</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1646"><span class='Ref_to_Parameter'>limit_tuples</span></a><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN1651"><span class='Ref_To_Local'>output_bytes</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN162"><span class='Ref_to_Proto'>relation_byte_size</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN1652"><span class='Ref_To_Local'>output_tuples</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN1644"><span class='Ref_to_Parameter'>width</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="costsize.c.html#LN1652"><span class='Ref_To_Local'>output_tuples</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1644"><span class='Ref_to_Parameter'>tuples</span></a><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN1651"><span class='Ref_To_Local'>output_bytes</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1650"><span class='Ref_To_Local'>input_bytes</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN1651"><span class='Ref_To_Local'>output_bytes</span></a> <span class='Operator'>&GT; </span><a href="costsize.c.html#LN1653"><span class='Ref_To_Local'>sort_mem_bytes</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * We'll have to use a disk-based sort of all the tuples 
         */ 
</span><a name="LN1687"></a>        <span class='Keyword'>double</span>      <span class='Declare_Local'>npages</span> <span class='Operator'>= </span>ceil<span class='Parentheses'>(</span><a href="costsize.c.html#LN1650"><span class='Ref_To_Local'>input_bytes</span></a> <span class='Operator'>/ </span>BLCKSZ<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1688"></a>        <span class='Keyword'>double</span>      <span class='Declare_Local'>nruns</span> <span class='Operator'>= </span><a href="costsize.c.html#LN1650"><span class='Ref_To_Local'>input_bytes</span></a> <span class='Operator'>/ </span><a href="costsize.c.html#LN1653"><span class='Ref_To_Local'>sort_mem_bytes</span></a><span class='Delimiter'>; 
</span><a name="LN1689"></a>        <span class='Keyword'>double</span>      <span class='Declare_Local'>mergeorder</span> <span class='Operator'>= </span><a href="../../../include/utils/tuplesort.h.html#LN113"><span class='Ref_to_Proto'>tuplesort_merge_order</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN1653"><span class='Ref_To_Local'>sort_mem_bytes</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1690"></a>        <span class='Keyword'>double</span>      <span class='Declare_Local'>log_runs</span><span class='Delimiter'>; 
</span><a name="LN1691"></a>        <span class='Keyword'>double</span>      <span class='Declare_Local'>npageaccesses</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * CPU costs 
         * 
         * Assume about N log2 N comparisons 
         */ 
</span>        <a href="costsize.c.html#LN1648"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1645"><span class='Ref_to_Parameter'>comparison_cost</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN1644"><span class='Ref_to_Parameter'>tuples</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN100"><span class='Ref_to_Macro'>LOG2</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN1644"><span class='Ref_to_Parameter'>tuples</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Disk costs */ 
</span> 
        <span class='Comment_Multi_Line'>/* Compute logM(r) as log(r) / log(M) */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN1688"><span class='Ref_To_Local'>nruns</span></a> <span class='Operator'>&GT; </span><a href="costsize.c.html#LN1689"><span class='Ref_To_Local'>mergeorder</span></a><span class='Parentheses'>) 
</span>            <a href="costsize.c.html#LN1690"><span class='Ref_To_Local'>log_runs</span></a> <span class='Operator'>= </span>ceil<span class='Parentheses'>(</span>log<span class='Parentheses'>(</span><a href="costsize.c.html#LN1688"><span class='Ref_To_Local'>nruns</span></a><span class='Parentheses'>) </span><span class='Operator'>/ </span>log<span class='Parentheses'>(</span><a href="costsize.c.html#LN1689"><span class='Ref_To_Local'>mergeorder</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="costsize.c.html#LN1690"><span class='Ref_To_Local'>log_runs</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN1691"><span class='Ref_To_Local'>npageaccesses</span></a> <span class='Operator'>= </span><span class='Number'>2</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>* </span><a href="costsize.c.html#LN1687"><span class='Ref_To_Local'>npages</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN1690"><span class='Ref_To_Local'>log_runs</span></a><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* Assume 3/4ths of accesses are sequential, 1/4th are not */ 
</span>        <a href="costsize.c.html#LN1648"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1691"><span class='Ref_To_Local'>npageaccesses</span></a> <span class='Operator'>* 
</span>            <span class='Parentheses'>(</span><a href="costsize.c.html#LN103"><span class='Ref_to_Global_Var'>seq_page_cost</span></a> <span class='Operator'>* </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>75</span> <span class='Operator'>+ </span><a href="costsize.c.html#LN104"><span class='Ref_to_Global_Var'>random_page_cost</span></a> <span class='Operator'>* </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>25</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if output_bytes&GT;sort_mem... &raquo; </span> 
    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN1644"><span class='Ref_to_Parameter'>tuples</span></a> <span class='Operator'>&GT; </span><span class='Number'>2</span> <span class='Operator'>* </span><a href="costsize.c.html#LN1652"><span class='Ref_To_Local'>output_tuples</span></a> <span class='Operator'>|| </span><a href="costsize.c.html#LN1650"><span class='Ref_To_Local'>input_bytes</span></a> <span class='Operator'>&GT; </span><a href="costsize.c.html#LN1653"><span class='Ref_To_Local'>sort_mem_bytes</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * We'll use a bounded heap-sort keeping just K tuples in memory, for 
         * a total number of tuple comparisons of N log2 K; but the constant 
         * factor is a bit higher than for quicksort.  Tweak it so that the 
         * cost curve is continuous at the crossover point. 
         */ 
</span>        <a href="costsize.c.html#LN1648"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1645"><span class='Ref_to_Parameter'>comparison_cost</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN1644"><span class='Ref_to_Parameter'>tuples</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN100"><span class='Ref_to_Macro'>LOG2</span></a><span class='Parentheses'>(</span><span class='Number'>2</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>* </span><a href="costsize.c.html#LN1652"><span class='Ref_To_Local'>output_tuples</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* We'll use plain quicksort on all the input tuples */ 
</span>        <a href="costsize.c.html#LN1648"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1645"><span class='Ref_to_Parameter'>comparison_cost</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN1644"><span class='Ref_to_Parameter'>tuples</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN100"><span class='Ref_to_Macro'>LOG2</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN1644"><span class='Ref_to_Parameter'>tuples</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Also charge a small amount (arbitrarily set equal to operator cost) per 
     * extracted tuple.  We don't charge cpu_tuple_cost because a Sort node 
     * doesn't do qual-checking or projection, so it has less overhead than 
     * most plan nodes.  Note it's correct to use tuples not output_tuples 
     * here --- the upper LIMIT will pro-rate the run cost so we'd be double 
     * counting the LIMIT otherwise. 
     */ 
</span>    <a href="costsize.c.html#LN1649"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN107"><span class='Ref_to_Global_Var'>cpu_operator_cost</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN1644"><span class='Ref_to_Parameter'>tuples</span></a><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN1643"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1648"><span class='Ref_To_Local'>startup_cost</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1643"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1648"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN1649"><span class='Ref_To_Local'>run_cost</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end cost_sort &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * cost_merge_append 
 *    Determines and returns the cost of a MergeAppend node. 
 * 
 * MergeAppend merges several pre-sorted input streams, using a heap that 
 * at any given instant holds the next tuple from each stream.  If there 
 * are N streams, we need about N*log2(N) tuple comparisons to construct 
 * the heap at startup, and then for each output tuple, about log2(N) 
 * comparisons to replace the top entry. 
 * 
 * (The effective value of N will drop once some of the input streams are 
 * exhausted, but it seems unlikely to be worth trying to account for that.) 
 * 
 * The heap is never spilled to disk, since we assume N is not very large. 
 * So this is much simpler than cost_sort. 
 * 
 * As in cost_sort, we charge two operator evals per tuple comparison. 
 * 
 * 'pathkeys' is a list of sort keys 
 * 'n_streams' is the number of input streams 
 * 'input_startup_cost' is the sum of the input streams' startup costs 
 * 'input_total_cost' is the sum of the input streams' total costs 
 * 'tuples' is the number of tuples in all the streams 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1767"></a><span class='Declare_Function'>cost_merge_append</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN1768"></a>                  <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pathkeys</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>n_streams</span><span class='Delimiter'>, 
</span><a name="LN1769"></a>                  <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a> <span class='Declare_Parameter'>input_startup_cost</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a> <span class='Declare_Parameter'>input_total_cost</span><span class='Delimiter'>, 
</span><a name="LN1770"></a>                  <span class='Keyword'>double </span><span class='Declare_Parameter'>tuples</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1772"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>startup_cost</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN1773"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>run_cost</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN1774"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>comparison_cost</span><span class='Delimiter'>; 
</span><a name="LN1775"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>N</span><span class='Delimiter'>; 
</span><a name="LN1776"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>logN</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Avoid log(0)... 
     */ 
</span>    <a href="costsize.c.html#LN1775"><span class='Ref_To_Local'>N</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="costsize.c.html#LN1768"><span class='Ref_to_Parameter'>n_streams</span></a> <span class='Operator'>&LT; </span><span class='Number'>2</span><span class='Parentheses'>) </span><span class='Operator'>? </span><span class='Number'>2</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>: </span><span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN1768"><span class='Ref_to_Parameter'>n_streams</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1776"><span class='Ref_To_Local'>logN</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN100"><span class='Ref_to_Macro'>LOG2</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN1775"><span class='Ref_To_Local'>N</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Assumed cost per tuple comparison */ 
</span>    <a href="costsize.c.html#LN1774"><span class='Ref_To_Local'>comparison_cost</span></a> <span class='Operator'>= </span><span class='Number'>2</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>* </span><a href="costsize.c.html#LN107"><span class='Ref_to_Global_Var'>cpu_operator_cost</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Heap creation cost */ 
</span>    <a href="costsize.c.html#LN1772"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1774"><span class='Ref_To_Local'>comparison_cost</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN1775"><span class='Ref_To_Local'>N</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN1776"><span class='Ref_To_Local'>logN</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Per-tuple heap maintenance cost */ 
</span>    <a href="costsize.c.html#LN1773"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1770"><span class='Ref_to_Parameter'>tuples</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN1774"><span class='Ref_To_Local'>comparison_cost</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN1776"><span class='Ref_To_Local'>logN</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Also charge a small amount (arbitrarily set equal to operator cost) per 
     * extracted tuple.  We don't charge cpu_tuple_cost because a MergeAppend 
     * node doesn't do qual-checking or projection, so it has less overhead 
     * than most plan nodes. 
     */ 
</span>    <a href="costsize.c.html#LN1773"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN107"><span class='Ref_to_Global_Var'>cpu_operator_cost</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN1770"><span class='Ref_to_Parameter'>tuples</span></a><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN1767"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1772"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN1769"><span class='Ref_to_Parameter'>input_startup_cost</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1767"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1772"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN1773"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN1769"><span class='Ref_to_Parameter'>input_total_cost</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end cost_merge_append &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * cost_material 
 *    Determines and returns the cost of materializing a relation, including 
 *    the cost of reading the input data. 
 * 
 * If the total volume of data to materialize exceeds work_mem, we will need 
 * to write it to disk, so the cost is much higher in that case. 
 * 
 * Note that here we are estimating the costs for the first scan of the 
 * relation, so the materialization is all overhead --- any savings will 
 * occur only on rescan, which is estimated in cost_rescan. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1818"></a><span class='Declare_Function'>cost_material</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Delimiter'>, 
</span><a name="LN1819"></a>              <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a> <span class='Declare_Parameter'>input_startup_cost</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a> <span class='Declare_Parameter'>input_total_cost</span><span class='Delimiter'>, 
</span><a name="LN1820"></a>              <span class='Keyword'>double </span><span class='Declare_Parameter'>tuples</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>width</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1822"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>startup_cost</span> <span class='Operator'>= </span><a href="costsize.c.html#LN1819"><span class='Ref_to_Parameter'>input_startup_cost</span></a><span class='Delimiter'>; 
</span><a name="LN1823"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>run_cost</span> <span class='Operator'>= </span><a href="costsize.c.html#LN1819"><span class='Ref_to_Parameter'>input_total_cost</span></a> <span class='Operator'>- </span><a href="costsize.c.html#LN1819"><span class='Ref_to_Parameter'>input_startup_cost</span></a><span class='Delimiter'>; 
</span><a name="LN1824"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>nbytes</span> <span class='Operator'>= </span><a href="costsize.c.html#LN162"><span class='Ref_to_Proto'>relation_byte_size</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN1820"><span class='Ref_to_Parameter'>tuples</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN1820"><span class='Ref_to_Parameter'>width</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1825"></a>    <span class='Keyword'>long</span>        <span class='Declare_Local'>work_mem_bytes</span> <span class='Operator'>= </span><a href="../../utils/init/globals.c.html#LN112"><span class='Ref_to_Global_Var'>work_mem</span></a> <span class='Operator'>* </span><span class='Number'>1024L</span><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN1818"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1820"><span class='Ref_to_Parameter'>tuples</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Whether spilling or not, charge 2x cpu_operator_cost per tuple to 
     * reflect bookkeeping overhead.  (This rate must be more than what 
     * cost_rescan charges for materialize, ie, cpu_operator_cost per tuple; 
     * if it is exactly the same then there will be a cost tie between 
     * nestloop with A outer, materialized B inner and nestloop with B outer, 
     * materialized A inner.  The extra cost ensures we'll prefer 
     * materializing the smaller rel.)  Note that this is normally a good deal 
     * less than cpu_tuple_cost; which is OK because a Material plan node 
     * doesn't do qual-checking or projection, so it's got less overhead than 
     * most plan nodes. 
     */ 
</span>    <a href="costsize.c.html#LN1823"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><span class='Number'>2</span> <span class='Operator'>* </span><a href="costsize.c.html#LN107"><span class='Ref_to_Global_Var'>cpu_operator_cost</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN1820"><span class='Ref_to_Parameter'>tuples</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we will spill to disk, charge at the rate of seq_page_cost per page. 
     * This cost is assumed to be evenly spread through the plan run phase, 
     * which isn't exactly accurate but our cost model doesn't allow for 
     * nonuniform costs within the run phase. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN1824"><span class='Ref_To_Local'>nbytes</span></a> <span class='Operator'>&GT; </span><a href="costsize.c.html#LN1825"><span class='Ref_To_Local'>work_mem_bytes</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1851"></a>        <span class='Keyword'>double</span>      <span class='Declare_Local'>npages</span> <span class='Operator'>= </span>ceil<span class='Parentheses'>(</span><a href="costsize.c.html#LN1824"><span class='Ref_To_Local'>nbytes</span></a> <span class='Operator'>/ </span>BLCKSZ<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="costsize.c.html#LN1823"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN103"><span class='Ref_to_Global_Var'>seq_page_cost</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN1851"><span class='Ref_To_Local'>npages</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="costsize.c.html#LN1818"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1822"><span class='Ref_To_Local'>startup_cost</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1818"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1822"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN1823"><span class='Ref_To_Local'>run_cost</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end cost_material &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * cost_agg 
 *      Determines and returns the cost of performing an Agg plan node, 
 *      including the cost of its input. 
 * 
 * aggcosts can be NULL when there are no actual aggregate functions (i.e., 
 * we are using a hashed Agg node just to do grouping). 
 * 
 * Note: when aggstrategy == AGG_SORTED, caller must ensure that input costs 
 * are for appropriately-sorted input. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1872"></a><span class='Declare_Function'>cost_agg</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN1873"></a>         <a href="../../../include/nodes/nodes.h.html#LN733"><span class='Ref_to_Enum'>AggStrategy</span></a> <span class='Declare_Parameter'>aggstrategy</span><span class='Delimiter'>, </span><span class='Keyword'>const </span><a href="../../../include/nodes/relation.h.html#LN55"><span class='Ref_to_Struct'>AggClauseCosts</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>aggcosts</span><span class='Delimiter'>, 
</span><a name="LN1874"></a>         <span class='Keyword'>int </span><span class='Declare_Parameter'>numGroupCols</span><span class='Delimiter'>, </span><span class='Keyword'>double </span><span class='Declare_Parameter'>numGroups</span><span class='Delimiter'>, 
</span><a name="LN1875"></a>         <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a> <span class='Declare_Parameter'>input_startup_cost</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a> <span class='Declare_Parameter'>input_total_cost</span><span class='Delimiter'>, 
</span><a name="LN1876"></a>         <span class='Keyword'>double </span><span class='Declare_Parameter'>input_tuples</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1878"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>output_tuples</span><span class='Delimiter'>; 
</span><a name="LN1879"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>startup_cost</span><span class='Delimiter'>; 
</span><a name="LN1880"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>total_cost</span><span class='Delimiter'>; 
</span><a name="LN1881"></a>    <a href="../../../include/nodes/relation.h.html#LN55"><span class='Ref_to_Struct'>AggClauseCosts</span></a> <span class='Declare_Local'>dummy_aggcosts</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Use all-zero per-aggregate costs if NULL is passed */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN1873"><span class='Ref_to_Parameter'>aggcosts</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN1873"><span class='Ref_to_Parameter'>aggstrategy</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN737"><span class='Ref_to_EnumConst'>AGG_HASHED</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/c.h.html#LN856"><span class='Ref_to_Macro'>MemSet</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="costsize.c.html#LN1881"><span class='Ref_To_Local'>dummy_aggcosts</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN55"><span class='Ref_to_Struct'>AggClauseCosts</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN1873"><span class='Ref_to_Parameter'>aggcosts</span></a> <span class='Operator'>= &</span><a href="costsize.c.html#LN1881"><span class='Ref_To_Local'>dummy_aggcosts</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * The transCost.per_tuple component of aggcosts should be charged once 
     * per input tuple, corresponding to the costs of evaluating the aggregate 
     * transfns and their input expressions (with any startup cost of course 
     * charged but once).  The finalCost component is charged once per output 
     * tuple, corresponding to the costs of evaluating the finalfns. 
     * 
     * If we are grouping, we charge an additional cpu_operator_cost per 
     * grouping column per input tuple for grouping comparisons. 
     * 
     * We will produce a single output tuple if not grouping, and a tuple per 
     * group otherwise.  We charge cpu_tuple_cost for each output tuple. 
     * 
     * Note: in this cost model, AGG_SORTED and AGG_HASHED have exactly the 
     * same total CPU cost, but AGG_SORTED has lower startup cost.  If the 
     * input path is already sorted appropriately, AGG_SORTED should be 
     * preferred (since it has no risk of memory overflow).  This will happen 
     * as long as the computed total costs are indeed exactly equal --- but if 
     * there's roundoff error we might do the wrong thing.  So be sure that 
     * the computations below form the same intermediate values in the same 
     * order. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN1873"><span class='Ref_to_Parameter'>aggstrategy</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN735"><span class='Ref_to_EnumConst'>AGG_PLAIN</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="costsize.c.html#LN1879"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1875"><span class='Ref_to_Parameter'>input_total_cost</span></a><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN1879"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1873"><span class='Ref_to_Parameter'>aggcosts</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN61"><span class='Ref_to_Member'>transCost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN1879"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1873"><span class='Ref_to_Parameter'>aggcosts</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN61"><span class='Ref_to_Member'>transCost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN1876"><span class='Ref_to_Parameter'>input_tuples</span></a><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN1879"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1873"><span class='Ref_to_Parameter'>aggcosts</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN62"><span class='Ref_to_Member'>finalCost</span></a><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* we aren't grouping */ 
</span>        <a href="costsize.c.html#LN1880"><span class='Ref_To_Local'>total_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1879"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN105"><span class='Ref_to_Global_Var'>cpu_tuple_cost</span></a><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN1878"><span class='Ref_To_Local'>output_tuples</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN1873"><span class='Ref_to_Parameter'>aggstrategy</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN736"><span class='Ref_to_EnumConst'>AGG_SORTED</span></a> <span class='Operator'>|| </span><a href="costsize.c.html#LN1873"><span class='Ref_to_Parameter'>aggstrategy</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN738"><span class='Ref_to_EnumConst'>AGG_MIXED</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Here we are able to deliver output on-the-fly */ 
</span>        <a href="costsize.c.html#LN1879"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1875"><span class='Ref_to_Parameter'>input_startup_cost</span></a><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN1880"><span class='Ref_To_Local'>total_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1875"><span class='Ref_to_Parameter'>input_total_cost</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN1873"><span class='Ref_to_Parameter'>aggstrategy</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN738"><span class='Ref_to_EnumConst'>AGG_MIXED</span></a> <span class='Operator'>&& !</span><a href="costsize.c.html#LN123"><span class='Ref_to_Global_Var'>enable_hashagg</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="costsize.c.html#LN1879"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN113"><span class='Ref_to_Global_Var'>disable_cost</span></a><span class='Delimiter'>; 
</span>            <a href="costsize.c.html#LN1880"><span class='Ref_To_Local'>total_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN113"><span class='Ref_to_Global_Var'>disable_cost</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Comment_Multi_Line'>/* calcs phrased this way to match HASHED case, see note above */ 
</span>        <a href="costsize.c.html#LN1880"><span class='Ref_To_Local'>total_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1873"><span class='Ref_to_Parameter'>aggcosts</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN61"><span class='Ref_to_Member'>transCost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN1880"><span class='Ref_To_Local'>total_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1873"><span class='Ref_to_Parameter'>aggcosts</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN61"><span class='Ref_to_Member'>transCost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN1876"><span class='Ref_to_Parameter'>input_tuples</span></a><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN1880"><span class='Ref_To_Local'>total_cost</span></a> <span class='Operator'>+= </span><span class='Parentheses'>(</span><a href="costsize.c.html#LN107"><span class='Ref_to_Global_Var'>cpu_operator_cost</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN1874"><span class='Ref_to_Parameter'>numGroupCols</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="costsize.c.html#LN1876"><span class='Ref_to_Parameter'>input_tuples</span></a><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN1880"><span class='Ref_To_Local'>total_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1873"><span class='Ref_to_Parameter'>aggcosts</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN62"><span class='Ref_to_Member'>finalCost</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN1874"><span class='Ref_to_Parameter'>numGroups</span></a><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN1880"><span class='Ref_To_Local'>total_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN105"><span class='Ref_to_Global_Var'>cpu_tuple_cost</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN1874"><span class='Ref_to_Parameter'>numGroups</span></a><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN1878"><span class='Ref_To_Local'>output_tuples</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1874"><span class='Ref_to_Parameter'>numGroups</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* must be AGG_HASHED */ 
</span>        <a href="costsize.c.html#LN1879"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1875"><span class='Ref_to_Parameter'>input_total_cost</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="costsize.c.html#LN123"><span class='Ref_to_Global_Var'>enable_hashagg</span></a><span class='Parentheses'>) 
</span>            <a href="costsize.c.html#LN1879"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN113"><span class='Ref_to_Global_Var'>disable_cost</span></a><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN1879"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1873"><span class='Ref_to_Parameter'>aggcosts</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN61"><span class='Ref_to_Member'>transCost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN1879"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1873"><span class='Ref_to_Parameter'>aggcosts</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN61"><span class='Ref_to_Member'>transCost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN1876"><span class='Ref_to_Parameter'>input_tuples</span></a><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN1879"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><span class='Parentheses'>(</span><a href="costsize.c.html#LN107"><span class='Ref_to_Global_Var'>cpu_operator_cost</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN1874"><span class='Ref_to_Parameter'>numGroupCols</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="costsize.c.html#LN1876"><span class='Ref_to_Parameter'>input_tuples</span></a><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN1880"><span class='Ref_To_Local'>total_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1879"><span class='Ref_To_Local'>startup_cost</span></a><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN1880"><span class='Ref_To_Local'>total_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1873"><span class='Ref_to_Parameter'>aggcosts</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN62"><span class='Ref_to_Member'>finalCost</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN1874"><span class='Ref_to_Parameter'>numGroups</span></a><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN1880"><span class='Ref_To_Local'>total_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN105"><span class='Ref_to_Global_Var'>cpu_tuple_cost</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN1874"><span class='Ref_to_Parameter'>numGroups</span></a><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN1878"><span class='Ref_To_Local'>output_tuples</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1874"><span class='Ref_to_Parameter'>numGroups</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="costsize.c.html#LN1872"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1878"><span class='Ref_To_Local'>output_tuples</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1872"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1879"><span class='Ref_To_Local'>startup_cost</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1872"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1880"><span class='Ref_To_Local'>total_cost</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end cost_agg &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * cost_windowagg 
 *      Determines and returns the cost of performing a WindowAgg plan node, 
 *      including the cost of its input. 
 * 
 * Input is assumed already properly sorted. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN1969"></a><span class='Declare_Function'>cost_windowagg</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN1970"></a>               <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>windowFuncs</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>numPartCols</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>numOrderCols</span><span class='Delimiter'>, 
</span><a name="LN1971"></a>               <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a> <span class='Declare_Parameter'>input_startup_cost</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a> <span class='Declare_Parameter'>input_total_cost</span><span class='Delimiter'>, 
</span><a name="LN1972"></a>               <span class='Keyword'>double </span><span class='Declare_Parameter'>input_tuples</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1974"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>startup_cost</span><span class='Delimiter'>; 
</span><a name="LN1975"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>total_cost</span><span class='Delimiter'>; 
</span><a name="LN1976"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN1974"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1971"><span class='Ref_to_Parameter'>input_startup_cost</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1975"><span class='Ref_To_Local'>total_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1971"><span class='Ref_to_Parameter'>input_total_cost</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Window functions are assumed to cost their stated execution cost, plus 
     * the cost of evaluating their input expressions, per tuple.  Since they 
     * may in fact evaluate their inputs at multiple rows during each cycle, 
     * this could be a drastic underestimate; but without a way to know how 
     * many rows the window function will fetch, it's hard to do better.  In 
     * any case, it's a good estimate for all the built-in window functions, 
     * so we'll just do this for now. 
     */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN1976"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN1970"><span class='Ref_to_Parameter'>windowFuncs</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1992"></a>        <a href="../../../include/nodes/primnodes.h.html#LN351"><span class='Ref_to_Struct'>WindowFunc</span></a> <span class='Operator'>*</span><span class='Declare_Local'>wfunc</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN108"><span class='Ref_to_Macro'>lfirst_node</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN351"><span class='Ref_to_Struct'>WindowFunc</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN1976"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1993"></a>        <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>wfunccost</span><span class='Delimiter'>; 
</span><a name="LN1994"></a>        <a href="../../../include/nodes/relation.h.html#LN42"><span class='Ref_to_Struct'>QualCost</span></a>    <span class='Declare_Local'>argcosts</span><span class='Delimiter'>; 
</span> 
        <a href="costsize.c.html#LN1993"><span class='Ref_To_Local'>wfunccost</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN121"><span class='Ref_to_Proto'>get_func_cost</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN1992"><span class='Ref_To_Local'>wfunc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN354"><span class='Ref_to_Member'>winfnoid</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="costsize.c.html#LN107"><span class='Ref_to_Global_Var'>cpu_operator_cost</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* also add the input expressions' cost to per-input-row costs */ 
</span>        <a href="../../../include/optimizer/cost.h.html#LN158"><span class='Ref_to_Proto'>cost_qual_eval_node</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="costsize.c.html#LN1994"><span class='Ref_To_Local'>argcosts</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN1992"><span class='Ref_To_Local'>wfunc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN358"><span class='Ref_to_Member'>args</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN1969"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN1974"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1994"><span class='Ref_To_Local'>argcosts</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN1993"><span class='Ref_To_Local'>wfunccost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1994"><span class='Ref_To_Local'>argcosts</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Add the filter's cost to per-input-row costs.  XXX We should reduce 
         * input expression costs according to filter selectivity. 
         */ 
</span>        <a href="../../../include/optimizer/cost.h.html#LN158"><span class='Ref_to_Proto'>cost_qual_eval_node</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="costsize.c.html#LN1994"><span class='Ref_To_Local'>argcosts</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN1992"><span class='Ref_To_Local'>wfunc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN359"><span class='Ref_to_Member'>aggfilter</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN1969"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN1974"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1994"><span class='Ref_To_Local'>argcosts</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN1993"><span class='Ref_To_Local'>wfunccost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1994"><span class='Ref_To_Local'>argcosts</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a><span class='Delimiter'>; 
</span> 
        <a href="costsize.c.html#LN1975"><span class='Ref_To_Local'>total_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN1993"><span class='Ref_To_Local'>wfunccost</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN1972"><span class='Ref_to_Parameter'>input_tuples</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We also charge cpu_operator_cost per grouping column per tuple for 
     * grouping comparisons, plus cpu_tuple_cost per tuple for general 
     * overhead. 
     * 
     * XXX this neglects costs of spooling the data to disk when it overflows 
     * work_mem.  Sooner or later that should get accounted for. 
     */ 
</span>    <a href="costsize.c.html#LN1975"><span class='Ref_To_Local'>total_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN107"><span class='Ref_to_Global_Var'>cpu_operator_cost</span></a> <span class='Operator'>* </span><span class='Parentheses'>(</span><a href="costsize.c.html#LN1970"><span class='Ref_to_Parameter'>numPartCols</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN1970"><span class='Ref_to_Parameter'>numOrderCols</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="costsize.c.html#LN1972"><span class='Ref_to_Parameter'>input_tuples</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1975"><span class='Ref_To_Local'>total_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN105"><span class='Ref_to_Global_Var'>cpu_tuple_cost</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN1972"><span class='Ref_to_Parameter'>input_tuples</span></a><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN1969"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1972"><span class='Ref_to_Parameter'>input_tuples</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1969"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1974"><span class='Ref_To_Local'>startup_cost</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN1969"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN1975"><span class='Ref_To_Local'>total_cost</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end cost_windowagg &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * cost_group 
 *      Determines and returns the cost of performing a Group plan node, 
 *      including the cost of its input. 
 * 
 * Note: caller must ensure that input costs are for appropriately-sorted 
 * input. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN2039"></a><span class='Declare_Function'>cost_group</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN2040"></a>           <span class='Keyword'>int </span><span class='Declare_Parameter'>numGroupCols</span><span class='Delimiter'>, </span><span class='Keyword'>double </span><span class='Declare_Parameter'>numGroups</span><span class='Delimiter'>, 
</span><a name="LN2041"></a>           <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a> <span class='Declare_Parameter'>input_startup_cost</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a> <span class='Declare_Parameter'>input_total_cost</span><span class='Delimiter'>, 
</span><a name="LN2042"></a>           <span class='Keyword'>double </span><span class='Declare_Parameter'>input_tuples</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2044"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>startup_cost</span><span class='Delimiter'>; 
</span><a name="LN2045"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>total_cost</span><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN2044"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2041"><span class='Ref_to_Parameter'>input_startup_cost</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN2045"><span class='Ref_To_Local'>total_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2041"><span class='Ref_to_Parameter'>input_total_cost</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Charge one cpu_operator_cost per comparison per input tuple. We assume 
     * all columns get compared at most of the tuples. 
     */ 
</span>    <a href="costsize.c.html#LN2045"><span class='Ref_To_Local'>total_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN107"><span class='Ref_to_Global_Var'>cpu_operator_cost</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN2042"><span class='Ref_to_Parameter'>input_tuples</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN2040"><span class='Ref_to_Parameter'>numGroupCols</span></a><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN2039"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2040"><span class='Ref_to_Parameter'>numGroups</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN2039"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2044"><span class='Ref_To_Local'>startup_cost</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN2039"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2045"><span class='Ref_To_Local'>total_cost</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end cost_group &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * initial_cost_nestloop 
 *    Preliminary estimate of the cost of a nestloop join path. 
 * 
 * This must quickly produce lower-bound estimates of the path's startup and 
 * total costs.  If we are unable to eliminate the proposed path from 
 * consideration using the lower bounds, final_cost_nestloop will be called 
 * to obtain the final estimates. 
 * 
 * The exact division of labor between this function and final_cost_nestloop 
 * is private to them, and represents a tradeoff between speed of the initial 
 * estimate and getting a tight lower bound.  We choose to not examine the 
 * join quals here, since that's by far the most expensive part of the 
 * calculations.  The end result is that CPU-cost considerations must be 
 * left for the second phase; and for SEMI/ANTI joins, we must also postpone 
 * incorporation of the inner path's run cost. 
 * 
 * 'workspace' is to be filled with startup_cost, total_cost, and perhaps 
 *      other data to be used by final_cost_nestloop 
 * 'jointype' is the type of join to be performed 
 * 'outer_path' is the outer input to the join 
 * 'inner_path' is the inner input to the join 
 * 'extra' contains miscellaneous information about the join 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN2086"></a><span class='Declare_Function'>initial_cost_nestloop</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN2199"><span class='Ref_to_Struct'>JoinCostWorkspace</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>workspace</span><span class='Delimiter'>, 
</span><a name="LN2087"></a>                      <a href="../../../include/nodes/nodes.h.html#LN671"><span class='Ref_to_Enum'>JoinType</span></a> <span class='Declare_Parameter'>jointype</span><span class='Delimiter'>, 
</span><a name="LN2088"></a>                      <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>outer_path</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>inner_path</span><span class='Delimiter'>, 
</span><a name="LN2089"></a>                      <a href="../../../include/nodes/relation.h.html#LN2177"><span class='Ref_to_Struct'>JoinPathExtraData</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>extra</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2091"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>startup_cost</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN2092"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>run_cost</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN2093"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>outer_path_rows</span> <span class='Operator'>= </span><a href="costsize.c.html#LN2088"><span class='Ref_to_Parameter'>outer_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span><a name="LN2094"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>inner_rescan_start_cost</span><span class='Delimiter'>; 
</span><a name="LN2095"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>inner_rescan_total_cost</span><span class='Delimiter'>; 
</span><a name="LN2096"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>inner_run_cost</span><span class='Delimiter'>; 
</span><a name="LN2097"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>inner_rescan_run_cost</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* estimate costs to rescan the inner relation */ 
</span>    <a href="costsize.c.html#LN140"><span class='Ref_to_Proto'>cost_rescan</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN2086"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN2088"><span class='Ref_to_Parameter'>inner_path</span></a><span class='Delimiter'>, 
</span>                <span class='Operator'>&</span><a href="costsize.c.html#LN2094"><span class='Ref_To_Local'>inner_rescan_start_cost</span></a><span class='Delimiter'>, 
</span>                <span class='Operator'>&</span><a href="costsize.c.html#LN2095"><span class='Ref_To_Local'>inner_rescan_total_cost</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* cost of source data */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * NOTE: clearly, we must pay both outer and inner paths' startup_cost 
     * before we can start returning tuples, so the join's startup cost is 
     * their sum.  We'll also pay the inner path's rescan startup cost 
     * multiple times. 
     */ 
</span>    <a href="costsize.c.html#LN2091"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN2088"><span class='Ref_to_Parameter'>outer_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN2088"><span class='Ref_to_Parameter'>inner_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN2092"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN2088"><span class='Ref_to_Parameter'>outer_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>- </span><a href="costsize.c.html#LN2088"><span class='Ref_to_Parameter'>outer_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN2093"><span class='Ref_To_Local'>outer_path_rows</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>        <a href="costsize.c.html#LN2092"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><span class='Parentheses'>(</span><a href="costsize.c.html#LN2093"><span class='Ref_To_Local'>outer_path_rows</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="costsize.c.html#LN2094"><span class='Ref_To_Local'>inner_rescan_start_cost</span></a><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN2096"><span class='Ref_To_Local'>inner_run_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2088"><span class='Ref_to_Parameter'>inner_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>- </span><a href="costsize.c.html#LN2088"><span class='Ref_to_Parameter'>inner_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN2097"><span class='Ref_To_Local'>inner_rescan_run_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2095"><span class='Ref_To_Local'>inner_rescan_total_cost</span></a> <span class='Operator'>- </span><a href="costsize.c.html#LN2094"><span class='Ref_To_Local'>inner_rescan_start_cost</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN2087"><span class='Ref_to_Parameter'>jointype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN691"><span class='Ref_to_EnumConst'>JOIN_SEMI</span></a> <span class='Operator'>|| </span><a href="costsize.c.html#LN2087"><span class='Ref_to_Parameter'>jointype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN692"><span class='Ref_to_EnumConst'>JOIN_ANTI</span></a> <span class='Operator'>|| 
</span>        <a href="costsize.c.html#LN2089"><span class='Ref_to_Parameter'>extra</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2181"><span class='Ref_to_Member'>inner_unique</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * With a SEMI or ANTI join, or if the innerrel is known unique, the 
         * executor will stop after the first match. 
         * 
         * Getting decent estimates requires inspection of the join quals, 
         * which we choose to postpone to final_cost_nestloop. 
         */ 
</span> 
        <span class='Comment_Multi_Line'>/* Save private data for final_cost_nestloop */ 
</span>        <a href="costsize.c.html#LN2086"><span class='Ref_to_Parameter'>workspace</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2209"><span class='Ref_to_Member'>inner_run_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2096"><span class='Ref_To_Local'>inner_run_cost</span></a><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN2086"><span class='Ref_to_Parameter'>workspace</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2210"><span class='Ref_to_Member'>inner_rescan_run_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2097"><span class='Ref_To_Local'>inner_rescan_run_cost</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Normal case; we'll scan whole input rel for each outer row */ 
</span>        <a href="costsize.c.html#LN2092"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN2096"><span class='Ref_To_Local'>inner_run_cost</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN2093"><span class='Ref_To_Local'>outer_path_rows</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>            <a href="costsize.c.html#LN2092"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><span class='Parentheses'>(</span><a href="costsize.c.html#LN2093"><span class='Ref_To_Local'>outer_path_rows</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="costsize.c.html#LN2097"><span class='Ref_To_Local'>inner_rescan_run_cost</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* CPU costs left for later */ 
</span> 
    <span class='Comment_Multi_Line'>/* Public result fields */ 
</span>    <a href="costsize.c.html#LN2086"><span class='Ref_to_Parameter'>workspace</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2202"><span class='Ref_to_Member'>startup_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2091"><span class='Ref_To_Local'>startup_cost</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN2086"><span class='Ref_to_Parameter'>workspace</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2203"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2091"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN2092"><span class='Ref_To_Local'>run_cost</span></a><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* Save private data for final_cost_nestloop */ 
</span>    <a href="costsize.c.html#LN2086"><span class='Ref_to_Parameter'>workspace</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2206"><span class='Ref_to_Member'>run_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2092"><span class='Ref_To_Local'>run_cost</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end initial_cost_nestloop &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * final_cost_nestloop 
 *    Final estimate of the cost and result size of a nestloop join path. 
 * 
 * 'path' is already filled in except for the rows and cost fields 
 * 'workspace' is the result from initial_cost_nestloop 
 * 'extra' contains miscellaneous information about the join 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN2161"></a><span class='Declare_Function'>final_cost_nestloop</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1311"><span class='Ref_to_Typedef'>NestPath</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Delimiter'>, 
</span><a name="LN2162"></a>                    <a href="../../../include/nodes/relation.h.html#LN2199"><span class='Ref_to_Struct'>JoinCostWorkspace</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>workspace</span><span class='Delimiter'>, 
</span><a name="LN2163"></a>                    <a href="../../../include/nodes/relation.h.html#LN2177"><span class='Ref_to_Struct'>JoinPathExtraData</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>extra</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2165"></a>    <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>outer_path</span> <span class='Operator'>= </span><a href="costsize.c.html#LN2161"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1295"><span class='Ref_to_Member'>outerjoinpath</span></a><span class='Delimiter'>; 
</span><a name="LN2166"></a>    <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>inner_path</span> <span class='Operator'>= </span><a href="costsize.c.html#LN2161"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1296"><span class='Ref_to_Member'>innerjoinpath</span></a><span class='Delimiter'>; 
</span><a name="LN2167"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>outer_path_rows</span> <span class='Operator'>= </span><a href="costsize.c.html#LN2165"><span class='Ref_To_Local'>outer_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span><a name="LN2168"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>inner_path_rows</span> <span class='Operator'>= </span><a href="costsize.c.html#LN2166"><span class='Ref_To_Local'>inner_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span><a name="LN2169"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>startup_cost</span> <span class='Operator'>= </span><a href="costsize.c.html#LN2162"><span class='Ref_to_Parameter'>workspace</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2202"><span class='Ref_to_Member'>startup_cost</span></a><span class='Delimiter'>; 
</span><a name="LN2170"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>run_cost</span> <span class='Operator'>= </span><a href="costsize.c.html#LN2162"><span class='Ref_to_Parameter'>workspace</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2206"><span class='Ref_to_Member'>run_cost</span></a><span class='Delimiter'>; 
</span><a name="LN2171"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>cpu_per_tuple</span><span class='Delimiter'>; 
</span><a name="LN2172"></a>    <a href="../../../include/nodes/relation.h.html#LN42"><span class='Ref_to_Struct'>QualCost</span></a>    <span class='Declare_Local'>restrict_qual_cost</span><span class='Delimiter'>; 
</span><a name="LN2173"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>ntuples</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Protect some assumptions below that rowcounts aren't zero or NaN */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN2167"><span class='Ref_To_Local'>outer_path_rows</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span> <span class='Operator'>|| </span><a href="../../../interfaces/ecpg/test/expected/pgtypeslib-nan_test.c.html#LN30"><span class='Ref_to_Macro'>isnan</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN2167"><span class='Ref_To_Local'>outer_path_rows</span></a><span class='Parentheses'>))</span> 
        <a href="costsize.c.html#LN2167"><span class='Ref_To_Local'>outer_path_rows</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN2168"><span class='Ref_To_Local'>inner_path_rows</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span> <span class='Operator'>|| </span><a href="../../../interfaces/ecpg/test/expected/pgtypeslib-nan_test.c.html#LN30"><span class='Ref_to_Macro'>isnan</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN2168"><span class='Ref_To_Local'>inner_path_rows</span></a><span class='Parentheses'>))</span> 
        <a href="costsize.c.html#LN2168"><span class='Ref_To_Local'>inner_path_rows</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Mark the path with the correct row estimate */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN2161"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1288"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN955"><span class='Ref_to_Member'>param_info</span></a><span class='Parentheses'>) 
</span>        <a href="costsize.c.html#LN2161"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1288"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2161"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1288"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN955"><span class='Ref_to_Member'>param_info</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN912"><span class='Ref_to_Member'>ppi_rows</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="costsize.c.html#LN2161"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1288"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2161"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1288"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN952"><span class='Ref_to_Member'>parent</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* For partial paths, scale row estimate. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN2161"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1288"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN959"><span class='Ref_to_Member'>parallel_workers</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2190"></a>        <span class='Keyword'>double</span>      <span class='Declare_Local'>parallel_divisor</span> <span class='Operator'>= </span><a href="costsize.c.html#LN164"><span class='Ref_to_Proto'>get_parallel_divisor</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="costsize.c.html#LN2161"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1288"><span class='Ref_to_Member'>path</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="costsize.c.html#LN2161"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1288"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= 
</span>            <a href="../../../include/optimizer/cost.h.html#LN71"><span class='Ref_to_Proto'>clamp_row_est</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN2161"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1288"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>/ </span><a href="costsize.c.html#LN2190"><span class='Ref_To_Local'>parallel_divisor</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We could include disable_cost in the preliminary estimate, but that 
     * would amount to optimizing for the case where the join method is 
     * disabled, which doesn't seem like the way to bet. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="costsize.c.html#LN124"><span class='Ref_to_Global_Var'>enable_nestloop</span></a><span class='Parentheses'>) 
</span>        <a href="costsize.c.html#LN2169"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN113"><span class='Ref_to_Global_Var'>disable_cost</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* cost of inner-relation source data (we already dealt with outer rel) */ 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN2161"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1290"><span class='Ref_to_Member'>jointype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN691"><span class='Ref_to_EnumConst'>JOIN_SEMI</span></a> <span class='Operator'>|| </span><a href="costsize.c.html#LN2161"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1290"><span class='Ref_to_Member'>jointype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN692"><span class='Ref_to_EnumConst'>JOIN_ANTI</span></a> <span class='Operator'>|| 
</span>        <a href="costsize.c.html#LN2163"><span class='Ref_to_Parameter'>extra</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2181"><span class='Ref_to_Member'>inner_unique</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * With a SEMI or ANTI join, or if the innerrel is known unique, the 
         * executor will stop after the first match. 
         */ 
</span><a name="LN2213"></a>        <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>inner_run_cost</span> <span class='Operator'>= </span><a href="costsize.c.html#LN2162"><span class='Ref_to_Parameter'>workspace</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2209"><span class='Ref_to_Member'>inner_run_cost</span></a><span class='Delimiter'>; 
</span><a name="LN2214"></a>        <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>inner_rescan_run_cost</span> <span class='Operator'>= </span><a href="costsize.c.html#LN2162"><span class='Ref_to_Parameter'>workspace</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2210"><span class='Ref_to_Member'>inner_rescan_run_cost</span></a><span class='Delimiter'>; 
</span><a name="LN2215"></a>        <span class='Keyword'>double</span>      <span class='Declare_Local'>outer_matched_rows</span><span class='Delimiter'>; 
</span><a name="LN2216"></a>        <span class='Keyword'>double</span>      <span class='Declare_Local'>outer_unmatched_rows</span><span class='Delimiter'>; 
</span><a name="LN2217"></a>        <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Local'>inner_scan_frac</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * For an outer-rel row that has at least one match, we can expect the 
         * inner scan to stop after a fraction 1/(match_count+1) of the inner 
         * rows, if the matches are evenly distributed.  Since they probably 
         * aren't quite evenly distributed, we apply a fuzz factor of 2.0 to 
         * that fraction.  (If we used a larger fuzz factor, we'd have to 
         * clamp inner_scan_frac to at most 1.0; but since match_count is at 
         * least 1, no such clamp is needed now.) 
         */ 
</span>        <a href="costsize.c.html#LN2215"><span class='Ref_To_Local'>outer_matched_rows</span></a> <span class='Operator'>= </span><a href="../../../port/rint.c.html#LN20"><span class='Ref_to_Func'>rint</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN2167"><span class='Ref_To_Local'>outer_path_rows</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN2163"><span class='Ref_to_Parameter'>extra</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2183"><span class='Ref_to_Member'>semifactors</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN2160"><span class='Ref_to_Member'>outer_match_frac</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN2216"><span class='Ref_To_Local'>outer_unmatched_rows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2167"><span class='Ref_To_Local'>outer_path_rows</span></a> <span class='Operator'>- </span><a href="costsize.c.html#LN2215"><span class='Ref_To_Local'>outer_matched_rows</span></a><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN2217"><span class='Ref_To_Local'>inner_scan_frac</span></a> <span class='Operator'>= </span><span class='Number'>2</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>/ </span><span class='Parentheses'>(</span><a href="costsize.c.html#LN2163"><span class='Ref_to_Parameter'>extra</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2183"><span class='Ref_to_Member'>semifactors</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN2161"><span class='Ref_to_Member'>match_count</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Compute number of tuples processed (not number emitted!).  First, 
         * account for successfully-matched outer rows. 
         */ 
</span>        <a href="costsize.c.html#LN2173"><span class='Ref_To_Local'>ntuples</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2215"><span class='Ref_To_Local'>outer_matched_rows</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN2168"><span class='Ref_To_Local'>inner_path_rows</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN2217"><span class='Ref_To_Local'>inner_scan_frac</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Now we need to estimate the actual costs of scanning the inner 
         * relation, which may be quite a bit less than N times inner_run_cost 
         * due to early scan stops.  We consider two cases.  If the inner path 
         * is an indexscan using all the joinquals as indexquals, then an 
         * unmatched outer row results in an indexscan returning no rows, 
         * which is probably quite cheap.  Otherwise, the executor will have 
         * to scan the whole inner rel for an unmatched row; not so cheap. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN146"><span class='Ref_to_Proto'>has_indexed_join_quals</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN2161"><span class='Ref_to_Parameter'>path</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Successfully-matched outer rows will only require scanning 
             * inner_scan_frac of the inner relation.  In this case, we don't 
             * need to charge the full inner_run_cost even when that's more 
             * than inner_rescan_run_cost, because we can assume that none of 
             * the inner scans ever scan the whole inner relation.  So it's 
             * okay to assume that all the inner scan executions can be 
             * fractions of the full cost, even if materialization is reducing 
             * the rescan cost.  At this writing, it's impossible to get here 
             * for a materialized inner scan, so inner_run_cost and 
             * inner_rescan_run_cost will be the same anyway; but just in 
             * case, use inner_run_cost for the first matched tuple and 
             * inner_rescan_run_cost for additional ones. 
             */ 
</span>            <a href="costsize.c.html#LN2170"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN2213"><span class='Ref_To_Local'>inner_run_cost</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN2217"><span class='Ref_To_Local'>inner_scan_frac</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN2215"><span class='Ref_To_Local'>outer_matched_rows</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>                <a href="costsize.c.html#LN2170"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><span class='Parentheses'>(</span><a href="costsize.c.html#LN2215"><span class='Ref_To_Local'>outer_matched_rows</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="costsize.c.html#LN2214"><span class='Ref_To_Local'>inner_rescan_run_cost</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN2217"><span class='Ref_To_Local'>inner_scan_frac</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Add the cost of inner-scan executions for unmatched outer rows. 
             * We estimate this as the same cost as returning the first tuple 
             * of a nonempty scan.  We consider that these are all rescans, 
             * since we used inner_run_cost once already. 
             */ 
</span>            <a href="costsize.c.html#LN2170"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN2216"><span class='Ref_To_Local'>outer_unmatched_rows</span></a> <span class='Operator'>* 
</span>                <a href="costsize.c.html#LN2214"><span class='Ref_To_Local'>inner_rescan_run_cost</span></a> <span class='Operator'>/ </span><a href="costsize.c.html#LN2168"><span class='Ref_To_Local'>inner_path_rows</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * We won't be evaluating any quals at all for unmatched rows, so 
             * don't add them to ntuples. 
             */ 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if has_indexed_join_qual... &raquo; </span> 
        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Here, a complicating factor is that rescans may be cheaper than 
             * first scans.  If we never scan all the way to the end of the 
             * inner rel, it might be (depending on the plan type) that we'd 
             * never pay the whole inner first-scan run cost.  However it is 
             * difficult to estimate whether that will happen (and it could 
             * not happen if there are any unmatched outer rows!), so be 
             * conservative and always charge the whole first-scan cost once. 
             * We consider this charge to correspond to the first unmatched 
             * outer row, unless there isn't one in our estimate, in which 
             * case blame it on the first matched row. 
             */ 
</span> 
            <span class='Comment_Multi_Line'>/* First, count all unmatched join tuples as being processed */ 
</span>            <a href="costsize.c.html#LN2173"><span class='Ref_To_Local'>ntuples</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN2216"><span class='Ref_To_Local'>outer_unmatched_rows</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN2168"><span class='Ref_To_Local'>inner_path_rows</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Now add the forced full scan, and decrement appropriate count */ 
</span>            <a href="costsize.c.html#LN2170"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN2213"><span class='Ref_To_Local'>inner_run_cost</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN2216"><span class='Ref_To_Local'>outer_unmatched_rows</span></a> <span class='Operator'>&GT;= </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>                <a href="costsize.c.html#LN2216"><span class='Ref_To_Local'>outer_unmatched_rows</span></a> <span class='Operator'>-= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="costsize.c.html#LN2215"><span class='Ref_To_Local'>outer_matched_rows</span></a> <span class='Operator'>-= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Add inner run cost for additional outer tuples having matches */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN2215"><span class='Ref_To_Local'>outer_matched_rows</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <a href="costsize.c.html#LN2170"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN2215"><span class='Ref_To_Local'>outer_matched_rows</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN2214"><span class='Ref_To_Local'>inner_rescan_run_cost</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN2217"><span class='Ref_To_Local'>inner_scan_frac</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Add inner run cost for additional unmatched outer tuples */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN2216"><span class='Ref_To_Local'>outer_unmatched_rows</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <a href="costsize.c.html#LN2170"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN2216"><span class='Ref_To_Local'>outer_unmatched_rows</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN2214"><span class='Ref_To_Local'>inner_rescan_run_cost</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if path-&GT;jointype==JOIN_... &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Normal-case source costs were included in preliminary estimate */ 
</span> 
        <span class='Comment_Multi_Line'>/* Compute number of tuples processed (not number emitted!) */ 
</span>        <a href="costsize.c.html#LN2173"><span class='Ref_To_Local'>ntuples</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2167"><span class='Ref_To_Local'>outer_path_rows</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN2168"><span class='Ref_To_Local'>inner_path_rows</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* CPU costs */ 
</span>    <a href="../../../include/optimizer/cost.h.html#LN157"><span class='Ref_to_Proto'>cost_qual_eval</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="costsize.c.html#LN2172"><span class='Ref_To_Local'>restrict_qual_cost</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN2161"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1298"><span class='Ref_to_Member'>joinrestrictinfo</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN2161"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN2169"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN2172"><span class='Ref_To_Local'>restrict_qual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN2171"><span class='Ref_To_Local'>cpu_per_tuple</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN105"><span class='Ref_to_Global_Var'>cpu_tuple_cost</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN2172"><span class='Ref_To_Local'>restrict_qual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN2170"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN2171"><span class='Ref_To_Local'>cpu_per_tuple</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN2173"><span class='Ref_To_Local'>ntuples</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* tlist eval costs are paid per output row, not per tuple scanned */ 
</span>    <a href="costsize.c.html#LN2169"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN2161"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1288"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN953"><span class='Ref_to_Member'>pathtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN884"><span class='Ref_to_Member'>cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN2170"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN2161"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1288"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN953"><span class='Ref_to_Member'>pathtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN884"><span class='Ref_to_Member'>cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN2161"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1288"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN2161"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1288"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2169"><span class='Ref_To_Local'>startup_cost</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN2161"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1288"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2169"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN2170"><span class='Ref_To_Local'>run_cost</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end final_cost_nestloop &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * initial_cost_mergejoin 
 *    Preliminary estimate of the cost of a mergejoin path. 
 * 
 * This must quickly produce lower-bound estimates of the path's startup and 
 * total costs.  If we are unable to eliminate the proposed path from 
 * consideration using the lower bounds, final_cost_mergejoin will be called 
 * to obtain the final estimates. 
 * 
 * The exact division of labor between this function and final_cost_mergejoin 
 * is private to them, and represents a tradeoff between speed of the initial 
 * estimate and getting a tight lower bound.  We choose to not examine the 
 * join quals here, except for obtaining the scan selectivity estimate which 
 * is really essential (but fortunately, use of caching keeps the cost of 
 * getting that down to something reasonable). 
 * We also assume that cost_sort is cheap enough to use here. 
 * 
 * 'workspace' is to be filled with startup_cost, total_cost, and perhaps 
 *      other data to be used by final_cost_mergejoin 
 * 'jointype' is the type of join to be performed 
 * 'mergeclauses' is the list of joinclauses to be used as merge clauses 
 * 'outer_path' is the outer input to the join 
 * 'inner_path' is the inner input to the join 
 * 'outersortkeys' is the list of sort keys for the outer path 
 * 'innersortkeys' is the list of sort keys for the inner path 
 * 'extra' contains miscellaneous information about the join 
 * 
 * Note: outersortkeys and innersortkeys should be NIL if no explicit 
 * sort is needed because the respective source path is already ordered. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN2368"></a><span class='Declare_Function'>initial_cost_mergejoin</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN2199"><span class='Ref_to_Struct'>JoinCostWorkspace</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>workspace</span><span class='Delimiter'>, 
</span><a name="LN2369"></a>                       <a href="../../../include/nodes/nodes.h.html#LN671"><span class='Ref_to_Enum'>JoinType</span></a> <span class='Declare_Parameter'>jointype</span><span class='Delimiter'>, 
</span><a name="LN2370"></a>                       <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>mergeclauses</span><span class='Delimiter'>, 
</span><a name="LN2371"></a>                       <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>outer_path</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>inner_path</span><span class='Delimiter'>, 
</span><a name="LN2372"></a>                       <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>outersortkeys</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>innersortkeys</span><span class='Delimiter'>, 
</span><a name="LN2373"></a>                       <a href="../../../include/nodes/relation.h.html#LN2177"><span class='Ref_to_Struct'>JoinPathExtraData</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>extra</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2375"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>startup_cost</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN2376"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>run_cost</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN2377"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>outer_path_rows</span> <span class='Operator'>= </span><a href="costsize.c.html#LN2371"><span class='Ref_to_Parameter'>outer_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span><a name="LN2378"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>inner_path_rows</span> <span class='Operator'>= </span><a href="costsize.c.html#LN2371"><span class='Ref_to_Parameter'>inner_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span><a name="LN2379"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>inner_run_cost</span><span class='Delimiter'>; 
</span><a name="LN2380"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>outer_rows</span><span class='Delimiter'>, 
</span><a name="LN2381"></a>                <span class='Declare_Local'>inner_rows</span><span class='Delimiter'>, 
</span><a name="LN2382"></a>                <span class='Declare_Local'>outer_skip_rows</span><span class='Delimiter'>, 
</span><a name="LN2383"></a>                <span class='Declare_Local'>inner_skip_rows</span><span class='Delimiter'>; 
</span><a name="LN2384"></a>    <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Local'>outerstartsel</span><span class='Delimiter'>, 
</span><a name="LN2385"></a>                <span class='Declare_Local'>outerendsel</span><span class='Delimiter'>, 
</span><a name="LN2386"></a>                <span class='Declare_Local'>innerstartsel</span><span class='Delimiter'>, 
</span><a name="LN2387"></a>                <span class='Declare_Local'>innerendsel</span><span class='Delimiter'>; 
</span><a name="LN2388"></a>    <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>        <span class='Declare_Local'>sort_path</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* dummy for result of cost_sort */ 
</span> 
    <span class='Comment_Multi_Line'>/* Protect some assumptions below that rowcounts aren't zero or NaN */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN2377"><span class='Ref_To_Local'>outer_path_rows</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span> <span class='Operator'>|| </span><a href="../../../interfaces/ecpg/test/expected/pgtypeslib-nan_test.c.html#LN30"><span class='Ref_to_Macro'>isnan</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN2377"><span class='Ref_To_Local'>outer_path_rows</span></a><span class='Parentheses'>))</span> 
        <a href="costsize.c.html#LN2377"><span class='Ref_To_Local'>outer_path_rows</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN2378"><span class='Ref_To_Local'>inner_path_rows</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span> <span class='Operator'>|| </span><a href="../../../interfaces/ecpg/test/expected/pgtypeslib-nan_test.c.html#LN30"><span class='Ref_to_Macro'>isnan</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN2378"><span class='Ref_To_Local'>inner_path_rows</span></a><span class='Parentheses'>))</span> 
        <a href="costsize.c.html#LN2378"><span class='Ref_To_Local'>inner_path_rows</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * A merge join will stop as soon as it exhausts either input stream 
     * (unless it's an outer join, in which case the outer side has to be 
     * scanned all the way anyway).  Estimate fraction of the left and right 
     * inputs that will actually need to be scanned.  Likewise, we can 
     * estimate the number of rows that will be skipped before the first join 
     * pair is found, which should be factored into startup cost. We use only 
     * the first (most significant) merge clause for this purpose. Since 
     * mergejoinscansel() is a fairly expensive computation, we cache the 
     * results in the merge clause RestrictInfo. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN2370"><span class='Ref_to_Parameter'>mergeclauses</span></a> <span class='Operator'>&& </span><a href="costsize.c.html#LN2369"><span class='Ref_to_Parameter'>jointype</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/nodes.h.html#LN679"><span class='Ref_to_EnumConst'>JOIN_FULL</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2409"></a>        <a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>firstclause</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN2370"><span class='Ref_to_Parameter'>mergeclauses</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2410"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>opathkeys</span><span class='Delimiter'>; 
</span><a name="LN2411"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>ipathkeys</span><span class='Delimiter'>; 
</span><a name="LN2412"></a>        <a href="../../../include/nodes/relation.h.html#LN845"><span class='Ref_to_Struct'>PathKey</span></a>    <span class='Operator'>*</span><span class='Declare_Local'>opathkey</span><span class='Delimiter'>; 
</span><a name="LN2413"></a>        <a href="../../../include/nodes/relation.h.html#LN845"><span class='Ref_to_Struct'>PathKey</span></a>    <span class='Operator'>*</span><span class='Declare_Local'>ipathkey</span><span class='Delimiter'>; 
</span><a name="LN2414"></a>        <a href="../../../include/nodes/relation.h.html#LN1818"><span class='Ref_to_Struct'>MergeScanSelCache</span></a> <span class='Operator'>*</span><span class='Declare_Local'>cache</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Get the input pathkeys to determine the sort-order details */ 
</span>        <a href="costsize.c.html#LN2410"><span class='Ref_To_Local'>opathkeys</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2372"><span class='Ref_to_Parameter'>outersortkeys</span></a> <span class='Operator'>? </span><a href="costsize.c.html#LN2372"><span class='Ref_to_Parameter'>outersortkeys</span></a> <span class='Operator'>: </span><a href="costsize.c.html#LN2371"><span class='Ref_to_Parameter'>outer_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN967"><span class='Ref_to_Member'>pathkeys</span></a><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN2411"><span class='Ref_To_Local'>ipathkeys</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2372"><span class='Ref_to_Parameter'>innersortkeys</span></a> <span class='Operator'>? </span><a href="costsize.c.html#LN2372"><span class='Ref_to_Parameter'>innersortkeys</span></a> <span class='Operator'>: </span><a href="costsize.c.html#LN2371"><span class='Ref_to_Parameter'>inner_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN967"><span class='Ref_to_Member'>pathkeys</span></a><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN2410"><span class='Ref_To_Local'>opathkeys</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN2411"><span class='Ref_To_Local'>ipathkeys</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN2412"><span class='Ref_To_Local'>opathkey</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN845"><span class='Ref_to_Struct'>PathKey</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN2410"><span class='Ref_To_Local'>opathkeys</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN2413"><span class='Ref_To_Local'>ipathkey</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN845"><span class='Ref_to_Struct'>PathKey</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN2411"><span class='Ref_To_Local'>ipathkeys</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* debugging check */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN2412"><span class='Ref_To_Local'>opathkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN850"><span class='Ref_to_Member'>pk_opfamily</span></a> <span class='Operator'>!= </span><a href="costsize.c.html#LN2413"><span class='Ref_To_Local'>ipathkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN850"><span class='Ref_to_Member'>pk_opfamily</span></a> <span class='Operator'>|| 
</span>            <a href="costsize.c.html#LN2412"><span class='Ref_To_Local'>opathkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN849"><span class='Ref_to_Member'>pk_eclass</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN771"><span class='Ref_to_Member'>ec_collation</span></a> <span class='Operator'>!= </span><a href="costsize.c.html#LN2413"><span class='Ref_To_Local'>ipathkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN849"><span class='Ref_to_Member'>pk_eclass</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN771"><span class='Ref_to_Member'>ec_collation</span></a> <span class='Operator'>|| 
</span>            <a href="costsize.c.html#LN2412"><span class='Ref_To_Local'>opathkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN851"><span class='Ref_to_Member'>pk_strategy</span></a> <span class='Operator'>!= </span><a href="costsize.c.html#LN2413"><span class='Ref_To_Local'>ipathkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN851"><span class='Ref_to_Member'>pk_strategy</span></a> <span class='Operator'>|| 
</span>            <a href="costsize.c.html#LN2412"><span class='Ref_To_Local'>opathkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN852"><span class='Ref_to_Member'>pk_nulls_first</span></a> <span class='Operator'>!= </span><a href="costsize.c.html#LN2413"><span class='Ref_To_Local'>ipathkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN852"><span class='Ref_to_Member'>pk_nulls_first</span></a><span class='Parentheses'>) 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"left and right pathkeys do not match in mergejoin"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Get the selectivity with caching */ 
</span>        <a href="costsize.c.html#LN2414"><span class='Ref_To_Local'>cache</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN137"><span class='Ref_to_Proto'>cached_scansel</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN2368"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN2409"><span class='Ref_To_Local'>firstclause</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN2412"><span class='Ref_To_Local'>opathkey</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN2409"><span class='Ref_To_Local'>firstclause</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1773"><span class='Ref_to_Member'>left_relids</span></a><span class='Delimiter'>, 
</span>                          <a href="costsize.c.html#LN2371"><span class='Ref_to_Parameter'>outer_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN952"><span class='Ref_to_Member'>parent</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* left side of clause is outer */ 
</span>            <a href="costsize.c.html#LN2384"><span class='Ref_To_Local'>outerstartsel</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2414"><span class='Ref_To_Local'>cache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1826"><span class='Ref_to_Member'>leftstartsel</span></a><span class='Delimiter'>; 
</span>            <a href="costsize.c.html#LN2385"><span class='Ref_To_Local'>outerendsel</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2414"><span class='Ref_To_Local'>cache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1827"><span class='Ref_to_Member'>leftendsel</span></a><span class='Delimiter'>; 
</span>            <a href="costsize.c.html#LN2386"><span class='Ref_To_Local'>innerstartsel</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2414"><span class='Ref_To_Local'>cache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1828"><span class='Ref_to_Member'>rightstartsel</span></a><span class='Delimiter'>; 
</span>            <a href="costsize.c.html#LN2387"><span class='Ref_To_Local'>innerendsel</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2414"><span class='Ref_To_Local'>cache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1829"><span class='Ref_to_Member'>rightendsel</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* left side of clause is inner */ 
</span>            <a href="costsize.c.html#LN2384"><span class='Ref_To_Local'>outerstartsel</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2414"><span class='Ref_To_Local'>cache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1828"><span class='Ref_to_Member'>rightstartsel</span></a><span class='Delimiter'>; 
</span>            <a href="costsize.c.html#LN2385"><span class='Ref_To_Local'>outerendsel</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2414"><span class='Ref_To_Local'>cache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1829"><span class='Ref_to_Member'>rightendsel</span></a><span class='Delimiter'>; 
</span>            <a href="costsize.c.html#LN2386"><span class='Ref_To_Local'>innerstartsel</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2414"><span class='Ref_To_Local'>cache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1826"><span class='Ref_to_Member'>leftstartsel</span></a><span class='Delimiter'>; 
</span>            <a href="costsize.c.html#LN2387"><span class='Ref_To_Local'>innerendsel</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2414"><span class='Ref_To_Local'>cache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1827"><span class='Ref_to_Member'>leftendsel</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN2369"><span class='Ref_to_Parameter'>jointype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN678"><span class='Ref_to_EnumConst'>JOIN_LEFT</span></a> <span class='Operator'>|| 
</span>            <a href="costsize.c.html#LN2369"><span class='Ref_to_Parameter'>jointype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN692"><span class='Ref_to_EnumConst'>JOIN_ANTI</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="costsize.c.html#LN2384"><span class='Ref_To_Local'>outerstartsel</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <a href="costsize.c.html#LN2385"><span class='Ref_To_Local'>outerendsel</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN2369"><span class='Ref_to_Parameter'>jointype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN680"><span class='Ref_to_EnumConst'>JOIN_RIGHT</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="costsize.c.html#LN2386"><span class='Ref_To_Local'>innerstartsel</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <a href="costsize.c.html#LN2387"><span class='Ref_To_Local'>innerendsel</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if mergeclauses&&jointyp... &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* cope with clauseless or full mergejoin */ 
</span>        <a href="costsize.c.html#LN2384"><span class='Ref_To_Local'>outerstartsel</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2386"><span class='Ref_To_Local'>innerstartsel</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN2385"><span class='Ref_To_Local'>outerendsel</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2387"><span class='Ref_To_Local'>innerendsel</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Convert selectivities to row counts.  We force outer_rows and 
     * inner_rows to be at least 1, but the skip_rows estimates can be zero. 
     */ 
</span>    <a href="costsize.c.html#LN2382"><span class='Ref_To_Local'>outer_skip_rows</span></a> <span class='Operator'>= </span><a href="../../../port/rint.c.html#LN20"><span class='Ref_to_Func'>rint</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN2377"><span class='Ref_To_Local'>outer_path_rows</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN2384"><span class='Ref_To_Local'>outerstartsel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN2383"><span class='Ref_To_Local'>inner_skip_rows</span></a> <span class='Operator'>= </span><a href="../../../port/rint.c.html#LN20"><span class='Ref_to_Func'>rint</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN2378"><span class='Ref_To_Local'>inner_path_rows</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN2386"><span class='Ref_To_Local'>innerstartsel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN2380"><span class='Ref_To_Local'>outer_rows</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/cost.h.html#LN71"><span class='Ref_to_Proto'>clamp_row_est</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN2377"><span class='Ref_To_Local'>outer_path_rows</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN2385"><span class='Ref_To_Local'>outerendsel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN2381"><span class='Ref_To_Local'>inner_rows</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/cost.h.html#LN71"><span class='Ref_to_Proto'>clamp_row_est</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN2378"><span class='Ref_To_Local'>inner_path_rows</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN2387"><span class='Ref_To_Local'>innerendsel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN2382"><span class='Ref_To_Local'>outer_skip_rows</span></a> <span class='Operator'>&LT;= </span><a href="costsize.c.html#LN2380"><span class='Ref_To_Local'>outer_rows</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN2383"><span class='Ref_To_Local'>inner_skip_rows</span></a> <span class='Operator'>&LT;= </span><a href="costsize.c.html#LN2381"><span class='Ref_To_Local'>inner_rows</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Readjust scan selectivities to account for above rounding.  This is 
     * normally an insignificant effect, but when there are only a few rows in 
     * the inputs, failing to do this makes for a large percentage error. 
     */ 
</span>    <a href="costsize.c.html#LN2384"><span class='Ref_To_Local'>outerstartsel</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2382"><span class='Ref_To_Local'>outer_skip_rows</span></a> <span class='Operator'>/ </span><a href="costsize.c.html#LN2377"><span class='Ref_To_Local'>outer_path_rows</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN2386"><span class='Ref_To_Local'>innerstartsel</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2383"><span class='Ref_To_Local'>inner_skip_rows</span></a> <span class='Operator'>/ </span><a href="costsize.c.html#LN2378"><span class='Ref_To_Local'>inner_path_rows</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN2385"><span class='Ref_To_Local'>outerendsel</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2380"><span class='Ref_To_Local'>outer_rows</span></a> <span class='Operator'>/ </span><a href="costsize.c.html#LN2377"><span class='Ref_To_Local'>outer_path_rows</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN2387"><span class='Ref_To_Local'>innerendsel</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2381"><span class='Ref_To_Local'>inner_rows</span></a> <span class='Operator'>/ </span><a href="costsize.c.html#LN2378"><span class='Ref_To_Local'>inner_path_rows</span></a><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN2384"><span class='Ref_To_Local'>outerstartsel</span></a> <span class='Operator'>&LT;= </span><a href="costsize.c.html#LN2385"><span class='Ref_To_Local'>outerendsel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN2386"><span class='Ref_To_Local'>innerstartsel</span></a> <span class='Operator'>&LT;= </span><a href="costsize.c.html#LN2387"><span class='Ref_To_Local'>innerendsel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* cost of source data */ 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN2372"><span class='Ref_to_Parameter'>outersortkeys</span></a><span class='Parentheses'>)</span>          <span class='Comment_Single_Line'>/* do we need to sort outer? */ 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/optimizer/cost.h.html#LN103"><span class='Ref_to_Proto'>cost_sort</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="costsize.c.html#LN2388"><span class='Ref_To_Local'>sort_path</span></a><span class='Delimiter'>, 
</span>                  <a href="costsize.c.html#LN2368"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                  <a href="costsize.c.html#LN2372"><span class='Ref_to_Parameter'>outersortkeys</span></a><span class='Delimiter'>, 
</span>                  <a href="costsize.c.html#LN2371"><span class='Ref_to_Parameter'>outer_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a><span class='Delimiter'>, 
</span>                  <a href="costsize.c.html#LN2377"><span class='Ref_To_Local'>outer_path_rows</span></a><span class='Delimiter'>, 
</span>                  <a href="costsize.c.html#LN2371"><span class='Ref_to_Parameter'>outer_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN953"><span class='Ref_to_Member'>pathtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN885"><span class='Ref_to_Member'>width</span></a><span class='Delimiter'>, 
</span>                  <span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>, 
</span>                  <a href="../../utils/init/globals.c.html#LN112"><span class='Ref_to_Global_Var'>work_mem</span></a><span class='Delimiter'>, 
</span>                  <span class='Operator'>-</span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN2375"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN2388"><span class='Ref_To_Local'>sort_path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN2375"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><span class='Parentheses'>(</span><a href="costsize.c.html#LN2388"><span class='Ref_To_Local'>sort_path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>- </span><a href="costsize.c.html#LN2388"><span class='Ref_To_Local'>sort_path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a><span class='Parentheses'>) 
</span>            <span class='Operator'>* </span><a href="costsize.c.html#LN2384"><span class='Ref_To_Local'>outerstartsel</span></a><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN2376"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><span class='Parentheses'>(</span><a href="costsize.c.html#LN2388"><span class='Ref_To_Local'>sort_path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>- </span><a href="costsize.c.html#LN2388"><span class='Ref_To_Local'>sort_path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a><span class='Parentheses'>) 
</span>            <span class='Operator'>* </span><span class='Parentheses'>(</span><a href="costsize.c.html#LN2385"><span class='Ref_To_Local'>outerendsel</span></a> <span class='Operator'>- </span><a href="costsize.c.html#LN2384"><span class='Ref_To_Local'>outerstartsel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="costsize.c.html#LN2375"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN2371"><span class='Ref_to_Parameter'>outer_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN2375"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><span class='Parentheses'>(</span><a href="costsize.c.html#LN2371"><span class='Ref_to_Parameter'>outer_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>- </span><a href="costsize.c.html#LN2371"><span class='Ref_to_Parameter'>outer_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a><span class='Parentheses'>) 
</span>            <span class='Operator'>* </span><a href="costsize.c.html#LN2384"><span class='Ref_To_Local'>outerstartsel</span></a><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN2376"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><span class='Parentheses'>(</span><a href="costsize.c.html#LN2371"><span class='Ref_to_Parameter'>outer_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>- </span><a href="costsize.c.html#LN2371"><span class='Ref_to_Parameter'>outer_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a><span class='Parentheses'>) 
</span>            <span class='Operator'>* </span><span class='Parentheses'>(</span><a href="costsize.c.html#LN2385"><span class='Ref_To_Local'>outerendsel</span></a> <span class='Operator'>- </span><a href="costsize.c.html#LN2384"><span class='Ref_To_Local'>outerstartsel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN2372"><span class='Ref_to_Parameter'>innersortkeys</span></a><span class='Parentheses'>)</span>          <span class='Comment_Single_Line'>/* do we need to sort inner? */ 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/optimizer/cost.h.html#LN103"><span class='Ref_to_Proto'>cost_sort</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="costsize.c.html#LN2388"><span class='Ref_To_Local'>sort_path</span></a><span class='Delimiter'>, 
</span>                  <a href="costsize.c.html#LN2368"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                  <a href="costsize.c.html#LN2372"><span class='Ref_to_Parameter'>innersortkeys</span></a><span class='Delimiter'>, 
</span>                  <a href="costsize.c.html#LN2371"><span class='Ref_to_Parameter'>inner_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a><span class='Delimiter'>, 
</span>                  <a href="costsize.c.html#LN2378"><span class='Ref_To_Local'>inner_path_rows</span></a><span class='Delimiter'>, 
</span>                  <a href="costsize.c.html#LN2371"><span class='Ref_to_Parameter'>inner_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN953"><span class='Ref_to_Member'>pathtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN885"><span class='Ref_to_Member'>width</span></a><span class='Delimiter'>, 
</span>                  <span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>, 
</span>                  <a href="../../utils/init/globals.c.html#LN112"><span class='Ref_to_Global_Var'>work_mem</span></a><span class='Delimiter'>, 
</span>                  <span class='Operator'>-</span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN2375"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN2388"><span class='Ref_To_Local'>sort_path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN2375"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><span class='Parentheses'>(</span><a href="costsize.c.html#LN2388"><span class='Ref_To_Local'>sort_path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>- </span><a href="costsize.c.html#LN2388"><span class='Ref_To_Local'>sort_path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a><span class='Parentheses'>) 
</span>            <span class='Operator'>* </span><a href="costsize.c.html#LN2386"><span class='Ref_To_Local'>innerstartsel</span></a><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN2379"><span class='Ref_To_Local'>inner_run_cost</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="costsize.c.html#LN2388"><span class='Ref_To_Local'>sort_path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>- </span><a href="costsize.c.html#LN2388"><span class='Ref_To_Local'>sort_path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a><span class='Parentheses'>) 
</span>            <span class='Operator'>* </span><span class='Parentheses'>(</span><a href="costsize.c.html#LN2387"><span class='Ref_To_Local'>innerendsel</span></a> <span class='Operator'>- </span><a href="costsize.c.html#LN2386"><span class='Ref_To_Local'>innerstartsel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="costsize.c.html#LN2375"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN2371"><span class='Ref_to_Parameter'>inner_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN2375"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><span class='Parentheses'>(</span><a href="costsize.c.html#LN2371"><span class='Ref_to_Parameter'>inner_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>- </span><a href="costsize.c.html#LN2371"><span class='Ref_to_Parameter'>inner_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a><span class='Parentheses'>) 
</span>            <span class='Operator'>* </span><a href="costsize.c.html#LN2386"><span class='Ref_To_Local'>innerstartsel</span></a><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN2379"><span class='Ref_To_Local'>inner_run_cost</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="costsize.c.html#LN2371"><span class='Ref_to_Parameter'>inner_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>- </span><a href="costsize.c.html#LN2371"><span class='Ref_to_Parameter'>inner_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a><span class='Parentheses'>) 
</span>            <span class='Operator'>* </span><span class='Parentheses'>(</span><a href="costsize.c.html#LN2387"><span class='Ref_To_Local'>innerendsel</span></a> <span class='Operator'>- </span><a href="costsize.c.html#LN2386"><span class='Ref_To_Local'>innerstartsel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We can't yet determine whether rescanning occurs, or whether 
     * materialization of the inner input should be done.  The minimum 
     * possible inner input cost, regardless of rescan and materialization 
     * considerations, is inner_run_cost.  We include that in 
     * workspace-&GT;total_cost, but not yet in run_cost. 
     */ 
</span> 
    <span class='Comment_Multi_Line'>/* CPU costs left for later */ 
</span> 
    <span class='Comment_Multi_Line'>/* Public result fields */ 
</span>    <a href="costsize.c.html#LN2368"><span class='Ref_to_Parameter'>workspace</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2202"><span class='Ref_to_Member'>startup_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2375"><span class='Ref_To_Local'>startup_cost</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN2368"><span class='Ref_to_Parameter'>workspace</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2203"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2375"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN2376"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN2379"><span class='Ref_To_Local'>inner_run_cost</span></a><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* Save private data for final_cost_mergejoin */ 
</span>    <a href="costsize.c.html#LN2368"><span class='Ref_to_Parameter'>workspace</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2206"><span class='Ref_to_Member'>run_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2376"><span class='Ref_To_Local'>run_cost</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN2368"><span class='Ref_to_Parameter'>workspace</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2209"><span class='Ref_to_Member'>inner_run_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2379"><span class='Ref_To_Local'>inner_run_cost</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN2368"><span class='Ref_to_Parameter'>workspace</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2213"><span class='Ref_to_Member'>outer_rows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2380"><span class='Ref_To_Local'>outer_rows</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN2368"><span class='Ref_to_Parameter'>workspace</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2214"><span class='Ref_to_Member'>inner_rows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2381"><span class='Ref_To_Local'>inner_rows</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN2368"><span class='Ref_to_Parameter'>workspace</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2215"><span class='Ref_to_Member'>outer_skip_rows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2382"><span class='Ref_To_Local'>outer_skip_rows</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN2368"><span class='Ref_to_Parameter'>workspace</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2216"><span class='Ref_to_Member'>inner_skip_rows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2383"><span class='Ref_To_Local'>inner_skip_rows</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end initial_cost_mergejoin &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * final_cost_mergejoin 
 *    Final estimate of the cost and result size of a mergejoin path. 
 * 
 * Unlike other costsize functions, this routine makes two actual decisions: 
 * whether the executor will need to do mark/restore, and whether we should 
 * materialize the inner path.  It would be logically cleaner to build 
 * separate paths testing these alternatives, but that would require repeating 
 * most of the cost calculations, which are not all that cheap.  Since the 
 * choice will not affect output pathkeys or startup cost, only total cost, 
 * there is no possibility of wanting to keep more than one path.  So it seems 
 * best to make the decisions here and record them in the path's 
 * skip_mark_restore and materialize_inner fields. 
 * 
 * Mark/restore overhead is usually required, but can be skipped if we know 
 * that the executor need find only one match per outer tuple, and that the 
 * mergeclauses are sufficient to identify a match. 
 * 
 * We materialize the inner path if we need mark/restore and either the inner 
 * path can't support mark/restore, or it's cheaper to use an interposed 
 * Material node to handle mark/restore. 
 * 
 * 'path' is already filled in except for the rows and cost fields and 
 *      skip_mark_restore and materialize_inner 
 * 'workspace' is the result from initial_cost_mergejoin 
 * 'extra' contains miscellaneous information about the join 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN2598"></a><span class='Declare_Function'>final_cost_mergejoin</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1348"><span class='Ref_to_Struct'>MergePath</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Delimiter'>, 
</span><a name="LN2599"></a>                     <a href="../../../include/nodes/relation.h.html#LN2199"><span class='Ref_to_Struct'>JoinCostWorkspace</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>workspace</span><span class='Delimiter'>, 
</span><a name="LN2600"></a>                     <a href="../../../include/nodes/relation.h.html#LN2177"><span class='Ref_to_Struct'>JoinPathExtraData</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>extra</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2602"></a>    <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>outer_path</span> <span class='Operator'>= </span><a href="costsize.c.html#LN2598"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1350"><span class='Ref_to_Member'>jpath</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1295"><span class='Ref_to_Member'>outerjoinpath</span></a><span class='Delimiter'>; 
</span><a name="LN2603"></a>    <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>inner_path</span> <span class='Operator'>= </span><a href="costsize.c.html#LN2598"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1350"><span class='Ref_to_Member'>jpath</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1296"><span class='Ref_to_Member'>innerjoinpath</span></a><span class='Delimiter'>; 
</span><a name="LN2604"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>inner_path_rows</span> <span class='Operator'>= </span><a href="costsize.c.html#LN2603"><span class='Ref_To_Local'>inner_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span><a name="LN2605"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>mergeclauses</span> <span class='Operator'>= </span><a href="costsize.c.html#LN2598"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1351"><span class='Ref_to_Member'>path_mergeclauses</span></a><span class='Delimiter'>; 
</span><a name="LN2606"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>innersortkeys</span> <span class='Operator'>= </span><a href="costsize.c.html#LN2598"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1353"><span class='Ref_to_Member'>innersortkeys</span></a><span class='Delimiter'>; 
</span><a name="LN2607"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>startup_cost</span> <span class='Operator'>= </span><a href="costsize.c.html#LN2599"><span class='Ref_to_Parameter'>workspace</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2202"><span class='Ref_to_Member'>startup_cost</span></a><span class='Delimiter'>; 
</span><a name="LN2608"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>run_cost</span> <span class='Operator'>= </span><a href="costsize.c.html#LN2599"><span class='Ref_to_Parameter'>workspace</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2206"><span class='Ref_to_Member'>run_cost</span></a><span class='Delimiter'>; 
</span><a name="LN2609"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>inner_run_cost</span> <span class='Operator'>= </span><a href="costsize.c.html#LN2599"><span class='Ref_to_Parameter'>workspace</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2209"><span class='Ref_to_Member'>inner_run_cost</span></a><span class='Delimiter'>; 
</span><a name="LN2610"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>outer_rows</span> <span class='Operator'>= </span><a href="costsize.c.html#LN2599"><span class='Ref_to_Parameter'>workspace</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2213"><span class='Ref_to_Member'>outer_rows</span></a><span class='Delimiter'>; 
</span><a name="LN2611"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>inner_rows</span> <span class='Operator'>= </span><a href="costsize.c.html#LN2599"><span class='Ref_to_Parameter'>workspace</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2214"><span class='Ref_to_Member'>inner_rows</span></a><span class='Delimiter'>; 
</span><a name="LN2612"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>outer_skip_rows</span> <span class='Operator'>= </span><a href="costsize.c.html#LN2599"><span class='Ref_to_Parameter'>workspace</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2215"><span class='Ref_to_Member'>outer_skip_rows</span></a><span class='Delimiter'>; 
</span><a name="LN2613"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>inner_skip_rows</span> <span class='Operator'>= </span><a href="costsize.c.html#LN2599"><span class='Ref_to_Parameter'>workspace</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2216"><span class='Ref_to_Member'>inner_skip_rows</span></a><span class='Delimiter'>; 
</span><a name="LN2614"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>cpu_per_tuple</span><span class='Delimiter'>, 
</span><a name="LN2615"></a>                <span class='Declare_Local'>bare_inner_cost</span><span class='Delimiter'>, 
</span><a name="LN2616"></a>                <span class='Declare_Local'>mat_inner_cost</span><span class='Delimiter'>; 
</span><a name="LN2617"></a>    <a href="../../../include/nodes/relation.h.html#LN42"><span class='Ref_to_Struct'>QualCost</span></a>    <span class='Declare_Local'>merge_qual_cost</span><span class='Delimiter'>; 
</span><a name="LN2618"></a>    <a href="../../../include/nodes/relation.h.html#LN42"><span class='Ref_to_Struct'>QualCost</span></a>    <span class='Declare_Local'>qp_qual_cost</span><span class='Delimiter'>; 
</span><a name="LN2619"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>mergejointuples</span><span class='Delimiter'>, 
</span><a name="LN2620"></a>                <span class='Declare_Local'>rescannedtuples</span><span class='Delimiter'>; 
</span><a name="LN2621"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>rescanratio</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Protect some assumptions below that rowcounts aren't zero or NaN */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN2604"><span class='Ref_To_Local'>inner_path_rows</span></a> <span class='Operator'>&LT;= </span><span class='Number'>0</span> <span class='Operator'>|| </span><a href="../../../interfaces/ecpg/test/expected/pgtypeslib-nan_test.c.html#LN30"><span class='Ref_to_Macro'>isnan</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN2604"><span class='Ref_To_Local'>inner_path_rows</span></a><span class='Parentheses'>))</span> 
        <a href="costsize.c.html#LN2604"><span class='Ref_To_Local'>inner_path_rows</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Mark the path with the correct row estimate */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN2598"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1350"><span class='Ref_to_Member'>jpath</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1288"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN955"><span class='Ref_to_Member'>param_info</span></a><span class='Parentheses'>) 
</span>        <a href="costsize.c.html#LN2598"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1350"><span class='Ref_to_Member'>jpath</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1288"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2598"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1350"><span class='Ref_to_Member'>jpath</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1288"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN955"><span class='Ref_to_Member'>param_info</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN912"><span class='Ref_to_Member'>ppi_rows</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="costsize.c.html#LN2598"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1350"><span class='Ref_to_Member'>jpath</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1288"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2598"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1350"><span class='Ref_to_Member'>jpath</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1288"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN952"><span class='Ref_to_Member'>parent</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* For partial paths, scale row estimate. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN2598"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1350"><span class='Ref_to_Member'>jpath</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1288"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN959"><span class='Ref_to_Member'>parallel_workers</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2636"></a>        <span class='Keyword'>double</span>      <span class='Declare_Local'>parallel_divisor</span> <span class='Operator'>= </span><a href="costsize.c.html#LN164"><span class='Ref_to_Proto'>get_parallel_divisor</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="costsize.c.html#LN2598"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1350"><span class='Ref_to_Member'>jpath</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1288"><span class='Ref_to_Member'>path</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="costsize.c.html#LN2598"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1350"><span class='Ref_to_Member'>jpath</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1288"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= 
</span>            <a href="../../../include/optimizer/cost.h.html#LN71"><span class='Ref_to_Proto'>clamp_row_est</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN2598"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1350"><span class='Ref_to_Member'>jpath</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1288"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>/ </span><a href="costsize.c.html#LN2636"><span class='Ref_To_Local'>parallel_divisor</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We could include disable_cost in the preliminary estimate, but that 
     * would amount to optimizing for the case where the join method is 
     * disabled, which doesn't seem like the way to bet. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="costsize.c.html#LN126"><span class='Ref_to_Global_Var'>enable_mergejoin</span></a><span class='Parentheses'>) 
</span>        <a href="costsize.c.html#LN2607"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN113"><span class='Ref_to_Global_Var'>disable_cost</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Compute cost of the mergequals and qpquals (other restriction clauses) 
     * separately. 
     */ 
</span>    <a href="../../../include/optimizer/cost.h.html#LN157"><span class='Ref_to_Proto'>cost_qual_eval</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="costsize.c.html#LN2617"><span class='Ref_To_Local'>merge_qual_cost</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN2605"><span class='Ref_To_Local'>mergeclauses</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN2598"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/optimizer/cost.h.html#LN157"><span class='Ref_to_Proto'>cost_qual_eval</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="costsize.c.html#LN2618"><span class='Ref_To_Local'>qp_qual_cost</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN2598"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1350"><span class='Ref_to_Member'>jpath</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1298"><span class='Ref_to_Member'>joinrestrictinfo</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN2598"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN2618"><span class='Ref_To_Local'>qp_qual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a> <span class='Operator'>-= </span><a href="costsize.c.html#LN2617"><span class='Ref_To_Local'>merge_qual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN2618"><span class='Ref_To_Local'>qp_qual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>-= </span><a href="costsize.c.html#LN2617"><span class='Ref_To_Local'>merge_qual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * With a SEMI or ANTI join, or if the innerrel is known unique, the 
     * executor will stop scanning for matches after the first match.  When 
     * all the joinclauses are merge clauses, this means we don't ever need to 
     * back up the merge, and so we can skip mark/restore overhead. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="costsize.c.html#LN2598"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1350"><span class='Ref_to_Member'>jpath</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1290"><span class='Ref_to_Member'>jointype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN691"><span class='Ref_to_EnumConst'>JOIN_SEMI</span></a> <span class='Operator'>|| 
</span>         <a href="costsize.c.html#LN2598"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1350"><span class='Ref_to_Member'>jpath</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1290"><span class='Ref_to_Member'>jointype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN692"><span class='Ref_to_EnumConst'>JOIN_ANTI</span></a> <span class='Operator'>|| 
</span>         <a href="costsize.c.html#LN2600"><span class='Ref_to_Parameter'>extra</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2181"><span class='Ref_to_Member'>inner_unique</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>        <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN2598"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1350"><span class='Ref_to_Member'>jpath</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1298"><span class='Ref_to_Member'>joinrestrictinfo</span></a><span class='Parentheses'>) </span><span class='Operator'>== 
</span>         <a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN2598"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1351"><span class='Ref_to_Member'>path_mergeclauses</span></a><span class='Parentheses'>)))</span> 
        <a href="costsize.c.html#LN2598"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1354"><span class='Ref_to_Member'>skip_mark_restore</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="costsize.c.html#LN2598"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1354"><span class='Ref_to_Member'>skip_mark_restore</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Get approx # tuples passing the mergequals.  We use approx_tuple_count 
     * here because we need an estimate done with JOIN_INNER semantics. 
     */ 
</span>    <a href="costsize.c.html#LN2619"><span class='Ref_To_Local'>mergejointuples</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN147"><span class='Ref_to_Proto'>approx_tuple_count</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN2598"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="costsize.c.html#LN2598"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1350"><span class='Ref_to_Member'>jpath</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN2605"><span class='Ref_To_Local'>mergeclauses</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * When there are equal merge keys in the outer relation, the mergejoin 
     * must rescan any matching tuples in the inner relation. This means 
     * re-fetching inner tuples; we have to estimate how often that happens. 
     * 
     * For regular inner and outer joins, the number of re-fetches can be 
     * estimated approximately as size of merge join output minus size of 
     * inner relation. Assume that the distinct key values are 1, 2, ..., and 
     * denote the number of values of each key in the outer relation as m1, 
     * m2, ...; in the inner relation, n1, n2, ...  Then we have 
     * 
     * size of join = m1 * n1 + m2 * n2 + ... 
     * 
     * number of rescanned tuples = (m1 - 1) * n1 + (m2 - 1) * n2 + ... = m1 * 
     * n1 + m2 * n2 + ... - (n1 + n2 + ...) = size of join - size of inner 
     * relation 
     * 
     * This equation works correctly for outer tuples having no inner match 
     * (nk = 0), but not for inner tuples having no outer match (mk = 0); we 
     * are effectively subtracting those from the number of rescanned tuples, 
     * when we should not.  Can we do better without expensive selectivity 
     * computations? 
     * 
     * The whole issue is moot if we are working from a unique-ified outer 
     * input, or if we know we don't need to mark/restore at all. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN2602"><span class='Ref_To_Local'>outer_path</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1247"><span class='Ref_to_Struct'>UniquePath</span></a><span class='Parentheses'>) </span><span class='Operator'>||</span><a href="costsize.c.html#LN2598"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1354"><span class='Ref_to_Member'>skip_mark_restore</span></a><span class='Parentheses'>)</span> 
        <a href="costsize.c.html#LN2620"><span class='Ref_To_Local'>rescannedtuples</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="costsize.c.html#LN2620"><span class='Ref_To_Local'>rescannedtuples</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2619"><span class='Ref_To_Local'>mergejointuples</span></a> <span class='Operator'>- </span><a href="costsize.c.html#LN2604"><span class='Ref_To_Local'>inner_path_rows</span></a><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* Must clamp because of possible underestimate */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN2620"><span class='Ref_To_Local'>rescannedtuples</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <a href="costsize.c.html#LN2620"><span class='Ref_To_Local'>rescannedtuples</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Comment_Multi_Line'>/* We'll inflate various costs this much to account for rescanning */ 
</span>    <a href="costsize.c.html#LN2621"><span class='Ref_To_Local'>rescanratio</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>+ </span><span class='Parentheses'>(</span><a href="costsize.c.html#LN2620"><span class='Ref_To_Local'>rescannedtuples</span></a> <span class='Operator'>/ </span><a href="costsize.c.html#LN2604"><span class='Ref_To_Local'>inner_path_rows</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Decide whether we want to materialize the inner input to shield it from 
     * mark/restore and performing re-fetches.  Our cost model for regular 
     * re-fetches is that a re-fetch costs the same as an original fetch, 
     * which is probably an overestimate; but on the other hand we ignore the 
     * bookkeeping costs of mark/restore.  Not clear if it's worth developing 
     * a more refined model.  So we just need to inflate the inner run cost by 
     * rescanratio. 
     */ 
</span>    <a href="costsize.c.html#LN2615"><span class='Ref_To_Local'>bare_inner_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2609"><span class='Ref_To_Local'>inner_run_cost</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN2621"><span class='Ref_To_Local'>rescanratio</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * When we interpose a Material node the re-fetch cost is assumed to be 
     * just cpu_operator_cost per tuple, independently of the underlying 
     * plan's cost; and we charge an extra cpu_operator_cost per original 
     * fetch as well.  Note that we're assuming the materialize node will 
     * never spill to disk, since it only has to remember tuples back to the 
     * last mark.  (If there are a huge number of duplicates, our other cost 
     * factors will make the path so expensive that it probably won't get 
     * chosen anyway.)  So we don't use cost_rescan here. 
     * 
     * Note: keep this estimate in sync with create_mergejoin_plan's labeling 
     * of the generated Material node. 
     */ 
</span>    <a href="costsize.c.html#LN2616"><span class='Ref_To_Local'>mat_inner_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2609"><span class='Ref_To_Local'>inner_run_cost</span></a> <span class='Operator'>+ 
</span>        <a href="costsize.c.html#LN107"><span class='Ref_to_Global_Var'>cpu_operator_cost</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN2604"><span class='Ref_To_Local'>inner_path_rows</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN2621"><span class='Ref_To_Local'>rescanratio</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we don't need mark/restore at all, we don't need materialization. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN2598"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1354"><span class='Ref_to_Member'>skip_mark_restore</span></a><span class='Parentheses'>) 
</span>        <a href="costsize.c.html#LN2598"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1355"><span class='Ref_to_Member'>materialize_inner</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Prefer materializing if it looks cheaper, unless the user has asked to 
     * suppress materialization. 
     */ 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN125"><span class='Ref_to_Global_Var'>enable_material</span></a> <span class='Operator'>&& </span><a href="costsize.c.html#LN2616"><span class='Ref_To_Local'>mat_inner_cost</span></a> <span class='Operator'>&LT; </span><a href="costsize.c.html#LN2615"><span class='Ref_To_Local'>bare_inner_cost</span></a><span class='Parentheses'>) 
</span>        <a href="costsize.c.html#LN2598"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1355"><span class='Ref_to_Member'>materialize_inner</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Even if materializing doesn't look cheaper, we *must* do it if the 
     * inner path is to be used directly (without sorting) and it doesn't 
     * support mark/restore. 
     * 
     * Since the inner side must be ordered, and only Sorts and IndexScans can 
     * create order to begin with, and they both support mark/restore, you 
     * might think there's no problem --- but you'd be wrong.  Nestloop and 
     * merge joins can *preserve* the order of their inputs, so they can be 
     * selected as the input of a mergejoin, and they don't support 
     * mark/restore at present. 
     * 
     * We don't test the value of enable_material here, because 
     * materialization is required for correctness in this case, and turning 
     * it off does not entitle us to deliver an invalid plan. 
     */ 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN2606"><span class='Ref_To_Local'>innersortkeys</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>&& 
</span>             <span class='Operator'>!</span><a href="../../../include/executor/executor.h.html#LN99"><span class='Ref_to_Proto'>ExecSupportsMarkRestore</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN2603"><span class='Ref_To_Local'>inner_path</span></a><span class='Parentheses'>))</span> 
        <a href="costsize.c.html#LN2598"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1355"><span class='Ref_to_Member'>materialize_inner</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Also, force materializing if the inner path is to be sorted and the 
     * sort is expected to spill to disk.  This is because the final merge 
     * pass can be done on-the-fly if it doesn't have to support mark/restore. 
     * We don't try to adjust the cost estimates for this consideration, 
     * though. 
     * 
     * Since materialization is a performance optimization in this case, 
     * rather than necessary for correctness, we skip it if enable_material is 
     * off. 
     */ 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN125"><span class='Ref_to_Global_Var'>enable_material</span></a> <span class='Operator'>&& </span><a href="costsize.c.html#LN2606"><span class='Ref_To_Local'>innersortkeys</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>&& 
</span>             <a href="costsize.c.html#LN162"><span class='Ref_to_Proto'>relation_byte_size</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN2604"><span class='Ref_To_Local'>inner_path_rows</span></a><span class='Delimiter'>, 
</span>                                <a href="costsize.c.html#LN2603"><span class='Ref_To_Local'>inner_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN953"><span class='Ref_to_Member'>pathtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN885"><span class='Ref_to_Member'>width</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT; 
</span>             <span class='Parentheses'>(</span><a href="../../utils/init/globals.c.html#LN112"><span class='Ref_to_Global_Var'>work_mem</span></a> <span class='Operator'>* </span><span class='Number'>1024L</span><span class='Parentheses'>))</span> 
        <a href="costsize.c.html#LN2598"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1355"><span class='Ref_to_Member'>materialize_inner</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="costsize.c.html#LN2598"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1355"><span class='Ref_to_Member'>materialize_inner</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Charge the right incremental cost for the chosen case */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN2598"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1355"><span class='Ref_to_Member'>materialize_inner</span></a><span class='Parentheses'>) 
</span>        <a href="costsize.c.html#LN2608"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN2616"><span class='Ref_To_Local'>mat_inner_cost</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="costsize.c.html#LN2608"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN2615"><span class='Ref_To_Local'>bare_inner_cost</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* CPU costs */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * The number of tuple comparisons needed is approximately number of outer 
     * rows plus number of inner rows plus number of rescanned tuples (can we 
     * refine this?).  At each one, we need to evaluate the mergejoin quals. 
     */ 
</span>    <a href="costsize.c.html#LN2607"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN2617"><span class='Ref_To_Local'>merge_qual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN2607"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN2617"><span class='Ref_To_Local'>merge_qual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>* 
</span>        <span class='Parentheses'>(</span><a href="costsize.c.html#LN2612"><span class='Ref_To_Local'>outer_skip_rows</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN2613"><span class='Ref_To_Local'>inner_skip_rows</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN2621"><span class='Ref_To_Local'>rescanratio</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN2608"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN2617"><span class='Ref_To_Local'>merge_qual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>* 
</span>        <span class='Parentheses'>((</span><a href="costsize.c.html#LN2610"><span class='Ref_To_Local'>outer_rows</span></a> <span class='Operator'>- </span><a href="costsize.c.html#LN2612"><span class='Ref_To_Local'>outer_skip_rows</span></a><span class='Parentheses'>) </span><span class='Operator'>+ 
</span>         <span class='Parentheses'>(</span><a href="costsize.c.html#LN2611"><span class='Ref_To_Local'>inner_rows</span></a> <span class='Operator'>- </span><a href="costsize.c.html#LN2613"><span class='Ref_To_Local'>inner_skip_rows</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="costsize.c.html#LN2621"><span class='Ref_To_Local'>rescanratio</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * For each tuple that gets through the mergejoin proper, we charge 
     * cpu_tuple_cost plus the cost of evaluating additional restriction 
     * clauses that are to be applied at the join.  (This is pessimistic since 
     * not all of the quals may get evaluated at each tuple.) 
     * 
     * Note: we could adjust for SEMI/ANTI joins skipping some qual 
     * evaluations here, but it's probably not worth the trouble. 
     */ 
</span>    <a href="costsize.c.html#LN2607"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN2618"><span class='Ref_To_Local'>qp_qual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN2614"><span class='Ref_To_Local'>cpu_per_tuple</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN105"><span class='Ref_to_Global_Var'>cpu_tuple_cost</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN2618"><span class='Ref_To_Local'>qp_qual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN2608"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN2614"><span class='Ref_To_Local'>cpu_per_tuple</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN2619"><span class='Ref_To_Local'>mergejointuples</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* tlist eval costs are paid per output row, not per tuple scanned */ 
</span>    <a href="costsize.c.html#LN2607"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN2598"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1350"><span class='Ref_to_Member'>jpath</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1288"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN953"><span class='Ref_to_Member'>pathtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN884"><span class='Ref_to_Member'>cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN2608"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN2598"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1350"><span class='Ref_to_Member'>jpath</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1288"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN953"><span class='Ref_to_Member'>pathtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN884"><span class='Ref_to_Member'>cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN2598"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1350"><span class='Ref_to_Member'>jpath</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1288"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN2598"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1350"><span class='Ref_to_Member'>jpath</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1288"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2607"><span class='Ref_To_Local'>startup_cost</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN2598"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1350"><span class='Ref_to_Member'>jpath</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1288"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2607"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN2608"><span class='Ref_To_Local'>run_cost</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end final_cost_mergejoin &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * run mergejoinscansel() with caching 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/relation.h.html#LN1818"><span class='Ref_to_Struct'>MergeScanSelCache</span></a> <span class='Operator'>* 
</span><a name="LN2842"></a><span class='Declare_Function'>cached_scansel</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rinfo</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN845"><span class='Ref_to_Struct'>PathKey</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>pathkey</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2844"></a>    <a href="../../../include/nodes/relation.h.html#LN1818"><span class='Ref_to_Struct'>MergeScanSelCache</span></a> <span class='Operator'>*</span><span class='Declare_Local'>cache</span><span class='Delimiter'>; 
</span><a name="LN2845"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span><a name="LN2846"></a>    <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Local'>leftstartsel</span><span class='Delimiter'>, 
</span><a name="LN2847"></a>                <span class='Declare_Local'>leftendsel</span><span class='Delimiter'>, 
</span><a name="LN2848"></a>                <span class='Declare_Local'>rightstartsel</span><span class='Delimiter'>, 
</span><a name="LN2849"></a>                <span class='Declare_Local'>rightendsel</span><span class='Delimiter'>; 
</span><a name="LN2850"></a>    <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldcontext</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Do we have this result already? */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN2845"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN2842"><span class='Ref_to_Parameter'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1798"><span class='Ref_to_Member'>scansel_cache</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="costsize.c.html#LN2844"><span class='Ref_To_Local'>cache</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1818"><span class='Ref_to_Struct'>MergeScanSelCache</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN2845"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN2844"><span class='Ref_To_Local'>cache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1821"><span class='Ref_to_Member'>opfamily</span></a> <span class='Operator'>== </span><a href="costsize.c.html#LN2842"><span class='Ref_to_Parameter'>pathkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN850"><span class='Ref_to_Member'>pk_opfamily</span></a> <span class='Operator'>&& 
</span>            <a href="costsize.c.html#LN2844"><span class='Ref_To_Local'>cache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1822"><span class='Ref_to_Member'>collation</span></a> <span class='Operator'>== </span><a href="costsize.c.html#LN2842"><span class='Ref_to_Parameter'>pathkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN849"><span class='Ref_to_Member'>pk_eclass</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN771"><span class='Ref_to_Member'>ec_collation</span></a> <span class='Operator'>&& 
</span>            <a href="costsize.c.html#LN2844"><span class='Ref_To_Local'>cache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1823"><span class='Ref_to_Member'>strategy</span></a> <span class='Operator'>== </span><a href="costsize.c.html#LN2842"><span class='Ref_to_Parameter'>pathkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN851"><span class='Ref_to_Member'>pk_strategy</span></a> <span class='Operator'>&& 
</span>            <a href="costsize.c.html#LN2844"><span class='Ref_To_Local'>cache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1824"><span class='Ref_to_Member'>nulls_first</span></a> <span class='Operator'>== </span><a href="costsize.c.html#LN2842"><span class='Ref_to_Parameter'>pathkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN852"><span class='Ref_to_Member'>pk_nulls_first</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <a href="costsize.c.html#LN2844"><span class='Ref_To_Local'>cache</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Nope, do the computation */ 
</span>    <a href="../../../include/utils/selfuncs.h.html#LN200"><span class='Ref_to_Proto'>mergejoinscansel</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN2842"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                     <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN2842"><span class='Ref_to_Parameter'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1746"><span class='Ref_to_Member'>clause</span></a><span class='Delimiter'>, 
</span>                     <a href="costsize.c.html#LN2842"><span class='Ref_to_Parameter'>pathkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN850"><span class='Ref_to_Member'>pk_opfamily</span></a><span class='Delimiter'>, 
</span>                     <a href="costsize.c.html#LN2842"><span class='Ref_to_Parameter'>pathkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN851"><span class='Ref_to_Member'>pk_strategy</span></a><span class='Delimiter'>, 
</span>                     <a href="costsize.c.html#LN2842"><span class='Ref_to_Parameter'>pathkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN852"><span class='Ref_to_Member'>pk_nulls_first</span></a><span class='Delimiter'>, 
</span>                     <span class='Operator'>&</span><a href="costsize.c.html#LN2846"><span class='Ref_To_Local'>leftstartsel</span></a><span class='Delimiter'>, 
</span>                     <span class='Operator'>&</span><a href="costsize.c.html#LN2847"><span class='Ref_To_Local'>leftendsel</span></a><span class='Delimiter'>, 
</span>                     <span class='Operator'>&</span><a href="costsize.c.html#LN2848"><span class='Ref_To_Local'>rightstartsel</span></a><span class='Delimiter'>, 
</span>                     <span class='Operator'>&</span><a href="costsize.c.html#LN2849"><span class='Ref_To_Local'>rightendsel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Cache the result in suitably long-lived workspace */ 
</span>    <a href="costsize.c.html#LN2850"><span class='Ref_To_Local'>oldcontext</span></a> <span class='Operator'>= </span><a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN2842"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN286"><span class='Ref_to_Member'>planner_cxt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN2844"><span class='Ref_To_Local'>cache</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1818"><span class='Ref_to_Struct'>MergeScanSelCache</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1818"><span class='Ref_to_Struct'>MergeScanSelCache</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN2844"><span class='Ref_To_Local'>cache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1821"><span class='Ref_to_Member'>opfamily</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2842"><span class='Ref_to_Parameter'>pathkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN850"><span class='Ref_to_Member'>pk_opfamily</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN2844"><span class='Ref_To_Local'>cache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1822"><span class='Ref_to_Member'>collation</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2842"><span class='Ref_to_Parameter'>pathkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN849"><span class='Ref_to_Member'>pk_eclass</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN771"><span class='Ref_to_Member'>ec_collation</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN2844"><span class='Ref_To_Local'>cache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1823"><span class='Ref_to_Member'>strategy</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2842"><span class='Ref_to_Parameter'>pathkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN851"><span class='Ref_to_Member'>pk_strategy</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN2844"><span class='Ref_To_Local'>cache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1824"><span class='Ref_to_Member'>nulls_first</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2842"><span class='Ref_to_Parameter'>pathkey</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN852"><span class='Ref_to_Member'>pk_nulls_first</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN2844"><span class='Ref_To_Local'>cache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1826"><span class='Ref_to_Member'>leftstartsel</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2846"><span class='Ref_To_Local'>leftstartsel</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN2844"><span class='Ref_To_Local'>cache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1827"><span class='Ref_to_Member'>leftendsel</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2847"><span class='Ref_To_Local'>leftendsel</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN2844"><span class='Ref_To_Local'>cache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1828"><span class='Ref_to_Member'>rightstartsel</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2848"><span class='Ref_To_Local'>rightstartsel</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN2844"><span class='Ref_To_Local'>cache</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1829"><span class='Ref_to_Member'>rightendsel</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2849"><span class='Ref_To_Local'>rightendsel</span></a><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN2842"><span class='Ref_to_Parameter'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1798"><span class='Ref_to_Member'>scansel_cache</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN2842"><span class='Ref_to_Parameter'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1798"><span class='Ref_to_Member'>scansel_cache</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN2844"><span class='Ref_To_Local'>cache</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN2850"><span class='Ref_To_Local'>oldcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="costsize.c.html#LN2844"><span class='Ref_To_Local'>cache</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end cached_scansel &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * initial_cost_hashjoin 
 *    Preliminary estimate of the cost of a hashjoin path. 
 * 
 * This must quickly produce lower-bound estimates of the path's startup and 
 * total costs.  If we are unable to eliminate the proposed path from 
 * consideration using the lower bounds, final_cost_hashjoin will be called 
 * to obtain the final estimates. 
 * 
 * The exact division of labor between this function and final_cost_hashjoin 
 * is private to them, and represents a tradeoff between speed of the initial 
 * estimate and getting a tight lower bound.  We choose to not examine the 
 * join quals here (other than by counting the number of hash clauses), 
 * so we can't do much with CPU costs.  We do assume that 
 * ExecChooseHashTableSize is cheap enough to use here. 
 * 
 * 'workspace' is to be filled with startup_cost, total_cost, and perhaps 
 *      other data to be used by final_cost_hashjoin 
 * 'jointype' is the type of join to be performed 
 * 'hashclauses' is the list of joinclauses to be used as hash clauses 
 * 'outer_path' is the outer input to the join 
 * 'inner_path' is the inner input to the join 
 * 'extra' contains miscellaneous information about the join 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN2919"></a><span class='Declare_Function'>initial_cost_hashjoin</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN2199"><span class='Ref_to_Struct'>JoinCostWorkspace</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>workspace</span><span class='Delimiter'>, 
</span><a name="LN2920"></a>                      <a href="../../../include/nodes/nodes.h.html#LN671"><span class='Ref_to_Enum'>JoinType</span></a> <span class='Declare_Parameter'>jointype</span><span class='Delimiter'>, 
</span><a name="LN2921"></a>                      <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>hashclauses</span><span class='Delimiter'>, 
</span><a name="LN2922"></a>                      <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>outer_path</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>inner_path</span><span class='Delimiter'>, 
</span><a name="LN2923"></a>                      <a href="../../../include/nodes/relation.h.html#LN2177"><span class='Ref_to_Struct'>JoinPathExtraData</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>extra</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2925"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>startup_cost</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN2926"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>run_cost</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN2927"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>outer_path_rows</span> <span class='Operator'>= </span><a href="costsize.c.html#LN2922"><span class='Ref_to_Parameter'>outer_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span><a name="LN2928"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>inner_path_rows</span> <span class='Operator'>= </span><a href="costsize.c.html#LN2922"><span class='Ref_to_Parameter'>inner_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span><a name="LN2929"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>num_hashclauses</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN2921"><span class='Ref_to_Parameter'>hashclauses</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2930"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numbuckets</span><span class='Delimiter'>; 
</span><a name="LN2931"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numbatches</span><span class='Delimiter'>; 
</span><a name="LN2932"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>num_skew_mcvs</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* cost of source data */ 
</span>    <a href="costsize.c.html#LN2925"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN2922"><span class='Ref_to_Parameter'>outer_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN2926"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN2922"><span class='Ref_to_Parameter'>outer_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>- </span><a href="costsize.c.html#LN2922"><span class='Ref_to_Parameter'>outer_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN2925"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN2922"><span class='Ref_to_Parameter'>inner_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Cost of computing hash function: must do it once per input tuple. We 
     * charge one cpu_operator_cost for each column's hash function.  Also, 
     * tack on one cpu_tuple_cost per inner row, to model the costs of 
     * inserting the row into the hashtable. 
     * 
     * XXX when a hashclause is more complex than a single operator, we really 
     * should charge the extra eval costs of the left or right side, as 
     * appropriate, here.  This seems more work than it's worth at the moment. 
     */ 
</span>    <a href="costsize.c.html#LN2925"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><span class='Parentheses'>(</span><a href="costsize.c.html#LN107"><span class='Ref_to_Global_Var'>cpu_operator_cost</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN2929"><span class='Ref_To_Local'>num_hashclauses</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN105"><span class='Ref_to_Global_Var'>cpu_tuple_cost</span></a><span class='Parentheses'>) 
</span>        <span class='Operator'>* </span><a href="costsize.c.html#LN2928"><span class='Ref_To_Local'>inner_path_rows</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN2926"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN107"><span class='Ref_to_Global_Var'>cpu_operator_cost</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN2929"><span class='Ref_To_Local'>num_hashclauses</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN2927"><span class='Ref_To_Local'>outer_path_rows</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Get hash table size that executor would use for inner relation. 
     * 
     * XXX for the moment, always assume that skew optimization will be 
     * performed.  As long as SKEW_WORK_MEM_PERCENT is small, it's not worth 
     * trying to determine that for sure. 
     * 
     * XXX at some point it might be interesting to try to account for skew 
     * optimization in the cost estimate, but for now, we don't. 
     */ 
</span>    <a href="../../../include/executor/nodeHash.h.html#LN46"><span class='Ref_to_Proto'>ExecChooseHashTableSize</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN2928"><span class='Ref_To_Local'>inner_path_rows</span></a><span class='Delimiter'>, 
</span>                            <a href="costsize.c.html#LN2922"><span class='Ref_to_Parameter'>inner_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN953"><span class='Ref_to_Member'>pathtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN885"><span class='Ref_to_Member'>width</span></a><span class='Delimiter'>, 
</span>                            <span class='Boolean'>true</span><span class='Delimiter'>,</span>       <span class='Comment_Single_Line'>/* useskew */ 
</span>                            <span class='Operator'>&</span><a href="costsize.c.html#LN2930"><span class='Ref_To_Local'>numbuckets</span></a><span class='Delimiter'>, 
</span>                            <span class='Operator'>&</span><a href="costsize.c.html#LN2931"><span class='Ref_To_Local'>numbatches</span></a><span class='Delimiter'>, 
</span>                            <span class='Operator'>&</span><a href="costsize.c.html#LN2932"><span class='Ref_To_Local'>num_skew_mcvs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If inner relation is too big then we will need to "batch" the join, 
     * which implies writing and reading most of the tuples to disk an extra 
     * time.  Charge seq_page_cost per page, since the I/O should be nice and 
     * sequential.  Writing the inner rel counts as startup cost, all the rest 
     * as run cost. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN2931"><span class='Ref_To_Local'>numbatches</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2979"></a>        <span class='Keyword'>double</span>      <span class='Declare_Local'>outerpages</span> <span class='Operator'>= </span><a href="costsize.c.html#LN163"><span class='Ref_to_Proto'>page_size</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN2927"><span class='Ref_To_Local'>outer_path_rows</span></a><span class='Delimiter'>, 
</span>                                           <a href="costsize.c.html#LN2922"><span class='Ref_to_Parameter'>outer_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN953"><span class='Ref_to_Member'>pathtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN885"><span class='Ref_to_Member'>width</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2981"></a>        <span class='Keyword'>double</span>      <span class='Declare_Local'>innerpages</span> <span class='Operator'>= </span><a href="costsize.c.html#LN163"><span class='Ref_to_Proto'>page_size</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN2928"><span class='Ref_To_Local'>inner_path_rows</span></a><span class='Delimiter'>, 
</span>                                           <a href="costsize.c.html#LN2922"><span class='Ref_to_Parameter'>inner_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN953"><span class='Ref_to_Member'>pathtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN885"><span class='Ref_to_Member'>width</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="costsize.c.html#LN2925"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN103"><span class='Ref_to_Global_Var'>seq_page_cost</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN2981"><span class='Ref_To_Local'>innerpages</span></a><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN2926"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN103"><span class='Ref_to_Global_Var'>seq_page_cost</span></a> <span class='Operator'>* </span><span class='Parentheses'>(</span><a href="costsize.c.html#LN2981"><span class='Ref_To_Local'>innerpages</span></a> <span class='Operator'>+ </span><span class='Number'>2</span> <span class='Operator'>* </span><a href="costsize.c.html#LN2979"><span class='Ref_To_Local'>outerpages</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* CPU costs left for later */ 
</span> 
    <span class='Comment_Multi_Line'>/* Public result fields */ 
</span>    <a href="costsize.c.html#LN2919"><span class='Ref_to_Parameter'>workspace</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2202"><span class='Ref_to_Member'>startup_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2925"><span class='Ref_To_Local'>startup_cost</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN2919"><span class='Ref_to_Parameter'>workspace</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2203"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2925"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN2926"><span class='Ref_To_Local'>run_cost</span></a><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* Save private data for final_cost_hashjoin */ 
</span>    <a href="costsize.c.html#LN2919"><span class='Ref_to_Parameter'>workspace</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2206"><span class='Ref_to_Member'>run_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2926"><span class='Ref_To_Local'>run_cost</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN2919"><span class='Ref_to_Parameter'>workspace</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2219"><span class='Ref_to_Member'>numbuckets</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2930"><span class='Ref_To_Local'>numbuckets</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN2919"><span class='Ref_to_Parameter'>workspace</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2220"><span class='Ref_to_Member'>numbatches</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN2931"><span class='Ref_To_Local'>numbatches</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end initial_cost_hashjoin &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * final_cost_hashjoin 
 *    Final estimate of the cost and result size of a hashjoin path. 
 * 
 * Note: the numbatches estimate is also saved into 'path' for use later 
 * 
 * 'path' is already filled in except for the rows and cost fields and 
 *      num_batches 
 * 'workspace' is the result from initial_cost_hashjoin 
 * 'extra' contains miscellaneous information about the join 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN3011"></a><span class='Declare_Function'>final_cost_hashjoin</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1367"><span class='Ref_to_Struct'>HashPath</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Delimiter'>, 
</span><a name="LN3012"></a>                    <a href="../../../include/nodes/relation.h.html#LN2199"><span class='Ref_to_Struct'>JoinCostWorkspace</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>workspace</span><span class='Delimiter'>, 
</span><a name="LN3013"></a>                    <a href="../../../include/nodes/relation.h.html#LN2177"><span class='Ref_to_Struct'>JoinPathExtraData</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>extra</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3015"></a>    <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>outer_path</span> <span class='Operator'>= </span><a href="costsize.c.html#LN3011"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1369"><span class='Ref_to_Member'>jpath</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1295"><span class='Ref_to_Member'>outerjoinpath</span></a><span class='Delimiter'>; 
</span><a name="LN3016"></a>    <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>inner_path</span> <span class='Operator'>= </span><a href="costsize.c.html#LN3011"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1369"><span class='Ref_to_Member'>jpath</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1296"><span class='Ref_to_Member'>innerjoinpath</span></a><span class='Delimiter'>; 
</span><a name="LN3017"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>outer_path_rows</span> <span class='Operator'>= </span><a href="costsize.c.html#LN3015"><span class='Ref_To_Local'>outer_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span><a name="LN3018"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>inner_path_rows</span> <span class='Operator'>= </span><a href="costsize.c.html#LN3016"><span class='Ref_To_Local'>inner_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span><a name="LN3019"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>hashclauses</span> <span class='Operator'>= </span><a href="costsize.c.html#LN3011"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1370"><span class='Ref_to_Member'>path_hashclauses</span></a><span class='Delimiter'>; 
</span><a name="LN3020"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>startup_cost</span> <span class='Operator'>= </span><a href="costsize.c.html#LN3012"><span class='Ref_to_Parameter'>workspace</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2202"><span class='Ref_to_Member'>startup_cost</span></a><span class='Delimiter'>; 
</span><a name="LN3021"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>run_cost</span> <span class='Operator'>= </span><a href="costsize.c.html#LN3012"><span class='Ref_to_Parameter'>workspace</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2206"><span class='Ref_to_Member'>run_cost</span></a><span class='Delimiter'>; 
</span><a name="LN3022"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numbuckets</span> <span class='Operator'>= </span><a href="costsize.c.html#LN3012"><span class='Ref_to_Parameter'>workspace</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2219"><span class='Ref_to_Member'>numbuckets</span></a><span class='Delimiter'>; 
</span><a name="LN3023"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>numbatches</span> <span class='Operator'>= </span><a href="costsize.c.html#LN3012"><span class='Ref_to_Parameter'>workspace</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2220"><span class='Ref_to_Member'>numbatches</span></a><span class='Delimiter'>; 
</span><a name="LN3024"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>cpu_per_tuple</span><span class='Delimiter'>; 
</span><a name="LN3025"></a>    <a href="../../../include/nodes/relation.h.html#LN42"><span class='Ref_to_Struct'>QualCost</span></a>    <span class='Declare_Local'>hash_qual_cost</span><span class='Delimiter'>; 
</span><a name="LN3026"></a>    <a href="../../../include/nodes/relation.h.html#LN42"><span class='Ref_to_Struct'>QualCost</span></a>    <span class='Declare_Local'>qp_qual_cost</span><span class='Delimiter'>; 
</span><a name="LN3027"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>hashjointuples</span><span class='Delimiter'>; 
</span><a name="LN3028"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>virtualbuckets</span><span class='Delimiter'>; 
</span><a name="LN3029"></a>    <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Local'>innerbucketsize</span><span class='Delimiter'>; 
</span><a name="LN3030"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>hcl</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Mark the path with the correct row estimate */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN3011"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1369"><span class='Ref_to_Member'>jpath</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1288"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN955"><span class='Ref_to_Member'>param_info</span></a><span class='Parentheses'>) 
</span>        <a href="costsize.c.html#LN3011"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1369"><span class='Ref_to_Member'>jpath</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1288"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN3011"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1369"><span class='Ref_to_Member'>jpath</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1288"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN955"><span class='Ref_to_Member'>param_info</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN912"><span class='Ref_to_Member'>ppi_rows</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="costsize.c.html#LN3011"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1369"><span class='Ref_to_Member'>jpath</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1288"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN3011"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1369"><span class='Ref_to_Member'>jpath</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1288"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN952"><span class='Ref_to_Member'>parent</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* For partial paths, scale row estimate. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN3011"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1369"><span class='Ref_to_Member'>jpath</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1288"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN959"><span class='Ref_to_Member'>parallel_workers</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3041"></a>        <span class='Keyword'>double</span>      <span class='Declare_Local'>parallel_divisor</span> <span class='Operator'>= </span><a href="costsize.c.html#LN164"><span class='Ref_to_Proto'>get_parallel_divisor</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="costsize.c.html#LN3011"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1369"><span class='Ref_to_Member'>jpath</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1288"><span class='Ref_to_Member'>path</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="costsize.c.html#LN3011"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1369"><span class='Ref_to_Member'>jpath</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1288"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= 
</span>            <a href="../../../include/optimizer/cost.h.html#LN71"><span class='Ref_to_Proto'>clamp_row_est</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3011"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1369"><span class='Ref_to_Member'>jpath</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1288"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>/ </span><a href="costsize.c.html#LN3041"><span class='Ref_To_Local'>parallel_divisor</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We could include disable_cost in the preliminary estimate, but that 
     * would amount to optimizing for the case where the join method is 
     * disabled, which doesn't seem like the way to bet. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="costsize.c.html#LN127"><span class='Ref_to_Global_Var'>enable_hashjoin</span></a><span class='Parentheses'>) 
</span>        <a href="costsize.c.html#LN3020"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN113"><span class='Ref_to_Global_Var'>disable_cost</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* mark the path with estimated # of batches */ 
</span>    <a href="costsize.c.html#LN3011"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1371"><span class='Ref_to_Member'>num_batches</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN3023"><span class='Ref_To_Local'>numbatches</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* and compute the number of "virtual" buckets in the whole join */ 
</span>    <a href="costsize.c.html#LN3028"><span class='Ref_To_Local'>virtualbuckets</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN3022"><span class='Ref_To_Local'>numbuckets</span></a> <span class='Operator'>*</span><span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN3023"><span class='Ref_To_Local'>numbatches</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Determine bucketsize fraction for inner relation.  We use the smallest 
     * bucketsize estimated for any individual hashclause; this is undoubtedly 
     * conservative. 
     * 
     * BUT: if inner relation has been unique-ified, we can assume it's good 
     * for hashing.  This is important both because it's the right answer, and 
     * because we avoid contaminating the cache with a value that's wrong for 
     * non-unique-ified paths. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3016"><span class='Ref_To_Local'>inner_path</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1247"><span class='Ref_to_Struct'>UniquePath</span></a><span class='Parentheses'>))</span> 
        <a href="costsize.c.html#LN3029"><span class='Ref_To_Local'>innerbucketsize</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>/ </span><a href="costsize.c.html#LN3028"><span class='Ref_To_Local'>virtualbuckets</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="costsize.c.html#LN3029"><span class='Ref_To_Local'>innerbucketsize</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3030"><span class='Ref_To_Local'>hcl</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN3019"><span class='Ref_To_Local'>hashclauses</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN3078"></a>            <a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>restrictinfo</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN108"><span class='Ref_to_Macro'>lfirst_node</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN3030"><span class='Ref_To_Local'>hcl</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN3079"></a>            <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Local'>thisbucketsize</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * First we have to figure out which side of the hashjoin clause 
             * is the inner side. 
             * 
             * Since we tend to visit the same clauses over and over when 
             * planning a large query, we cache the bucketsize estimate in the 
             * RestrictInfo node to avoid repeated lookups of statistics. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3078"><span class='Ref_To_Local'>restrictinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1774"><span class='Ref_to_Member'>right_relids</span></a><span class='Delimiter'>, 
</span>                              <a href="costsize.c.html#LN3016"><span class='Ref_To_Local'>inner_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN952"><span class='Ref_to_Member'>parent</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* righthand side is inner */ 
</span>                <a href="costsize.c.html#LN3079"><span class='Ref_To_Local'>thisbucketsize</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN3078"><span class='Ref_To_Local'>restrictinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1808"><span class='Ref_to_Member'>right_bucketsize</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN3079"><span class='Ref_To_Local'>thisbucketsize</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* not cached yet */ 
</span>                    <a href="costsize.c.html#LN3079"><span class='Ref_To_Local'>thisbucketsize</span></a> <span class='Operator'>= 
</span>                        <a href="../../../include/utils/selfuncs.h.html#LN208"><span class='Ref_to_Proto'>estimate_hash_bucketsize</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3011"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                           <a href="../../../include/optimizer/clauses.h.html#LN33"><span class='Ref_to_Proto'>get_rightop</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3078"><span class='Ref_To_Local'>restrictinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1746"><span class='Ref_to_Member'>clause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                 <a href="costsize.c.html#LN3028"><span class='Ref_To_Local'>virtualbuckets</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="costsize.c.html#LN3078"><span class='Ref_To_Local'>restrictinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1808"><span class='Ref_to_Member'>right_bucketsize</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN3079"><span class='Ref_To_Local'>thisbucketsize</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3078"><span class='Ref_To_Local'>restrictinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1773"><span class='Ref_to_Member'>left_relids</span></a><span class='Delimiter'>, 
</span>                                     <a href="costsize.c.html#LN3016"><span class='Ref_To_Local'>inner_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN952"><span class='Ref_to_Member'>parent</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <span class='Comment_Multi_Line'>/* lefthand side is inner */ 
</span>                <a href="costsize.c.html#LN3079"><span class='Ref_To_Local'>thisbucketsize</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN3078"><span class='Ref_To_Local'>restrictinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1807"><span class='Ref_to_Member'>left_bucketsize</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN3079"><span class='Ref_To_Local'>thisbucketsize</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* not cached yet */ 
</span>                    <a href="costsize.c.html#LN3079"><span class='Ref_To_Local'>thisbucketsize</span></a> <span class='Operator'>= 
</span>                        <a href="../../../include/utils/selfuncs.h.html#LN208"><span class='Ref_to_Proto'>estimate_hash_bucketsize</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3011"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                            <a href="../../../include/optimizer/clauses.h.html#LN32"><span class='Ref_to_Proto'>get_leftop</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3078"><span class='Ref_To_Local'>restrictinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1746"><span class='Ref_to_Member'>clause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                                 <a href="costsize.c.html#LN3028"><span class='Ref_To_Local'>virtualbuckets</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="costsize.c.html#LN3078"><span class='Ref_To_Local'>restrictinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1807"><span class='Ref_to_Member'>left_bucketsize</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN3079"><span class='Ref_To_Local'>thisbucketsize</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN3029"><span class='Ref_To_Local'>innerbucketsize</span></a> <span class='Operator'>&GT; </span><a href="costsize.c.html#LN3079"><span class='Ref_To_Local'>thisbucketsize</span></a><span class='Parentheses'>) 
</span>                <a href="costsize.c.html#LN3029"><span class='Ref_To_Local'>innerbucketsize</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN3079"><span class='Ref_To_Local'>thisbucketsize</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Compute cost of the hashquals and qpquals (other restriction clauses) 
     * separately. 
     */ 
</span>    <a href="../../../include/optimizer/cost.h.html#LN157"><span class='Ref_to_Proto'>cost_qual_eval</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="costsize.c.html#LN3025"><span class='Ref_To_Local'>hash_qual_cost</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN3019"><span class='Ref_To_Local'>hashclauses</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN3011"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/optimizer/cost.h.html#LN157"><span class='Ref_to_Proto'>cost_qual_eval</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="costsize.c.html#LN3026"><span class='Ref_To_Local'>qp_qual_cost</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN3011"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1369"><span class='Ref_to_Member'>jpath</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1298"><span class='Ref_to_Member'>joinrestrictinfo</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN3011"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN3026"><span class='Ref_To_Local'>qp_qual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a> <span class='Operator'>-= </span><a href="costsize.c.html#LN3025"><span class='Ref_To_Local'>hash_qual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN3026"><span class='Ref_To_Local'>qp_qual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>-= </span><a href="costsize.c.html#LN3025"><span class='Ref_To_Local'>hash_qual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* CPU costs */ 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN3011"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1369"><span class='Ref_to_Member'>jpath</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1290"><span class='Ref_to_Member'>jointype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN691"><span class='Ref_to_EnumConst'>JOIN_SEMI</span></a> <span class='Operator'>|| 
</span>        <a href="costsize.c.html#LN3011"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1369"><span class='Ref_to_Member'>jpath</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1290"><span class='Ref_to_Member'>jointype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN692"><span class='Ref_to_EnumConst'>JOIN_ANTI</span></a> <span class='Operator'>|| 
</span>        <a href="costsize.c.html#LN3013"><span class='Ref_to_Parameter'>extra</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2181"><span class='Ref_to_Member'>inner_unique</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3141"></a>        <span class='Keyword'>double</span>      <span class='Declare_Local'>outer_matched_rows</span><span class='Delimiter'>; 
</span><a name="LN3142"></a>        <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Local'>inner_scan_frac</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * With a SEMI or ANTI join, or if the innerrel is known unique, the 
         * executor will stop after the first match. 
         * 
         * For an outer-rel row that has at least one match, we can expect the 
         * bucket scan to stop after a fraction 1/(match_count+1) of the 
         * bucket's rows, if the matches are evenly distributed.  Since they 
         * probably aren't quite evenly distributed, we apply a fuzz factor of 
         * 2.0 to that fraction.  (If we used a larger fuzz factor, we'd have 
         * to clamp inner_scan_frac to at most 1.0; but since match_count is 
         * at least 1, no such clamp is needed now.) 
         */ 
</span>        <a href="costsize.c.html#LN3141"><span class='Ref_To_Local'>outer_matched_rows</span></a> <span class='Operator'>= </span><a href="../../../port/rint.c.html#LN20"><span class='Ref_to_Func'>rint</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3017"><span class='Ref_To_Local'>outer_path_rows</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN3013"><span class='Ref_to_Parameter'>extra</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2183"><span class='Ref_to_Member'>semifactors</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN2160"><span class='Ref_to_Member'>outer_match_frac</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN3142"><span class='Ref_To_Local'>inner_scan_frac</span></a> <span class='Operator'>= </span><span class='Number'>2</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>/ </span><span class='Parentheses'>(</span><a href="costsize.c.html#LN3013"><span class='Ref_to_Parameter'>extra</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2183"><span class='Ref_to_Member'>semifactors</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN2161"><span class='Ref_to_Member'>match_count</span></a> <span class='Operator'>+ </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="costsize.c.html#LN3020"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN3025"><span class='Ref_To_Local'>hash_qual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN3021"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN3025"><span class='Ref_To_Local'>hash_qual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN3141"><span class='Ref_To_Local'>outer_matched_rows</span></a> <span class='Operator'>* 
</span>            <a href="../../../include/optimizer/cost.h.html#LN71"><span class='Ref_to_Proto'>clamp_row_est</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3018"><span class='Ref_To_Local'>inner_path_rows</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN3029"><span class='Ref_To_Local'>innerbucketsize</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN3142"><span class='Ref_To_Local'>inner_scan_frac</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>5</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * For unmatched outer-rel rows, the picture is quite a lot different. 
         * In the first place, there is no reason to assume that these rows 
         * preferentially hit heavily-populated buckets; instead assume they 
         * are uncorrelated with the inner distribution and so they see an 
         * average bucket size of inner_path_rows / virtualbuckets.  In the 
         * second place, it seems likely that they will have few if any exact 
         * hash-code matches and so very few of the tuples in the bucket will 
         * actually require eval of the hash quals.  We don't have any good 
         * way to estimate how many will, but for the moment assume that the 
         * effective cost per bucket entry is one-tenth what it is for 
         * matchable tuples. 
         */ 
</span>        <a href="costsize.c.html#LN3021"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN3025"><span class='Ref_To_Local'>hash_qual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>* 
</span>            <span class='Parentheses'>(</span><a href="costsize.c.html#LN3017"><span class='Ref_To_Local'>outer_path_rows</span></a> <span class='Operator'>- </span><a href="costsize.c.html#LN3141"><span class='Ref_To_Local'>outer_matched_rows</span></a><span class='Parentheses'>) </span><span class='Operator'>* 
</span>            <a href="../../../include/optimizer/cost.h.html#LN71"><span class='Ref_to_Proto'>clamp_row_est</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3018"><span class='Ref_To_Local'>inner_path_rows</span></a> <span class='Operator'>/ </span><a href="costsize.c.html#LN3028"><span class='Ref_To_Local'>virtualbuckets</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>05</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Get # of tuples that will pass the basic join */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN3011"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1369"><span class='Ref_to_Member'>jpath</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1290"><span class='Ref_to_Member'>jointype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN691"><span class='Ref_to_EnumConst'>JOIN_SEMI</span></a><span class='Parentheses'>) 
</span>            <a href="costsize.c.html#LN3027"><span class='Ref_To_Local'>hashjointuples</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN3141"><span class='Ref_To_Local'>outer_matched_rows</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="costsize.c.html#LN3027"><span class='Ref_To_Local'>hashjointuples</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN3017"><span class='Ref_To_Local'>outer_path_rows</span></a> <span class='Operator'>- </span><a href="costsize.c.html#LN3141"><span class='Ref_To_Local'>outer_matched_rows</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if path-&GT;jpath.jointype=... &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * The number of tuple comparisons needed is the number of outer 
         * tuples times the typical number of tuples in a hash bucket, which 
         * is the inner relation size times its bucketsize fraction.  At each 
         * one, we need to evaluate the hashjoin quals.  But actually, 
         * charging the full qual eval cost at each tuple is pessimistic, 
         * since we don't evaluate the quals unless the hash values match 
         * exactly.  For lack of a better idea, halve the cost estimate to 
         * allow for that. 
         */ 
</span>        <a href="costsize.c.html#LN3020"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN3025"><span class='Ref_To_Local'>hash_qual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN3021"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN3025"><span class='Ref_To_Local'>hash_qual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN3017"><span class='Ref_To_Local'>outer_path_rows</span></a> <span class='Operator'>* 
</span>            <a href="../../../include/optimizer/cost.h.html#LN71"><span class='Ref_to_Proto'>clamp_row_est</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3018"><span class='Ref_To_Local'>inner_path_rows</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN3029"><span class='Ref_To_Local'>innerbucketsize</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>5</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Get approx # tuples passing the hashquals.  We use 
         * approx_tuple_count here because we need an estimate done with 
         * JOIN_INNER semantics. 
         */ 
</span>        <a href="costsize.c.html#LN3027"><span class='Ref_To_Local'>hashjointuples</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN147"><span class='Ref_to_Proto'>approx_tuple_count</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3011"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="costsize.c.html#LN3011"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1369"><span class='Ref_to_Member'>jpath</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN3019"><span class='Ref_To_Local'>hashclauses</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * For each tuple that gets through the hashjoin proper, we charge 
     * cpu_tuple_cost plus the cost of evaluating additional restriction 
     * clauses that are to be applied at the join.  (This is pessimistic since 
     * not all of the quals may get evaluated at each tuple.) 
     */ 
</span>    <a href="costsize.c.html#LN3020"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN3026"><span class='Ref_To_Local'>qp_qual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN3024"><span class='Ref_To_Local'>cpu_per_tuple</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN105"><span class='Ref_to_Global_Var'>cpu_tuple_cost</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN3026"><span class='Ref_To_Local'>qp_qual_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN3021"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN3024"><span class='Ref_To_Local'>cpu_per_tuple</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN3027"><span class='Ref_To_Local'>hashjointuples</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* tlist eval costs are paid per output row, not per tuple scanned */ 
</span>    <a href="costsize.c.html#LN3020"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN3011"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1369"><span class='Ref_to_Member'>jpath</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1288"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN953"><span class='Ref_to_Member'>pathtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN884"><span class='Ref_to_Member'>cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN3021"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN3011"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1369"><span class='Ref_to_Member'>jpath</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1288"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN953"><span class='Ref_to_Member'>pathtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN884"><span class='Ref_to_Member'>cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN3011"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1369"><span class='Ref_to_Member'>jpath</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1288"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN3011"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1369"><span class='Ref_to_Member'>jpath</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1288"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN3020"><span class='Ref_To_Local'>startup_cost</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN3011"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1369"><span class='Ref_to_Member'>jpath</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1288"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN3020"><span class='Ref_To_Local'>startup_cost</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN3021"><span class='Ref_To_Local'>run_cost</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end final_cost_hashjoin &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * cost_subplan 
 *      Figure the costs for a SubPlan (or initplan). 
 * 
 * Note: we could dig the subplan's Plan out of the root list, but in practice 
 * all callers have it handy already, so we make them pass it. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN3237"></a><span class='Declare_Function'>cost_subplan</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN678"><span class='Ref_to_Struct'>SubPlan</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>subplan</span><span class='Delimiter'>, </span><a href="../../../include/nodes/plannodes.h.html#LN117"><span class='Ref_to_Struct'>Plan</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>plan</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3239"></a>    <a href="../../../include/nodes/relation.h.html#LN42"><span class='Ref_to_Struct'>QualCost</span></a>    <span class='Declare_Local'>sp_cost</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Figure any cost for evaluating the testexpr */ 
</span>    <a href="../../../include/optimizer/cost.h.html#LN157"><span class='Ref_to_Proto'>cost_qual_eval</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="costsize.c.html#LN3239"><span class='Ref_To_Local'>sp_cost</span></a><span class='Delimiter'>, 
</span>                   <a href="../../../include/optimizer/clauses.h.html#LN46"><span class='Ref_to_Proto'>make_ands_implicit</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN3237"><span class='Ref_to_Parameter'>subplan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN684"><span class='Ref_to_Member'>testexpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                   <a href="costsize.c.html#LN3237"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN3237"><span class='Ref_to_Parameter'>subplan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN696"><span class='Ref_to_Member'>useHashTable</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * If we are using a hash table for the subquery outputs, then the 
         * cost of evaluating the query is a one-time cost.  We charge one 
         * cpu_operator_cost per tuple for the work of loading the hashtable, 
         * too. 
         */ 
</span>        <a href="costsize.c.html#LN3239"><span class='Ref_To_Local'>sp_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN3237"><span class='Ref_to_Parameter'>plan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN125"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>+ 
</span>            <a href="costsize.c.html#LN107"><span class='Ref_to_Global_Var'>cpu_operator_cost</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN3237"><span class='Ref_to_Parameter'>plan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN130"><span class='Ref_to_Member'>plan_rows</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * The per-tuple costs include the cost of evaluating the lefthand 
         * expressions, plus the cost of probing the hashtable.  We already 
         * accounted for the lefthand expressions as part of the testexpr, and 
         * will also have counted one cpu_operator_cost for each comparison 
         * operator.  That is probably too low for the probing cost, but it's 
         * hard to make a better estimate, so live with it for now. 
         */ 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if subplan-&GT;useHashTable &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Otherwise we will be rescanning the subplan output on each 
         * evaluation.  We need to estimate how much of the output we will 
         * actually need to scan.  NOTE: this logic should agree with the 
         * tuple_fraction estimates used by make_subplan() in 
         * plan/subselect.c. 
         */ 
</span><a name="LN3275"></a>        <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>plan_run_cost</span> <span class='Operator'>= </span><a href="costsize.c.html#LN3237"><span class='Ref_to_Parameter'>plan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN125"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>- </span><a href="costsize.c.html#LN3237"><span class='Ref_to_Parameter'>plan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN124"><span class='Ref_to_Member'>startup_cost</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN3237"><span class='Ref_to_Parameter'>subplan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN682"><span class='Ref_to_Member'>subLinkType</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/primnodes.h.html#LN618"><span class='Ref_to_EnumConst'>EXISTS_SUBLINK</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* we only need to fetch 1 tuple; clamp to avoid zero divide */ 
</span>            <a href="costsize.c.html#LN3239"><span class='Ref_To_Local'>sp_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN3275"><span class='Ref_To_Local'>plan_run_cost</span></a> <span class='Operator'>/ </span><a href="../../../include/optimizer/cost.h.html#LN71"><span class='Ref_to_Proto'>clamp_row_est</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3237"><span class='Ref_to_Parameter'>plan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN130"><span class='Ref_to_Member'>plan_rows</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN3237"><span class='Ref_to_Parameter'>subplan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN682"><span class='Ref_to_Member'>subLinkType</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/primnodes.h.html#LN619"><span class='Ref_to_EnumConst'>ALL_SUBLINK</span></a> <span class='Operator'>|| 
</span>                 <a href="costsize.c.html#LN3237"><span class='Ref_to_Parameter'>subplan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN682"><span class='Ref_to_Member'>subLinkType</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/primnodes.h.html#LN620"><span class='Ref_to_EnumConst'>ANY_SUBLINK</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* assume we need 50% of the tuples */ 
</span>            <a href="costsize.c.html#LN3239"><span class='Ref_To_Local'>sp_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>+= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>50</span> <span class='Operator'>* </span><a href="costsize.c.html#LN3275"><span class='Ref_To_Local'>plan_run_cost</span></a><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* also charge a cpu_operator_cost per row examined */ 
</span>            <a href="costsize.c.html#LN3239"><span class='Ref_To_Local'>sp_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>+= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>50</span> <span class='Operator'>* </span><a href="costsize.c.html#LN3237"><span class='Ref_to_Parameter'>plan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN130"><span class='Ref_to_Member'>plan_rows</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN107"><span class='Ref_to_Global_Var'>cpu_operator_cost</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* assume we need all tuples */ 
</span>            <a href="costsize.c.html#LN3239"><span class='Ref_To_Local'>sp_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN3275"><span class='Ref_To_Local'>plan_run_cost</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Also account for subplan's startup cost. If the subplan is 
         * uncorrelated or undirect correlated, AND its topmost node is one 
         * that materializes its output, assume that we'll only need to pay 
         * its startup cost once; otherwise assume we pay the startup cost 
         * every time. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN3237"><span class='Ref_to_Parameter'>subplan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN707"><span class='Ref_to_Member'>parParam</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>&& 
</span>            <a href="../../../include/executor/executor.h.html#LN101"><span class='Ref_to_Proto'>ExecMaterializesOutput</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN513"><span class='Ref_to_Macro'>nodeTag</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3237"><span class='Ref_to_Parameter'>plan</span></a><span class='Parentheses'>)))</span> 
            <a href="costsize.c.html#LN3239"><span class='Ref_To_Local'>sp_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN3237"><span class='Ref_to_Parameter'>plan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN124"><span class='Ref_to_Member'>startup_cost</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <a href="costsize.c.html#LN3239"><span class='Ref_To_Local'>sp_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN3237"><span class='Ref_to_Parameter'>plan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/plannodes.h.html#LN124"><span class='Ref_to_Member'>startup_cost</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
    <a href="costsize.c.html#LN3237"><span class='Ref_to_Parameter'>subplan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN710"><span class='Ref_to_Member'>startup_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN3239"><span class='Ref_To_Local'>sp_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN3237"><span class='Ref_to_Parameter'>subplan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN711"><span class='Ref_to_Member'>per_call_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN3239"><span class='Ref_To_Local'>sp_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end cost_subplan &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * cost_rescan 
 *      Given a finished Path, estimate the costs of rescanning it after 
 *      having done so the first time.  For some Path types a rescan is 
 *      cheaper than an original scan (if no parameters change), and this 
 *      function embodies knowledge about that.  The default is to return 
 *      the same costs stored in the Path.  (Note that the cost estimates 
 *      actually stored in Paths are always for first scans.) 
 * 
 * This function is not currently intended to model effects such as rescans 
 * being cheaper due to disk block caching; what we are concerned with is 
 * plan types wherein the executor caches results explicitly, or doesn't 
 * redo startup calculations, etc. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN3330"></a><span class='Declare_Function'>cost_rescan</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Delimiter'>, 
</span><a name="LN3331"></a>            <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rescan_startup_cost</span><span class='Delimiter'>,</span>  <span class='Comment_Single_Line'>/* output parameters */ 
</span><a name="LN3332"></a>            <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rescan_total_cost</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN3330"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN950"><span class='Ref_to_Member'>pathtype</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN61"><span class='Ref_to_EnumConst'>T_FunctionScan</span></a><span class='Operator'>: 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Currently, nodeFunctionscan.c always executes the function to 
             * completion before returning any rows, and caches the results in 
             * a tuplestore.  So the function eval cost is all startup cost 
             * and isn't paid over again on rescans. However, all run costs 
             * will be paid over again. 
             */ 
</span>            <span class='Operator'>*</span><a href="costsize.c.html#LN3331"><span class='Ref_to_Parameter'>rescan_startup_cost</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <span class='Operator'>*</span><a href="costsize.c.html#LN3332"><span class='Ref_to_Parameter'>rescan_total_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN3330"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>- </span><a href="costsize.c.html#LN3330"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN72"><span class='Ref_to_EnumConst'>T_HashJoin</span></a><span class='Operator'>: 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * If it's a single-batch join, we don't need to rebuild the hash 
             * table during a rescan. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(((</span><a href="../../../include/nodes/relation.h.html#LN1367"><span class='Ref_to_Struct'>HashPath</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN3330"><span class='Ref_to_Parameter'>path</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>num_batches <span class='Operator'>== </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* Startup cost is exactly the cost of hash table building */ 
</span>                <span class='Operator'>*</span><a href="costsize.c.html#LN3331"><span class='Ref_to_Parameter'>rescan_startup_cost</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>                <span class='Operator'>*</span><a href="costsize.c.html#LN3332"><span class='Ref_to_Parameter'>rescan_total_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN3330"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>- </span><a href="costsize.c.html#LN3330"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* Otherwise, no special treatment */ 
</span>                <span class='Operator'>*</span><a href="costsize.c.html#LN3331"><span class='Ref_to_Parameter'>rescan_startup_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN3330"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a><span class='Delimiter'>; 
</span>                <span class='Operator'>*</span><a href="costsize.c.html#LN3332"><span class='Ref_to_Parameter'>rescan_total_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN3330"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN64"><span class='Ref_to_EnumConst'>T_CteScan</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN66"><span class='Ref_to_EnumConst'>T_WorkTableScan</span></a><span class='Operator'>: 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * These plan types materialize their final result in a 
                 * tuplestore or tuplesort object.  So the rescan cost is only 
                 * cpu_tuple_cost per tuple, unless the result is large enough 
                 * to spill to disk. 
                 */ 
</span><a name="LN3376"></a>                <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>run_cost</span> <span class='Operator'>= </span><a href="costsize.c.html#LN105"><span class='Ref_to_Global_Var'>cpu_tuple_cost</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN3330"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span><a name="LN3377"></a>                <span class='Keyword'>double</span>      <span class='Declare_Local'>nbytes</span> <span class='Operator'>= </span><a href="costsize.c.html#LN162"><span class='Ref_to_Proto'>relation_byte_size</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3330"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>, 
</span>                                                    <a href="costsize.c.html#LN3330"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN953"><span class='Ref_to_Member'>pathtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN885"><span class='Ref_to_Member'>width</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN3379"></a>                <span class='Keyword'>long</span>        <span class='Declare_Local'>work_mem_bytes</span> <span class='Operator'>= </span><a href="../../utils/init/globals.c.html#LN112"><span class='Ref_to_Global_Var'>work_mem</span></a> <span class='Operator'>* </span><span class='Number'>1024L</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN3377"><span class='Ref_To_Local'>nbytes</span></a> <span class='Operator'>&GT; </span><a href="costsize.c.html#LN3379"><span class='Ref_To_Local'>work_mem_bytes</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* It will spill, so account for re-read cost */ 
</span><a name="LN3384"></a>                    <span class='Keyword'>double</span>      <span class='Declare_Local'>npages</span> <span class='Operator'>= </span>ceil<span class='Parentheses'>(</span><a href="costsize.c.html#LN3377"><span class='Ref_To_Local'>nbytes</span></a> <span class='Operator'>/ </span>BLCKSZ<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                    <a href="costsize.c.html#LN3376"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN103"><span class='Ref_to_Global_Var'>seq_page_cost</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN3384"><span class='Ref_To_Local'>npages</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Operator'>*</span><a href="costsize.c.html#LN3331"><span class='Ref_to_Parameter'>rescan_startup_cost</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>                <span class='Operator'>*</span><a href="costsize.c.html#LN3332"><span class='Ref_to_Parameter'>rescan_total_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN3376"><span class='Ref_To_Local'>run_cost</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN73"><span class='Ref_to_EnumConst'>T_Material</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN74"><span class='Ref_to_EnumConst'>T_Sort</span></a><span class='Operator'>: 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * These plan types not only materialize their results, but do 
                 * not implement qual filtering or projection.  So they are 
                 * even cheaper to rescan than the ones above.  We charge only 
                 * cpu_operator_cost per tuple.  (Note: keep that in sync with 
                 * the run_cost charge in cost_sort, and also see comments in 
                 * cost_material before you change it.) 
                 */ 
</span><a name="LN3403"></a>                <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>run_cost</span> <span class='Operator'>= </span><a href="costsize.c.html#LN107"><span class='Ref_to_Global_Var'>cpu_operator_cost</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN3330"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span><a name="LN3404"></a>                <span class='Keyword'>double</span>      <span class='Declare_Local'>nbytes</span> <span class='Operator'>= </span><a href="costsize.c.html#LN162"><span class='Ref_to_Proto'>relation_byte_size</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3330"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>, 
</span>                                                    <a href="costsize.c.html#LN3330"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN953"><span class='Ref_to_Member'>pathtarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN885"><span class='Ref_to_Member'>width</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN3406"></a>                <span class='Keyword'>long</span>        <span class='Declare_Local'>work_mem_bytes</span> <span class='Operator'>= </span><a href="../../utils/init/globals.c.html#LN112"><span class='Ref_to_Global_Var'>work_mem</span></a> <span class='Operator'>* </span><span class='Number'>1024L</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN3404"><span class='Ref_To_Local'>nbytes</span></a> <span class='Operator'>&GT; </span><a href="costsize.c.html#LN3406"><span class='Ref_To_Local'>work_mem_bytes</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* It will spill, so account for re-read cost */ 
</span><a name="LN3411"></a>                    <span class='Keyword'>double</span>      <span class='Declare_Local'>npages</span> <span class='Operator'>= </span>ceil<span class='Parentheses'>(</span><a href="costsize.c.html#LN3404"><span class='Ref_To_Local'>nbytes</span></a> <span class='Operator'>/ </span>BLCKSZ<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                    <a href="costsize.c.html#LN3403"><span class='Ref_To_Local'>run_cost</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN103"><span class='Ref_to_Global_Var'>seq_page_cost</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN3411"><span class='Ref_To_Local'>npages</span></a><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Operator'>*</span><a href="costsize.c.html#LN3331"><span class='Ref_to_Parameter'>rescan_startup_cost</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>                <span class='Operator'>*</span><a href="costsize.c.html#LN3332"><span class='Ref_to_Parameter'>rescan_total_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN3403"><span class='Ref_To_Local'>run_cost</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>default</span><span class='Operator'>: 
</span>            <span class='Operator'>*</span><a href="costsize.c.html#LN3331"><span class='Ref_to_Parameter'>rescan_startup_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN3330"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a><span class='Delimiter'>; 
</span>            <span class='Operator'>*</span><a href="costsize.c.html#LN3332"><span class='Ref_to_Parameter'>rescan_total_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN3330"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch path-&GT;pathtype &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end cost_rescan &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * cost_qual_eval 
 *      Estimate the CPU costs of evaluating a WHERE clause. 
 *      The input can be either an implicitly-ANDed list of boolean 
 *      expressions, or a list of RestrictInfo nodes.  (The latter is 
 *      preferred since it allows caching of the results.) 
 *      The result includes both a one-time (startup) component, 
 *      and a per-evaluation component. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN3437"></a><span class='Declare_Function'>cost_qual_eval</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN42"><span class='Ref_to_Struct'>QualCost</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>cost</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>quals</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3439"></a>    <a href="costsize.c.html#LN130"><span class='Ref_to_Typedef'>cost_qual_eval_context</span></a> <span class='Declare_Local'>context</span><span class='Delimiter'>; 
</span><a name="LN3440"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN3439"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="costsize.c.html#LN132"><span class='Ref_to_Member'>root</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN3437"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN3439"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="costsize.c.html#LN133"><span class='Ref_to_Member'>total</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN3439"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="costsize.c.html#LN133"><span class='Ref_to_Member'>total</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* We don't charge any cost for the implicit ANDing at top level ... */ 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3440"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN3437"><span class='Ref_to_Parameter'>quals</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3450"></a>        <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>qual</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3440"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="costsize.c.html#LN142"><span class='Ref_to_Proto'>cost_qual_eval_walker</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3450"><span class='Ref_To_Local'>qual</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="costsize.c.html#LN3439"><span class='Ref_To_Local'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Operator'>*</span><a href="costsize.c.html#LN3437"><span class='Ref_to_Parameter'>cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN3439"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="costsize.c.html#LN133"><span class='Ref_to_Member'>total</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end cost_qual_eval &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * cost_qual_eval_node 
 *      As above, for a single RestrictInfo or expression. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN3463"></a><span class='Declare_Function'>cost_qual_eval_node</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN42"><span class='Ref_to_Struct'>QualCost</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>cost</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>qual</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3465"></a>    <a href="costsize.c.html#LN130"><span class='Ref_to_Typedef'>cost_qual_eval_context</span></a> <span class='Declare_Local'>context</span><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN3465"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="costsize.c.html#LN132"><span class='Ref_to_Member'>root</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN3463"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN3465"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="costsize.c.html#LN133"><span class='Ref_to_Member'>total</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN3465"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="costsize.c.html#LN133"><span class='Ref_to_Member'>total</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN142"><span class='Ref_to_Proto'>cost_qual_eval_walker</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3463"><span class='Ref_to_Parameter'>qual</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="costsize.c.html#LN3465"><span class='Ref_To_Local'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Operator'>*</span><a href="costsize.c.html#LN3463"><span class='Ref_to_Parameter'>cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN3465"><span class='Ref_To_Local'>context</span></a><span class='Operator'>.</span><a href="costsize.c.html#LN133"><span class='Ref_to_Member'>total</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Keyword'>static bool 
</span><a name="LN3477"></a><span class='Declare_Function'>cost_qual_eval_walker</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><a href="costsize.c.html#LN130"><span class='Ref_to_Typedef'>cost_qual_eval_context</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN3477"><span class='Ref_to_Parameter'>node</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * RestrictInfo nodes contain an eval_cost field reserved for this 
     * routine's use, so that it's not necessary to evaluate the qual clause's 
     * cost more than once.  If the clause's cost hasn't been computed yet, 
     * the field's startup value will contain -1. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3477"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN3490"></a>        <a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN3477"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN3490"><span class='Ref_To_Local'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1783"><span class='Ref_to_Member'>eval_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN3494"></a>            <a href="costsize.c.html#LN130"><span class='Ref_to_Typedef'>cost_qual_eval_context</span></a> <span class='Declare_Local'>locContext</span><span class='Delimiter'>; 
</span> 
            <a href="costsize.c.html#LN3494"><span class='Ref_To_Local'>locContext</span></a><span class='Operator'>.</span><a href="costsize.c.html#LN132"><span class='Ref_to_Member'>root</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN3477"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="costsize.c.html#LN132"><span class='Ref_to_Member'>root</span></a><span class='Delimiter'>; 
</span>            <a href="costsize.c.html#LN3494"><span class='Ref_To_Local'>locContext</span></a><span class='Operator'>.</span><a href="costsize.c.html#LN133"><span class='Ref_to_Member'>total</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <a href="costsize.c.html#LN3494"><span class='Ref_To_Local'>locContext</span></a><span class='Operator'>.</span><a href="costsize.c.html#LN133"><span class='Ref_to_Member'>total</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * For an OR clause, recurse into the marked-up tree so that we 
             * set the eval_cost for contained RestrictInfos too. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN3490"><span class='Ref_To_Local'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1777"><span class='Ref_to_Member'>orclause</span></a><span class='Parentheses'>) 
</span>                <a href="costsize.c.html#LN142"><span class='Ref_to_Proto'>cost_qual_eval_walker</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN3490"><span class='Ref_To_Local'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1777"><span class='Ref_to_Member'>orclause</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="costsize.c.html#LN3494"><span class='Ref_To_Local'>locContext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="costsize.c.html#LN142"><span class='Ref_to_Proto'>cost_qual_eval_walker</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN3490"><span class='Ref_To_Local'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1746"><span class='Ref_to_Member'>clause</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="costsize.c.html#LN3494"><span class='Ref_To_Local'>locContext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * If the RestrictInfo is marked pseudoconstant, it will be tested 
             * only once, so treat its cost as all startup cost. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN3490"><span class='Ref_To_Local'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1754"><span class='Ref_to_Member'>pseudoconstant</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* count one execution during startup */ 
</span>                <a href="costsize.c.html#LN3494"><span class='Ref_To_Local'>locContext</span></a><span class='Operator'>.</span><a href="costsize.c.html#LN133"><span class='Ref_to_Member'>total</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN3494"><span class='Ref_To_Local'>locContext</span></a><span class='Operator'>.</span><a href="costsize.c.html#LN133"><span class='Ref_to_Member'>total</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a><span class='Delimiter'>; 
</span>                <a href="costsize.c.html#LN3494"><span class='Ref_To_Local'>locContext</span></a><span class='Operator'>.</span><a href="costsize.c.html#LN133"><span class='Ref_to_Member'>total</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <a href="costsize.c.html#LN3490"><span class='Ref_To_Local'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1783"><span class='Ref_to_Member'>eval_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN3494"><span class='Ref_To_Local'>locContext</span></a><span class='Operator'>.</span><a href="costsize.c.html#LN133"><span class='Ref_to_Member'>total</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if rinfo-&GT;eval_cost.star... &raquo; </span> 
        <a href="costsize.c.html#LN3477"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="costsize.c.html#LN133"><span class='Ref_to_Member'>total</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN3490"><span class='Ref_To_Local'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1783"><span class='Ref_to_Member'>eval_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN3477"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="costsize.c.html#LN133"><span class='Ref_to_Member'>total</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN3490"><span class='Ref_To_Local'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1783"><span class='Ref_to_Member'>eval_cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* do NOT recurse into children */ 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if IsA(node,RestrictInfo... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * For each operator or function node in the given tree, we charge the 
     * estimated execution cost given by pg_proc.procost (remember to multiply 
     * this by cpu_operator_cost). 
     * 
     * Vars and Consts are charged zero, and so are boolean operators (AND, 
     * OR, NOT). Simplistic, but a lot better than no model at all. 
     * 
     * Should we try to account for the possibility of short-circuit 
     * evaluation of AND/OR?  Probably *not*, because that would make the 
     * results depend on the clause ordering, and we are not in any position 
     * to expect that the current ordering of the clauses is the one that's 
     * going to end up being used.  The above per-RestrictInfo caching would 
     * not mix well with trying to re-order clauses anyway. 
     * 
     * Another issue that is entirely ignored here is that if a set-returning 
     * function is below top level in the tree, the functions/operators above 
     * it will need to be evaluated multiple times.  In practical use, such 
     * cases arise so seldom as to not be worth the added complexity needed; 
     * moreover, since our rowcount estimates for functions tend to be pretty 
     * phony, the results would also be pretty phony. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3477"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="costsize.c.html#LN3477"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="costsize.c.html#LN133"><span class='Ref_to_Member'>total</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>+= 
</span>            <a href="../../../include/utils/lsyscache.h.html#LN121"><span class='Ref_to_Proto'>get_func_cost</span></a><span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN444"><span class='Ref_to_Struct'>FuncExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN3477"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>funcid<span class='Parentheses'>)</span> <span class='Operator'>* </span><a href="costsize.c.html#LN107"><span class='Ref_to_Global_Var'>cpu_operator_cost</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3477"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>             <a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3477"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN514"><span class='Ref_to_Typedef'>DistinctExpr</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>             <a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3477"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN522"><span class='Ref_to_Typedef'>NullIfExpr</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* rely on struct equivalence to treat these all alike */ 
</span>        <a href="../../../include/nodes/nodeFuncs.h.html#LN46"><span class='Ref_to_Proto'>set_opfuncid</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN3477"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN3477"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="costsize.c.html#LN133"><span class='Ref_to_Member'>total</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>+= 
</span>            <a href="../../../include/utils/lsyscache.h.html#LN121"><span class='Ref_to_Proto'>get_func_cost</span></a><span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN3477"><span class='Ref_to_Parameter'>node</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>opfuncid<span class='Parentheses'>)</span> <span class='Operator'>* </span><a href="costsize.c.html#LN107"><span class='Ref_to_Global_Var'>cpu_operator_cost</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3477"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN534"><span class='Ref_to_Struct'>ScalarArrayOpExpr</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Estimate that the operator will be applied to about half of the 
         * array elements before the answer is determined. 
         */ 
</span><a name="LN3569"></a>        <a href="../../../include/nodes/primnodes.h.html#LN534"><span class='Ref_to_Struct'>ScalarArrayOpExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>saop</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN534"><span class='Ref_to_Struct'>ScalarArrayOpExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN3477"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span><a name="LN3570"></a>        <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>arraynode</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN115"><span class='Ref_to_Macro'>lsecond</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3569"><span class='Ref_To_Local'>saop</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN541"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/nodes/nodeFuncs.h.html#LN47"><span class='Ref_to_Proto'>set_sa_opfuncid</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3569"><span class='Ref_To_Local'>saop</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN3477"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="costsize.c.html#LN133"><span class='Ref_to_Member'>total</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>+= </span><a href="../../../include/utils/lsyscache.h.html#LN121"><span class='Ref_to_Proto'>get_func_cost</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3569"><span class='Ref_To_Local'>saop</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN538"><span class='Ref_to_Member'>opfuncid</span></a><span class='Parentheses'>) </span><span class='Operator'>* 
</span>            <a href="costsize.c.html#LN107"><span class='Ref_to_Global_Var'>cpu_operator_cost</span></a> <span class='Operator'>* </span><a href="../../../include/utils/selfuncs.h.html#LN195"><span class='Ref_to_Proto'>estimate_array_length</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3570"><span class='Ref_To_Local'>arraynode</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>5</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3477"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>             <a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3477"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN351"><span class='Ref_to_Struct'>WindowFunc</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Aggref and WindowFunc nodes are (and should be) treated like Vars, 
         * ie, zero execution cost in the current model, because they behave 
         * essentially like Vars at execution.  We disregard the costs of 
         * their input expressions for the same reason.  The actual execution 
         * costs of the aggregate/window functions and their arguments have to 
         * be factored into plan-node-specific costing of the Agg or WindowAgg 
         * plan node. 
         */ 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* don't recurse into children */ 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3477"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN806"><span class='Ref_to_Struct'>CoerceViaIO</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN3592"></a>        <a href="../../../include/nodes/primnodes.h.html#LN806"><span class='Ref_to_Struct'>CoerceViaIO</span></a> <span class='Operator'>*</span><span class='Declare_Local'>iocoerce</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN806"><span class='Ref_to_Struct'>CoerceViaIO</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN3477"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span><a name="LN3593"></a>        <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>iofunc</span><span class='Delimiter'>; 
</span><a name="LN3594"></a>        <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>typioparam</span><span class='Delimiter'>; 
</span><a name="LN3595"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>typisvarlena</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* check the result type's input function */ 
</span>        <a href="../../../include/utils/lsyscache.h.html#LN161"><span class='Ref_to_Proto'>getTypeInputInfo</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3592"><span class='Ref_To_Local'>iocoerce</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN810"><span class='Ref_to_Member'>resulttype</span></a><span class='Delimiter'>, 
</span>                         <span class='Operator'>&</span><a href="costsize.c.html#LN3593"><span class='Ref_To_Local'>iofunc</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="costsize.c.html#LN3594"><span class='Ref_To_Local'>typioparam</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN3477"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="costsize.c.html#LN133"><span class='Ref_to_Member'>total</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>+= </span><a href="../../../include/utils/lsyscache.h.html#LN121"><span class='Ref_to_Proto'>get_func_cost</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3593"><span class='Ref_To_Local'>iofunc</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="costsize.c.html#LN107"><span class='Ref_to_Global_Var'>cpu_operator_cost</span></a><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* check the input type's output function */ 
</span>        <a href="../../../include/utils/lsyscache.h.html#LN162"><span class='Ref_to_Proto'>getTypeOutputInfo</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN3592"><span class='Ref_To_Local'>iocoerce</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN809"><span class='Ref_to_Member'>arg</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                          <span class='Operator'>&</span><a href="costsize.c.html#LN3593"><span class='Ref_To_Local'>iofunc</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="costsize.c.html#LN3595"><span class='Ref_To_Local'>typisvarlena</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN3477"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="costsize.c.html#LN133"><span class='Ref_to_Member'>total</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>+= </span><a href="../../../include/utils/lsyscache.h.html#LN121"><span class='Ref_to_Proto'>get_func_cost</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3593"><span class='Ref_To_Local'>iofunc</span></a><span class='Parentheses'>) </span><span class='Operator'>* </span><a href="costsize.c.html#LN107"><span class='Ref_to_Global_Var'>cpu_operator_cost</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3477"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN829"><span class='Ref_to_Struct'>ArrayCoerceExpr</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN3608"></a>        <a href="../../../include/nodes/primnodes.h.html#LN829"><span class='Ref_to_Struct'>ArrayCoerceExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>acoerce</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN829"><span class='Ref_to_Struct'>ArrayCoerceExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN3477"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span><a name="LN3609"></a>        <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>arraynode</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN3608"><span class='Ref_To_Local'>acoerce</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN832"><span class='Ref_to_Member'>arg</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3608"><span class='Ref_To_Local'>acoerce</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN833"><span class='Ref_to_Member'>elemfuncid</span></a><span class='Parentheses'>))</span> 
            <a href="costsize.c.html#LN3477"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="costsize.c.html#LN133"><span class='Ref_to_Member'>total</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>+= </span><a href="../../../include/utils/lsyscache.h.html#LN121"><span class='Ref_to_Proto'>get_func_cost</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3608"><span class='Ref_To_Local'>acoerce</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN833"><span class='Ref_to_Member'>elemfuncid</span></a><span class='Parentheses'>) </span><span class='Operator'>* 
</span>                <a href="costsize.c.html#LN107"><span class='Ref_to_Global_Var'>cpu_operator_cost</span></a> <span class='Operator'>* </span><a href="../../../include/utils/selfuncs.h.html#LN195"><span class='Ref_to_Proto'>estimate_array_length</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3609"><span class='Ref_To_Local'>arraynode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3477"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN1026"><span class='Ref_to_Struct'>RowCompareExpr</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Conservatively assume we will check all the columns */ 
</span><a name="LN3618"></a>        <a href="../../../include/nodes/primnodes.h.html#LN1026"><span class='Ref_to_Struct'>RowCompareExpr</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rcexpr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1026"><span class='Ref_to_Struct'>RowCompareExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN3477"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span><a name="LN3619"></a>        <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3619"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN3618"><span class='Ref_To_Local'>rcexpr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1030"><span class='Ref_to_Member'>opnos</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN3623"></a>            <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>opid</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN107"><span class='Ref_to_Macro'>lfirst_oid</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3619"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="costsize.c.html#LN3477"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="costsize.c.html#LN133"><span class='Ref_to_Member'>total</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>+= </span><a href="../../../include/utils/lsyscache.h.html#LN121"><span class='Ref_to_Proto'>get_func_cost</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/lsyscache.h.html#LN98"><span class='Ref_to_Proto'>get_opcode</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3623"><span class='Ref_To_Local'>opid</span></a><span class='Parentheses'>))</span> <span class='Operator'>* 
</span>                <a href="costsize.c.html#LN107"><span class='Ref_to_Global_Var'>cpu_operator_cost</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3477"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN1272"><span class='Ref_to_Struct'>CurrentOfExpr</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Report high cost to prevent selection of anything but TID scan */ 
</span>        <a href="costsize.c.html#LN3477"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="costsize.c.html#LN133"><span class='Ref_to_Member'>total</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN113"><span class='Ref_to_Global_Var'>disable_cost</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3477"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN629"><span class='Ref_to_Struct'>SubLink</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* This routine should not be applied to un-planned expressions */ 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cannot handle unplanned sub-select"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3477"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN678"><span class='Ref_to_Struct'>SubPlan</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * A subplan node in an expression typically indicates that the 
         * subplan will be executed on each evaluation, so charge accordingly. 
         * (Sub-selects that can be executed as InitPlans have already been 
         * removed from the expression.) 
         */ 
</span><a name="LN3647"></a>        <a href="../../../include/nodes/primnodes.h.html#LN678"><span class='Ref_to_Struct'>SubPlan</span></a>    <span class='Operator'>*</span><span class='Declare_Local'>subplan</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN678"><span class='Ref_to_Struct'>SubPlan</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN3477"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
        <a href="costsize.c.html#LN3477"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="costsize.c.html#LN133"><span class='Ref_to_Member'>total</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN3647"><span class='Ref_To_Local'>subplan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN710"><span class='Ref_to_Member'>startup_cost</span></a><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN3477"><span class='Ref_to_Parameter'>context</span></a><span class='Operator'>-&GT;</span><a href="costsize.c.html#LN133"><span class='Ref_to_Member'>total</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN3647"><span class='Ref_To_Local'>subplan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN711"><span class='Ref_to_Member'>per_call_cost</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We don't want to recurse into the testexpr, because it was already 
         * counted in the SubPlan node's costs.  So we're done. 
         */ 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3477"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN722"><span class='Ref_to_Struct'>AlternativeSubPlan</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Arbitrarily use the first alternative plan for costing.  (We should 
         * certainly only include one alternative, and we don't yet have 
         * enough information to know which one the executor is most likely to 
         * use.) 
         */ 
</span><a name="LN3666"></a>        <a href="../../../include/nodes/primnodes.h.html#LN722"><span class='Ref_to_Struct'>AlternativeSubPlan</span></a> <span class='Operator'>*</span><span class='Declare_Local'>asplan</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN722"><span class='Ref_to_Struct'>AlternativeSubPlan</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN3477"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span> 
        <span class='Control'>return</span> <a href="costsize.c.html#LN142"><span class='Ref_to_Proto'>cost_qual_eval_walker</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3666"><span class='Ref_To_Local'>asplan</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN725"><span class='Ref_to_Member'>subplans</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                     <a href="costsize.c.html#LN3477"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3477"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1846"><span class='Ref_to_Struct'>PlaceHolderVar</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * A PlaceHolderVar should be given cost zero when considering general 
         * expression evaluation costs.  The expense of doing the contained 
         * expression is charged as part of the tlist eval costs of the scan 
         * or join where the PHV is first computed (see set_rel_width and 
         * add_placeholders_to_joinrel).  If we charged it again here, we'd be 
         * double-counting the cost for each level of plan that the PHV 
         * bubbles up through.  Hence, return without recursing into the 
         * phexpr. 
         */ 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* recurse into children */ 
</span>    <span class='Control'>return</span> <a href="../../../include/nodes/nodeFuncs.h.html#LN52"><span class='Ref_to_Proto'>expression_tree_walker</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3477"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN142"><span class='Ref_to_Proto'>cost_qual_eval_walker</span></a><span class='Delimiter'>, 
</span>                                  <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN3477"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end cost_qual_eval_walker &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * get_restriction_qual_cost 
 *    Compute evaluation costs of a baserel's restriction quals, plus any 
 *    movable join quals that have been pushed down to the scan. 
 *    Results are returned into *qpqual_cost. 
 * 
 * This is a convenience subroutine that works for seqscans and other cases 
 * where all the given quals will be evaluated the hard way.  It's not useful 
 * for cost_index(), for example, where the index machinery takes care of 
 * some of the quals.  We assume baserestrictcost was previously set by 
 * set_baserel_size_estimates(). 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN3704"></a><span class='Declare_Function'>get_restriction_qual_cost</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>baserel</span><span class='Delimiter'>, 
</span><a name="LN3705"></a>                          <a href="../../../include/nodes/relation.h.html#LN907"><span class='Ref_to_Struct'>ParamPathInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>param_info</span><span class='Delimiter'>, 
</span><a name="LN3706"></a>                          <a href="../../../include/nodes/relation.h.html#LN42"><span class='Ref_to_Struct'>QualCost</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>qpqual_cost</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN3705"><span class='Ref_to_Parameter'>param_info</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Include costs of pushed-down clauses */ 
</span>        <a href="../../../include/optimizer/cost.h.html#LN157"><span class='Ref_to_Proto'>cost_qual_eval</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3706"><span class='Ref_to_Parameter'>qpqual_cost</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN3705"><span class='Ref_to_Parameter'>param_info</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN913"><span class='Ref_to_Member'>ppi_clauses</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN3704"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="costsize.c.html#LN3706"><span class='Ref_to_Parameter'>qpqual_cost</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN3704"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN585"><span class='Ref_to_Member'>baserestrictcost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN3706"><span class='Ref_to_Parameter'>qpqual_cost</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN3704"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN585"><span class='Ref_to_Member'>baserestrictcost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
        <span class='Operator'>*</span><a href="costsize.c.html#LN3706"><span class='Ref_to_Parameter'>qpqual_cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN3704"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN585"><span class='Ref_to_Member'>baserestrictcost</span></a><span class='Delimiter'>; 
} 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * compute_semi_anti_join_factors 
 *    Estimate how much of the inner input a SEMI, ANTI, or inner_unique join 
 *    can be expected to scan. 
 * 
 * In a hash or nestloop SEMI/ANTI join, the executor will stop scanning 
 * inner rows as soon as it finds a match to the current outer row. 
 * The same happens if we have detected the inner rel is unique. 
 * We should therefore adjust some of the cost components for this effect. 
 * This function computes some estimates needed for these adjustments. 
 * These estimates will be the same regardless of the particular paths used 
 * for the outer and inner relation, so we compute these once and then pass 
 * them to all the join cost estimation functions. 
 * 
 * Input parameters: 
 *  outerrel: outer relation under consideration 
 *  innerrel: inner relation under consideration 
 *  jointype: if not JOIN_SEMI or JOIN_ANTI, we assume it's inner_unique 
 *  sjinfo: SpecialJoinInfo relevant to this join 
 *  restrictlist: join quals 
 * Output parameters: 
 *  *semifactors is filled in (see relation.h for field definitions) 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN3745"></a><span class='Declare_Function'>compute_semi_anti_join_factors</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN3746"></a>                               <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>outerrel</span><span class='Delimiter'>, 
</span><a name="LN3747"></a>                               <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>innerrel</span><span class='Delimiter'>, 
</span><a name="LN3748"></a>                               <a href="../../../include/nodes/nodes.h.html#LN671"><span class='Ref_to_Enum'>JoinType</span></a> <span class='Declare_Parameter'>jointype</span><span class='Delimiter'>, 
</span><a name="LN3749"></a>                               <a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sjinfo</span><span class='Delimiter'>, 
</span><a name="LN3750"></a>                               <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>restrictlist</span><span class='Delimiter'>, 
</span><a name="LN3751"></a>                               <a href="../../../include/nodes/relation.h.html#LN2158"><span class='Ref_to_Struct'>SemiAntiJoinFactors</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>semifactors</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3753"></a>    <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Local'>jselec</span><span class='Delimiter'>; 
</span><a name="LN3754"></a>    <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Local'>nselec</span><span class='Delimiter'>; 
</span><a name="LN3755"></a>    <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Local'>avgmatch</span><span class='Delimiter'>; 
</span><a name="LN3756"></a>    <a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Declare_Local'>norm_sjinfo</span><span class='Delimiter'>; 
</span><a name="LN3757"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>joinquals</span><span class='Delimiter'>; 
</span><a name="LN3758"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * In an ANTI join, we must ignore clauses that are "pushed down", since 
     * those won't affect the match logic.  In a SEMI join, we do not 
     * distinguish joinquals from "pushed down" quals, so just use the whole 
     * restrictinfo list.  For other outer join types, we should consider only 
     * non-pushed-down quals, so that this devolves to an IS_OUTER_JOIN check. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN720"><span class='Ref_to_Macro'>IS_OUTER_JOIN</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3748"><span class='Ref_to_Parameter'>jointype</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="costsize.c.html#LN3757"><span class='Ref_To_Local'>joinquals</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3758"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN3750"><span class='Ref_to_Parameter'>restrictlist</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN3772"></a>            <a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rinfo</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN108"><span class='Ref_to_Macro'>lfirst_node</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN3758"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="costsize.c.html#LN3772"><span class='Ref_To_Local'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1748"><span class='Ref_to_Member'>is_pushed_down</span></a><span class='Parentheses'>) 
</span>                <a href="costsize.c.html#LN3757"><span class='Ref_To_Local'>joinquals</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3757"><span class='Ref_To_Local'>joinquals</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN3772"><span class='Ref_To_Local'>rinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
        <a href="costsize.c.html#LN3757"><span class='Ref_To_Local'>joinquals</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN3750"><span class='Ref_to_Parameter'>restrictlist</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Get the JOIN_SEMI or JOIN_ANTI selectivity of the join clauses. 
     */ 
</span>    <a href="costsize.c.html#LN3753"><span class='Ref_To_Local'>jselec</span></a> <span class='Operator'>= </span><a href="clausesel.c.html#LN97"><span class='Ref_to_Func'>clauselist_selectivity</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3745"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                    <a href="costsize.c.html#LN3757"><span class='Ref_To_Local'>joinquals</span></a><span class='Delimiter'>, 
</span>                                    <span class='Number'>0</span><span class='Delimiter'>, 
</span>                             <span class='Parentheses'>(</span><a href="costsize.c.html#LN3748"><span class='Ref_to_Parameter'>jointype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN692"><span class='Ref_to_EnumConst'>JOIN_ANTI</span></a><span class='Parentheses'>) </span><span class='Operator'>? </span><a href="../../../include/nodes/nodes.h.html#LN692"><span class='Ref_to_EnumConst'>JOIN_ANTI</span></a> <span class='Operator'>: </span><a href="../../../include/nodes/nodes.h.html#LN691"><span class='Ref_to_EnumConst'>JOIN_SEMI</span></a><span class='Delimiter'>, 
</span>                                    <a href="costsize.c.html#LN3749"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Also get the normal inner-join selectivity of the join clauses. 
     */ 
</span>    <a href="costsize.c.html#LN3756"><span class='Ref_To_Local'>norm_sjinfo</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1915"><span class='Ref_to_Member'>type</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN260"><span class='Ref_to_EnumConst'>T_SpecialJoinInfo</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN3756"><span class='Ref_To_Local'>norm_sjinfo</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1916"><span class='Ref_to_Member'>min_lefthand</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN3746"><span class='Ref_to_Parameter'>outerrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN3756"><span class='Ref_To_Local'>norm_sjinfo</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1917"><span class='Ref_to_Member'>min_righthand</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN3747"><span class='Ref_to_Parameter'>innerrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN3756"><span class='Ref_To_Local'>norm_sjinfo</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1918"><span class='Ref_to_Member'>syn_lefthand</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN3746"><span class='Ref_to_Parameter'>outerrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN3756"><span class='Ref_To_Local'>norm_sjinfo</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1919"><span class='Ref_to_Member'>syn_righthand</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN3747"><span class='Ref_to_Parameter'>innerrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN3756"><span class='Ref_To_Local'>norm_sjinfo</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1920"><span class='Ref_to_Member'>jointype</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN677"><span class='Ref_to_EnumConst'>JOIN_INNER</span></a><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* we don't bother trying to make the remaining fields valid */ 
</span>    <a href="costsize.c.html#LN3756"><span class='Ref_To_Local'>norm_sjinfo</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1921"><span class='Ref_to_Member'>lhs_strict</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN3756"><span class='Ref_To_Local'>norm_sjinfo</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1922"><span class='Ref_to_Member'>delay_upper_joins</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN3756"><span class='Ref_To_Local'>norm_sjinfo</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1924"><span class='Ref_to_Member'>semi_can_btree</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN3756"><span class='Ref_To_Local'>norm_sjinfo</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1925"><span class='Ref_to_Member'>semi_can_hash</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN3756"><span class='Ref_To_Local'>norm_sjinfo</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1926"><span class='Ref_to_Member'>semi_operators</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN3756"><span class='Ref_To_Local'>norm_sjinfo</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1927"><span class='Ref_to_Member'>semi_rhs_exprs</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN3754"><span class='Ref_To_Local'>nselec</span></a> <span class='Operator'>= </span><a href="clausesel.c.html#LN97"><span class='Ref_to_Func'>clauselist_selectivity</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3745"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                    <a href="costsize.c.html#LN3757"><span class='Ref_To_Local'>joinquals</span></a><span class='Delimiter'>, 
</span>                                    <span class='Number'>0</span><span class='Delimiter'>, 
</span>                                    <a href="../../../include/nodes/nodes.h.html#LN677"><span class='Ref_to_EnumConst'>JOIN_INNER</span></a><span class='Delimiter'>, 
</span>                                    <span class='Operator'>&</span><a href="costsize.c.html#LN3756"><span class='Ref_To_Local'>norm_sjinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Avoid leaking a lot of ListCells */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN720"><span class='Ref_to_Macro'>IS_OUTER_JOIN</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3748"><span class='Ref_to_Parameter'>jointype</span></a><span class='Parentheses'>))</span> 
        <a href="../../../include/nodes/pg_list.h.html#LN265"><span class='Ref_to_Proto'>list_free</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3757"><span class='Ref_To_Local'>joinquals</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * jselec can be interpreted as the fraction of outer-rel rows that have 
     * any matches (this is true for both SEMI and ANTI cases).  And nselec is 
     * the fraction of the Cartesian product that matches.  So, the average 
     * number of matches for each outer-rel row that has at least one match is 
     * nselec * inner_rows / jselec. 
     * 
     * Note: it is correct to use the inner rel's "rows" count here, even 
     * though we might later be considering a parameterized inner path with 
     * fewer rows.  This is because we have included all the join clauses in 
     * the selectivity estimate. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN3753"><span class='Ref_To_Local'>jselec</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span>             <span class='Comment_Single_Line'>/* protect against zero divide */ 
</span>    <span class='Delimiter'>{ 
</span>        <a href="costsize.c.html#LN3755"><span class='Ref_To_Local'>avgmatch</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN3754"><span class='Ref_To_Local'>nselec</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN3747"><span class='Ref_to_Parameter'>innerrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>/ </span><a href="costsize.c.html#LN3753"><span class='Ref_To_Local'>jselec</span></a><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* Clamp to sane range */ 
</span>        <a href="costsize.c.html#LN3755"><span class='Ref_To_Local'>avgmatch</span></a> <span class='Operator'>= </span><a href="../../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN10"><span class='Ref_to_Macro'>Max</span></a><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>, </span><a href="costsize.c.html#LN3755"><span class='Ref_To_Local'>avgmatch</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
        <a href="costsize.c.html#LN3755"><span class='Ref_To_Local'>avgmatch</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN3751"><span class='Ref_to_Parameter'>semifactors</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2160"><span class='Ref_to_Member'>outer_match_frac</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN3753"><span class='Ref_To_Local'>jselec</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN3751"><span class='Ref_to_Parameter'>semifactors</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2161"><span class='Ref_to_Member'>match_count</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN3755"><span class='Ref_To_Local'>avgmatch</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end compute_semi_anti_join_factors &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * has_indexed_join_quals 
 *    Check whether all the joinquals of a nestloop join are used as 
 *    inner index quals. 
 * 
 * If the inner path of a SEMI/ANTI join is an indexscan (including bitmap 
 * indexscan) that uses all the joinquals as indexquals, we can assume that an 
 * unmatched outer tuple is cheap to process, whereas otherwise it's probably 
 * expensive. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN3853"></a><span class='Declare_Function'>has_indexed_join_quals</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1311"><span class='Ref_to_Typedef'>NestPath</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>joinpath</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3855"></a>    <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>joinrelids</span> <span class='Operator'>= </span><a href="costsize.c.html#LN3853"><span class='Ref_to_Parameter'>joinpath</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1288"><span class='Ref_to_Member'>path</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN952"><span class='Ref_to_Member'>parent</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Delimiter'>; 
</span><a name="LN3856"></a>    <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>innerpath</span> <span class='Operator'>= </span><a href="costsize.c.html#LN3853"><span class='Ref_to_Parameter'>joinpath</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1296"><span class='Ref_to_Member'>innerjoinpath</span></a><span class='Delimiter'>; 
</span><a name="LN3857"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>indexclauses</span><span class='Delimiter'>; 
</span><a name="LN3858"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>found_one</span><span class='Delimiter'>; 
</span><a name="LN3859"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* If join still has quals to evaluate, it's not fast */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN3853"><span class='Ref_to_Parameter'>joinpath</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1298"><span class='Ref_to_Member'>joinrestrictinfo</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* Nor if the inner path isn't parameterized at all */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN3856"><span class='Ref_To_Local'>innerpath</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN955"><span class='Ref_to_Member'>param_info</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Find the indexclauses list for the inner scan */ 
</span>    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN3856"><span class='Ref_To_Local'>innerpath</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN950"><span class='Ref_to_Member'>pathtype</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN55"><span class='Ref_to_EnumConst'>T_IndexScan</span></a><span class='Operator'>: 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN56"><span class='Ref_to_EnumConst'>T_IndexOnlyScan</span></a><span class='Operator'>: 
</span>            <a href="costsize.c.html#LN3857"><span class='Ref_To_Local'>indexclauses</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/relation.h.html#LN1027"><span class='Ref_to_Struct'>IndexPath</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN3856"><span class='Ref_To_Local'>innerpath</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>indexclauses<span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN58"><span class='Ref_to_EnumConst'>T_BitmapHeapScan</span></a><span class='Operator'>: 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* Accept only a simple bitmap scan, not AND/OR cases */ 
</span><a name="LN3878"></a>                <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>bmqual</span> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/relation.h.html#LN1058"><span class='Ref_to_Struct'>BitmapHeapPath</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN3856"><span class='Ref_To_Local'>innerpath</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>bitmapqual<span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3878"><span class='Ref_To_Local'>bmqual</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1027"><span class='Ref_to_Struct'>IndexPath</span></a><span class='Parentheses'>))</span> 
                    <a href="costsize.c.html#LN3857"><span class='Ref_To_Local'>indexclauses</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/relation.h.html#LN1027"><span class='Ref_to_Struct'>IndexPath</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN3878"><span class='Ref_To_Local'>bmqual</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>indexclauses<span class='Delimiter'>; 
</span>                <span class='Control'>else</span> 
                    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Control'>default</span><span class='Operator'>: 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * If it's not a simple indexscan, it probably doesn't run quickly 
             * for zero rows out, even if it's a parameterized path using all 
             * the joinquals. 
             */ 
</span>            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch innerpath-&GT;pathtype &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Examine the inner path's param clauses.  Any that are from the outer 
     * path must be found in the indexclauses list, either exactly or in an 
     * equivalent form generated by equivclass.c.  Also, we must find at least 
     * one such clause, else it's a clauseless join which isn't fast. 
     */ 
</span>    <a href="costsize.c.html#LN3858"><span class='Ref_To_Local'>found_one</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3859"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN3856"><span class='Ref_To_Local'>innerpath</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN955"><span class='Ref_to_Member'>param_info</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN913"><span class='Ref_to_Member'>ppi_clauses</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3905"></a>        <a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3859"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/optimizer/restrictinfo.h.html#LN41"><span class='Ref_to_Proto'>join_clause_is_movable_into</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3905"><span class='Ref_To_Local'>rinfo</span></a><span class='Delimiter'>, 
</span>                                        <a href="costsize.c.html#LN3856"><span class='Ref_To_Local'>innerpath</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN952"><span class='Ref_to_Member'>parent</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Delimiter'>, 
</span>                                        <a href="costsize.c.html#LN3855"><span class='Ref_To_Local'>joinrelids</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN229"><span class='Ref_to_Proto'>list_member_ptr</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3857"><span class='Ref_To_Local'>indexclauses</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN3905"><span class='Ref_To_Local'>rinfo</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>                  <a href="../../../include/optimizer/paths.h.html#LN168"><span class='Ref_to_Proto'>is_redundant_derived_clause</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3905"><span class='Ref_To_Local'>rinfo</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN3857"><span class='Ref_To_Local'>indexclauses</span></a><span class='Parentheses'>)))</span> 
                <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="costsize.c.html#LN3858"><span class='Ref_To_Local'>found_one</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <a href="costsize.c.html#LN3858"><span class='Ref_To_Local'>found_one</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end has_indexed_join_quals &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * approx_tuple_count 
 *      Quick-and-dirty estimation of the number of join rows passing 
 *      a set of qual conditions. 
 * 
 * The quals can be either an implicitly-ANDed list of boolean expressions, 
 * or a list of RestrictInfo nodes (typically the latter). 
 * 
 * We intentionally compute the selectivity under JOIN_INNER rules, even 
 * if it's some type of outer join.  This is appropriate because we are 
 * trying to figure out how many tuples pass the initial merge or hash 
 * join step. 
 * 
 * This is quick-and-dirty because we bypass clauselist_selectivity, and 
 * simply multiply the independent clause selectivities together.  Now 
 * clauselist_selectivity often can't do any better than that anyhow, but 
 * for some situations (such as range constraints) it is smarter.  However, 
 * we can't effectively cache the results of clauselist_selectivity, whereas 
 * the individual clause selectivities can be and are cached. 
 * 
 * Since we are only using the results to estimate how many potential 
 * output tuples are generated and passed through qpqual checking, it 
 * seems OK to live with the approximation. 
 */ 
</span><span class='Keyword'>static double 
</span><a name="LN3946"></a><span class='Declare_Function'>approx_tuple_count</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1286"><span class='Ref_to_Struct'>JoinPath</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>quals</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN3948"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>tuples</span><span class='Delimiter'>; 
</span><a name="LN3949"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>outer_tuples</span> <span class='Operator'>= </span><a href="costsize.c.html#LN3946"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1295"><span class='Ref_to_Member'>outerjoinpath</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span><a name="LN3950"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>inner_tuples</span> <span class='Operator'>= </span><a href="costsize.c.html#LN3946"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1296"><span class='Ref_to_Member'>innerjoinpath</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span><a name="LN3951"></a>    <a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Declare_Local'>sjinfo</span><span class='Delimiter'>; 
</span><a name="LN3952"></a>    <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Local'>selec</span> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN3953"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Make up a SpecialJoinInfo for JOIN_INNER semantics. 
     */ 
</span>    <a href="costsize.c.html#LN3951"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1915"><span class='Ref_to_Member'>type</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN260"><span class='Ref_to_EnumConst'>T_SpecialJoinInfo</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN3951"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1916"><span class='Ref_to_Member'>min_lefthand</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN3946"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1295"><span class='Ref_to_Member'>outerjoinpath</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN952"><span class='Ref_to_Member'>parent</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN3951"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1917"><span class='Ref_to_Member'>min_righthand</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN3946"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1296"><span class='Ref_to_Member'>innerjoinpath</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN952"><span class='Ref_to_Member'>parent</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN3951"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1918"><span class='Ref_to_Member'>syn_lefthand</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN3946"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1295"><span class='Ref_to_Member'>outerjoinpath</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN952"><span class='Ref_to_Member'>parent</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN3951"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1919"><span class='Ref_to_Member'>syn_righthand</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN3946"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1296"><span class='Ref_to_Member'>innerjoinpath</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN952"><span class='Ref_to_Member'>parent</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN3951"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1920"><span class='Ref_to_Member'>jointype</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN677"><span class='Ref_to_EnumConst'>JOIN_INNER</span></a><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* we don't bother trying to make the remaining fields valid */ 
</span>    <a href="costsize.c.html#LN3951"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1921"><span class='Ref_to_Member'>lhs_strict</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN3951"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1922"><span class='Ref_to_Member'>delay_upper_joins</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN3951"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1924"><span class='Ref_to_Member'>semi_can_btree</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN3951"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1925"><span class='Ref_to_Member'>semi_can_hash</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN3951"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1926"><span class='Ref_to_Member'>semi_operators</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN3951"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN1927"><span class='Ref_to_Member'>semi_rhs_exprs</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Get the approximate selectivity */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3953"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN3946"><span class='Ref_to_Parameter'>quals</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN3975"></a>        <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>qual</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3953"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Note that clause_selectivity will be able to cache its result */ 
</span>        <a href="costsize.c.html#LN3952"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>*= </span><a href="../../../include/optimizer/cost.h.html#LN202"><span class='Ref_to_Proto'>clause_selectivity</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3946"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN3975"><span class='Ref_To_Local'>qual</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN677"><span class='Ref_to_EnumConst'>JOIN_INNER</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="costsize.c.html#LN3951"><span class='Ref_To_Local'>sjinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Apply it to the input relation sizes */ 
</span>    <a href="costsize.c.html#LN3948"><span class='Ref_To_Local'>tuples</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN3952"><span class='Ref_To_Local'>selec</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN3949"><span class='Ref_To_Local'>outer_tuples</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN3950"><span class='Ref_To_Local'>inner_tuples</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="../../../include/optimizer/cost.h.html#LN71"><span class='Ref_to_Proto'>clamp_row_est</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN3948"><span class='Ref_To_Local'>tuples</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end approx_tuple_count &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * set_baserel_size_estimates 
 *      Set the size estimates for the given base relation. 
 * 
 * The rel's targetlist and restrictinfo list must have been constructed 
 * already, and rel-&GT;tuples must be set. 
 * 
 * We set the following fields of the rel node: 
 *  rows: the estimated number of output tuples (after applying 
 *        restriction clauses). 
 *  width: the estimated average output tuple width in bytes. 
 *  baserestrictcost: estimated cost of evaluating baserestrictinfo clauses. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN4002"></a><span class='Declare_Function'>set_baserel_size_estimates</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4004"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>nrows</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Should only be applied to base relations */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN4002"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN4004"><span class='Ref_To_Local'>nrows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN4002"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN564"><span class='Ref_to_Member'>tuples</span></a> <span class='Operator'>* 
</span>        <a href="clausesel.c.html#LN97"><span class='Ref_to_Func'>clauselist_selectivity</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4002"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                               <a href="costsize.c.html#LN4002"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN583"><span class='Ref_to_Member'>baserestrictinfo</span></a><span class='Delimiter'>, 
</span>                               <span class='Number'>0</span><span class='Delimiter'>, 
</span>                               <a href="../../../include/nodes/nodes.h.html#LN677"><span class='Ref_to_EnumConst'>JOIN_INNER</span></a><span class='Delimiter'>, 
</span>                               <span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN4002"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/cost.h.html#LN71"><span class='Ref_to_Proto'>clamp_row_est</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4004"><span class='Ref_To_Local'>nrows</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/optimizer/cost.h.html#LN157"><span class='Ref_to_Proto'>cost_qual_eval</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="costsize.c.html#LN4002"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN585"><span class='Ref_to_Member'>baserestrictcost</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4002"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN583"><span class='Ref_to_Member'>baserestrictinfo</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4002"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN161"><span class='Ref_to_Proto'>set_rel_width</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4002"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4002"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end set_baserel_size_estimates &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * get_parameterized_baserel_size 
 *      Make a size estimate for a parameterized scan of a base relation. 
 * 
 * 'param_clauses' lists the additional join clauses to be used. 
 * 
 * set_baserel_size_estimates must have been applied already. 
 */ 
</span><span class='Keyword'>double 
</span><a name="LN4032"></a><span class='Declare_Function'>get_parameterized_baserel_size</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, 
</span><a name="LN4033"></a>                               <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>param_clauses</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4035"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>allclauses</span><span class='Delimiter'>; 
</span><a name="LN4036"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>nrows</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Estimate the number of rows returned by the parameterized scan, knowing 
     * that it will apply all the extra join clauses as well as the rel's own 
     * restriction clauses.  Note that we force the clauses to be treated as 
     * non-join clauses during selectivity estimation. 
     */ 
</span>    <a href="costsize.c.html#LN4035"><span class='Ref_To_Local'>allclauses</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN219"><span class='Ref_to_Proto'>list_concat</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN268"><span class='Ref_to_Proto'>list_copy</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4033"><span class='Ref_to_Parameter'>param_clauses</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                             <a href="costsize.c.html#LN4032"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN583"><span class='Ref_to_Member'>baserestrictinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN4036"><span class='Ref_To_Local'>nrows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN4032"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN564"><span class='Ref_to_Member'>tuples</span></a> <span class='Operator'>* 
</span>        <a href="clausesel.c.html#LN97"><span class='Ref_to_Func'>clauselist_selectivity</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4032"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                               <a href="costsize.c.html#LN4035"><span class='Ref_To_Local'>allclauses</span></a><span class='Delimiter'>, 
</span>                               <a href="costsize.c.html#LN4032"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a><span class='Delimiter'>,</span>      <span class='Comment_Single_Line'>/* do not use 0! */ 
</span>                               <a href="../../../include/nodes/nodes.h.html#LN677"><span class='Ref_to_EnumConst'>JOIN_INNER</span></a><span class='Delimiter'>, 
</span>                               <span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN4036"><span class='Ref_To_Local'>nrows</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/cost.h.html#LN71"><span class='Ref_to_Proto'>clamp_row_est</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4036"><span class='Ref_To_Local'>nrows</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* For safety, make sure result is not more than the base estimate */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN4036"><span class='Ref_To_Local'>nrows</span></a> <span class='Operator'>&GT; </span><a href="costsize.c.html#LN4032"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a><span class='Parentheses'>) 
</span>        <a href="costsize.c.html#LN4036"><span class='Ref_To_Local'>nrows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN4032"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="costsize.c.html#LN4036"><span class='Ref_To_Local'>nrows</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end get_parameterized_baserel_size &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * set_joinrel_size_estimates 
 *      Set the size estimates for the given join relation. 
 * 
 * The rel's targetlist must have been constructed already, and a 
 * restriction clause list that matches the given component rels must 
 * be provided. 
 * 
 * Since there is more than one way to make a joinrel for more than two 
 * base relations, the results we get here could depend on which component 
 * rel pair is provided.  In theory we should get the same answers no matter 
 * which pair is provided; in practice, since the selectivity estimation 
 * routines don't handle all cases equally well, we might not.  But there's 
 * not much to be done about it.  (Would it make sense to repeat the 
 * calculations for each pair of input rels that's encountered, and somehow 
 * average the results?  Probably way more trouble than it's worth, and 
 * anyway we must keep the rowcount estimate the same for all paths for the 
 * joinrel.) 
 * 
 * We set only the rows field here.  The reltarget field was already set by 
 * build_joinrel_tlist, and baserestrictcost is not used for join rels. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN4082"></a><span class='Declare_Function'>set_joinrel_size_estimates</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, 
</span><a name="LN4083"></a>                           <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>outer_rel</span><span class='Delimiter'>, 
</span><a name="LN4084"></a>                           <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>inner_rel</span><span class='Delimiter'>, 
</span><a name="LN4085"></a>                           <a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sjinfo</span><span class='Delimiter'>, 
</span><a name="LN4086"></a>                           <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>restrictlist</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="costsize.c.html#LN4082"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN149"><span class='Ref_to_Proto'>calc_joinrel_size_estimate</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4082"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                           <a href="costsize.c.html#LN4083"><span class='Ref_to_Parameter'>outer_rel</span></a><span class='Delimiter'>, 
</span>                                           <a href="costsize.c.html#LN4084"><span class='Ref_to_Parameter'>inner_rel</span></a><span class='Delimiter'>, 
</span>                                           <a href="costsize.c.html#LN4083"><span class='Ref_to_Parameter'>outer_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>, 
</span>                                           <a href="costsize.c.html#LN4084"><span class='Ref_to_Parameter'>inner_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>, 
</span>                                           <a href="costsize.c.html#LN4085"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Delimiter'>, 
</span>                                           <a href="costsize.c.html#LN4086"><span class='Ref_to_Parameter'>restrictlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * get_parameterized_joinrel_size 
 *      Make a size estimate for a parameterized scan of a join relation. 
 * 
 * 'rel' is the joinrel under consideration. 
 * 'outer_path', 'inner_path' are (probably also parameterized) Paths that 
 *      produce the relations being joined. 
 * 'sjinfo' is any SpecialJoinInfo relevant to this join. 
 * 'restrict_clauses' lists the join clauses that need to be applied at the 
 * join node (including any movable clauses that were moved down to this join, 
 * and not including any movable clauses that were pushed down into the 
 * child paths). 
 * 
 * set_joinrel_size_estimates must have been applied already. 
 */ 
</span><span class='Keyword'>double 
</span><a name="LN4113"></a><span class='Declare_Function'>get_parameterized_joinrel_size</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, 
</span><a name="LN4114"></a>                               <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>outer_path</span><span class='Delimiter'>, 
</span><a name="LN4115"></a>                               <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>inner_path</span><span class='Delimiter'>, 
</span><a name="LN4116"></a>                               <a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sjinfo</span><span class='Delimiter'>, 
</span><a name="LN4117"></a>                               <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>restrict_clauses</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4119"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>nrows</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Estimate the number of rows returned by the parameterized join as the 
     * sizes of the input paths times the selectivity of the clauses that have 
     * ended up at this join node. 
     * 
     * As with set_joinrel_size_estimates, the rowcount estimate could depend 
     * on the pair of input paths provided, though ideally we'd get the same 
     * estimate for any pair with the same parameterization. 
     */ 
</span>    <a href="costsize.c.html#LN4119"><span class='Ref_To_Local'>nrows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN149"><span class='Ref_to_Proto'>calc_joinrel_size_estimate</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4113"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                       <a href="costsize.c.html#LN4114"><span class='Ref_to_Parameter'>outer_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN952"><span class='Ref_to_Member'>parent</span></a><span class='Delimiter'>, 
</span>                                       <a href="costsize.c.html#LN4115"><span class='Ref_to_Parameter'>inner_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN952"><span class='Ref_to_Member'>parent</span></a><span class='Delimiter'>, 
</span>                                       <a href="costsize.c.html#LN4114"><span class='Ref_to_Parameter'>outer_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>, 
</span>                                       <a href="costsize.c.html#LN4115"><span class='Ref_to_Parameter'>inner_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>, 
</span>                                       <a href="costsize.c.html#LN4116"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Delimiter'>, 
</span>                                       <a href="costsize.c.html#LN4117"><span class='Ref_to_Parameter'>restrict_clauses</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* For safety, make sure result is not more than the base estimate */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN4119"><span class='Ref_To_Local'>nrows</span></a> <span class='Operator'>&GT; </span><a href="costsize.c.html#LN4113"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a><span class='Parentheses'>) 
</span>        <a href="costsize.c.html#LN4119"><span class='Ref_To_Local'>nrows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN4113"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="costsize.c.html#LN4119"><span class='Ref_To_Local'>nrows</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end get_parameterized_joinrel_size &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * calc_joinrel_size_estimate 
 *      Workhorse for set_joinrel_size_estimates and 
 *      get_parameterized_joinrel_size. 
 * 
 * outer_rel/inner_rel are the relations being joined, but they should be 
 * assumed to have sizes outer_rows/inner_rows; those numbers might be less 
 * than what rel-&GT;rows says, when we are considering parameterized paths. 
 */ 
</span><span class='Keyword'>static double 
</span><a name="LN4153"></a><span class='Declare_Function'>calc_joinrel_size_estimate</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN4154"></a>                           <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>outer_rel</span><span class='Delimiter'>, 
</span><a name="LN4155"></a>                           <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>inner_rel</span><span class='Delimiter'>, 
</span><a name="LN4156"></a>                           <span class='Keyword'>double </span><span class='Declare_Parameter'>outer_rows</span><span class='Delimiter'>, 
</span><a name="LN4157"></a>                           <span class='Keyword'>double </span><span class='Declare_Parameter'>inner_rows</span><span class='Delimiter'>, 
</span><a name="LN4158"></a>                           <a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sjinfo</span><span class='Delimiter'>, 
</span><a name="LN4159"></a>                           <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>restrictlist_in</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* This apparently-useless variable dodges a compiler bug in VS2013: */ 
</span><a name="LN4162"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>restrictlist</span> <span class='Operator'>= </span><a href="costsize.c.html#LN4159"><span class='Ref_to_Parameter'>restrictlist_in</span></a><span class='Delimiter'>; 
</span><a name="LN4163"></a>    <a href="../../../include/nodes/nodes.h.html#LN671"><span class='Ref_to_Enum'>JoinType</span></a>    <span class='Declare_Local'>jointype</span> <span class='Operator'>= </span><a href="costsize.c.html#LN4158"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1920"><span class='Ref_to_Member'>jointype</span></a><span class='Delimiter'>; 
</span><a name="LN4164"></a>    <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Local'>fkselec</span><span class='Delimiter'>; 
</span><a name="LN4165"></a>    <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Local'>jselec</span><span class='Delimiter'>; 
</span><a name="LN4166"></a>    <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Local'>pselec</span><span class='Delimiter'>; 
</span><a name="LN4167"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>nrows</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Compute joinclause selectivity.  Note that we are only considering 
     * clauses that become restriction clauses at this join level; we are not 
     * double-counting them because they were not considered in estimating the 
     * sizes of the component rels. 
     * 
     * First, see whether any of the joinclauses can be matched to known FK 
     * constraints.  If so, drop those clauses from the restrictlist, and 
     * instead estimate their selectivity using FK semantics.  (We do this 
     * without regard to whether said clauses are local or "pushed down". 
     * Probably, an FK-matching clause could never be seen as pushed down at 
     * an outer join, since it would be strict and hence would be grounds for 
     * join strength reduction.)  fkselec gets the net selectivity for 
     * FK-matching clauses, or 1.0 if there are none. 
     */ 
</span>    <a href="costsize.c.html#LN4164"><span class='Ref_To_Local'>fkselec</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN156"><span class='Ref_to_Proto'>get_foreign_key_join_selectivity</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4153"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                               <a href="costsize.c.html#LN4154"><span class='Ref_to_Parameter'>outer_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Delimiter'>, 
</span>                                               <a href="costsize.c.html#LN4155"><span class='Ref_to_Parameter'>inner_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Delimiter'>, 
</span>                                               <a href="costsize.c.html#LN4158"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Delimiter'>, 
</span>                                               <span class='Operator'>&</span><a href="costsize.c.html#LN4162"><span class='Ref_To_Local'>restrictlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * For an outer join, we have to distinguish the selectivity of the join's 
     * own clauses (JOIN/ON conditions) from any clauses that were "pushed 
     * down".  For inner joins we just count them all as joinclauses. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN720"><span class='Ref_to_Macro'>IS_OUTER_JOIN</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4163"><span class='Ref_To_Local'>jointype</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN4197"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>joinquals</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN4198"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>pushedquals</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN4199"></a>        <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Grovel through the clauses to separate into two lists */ 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4199"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4162"><span class='Ref_To_Local'>restrictlist</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN4204"></a>            <a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rinfo</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN108"><span class='Ref_to_Macro'>lfirst_node</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4199"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN4204"><span class='Ref_To_Local'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1748"><span class='Ref_to_Member'>is_pushed_down</span></a><span class='Parentheses'>) 
</span>                <a href="costsize.c.html#LN4198"><span class='Ref_To_Local'>pushedquals</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4198"><span class='Ref_To_Local'>pushedquals</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4204"><span class='Ref_To_Local'>rinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="costsize.c.html#LN4197"><span class='Ref_To_Local'>joinquals</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4197"><span class='Ref_To_Local'>joinquals</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4204"><span class='Ref_To_Local'>rinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* Get the separate selectivities */ 
</span>        <a href="costsize.c.html#LN4165"><span class='Ref_To_Local'>jselec</span></a> <span class='Operator'>= </span><a href="clausesel.c.html#LN97"><span class='Ref_to_Func'>clauselist_selectivity</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4153"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                        <a href="costsize.c.html#LN4197"><span class='Ref_To_Local'>joinquals</span></a><span class='Delimiter'>, 
</span>                                        <span class='Number'>0</span><span class='Delimiter'>, 
</span>                                        <a href="costsize.c.html#LN4163"><span class='Ref_To_Local'>jointype</span></a><span class='Delimiter'>, 
</span>                                        <a href="costsize.c.html#LN4158"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN4166"><span class='Ref_To_Local'>pselec</span></a> <span class='Operator'>= </span><a href="clausesel.c.html#LN97"><span class='Ref_to_Func'>clauselist_selectivity</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4153"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                        <a href="costsize.c.html#LN4198"><span class='Ref_To_Local'>pushedquals</span></a><span class='Delimiter'>, 
</span>                                        <span class='Number'>0</span><span class='Delimiter'>, 
</span>                                        <a href="costsize.c.html#LN4163"><span class='Ref_To_Local'>jointype</span></a><span class='Delimiter'>, 
</span>                                        <a href="costsize.c.html#LN4158"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Avoid leaking a lot of ListCells */ 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN265"><span class='Ref_to_Proto'>list_free</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4197"><span class='Ref_To_Local'>joinquals</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN265"><span class='Ref_to_Proto'>list_free</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4198"><span class='Ref_To_Local'>pushedquals</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if IS_OUTER_JOIN(jointyp... &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="costsize.c.html#LN4165"><span class='Ref_To_Local'>jselec</span></a> <span class='Operator'>= </span><a href="clausesel.c.html#LN97"><span class='Ref_to_Func'>clauselist_selectivity</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4153"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                        <a href="costsize.c.html#LN4162"><span class='Ref_To_Local'>restrictlist</span></a><span class='Delimiter'>, 
</span>                                        <span class='Number'>0</span><span class='Delimiter'>, 
</span>                                        <a href="costsize.c.html#LN4163"><span class='Ref_To_Local'>jointype</span></a><span class='Delimiter'>, 
</span>                                        <a href="costsize.c.html#LN4158"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN4166"><span class='Ref_To_Local'>pselec</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* not used, keep compiler quiet */ 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Basically, we multiply size of Cartesian product by selectivity. 
     * 
     * If we are doing an outer join, take that into account: the joinqual 
     * selectivity has to be clamped using the knowledge that the output must 
     * be at least as large as the non-nullable input.  However, any 
     * pushed-down quals are applied after the outer join, so their 
     * selectivity applies fully. 
     * 
     * For JOIN_SEMI and JOIN_ANTI, the selectivity is defined as the fraction 
     * of LHS rows that have matches, and we apply that straightforwardly. 
     */ 
</span>    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN4163"><span class='Ref_To_Local'>jointype</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN677"><span class='Ref_to_EnumConst'>JOIN_INNER</span></a><span class='Operator'>: 
</span>            <a href="costsize.c.html#LN4167"><span class='Ref_To_Local'>nrows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN4156"><span class='Ref_to_Parameter'>outer_rows</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN4157"><span class='Ref_to_Parameter'>inner_rows</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN4164"><span class='Ref_To_Local'>fkselec</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN4165"><span class='Ref_To_Local'>jselec</span></a><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* pselec not used */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN678"><span class='Ref_to_EnumConst'>JOIN_LEFT</span></a><span class='Operator'>: 
</span>            <a href="costsize.c.html#LN4167"><span class='Ref_To_Local'>nrows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN4156"><span class='Ref_to_Parameter'>outer_rows</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN4157"><span class='Ref_to_Parameter'>inner_rows</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN4164"><span class='Ref_To_Local'>fkselec</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN4165"><span class='Ref_To_Local'>jselec</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN4167"><span class='Ref_To_Local'>nrows</span></a> <span class='Operator'>&LT; </span><a href="costsize.c.html#LN4156"><span class='Ref_to_Parameter'>outer_rows</span></a><span class='Parentheses'>) 
</span>                <a href="costsize.c.html#LN4167"><span class='Ref_To_Local'>nrows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN4156"><span class='Ref_to_Parameter'>outer_rows</span></a><span class='Delimiter'>; 
</span>            <a href="costsize.c.html#LN4167"><span class='Ref_To_Local'>nrows</span></a> <span class='Operator'>*= </span><a href="costsize.c.html#LN4166"><span class='Ref_To_Local'>pselec</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN679"><span class='Ref_to_EnumConst'>JOIN_FULL</span></a><span class='Operator'>: 
</span>            <a href="costsize.c.html#LN4167"><span class='Ref_To_Local'>nrows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN4156"><span class='Ref_to_Parameter'>outer_rows</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN4157"><span class='Ref_to_Parameter'>inner_rows</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN4164"><span class='Ref_To_Local'>fkselec</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN4165"><span class='Ref_To_Local'>jselec</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN4167"><span class='Ref_To_Local'>nrows</span></a> <span class='Operator'>&LT; </span><a href="costsize.c.html#LN4156"><span class='Ref_to_Parameter'>outer_rows</span></a><span class='Parentheses'>) 
</span>                <a href="costsize.c.html#LN4167"><span class='Ref_To_Local'>nrows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN4156"><span class='Ref_to_Parameter'>outer_rows</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN4167"><span class='Ref_To_Local'>nrows</span></a> <span class='Operator'>&LT; </span><a href="costsize.c.html#LN4157"><span class='Ref_to_Parameter'>inner_rows</span></a><span class='Parentheses'>) 
</span>                <a href="costsize.c.html#LN4167"><span class='Ref_To_Local'>nrows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN4157"><span class='Ref_to_Parameter'>inner_rows</span></a><span class='Delimiter'>; 
</span>            <a href="costsize.c.html#LN4167"><span class='Ref_To_Local'>nrows</span></a> <span class='Operator'>*= </span><a href="costsize.c.html#LN4166"><span class='Ref_To_Local'>pselec</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN691"><span class='Ref_to_EnumConst'>JOIN_SEMI</span></a><span class='Operator'>: 
</span>            <a href="costsize.c.html#LN4167"><span class='Ref_To_Local'>nrows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN4156"><span class='Ref_to_Parameter'>outer_rows</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN4164"><span class='Ref_To_Local'>fkselec</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN4165"><span class='Ref_To_Local'>jselec</span></a><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* pselec not used */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN692"><span class='Ref_to_EnumConst'>JOIN_ANTI</span></a><span class='Operator'>: 
</span>            <a href="costsize.c.html#LN4167"><span class='Ref_To_Local'>nrows</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN4156"><span class='Ref_to_Parameter'>outer_rows</span></a> <span class='Operator'>* </span><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>- </span><a href="costsize.c.html#LN4164"><span class='Ref_To_Local'>fkselec</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN4165"><span class='Ref_To_Local'>jselec</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="costsize.c.html#LN4167"><span class='Ref_To_Local'>nrows</span></a> <span class='Operator'>*= </span><a href="costsize.c.html#LN4166"><span class='Ref_To_Local'>pselec</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>default</span><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* other values not expected here */ 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized join type: %d"</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN4163"><span class='Ref_To_Local'>jointype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="costsize.c.html#LN4167"><span class='Ref_To_Local'>nrows</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* keep compiler quiet */ 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch jointype &raquo; </span> 
 
    <span class='Control'>return</span> <a href="../../../include/optimizer/cost.h.html#LN71"><span class='Ref_to_Proto'>clamp_row_est</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4167"><span class='Ref_To_Local'>nrows</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end calc_joinrel_size_estimate &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * get_foreign_key_join_selectivity 
 *      Estimate join selectivity for foreign-key-related clauses. 
 * 
 * Remove any clauses that can be matched to FK constraints from *restrictlist, 
 * and return a substitute estimate of their selectivity.  1.0 is returned 
 * when there are no such clauses. 
 * 
 * The reason for treating such clauses specially is that we can get better 
 * estimates this way than by relying on clauselist_selectivity(), especially 
 * for multi-column FKs where that function's assumption that the clauses are 
 * independent falls down badly.  But even with single-column FKs, we may be 
 * able to get a better answer when the pg_statistic stats are missing or out 
 * of date. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> 
<a name="LN4304"></a><span class='Declare_Function'>get_foreign_key_join_selectivity</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN4305"></a>                                 <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Declare_Parameter'>outer_relids</span><span class='Delimiter'>, 
</span><a name="LN4306"></a>                                 <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Declare_Parameter'>inner_relids</span><span class='Delimiter'>, 
</span><a name="LN4307"></a>                                 <a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sjinfo</span><span class='Delimiter'>, 
</span><a name="LN4308"></a>                                 <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>restrictlist</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4310"></a>    <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Local'>fkselec</span> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN4311"></a>    <a href="../../../include/nodes/nodes.h.html#LN671"><span class='Ref_to_Enum'>JoinType</span></a>    <span class='Declare_Local'>jointype</span> <span class='Operator'>= </span><a href="costsize.c.html#LN4307"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1920"><span class='Ref_to_Member'>jointype</span></a><span class='Delimiter'>; 
</span><a name="LN4312"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>worklist</span> <span class='Operator'>= *</span><a href="costsize.c.html#LN4308"><span class='Ref_to_Parameter'>restrictlist</span></a><span class='Delimiter'>; 
</span><a name="LN4313"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Consider each FK constraint that is known to match the query */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4313"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4304"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN259"><span class='Ref_to_Member'>fkey_list</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN4318"></a>        <a href="../../../include/nodes/relation.h.html#LN687"><span class='Ref_to_Struct'>ForeignKeyOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>fkinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN687"><span class='Ref_to_Struct'>ForeignKeyOptInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4313"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN4319"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>ref_is_outer</span><span class='Delimiter'>; 
</span><a name="LN4320"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>use_smallest_selectivity</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN4321"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>removedlist</span><span class='Delimiter'>; 
</span><a name="LN4322"></a>        <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>cell</span><span class='Delimiter'>; 
</span><a name="LN4323"></a>        <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>prev</span><span class='Delimiter'>; 
</span><a name="LN4324"></a>        <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>next</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * This FK is not relevant unless it connects a baserel on one side of 
         * this join to a baserel on the other side. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN75"><span class='Ref_to_Proto'>bms_is_member</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4318"><span class='Ref_To_Local'>fkinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN692"><span class='Ref_to_Member'>con_relid</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4305"><span class='Ref_to_Parameter'>outer_relids</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>            <a href="../../../include/nodes/bitmapset.h.html#LN75"><span class='Ref_to_Proto'>bms_is_member</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4318"><span class='Ref_To_Local'>fkinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN693"><span class='Ref_to_Member'>ref_relid</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4306"><span class='Ref_to_Parameter'>inner_relids</span></a><span class='Parentheses'>))</span> 
            <a href="costsize.c.html#LN4319"><span class='Ref_To_Local'>ref_is_outer</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN75"><span class='Ref_to_Proto'>bms_is_member</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4318"><span class='Ref_To_Local'>fkinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN693"><span class='Ref_to_Member'>ref_relid</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4305"><span class='Ref_to_Parameter'>outer_relids</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                 <a href="../../../include/nodes/bitmapset.h.html#LN75"><span class='Ref_to_Proto'>bms_is_member</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4318"><span class='Ref_To_Local'>fkinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN692"><span class='Ref_to_Member'>con_relid</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4306"><span class='Ref_to_Parameter'>inner_relids</span></a><span class='Parentheses'>))</span> 
            <a href="costsize.c.html#LN4319"><span class='Ref_To_Local'>ref_is_outer</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Modify the restrictlist by removing clauses that match the FK (and 
         * putting them into removedlist instead).  It seems unsafe to modify 
         * the originally-passed List structure, so we make a shallow copy the 
         * first time through. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN4312"><span class='Ref_To_Local'>worklist</span></a> <span class='Operator'>== *</span><a href="costsize.c.html#LN4308"><span class='Ref_to_Parameter'>restrictlist</span></a><span class='Parentheses'>) 
</span>            <a href="costsize.c.html#LN4312"><span class='Ref_To_Local'>worklist</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN268"><span class='Ref_to_Proto'>list_copy</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4312"><span class='Ref_To_Local'>worklist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="costsize.c.html#LN4321"><span class='Ref_To_Local'>removedlist</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN4323"><span class='Ref_To_Local'>prev</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN4322"><span class='Ref_To_Local'>cell</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4312"><span class='Ref_To_Local'>worklist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; </span><a href="costsize.c.html#LN4322"><span class='Ref_To_Local'>cell</span></a><span class='Delimiter'>; </span><a href="costsize.c.html#LN4322"><span class='Ref_To_Local'>cell</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN4324"><span class='Ref_To_Local'>next</span></a><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span><a name="LN4352"></a>            <a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4322"><span class='Ref_To_Local'>cell</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN4353"></a>            <span class='Keyword'>bool</span>        <span class='Declare_Local'>remove_it</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN4354"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
            <a href="costsize.c.html#LN4324"><span class='Ref_To_Local'>next</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4322"><span class='Ref_To_Local'>cell</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* Drop this clause if it matches any column of the FK */ 
</span>            <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN4354"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="costsize.c.html#LN4354"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT; </span><a href="costsize.c.html#LN4318"><span class='Ref_To_Local'>fkinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN694"><span class='Ref_to_Member'>nkeys</span></a><span class='Delimiter'>; </span><a href="costsize.c.html#LN4354"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN4352"><span class='Ref_To_Local'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1780"><span class='Ref_to_Member'>parent_ec</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* 
                     * EC-derived clauses can only match by EC.  It is okay to 
                     * consider any clause derived from the same EC as 
                     * matching the FK: even if equivclass.c chose to generate 
                     * a clause equating some other pair of Vars, it could 
                     * have generated one equating the FK's Vars.  So for 
                     * purposes of estimation, we can act as though it did so. 
                     * 
                     * Note: checking parent_ec is a bit of a cheat because 
                     * there are EC-derived clauses that don't have parent_ec 
                     * set; but such clauses must compare expressions that 
                     * aren't just Vars, so they cannot match the FK anyway. 
                     */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN4318"><span class='Ref_To_Local'>fkinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN704"><span class='Ref_to_Member'>eclass</span></a><span class='Delimiter'>[</span><a href="costsize.c.html#LN4354"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><a href="costsize.c.html#LN4352"><span class='Ref_To_Local'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1780"><span class='Ref_to_Member'>parent_ec</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <a href="costsize.c.html#LN4353"><span class='Ref_To_Local'>remove_it</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                        <span class='Control'>break</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if rinfo-&GT;parent_ec &raquo; </span> 
                <span class='Control'>else</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* 
                     * Otherwise, see if rinfo was previously matched to FK as 
                     * a "loose" clause. 
                     */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN229"><span class='Ref_to_Proto'>list_member_ptr</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4318"><span class='Ref_To_Local'>fkinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN706"><span class='Ref_to_Member'>rinfos</span></a><span class='Delimiter'>[</span><a href="costsize.c.html#LN4354"><span class='Ref_To_Local'>i</span></a><span class='Delimiter'>], </span><a href="costsize.c.html#LN4352"><span class='Ref_To_Local'>rinfo</span></a><span class='Parentheses'>))</span> 
                    <span class='Delimiter'>{ 
</span>                        <a href="costsize.c.html#LN4353"><span class='Ref_To_Local'>remove_it</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                        <span class='Control'>break</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for i=0;i&LT;fkinfo-&GT;nkeys;i... &raquo; </span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN4353"><span class='Ref_To_Local'>remove_it</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="costsize.c.html#LN4312"><span class='Ref_To_Local'>worklist</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN238"><span class='Ref_to_Proto'>list_delete_cell</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4312"><span class='Ref_To_Local'>worklist</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4322"><span class='Ref_To_Local'>cell</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4323"><span class='Ref_To_Local'>prev</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="costsize.c.html#LN4321"><span class='Ref_To_Local'>removedlist</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4321"><span class='Ref_To_Local'>removedlist</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4352"><span class='Ref_To_Local'>rinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
                <a href="costsize.c.html#LN4323"><span class='Ref_To_Local'>prev</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN4322"><span class='Ref_To_Local'>cell</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for cell=list_head(workli... &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* 
         * If we failed to remove all the matching clauses we expected to 
         * find, chicken out and ignore this FK; applying its selectivity 
         * might result in double-counting.  Put any clauses we did manage to 
         * remove back into the worklist. 
         * 
         * Since the matching clauses are known not outerjoin-delayed, they 
         * should certainly have appeared in the initial joinclause list.  If 
         * we didn't find them, they must have been matched to, and removed 
         * by, some other FK in a previous iteration of this loop.  (A likely 
         * case is that two FKs are matched to the same EC; there will be only 
         * one EC-derived clause in the initial list, so the first FK will 
         * consume it.)  Applying both FKs' selectivity independently risks 
         * underestimating the join size; in particular, this would undo one 
         * of the main things that ECs were invented for, namely to avoid 
         * double-counting the selectivity of redundant equality conditions. 
         * Later we might think of a reasonable way to combine the estimates, 
         * but for now, just punt, since this is a fairly uncommon situation. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4321"><span class='Ref_To_Local'>removedlist</span></a><span class='Parentheses'>) </span><span class='Operator'>!= 
</span>            <span class='Parentheses'>(</span><a href="costsize.c.html#LN4318"><span class='Ref_To_Local'>fkinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN700"><span class='Ref_to_Member'>nmatched_ec</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN4318"><span class='Ref_To_Local'>fkinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN702"><span class='Ref_to_Member'>nmatched_ri</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="costsize.c.html#LN4312"><span class='Ref_To_Local'>worklist</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN219"><span class='Ref_to_Proto'>list_concat</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4312"><span class='Ref_To_Local'>worklist</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4321"><span class='Ref_To_Local'>removedlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Finally we get to the payoff: estimate selectivity using the 
         * knowledge that each referencing row will match exactly one row in 
         * the referenced table. 
         * 
         * XXX that's not true in the presence of nulls in the referencing 
         * column(s), so in principle we should derate the estimate for those. 
         * However (1) if there are any strict restriction clauses for the 
         * referencing column(s) elsewhere in the query, derating here would 
         * be double-counting the null fraction, and (2) it's not very clear 
         * how to combine null fractions for multiple referencing columns. 
         * 
         * In the use_smallest_selectivity code below, null derating is done 
         * implicitly by relying on clause_selectivity(); in the other cases, 
         * we do nothing for now about correcting for nulls. 
         * 
         * XXX another point here is that if either side of an FK constraint 
         * is an inheritance parent, we estimate as though the constraint 
         * covers all its children as well.  This is not an unreasonable 
         * assumption for a referencing table, ie the user probably applied 
         * identical constraints to all child tables (though perhaps we ought 
         * to check that).  But it's not possible to have done that for a 
         * referenced table.  Fortunately, precisely because that doesn't 
         * work, it is uncommon in practice to have an FK referencing a parent 
         * table.  So, at least for now, disregard inheritance here. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN4319"><span class='Ref_To_Local'>ref_is_outer</span></a> <span class='Operator'>&& </span><a href="costsize.c.html#LN4311"><span class='Ref_To_Local'>jointype</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/nodes.h.html#LN677"><span class='Ref_to_EnumConst'>JOIN_INNER</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * When the referenced table is on the outer side of a non-inner 
             * join, knowing that each inner row has exactly one match is not 
             * as useful as one could wish, since we really need to know the 
             * fraction of outer rows with a match.  Still, we can avoid the 
             * folly of multiplying the per-column estimates together.  Take 
             * the smallest per-column selectivity, instead.  (This should 
             * correspond to the FK column with the most nulls.) 
             */ 
</span>            <a href="costsize.c.html#LN4320"><span class='Ref_To_Local'>use_smallest_selectivity</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN4311"><span class='Ref_To_Local'>jointype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN691"><span class='Ref_to_EnumConst'>JOIN_SEMI</span></a> <span class='Operator'>|| </span><a href="costsize.c.html#LN4311"><span class='Ref_To_Local'>jointype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN692"><span class='Ref_to_EnumConst'>JOIN_ANTI</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * For JOIN_SEMI and JOIN_ANTI, the selectivity is defined as the 
             * fraction of LHS rows that have matches.  The referenced table 
             * is on the inner side (we already handled the other case above), 
             * so the FK implies that every LHS row has a match *in the 
             * referenced table*.  But any restriction or join clauses below 
             * here will reduce the number of matches. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN84"><span class='Ref_to_Proto'>bms_membership</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4306"><span class='Ref_to_Parameter'>inner_relids</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="../../../include/nodes/bitmapset.h.html#LN56"><span class='Ref_to_EnumConst'>BMS_SINGLETON</span></a><span class='Parentheses'>)</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * When the inner side of the semi/anti join is just the 
                 * referenced table, we may take the FK selectivity as equal 
                 * to the selectivity of the table's restriction clauses. 
                 */ 
</span><a name="LN4485"></a>                <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>ref_rel</span> <span class='Operator'>= </span><a href="../util/relnode.c.html#LN241"><span class='Ref_to_Func'>find_base_rel</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4304"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4318"><span class='Ref_To_Local'>fkinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN693"><span class='Ref_to_Member'>ref_relid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN4486"></a>                <span class='Keyword'>double</span>      <span class='Declare_Local'>ref_tuples</span> <span class='Operator'>= </span><a href="../../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN10"><span class='Ref_to_Macro'>Max</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4485"><span class='Ref_To_Local'>ref_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN564"><span class='Ref_to_Member'>tuples</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="costsize.c.html#LN4310"><span class='Ref_To_Local'>fkselec</span></a> <span class='Operator'>*= </span><a href="costsize.c.html#LN4485"><span class='Ref_To_Local'>ref_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>/ </span><a href="costsize.c.html#LN4486"><span class='Ref_To_Local'>ref_tuples</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * When the inner side of the semi/anti join is itself a join, 
                 * it's hard to guess what fraction of the referenced table 
                 * will get through the join.  But we still don't want to 
                 * multiply per-column estimates together.  Take the smallest 
                 * per-column selectivity, instead. 
                 */ 
</span>                <a href="costsize.c.html#LN4320"><span class='Ref_To_Local'>use_smallest_selectivity</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if jointype==JOIN_SEMI||... &raquo; </span> 
        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Otherwise, selectivity is exactly 1/referenced-table-size; but 
             * guard against tuples == 0.  Note we should use the raw table 
             * tuple count, not any estimate of its filtered or joined size. 
             */ 
</span><a name="LN4509"></a>            <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>ref_rel</span> <span class='Operator'>= </span><a href="../util/relnode.c.html#LN241"><span class='Ref_to_Func'>find_base_rel</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4304"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4318"><span class='Ref_To_Local'>fkinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN693"><span class='Ref_to_Member'>ref_relid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN4510"></a>            <span class='Keyword'>double</span>      <span class='Declare_Local'>ref_tuples</span> <span class='Operator'>= </span><a href="../../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN10"><span class='Ref_to_Macro'>Max</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4509"><span class='Ref_To_Local'>ref_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN564"><span class='Ref_to_Member'>tuples</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="costsize.c.html#LN4310"><span class='Ref_To_Local'>fkselec</span></a> <span class='Operator'>*= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>/ </span><a href="costsize.c.html#LN4510"><span class='Ref_To_Local'>ref_tuples</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Common code for cases where we should use the smallest selectivity 
         * that would be computed for any one of the FK's clauses. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN4320"><span class='Ref_To_Local'>use_smallest_selectivity</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN4521"></a>            <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Local'>thisfksel</span> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
            <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4322"><span class='Ref_To_Local'>cell</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4321"><span class='Ref_To_Local'>removedlist</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN4525"></a>                <a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4322"><span class='Ref_To_Local'>cell</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN4526"></a>                <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Local'>csel</span><span class='Delimiter'>; 
</span> 
                <a href="costsize.c.html#LN4526"><span class='Ref_To_Local'>csel</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/cost.h.html#LN202"><span class='Ref_to_Proto'>clause_selectivity</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4304"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN4525"><span class='Ref_To_Local'>rinfo</span></a><span class='Delimiter'>, 
</span>                                          <span class='Number'>0</span><span class='Delimiter'>, </span><a href="costsize.c.html#LN4311"><span class='Ref_To_Local'>jointype</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4307"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="costsize.c.html#LN4521"><span class='Ref_To_Local'>thisfksel</span></a> <span class='Operator'>= </span><a href="../../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN11"><span class='Ref_to_Macro'>Min</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4521"><span class='Ref_To_Local'>thisfksel</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4526"><span class='Ref_To_Local'>csel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <a href="costsize.c.html#LN4310"><span class='Ref_To_Local'>fkselec</span></a> <span class='Operator'>*= </span><a href="costsize.c.html#LN4521"><span class='Ref_To_Local'>thisfksel</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Operator'>*</span><a href="costsize.c.html#LN4308"><span class='Ref_to_Parameter'>restrictlist</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN4312"><span class='Ref_To_Local'>worklist</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="costsize.c.html#LN4310"><span class='Ref_To_Local'>fkselec</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end get_foreign_key_join_selectivity &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * set_subquery_size_estimates 
 *      Set the size estimates for a base relation that is a subquery. 
 * 
 * The rel's targetlist and restrictinfo list must have been constructed 
 * already, and the Paths for the subquery must have been completed. 
 * We look at the subquery's PlannerInfo to extract data. 
 * 
 * We set the same fields as set_baserel_size_estimates. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN4551"></a><span class='Declare_Function'>set_subquery_size_estimates</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4553"></a>    <a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>subroot</span> <span class='Operator'>= </span><a href="costsize.c.html#LN4551"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN566"><span class='Ref_to_Member'>subroot</span></a><span class='Delimiter'>; 
</span><a name="LN4554"></a>    <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sub_final_rel</span><span class='Delimiter'>; 
</span><a name="LN4555"></a>    <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span>rte <span class='Declare_Local'>PG_USED_FOR_ASSERTS_ONLY</span><span class='Delimiter'>; 
</span><a name="LN4556"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Should only be applied to base relations that are subqueries */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN4551"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#ifdef</span> USE_ASSERT_CHECKING 
    rte <span class='Operator'>= </span><a href="../../../include/nodes/relation.h.html#LN324"><span class='Ref_to_Macro'>planner_rt_fetch</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4551"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4551"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span>rte<span class='Operator'>-&GT;</span>rtekind <span class='Operator'>== </span><a href="../../../include/nodes/parsenodes.h.html#LN923"><span class='Ref_to_EnumConst'>RTE_SUBQUERY</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Copy raw number of output rows from subquery.  All of its paths should 
     * have the same output rowcount, so just look at cheapest-total. 
     */ 
</span>    <a href="costsize.c.html#LN4554"><span class='Ref_To_Local'>sub_final_rel</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/pathnode.h.html#LN270"><span class='Ref_to_Proto'>fetch_upper_rel</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4553"><span class='Ref_To_Local'>subroot</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN77"><span class='Ref_to_EnumConst'>UPPERREL_FINAL</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN4551"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN564"><span class='Ref_to_Member'>tuples</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN4554"><span class='Ref_To_Local'>sub_final_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN542"><span class='Ref_to_Member'>cheapest_total_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN963"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Compute per-output-column width estimates by examining the subquery's 
     * targetlist.  For any output that is a plain Var, get the width estimate 
     * that was made while planning the subquery.  Otherwise, we leave it to 
     * set_rel_width to fill in a datatype-based default estimate. 
     */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4556"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4553"><span class='Ref_To_Local'>subroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN4580"></a>        <a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>te</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN108"><span class='Ref_to_Macro'>lfirst_node</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4556"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN4581"></a>        <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>texpr</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN4580"><span class='Ref_To_Local'>te</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Delimiter'>; 
</span><a name="LN4582"></a>        <a href="../../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Local'>item_width</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* junk columns aren't visible to upper query */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN4580"><span class='Ref_To_Local'>te</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1373"><span class='Ref_to_Member'>resjunk</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * The subquery could be an expansion of a view that's had columns 
         * added to it since the current query was parsed, so that there are 
         * non-junk tlist columns in it that don't correspond to any column 
         * visible at our query level.  Ignore such columns. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN4580"><span class='Ref_To_Local'>te</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1367"><span class='Ref_to_Member'>resno</span></a> <span class='Operator'>&LT; </span><a href="costsize.c.html#LN4551"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN555"><span class='Ref_to_Member'>min_attr</span></a> <span class='Operator'>|| </span><a href="costsize.c.html#LN4580"><span class='Ref_To_Local'>te</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1367"><span class='Ref_to_Member'>resno</span></a> <span class='Operator'>&GT; </span><a href="costsize.c.html#LN4551"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN556"><span class='Ref_to_Member'>max_attr</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * XXX This currently doesn't work for subqueries containing set 
         * operations, because the Vars in their tlists are bogus references 
         * to the first leaf subquery, which wouldn't give the right answer 
         * even if we could still get to its PlannerInfo. 
         * 
         * Also, the subquery could be an appendrel for which all branches are 
         * known empty due to constraint exclusion, in which case 
         * set_append_rel_pathlist will have left the attr_widths set to zero. 
         * 
         * In either case, we just leave the width estimate zero until 
         * set_rel_width fixes it. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4581"><span class='Ref_To_Local'>texpr</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>            <a href="costsize.c.html#LN4553"><span class='Ref_To_Local'>subroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN162"><span class='Ref_to_Member'>setOperations</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span><a name="LN4613"></a>            <a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>var</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN4581"><span class='Ref_To_Local'>texpr</span></a><span class='Delimiter'>; 
</span><a name="LN4614"></a>            <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>subrel</span> <span class='Operator'>= </span><a href="../util/relnode.c.html#LN241"><span class='Ref_to_Func'>find_base_rel</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4553"><span class='Ref_To_Local'>subroot</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4613"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN165"><span class='Ref_to_Member'>varno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="costsize.c.html#LN4582"><span class='Ref_To_Local'>item_width</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN4614"><span class='Ref_To_Local'>subrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN558"><span class='Ref_to_Member'>attr_widths</span></a><span class='Delimiter'>[</span><a href="costsize.c.html#LN4613"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN167"><span class='Ref_to_Member'>varattno</span></a> <span class='Operator'>- </span><a href="costsize.c.html#LN4614"><span class='Ref_To_Local'>subrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN555"><span class='Ref_to_Member'>min_attr</span></a><span class='Delimiter'>]; 
</span>        <span class='Delimiter'>} 
</span>        <a href="costsize.c.html#LN4551"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN558"><span class='Ref_to_Member'>attr_widths</span></a><span class='Delimiter'>[</span><a href="costsize.c.html#LN4580"><span class='Ref_To_Local'>te</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1367"><span class='Ref_to_Member'>resno</span></a> <span class='Operator'>- </span><a href="costsize.c.html#LN4551"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN555"><span class='Ref_to_Member'>min_attr</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="costsize.c.html#LN4582"><span class='Ref_To_Local'>item_width</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Now estimate number of output rows, etc */ 
</span>    <a href="../../../include/optimizer/cost.h.html#LN166"><span class='Ref_to_Proto'>set_baserel_size_estimates</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4551"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4551"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end set_subquery_size_estimates &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * set_function_size_estimates 
 *      Set the size estimates for a base relation that is a function call. 
 * 
 * The rel's targetlist and restrictinfo list must have been constructed 
 * already. 
 * 
 * We set the same fields as set_baserel_size_estimates. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN4635"></a><span class='Declare_Function'>set_function_size_estimates</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4637"></a>    <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span><span class='Delimiter'>; 
</span><a name="LN4638"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Should only be applied to base relations that are functions */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN4635"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN4637"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/relation.h.html#LN324"><span class='Ref_to_Macro'>planner_rt_fetch</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4635"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4635"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN4637"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN936"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/parsenodes.h.html#LN925"><span class='Ref_to_EnumConst'>RTE_FUNCTION</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Estimate number of rows the functions will return. The rowcount of the 
     * node is that of the largest function result. 
     */ 
</span>    <a href="costsize.c.html#LN4635"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN564"><span class='Ref_to_Member'>tuples</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4638"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4637"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN985"><span class='Ref_to_Member'>functions</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN4652"></a>        <a href="../../../include/nodes/parsenodes.h.html#LN1051"><span class='Ref_to_Struct'>RangeTblFunction</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rtfunc</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN1051"><span class='Ref_to_Struct'>RangeTblFunction</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4638"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN4653"></a>        <span class='Keyword'>double</span>      <span class='Declare_Local'>ntup</span> <span class='Operator'>= </span><a href="../../../include/optimizer/clauses.h.html#LN55"><span class='Ref_to_Proto'>expression_returns_set_rows</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4652"><span class='Ref_To_Local'>rtfunc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1055"><span class='Ref_to_Member'>funcexpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN4653"><span class='Ref_To_Local'>ntup</span></a> <span class='Operator'>&GT; </span><a href="costsize.c.html#LN4635"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN564"><span class='Ref_to_Member'>tuples</span></a><span class='Parentheses'>) 
</span>            <a href="costsize.c.html#LN4635"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN564"><span class='Ref_to_Member'>tuples</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN4653"><span class='Ref_To_Local'>ntup</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Now estimate number of output rows, etc */ 
</span>    <a href="../../../include/optimizer/cost.h.html#LN166"><span class='Ref_to_Proto'>set_baserel_size_estimates</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4635"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4635"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end set_function_size_estimates &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * set_function_size_estimates 
 *      Set the size estimates for a base relation that is a function call. 
 * 
 * The rel's targetlist and restrictinfo list must have been constructed 
 * already. 
 * 
 * We set the same fields as set_tablefunc_size_estimates. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN4673"></a><span class='Declare_Function'>set_tablefunc_size_estimates</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4675"></a>    <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span>rte <span class='Declare_Local'>PG_USED_FOR_ASSERTS_ONLY</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Should only be applied to base relations that are functions */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN4673"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#ifdef</span> USE_ASSERT_CHECKING 
    rte <span class='Operator'>= </span><a href="../../../include/nodes/relation.h.html#LN324"><span class='Ref_to_Macro'>planner_rt_fetch</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4673"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4673"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span>rte<span class='Operator'>-&GT;</span>rtekind <span class='Operator'>== </span><a href="../../../include/nodes/parsenodes.h.html#LN926"><span class='Ref_to_EnumConst'>RTE_TABLEFUNC</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><span class='Directive'>#endif</span> 
 
    <a href="costsize.c.html#LN4673"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN564"><span class='Ref_to_Member'>tuples</span></a> <span class='Operator'>= </span><span class='Number'>100</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Now estimate number of output rows, etc */ 
</span>    <a href="../../../include/optimizer/cost.h.html#LN166"><span class='Ref_to_Proto'>set_baserel_size_estimates</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4673"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4673"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * set_values_size_estimates 
 *      Set the size estimates for a base relation that is a values list. 
 * 
 * The rel's targetlist and restrictinfo list must have been constructed 
 * already. 
 * 
 * We set the same fields as set_baserel_size_estimates. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN4700"></a><span class='Declare_Function'>set_values_size_estimates</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4702"></a>    <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Should only be applied to base relations that are values lists */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN4700"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN4702"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/relation.h.html#LN324"><span class='Ref_to_Macro'>planner_rt_fetch</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4700"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4700"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN4702"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN936"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/parsenodes.h.html#LN927"><span class='Ref_to_EnumConst'>RTE_VALUES</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Estimate number of rows the values list will return. We know this 
     * precisely based on the list length (well, barring set-returning 
     * functions in list items, but that's a refinement not catered for 
     * anywhere else either). 
     */ 
</span>    <a href="costsize.c.html#LN4700"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN564"><span class='Ref_to_Member'>tuples</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4702"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN996"><span class='Ref_to_Member'>values_lists</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Now estimate number of output rows, etc */ 
</span>    <a href="../../../include/optimizer/cost.h.html#LN166"><span class='Ref_to_Proto'>set_baserel_size_estimates</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4700"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4700"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end set_values_size_estimates &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * set_cte_size_estimates 
 *      Set the size estimates for a base relation that is a CTE reference. 
 * 
 * The rel's targetlist and restrictinfo list must have been constructed 
 * already, and we need an estimate of the number of rows returned by the CTE 
 * (if a regular CTE) or the non-recursive term (if a self-reference). 
 * 
 * We set the same fields as set_baserel_size_estimates. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN4732"></a><span class='Declare_Function'>set_cte_size_estimates</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, </span><span class='Keyword'>double </span><span class='Declare_Parameter'>cte_rows</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4734"></a>    <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Should only be applied to base relations that are CTE references */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN4732"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN4734"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/relation.h.html#LN324"><span class='Ref_to_Macro'>planner_rt_fetch</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4732"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4732"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN4734"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN936"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/parsenodes.h.html#LN928"><span class='Ref_to_EnumConst'>RTE_CTE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN4734"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1003"><span class='Ref_to_Member'>self_reference</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * In a self-reference, arbitrarily assume the average worktable size 
         * is about 10 times the nonrecursive term's size. 
         */ 
</span>        <a href="costsize.c.html#LN4732"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN564"><span class='Ref_to_Member'>tuples</span></a> <span class='Operator'>= </span><span class='Number'>10</span> <span class='Operator'>* </span><a href="costsize.c.html#LN4732"><span class='Ref_to_Parameter'>cte_rows</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* Otherwise just believe the CTE's rowcount estimate */ 
</span>        <a href="costsize.c.html#LN4732"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN564"><span class='Ref_to_Member'>tuples</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN4732"><span class='Ref_to_Parameter'>cte_rows</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Now estimate number of output rows, etc */ 
</span>    <a href="../../../include/optimizer/cost.h.html#LN166"><span class='Ref_to_Proto'>set_baserel_size_estimates</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4732"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4732"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end set_cte_size_estimates &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * set_namedtuplestore_size_estimates 
 *      Set the size estimates for a base relation that is a tuplestore reference. 
 * 
 * The rel's targetlist and restrictinfo list must have been constructed 
 * already. 
 * 
 * We set the same fields as set_baserel_size_estimates. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN4769"></a><span class='Declare_Function'>set_namedtuplestore_size_estimates</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4771"></a>    <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Should only be applied to base relations that are tuplestore references */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN4769"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN4771"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/relation.h.html#LN324"><span class='Ref_to_Macro'>planner_rt_fetch</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4769"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4769"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN4771"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN936"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/parsenodes.h.html#LN929"><span class='Ref_to_EnumConst'>RTE_NAMEDTUPLESTORE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Use the estimate provided by the code which is generating the named 
     * tuplestore.  In some cases, the actual number might be available; in 
     * others the same plan will be re-used, so a "typical" value might be 
     * estimated and used. 
     */ 
</span>    <a href="costsize.c.html#LN4769"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN564"><span class='Ref_to_Member'>tuples</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN4771"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1017"><span class='Ref_to_Member'>enrtuples</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN4769"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN564"><span class='Ref_to_Member'>tuples</span></a> <span class='Operator'>&LT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="costsize.c.html#LN4769"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN564"><span class='Ref_to_Member'>tuples</span></a> <span class='Operator'>= </span><span class='Number'>1000</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Now estimate number of output rows, etc */ 
</span>    <a href="../../../include/optimizer/cost.h.html#LN166"><span class='Ref_to_Proto'>set_baserel_size_estimates</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4769"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4769"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end set_namedtuplestore_size_estimates &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * set_foreign_size_estimates 
 *      Set the size estimates for a base relation that is a foreign table. 
 * 
 * There is not a whole lot that we can do here; the foreign-data wrapper 
 * is responsible for producing useful estimates.  We can do a decent job 
 * of estimating baserestrictcost, so we set that, and we also set up width 
 * using what will be purely datatype-driven estimates from the targetlist. 
 * There is no way to do anything sane with the rows value, so we just put 
 * a default estimate and hope that the wrapper can improve on it.  The 
 * wrapper's GetForeignRelSize function will be called momentarily. 
 * 
 * The rel's targetlist and restrictinfo list must have been constructed 
 * already. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN4808"></a><span class='Declare_Function'>set_foreign_size_estimates</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* Should only be applied to base relations */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN4808"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN4808"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><span class='Number'>1000</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* entirely bogus default estimate */ 
</span> 
    <a href="../../../include/optimizer/cost.h.html#LN157"><span class='Ref_to_Proto'>cost_qual_eval</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="costsize.c.html#LN4808"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN585"><span class='Ref_to_Member'>baserestrictcost</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4808"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN583"><span class='Ref_to_Member'>baserestrictinfo</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4808"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN161"><span class='Ref_to_Proto'>set_rel_width</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4808"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4808"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * set_rel_width 
 *      Set the estimated output width of a base relation. 
 * 
 * The estimated output width is the sum of the per-attribute width estimates 
 * for the actually-referenced columns, plus any PHVs or other expressions 
 * that have to be calculated at this relation.  This is the amount of data 
 * we'd need to pass upwards in case of a sort, hash, etc. 
 * 
 * This function also sets reltarget-&GT;cost, so it's a bit misnamed now. 
 * 
 * NB: this works best on plain relations because it prefers to look at 
 * real Vars.  For subqueries, set_subquery_size_estimates will already have 
 * copied up whatever per-column estimates were made within the subquery, 
 * and for other types of rels there isn't much we can do anyway.  We fall 
 * back on (fairly stupid) datatype-based width estimates if we can't get 
 * any better number. 
 * 
 * The per-attribute width estimates are cached for possible re-use while 
 * building join relations or post-scan/join pathtargets. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN4843"></a><span class='Declare_Function'>set_rel_width</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN4845"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>reloid</span> <span class='Operator'>= </span><a href="../../../include/nodes/relation.h.html#LN324"><span class='Ref_to_Macro'>planner_rt_fetch</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4843"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4843"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>relid<span class='Delimiter'>; 
</span><a name="LN4846"></a>    <a href="../../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Local'>tuple_width</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN4847"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>have_wholerow_var</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN4848"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Vars are assumed to have cost zero, but other exprs do not */ 
</span>    <a href="costsize.c.html#LN4843"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN535"><span class='Ref_to_Member'>reltarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN884"><span class='Ref_to_Member'>cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN4843"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN535"><span class='Ref_to_Member'>reltarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN884"><span class='Ref_to_Member'>cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4848"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4843"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN535"><span class='Ref_to_Member'>reltarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN882"><span class='Ref_to_Member'>exprs</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN4856"></a>        <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>node</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4848"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Ordinarily, a Var in a rel's targetlist must belong to that rel; 
         * but there are corner cases involving LATERAL references where that 
         * isn't so.  If the Var has the wrong varno, fall through to the 
         * generic case (it doesn't seem worth the trouble to be any smarter). 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4856"><span class='Ref_To_Local'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>            <span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN4856"><span class='Ref_To_Local'>node</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>varno <span class='Operator'>== </span><a href="costsize.c.html#LN4843"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span><a name="LN4867"></a>            <a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>var</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN4856"><span class='Ref_To_Local'>node</span></a><span class='Delimiter'>; 
</span><a name="LN4868"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>ndx</span><span class='Delimiter'>; 
</span><a name="LN4869"></a>            <a href="../../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Local'>item_width</span><span class='Delimiter'>; 
</span> 
            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN4867"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN167"><span class='Ref_to_Member'>varattno</span></a> <span class='Operator'>&GT;= </span><a href="costsize.c.html#LN4843"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN555"><span class='Ref_to_Member'>min_attr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN4867"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN167"><span class='Ref_to_Member'>varattno</span></a> <span class='Operator'>&LT;= </span><a href="costsize.c.html#LN4843"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN556"><span class='Ref_to_Member'>max_attr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="costsize.c.html#LN4868"><span class='Ref_To_Local'>ndx</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN4867"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN167"><span class='Ref_to_Member'>varattno</span></a> <span class='Operator'>- </span><a href="costsize.c.html#LN4843"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN555"><span class='Ref_to_Member'>min_attr</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * If it's a whole-row Var, we'll deal with it below after we have 
             * already cached as many attr widths as possible. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN4867"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN167"><span class='Ref_to_Member'>varattno</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="costsize.c.html#LN4847"><span class='Ref_To_Local'>have_wholerow_var</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Control'>continue</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * The width may have been cached already (especially if it's a 
             * subquery), so don't duplicate effort. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN4843"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN558"><span class='Ref_to_Member'>attr_widths</span></a><span class='Delimiter'>[</span><a href="costsize.c.html#LN4868"><span class='Ref_To_Local'>ndx</span></a><span class='Delimiter'>] </span><span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="costsize.c.html#LN4846"><span class='Ref_To_Local'>tuple_width</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN4843"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN558"><span class='Ref_to_Member'>attr_widths</span></a><span class='Delimiter'>[</span><a href="costsize.c.html#LN4868"><span class='Ref_To_Local'>ndx</span></a><span class='Delimiter'>]; 
</span>                <span class='Control'>continue</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* Try to get column width from statistics */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN4845"><span class='Ref_To_Local'>reloid</span></a> <span class='Operator'>!= </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a> <span class='Operator'>&& </span><a href="costsize.c.html#LN4867"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN167"><span class='Ref_to_Member'>varattno</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="costsize.c.html#LN4869"><span class='Ref_To_Local'>item_width</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN171"><span class='Ref_to_Proto'>get_attavgwidth</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4845"><span class='Ref_To_Local'>reloid</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4867"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN167"><span class='Ref_to_Member'>varattno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN4869"><span class='Ref_To_Local'>item_width</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <a href="costsize.c.html#LN4843"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN558"><span class='Ref_to_Member'>attr_widths</span></a><span class='Delimiter'>[</span><a href="costsize.c.html#LN4868"><span class='Ref_To_Local'>ndx</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="costsize.c.html#LN4869"><span class='Ref_To_Local'>item_width</span></a><span class='Delimiter'>; 
</span>                    <a href="costsize.c.html#LN4846"><span class='Ref_To_Local'>tuple_width</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN4869"><span class='Ref_To_Local'>item_width</span></a><span class='Delimiter'>; 
</span>                    <span class='Control'>continue</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Not a plain relation, or can't find statistics for it. Estimate 
             * using just the type info. 
             */ 
</span>            <a href="costsize.c.html#LN4869"><span class='Ref_To_Local'>item_width</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN170"><span class='Ref_to_Proto'>get_typavgwidth</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4867"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN169"><span class='Ref_to_Member'>vartype</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4867"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN170"><span class='Ref_to_Member'>vartypmod</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN4869"><span class='Ref_To_Local'>item_width</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="costsize.c.html#LN4843"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN558"><span class='Ref_to_Member'>attr_widths</span></a><span class='Delimiter'>[</span><a href="costsize.c.html#LN4868"><span class='Ref_To_Local'>ndx</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="costsize.c.html#LN4869"><span class='Ref_To_Local'>item_width</span></a><span class='Delimiter'>; 
</span>            <a href="costsize.c.html#LN4846"><span class='Ref_To_Local'>tuple_width</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN4869"><span class='Ref_To_Local'>item_width</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if IsA(node,Var)&&((Var*... &raquo; </span> 
        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4856"><span class='Ref_To_Local'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1846"><span class='Ref_to_Struct'>PlaceHolderVar</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * We will need to evaluate the PHV's contained expression while 
             * scanning this rel, so be sure to include it in reltarget-&GT;cost. 
             */ 
</span><a name="LN4923"></a>            <a href="../../../include/nodes/relation.h.html#LN1846"><span class='Ref_to_Struct'>PlaceHolderVar</span></a> <span class='Operator'>*</span><span class='Declare_Local'>phv</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1846"><span class='Ref_to_Struct'>PlaceHolderVar</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN4856"><span class='Ref_To_Local'>node</span></a><span class='Delimiter'>; 
</span><a name="LN4924"></a>            <a href="../../../include/nodes/relation.h.html#LN2057"><span class='Ref_to_Struct'>PlaceHolderInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>phinfo</span> <span class='Operator'>= </span><a href="../../../include/optimizer/placeholder.h.html#LN21"><span class='Ref_to_Proto'>find_placeholder_info</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4843"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4923"><span class='Ref_To_Local'>phv</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN4925"></a>            <a href="../../../include/nodes/relation.h.html#LN42"><span class='Ref_to_Struct'>QualCost</span></a>    <span class='Declare_Local'>cost</span><span class='Delimiter'>; 
</span> 
            <a href="costsize.c.html#LN4846"><span class='Ref_To_Local'>tuple_width</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN4924"><span class='Ref_To_Local'>phinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2066"><span class='Ref_to_Member'>ph_width</span></a><span class='Delimiter'>; 
</span>            <a href="../../../include/optimizer/cost.h.html#LN158"><span class='Ref_to_Proto'>cost_qual_eval_node</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="costsize.c.html#LN4925"><span class='Ref_To_Local'>cost</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN4923"><span class='Ref_To_Local'>phv</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1849"><span class='Ref_to_Member'>phexpr</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4843"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="costsize.c.html#LN4843"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN535"><span class='Ref_to_Member'>reltarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN884"><span class='Ref_to_Member'>cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN4925"><span class='Ref_To_Local'>cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a><span class='Delimiter'>; 
</span>            <a href="costsize.c.html#LN4843"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN535"><span class='Ref_to_Member'>reltarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN884"><span class='Ref_to_Member'>cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN4925"><span class='Ref_To_Local'>cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * We could be looking at an expression pulled up from a subquery, 
             * or a ROW() representing a whole-row child Var, etc.  Do what we 
             * can using the expression type information. 
             */ 
</span><a name="LN4939"></a>            <a href="../../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Local'>item_width</span><span class='Delimiter'>; 
</span><a name="LN4940"></a>            <a href="../../../include/nodes/relation.h.html#LN42"><span class='Ref_to_Struct'>QualCost</span></a>    <span class='Declare_Local'>cost</span><span class='Delimiter'>; 
</span> 
            <a href="costsize.c.html#LN4939"><span class='Ref_To_Local'>item_width</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN170"><span class='Ref_to_Proto'>get_typavgwidth</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4856"><span class='Ref_To_Local'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodeFuncs.h.html#LN32"><span class='Ref_to_Proto'>exprTypmod</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4856"><span class='Ref_To_Local'>node</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN4939"><span class='Ref_To_Local'>item_width</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="costsize.c.html#LN4846"><span class='Ref_To_Local'>tuple_width</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN4939"><span class='Ref_To_Local'>item_width</span></a><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* Not entirely clear if we need to account for cost, but do so */ 
</span>            <a href="../../../include/optimizer/cost.h.html#LN158"><span class='Ref_to_Proto'>cost_qual_eval_node</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="costsize.c.html#LN4940"><span class='Ref_To_Local'>cost</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4856"><span class='Ref_To_Local'>node</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN4843"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="costsize.c.html#LN4843"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN535"><span class='Ref_to_Member'>reltarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN884"><span class='Ref_to_Member'>cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN4940"><span class='Ref_To_Local'>cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a><span class='Delimiter'>; 
</span>            <a href="costsize.c.html#LN4843"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN535"><span class='Ref_to_Member'>reltarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN884"><span class='Ref_to_Member'>cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN4940"><span class='Ref_To_Local'>cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we have a whole-row reference, estimate its width as the sum of 
     * per-column widths plus heap tuple header overhead. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN4847"><span class='Ref_To_Local'>have_wholerow_var</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN4958"></a>        <a href="../../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Local'>wholerow_width</span> <span class='Operator'>= </span><a href="../../../include/c.h.html#LN587"><span class='Ref_to_Macro'>MAXALIGN</span></a><span class='Parentheses'>(</span><a href="../../../include/access/htup_details.h.html#LN169"><span class='Ref_to_Const'>SizeofHeapTupleHeader</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN4845"><span class='Ref_To_Local'>reloid</span></a> <span class='Operator'>!= </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Real relation, so estimate true tuple width */ 
</span>            <a href="costsize.c.html#LN4958"><span class='Ref_To_Local'>wholerow_width</span></a> <span class='Operator'>+= </span><a href="../../../include/optimizer/plancat.h.html#LN35"><span class='Ref_to_Proto'>get_relation_data_width</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN4845"><span class='Ref_To_Local'>reloid</span></a><span class='Delimiter'>, 
</span>                                           <a href="costsize.c.html#LN4843"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN558"><span class='Ref_to_Member'>attr_widths</span></a> <span class='Operator'>- </span><a href="costsize.c.html#LN4843"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN555"><span class='Ref_to_Member'>min_attr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Do what we can with info for a phony rel */ 
</span><a name="LN4969"></a>            <a href="../../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a>  <span class='Declare_Local'>i</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN4969"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="costsize.c.html#LN4969"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>&LT;= </span><a href="costsize.c.html#LN4843"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN556"><span class='Ref_to_Member'>max_attr</span></a><span class='Delimiter'>; </span><a href="costsize.c.html#LN4969"><span class='Ref_To_Local'>i</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>                <a href="costsize.c.html#LN4958"><span class='Ref_To_Local'>wholerow_width</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN4843"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN558"><span class='Ref_to_Member'>attr_widths</span></a><span class='Delimiter'>[</span><a href="costsize.c.html#LN4969"><span class='Ref_To_Local'>i</span></a> <span class='Operator'>- </span><a href="costsize.c.html#LN4843"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN555"><span class='Ref_to_Member'>min_attr</span></a><span class='Delimiter'>]; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="costsize.c.html#LN4843"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN558"><span class='Ref_to_Member'>attr_widths</span></a><span class='Delimiter'>[</span><span class='Number'>0</span> <span class='Operator'>- </span><a href="costsize.c.html#LN4843"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN555"><span class='Ref_to_Member'>min_attr</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="costsize.c.html#LN4958"><span class='Ref_To_Local'>wholerow_width</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Include the whole-row Var as part of the output tuple.  Yes, that 
         * really is what happens at runtime. 
         */ 
</span>        <a href="costsize.c.html#LN4846"><span class='Ref_To_Local'>tuple_width</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN4958"><span class='Ref_To_Local'>wholerow_width</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if have_wholerow_var &raquo; </span> 
 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN4846"><span class='Ref_To_Local'>tuple_width</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN4843"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN535"><span class='Ref_to_Member'>reltarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN885"><span class='Ref_to_Member'>width</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN4846"><span class='Ref_To_Local'>tuple_width</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end set_rel_width &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * set_pathtarget_cost_width 
 *      Set the estimated eval cost and output width of a PathTarget tlist. 
 * 
 * As a notational convenience, returns the same PathTarget pointer passed in. 
 * 
 * Most, though not quite all, uses of this function occur after we've run 
 * set_rel_width() for base relations; so we can usually obtain cached width 
 * estimates for Vars.  If we can't, fall back on datatype-based width 
 * estimates.  Present early-planning uses of PathTargets don't need accurate 
 * widths badly enough to justify going to the catalogs for better data. 
 */ 
</span><a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>* 
</span><a name="LN5001"></a><span class='Declare_Function'>set_pathtarget_cost_width</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN879"><span class='Ref_to_Struct'>PathTarget</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>target</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN5003"></a>    <a href="../../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Local'>tuple_width</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN5004"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Vars are assumed to have cost zero, but other exprs do not */ 
</span>    <a href="costsize.c.html#LN5001"><span class='Ref_to_Parameter'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN884"><span class='Ref_to_Member'>cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN5001"><span class='Ref_to_Parameter'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN884"><span class='Ref_to_Member'>cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN5004"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN5001"><span class='Ref_to_Parameter'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN882"><span class='Ref_to_Member'>exprs</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN5012"></a>        <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>node</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN5004"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN5012"><span class='Ref_To_Local'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN5016"></a>            <a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>var</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN5012"><span class='Ref_To_Local'>node</span></a><span class='Delimiter'>; 
</span><a name="LN5017"></a>            <a href="../../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Local'>item_width</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* We should not see any upper-level Vars here */ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN5016"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN172"><span class='Ref_to_Member'>varlevelsup</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Try to get data from RelOptInfo cache */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN5016"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN165"><span class='Ref_to_Member'>varno</span></a> <span class='Operator'>&LT; </span><a href="costsize.c.html#LN5001"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN179"><span class='Ref_to_Member'>simple_rel_array_size</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN5025"></a>                <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rel</span> <span class='Operator'>= </span><a href="costsize.c.html#LN5001"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN178"><span class='Ref_to_Member'>simple_rel_array</span></a><span class='Delimiter'>[</span><a href="costsize.c.html#LN5016"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN165"><span class='Ref_to_Member'>varno</span></a><span class='Delimiter'>]; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN5025"><span class='Ref_To_Local'>rel</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL </span><span class='Operator'>&& 
</span>                    <a href="costsize.c.html#LN5016"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN167"><span class='Ref_to_Member'>varattno</span></a> <span class='Operator'>&GT;= </span><a href="costsize.c.html#LN5025"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN555"><span class='Ref_to_Member'>min_attr</span></a> <span class='Operator'>&& 
</span>                    <a href="costsize.c.html#LN5016"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN167"><span class='Ref_to_Member'>varattno</span></a> <span class='Operator'>&LT;= </span><a href="costsize.c.html#LN5025"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN556"><span class='Ref_to_Member'>max_attr</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span><a name="LN5031"></a>                    <span class='Keyword'>int</span>         <span class='Declare_Local'>ndx</span> <span class='Operator'>= </span><a href="costsize.c.html#LN5016"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN167"><span class='Ref_to_Member'>varattno</span></a> <span class='Operator'>- </span><a href="costsize.c.html#LN5025"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN555"><span class='Ref_to_Member'>min_attr</span></a><span class='Delimiter'>; 
</span> 
                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN5025"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN558"><span class='Ref_to_Member'>attr_widths</span></a><span class='Delimiter'>[</span><a href="costsize.c.html#LN5031"><span class='Ref_To_Local'>ndx</span></a><span class='Delimiter'>] </span><span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <a href="costsize.c.html#LN5003"><span class='Ref_To_Local'>tuple_width</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN5025"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN558"><span class='Ref_to_Member'>attr_widths</span></a><span class='Delimiter'>[</span><a href="costsize.c.html#LN5031"><span class='Ref_To_Local'>ndx</span></a><span class='Delimiter'>]; 
</span>                        <span class='Control'>continue</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * No cached data available, so estimate using just the type info. 
             */ 
</span>            <a href="costsize.c.html#LN5017"><span class='Ref_To_Local'>item_width</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN170"><span class='Ref_to_Proto'>get_typavgwidth</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN5016"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN169"><span class='Ref_to_Member'>vartype</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN5016"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN170"><span class='Ref_to_Member'>vartypmod</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN5017"><span class='Ref_To_Local'>item_width</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="costsize.c.html#LN5003"><span class='Ref_To_Local'>tuple_width</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN5017"><span class='Ref_To_Local'>item_width</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if IsA(node,Var) &raquo; </span> 
        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Handle general expressions using type info. 
             */ 
</span><a name="LN5053"></a>            <a href="../../../include/c.h.html#LN255"><span class='Ref_to_Typedef'>int32</span></a>       <span class='Declare_Local'>item_width</span><span class='Delimiter'>; 
</span><a name="LN5054"></a>            <a href="../../../include/nodes/relation.h.html#LN42"><span class='Ref_to_Struct'>QualCost</span></a>    <span class='Declare_Local'>cost</span><span class='Delimiter'>; 
</span> 
            <a href="costsize.c.html#LN5053"><span class='Ref_To_Local'>item_width</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN170"><span class='Ref_to_Proto'>get_typavgwidth</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN5012"><span class='Ref_To_Local'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodeFuncs.h.html#LN32"><span class='Ref_to_Proto'>exprTypmod</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN5012"><span class='Ref_To_Local'>node</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN5053"><span class='Ref_To_Local'>item_width</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="costsize.c.html#LN5003"><span class='Ref_To_Local'>tuple_width</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN5053"><span class='Ref_To_Local'>item_width</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Account for cost, too */ 
</span>            <a href="../../../include/optimizer/cost.h.html#LN158"><span class='Ref_to_Proto'>cost_qual_eval_node</span></a><span class='Parentheses'>(</span><span class='Operator'>&</span><a href="costsize.c.html#LN5054"><span class='Ref_To_Local'>cost</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN5012"><span class='Ref_To_Local'>node</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN5001"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="costsize.c.html#LN5001"><span class='Ref_to_Parameter'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN884"><span class='Ref_to_Member'>cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN5054"><span class='Ref_To_Local'>cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN44"><span class='Ref_to_Member'>startup</span></a><span class='Delimiter'>; 
</span>            <a href="costsize.c.html#LN5001"><span class='Ref_to_Parameter'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN884"><span class='Ref_to_Member'>cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN5054"><span class='Ref_To_Local'>cost</span></a><span class='Operator'>.</span><a href="../../../include/nodes/relation.h.html#LN45"><span class='Ref_to_Member'>per_tuple</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="costsize.c.html#LN5003"><span class='Ref_To_Local'>tuple_width</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="costsize.c.html#LN5001"><span class='Ref_to_Parameter'>target</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN885"><span class='Ref_to_Member'>width</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN5003"><span class='Ref_To_Local'>tuple_width</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="costsize.c.html#LN5001"><span class='Ref_to_Parameter'>target</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end set_pathtarget_cost_width &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * relation_byte_size 
 *    Estimate the storage space in bytes for a given number of tuples 
 *    of a given width (size in bytes). 
 */ 
</span><span class='Keyword'>static double 
</span><a name="LN5079"></a><span class='Declare_Function'>relation_byte_size</span><span class='Parentheses'>(</span><span class='Keyword'>double </span><span class='Declare_Parameter'>tuples</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>width</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <a href="costsize.c.html#LN5079"><span class='Ref_to_Parameter'>tuples</span></a> <span class='Operator'>* </span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN587"><span class='Ref_to_Macro'>MAXALIGN</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN5079"><span class='Ref_to_Parameter'>width</span></a><span class='Parentheses'>) </span><span class='Operator'>+ </span><a href="../../../include/c.h.html#LN587"><span class='Ref_to_Macro'>MAXALIGN</span></a><span class='Parentheses'>(</span><a href="../../../include/access/htup_details.h.html#LN169"><span class='Ref_to_Const'>SizeofHeapTupleHeader</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * page_size 
 *    Returns an estimate of the number of pages covered by a given 
 *    number of tuples of a given width (size in bytes). 
 */ 
</span><span class='Keyword'>static double 
</span><a name="LN5090"></a><span class='Declare_Function'>page_size</span><span class='Parentheses'>(</span><span class='Keyword'>double </span><span class='Declare_Parameter'>tuples</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>width</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> ceil<span class='Parentheses'>(</span><a href="costsize.c.html#LN162"><span class='Ref_to_Proto'>relation_byte_size</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN5090"><span class='Ref_to_Parameter'>tuples</span></a><span class='Delimiter'>, </span><a href="costsize.c.html#LN5090"><span class='Ref_to_Parameter'>width</span></a><span class='Parentheses'>) </span><span class='Operator'>/ </span>BLCKSZ<span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Estimate the fraction of the work that each worker will do given the 
 * number of workers budgeted for the path. 
 */ 
</span><span class='Keyword'>static double 
</span><a name="LN5100"></a><span class='Declare_Function'>get_parallel_divisor</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>path</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN5102"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>parallel_divisor</span> <span class='Operator'>= </span><a href="costsize.c.html#LN5100"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN959"><span class='Ref_to_Member'>parallel_workers</span></a><span class='Delimiter'>; 
</span><a name="LN5103"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>leader_contribution</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Early experience with parallel query suggests that when there is only 
     * one worker, the leader often makes a very substantial contribution to 
     * executing the parallel portion of the plan, but as more workers are 
     * added, it does less and less, because it's busy reading tuples from the 
     * workers and doing whatever non-parallel post-processing is needed.  By 
     * the time we reach 4 workers, the leader no longer makes a meaningful 
     * contribution.  Thus, for now, estimate that the leader spends 30% of 
     * its time servicing each worker, and the remainder executing the 
     * parallel plan. 
     */ 
</span>    <a href="costsize.c.html#LN5103"><span class='Ref_To_Local'>leader_contribution</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>- </span><span class='Parentheses'>(</span><span class='Number'>0</span><span class='Operator'>.</span><span class='Number'>3</span> <span class='Operator'>* </span><a href="costsize.c.html#LN5100"><span class='Ref_to_Parameter'>path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN959"><span class='Ref_to_Member'>parallel_workers</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN5103"><span class='Ref_To_Local'>leader_contribution</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="costsize.c.html#LN5102"><span class='Ref_To_Local'>parallel_divisor</span></a> <span class='Operator'>+= </span><a href="costsize.c.html#LN5103"><span class='Ref_To_Local'>leader_contribution</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="costsize.c.html#LN5102"><span class='Ref_To_Local'>parallel_divisor</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end get_parallel_divisor &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * compute_bitmap_pages 
 * 
 * compute number of pages fetched from heap in bitmap heap scan. 
 */ 
</span><span class='Keyword'>double 
</span><a name="LN5129"></a><span class='Declare_Function'>compute_bitmap_pages</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>baserel</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>bitmapqual</span><span class='Delimiter'>, 
</span><a name="LN5130"></a>                     <span class='Keyword'>int </span><span class='Declare_Parameter'>loop_count</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>cost</span><span class='Delimiter'>, </span><span class='Keyword'>double </span><span class='Operator'>*</span><span class='Declare_Parameter'>tuple</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN5132"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>indexTotalCost</span><span class='Delimiter'>; 
</span><a name="LN5133"></a>    <a href="../../../include/nodes/nodes.h.html#LN637"><span class='Ref_to_Typedef'>Selectivity</span></a> <span class='Declare_Local'>indexSelectivity</span><span class='Delimiter'>; 
</span><a name="LN5134"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>T</span><span class='Delimiter'>; 
</span><a name="LN5135"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>pages_fetched</span><span class='Delimiter'>; 
</span><a name="LN5136"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>tuples_fetched</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Fetch total cost of obtaining the bitmap, as well as its total 
     * selectivity. 
     */ 
</span>    <a href="../../../include/optimizer/cost.h.html#LN85"><span class='Ref_to_Proto'>cost_bitmap_tree_node</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN5129"><span class='Ref_to_Parameter'>bitmapqual</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="costsize.c.html#LN5132"><span class='Ref_To_Local'>indexTotalCost</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="costsize.c.html#LN5133"><span class='Ref_To_Local'>indexSelectivity</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Estimate number of main-table pages fetched. 
     */ 
</span>    <a href="costsize.c.html#LN5136"><span class='Ref_To_Local'>tuples_fetched</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/cost.h.html#LN71"><span class='Ref_to_Proto'>clamp_row_est</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN5133"><span class='Ref_To_Local'>indexSelectivity</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN5129"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN564"><span class='Ref_to_Member'>tuples</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="costsize.c.html#LN5134"><span class='Ref_To_Local'>T</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="costsize.c.html#LN5129"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN563"><span class='Ref_to_Member'>pages</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Parentheses'>) </span><span class='Operator'>? </span><span class='Parentheses'>(</span><span class='Keyword'>double</span><span class='Parentheses'>) </span><a href="costsize.c.html#LN5129"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN563"><span class='Ref_to_Member'>pages</span></a> <span class='Operator'>: </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN5130"><span class='Ref_to_Parameter'>loop_count</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * For repeated bitmap scans, scale up the number of tuples fetched in 
         * the Mackert and Lohman formula by the number of scans, so that we 
         * estimate the number of pages fetched by all the scans. Then 
         * pro-rate for one scan. 
         */ 
</span>        <a href="costsize.c.html#LN5135"><span class='Ref_To_Local'>pages_fetched</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/cost.h.html#LN72"><span class='Ref_to_Proto'>index_pages_fetched</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN5136"><span class='Ref_To_Local'>tuples_fetched</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN5130"><span class='Ref_to_Parameter'>loop_count</span></a><span class='Delimiter'>, 
</span>                                            <a href="costsize.c.html#LN5129"><span class='Ref_to_Parameter'>baserel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN563"><span class='Ref_to_Member'>pages</span></a><span class='Delimiter'>, 
</span>                                            <a href="costsize.c.html#LN876"><span class='Ref_to_Func'>get_indexpath_pages</span></a><span class='Parentheses'>(</span><a href="costsize.c.html#LN5129"><span class='Ref_to_Parameter'>bitmapqual</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                            <a href="costsize.c.html#LN5129"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="costsize.c.html#LN5135"><span class='Ref_To_Local'>pages_fetched</span></a> <span class='Operator'>/= </span><a href="costsize.c.html#LN5130"><span class='Ref_to_Parameter'>loop_count</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * For a single scan, the number of heap pages that need to be fetched 
         * is the same as the Mackert and Lohman formula for the case T &LT;= b 
         * (ie, no re-reads needed). 
         */ 
</span>        <a href="costsize.c.html#LN5135"><span class='Ref_To_Local'>pages_fetched</span></a> <span class='Operator'>= 
</span>            <span class='Parentheses'>(</span><span class='Number'>2</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>* </span><a href="costsize.c.html#LN5134"><span class='Ref_To_Local'>T</span></a> <span class='Operator'>* </span><a href="costsize.c.html#LN5136"><span class='Ref_To_Local'>tuples_fetched</span></a><span class='Parentheses'>) </span><span class='Operator'>/ </span><span class='Parentheses'>(</span><span class='Number'>2</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>* </span><a href="costsize.c.html#LN5134"><span class='Ref_To_Local'>T</span></a> <span class='Operator'>+ </span><a href="costsize.c.html#LN5136"><span class='Ref_To_Local'>tuples_fetched</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN5135"><span class='Ref_To_Local'>pages_fetched</span></a> <span class='Operator'>&GT;= </span><a href="costsize.c.html#LN5134"><span class='Ref_To_Local'>T</span></a><span class='Parentheses'>) 
</span>        <a href="costsize.c.html#LN5135"><span class='Ref_To_Local'>pages_fetched</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN5134"><span class='Ref_To_Local'>T</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="costsize.c.html#LN5135"><span class='Ref_To_Local'>pages_fetched</span></a> <span class='Operator'>= </span>ceil<span class='Parentheses'>(</span><a href="costsize.c.html#LN5135"><span class='Ref_To_Local'>pages_fetched</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN5130"><span class='Ref_to_Parameter'>cost</span></a><span class='Parentheses'>) 
</span>        <span class='Operator'>*</span><a href="costsize.c.html#LN5130"><span class='Ref_to_Parameter'>cost</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN5132"><span class='Ref_To_Local'>indexTotalCost</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="costsize.c.html#LN5130"><span class='Ref_to_Parameter'>tuple</span></a><span class='Parentheses'>) 
</span>        <span class='Operator'>*</span><a href="costsize.c.html#LN5130"><span class='Ref_to_Parameter'>tuple</span></a> <span class='Operator'>= </span><a href="costsize.c.html#LN5136"><span class='Ref_To_Local'>tuples_fetched</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="costsize.c.html#LN5135"><span class='Ref_To_Local'>pages_fetched</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end compute_bitmap_pages &raquo; </span> 
</pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>