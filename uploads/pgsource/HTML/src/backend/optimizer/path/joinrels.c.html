<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\optimizer\path\joinrels.c</title>
<LINK REL=StyleSheet HREF="../../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\optimizer\path\joinrels.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:42 2017
</td></tr>
<tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * joinrels.c 
 *    Routines to determine which relations should be joined 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * 
 * IDENTIFICATION 
 *    src/backend/optimizer/path/joinrels.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"optimizer/joininfo.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/pathnode.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/paths.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/memutils.h"</span> 
 
 
<a name="LN22"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>make_rels_by_clause_joins</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN23"></a>                          <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>old_rel</span><span class='Delimiter'>, 
</span><a name="LN24"></a>                          <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>other_rels</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN25"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>make_rels_by_clauseless_joins</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN26"></a>                              <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>old_rel</span><span class='Delimiter'>, 
</span><a name="LN27"></a>                              <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>other_rels</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN28"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>has_join_restriction</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN29"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>has_legal_joinclause</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN30"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>is_dummy_rel</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN31"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>mark_dummy_rel</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN32"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>restriction_is_constant_false</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>restrictlist</span><span class='Delimiter'>, 
</span><a name="LN33"></a>                              <span class='Keyword'>bool </span><span class='Declare_Parameter'>only_pushed_down</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN34"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>populate_joinrel_with_paths</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel1</span><span class='Delimiter'>, 
</span><a name="LN35"></a>                            <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel2</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>joinrel</span><span class='Delimiter'>, 
</span><a name="LN36"></a>                            <a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sjinfo</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>restrictlist</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * join_search_one_level 
 *    Consider ways to produce join relations containing exactly 'level' 
 *    jointree items.  (This is one step of the dynamic-programming method 
 *    embodied in standard_join_search.)  Join rel nodes for each feasible 
 *    combination of lower-level rels are created and returned in a list. 
 *    Implementation paths are created for each such joinrel, too. 
 * 
 * level: level of rels we want to make this time 
 * root-&GT;join_rel_level[j], 1 &LT;= j &LT; level, is a list of rels containing j items 
 * 
 * The result is returned in root-&GT;join_rel_level[level]. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN53"></a><span class='Declare_Function'>join_search_one_level</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>level</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN55"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>      <span class='Operator'>**</span><span class='Declare_Local'>joinrels</span> <span class='Operator'>= </span><a href="joinrels.c.html#LN53"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN224"><span class='Ref_to_Member'>join_rel_level</span></a><span class='Delimiter'>; 
</span><a name="LN56"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>r</span><span class='Delimiter'>; 
</span><a name="LN57"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>k</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="joinrels.c.html#LN55"><span class='Ref_To_Local'>joinrels</span></a><span class='Delimiter'>[</span><a href="joinrels.c.html#LN53"><span class='Ref_to_Parameter'>level</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Set join_cur_level so that new joinrels are added to proper list */ 
</span>    <a href="joinrels.c.html#LN53"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN225"><span class='Ref_to_Member'>join_cur_level</span></a> <span class='Operator'>= </span><a href="joinrels.c.html#LN53"><span class='Ref_to_Parameter'>level</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * First, consider left-sided and right-sided plans, in which rels of 
     * exactly level-1 member relations are joined against initial relations. 
     * We prefer to join using join clauses, but if we find a rel of level-1 
     * members that has no join clauses, we will generate Cartesian-product 
     * joins against all initial rels not already contained in it. 
     */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN56"><span class='Ref_To_Local'>r</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN55"><span class='Ref_To_Local'>joinrels</span></a><span class='Delimiter'>[</span><a href="joinrels.c.html#LN53"><span class='Ref_to_Parameter'>level</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN73"></a>        <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>old_rel</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN56"><span class='Ref_To_Local'>r</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN73"><span class='Ref_To_Local'>old_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN588"><span class='Ref_to_Member'>joininfo</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>|| </span><a href="joinrels.c.html#LN73"><span class='Ref_To_Local'>old_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN590"><span class='Ref_to_Member'>has_eclass_joins</span></a> <span class='Operator'>|| 
</span>            <a href="joinrels.c.html#LN28"><span class='Ref_to_Proto'>has_join_restriction</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN53"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN73"><span class='Ref_To_Local'>old_rel</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * There are join clauses or join order restrictions relevant to 
             * this rel, so consider joins between this rel and (only) those 
             * initial rels it is linked to by a clause or restriction. 
             * 
             * At level 2 this condition is symmetric, so there is no need to 
             * look at initial rels before this one in the list; we already 
             * considered such joins when we were at the earlier rel.  (The 
             * mirror-image joins are handled automatically by make_join_rel.) 
             * In later passes (level &GT; 2), we join rels of the previous level 
             * to each initial rel they don't already include but have a join 
             * clause or restriction with. 
             */ 
</span><a name="LN91"></a>            <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>other_rels</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN53"><span class='Ref_to_Parameter'>level</span></a> <span class='Operator'>== </span><span class='Number'>2</span><span class='Parentheses'>)</span>     <span class='Comment_Single_Line'>/* consider remaining initial rels */ 
</span>                <a href="joinrels.c.html#LN91"><span class='Ref_To_Local'>other_rels</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN56"><span class='Ref_To_Local'>r</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span>    <span class='Comment_Single_Line'>/* consider all initial rels */ 
</span>                <a href="joinrels.c.html#LN91"><span class='Ref_To_Local'>other_rels</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN55"><span class='Ref_To_Local'>joinrels</span></a><span class='Delimiter'>[</span><span class='Number'>1</span><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="joinrels.c.html#LN22"><span class='Ref_to_Proto'>make_rels_by_clause_joins</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN53"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                      <a href="joinrels.c.html#LN73"><span class='Ref_To_Local'>old_rel</span></a><span class='Delimiter'>, 
</span>                                      <a href="joinrels.c.html#LN91"><span class='Ref_To_Local'>other_rels</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if old_rel-&GT;joininfo!=NI... &raquo; </span> 
        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Oops, we have a relation that is not joined to any other 
             * relation, either directly or by join-order restrictions. 
             * Cartesian product time. 
             * 
             * We consider a cartesian product with each not-already-included 
             * initial rel, whether it has other join clauses or not.  At 
             * level 2, if there are two or more clauseless initial rels, we 
             * will redundantly consider joining them in both directions; but 
             * such cases aren't common enough to justify adding complexity to 
             * avoid the duplicated effort. 
             */ 
</span>            <a href="joinrels.c.html#LN25"><span class='Ref_to_Proto'>make_rels_by_clauseless_joins</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN53"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                          <a href="joinrels.c.html#LN73"><span class='Ref_To_Local'>old_rel</span></a><span class='Delimiter'>, 
</span>                                          <a href="../../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN55"><span class='Ref_To_Local'>joinrels</span></a><span class='Delimiter'>[</span><span class='Number'>1</span><span class='Delimiter'>]</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now, consider "bushy plans" in which relations of k initial rels are 
     * joined to relations of level-k initial rels, for 2 &LT;= k &LT;= level-2. 
     * 
     * We only consider bushy-plan joins for pairs of rels where there is a 
     * suitable join clause (or join order restriction), in order to avoid 
     * unreasonable growth of planning time. 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN57"><span class='Ref_To_Local'>k</span></a> <span class='Operator'>= </span><span class='Number'>2</span><span class='Delimiter'>;; </span><a href="joinrels.c.html#LN57"><span class='Ref_To_Local'>k</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN132"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>other_level</span> <span class='Operator'>= </span><a href="joinrels.c.html#LN53"><span class='Ref_to_Parameter'>level</span></a> <span class='Operator'>- </span><a href="joinrels.c.html#LN57"><span class='Ref_To_Local'>k</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Since make_join_rel(x, y) handles both x,y and y,x cases, we only 
         * need to go as far as the halfway point. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN57"><span class='Ref_To_Local'>k</span></a> <span class='Operator'>&GT; </span><a href="joinrels.c.html#LN132"><span class='Ref_To_Local'>other_level</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN56"><span class='Ref_To_Local'>r</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN55"><span class='Ref_To_Local'>joinrels</span></a><span class='Delimiter'>[</span><a href="joinrels.c.html#LN57"><span class='Ref_To_Local'>k</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN143"></a>            <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>old_rel</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN56"><span class='Ref_To_Local'>r</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN144"></a>            <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>other_rels</span><span class='Delimiter'>; 
</span><a name="LN145"></a>            <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>r2</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * We can ignore relations without join clauses here, unless they 
             * participate in join-order restrictions --- then we might have 
             * to force a bushy join plan. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN143"><span class='Ref_To_Local'>old_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN588"><span class='Ref_to_Member'>joininfo</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>&& !</span><a href="joinrels.c.html#LN143"><span class='Ref_To_Local'>old_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN590"><span class='Ref_to_Member'>has_eclass_joins</span></a> <span class='Operator'>&& 
</span>                <span class='Operator'>!</span><a href="joinrels.c.html#LN28"><span class='Ref_to_Proto'>has_join_restriction</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN53"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN143"><span class='Ref_To_Local'>old_rel</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN57"><span class='Ref_To_Local'>k</span></a> <span class='Operator'>== </span><a href="joinrels.c.html#LN132"><span class='Ref_To_Local'>other_level</span></a><span class='Parentheses'>) 
</span>                <a href="joinrels.c.html#LN144"><span class='Ref_To_Local'>other_rels</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN56"><span class='Ref_To_Local'>r</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* only consider remaining rels */ 
</span>            <span class='Control'>else</span> 
                <a href="joinrels.c.html#LN144"><span class='Ref_To_Local'>other_rels</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN55"><span class='Ref_To_Local'>joinrels</span></a><span class='Delimiter'>[</span><a href="joinrels.c.html#LN132"><span class='Ref_To_Local'>other_level</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="../../../include/nodes/pg_list.h.html#LN168"><span class='Ref_to_Macro'>for_each_cell</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN145"><span class='Ref_To_Local'>r2</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN144"><span class='Ref_To_Local'>other_rels</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN163"></a>                <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>new_rel</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN145"><span class='Ref_To_Local'>r2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN143"><span class='Ref_To_Local'>old_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN163"><span class='Ref_To_Local'>new_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* 
                     * OK, we can build a rel of the right level from this 
                     * pair of rels.  Do so if there is at least one relevant 
                     * join clause or join order restriction. 
                     */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/optimizer/joininfo.h.html#LN19"><span class='Ref_to_Proto'>have_relevant_joinclause</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN53"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN143"><span class='Ref_To_Local'>old_rel</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN163"><span class='Ref_To_Local'>new_rel</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>                        <a href="../../../include/optimizer/paths.h.html#LN109"><span class='Ref_to_Proto'>have_join_order_restriction</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN53"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN143"><span class='Ref_To_Local'>old_rel</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN163"><span class='Ref_To_Local'>new_rel</span></a><span class='Parentheses'>))</span> 
                    <span class='Delimiter'>{ 
</span>                        <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="../../../include/optimizer/paths.h.html#LN107"><span class='Ref_to_Proto'>make_join_rel</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN53"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN143"><span class='Ref_To_Local'>old_rel</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN163"><span class='Ref_To_Local'>new_rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for k=2;;k++ &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/*---------- 
     * Last-ditch effort: if we failed to find any usable joins so far, force 
     * a set of cartesian-product joins to be generated.  This handles the 
     * special case where all the available rels have join clauses but we 
     * cannot use any of those clauses yet.  This can only happen when we are 
     * considering a join sub-problem (a sub-joinlist) and all the rels in the 
     * sub-problem have only join clauses with rels outside the sub-problem. 
     * An example is 
     * 
     *      SELECT ... FROM a INNER JOIN b ON TRUE, c, d, ... 
     *      WHERE a.w = c.x and b.y = d.z; 
     * 
     * If the "a INNER JOIN b" sub-problem does not get flattened into the 
     * upper level, we must be willing to make a cartesian join of a and b; 
     * but the code above will not have done so, because it thought that both 
     * a and b have joinclauses.  We consider only left-sided and right-sided 
     * cartesian joins in this case (no bushy). 
     *---------- 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN55"><span class='Ref_To_Local'>joinrels</span></a><span class='Delimiter'>[</span><a href="joinrels.c.html#LN53"><span class='Ref_to_Parameter'>level</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * This loop is just like the first one, except we always call 
         * make_rels_by_clauseless_joins(). 
         */ 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN56"><span class='Ref_To_Local'>r</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN55"><span class='Ref_To_Local'>joinrels</span></a><span class='Delimiter'>[</span><a href="joinrels.c.html#LN53"><span class='Ref_to_Parameter'>level</span></a> <span class='Operator'>- </span><span class='Number'>1</span><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN209"></a>            <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>old_rel</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN56"><span class='Ref_To_Local'>r</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="joinrels.c.html#LN25"><span class='Ref_to_Proto'>make_rels_by_clauseless_joins</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN53"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                          <a href="joinrels.c.html#LN209"><span class='Ref_To_Local'>old_rel</span></a><span class='Delimiter'>, 
</span>                                          <a href="../../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN55"><span class='Ref_To_Local'>joinrels</span></a><span class='Delimiter'>[</span><span class='Number'>1</span><span class='Delimiter'>]</span><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/*---------- 
         * When special joins are involved, there may be no legal way 
         * to make an N-way join for some values of N.  For example consider 
         * 
         * SELECT ... FROM t1 WHERE 
         *   x IN (SELECT ... FROM t2,t3 WHERE ...) AND 
         *   y IN (SELECT ... FROM t4,t5 WHERE ...) 
         * 
         * We will flatten this query to a 5-way join problem, but there are 
         * no 4-way joins that join_is_legal() will consider legal.  We have 
         * to accept failure at level 4 and go on to discover a workable 
         * bushy plan at level 5. 
         * 
         * However, if there are no special joins and no lateral references 
         * then join_is_legal() should never fail, and so the following sanity 
         * check is useful. 
         *---------- 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN55"><span class='Ref_To_Local'>joinrels</span></a><span class='Delimiter'>[</span><a href="joinrels.c.html#LN53"><span class='Ref_to_Parameter'>level</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>&& 
</span>            <a href="joinrels.c.html#LN53"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN249"><span class='Ref_to_Member'>join_info_list</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>&& 
</span>            <span class='Operator'>!</span><a href="joinrels.c.html#LN53"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN299"><span class='Ref_to_Member'>hasLateralRTEs</span></a><span class='Parentheses'>) 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"failed to build any %d-way joins"</span><span class='Delimiter'>, </span><a href="joinrels.c.html#LN53"><span class='Ref_to_Parameter'>level</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if joinrels[level]==NIL &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end join_search_one_level &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * make_rels_by_clause_joins 
 *    Build joins between the given relation 'old_rel' and other relations 
 *    that participate in join clauses that 'old_rel' also participates in 
 *    (or participate in join-order restrictions with it). 
 *    The join rels are returned in root-&GT;join_rel_level[join_cur_level]. 
 * 
 * Note: at levels above 2 we will generate the same joined relation in 
 * multiple ways --- for example (a join b) join c is the same RelOptInfo as 
 * (b join c) join a, though the second case will add a different set of Paths 
 * to it.  This is the reason for using the join_rel_level mechanism, which 
 * automatically ensures that each new joinrel is only added to the list once. 
 * 
 * 'old_rel' is the relation entry for the relation to be joined 
 * 'other_rels': the first cell in a linked list containing the other 
 * rels to be considered for joining 
 * 
 * Currently, this is only used with initial rels in other_rels, but it 
 * will work for joining to joinrels too. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN262"></a><span class='Declare_Function'>make_rels_by_clause_joins</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN263"></a>                          <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>old_rel</span><span class='Delimiter'>, 
</span><a name="LN264"></a>                          <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>other_rels</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN266"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN168"><span class='Ref_to_Macro'>for_each_cell</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN266"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN264"><span class='Ref_to_Parameter'>other_rels</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN270"></a>        <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>other_rel</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN266"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN263"><span class='Ref_to_Parameter'>old_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN270"><span class='Ref_To_Local'>other_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>            <span class='Parentheses'>(</span><a href="../../../include/optimizer/joininfo.h.html#LN19"><span class='Ref_to_Proto'>have_relevant_joinclause</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN262"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN263"><span class='Ref_to_Parameter'>old_rel</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN270"><span class='Ref_To_Local'>other_rel</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>             <a href="../../../include/optimizer/paths.h.html#LN109"><span class='Ref_to_Proto'>have_join_order_restriction</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN262"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN263"><span class='Ref_to_Parameter'>old_rel</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN270"><span class='Ref_To_Local'>other_rel</span></a><span class='Parentheses'>)))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="../../../include/optimizer/paths.h.html#LN107"><span class='Ref_to_Proto'>make_join_rel</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN262"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN263"><span class='Ref_to_Parameter'>old_rel</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN270"><span class='Ref_To_Local'>other_rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * make_rels_by_clauseless_joins 
 *    Given a relation 'old_rel' and a list of other relations 
 *    'other_rels', create a join relation between 'old_rel' and each 
 *    member of 'other_rels' that isn't already included in 'old_rel'. 
 *    The join rels are returned in root-&GT;join_rel_level[join_cur_level]. 
 * 
 * 'old_rel' is the relation entry for the relation to be joined 
 * 'other_rels': the first cell of a linked list containing the 
 * other rels to be considered for joining 
 * 
 * Currently, this is only used with initial rels in other_rels, but it would 
 * work for joining to joinrels too. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN296"></a><span class='Declare_Function'>make_rels_by_clauseless_joins</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN297"></a>                              <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>old_rel</span><span class='Delimiter'>, 
</span><a name="LN298"></a>                              <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>other_rels</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN300"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN168"><span class='Ref_to_Macro'>for_each_cell</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN300"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN298"><span class='Ref_to_Parameter'>other_rels</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN304"></a>        <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>other_rel</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN300"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN304"><span class='Ref_To_Local'>other_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN297"><span class='Ref_to_Parameter'>old_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="../../../include/optimizer/paths.h.html#LN107"><span class='Ref_to_Proto'>make_join_rel</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN296"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN297"><span class='Ref_to_Parameter'>old_rel</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN304"><span class='Ref_To_Local'>other_rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
} 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * join_is_legal 
 *     Determine whether a proposed join is legal given the query's 
 *     join order constraints; and if it is, determine the join type. 
 * 
 * Caller must supply not only the two rels, but the union of their relids. 
 * (We could simplify the API by computing joinrelids locally, but this 
 * would be redundant work in the normal path through make_join_rel.) 
 * 
 * On success, *sjinfo_p is set to NULL if this is to be a plain inner join, 
 * else it's set to point to the associated SpecialJoinInfo node.  Also, 
 * *reversed_p is set TRUE if the given relations need to be swapped to 
 * match the SpecialJoinInfo node. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN329"></a><span class='Declare_Function'>join_is_legal</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel1</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel2</span><span class='Delimiter'>, 
</span><a name="LN330"></a>              <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Declare_Parameter'>joinrelids</span><span class='Delimiter'>, 
</span><a name="LN331"></a>              <a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>sjinfo_p</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Operator'>*</span><span class='Declare_Parameter'>reversed_p</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN333"></a>    <a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>match_sjinfo</span><span class='Delimiter'>; 
</span><a name="LN334"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>reversed</span><span class='Delimiter'>; 
</span><a name="LN335"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>unique_ified</span><span class='Delimiter'>; 
</span><a name="LN336"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>must_be_leftjoin</span><span class='Delimiter'>; 
</span><a name="LN337"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Ensure output params are set on failure return.  This is just to 
     * suppress uninitialized-variable warnings from overly anal compilers. 
     */ 
</span>    <span class='Operator'>*</span><a href="joinrels.c.html#LN331"><span class='Ref_to_Parameter'>sjinfo_p</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="joinrels.c.html#LN331"><span class='Ref_to_Parameter'>reversed_p</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we have any special joins, the proposed join might be illegal; and 
     * in any case we have to determine its join type.  Scan the join info 
     * list for matches and conflicts. 
     */ 
</span>    <a href="joinrels.c.html#LN333"><span class='Ref_To_Local'>match_sjinfo</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="joinrels.c.html#LN334"><span class='Ref_To_Local'>reversed</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="joinrels.c.html#LN335"><span class='Ref_To_Local'>unique_ified</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="joinrels.c.html#LN336"><span class='Ref_To_Local'>must_be_leftjoin</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN337"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN329"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN249"><span class='Ref_to_Member'>join_info_list</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN358"></a>        <a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sjinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN337"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * This special join is not relevant unless its RHS overlaps the 
         * proposed join.  (Check this first as a fast path for dismissing 
         * most irrelevant SJs quickly.) 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN358"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1917"><span class='Ref_to_Member'>min_righthand</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN330"><span class='Ref_to_Parameter'>joinrelids</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Also, not relevant if proposed join is fully contained within RHS 
         * (ie, we're still building up the RHS). 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN330"><span class='Ref_to_Parameter'>joinrelids</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN358"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1917"><span class='Ref_to_Member'>min_righthand</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Also, not relevant if SJ is already done within either input. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN358"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1916"><span class='Ref_to_Member'>min_lefthand</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN329"><span class='Ref_to_Parameter'>rel1</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>            <a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN358"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1917"><span class='Ref_to_Member'>min_righthand</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN329"><span class='Ref_to_Parameter'>rel1</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN358"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1916"><span class='Ref_to_Member'>min_lefthand</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN329"><span class='Ref_to_Parameter'>rel2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>            <a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN358"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1917"><span class='Ref_to_Member'>min_righthand</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN329"><span class='Ref_to_Parameter'>rel2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If it's a semijoin and we already joined the RHS to any other rels 
         * within either input, then we must have unique-ified the RHS at that 
         * point (see below).  Therefore the semijoin is no longer relevant in 
         * this join path. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN358"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1920"><span class='Ref_to_Member'>jointype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN691"><span class='Ref_to_EnumConst'>JOIN_SEMI</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN358"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1919"><span class='Ref_to_Member'>syn_righthand</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN329"><span class='Ref_to_Parameter'>rel1</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                <span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN66"><span class='Ref_to_Proto'>bms_equal</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN358"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1919"><span class='Ref_to_Member'>syn_righthand</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN329"><span class='Ref_to_Parameter'>rel1</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>continue</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN358"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1919"><span class='Ref_to_Member'>syn_righthand</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN329"><span class='Ref_to_Parameter'>rel2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                <span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN66"><span class='Ref_to_Proto'>bms_equal</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN358"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1919"><span class='Ref_to_Member'>syn_righthand</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN329"><span class='Ref_to_Parameter'>rel2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If one input contains min_lefthand and the other contains 
         * min_righthand, then we can perform the SJ at this join. 
         * 
         * Reject if we get matches to more than one SJ; that implies we're 
         * considering something that's not really valid. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN358"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1916"><span class='Ref_to_Member'>min_lefthand</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN329"><span class='Ref_to_Parameter'>rel1</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>            <a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN358"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1917"><span class='Ref_to_Member'>min_righthand</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN329"><span class='Ref_to_Parameter'>rel2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN333"><span class='Ref_To_Local'>match_sjinfo</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* invalid join path */ 
</span>            <a href="joinrels.c.html#LN333"><span class='Ref_To_Local'>match_sjinfo</span></a> <span class='Operator'>= </span><a href="joinrels.c.html#LN358"><span class='Ref_To_Local'>sjinfo</span></a><span class='Delimiter'>; 
</span>            <a href="joinrels.c.html#LN334"><span class='Ref_To_Local'>reversed</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN358"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1916"><span class='Ref_to_Member'>min_lefthand</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN329"><span class='Ref_to_Parameter'>rel2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                 <a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN358"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1917"><span class='Ref_to_Member'>min_righthand</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN329"><span class='Ref_to_Parameter'>rel1</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN333"><span class='Ref_To_Local'>match_sjinfo</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* invalid join path */ 
</span>            <a href="joinrels.c.html#LN333"><span class='Ref_To_Local'>match_sjinfo</span></a> <span class='Operator'>= </span><a href="joinrels.c.html#LN358"><span class='Ref_To_Local'>sjinfo</span></a><span class='Delimiter'>; 
</span>            <a href="joinrels.c.html#LN334"><span class='Ref_To_Local'>reversed</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN358"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1920"><span class='Ref_to_Member'>jointype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN691"><span class='Ref_to_EnumConst'>JOIN_SEMI</span></a> <span class='Operator'>&& 
</span>                 <a href="../../../include/nodes/bitmapset.h.html#LN66"><span class='Ref_to_Proto'>bms_equal</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN358"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1919"><span class='Ref_to_Member'>syn_righthand</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN329"><span class='Ref_to_Parameter'>rel2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                 <a href="../../../include/optimizer/pathnode.h.html#LN77"><span class='Ref_to_Proto'>create_unique_path</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN329"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN329"><span class='Ref_to_Parameter'>rel2</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN329"><span class='Ref_to_Parameter'>rel2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN542"><span class='Ref_to_Member'>cheapest_total_path</span></a><span class='Delimiter'>, 
</span>                                    <a href="joinrels.c.html#LN358"><span class='Ref_To_Local'>sjinfo</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/*---------- 
             * For a semijoin, we can join the RHS to anything else by 
             * unique-ifying the RHS (if the RHS can be unique-ified). 
             * We will only get here if we have the full RHS but less 
             * than min_lefthand on the LHS. 
             * 
             * The reason to consider such a join path is exemplified by 
             *  SELECT ... FROM a,b WHERE (a.x,b.y) IN (SELECT c1,c2 FROM c) 
             * If we insist on doing this as a semijoin we will first have 
             * to form the cartesian product of A*B.  But if we unique-ify 
             * C then the semijoin becomes a plain innerjoin and we can join 
             * in any order, eg C to A and then to B.  When C is much smaller 
             * than A and B this can be a huge win.  So we allow C to be 
             * joined to just A or just B here, and then make_join_rel has 
             * to handle the case properly. 
             * 
             * Note that actually we'll allow unique-ified C to be joined to 
             * some other relation D here, too.  That is legal, if usually not 
             * very sane, and this routine is only concerned with legality not 
             * with whether the join is good strategy. 
             *---------- 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN333"><span class='Ref_To_Local'>match_sjinfo</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* invalid join path */ 
</span>            <a href="joinrels.c.html#LN333"><span class='Ref_To_Local'>match_sjinfo</span></a> <span class='Operator'>= </span><a href="joinrels.c.html#LN358"><span class='Ref_To_Local'>sjinfo</span></a><span class='Delimiter'>; 
</span>            <a href="joinrels.c.html#LN334"><span class='Ref_To_Local'>reversed</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <a href="joinrels.c.html#LN335"><span class='Ref_To_Local'>unique_ified</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if sjinfo-&GT;jointype==JOI... &raquo; </span> 
        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN358"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1920"><span class='Ref_to_Member'>jointype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN691"><span class='Ref_to_EnumConst'>JOIN_SEMI</span></a> <span class='Operator'>&& 
</span>                 <a href="../../../include/nodes/bitmapset.h.html#LN66"><span class='Ref_to_Proto'>bms_equal</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN358"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1919"><span class='Ref_to_Member'>syn_righthand</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN329"><span class='Ref_to_Parameter'>rel1</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                 <a href="../../../include/optimizer/pathnode.h.html#LN77"><span class='Ref_to_Proto'>create_unique_path</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN329"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN329"><span class='Ref_to_Parameter'>rel1</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN329"><span class='Ref_to_Parameter'>rel1</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN542"><span class='Ref_to_Member'>cheapest_total_path</span></a><span class='Delimiter'>, 
</span>                                    <a href="joinrels.c.html#LN358"><span class='Ref_To_Local'>sjinfo</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Reversed semijoin case */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN333"><span class='Ref_To_Local'>match_sjinfo</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* invalid join path */ 
</span>            <a href="joinrels.c.html#LN333"><span class='Ref_To_Local'>match_sjinfo</span></a> <span class='Operator'>= </span><a href="joinrels.c.html#LN358"><span class='Ref_To_Local'>sjinfo</span></a><span class='Delimiter'>; 
</span>            <a href="joinrels.c.html#LN334"><span class='Ref_To_Local'>reversed</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <a href="joinrels.c.html#LN335"><span class='Ref_To_Local'>unique_ified</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Otherwise, the proposed join overlaps the RHS but isn't a valid 
             * implementation of this SJ.  But don't panic quite yet: the RHS 
             * violation might have occurred previously, in one or both input 
             * relations, in which case we must have previously decided that 
             * it was OK to commute some other SJ with this one.  If we need 
             * to perform this join to finish building up the RHS, rejecting 
             * it could lead to not finding any plan at all.  (This can occur 
             * because of the heuristics elsewhere in this file that postpone 
             * clauseless joins: we might not consider doing a clauseless join 
             * within the RHS until after we've performed other, validly 
             * commutable SJs with one or both sides of the clauseless join.) 
             * This consideration boils down to the rule that if both inputs 
             * overlap the RHS, we can allow the join --- they are either 
             * fully within the RHS, or represent previously-allowed joins to 
             * rels outside it. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN329"><span class='Ref_to_Parameter'>rel1</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN358"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1917"><span class='Ref_to_Member'>min_righthand</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                <a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN329"><span class='Ref_to_Parameter'>rel2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN358"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1917"><span class='Ref_to_Member'>min_righthand</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>continue</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* assume valid previous violation of RHS */ 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * The proposed join could still be legal, but only if we're 
             * allowed to associate it into the RHS of this SJ.  That means 
             * this SJ must be a LEFT join (not SEMI or ANTI, and certainly 
             * not FULL) and the proposed join must not overlap the LHS. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN358"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1920"><span class='Ref_to_Member'>jointype</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/nodes.h.html#LN678"><span class='Ref_to_EnumConst'>JOIN_LEFT</span></a> <span class='Operator'>|| 
</span>                <a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN330"><span class='Ref_to_Parameter'>joinrelids</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN358"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1916"><span class='Ref_to_Member'>min_lefthand</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* invalid join path */ 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * To be valid, the proposed join must be a LEFT join; otherwise 
             * it can't associate into this SJ's RHS.  But we may not yet have 
             * found the SpecialJoinInfo matching the proposed join, so we 
             * can't test that yet.  Remember the requirement for later. 
             */ 
</span>            <a href="joinrels.c.html#LN336"><span class='Ref_To_Local'>must_be_leftjoin</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Fail if violated any SJ's RHS and didn't match to a LEFT SJ: the 
     * proposed join can't associate into an SJ's RHS. 
     * 
     * Also, fail if the proposed join's predicate isn't strict; we're 
     * essentially checking to see if we can apply outer-join identity 3, and 
     * that's a requirement.  (This check may be redundant with checks in 
     * make_outerjoininfo, but I'm not quite sure, and it's cheap to test.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN336"><span class='Ref_To_Local'>must_be_leftjoin</span></a> <span class='Operator'>&& 
</span>        <span class='Parentheses'>(</span><a href="joinrels.c.html#LN333"><span class='Ref_To_Local'>match_sjinfo</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>|| 
</span>         <a href="joinrels.c.html#LN333"><span class='Ref_To_Local'>match_sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1920"><span class='Ref_to_Member'>jointype</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/nodes.h.html#LN678"><span class='Ref_to_EnumConst'>JOIN_LEFT</span></a> <span class='Operator'>|| 
</span>         <span class='Operator'>!</span><a href="joinrels.c.html#LN333"><span class='Ref_To_Local'>match_sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1921"><span class='Ref_to_Member'>lhs_strict</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* invalid join path */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We also have to check for constraints imposed by LATERAL references. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN329"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN299"><span class='Ref_to_Member'>hasLateralRTEs</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN532"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>lateral_fwd</span><span class='Delimiter'>; 
</span><a name="LN533"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>lateral_rev</span><span class='Delimiter'>; 
</span><a name="LN534"></a>        <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>join_lateral_rels</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * The proposed rels could each contain lateral references to the 
         * other, in which case the join is impossible.  If there are lateral 
         * references in just one direction, then the join has to be done with 
         * a nestloop with the lateral referencer on the inside.  If the join 
         * matches an SJ that cannot be implemented by such a nestloop, the 
         * join is impossible. 
         * 
         * Also, if the lateral reference is only indirect, we should reject 
         * the join; whatever rel(s) the reference chain goes through must be 
         * joined to first. 
         * 
         * Another case that might keep us from building a valid plan is the 
         * implementation restriction described by have_dangerous_phv(). 
         */ 
</span>        <a href="joinrels.c.html#LN532"><span class='Ref_To_Local'>lateral_fwd</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN329"><span class='Ref_to_Parameter'>rel1</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN329"><span class='Ref_to_Parameter'>rel2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN549"><span class='Ref_to_Member'>lateral_relids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="joinrels.c.html#LN533"><span class='Ref_To_Local'>lateral_rev</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN329"><span class='Ref_to_Parameter'>rel2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN329"><span class='Ref_to_Parameter'>rel1</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN549"><span class='Ref_to_Member'>lateral_relids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN532"><span class='Ref_To_Local'>lateral_fwd</span></a> <span class='Operator'>&& </span><a href="joinrels.c.html#LN533"><span class='Ref_To_Local'>lateral_rev</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* have lateral refs in both directions */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN532"><span class='Ref_To_Local'>lateral_fwd</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* has to be implemented as nestloop with rel1 on left */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN333"><span class='Ref_To_Local'>match_sjinfo</span></a> <span class='Operator'>&& 
</span>                <span class='Parentheses'>(</span><a href="joinrels.c.html#LN334"><span class='Ref_To_Local'>reversed</span></a> <span class='Operator'>|| 
</span>                 <a href="joinrels.c.html#LN335"><span class='Ref_To_Local'>unique_ified</span></a> <span class='Operator'>|| 
</span>                 <a href="joinrels.c.html#LN333"><span class='Ref_To_Local'>match_sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1920"><span class='Ref_to_Member'>jointype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN679"><span class='Ref_to_EnumConst'>JOIN_FULL</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* not implementable as nestloop */ 
</span>            <span class='Comment_Multi_Line'>/* check there is a direct reference from rel2 to rel1 */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN329"><span class='Ref_to_Parameter'>rel1</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN329"><span class='Ref_to_Parameter'>rel2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN548"><span class='Ref_to_Member'>direct_lateral_relids</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* only indirect refs, so reject */ 
</span>            <span class='Comment_Multi_Line'>/* check we won't have a dangerous PHV */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/optimizer/paths.h.html#LN111"><span class='Ref_to_Proto'>have_dangerous_phv</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN329"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN329"><span class='Ref_to_Parameter'>rel1</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN329"><span class='Ref_to_Parameter'>rel2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN549"><span class='Ref_to_Member'>lateral_relids</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* might be unable to handle required PHV */ 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN533"><span class='Ref_To_Local'>lateral_rev</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* has to be implemented as nestloop with rel2 on left */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN333"><span class='Ref_To_Local'>match_sjinfo</span></a> <span class='Operator'>&& 
</span>                <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="joinrels.c.html#LN334"><span class='Ref_To_Local'>reversed</span></a> <span class='Operator'>|| 
</span>                 <a href="joinrels.c.html#LN335"><span class='Ref_To_Local'>unique_ified</span></a> <span class='Operator'>|| 
</span>                 <a href="joinrels.c.html#LN333"><span class='Ref_To_Local'>match_sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1920"><span class='Ref_to_Member'>jointype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN679"><span class='Ref_to_EnumConst'>JOIN_FULL</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* not implementable as nestloop */ 
</span>            <span class='Comment_Multi_Line'>/* check there is a direct reference from rel1 to rel2 */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN329"><span class='Ref_to_Parameter'>rel2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN329"><span class='Ref_to_Parameter'>rel1</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN548"><span class='Ref_to_Member'>direct_lateral_relids</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* only indirect refs, so reject */ 
</span>            <span class='Comment_Multi_Line'>/* check we won't have a dangerous PHV */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/optimizer/paths.h.html#LN111"><span class='Ref_to_Proto'>have_dangerous_phv</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN329"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN329"><span class='Ref_to_Parameter'>rel2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN329"><span class='Ref_to_Parameter'>rel1</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN549"><span class='Ref_to_Member'>lateral_relids</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* might be unable to handle required PHV */ 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * LATERAL references could also cause problems later on if we accept 
         * this join: if the join's minimum parameterization includes any rels 
         * that would have to be on the inside of an outer join with this join 
         * rel, then it's never going to be possible to build the complete 
         * query using this join.  We should reject this join not only because 
         * it'll save work, but because if we don't, the clauseless-join 
         * heuristics might think that legality of this join means that some 
         * other join rel need not be formed, and that could lead to failure 
         * to find any plan at all.  We have to consider not only rels that 
         * are directly on the inner side of an OJ with the joinrel, but also 
         * ones that are indirectly so, so search to find all such rels. 
         */ 
</span>        <a href="joinrels.c.html#LN534"><span class='Ref_To_Local'>join_lateral_rels</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/pathnode.h.html#LN265"><span class='Ref_to_Proto'>min_join_parameterization</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN329"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN330"><span class='Ref_to_Parameter'>joinrelids</span></a><span class='Delimiter'>, 
</span>                                                      <a href="joinrels.c.html#LN329"><span class='Ref_to_Parameter'>rel1</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN329"><span class='Ref_to_Parameter'>rel2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN534"><span class='Ref_To_Local'>join_lateral_rels</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN603"></a>            <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>join_plus_rhs</span> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN65"><span class='Ref_to_Proto'>bms_copy</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN330"><span class='Ref_to_Parameter'>joinrelids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN604"></a>            <span class='Keyword'>bool</span>        <span class='Declare_Local'>more</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>do</span> 
            <span class='Delimiter'>{ 
</span>                <a href="joinrels.c.html#LN604"><span class='Ref_To_Local'>more</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>                <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN337"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN329"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN249"><span class='Ref_to_Member'>join_info_list</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span><a name="LN611"></a>                    <a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sjinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN337"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN611"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1916"><span class='Ref_to_Member'>min_lefthand</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN603"><span class='Ref_To_Local'>join_plus_rhs</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                        <span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN611"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1917"><span class='Ref_to_Member'>min_righthand</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN603"><span class='Ref_To_Local'>join_plus_rhs</span></a><span class='Parentheses'>))</span> 
                    <span class='Delimiter'>{ 
</span>                        <a href="joinrels.c.html#LN603"><span class='Ref_To_Local'>join_plus_rhs</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN91"><span class='Ref_to_Proto'>bms_add_members</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN603"><span class='Ref_To_Local'>join_plus_rhs</span></a><span class='Delimiter'>, 
</span>                                                      <a href="joinrels.c.html#LN611"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1917"><span class='Ref_to_Member'>min_righthand</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                        <a href="joinrels.c.html#LN604"><span class='Ref_To_Local'>more</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                    <span class='Comment_Multi_Line'>/* full joins constrain both sides symmetrically */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN611"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1920"><span class='Ref_to_Member'>jointype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN679"><span class='Ref_to_EnumConst'>JOIN_FULL</span></a> <span class='Operator'>&& 
</span>                        <a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN611"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1917"><span class='Ref_to_Member'>min_righthand</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN603"><span class='Ref_To_Local'>join_plus_rhs</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                        <span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN611"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1916"><span class='Ref_to_Member'>min_lefthand</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN603"><span class='Ref_To_Local'>join_plus_rhs</span></a><span class='Parentheses'>))</span> 
                    <span class='Delimiter'>{ 
</span>                        <a href="joinrels.c.html#LN603"><span class='Ref_To_Local'>join_plus_rhs</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN91"><span class='Ref_to_Proto'>bms_add_members</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN603"><span class='Ref_To_Local'>join_plus_rhs</span></a><span class='Delimiter'>, 
</span>                                                        <a href="joinrels.c.html#LN611"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1916"><span class='Ref_to_Member'>min_lefthand</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                        <a href="joinrels.c.html#LN604"><span class='Ref_To_Local'>more</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end do &raquo; </span> <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN604"><span class='Ref_To_Local'>more</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN603"><span class='Ref_To_Local'>join_plus_rhs</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN534"><span class='Ref_To_Local'>join_lateral_rels</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* will not be able to join to some RHS rel */ 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if join_lateral_rels &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if root-&GT;hasLateralRTEs &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* Otherwise, it's a valid join */ 
</span>    <span class='Operator'>*</span><a href="joinrels.c.html#LN331"><span class='Ref_to_Parameter'>sjinfo_p</span></a> <span class='Operator'>= </span><a href="joinrels.c.html#LN333"><span class='Ref_To_Local'>match_sjinfo</span></a><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="joinrels.c.html#LN331"><span class='Ref_to_Parameter'>reversed_p</span></a> <span class='Operator'>= </span><a href="joinrels.c.html#LN334"><span class='Ref_To_Local'>reversed</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end join_is_legal &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * make_join_rel 
 *     Find or create a join RelOptInfo that represents the join of 
 *     the two given rels, and add to it path information for paths 
 *     created with the two rels as outer and inner rel. 
 *     (The join rel may already contain paths generated from other 
 *     pairs of rels that add up to the same set of base rels.) 
 * 
 * NB: will return NULL if attempted join is not valid.  This can happen 
 * when working with outer joins, or with IN or EXISTS clauses that have been 
 * turned into joins. 
 */ 
</span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>* 
</span><a name="LN656"></a><span class='Declare_Function'>make_join_rel</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel1</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel2</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN658"></a>    <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>joinrelids</span><span class='Delimiter'>; 
</span><a name="LN659"></a>    <a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sjinfo</span><span class='Delimiter'>; 
</span><a name="LN660"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>reversed</span><span class='Delimiter'>; 
</span><a name="LN661"></a>    <a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Declare_Local'>sjinfo_data</span><span class='Delimiter'>; 
</span><a name="LN662"></a>    <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>joinrel</span><span class='Delimiter'>; 
</span><a name="LN663"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>restrictlist</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* We should never try to join two overlapping sets of rels. */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN656"><span class='Ref_to_Parameter'>rel1</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN656"><span class='Ref_to_Parameter'>rel2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Construct Relids set that identifies the joinrel. */ 
</span>    <a href="joinrels.c.html#LN658"><span class='Ref_To_Local'>joinrelids</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN70"><span class='Ref_to_Proto'>bms_union</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN656"><span class='Ref_to_Parameter'>rel1</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN656"><span class='Ref_to_Parameter'>rel2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Check validity and determine join type. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="joinrels.c.html#LN328"><span class='Ref_to_Func'>join_is_legal</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN656"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN656"><span class='Ref_to_Parameter'>rel1</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN656"><span class='Ref_to_Parameter'>rel2</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN658"><span class='Ref_To_Local'>joinrelids</span></a><span class='Delimiter'>, 
</span>                       <span class='Operator'>&</span><a href="joinrels.c.html#LN659"><span class='Ref_To_Local'>sjinfo</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="joinrels.c.html#LN660"><span class='Ref_To_Local'>reversed</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* invalid join path */ 
</span>        <a href="../../../include/nodes/bitmapset.h.html#LN68"><span class='Ref_to_Proto'>bms_free</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN658"><span class='Ref_To_Local'>joinrelids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Swap rels if needed to match the join info. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN660"><span class='Ref_To_Local'>reversed</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN683"></a>        <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>trel</span> <span class='Operator'>= </span><a href="joinrels.c.html#LN656"><span class='Ref_to_Parameter'>rel1</span></a><span class='Delimiter'>; 
</span> 
        <a href="joinrels.c.html#LN656"><span class='Ref_to_Parameter'>rel1</span></a> <span class='Operator'>= </span><a href="joinrels.c.html#LN656"><span class='Ref_to_Parameter'>rel2</span></a><span class='Delimiter'>; 
</span>        <a href="joinrels.c.html#LN656"><span class='Ref_to_Parameter'>rel2</span></a> <span class='Operator'>= </span><a href="joinrels.c.html#LN683"><span class='Ref_To_Local'>trel</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If it's a plain inner join, then we won't have found anything in 
     * join_info_list.  Make up a SpecialJoinInfo so that selectivity 
     * estimation functions will know what's being joined. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN659"><span class='Ref_To_Local'>sjinfo</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="joinrels.c.html#LN659"><span class='Ref_To_Local'>sjinfo</span></a> <span class='Operator'>= &</span><a href="joinrels.c.html#LN661"><span class='Ref_To_Local'>sjinfo_data</span></a><span class='Delimiter'>; 
</span>        <a href="joinrels.c.html#LN659"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1915"><span class='Ref_to_Member'>type</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN260"><span class='Ref_to_EnumConst'>T_SpecialJoinInfo</span></a><span class='Delimiter'>; 
</span>        <a href="joinrels.c.html#LN659"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1916"><span class='Ref_to_Member'>min_lefthand</span></a> <span class='Operator'>= </span><a href="joinrels.c.html#LN656"><span class='Ref_to_Parameter'>rel1</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Delimiter'>; 
</span>        <a href="joinrels.c.html#LN659"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1917"><span class='Ref_to_Member'>min_righthand</span></a> <span class='Operator'>= </span><a href="joinrels.c.html#LN656"><span class='Ref_to_Parameter'>rel2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Delimiter'>; 
</span>        <a href="joinrels.c.html#LN659"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1918"><span class='Ref_to_Member'>syn_lefthand</span></a> <span class='Operator'>= </span><a href="joinrels.c.html#LN656"><span class='Ref_to_Parameter'>rel1</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Delimiter'>; 
</span>        <a href="joinrels.c.html#LN659"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1919"><span class='Ref_to_Member'>syn_righthand</span></a> <span class='Operator'>= </span><a href="joinrels.c.html#LN656"><span class='Ref_to_Parameter'>rel2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Delimiter'>; 
</span>        <a href="joinrels.c.html#LN659"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1920"><span class='Ref_to_Member'>jointype</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN677"><span class='Ref_to_EnumConst'>JOIN_INNER</span></a><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* we don't bother trying to make the remaining fields valid */ 
</span>        <a href="joinrels.c.html#LN659"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1921"><span class='Ref_to_Member'>lhs_strict</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <a href="joinrels.c.html#LN659"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1922"><span class='Ref_to_Member'>delay_upper_joins</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <a href="joinrels.c.html#LN659"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1924"><span class='Ref_to_Member'>semi_can_btree</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <a href="joinrels.c.html#LN659"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1925"><span class='Ref_to_Member'>semi_can_hash</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <a href="joinrels.c.html#LN659"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1926"><span class='Ref_to_Member'>semi_operators</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>        <a href="joinrels.c.html#LN659"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1927"><span class='Ref_to_Member'>semi_rhs_exprs</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Find or build the join RelOptInfo, and compute the restrictlist that 
     * goes with this particular joining. 
     */ 
</span>    <a href="joinrels.c.html#LN662"><span class='Ref_To_Local'>joinrel</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/pathnode.h.html#LN259"><span class='Ref_to_Proto'>build_join_rel</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN656"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN658"><span class='Ref_To_Local'>joinrelids</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN656"><span class='Ref_to_Parameter'>rel1</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN656"><span class='Ref_to_Parameter'>rel2</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN659"><span class='Ref_To_Local'>sjinfo</span></a><span class='Delimiter'>, 
</span>                             <span class='Operator'>&</span><a href="joinrels.c.html#LN663"><span class='Ref_To_Local'>restrictlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we've already proven this join is empty, we needn't consider any 
     * more paths for it. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN30"><span class='Ref_to_Proto'>is_dummy_rel</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN662"><span class='Ref_To_Local'>joinrel</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../../include/nodes/bitmapset.h.html#LN68"><span class='Ref_to_Proto'>bms_free</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN658"><span class='Ref_To_Local'>joinrelids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <a href="joinrels.c.html#LN662"><span class='Ref_To_Local'>joinrel</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Add paths to the join relation. */ 
</span>    <a href="joinrels.c.html#LN34"><span class='Ref_to_Proto'>populate_joinrel_with_paths</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN656"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN656"><span class='Ref_to_Parameter'>rel1</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN656"><span class='Ref_to_Parameter'>rel2</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN662"><span class='Ref_To_Local'>joinrel</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN659"><span class='Ref_To_Local'>sjinfo</span></a><span class='Delimiter'>, 
</span>                                <a href="joinrels.c.html#LN663"><span class='Ref_To_Local'>restrictlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/bitmapset.h.html#LN68"><span class='Ref_to_Proto'>bms_free</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN658"><span class='Ref_To_Local'>joinrelids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="joinrels.c.html#LN662"><span class='Ref_To_Local'>joinrel</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end make_join_rel &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * populate_joinrel_with_paths 
 *    Add paths to the given joinrel for given pair of joining relations. The 
 *    SpecialJoinInfo provides details about the join and the restrictlist 
 *    contains the join clauses and the other clauses applicable for given pair 
 *    of the joining relations. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN746"></a><span class='Declare_Function'>populate_joinrel_with_paths</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel1</span><span class='Delimiter'>, 
</span><a name="LN747"></a>                            <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel2</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>joinrel</span><span class='Delimiter'>, 
</span><a name="LN748"></a>                            <a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sjinfo</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>restrictlist</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * Consider paths using each rel as both outer and inner.  Depending on 
     * the join type, a provably empty outer or inner rel might mean the join 
     * is provably empty too; in which case throw away any previously computed 
     * paths and mark the join as dummy.  (We do it this way since it's 
     * conceivable that dummy-ness of a multi-element join might only be 
     * noticeable for certain construction paths.) 
     * 
     * Also, a provably constant-false join restriction typically means that 
     * we can skip evaluating one or both sides of the join.  We do this by 
     * marking the appropriate rel as dummy.  For outer joins, a 
     * constant-false restriction that is pushed down still means the whole 
     * join is dummy, while a non-pushed-down one means that no inner rows 
     * will join so we can treat the inner rel as dummy. 
     * 
     * We need only consider the jointypes that appear in join_info_list, plus 
     * JOIN_INNER. 
     */ 
</span>    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN748"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1920"><span class='Ref_to_Member'>jointype</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN677"><span class='Ref_to_EnumConst'>JOIN_INNER</span></a><span class='Operator'>: 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN30"><span class='Ref_to_Proto'>is_dummy_rel</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN746"><span class='Ref_to_Parameter'>rel1</span></a><span class='Parentheses'>) </span><span class='Operator'>|| </span><a href="joinrels.c.html#LN30"><span class='Ref_to_Proto'>is_dummy_rel</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN747"><span class='Ref_to_Parameter'>rel2</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>                <a href="joinrels.c.html#LN32"><span class='Ref_to_Proto'>restriction_is_constant_false</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN748"><span class='Ref_to_Parameter'>restrictlist</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <a href="joinrels.c.html#LN31"><span class='Ref_to_Proto'>mark_dummy_rel</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN747"><span class='Ref_to_Parameter'>joinrel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <a href="../../../include/optimizer/paths.h.html#LN97"><span class='Ref_to_Proto'>add_paths_to_joinrel</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN746"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN747"><span class='Ref_to_Parameter'>joinrel</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN746"><span class='Ref_to_Parameter'>rel1</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN747"><span class='Ref_to_Parameter'>rel2</span></a><span class='Delimiter'>, 
</span>                                 <a href="../../../include/nodes/nodes.h.html#LN677"><span class='Ref_to_EnumConst'>JOIN_INNER</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN748"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Delimiter'>, 
</span>                                 <a href="joinrels.c.html#LN748"><span class='Ref_to_Parameter'>restrictlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/optimizer/paths.h.html#LN97"><span class='Ref_to_Proto'>add_paths_to_joinrel</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN746"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN747"><span class='Ref_to_Parameter'>joinrel</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN747"><span class='Ref_to_Parameter'>rel2</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN746"><span class='Ref_to_Parameter'>rel1</span></a><span class='Delimiter'>, 
</span>                                 <a href="../../../include/nodes/nodes.h.html#LN677"><span class='Ref_to_EnumConst'>JOIN_INNER</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN748"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Delimiter'>, 
</span>                                 <a href="joinrels.c.html#LN748"><span class='Ref_to_Parameter'>restrictlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN678"><span class='Ref_to_EnumConst'>JOIN_LEFT</span></a><span class='Operator'>: 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN30"><span class='Ref_to_Proto'>is_dummy_rel</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN746"><span class='Ref_to_Parameter'>rel1</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>                <a href="joinrels.c.html#LN32"><span class='Ref_to_Proto'>restriction_is_constant_false</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN748"><span class='Ref_to_Parameter'>restrictlist</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <a href="joinrels.c.html#LN31"><span class='Ref_to_Proto'>mark_dummy_rel</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN747"><span class='Ref_to_Parameter'>joinrel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN32"><span class='Ref_to_Proto'>restriction_is_constant_false</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN748"><span class='Ref_to_Parameter'>restrictlist</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                <a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN747"><span class='Ref_to_Parameter'>rel2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN748"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1919"><span class='Ref_to_Member'>syn_righthand</span></a><span class='Parentheses'>))</span> 
                <a href="joinrels.c.html#LN31"><span class='Ref_to_Proto'>mark_dummy_rel</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN747"><span class='Ref_to_Parameter'>rel2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/optimizer/paths.h.html#LN97"><span class='Ref_to_Proto'>add_paths_to_joinrel</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN746"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN747"><span class='Ref_to_Parameter'>joinrel</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN746"><span class='Ref_to_Parameter'>rel1</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN747"><span class='Ref_to_Parameter'>rel2</span></a><span class='Delimiter'>, 
</span>                                 <a href="../../../include/nodes/nodes.h.html#LN678"><span class='Ref_to_EnumConst'>JOIN_LEFT</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN748"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Delimiter'>, 
</span>                                 <a href="joinrels.c.html#LN748"><span class='Ref_to_Parameter'>restrictlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/optimizer/paths.h.html#LN97"><span class='Ref_to_Proto'>add_paths_to_joinrel</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN746"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN747"><span class='Ref_to_Parameter'>joinrel</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN747"><span class='Ref_to_Parameter'>rel2</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN746"><span class='Ref_to_Parameter'>rel1</span></a><span class='Delimiter'>, 
</span>                                 <a href="../../../include/nodes/nodes.h.html#LN680"><span class='Ref_to_EnumConst'>JOIN_RIGHT</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN748"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Delimiter'>, 
</span>                                 <a href="joinrels.c.html#LN748"><span class='Ref_to_Parameter'>restrictlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN679"><span class='Ref_to_EnumConst'>JOIN_FULL</span></a><span class='Operator'>: 
</span>            <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="joinrels.c.html#LN30"><span class='Ref_to_Proto'>is_dummy_rel</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN746"><span class='Ref_to_Parameter'>rel1</span></a><span class='Parentheses'>) </span><span class='Operator'>&& </span><a href="joinrels.c.html#LN30"><span class='Ref_to_Proto'>is_dummy_rel</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN747"><span class='Ref_to_Parameter'>rel2</span></a><span class='Parentheses'>))</span> <span class='Operator'>|| 
</span>                <a href="joinrels.c.html#LN32"><span class='Ref_to_Proto'>restriction_is_constant_false</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN748"><span class='Ref_to_Parameter'>restrictlist</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <a href="joinrels.c.html#LN31"><span class='Ref_to_Proto'>mark_dummy_rel</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN747"><span class='Ref_to_Parameter'>joinrel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <a href="../../../include/optimizer/paths.h.html#LN97"><span class='Ref_to_Proto'>add_paths_to_joinrel</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN746"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN747"><span class='Ref_to_Parameter'>joinrel</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN746"><span class='Ref_to_Parameter'>rel1</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN747"><span class='Ref_to_Parameter'>rel2</span></a><span class='Delimiter'>, 
</span>                                 <a href="../../../include/nodes/nodes.h.html#LN679"><span class='Ref_to_EnumConst'>JOIN_FULL</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN748"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Delimiter'>, 
</span>                                 <a href="joinrels.c.html#LN748"><span class='Ref_to_Parameter'>restrictlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/optimizer/paths.h.html#LN97"><span class='Ref_to_Proto'>add_paths_to_joinrel</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN746"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN747"><span class='Ref_to_Parameter'>joinrel</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN747"><span class='Ref_to_Parameter'>rel2</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN746"><span class='Ref_to_Parameter'>rel1</span></a><span class='Delimiter'>, 
</span>                                 <a href="../../../include/nodes/nodes.h.html#LN679"><span class='Ref_to_EnumConst'>JOIN_FULL</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN748"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Delimiter'>, 
</span>                                 <a href="joinrels.c.html#LN748"><span class='Ref_to_Parameter'>restrictlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * If there are join quals that aren't mergeable or hashable, we 
             * may not be able to build any valid plan.  Complain here so that 
             * we can give a somewhat-useful error message.  (Since we have no 
             * flexibility of planning for a full join, there's no chance of 
             * succeeding later with another pair of input rels.) 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN747"><span class='Ref_to_Parameter'>joinrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN538"><span class='Ref_to_Member'>pathlist</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>                <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                        <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                         <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"FULL JOIN is only supported with merge-joinable or hash-joinable join conditions"</span><span class='Parentheses'>)))</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN691"><span class='Ref_to_EnumConst'>JOIN_SEMI</span></a><span class='Operator'>: 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * We might have a normal semijoin, or a case where we don't have 
             * enough rels to do the semijoin but can unique-ify the RHS and 
             * then do an innerjoin (see comments in join_is_legal).  In the 
             * latter case we can't apply JOIN_SEMI joining. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN748"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1916"><span class='Ref_to_Member'>min_lefthand</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN746"><span class='Ref_to_Parameter'>rel1</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                <a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN748"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1917"><span class='Ref_to_Member'>min_righthand</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN747"><span class='Ref_to_Parameter'>rel2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN30"><span class='Ref_to_Proto'>is_dummy_rel</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN746"><span class='Ref_to_Parameter'>rel1</span></a><span class='Parentheses'>) </span><span class='Operator'>|| </span><a href="joinrels.c.html#LN30"><span class='Ref_to_Proto'>is_dummy_rel</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN747"><span class='Ref_to_Parameter'>rel2</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>                    <a href="joinrels.c.html#LN32"><span class='Ref_to_Proto'>restriction_is_constant_false</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN748"><span class='Ref_to_Parameter'>restrictlist</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span>                    <a href="joinrels.c.html#LN31"><span class='Ref_to_Proto'>mark_dummy_rel</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN747"><span class='Ref_to_Parameter'>joinrel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <a href="../../../include/optimizer/paths.h.html#LN97"><span class='Ref_to_Proto'>add_paths_to_joinrel</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN746"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN747"><span class='Ref_to_Parameter'>joinrel</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN746"><span class='Ref_to_Parameter'>rel1</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN747"><span class='Ref_to_Parameter'>rel2</span></a><span class='Delimiter'>, 
</span>                                     <a href="../../../include/nodes/nodes.h.html#LN691"><span class='Ref_to_EnumConst'>JOIN_SEMI</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN748"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Delimiter'>, 
</span>                                     <a href="joinrels.c.html#LN748"><span class='Ref_to_Parameter'>restrictlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * If we know how to unique-ify the RHS and one input rel is 
             * exactly the RHS (not a superset) we can consider unique-ifying 
             * it and then doing a regular join.  (The create_unique_path 
             * check here is probably redundant with what join_is_legal did, 
             * but if so the check is cheap because it's cached.  So test 
             * anyway to be sure.) 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN66"><span class='Ref_to_Proto'>bms_equal</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN748"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1919"><span class='Ref_to_Member'>syn_righthand</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN747"><span class='Ref_to_Parameter'>rel2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                <a href="../../../include/optimizer/pathnode.h.html#LN77"><span class='Ref_to_Proto'>create_unique_path</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN746"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN747"><span class='Ref_to_Parameter'>rel2</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN747"><span class='Ref_to_Parameter'>rel2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN542"><span class='Ref_to_Member'>cheapest_total_path</span></a><span class='Delimiter'>, 
</span>                                   <a href="joinrels.c.html#LN748"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN30"><span class='Ref_to_Proto'>is_dummy_rel</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN746"><span class='Ref_to_Parameter'>rel1</span></a><span class='Parentheses'>) </span><span class='Operator'>|| </span><a href="joinrels.c.html#LN30"><span class='Ref_to_Proto'>is_dummy_rel</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN747"><span class='Ref_to_Parameter'>rel2</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>                    <a href="joinrels.c.html#LN32"><span class='Ref_to_Proto'>restriction_is_constant_false</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN748"><span class='Ref_to_Parameter'>restrictlist</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span>                    <a href="joinrels.c.html#LN31"><span class='Ref_to_Proto'>mark_dummy_rel</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN747"><span class='Ref_to_Parameter'>joinrel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>break</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <a href="../../../include/optimizer/paths.h.html#LN97"><span class='Ref_to_Proto'>add_paths_to_joinrel</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN746"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN747"><span class='Ref_to_Parameter'>joinrel</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN746"><span class='Ref_to_Parameter'>rel1</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN747"><span class='Ref_to_Parameter'>rel2</span></a><span class='Delimiter'>, 
</span>                                     <a href="../../../include/nodes/nodes.h.html#LN699"><span class='Ref_to_EnumConst'>JOIN_UNIQUE_INNER</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN748"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Delimiter'>, 
</span>                                     <a href="joinrels.c.html#LN748"><span class='Ref_to_Parameter'>restrictlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="../../../include/optimizer/paths.h.html#LN97"><span class='Ref_to_Proto'>add_paths_to_joinrel</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN746"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN747"><span class='Ref_to_Parameter'>joinrel</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN747"><span class='Ref_to_Parameter'>rel2</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN746"><span class='Ref_to_Parameter'>rel1</span></a><span class='Delimiter'>, 
</span>                                     <a href="../../../include/nodes/nodes.h.html#LN698"><span class='Ref_to_EnumConst'>JOIN_UNIQUE_OUTER</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN748"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Delimiter'>, 
</span>                                     <a href="joinrels.c.html#LN748"><span class='Ref_to_Parameter'>restrictlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN692"><span class='Ref_to_EnumConst'>JOIN_ANTI</span></a><span class='Operator'>: 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN30"><span class='Ref_to_Proto'>is_dummy_rel</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN746"><span class='Ref_to_Parameter'>rel1</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>                <a href="joinrels.c.html#LN32"><span class='Ref_to_Proto'>restriction_is_constant_false</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN748"><span class='Ref_to_Parameter'>restrictlist</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <a href="joinrels.c.html#LN31"><span class='Ref_to_Proto'>mark_dummy_rel</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN747"><span class='Ref_to_Parameter'>joinrel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN32"><span class='Ref_to_Proto'>restriction_is_constant_false</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN748"><span class='Ref_to_Parameter'>restrictlist</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                <a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN747"><span class='Ref_to_Parameter'>rel2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN748"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1919"><span class='Ref_to_Member'>syn_righthand</span></a><span class='Parentheses'>))</span> 
                <a href="joinrels.c.html#LN31"><span class='Ref_to_Proto'>mark_dummy_rel</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN747"><span class='Ref_to_Parameter'>rel2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/optimizer/paths.h.html#LN97"><span class='Ref_to_Proto'>add_paths_to_joinrel</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN746"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN747"><span class='Ref_to_Parameter'>joinrel</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN746"><span class='Ref_to_Parameter'>rel1</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN747"><span class='Ref_to_Parameter'>rel2</span></a><span class='Delimiter'>, 
</span>                                 <a href="../../../include/nodes/nodes.h.html#LN692"><span class='Ref_to_EnumConst'>JOIN_ANTI</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN748"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Delimiter'>, 
</span>                                 <a href="joinrels.c.html#LN748"><span class='Ref_to_Parameter'>restrictlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>default</span><span class='Operator'>: 
</span>            <span class='Comment_Multi_Line'>/* other values not expected here */ 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized join type: %d"</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="joinrels.c.html#LN748"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1920"><span class='Ref_to_Member'>jointype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch sjinfo-&GT;jointype &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end populate_joinrel_with_paths &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * have_join_order_restriction 
 *      Detect whether the two relations should be joined to satisfy 
 *      a join-order restriction arising from special or lateral joins. 
 * 
 * In practice this is always used with have_relevant_joinclause(), and so 
 * could be merged with that function, but it seems clearer to separate the 
 * two concerns.  We need this test because there are degenerate cases where 
 * a clauseless join must be performed to satisfy join-order restrictions. 
 * Also, if one rel has a lateral reference to the other, or both are needed 
 * to compute some PHV, we should consider joining them even if the join would 
 * be clauseless. 
 * 
 * Note: this is only a problem if one side of a degenerate outer join 
 * contains multiple rels, or a clauseless join is required within an 
 * IN/EXISTS RHS; else we will find a join path via the "last ditch" case in 
 * join_search_one_level().  We could dispense with this test if we were 
 * willing to try bushy plans in the "last ditch" case, but that seems much 
 * less efficient. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN918"></a><span class='Declare_Function'>have_join_order_restriction</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN919"></a>                            <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel1</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel2</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN921"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>result</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN922"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If either side has a direct lateral reference to the other, attempt the 
     * join regardless of outer-join considerations. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN919"><span class='Ref_to_Parameter'>rel1</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN919"><span class='Ref_to_Parameter'>rel2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN548"><span class='Ref_to_Member'>direct_lateral_relids</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>        <a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN919"><span class='Ref_to_Parameter'>rel2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN919"><span class='Ref_to_Parameter'>rel1</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN548"><span class='Ref_to_Member'>direct_lateral_relids</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Likewise, if both rels are needed to compute some PlaceHolderVar, 
     * attempt the join regardless of outer-join considerations.  (This is not 
     * very desirable, because a PHV with a large eval_at set will cause a lot 
     * of probably-useless joins to be considered, but failing to do this can 
     * cause us to fail to construct a plan at all.) 
     */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN922"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN918"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN257"><span class='Ref_to_Member'>placeholder_list</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN941"></a>        <a href="../../../include/nodes/relation.h.html#LN2057"><span class='Ref_to_Struct'>PlaceHolderInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>phinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN2057"><span class='Ref_to_Struct'>PlaceHolderInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN922"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN919"><span class='Ref_to_Parameter'>rel1</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN941"><span class='Ref_To_Local'>phinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2063"><span class='Ref_to_Member'>ph_eval_at</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>            <a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN919"><span class='Ref_to_Parameter'>rel2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN941"><span class='Ref_To_Local'>phinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2063"><span class='Ref_to_Member'>ph_eval_at</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * It's possible that the rels correspond to the left and right sides of a 
     * degenerate outer join, that is, one with no joinclause mentioning the 
     * non-nullable side; in which case we should force the join to occur. 
     * 
     * Also, the two rels could represent a clauseless join that has to be 
     * completed to build up the LHS or RHS of an outer join. 
     */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN922"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN918"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN249"><span class='Ref_to_Member'>join_info_list</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN958"></a>        <a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sjinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN922"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* ignore full joins --- other mechanisms handle them */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN958"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1920"><span class='Ref_to_Member'>jointype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN679"><span class='Ref_to_EnumConst'>JOIN_FULL</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Can we perform the SJ with these rels? */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN958"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1916"><span class='Ref_to_Member'>min_lefthand</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN919"><span class='Ref_to_Parameter'>rel1</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>            <a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN958"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1917"><span class='Ref_to_Member'>min_righthand</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN919"><span class='Ref_to_Parameter'>rel2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="joinrels.c.html#LN921"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN958"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1916"><span class='Ref_to_Member'>min_lefthand</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN919"><span class='Ref_to_Parameter'>rel2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>            <a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN958"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1917"><span class='Ref_to_Member'>min_righthand</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN919"><span class='Ref_to_Parameter'>rel1</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="joinrels.c.html#LN921"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Might we need to join these rels to complete the RHS?  We have to 
         * use "overlap" tests since either rel might include a lower SJ that 
         * has been proven to commute with this one. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN958"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1917"><span class='Ref_to_Member'>min_righthand</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN919"><span class='Ref_to_Parameter'>rel1</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>            <a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN958"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1917"><span class='Ref_to_Member'>min_righthand</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN919"><span class='Ref_to_Parameter'>rel2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="joinrels.c.html#LN921"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* Likewise for the LHS. */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN958"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1916"><span class='Ref_to_Member'>min_lefthand</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN919"><span class='Ref_to_Parameter'>rel1</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>            <a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN958"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1916"><span class='Ref_to_Member'>min_lefthand</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN919"><span class='Ref_to_Parameter'>rel2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <a href="joinrels.c.html#LN921"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We do not force the join to occur if either input rel can legally be 
     * joined to anything else using joinclauses.  This essentially means that 
     * clauseless bushy joins are put off as long as possible. The reason is 
     * that when there is a join order restriction high up in the join tree 
     * (that is, with many rels inside the LHS or RHS), we would otherwise 
     * expend lots of effort considering very stupid join combinations within 
     * its LHS or RHS. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN921"><span class='Ref_To_Local'>result</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN29"><span class='Ref_to_Proto'>has_legal_joinclause</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN918"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN919"><span class='Ref_to_Parameter'>rel1</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>            <a href="joinrels.c.html#LN29"><span class='Ref_to_Proto'>has_legal_joinclause</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN918"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN919"><span class='Ref_to_Parameter'>rel2</span></a><span class='Parentheses'>))</span> 
            <a href="joinrels.c.html#LN921"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="joinrels.c.html#LN921"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end have_join_order_restriction &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * has_join_restriction 
 *      Detect whether the specified relation has join-order restrictions, 
 *      due to being inside an outer join or an IN (sub-SELECT), 
 *      or participating in any LATERAL references or multi-rel PHVs. 
 * 
 * Essentially, this tests whether have_join_order_restriction() could 
 * succeed with this rel and some other one.  It's OK if we sometimes 
 * say "true" incorrectly.  (Therefore, we don't bother with the relatively 
 * expensive has_legal_joinclause test.) 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN1031"></a><span class='Declare_Function'>has_join_restriction</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1033"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN1031"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN549"><span class='Ref_to_Member'>lateral_relids</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL </span><span class='Operator'>|| </span><a href="joinrels.c.html#LN1031"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN560"><span class='Ref_to_Member'>lateral_referencers</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN1033"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN1031"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN257"><span class='Ref_to_Member'>placeholder_list</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1040"></a>        <a href="../../../include/nodes/relation.h.html#LN2057"><span class='Ref_to_Struct'>PlaceHolderInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>phinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN2057"><span class='Ref_to_Struct'>PlaceHolderInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN1033"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN1031"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN1040"><span class='Ref_To_Local'>phinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2063"><span class='Ref_to_Member'>ph_eval_at</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>            <span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN66"><span class='Ref_to_Proto'>bms_equal</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN1031"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN1040"><span class='Ref_To_Local'>phinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2063"><span class='Ref_to_Member'>ph_eval_at</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN1033"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN1031"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN249"><span class='Ref_to_Member'>join_info_list</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1049"></a>        <a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sjinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN1033"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* ignore full joins --- other mechanisms preserve their ordering */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN1049"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1920"><span class='Ref_to_Member'>jointype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN679"><span class='Ref_to_EnumConst'>JOIN_FULL</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* ignore if SJ is already contained in rel */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN1049"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1916"><span class='Ref_to_Member'>min_lefthand</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN1031"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>            <a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN1049"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1917"><span class='Ref_to_Member'>min_righthand</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN1031"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* restricted if it overlaps LHS or RHS, but doesn't contain SJ */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN1049"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1916"><span class='Ref_to_Member'>min_lefthand</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN1031"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>            <a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN1049"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1917"><span class='Ref_to_Member'>min_righthand</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN1031"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end has_join_restriction &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * has_legal_joinclause 
 *      Detect whether the specified relation can legally be joined 
 *      to any other rels using join clauses. 
 * 
 * We consider only joins to single other relations in the current 
 * initial_rels list.  This is sufficient to get a "true" result in most real 
 * queries, and an occasional erroneous "false" will only cost a bit more 
 * planning time.  The reason for this limitation is that considering joins to 
 * other joins would require proving that the other join rel can legally be 
 * formed, which seems like too much trouble for something that's only a 
 * heuristic to save planning time.  (Note: we must look at initial_rels 
 * and not all of the query, since when we are planning a sub-joinlist we 
 * may be forced to make clauseless joins within initial_rels even though 
 * there are join clauses linking to other parts of the query.) 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN1087"></a><span class='Declare_Function'>has_legal_joinclause</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1089"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN1089"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN1087"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN268"><span class='Ref_to_Member'>initial_rels</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1093"></a>        <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rel2</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN1089"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* ignore rels that are already in "rel" */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN1087"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN1093"><span class='Ref_To_Local'>rel2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/optimizer/joininfo.h.html#LN19"><span class='Ref_to_Proto'>have_relevant_joinclause</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN1087"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN1087"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN1093"><span class='Ref_To_Local'>rel2</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN1101"></a>            <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>joinrelids</span><span class='Delimiter'>; 
</span><a name="LN1102"></a>            <a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sjinfo</span><span class='Delimiter'>; 
</span><a name="LN1103"></a>            <span class='Keyword'>bool</span>        <span class='Declare_Local'>reversed</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* join_is_legal needs relids of the union */ 
</span>            <a href="joinrels.c.html#LN1101"><span class='Ref_To_Local'>joinrelids</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN70"><span class='Ref_to_Proto'>bms_union</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN1087"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN1093"><span class='Ref_To_Local'>rel2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN328"><span class='Ref_to_Func'>join_is_legal</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN1087"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN1087"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN1093"><span class='Ref_To_Local'>rel2</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN1101"><span class='Ref_To_Local'>joinrelids</span></a><span class='Delimiter'>, 
</span>                              <span class='Operator'>&</span><a href="joinrels.c.html#LN1102"><span class='Ref_To_Local'>sjinfo</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="joinrels.c.html#LN1103"><span class='Ref_To_Local'>reversed</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* Yes, this will work */ 
</span>                <a href="../../../include/nodes/bitmapset.h.html#LN68"><span class='Ref_to_Proto'>bms_free</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN1101"><span class='Ref_To_Local'>joinrelids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <a href="../../../include/nodes/bitmapset.h.html#LN68"><span class='Ref_to_Proto'>bms_free</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN1101"><span class='Ref_To_Local'>joinrelids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end has_legal_joinclause &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * There's a pitfall for creating parameterized nestloops: suppose the inner 
 * rel (call it A) has a parameter that is a PlaceHolderVar, and that PHV's 
 * minimum eval_at set includes the outer rel (B) and some third rel (C). 
 * We might think we could create a B/A nestloop join that's parameterized by 
 * C.  But we would end up with a plan in which the PHV's expression has to be 
 * evaluated as a nestloop parameter at the B/A join; and the executor is only 
 * set up to handle simple Vars as NestLoopParams.  Rather than add complexity 
 * and overhead to the executor for such corner cases, it seems better to 
 * forbid the join.  (Note that we can still make use of A's parameterized 
 * path with pre-joined B+C as the outer rel.  have_join_order_restriction() 
 * ensures that we will consider making such a join even if there are not 
 * other reasons to do so.) 
 * 
 * So we check whether any PHVs used in the query could pose such a hazard. 
 * We don't have any simple way of checking whether a risky PHV would actually 
 * be used in the inner plan, and the case is so unusual that it doesn't seem 
 * worth working very hard on it. 
 * 
 * This needs to be checked in two places.  If the inner rel's minimum 
 * parameterization would trigger the restriction, then join_is_legal() should 
 * reject the join altogether, because there will be no workable paths for it. 
 * But joinpath.c has to check again for every proposed nestloop path, because 
 * the inner path might have more than the minimum parameterization, causing 
 * some PHV to be dangerous for it that otherwise wouldn't be. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN1151"></a><span class='Declare_Function'>have_dangerous_phv</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN1152"></a>                   <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Declare_Parameter'>outer_relids</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Declare_Parameter'>inner_params</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1154"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN1154"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN1151"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN257"><span class='Ref_to_Member'>placeholder_list</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1158"></a>        <a href="../../../include/nodes/relation.h.html#LN2057"><span class='Ref_to_Struct'>PlaceHolderInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>phinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN2057"><span class='Ref_to_Struct'>PlaceHolderInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN1154"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN1158"><span class='Ref_To_Local'>phinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2063"><span class='Ref_to_Member'>ph_eval_at</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN1152"><span class='Ref_to_Parameter'>inner_params</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* ignore, could not be a nestloop param */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN1158"><span class='Ref_To_Local'>phinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2063"><span class='Ref_to_Member'>ph_eval_at</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN1152"><span class='Ref_to_Parameter'>outer_relids</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* ignore, not relevant to this join */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN1158"><span class='Ref_To_Local'>phinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2063"><span class='Ref_to_Member'>ph_eval_at</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN1152"><span class='Ref_to_Parameter'>outer_relids</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* safe, it can be eval'd within outerrel */ 
</span>        <span class='Comment_Multi_Line'>/* Otherwise, it's potentially unsafe, so reject the join */ 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* OK to perform the join */ 
</span>    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end have_dangerous_phv &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * is_dummy_rel --- has relation been proven empty? 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN1179"></a><span class='Declare_Function'>is_dummy_rel</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>return</span> <a href="../../../include/nodes/relation.h.html#LN1186"><span class='Ref_to_Macro'>IS_DUMMY_REL</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN1179"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Mark a relation as proven empty. 
 * 
 * During GEQO planning, this can get invoked more than once on the same 
 * baserel struct, so it's worth checking to see if the rel is already marked 
 * dummy. 
 * 
 * Also, when called during GEQO join planning, we are in a short-lived 
 * memory context.  We must make sure that the dummy path attached to a 
 * baserel survives the GEQO cycle, else the baserel is trashed for future 
 * GEQO cycles.  On the other hand, when we are marking a joinrel during GEQO, 
 * we don't want the dummy path to clutter the main planning context.  Upshot 
 * is that the best solution is to explicitly make the dummy path in the same 
 * context the given RelOptInfo is in. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1200"></a><span class='Declare_Function'>mark_dummy_rel</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1202"></a>    <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>oldcontext</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Already marked? */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN30"><span class='Ref_to_Proto'>is_dummy_rel</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN1200"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* No, so choose correct context to make the dummy path in */ 
</span>    <a href="joinrels.c.html#LN1202"><span class='Ref_To_Local'>oldcontext</span></a> <span class='Operator'>= </span><a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/memutils.h.html#LN105"><span class='Ref_to_Func'>GetMemoryChunkContext</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN1200"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Set dummy size estimate */ 
</span>    <a href="joinrels.c.html#LN1200"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Evict any previously chosen paths */ 
</span>    <a href="joinrels.c.html#LN1200"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN538"><span class='Ref_to_Member'>pathlist</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="joinrels.c.html#LN1200"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN540"><span class='Ref_to_Member'>partial_pathlist</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Set up the dummy path */ 
</span>    <a href="../../../include/optimizer/pathnode.h.html#LN27"><span class='Ref_to_Proto'>add_path</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN1200"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/optimizer/pathnode.h.html#LN65"><span class='Ref_to_Proto'>create_append_path</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN1200"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Set or update cheapest_total_path and related fields */ 
</span>    <a href="../../../include/optimizer/pathnode.h.html#LN26"><span class='Ref_to_Proto'>set_cheapest</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN1200"><span class='Ref_to_Parameter'>rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN1202"><span class='Ref_To_Local'>oldcontext</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end mark_dummy_rel &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * restriction_is_constant_false --- is a restrictlist just FALSE? 
 * 
 * In cases where a qual is provably constant FALSE, eval_const_expressions 
 * will generally have thrown away anything that's ANDed with it.  In outer 
 * join situations this will leave us computing cartesian products only to 
 * decide there's no match for an outer row, which is pretty stupid.  So, 
 * we need to detect the case. 
 * 
 * If only_pushed_down is TRUE, then consider only pushed-down quals. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN1240"></a><span class='Declare_Function'>restriction_is_constant_false</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>restrictlist</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>only_pushed_down</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1242"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Despite the above comment, the restriction list we see here might 
     * possibly have other members besides the FALSE constant, since other 
     * quals could get "pushed down" to the outer join level.  So we check 
     * each member of the list. 
     */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN1242"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN1240"><span class='Ref_to_Parameter'>restrictlist</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1252"></a>        <a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rinfo</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN108"><span class='Ref_to_Macro'>lfirst_node</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a><span class='Delimiter'>, </span><a href="joinrels.c.html#LN1242"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN1240"><span class='Ref_to_Parameter'>only_pushed_down</span></a> <span class='Operator'>&& !</span><a href="joinrels.c.html#LN1252"><span class='Ref_To_Local'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1748"><span class='Ref_to_Member'>is_pushed_down</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN1252"><span class='Ref_To_Local'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1746"><span class='Ref_to_Member'>clause</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN1252"><span class='Ref_To_Local'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1746"><span class='Ref_to_Member'>clause</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN1259"></a>            <a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>con</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="joinrels.c.html#LN1252"><span class='Ref_To_Local'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1746"><span class='Ref_to_Member'>clause</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* constant NULL is as good as constant FALSE for our purposes */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="joinrels.c.html#LN1259"><span class='Ref_To_Local'>con</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN196"><span class='Ref_to_Member'>constisnull</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/postgres.h.html#LN398"><span class='Ref_to_Macro'>DatumGetBool</span></a><span class='Parentheses'>(</span><a href="joinrels.c.html#LN1259"><span class='Ref_To_Local'>con</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN195"><span class='Ref_to_Member'>constvalue</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end restriction_is_constant_false &raquo; </span> 
</pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>