<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\optimizer\plan\analyzejoins.c</title>
<LINK REL=StyleSheet HREF="../../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\optimizer\plan\analyzejoins.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:42 2017
</td></tr>
<tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
</span><span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * analyzejoins.c 
 *    Routines for simplifying joins after initial query analysis 
 * 
 * While we do a great deal of join simplification in prep/prepjointree.c, 
 * certain optimizations cannot be performed at that stage for lack of 
 * detailed information about the query.  The routines here are invoked 
 * after initsplan.c has done its work, and can do additional join removal 
 * and simplification steps based on the information extracted.  The penalty 
 * is that we have to work harder to clean up after ourselves when we modify 
 * the query, since the derived data structures have to be updated too. 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * 
 * IDENTIFICATION 
 *    src/backend/optimizer/plan/analyzejoins.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"nodes/nodeFuncs.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/clauses.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/joininfo.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/pathnode.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/paths.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/planmain.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/tlist.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/var.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/lsyscache.h"</span> 
 
<span class='Comment_Multi_Line'>/* local functions */ 
</span><a name="LN35"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>join_is_removable</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sjinfo</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN36"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>remove_rel_from_query</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>relid</span><span class='Delimiter'>, 
</span><a name="LN37"></a>                      <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Declare_Parameter'>joinrelids</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN38"></a><span class='Keyword'>static </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>remove_rel_from_joinlist</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>joinlist</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>relid</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Operator'>*</span><span class='Declare_Parameter'>nremoved</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN39"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>rel_supports_distinctness</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN40"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>rel_is_distinct_for</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, 
</span><a name="LN41"></a>                    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause_list</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN42"></a><span class='Keyword'>static </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>  <span class='Declare_Prototype'>distinct_col_search</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>colno</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>colnos</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>opids</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN43"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>is_innerrel_unique_for</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN44"></a>                       <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Declare_Parameter'>outerrelids</span><span class='Delimiter'>, 
</span><a name="LN45"></a>                       <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>innerrel</span><span class='Delimiter'>, 
</span><a name="LN46"></a>                       <a href="../../../include/nodes/nodes.h.html#LN671"><span class='Ref_to_Enum'>JoinType</span></a> <span class='Declare_Parameter'>jointype</span><span class='Delimiter'>, 
</span><a name="LN47"></a>                       <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>restrictlist</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * remove_useless_joins 
 *      Check for relations that don't actually need to be joined at all, 
 *      and remove them from the query. 
 * 
 * We are passed the current joinlist and return the updated list.  Other 
 * data structures that have to be updated are accessible via "root". 
 */ 
</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN59"></a><span class='Declare_Function'>remove_useless_joins</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>joinlist</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN61"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We are only interested in relations that are left-joined to, so we can 
     * scan the join_info_list to find them easily. 
     */ 
</span><a name="LN67"></a><span class='Label'>restart</span><span class='Operator'>: 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN61"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN59"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN249"><span class='Ref_to_Member'>join_info_list</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN70"></a>        <a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sjinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN61"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN71"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>innerrelid</span><span class='Delimiter'>; 
</span><a name="LN72"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>nremoved</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Skip if not removable */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="analyzejoins.c.html#LN35"><span class='Ref_to_Proto'>join_is_removable</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN59"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN70"><span class='Ref_To_Local'>sjinfo</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Currently, join_is_removable can only succeed when the sjinfo's 
         * righthand is a single baserel.  Remove that rel from the query and 
         * joinlist. 
         */ 
</span>        <a href="analyzejoins.c.html#LN71"><span class='Ref_To_Local'>innerrelid</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN79"><span class='Ref_to_Proto'>bms_singleton_member</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN70"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1917"><span class='Ref_to_Member'>min_righthand</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="analyzejoins.c.html#LN36"><span class='Ref_to_Proto'>remove_rel_from_query</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN59"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN71"><span class='Ref_To_Local'>innerrelid</span></a><span class='Delimiter'>, 
</span>                              <a href="../../../include/nodes/bitmapset.h.html#LN70"><span class='Ref_to_Proto'>bms_union</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN70"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1916"><span class='Ref_to_Member'>min_lefthand</span></a><span class='Delimiter'>, 
</span>                                        <a href="analyzejoins.c.html#LN70"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1917"><span class='Ref_to_Member'>min_righthand</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* We verify that exactly one reference gets removed from joinlist */ 
</span>        <a href="analyzejoins.c.html#LN72"><span class='Ref_To_Local'>nremoved</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="analyzejoins.c.html#LN59"><span class='Ref_to_Parameter'>joinlist</span></a> <span class='Operator'>= </span><a href="analyzejoins.c.html#LN38"><span class='Ref_to_Proto'>remove_rel_from_joinlist</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN59"><span class='Ref_to_Parameter'>joinlist</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN71"><span class='Ref_To_Local'>innerrelid</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="analyzejoins.c.html#LN72"><span class='Ref_To_Local'>nremoved</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN72"><span class='Ref_To_Local'>nremoved</span></a> <span class='Operator'>!= </span><span class='Number'>1</span><span class='Parentheses'>) 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"failed to find relation %d in joinlist"</span><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN71"><span class='Ref_To_Local'>innerrelid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We can delete this SpecialJoinInfo from the list too, since it's no 
         * longer of interest. 
         */ 
</span>        <a href="analyzejoins.c.html#LN59"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN249"><span class='Ref_to_Member'>join_info_list</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN234"><span class='Ref_to_Proto'>list_delete_ptr</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN59"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN249"><span class='Ref_to_Member'>join_info_list</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN70"><span class='Ref_To_Local'>sjinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Restart the scan.  This is necessary to ensure we find all 
         * removable joins independently of ordering of the join_info_list 
         * (note that removal of attr_needed bits may make a join appear 
         * removable that did not before).  Also, since we just deleted the 
         * current list cell, we'd have to have some kluge to continue the 
         * list scan anyway. 
         */ 
</span>        <span class='Control'>goto</span> <span class='Symbol_Characters'>&uarr;</span><a href="analyzejoins.c.html#LN67"><span class='Ref_to_Label'>restart</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="analyzejoins.c.html#LN59"><span class='Ref_to_Parameter'>joinlist</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end remove_useless_joins &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * clause_sides_match_join 
 *    Determine whether a join clause is of the right form to use in this join. 
 * 
 * We already know that the clause is a binary opclause referencing only the 
 * rels in the current join.  The point here is to check whether it has the 
 * form "outerrel_expr op innerrel_expr" or "innerrel_expr op outerrel_expr", 
 * rather than mixing outer and inner vars on either side.  If it matches, 
 * we set the transient flag outer_is_left to identify which side is which. 
 */ 
</span><span class='Keyword'>static inline bool 
</span><a name="LN126"></a><span class='Declare_Function'>clause_sides_match_join</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rinfo</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Declare_Parameter'>outerrelids</span><span class='Delimiter'>, 
</span><a name="LN127"></a>                        <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Declare_Parameter'>innerrelids</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN126"><span class='Ref_to_Parameter'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1773"><span class='Ref_to_Member'>left_relids</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN126"><span class='Ref_to_Parameter'>outerrelids</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>        <a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN126"><span class='Ref_to_Parameter'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1774"><span class='Ref_to_Member'>right_relids</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN127"><span class='Ref_to_Parameter'>innerrelids</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* lefthand side is outer */ 
</span>        <a href="analyzejoins.c.html#LN126"><span class='Ref_to_Parameter'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1801"><span class='Ref_to_Member'>outer_is_left</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN126"><span class='Ref_to_Parameter'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1773"><span class='Ref_to_Member'>left_relids</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN127"><span class='Ref_to_Parameter'>innerrelids</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>             <a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN126"><span class='Ref_to_Parameter'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1774"><span class='Ref_to_Member'>right_relids</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN126"><span class='Ref_to_Parameter'>outerrelids</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* righthand side is outer */ 
</span>        <a href="analyzejoins.c.html#LN126"><span class='Ref_to_Parameter'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1801"><span class='Ref_to_Member'>outer_is_left</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>               <span class='Comment_Single_Line'>/* no good for these input relations */ 
</span><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end clause_sides_match_join &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * join_is_removable 
 *    Check whether we need not perform this special join at all, because 
 *    it will just duplicate its left input. 
 * 
 * This is true for a left join for which the join condition cannot match 
 * more than one inner-side row.  (There are other possibly interesting 
 * cases, but we don't have the infrastructure to prove them.)  We also 
 * have to check that the inner side doesn't generate any variables needed 
 * above the join. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN158"></a><span class='Declare_Function'>join_is_removable</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sjinfo</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN160"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>innerrelid</span><span class='Delimiter'>; 
</span><a name="LN161"></a>    <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>innerrel</span><span class='Delimiter'>; 
</span><a name="LN162"></a>    <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>joinrelids</span><span class='Delimiter'>; 
</span><a name="LN163"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>clause_list</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN164"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span><a name="LN165"></a>    <span class='Keyword'>int</span>         <span class='Declare_Local'>attroff</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Must be a non-delaying left join to a single baserel, else we aren't 
     * going to be able to do anything with it. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN158"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1920"><span class='Ref_to_Member'>jointype</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/nodes.h.html#LN678"><span class='Ref_to_EnumConst'>JOIN_LEFT</span></a> <span class='Operator'>|| 
</span>        <a href="analyzejoins.c.html#LN158"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1922"><span class='Ref_to_Member'>delay_upper_joins</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN80"><span class='Ref_to_Proto'>bms_get_singleton_member</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN158"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1917"><span class='Ref_to_Member'>min_righthand</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="analyzejoins.c.html#LN160"><span class='Ref_To_Local'>innerrelid</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <a href="analyzejoins.c.html#LN161"><span class='Ref_To_Local'>innerrel</span></a> <span class='Operator'>= </span><a href="../util/relnode.c.html#LN241"><span class='Ref_to_Func'>find_base_rel</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN158"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN160"><span class='Ref_To_Local'>innerrelid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Before we go to the effort of checking whether any innerrel variables 
     * are needed above the join, make a quick check to eliminate cases in 
     * which we will surely be unable to prove uniqueness of the innerrel. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="analyzejoins.c.html#LN39"><span class='Ref_to_Proto'>rel_supports_distinctness</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN158"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN161"><span class='Ref_To_Local'>innerrel</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Compute the relid set for the join we are considering */ 
</span>    <a href="analyzejoins.c.html#LN162"><span class='Ref_To_Local'>joinrelids</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN70"><span class='Ref_to_Proto'>bms_union</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN158"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1916"><span class='Ref_to_Member'>min_lefthand</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN158"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1917"><span class='Ref_to_Member'>min_righthand</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We can't remove the join if any inner-rel attributes are used above the 
     * join. 
     * 
     * Note that this test only detects use of inner-rel attributes in higher 
     * join conditions and the target list.  There might be such attributes in 
     * pushed-down conditions at this join, too.  We check that case below. 
     * 
     * As a micro-optimization, it seems better to start with max_attr and 
     * count down rather than starting with min_attr and counting up, on the 
     * theory that the system attributes are somewhat less likely to be wanted 
     * and should be tested last. 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN165"><span class='Ref_To_Local'>attroff</span></a> <span class='Operator'>= </span><a href="analyzejoins.c.html#LN161"><span class='Ref_To_Local'>innerrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN556"><span class='Ref_to_Member'>max_attr</span></a> <span class='Operator'>- </span><a href="analyzejoins.c.html#LN161"><span class='Ref_To_Local'>innerrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN555"><span class='Ref_to_Member'>min_attr</span></a><span class='Delimiter'>; 
</span>         <a href="analyzejoins.c.html#LN165"><span class='Ref_To_Local'>attroff</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>         <a href="analyzejoins.c.html#LN165"><span class='Ref_To_Local'>attroff</span></a><span class='Operator'>--</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN161"><span class='Ref_To_Local'>innerrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN557"><span class='Ref_to_Member'>attr_needed</span></a><span class='Delimiter'>[</span><a href="analyzejoins.c.html#LN165"><span class='Ref_To_Local'>attroff</span></a><span class='Delimiter'>], </span><a href="analyzejoins.c.html#LN162"><span class='Ref_To_Local'>joinrelids</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Similarly check that the inner rel isn't needed by any PlaceHolderVars 
     * that will be used above the join.  We only need to fail if such a PHV 
     * actually references some inner-rel attributes; but the correct check 
     * for that is relatively expensive, so we first check against ph_eval_at, 
     * which must mention the inner rel if the PHV uses any inner-rel attrs as 
     * non-lateral references.  Note that if the PHV's syntactic scope is just 
     * the inner rel, we can't drop the rel even if the PHV is variable-free. 
     */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN164"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN158"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN257"><span class='Ref_to_Member'>placeholder_list</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN223"></a>        <a href="../../../include/nodes/relation.h.html#LN2057"><span class='Ref_to_Struct'>PlaceHolderInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>phinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN2057"><span class='Ref_to_Struct'>PlaceHolderInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN164"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN223"><span class='Ref_To_Local'>phinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2064"><span class='Ref_to_Member'>ph_lateral</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN161"><span class='Ref_To_Local'>innerrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* it references innerrel laterally */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN223"><span class='Ref_To_Local'>phinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2065"><span class='Ref_to_Member'>ph_needed</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN162"><span class='Ref_To_Local'>joinrelids</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* PHV is not used above the join */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN223"><span class='Ref_To_Local'>phinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2063"><span class='Ref_to_Member'>ph_eval_at</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN161"><span class='Ref_To_Local'>innerrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* it definitely doesn't reference innerrel */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN223"><span class='Ref_To_Local'>phinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2063"><span class='Ref_to_Member'>ph_eval_at</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN161"><span class='Ref_To_Local'>innerrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* there isn't any other place to eval PHV */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="../../../include/optimizer/var.h.html#LN29"><span class='Ref_to_Proto'>pull_varnos</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyzejoins.c.html#LN223"><span class='Ref_To_Local'>phinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2062"><span class='Ref_to_Member'>ph_var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1849"><span class='Ref_to_Member'>phexpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                        <a href="analyzejoins.c.html#LN161"><span class='Ref_To_Local'>innerrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>;</span>       <span class='Comment_Single_Line'>/* it does reference innerrel */ 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Search for mergejoinable clauses that constrain the inner rel against 
     * either the outer rel or a pseudoconstant.  If an operator is 
     * mergejoinable then it behaves like equality for some btree opclass, so 
     * it's what we want.  The mergejoinability test also eliminates clauses 
     * containing volatile functions, which we couldn't depend on. 
     */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN164"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN161"><span class='Ref_To_Local'>innerrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN588"><span class='Ref_to_Member'>joininfo</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN247"></a>        <a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>restrictinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN164"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If it's not a join clause for this outer join, we can't use it. 
         * Note that if the clause is pushed-down, then it is logically from 
         * above the outer join, even if it references no other rels (it might 
         * be from WHERE, for example). 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN247"><span class='Ref_To_Local'>restrictinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1748"><span class='Ref_to_Member'>is_pushed_down</span></a> <span class='Operator'>|| 
</span>            <span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN66"><span class='Ref_to_Proto'>bms_equal</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN247"><span class='Ref_To_Local'>restrictinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1764"><span class='Ref_to_Member'>required_relids</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN162"><span class='Ref_To_Local'>joinrelids</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * If such a clause actually references the inner rel then join 
             * removal has to be disallowed.  We have to check this despite 
             * the previous attr_needed checks because of the possibility of 
             * pushed-down clauses referencing the rel. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN75"><span class='Ref_to_Proto'>bms_is_member</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN160"><span class='Ref_To_Local'>innerrelid</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN247"><span class='Ref_To_Local'>restrictinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1761"><span class='Ref_to_Member'>clause_relids</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>            <span class='Control'>continue</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* else, ignore; not useful here */ 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* Ignore if it's not a mergejoinable clause */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="analyzejoins.c.html#LN247"><span class='Ref_To_Local'>restrictinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1752"><span class='Ref_to_Member'>can_join</span></a> <span class='Operator'>|| 
</span>            <a href="analyzejoins.c.html#LN247"><span class='Ref_To_Local'>restrictinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1791"><span class='Ref_to_Member'>mergeopfamilies</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* not mergejoinable */ 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Check if clause has the form "outer op inner" or "inner op outer", 
         * and if so mark which side is inner. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="analyzejoins.c.html#LN125"><span class='Ref_to_Func'>clause_sides_match_join</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN247"><span class='Ref_To_Local'>restrictinfo</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN158"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1916"><span class='Ref_to_Member'>min_lefthand</span></a><span class='Delimiter'>, 
</span>                                     <a href="analyzejoins.c.html#LN161"><span class='Ref_To_Local'>innerrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* no good for these input relations */ 
</span> 
        <span class='Comment_Multi_Line'>/* OK, add to list */ 
</span>        <a href="analyzejoins.c.html#LN163"><span class='Ref_To_Local'>clause_list</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN163"><span class='Ref_To_Local'>clause_list</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN247"><span class='Ref_To_Local'>restrictinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now that we have the relevant equality join clauses, try to prove the 
     * innerrel distinct. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN40"><span class='Ref_to_Proto'>rel_is_distinct_for</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN158"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN161"><span class='Ref_To_Local'>innerrel</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN163"><span class='Ref_To_Local'>clause_list</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Some day it would be nice to check for other methods of establishing 
     * distinctness. 
     */ 
</span>    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end join_is_removable &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * Remove the target relid from the planner's data structures, having 
 * determined that there is no need to include it in the query. 
 * 
 * We are not terribly thorough here.  We must make sure that the rel is 
 * no longer treated as a baserel, and that attributes of other baserels 
 * are no longer marked as being needed at joins involving this rel. 
 * Also, join quals involving the rel have to be removed from the joininfo 
 * lists, but only if they belong to the outer join identified by joinrelids. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN312"></a><span class='Declare_Function'>remove_rel_from_query</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>relid</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Declare_Parameter'>joinrelids</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN314"></a>    <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rel</span> <span class='Operator'>= </span><a href="../util/relnode.c.html#LN241"><span class='Ref_to_Func'>find_base_rel</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN312"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN312"><span class='Ref_to_Parameter'>relid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN315"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>joininfos</span><span class='Delimiter'>; 
</span><a name="LN316"></a>    <a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Local'>rti</span><span class='Delimiter'>; 
</span><a name="LN317"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span><a name="LN318"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>nextl</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Mark the rel as "dead" to show it is no longer part of the join tree. 
     * (Removing it from the baserel array altogether seems too risky.) 
     */ 
</span>    <a href="analyzejoins.c.html#LN314"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN521"><span class='Ref_to_Member'>reloptkind</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/relation.h.html#LN497"><span class='Ref_to_EnumConst'>RELOPT_DEADREL</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Remove references to the rel from other baserels' attr_needed arrays. 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN316"><span class='Ref_To_Local'>rti</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="analyzejoins.c.html#LN316"><span class='Ref_To_Local'>rti</span></a> <span class='Operator'>&LT; </span><a href="analyzejoins.c.html#LN312"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN179"><span class='Ref_to_Member'>simple_rel_array_size</span></a><span class='Delimiter'>; </span><a href="analyzejoins.c.html#LN316"><span class='Ref_To_Local'>rti</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN331"></a>        <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>otherrel</span> <span class='Operator'>= </span><a href="analyzejoins.c.html#LN312"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN178"><span class='Ref_to_Member'>simple_rel_array</span></a><span class='Delimiter'>[</span><a href="analyzejoins.c.html#LN316"><span class='Ref_To_Local'>rti</span></a><span class='Delimiter'>]; 
</span><a name="LN332"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>attroff</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* there may be empty slots corresponding to non-baserel RTEs */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN331"><span class='Ref_To_Local'>otherrel</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN331"><span class='Ref_To_Local'>otherrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a> <span class='Operator'>== </span><a href="analyzejoins.c.html#LN316"><span class='Ref_To_Local'>rti</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* sanity check on array */ 
</span> 
        <span class='Comment_Multi_Line'>/* no point in processing target rel itself */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN331"><span class='Ref_To_Local'>otherrel</span></a> <span class='Operator'>== </span><a href="analyzejoins.c.html#LN314"><span class='Ref_To_Local'>rel</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN332"><span class='Ref_To_Local'>attroff</span></a> <span class='Operator'>= </span><a href="analyzejoins.c.html#LN331"><span class='Ref_To_Local'>otherrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN556"><span class='Ref_to_Member'>max_attr</span></a> <span class='Operator'>- </span><a href="analyzejoins.c.html#LN331"><span class='Ref_To_Local'>otherrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN555"><span class='Ref_to_Member'>min_attr</span></a><span class='Delimiter'>; 
</span>             <a href="analyzejoins.c.html#LN332"><span class='Ref_To_Local'>attroff</span></a> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>             <a href="analyzejoins.c.html#LN332"><span class='Ref_To_Local'>attroff</span></a><span class='Operator'>--</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="analyzejoins.c.html#LN331"><span class='Ref_To_Local'>otherrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN557"><span class='Ref_to_Member'>attr_needed</span></a><span class='Delimiter'>[</span><a href="analyzejoins.c.html#LN332"><span class='Ref_To_Local'>attroff</span></a><span class='Delimiter'>] </span><span class='Operator'>= 
</span>                <a href="../../../include/nodes/bitmapset.h.html#LN90"><span class='Ref_to_Proto'>bms_del_member</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN331"><span class='Ref_To_Local'>otherrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN557"><span class='Ref_to_Member'>attr_needed</span></a><span class='Delimiter'>[</span><a href="analyzejoins.c.html#LN332"><span class='Ref_To_Local'>attroff</span></a><span class='Delimiter'>], </span><a href="analyzejoins.c.html#LN312"><span class='Ref_to_Parameter'>relid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for rti=1;rti&LT;root-&GT;simpl... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Likewise remove references from SpecialJoinInfo data structures. 
     * 
     * This is relevant in case the outer join we're deleting is nested inside 
     * other outer joins: the upper joins' relid sets have to be adjusted. The 
     * RHS of the target outer join will be made empty here, but that's OK 
     * since caller will delete that SpecialJoinInfo entirely. 
     */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN317"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN312"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN249"><span class='Ref_to_Member'>join_info_list</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN363"></a>        <a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sjinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN317"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="analyzejoins.c.html#LN363"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1916"><span class='Ref_to_Member'>min_lefthand</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN90"><span class='Ref_to_Proto'>bms_del_member</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN363"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1916"><span class='Ref_to_Member'>min_lefthand</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN312"><span class='Ref_to_Parameter'>relid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="analyzejoins.c.html#LN363"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1917"><span class='Ref_to_Member'>min_righthand</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN90"><span class='Ref_to_Proto'>bms_del_member</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN363"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1917"><span class='Ref_to_Member'>min_righthand</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN312"><span class='Ref_to_Parameter'>relid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="analyzejoins.c.html#LN363"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1918"><span class='Ref_to_Member'>syn_lefthand</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN90"><span class='Ref_to_Proto'>bms_del_member</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN363"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1918"><span class='Ref_to_Member'>syn_lefthand</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN312"><span class='Ref_to_Parameter'>relid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="analyzejoins.c.html#LN363"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1919"><span class='Ref_to_Member'>syn_righthand</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN90"><span class='Ref_to_Proto'>bms_del_member</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN363"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1919"><span class='Ref_to_Member'>syn_righthand</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN312"><span class='Ref_to_Parameter'>relid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Likewise remove references from PlaceHolderVar data structures, 
     * removing any no-longer-needed placeholders entirely. 
     * 
     * Removal is a bit tricker than it might seem: we can remove PHVs that 
     * are used at the target rel and/or in the join qual, but not those that 
     * are used at join partner rels or above the join.  It's not that easy to 
     * distinguish PHVs used at partner rels from those used in the join qual, 
     * since they will both have ph_needed sets that are subsets of 
     * joinrelids.  However, a PHV used at a partner rel could not have the 
     * target rel in ph_eval_at, so we check that while deciding whether to 
     * remove or just update the PHV.  There is no corresponding test in 
     * join_is_removable because it doesn't need to distinguish those cases. 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN317"><span class='Ref_To_Local'>l</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN312"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN257"><span class='Ref_to_Member'>placeholder_list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; </span><a href="analyzejoins.c.html#LN317"><span class='Ref_To_Local'>l</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; </span><a href="analyzejoins.c.html#LN317"><span class='Ref_To_Local'>l</span></a> <span class='Operator'>= </span><a href="analyzejoins.c.html#LN318"><span class='Ref_To_Local'>nextl</span></a><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span><a name="LN387"></a>        <a href="../../../include/nodes/relation.h.html#LN2057"><span class='Ref_to_Struct'>PlaceHolderInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>phinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN2057"><span class='Ref_to_Struct'>PlaceHolderInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN317"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="analyzejoins.c.html#LN318"><span class='Ref_To_Local'>nextl</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN317"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN75"><span class='Ref_to_Proto'>bms_is_member</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN312"><span class='Ref_to_Parameter'>relid</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN387"><span class='Ref_To_Local'>phinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2064"><span class='Ref_to_Member'>ph_lateral</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN387"><span class='Ref_To_Local'>phinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2065"><span class='Ref_to_Member'>ph_needed</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN312"><span class='Ref_to_Parameter'>joinrelids</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>            <a href="../../../include/nodes/bitmapset.h.html#LN75"><span class='Ref_to_Proto'>bms_is_member</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN312"><span class='Ref_to_Parameter'>relid</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN387"><span class='Ref_To_Local'>phinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2063"><span class='Ref_to_Member'>ph_eval_at</span></a><span class='Parentheses'>))</span> 
            <a href="analyzejoins.c.html#LN312"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN257"><span class='Ref_to_Member'>placeholder_list</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN234"><span class='Ref_to_Proto'>list_delete_ptr</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN312"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN257"><span class='Ref_to_Member'>placeholder_list</span></a><span class='Delimiter'>, 
</span>                                                     <a href="analyzejoins.c.html#LN387"><span class='Ref_To_Local'>phinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <a href="analyzejoins.c.html#LN387"><span class='Ref_To_Local'>phinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2063"><span class='Ref_to_Member'>ph_eval_at</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN90"><span class='Ref_to_Proto'>bms_del_member</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN387"><span class='Ref_To_Local'>phinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2063"><span class='Ref_to_Member'>ph_eval_at</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN312"><span class='Ref_to_Parameter'>relid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN85"><span class='Ref_to_Proto'>bms_is_empty</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN387"><span class='Ref_To_Local'>phinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2063"><span class='Ref_to_Member'>ph_eval_at</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="analyzejoins.c.html#LN387"><span class='Ref_To_Local'>phinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2065"><span class='Ref_to_Member'>ph_needed</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN90"><span class='Ref_to_Proto'>bms_del_member</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN387"><span class='Ref_To_Local'>phinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2065"><span class='Ref_to_Member'>ph_needed</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN312"><span class='Ref_to_Parameter'>relid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Remove any joinquals referencing the rel from the joininfo lists. 
     * 
     * In some cases, a joinqual has to be put back after deleting its 
     * reference to the target rel.  This can occur for pseudoconstant and 
     * outerjoin-delayed quals, which can get marked as requiring the rel in 
     * order to force them to be evaluated at or above the join.  We can't 
     * just discard them, though.  Only quals that logically belonged to the 
     * outer join being discarded should be removed from the query. 
     * 
     * We must make a copy of the rel's old joininfo list before starting the 
     * loop, because otherwise remove_join_clause_from_rels would destroy the 
     * list while we're scanning it. 
     */ 
</span>    <a href="analyzejoins.c.html#LN315"><span class='Ref_To_Local'>joininfos</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN268"><span class='Ref_to_Proto'>list_copy</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN314"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN588"><span class='Ref_to_Member'>joininfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN317"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN315"><span class='Ref_To_Local'>joininfos</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN420"></a>        <a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN317"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/optimizer/joininfo.h.html#LN25"><span class='Ref_to_Proto'>remove_join_clause_from_rels</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN312"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN420"><span class='Ref_To_Local'>rinfo</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN420"><span class='Ref_To_Local'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1764"><span class='Ref_to_Member'>required_relids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN420"><span class='Ref_To_Local'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1748"><span class='Ref_to_Member'>is_pushed_down</span></a> <span class='Operator'>|| 
</span>            <span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN66"><span class='Ref_to_Proto'>bms_equal</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN420"><span class='Ref_To_Local'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1764"><span class='Ref_to_Member'>required_relids</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN312"><span class='Ref_to_Parameter'>joinrelids</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Recheck that qual doesn't actually reference the target rel */ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN75"><span class='Ref_to_Proto'>bms_is_member</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN312"><span class='Ref_to_Parameter'>relid</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN420"><span class='Ref_To_Local'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1761"><span class='Ref_to_Member'>clause_relids</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * The required_relids probably aren't shared with anything else, 
             * but let's copy them just to be sure. 
             */ 
</span>            <a href="analyzejoins.c.html#LN420"><span class='Ref_To_Local'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1764"><span class='Ref_to_Member'>required_relids</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN65"><span class='Ref_to_Proto'>bms_copy</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN420"><span class='Ref_To_Local'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1764"><span class='Ref_to_Member'>required_relids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="analyzejoins.c.html#LN420"><span class='Ref_To_Local'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1764"><span class='Ref_to_Member'>required_relids</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN90"><span class='Ref_to_Proto'>bms_del_member</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN420"><span class='Ref_To_Local'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1764"><span class='Ref_to_Member'>required_relids</span></a><span class='Delimiter'>, 
</span>                                                    <a href="analyzejoins.c.html#LN312"><span class='Ref_to_Parameter'>relid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/optimizer/planmain.h.html#LN80"><span class='Ref_to_Proto'>distribute_restrictinfo_to_rels</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN312"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN420"><span class='Ref_To_Local'>rinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * There may be references to the rel in root-&GT;fkey_list, but if so, 
     * match_foreign_keys_to_quals() will get rid of them. 
     */ 
</span><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end remove_rel_from_query &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Remove any occurrences of the target relid from a joinlist structure. 
 * 
 * It's easiest to build a whole new list structure, so we handle it that 
 * way.  Efficiency is not a big deal here. 
 * 
 * *nremoved is incremented by the number of occurrences removed (there 
 * should be exactly one, but the caller checks that). 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN457"></a><span class='Declare_Function'>remove_rel_from_joinlist</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>joinlist</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Declare_Parameter'>relid</span><span class='Delimiter'>, </span><span class='Keyword'>int </span><span class='Operator'>*</span><span class='Declare_Parameter'>nremoved</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN459"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>result</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN460"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>jl</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN460"><span class='Ref_To_Local'>jl</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN457"><span class='Ref_to_Parameter'>joinlist</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN464"></a>        <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>jlnode</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN460"><span class='Ref_To_Local'>jl</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN464"><span class='Ref_To_Local'>jlnode</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN1415"><span class='Ref_to_Struct'>RangeTblRef</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN468"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>varno</span> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN1415"><span class='Ref_to_Struct'>RangeTblRef</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyzejoins.c.html#LN464"><span class='Ref_To_Local'>jlnode</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>rtindex<span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN468"><span class='Ref_To_Local'>varno</span></a> <span class='Operator'>== </span><a href="analyzejoins.c.html#LN457"><span class='Ref_to_Parameter'>relid</span></a><span class='Parentheses'>) 
</span>                <span class='Parentheses'>(</span><span class='Operator'>*</span><a href="analyzejoins.c.html#LN457"><span class='Ref_to_Parameter'>nremoved</span></a><span class='Parentheses'>)</span><span class='Operator'>++</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="analyzejoins.c.html#LN459"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN459"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN464"><span class='Ref_To_Local'>jlnode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN464"><span class='Ref_To_Local'>jlnode</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Recurse to handle subproblem */ 
</span><a name="LN478"></a>            <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>sublist</span><span class='Delimiter'>; 
</span> 
            <a href="analyzejoins.c.html#LN478"><span class='Ref_To_Local'>sublist</span></a> <span class='Operator'>= </span><a href="analyzejoins.c.html#LN38"><span class='Ref_to_Proto'>remove_rel_from_joinlist</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="analyzejoins.c.html#LN464"><span class='Ref_To_Local'>jlnode</span></a><span class='Delimiter'>, 
</span>                                               <a href="analyzejoins.c.html#LN457"><span class='Ref_to_Parameter'>relid</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN457"><span class='Ref_to_Parameter'>nremoved</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* Avoid including empty sub-lists in the result */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN478"><span class='Ref_To_Local'>sublist</span></a><span class='Parentheses'>) 
</span>                <a href="analyzejoins.c.html#LN459"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN459"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN478"><span class='Ref_To_Local'>sublist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized joinlist node type: %d"</span><span class='Delimiter'>, 
</span>                 <span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="../../../include/nodes/nodes.h.html#LN513"><span class='Ref_to_Macro'>nodeTag</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN464"><span class='Ref_To_Local'>jlnode</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <a href="analyzejoins.c.html#LN459"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end remove_rel_from_joinlist &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * reduce_unique_semijoins 
 *      Check for semijoins that can be simplified to plain inner joins 
 *      because the inner relation is provably unique for the join clauses. 
 * 
 * Ideally this would happen during reduce_outer_joins, but we don't have 
 * enough information at that point. 
 * 
 * To perform the strength reduction when applicable, we need only delete 
 * the semijoin's SpecialJoinInfo from root-&GT;join_info_list.  (We don't 
 * bother fixing the join type attributed to it in the query jointree, 
 * since that won't be consulted again.) 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN511"></a><span class='Declare_Function'>reduce_unique_semijoins</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN513"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span><a name="LN514"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>next</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Scan the join_info_list to find semijoins.  We can't use foreach 
     * because we may delete the current cell. 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN513"><span class='Ref_To_Local'>lc</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN511"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN249"><span class='Ref_to_Member'>join_info_list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; </span><a href="analyzejoins.c.html#LN513"><span class='Ref_To_Local'>lc</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; </span><a href="analyzejoins.c.html#LN513"><span class='Ref_To_Local'>lc</span></a> <span class='Operator'>= </span><a href="analyzejoins.c.html#LN514"><span class='Ref_To_Local'>next</span></a><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span><a name="LN522"></a>        <a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sjinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN513"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN523"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>innerrelid</span><span class='Delimiter'>; 
</span><a name="LN524"></a>        <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>innerrel</span><span class='Delimiter'>; 
</span><a name="LN525"></a>        <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>joinrelids</span><span class='Delimiter'>; 
</span><a name="LN526"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>restrictlist</span><span class='Delimiter'>; 
</span> 
        <a href="analyzejoins.c.html#LN514"><span class='Ref_To_Local'>next</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN513"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Must be a non-delaying semijoin to a single baserel, else we aren't 
         * going to be able to do anything with it.  (It's probably not 
         * possible for delay_upper_joins to be set on a semijoin, but we 
         * might as well check.) 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN522"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1920"><span class='Ref_to_Member'>jointype</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/nodes.h.html#LN691"><span class='Ref_to_EnumConst'>JOIN_SEMI</span></a> <span class='Operator'>|| 
</span>            <a href="analyzejoins.c.html#LN522"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1922"><span class='Ref_to_Member'>delay_upper_joins</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN80"><span class='Ref_to_Proto'>bms_get_singleton_member</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN522"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1917"><span class='Ref_to_Member'>min_righthand</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="analyzejoins.c.html#LN523"><span class='Ref_To_Local'>innerrelid</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <a href="analyzejoins.c.html#LN524"><span class='Ref_To_Local'>innerrel</span></a> <span class='Operator'>= </span><a href="../util/relnode.c.html#LN241"><span class='Ref_to_Func'>find_base_rel</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN511"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN523"><span class='Ref_To_Local'>innerrelid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Before we trouble to run generate_join_implied_equalities, make a 
         * quick check to eliminate cases in which we will surely be unable to 
         * prove uniqueness of the innerrel. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="analyzejoins.c.html#LN39"><span class='Ref_to_Proto'>rel_supports_distinctness</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN511"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN524"><span class='Ref_To_Local'>innerrel</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Compute the relid set for the join we are considering */ 
</span>        <a href="analyzejoins.c.html#LN525"><span class='Ref_To_Local'>joinrelids</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN70"><span class='Ref_to_Proto'>bms_union</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN522"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1916"><span class='Ref_to_Member'>min_lefthand</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN522"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1917"><span class='Ref_to_Member'>min_righthand</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Since we're only considering a single-rel RHS, any join clauses it 
         * has must be clauses linking it to the semijoin's min_lefthand.  We 
         * can also consider EC-derived join clauses. 
         */ 
</span>        <a href="analyzejoins.c.html#LN526"><span class='Ref_To_Local'>restrictlist</span></a> <span class='Operator'>= 
</span>            <a href="../../../include/nodes/pg_list.h.html#LN219"><span class='Ref_to_Proto'>list_concat</span></a><span class='Parentheses'>(</span><a href="../../../include/optimizer/paths.h.html#LN139"><span class='Ref_to_Proto'>generate_join_implied_equalities</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN511"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                                         <a href="analyzejoins.c.html#LN525"><span class='Ref_To_Local'>joinrelids</span></a><span class='Delimiter'>, 
</span>                                                         <a href="analyzejoins.c.html#LN522"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1916"><span class='Ref_to_Member'>min_lefthand</span></a><span class='Delimiter'>, 
</span>                                                         <a href="analyzejoins.c.html#LN524"><span class='Ref_To_Local'>innerrel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                        <a href="analyzejoins.c.html#LN524"><span class='Ref_To_Local'>innerrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN588"><span class='Ref_to_Member'>joininfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Test whether the innerrel is unique for those clauses. */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/optimizer/planmain.h.html#LN108"><span class='Ref_to_Proto'>innerrel_is_unique</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN511"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN522"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1916"><span class='Ref_to_Member'>min_lefthand</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN524"><span class='Ref_To_Local'>innerrel</span></a><span class='Delimiter'>, 
</span>                                <a href="../../../include/nodes/nodes.h.html#LN691"><span class='Ref_to_EnumConst'>JOIN_SEMI</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN526"><span class='Ref_To_Local'>restrictlist</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* OK, remove the SpecialJoinInfo from the list. */ 
</span>        <a href="analyzejoins.c.html#LN511"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN249"><span class='Ref_to_Member'>join_info_list</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN234"><span class='Ref_to_Proto'>list_delete_ptr</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN511"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN249"><span class='Ref_to_Member'>join_info_list</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN522"><span class='Ref_To_Local'>sjinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for lc=list_head(root-&GT;jo... &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end reduce_unique_semijoins &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * rel_supports_distinctness 
 *      Could the relation possibly be proven distinct on some set of columns? 
 * 
 * This is effectively a pre-checking function for rel_is_distinct_for(). 
 * It must return TRUE if rel_is_distinct_for() could possibly return TRUE 
 * with this rel, but it should not expend a lot of cycles.  The idea is 
 * that callers can avoid doing possibly-expensive processing to compute 
 * rel_is_distinct_for()'s argument lists if the call could not possibly 
 * succeed. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN591"></a><span class='Declare_Function'>rel_supports_distinctness</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* We only know about baserels ... */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN591"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN521"><span class='Ref_to_Member'>reloptkind</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/relation.h.html#LN493"><span class='Ref_to_EnumConst'>RELOPT_BASEREL</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN591"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN554"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/parsenodes.h.html#LN922"><span class='Ref_to_EnumConst'>RTE_RELATION</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * For a plain relation, we only know how to prove uniqueness by 
         * reference to unique indexes.  Make sure there's at least one 
         * suitable unique index.  It must be immediately enforced, and if 
         * it's a partial index, it must match the query.  (Keep these 
         * conditions in sync with relation_has_unique_index_for!) 
         */ 
</span><a name="LN605"></a>        <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN605"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN591"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN561"><span class='Ref_to_Member'>indexlist</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN609"></a>            <a href="../../../include/nodes/relation.h.html#LN626"><span class='Ref_to_Struct'>IndexOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>ind</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN626"><span class='Ref_to_Struct'>IndexOptInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN605"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN609"><span class='Ref_To_Local'>ind</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN663"><span class='Ref_to_Member'>unique</span></a> <span class='Operator'>&& </span><a href="analyzejoins.c.html#LN609"><span class='Ref_To_Local'>ind</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN664"><span class='Ref_to_Member'>immediate</span></a> <span class='Operator'>&& 
</span>                <span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN609"><span class='Ref_To_Local'>ind</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN653"><span class='Ref_to_Member'>indpred</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>|| </span><a href="analyzejoins.c.html#LN609"><span class='Ref_To_Local'>ind</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN662"><span class='Ref_to_Member'>predOK</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if rel-&GT;rtekind==RTE_REL... &raquo; </span> 
    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN591"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN554"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/parsenodes.h.html#LN923"><span class='Ref_to_EnumConst'>RTE_SUBQUERY</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN618"></a>        <a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>subquery</span> <span class='Operator'>= </span><a href="analyzejoins.c.html#LN591"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN187"><span class='Ref_to_Member'>simple_rte_array</span></a><span class='Delimiter'>[</span><a href="analyzejoins.c.html#LN591"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a><span class='Delimiter'>]</span><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN954"><span class='Ref_to_Member'>subquery</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Check if the subquery has any qualities that support distinctness */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/optimizer/planmain.h.html#LN106"><span class='Ref_to_Proto'>query_supports_distinctness</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN618"><span class='Ref_To_Local'>subquery</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Comment_Multi_Line'>/* We have no proof rules for any other rtekinds. */ 
</span>    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end rel_supports_distinctness &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * rel_is_distinct_for 
 *      Does the relation return only distinct rows according to clause_list? 
 * 
 * clause_list is a list of join restriction clauses involving this rel and 
 * some other one.  Return true if no two rows emitted by this rel could 
 * possibly join to the same row of the other rel. 
 * 
 * The caller must have already determined that each condition is a 
 * mergejoinable equality with an expression in this relation on one side, and 
 * an expression not involving this relation on the other.  The transient 
 * outer_is_left flag is used to identify which side references this relation: 
 * left side if outer_is_left is false, right side if it is true. 
 * 
 * Note that the passed-in clause_list may be destructively modified!  This 
 * is OK for current uses, because the clause_list is built by the caller for 
 * the sole purpose of passing to this function. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN647"></a><span class='Declare_Function'>rel_is_distinct_for</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>rel</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause_list</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* 
     * We could skip a couple of tests here if we assume all callers checked 
     * rel_supports_distinctness first, but it doesn't seem worth taking any 
     * risk for. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN647"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN521"><span class='Ref_to_Member'>reloptkind</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/relation.h.html#LN493"><span class='Ref_to_EnumConst'>RELOPT_BASEREL</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN647"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN554"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/parsenodes.h.html#LN922"><span class='Ref_to_EnumConst'>RTE_RELATION</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Examine the indexes to see if we have a matching unique index. 
         * relation_has_unique_index_for automatically adds any usable 
         * restriction clauses for the rel, so we needn't do that here. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/optimizer/paths.h.html#LN70"><span class='Ref_to_Proto'>relation_has_unique_index_for</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN647"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN647"><span class='Ref_to_Parameter'>rel</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN647"><span class='Ref_to_Parameter'>clause_list</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN647"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN554"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/parsenodes.h.html#LN923"><span class='Ref_to_EnumConst'>RTE_SUBQUERY</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN668"></a>        <a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Local'>relid</span> <span class='Operator'>= </span><a href="analyzejoins.c.html#LN647"><span class='Ref_to_Parameter'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a><span class='Delimiter'>; 
</span><a name="LN669"></a>        <a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>subquery</span> <span class='Operator'>= </span><a href="analyzejoins.c.html#LN647"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN187"><span class='Ref_to_Member'>simple_rte_array</span></a><span class='Delimiter'>[</span><a href="analyzejoins.c.html#LN668"><span class='Ref_To_Local'>relid</span></a><span class='Delimiter'>]</span><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN954"><span class='Ref_to_Member'>subquery</span></a><span class='Delimiter'>; 
</span><a name="LN670"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>colnos</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN671"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>opids</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN672"></a>        <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Build the argument lists for query_is_distinct_for: a list of 
         * output column numbers that the query needs to be distinct over, and 
         * a list of equality operators that the output columns need to be 
         * distinct according to. 
         * 
         * (XXX we are not considering restriction clauses attached to the 
         * subquery; is that worth doing?) 
         */ 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN672"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN647"><span class='Ref_to_Parameter'>clause_list</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN685"></a>            <a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rinfo</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN108"><span class='Ref_to_Macro'>lfirst_node</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN672"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN686"></a>            <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>op</span><span class='Delimiter'>; 
</span><a name="LN687"></a>            <a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>var</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Get the equality operator we need uniqueness according to. 
             * (This might be a cross-type operator and thus not exactly the 
             * same operator the subquery would consider; that's all right 
             * since query_is_distinct_for can resolve such cases.)  The 
             * caller's mergejoinability test should have selected only 
             * OpExprs. 
             */ 
</span>            <a href="analyzejoins.c.html#LN686"><span class='Ref_To_Local'>op</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN575"><span class='Ref_to_Macro'>castNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN685"><span class='Ref_To_Local'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1746"><span class='Ref_to_Member'>clause</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>opno<span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* caller identified the inner side for us */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN685"><span class='Ref_To_Local'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1801"><span class='Ref_to_Member'>outer_is_left</span></a><span class='Parentheses'>) 
</span>                <a href="analyzejoins.c.html#LN687"><span class='Ref_To_Local'>var</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/optimizer/clauses.h.html#LN33"><span class='Ref_to_Proto'>get_rightop</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN685"><span class='Ref_To_Local'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1746"><span class='Ref_to_Member'>clause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="analyzejoins.c.html#LN687"><span class='Ref_To_Local'>var</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/optimizer/clauses.h.html#LN32"><span class='Ref_to_Proto'>get_leftop</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN685"><span class='Ref_To_Local'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1746"><span class='Ref_to_Member'>clause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * If inner side isn't a Var referencing a subquery output column, 
             * this clause doesn't help us. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="analyzejoins.c.html#LN687"><span class='Ref_To_Local'>var</span></a> <span class='Operator'>|| !</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN687"><span class='Ref_To_Local'>var</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>                <a href="analyzejoins.c.html#LN687"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN165"><span class='Ref_to_Member'>varno</span></a> <span class='Operator'>!= </span><a href="analyzejoins.c.html#LN668"><span class='Ref_To_Local'>relid</span></a> <span class='Operator'>|| </span><a href="analyzejoins.c.html#LN687"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN172"><span class='Ref_to_Member'>varlevelsup</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
                <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
            <a href="analyzejoins.c.html#LN670"><span class='Ref_To_Local'>colnos</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN144"><span class='Ref_to_Func'>lappend_int</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN670"><span class='Ref_To_Local'>colnos</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN687"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN167"><span class='Ref_to_Member'>varattno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="analyzejoins.c.html#LN671"><span class='Ref_To_Local'>opids</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN162"><span class='Ref_to_Func'>lappend_oid</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN671"><span class='Ref_To_Local'>opids</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN686"><span class='Ref_To_Local'>op</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/optimizer/planmain.h.html#LN107"><span class='Ref_to_Proto'>query_is_distinct_for</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN669"><span class='Ref_To_Local'>subquery</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN670"><span class='Ref_To_Local'>colnos</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN671"><span class='Ref_To_Local'>opids</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if rel-&GT;rtekind==RTE_SUB... &raquo; </span> 
    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end rel_is_distinct_for &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * query_supports_distinctness - could the query possibly be proven distinct 
 *      on some set of output columns? 
 * 
 * This is effectively a pre-checking function for query_is_distinct_for(). 
 * It must return TRUE if query_is_distinct_for() could possibly return TRUE 
 * with this query, but it should not expend a lot of cycles.  The idea is 
 * that callers can avoid doing possibly-expensive processing to compute 
 * query_is_distinct_for()'s argument lists if the call could not possibly 
 * succeed. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN736"></a><span class='Declare_Function'>query_supports_distinctness</span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>query</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Comment_Multi_Line'>/* we don't cope with SRFs, see comment below */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN736"><span class='Ref_to_Parameter'>query</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN124"><span class='Ref_to_Member'>hasTargetSRFs</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* check for features we can prove distinctness with */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN736"><span class='Ref_to_Parameter'>query</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN153"><span class='Ref_to_Member'>distinctClause</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>|| 
</span>        <a href="analyzejoins.c.html#LN736"><span class='Ref_to_Parameter'>query</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>|| 
</span>        <a href="analyzejoins.c.html#LN736"><span class='Ref_to_Parameter'>query</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN147"><span class='Ref_to_Member'>groupingSets</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a> <span class='Operator'>|| 
</span>        <a href="analyzejoins.c.html#LN736"><span class='Ref_to_Parameter'>query</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN122"><span class='Ref_to_Member'>hasAggs</span></a> <span class='Operator'>|| 
</span>        <a href="analyzejoins.c.html#LN736"><span class='Ref_to_Parameter'>query</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN149"><span class='Ref_to_Member'>havingQual</span></a> <span class='Operator'>|| 
</span>        <a href="analyzejoins.c.html#LN736"><span class='Ref_to_Parameter'>query</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN162"><span class='Ref_to_Member'>setOperations</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * query_is_distinct_for - does query never return duplicates of the 
 *      specified columns? 
 * 
 * query is a not-yet-planned subquery (in current usage, it's always from 
 * a subquery RTE, which the planner avoids scribbling on). 
 * 
 * colnos is an integer list of output column numbers (resno's).  We are 
 * interested in whether rows consisting of just these columns are certain 
 * to be distinct.  "Distinctness" is defined according to whether the 
 * corresponding upper-level equality operators listed in opids would think 
 * the values are distinct.  (Note: the opids entries could be cross-type 
 * operators, and thus not exactly the equality operators that the subquery 
 * would use itself.  We use equality_ops_are_compatible() to check 
 * compatibility.  That looks at btree or hash opfamily membership, and so 
 * should give trustworthy answers for all operators that we might need 
 * to deal with here.) 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN773"></a><span class='Declare_Function'>query_is_distinct_for</span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>query</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>colnos</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>opids</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN775"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span><a name="LN776"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>opid</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN773"><span class='Ref_to_Parameter'>colnos</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN773"><span class='Ref_to_Parameter'>opids</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * A set-returning function in the query's targetlist can result in 
     * returning duplicate rows, if the SRF is evaluated after the 
     * de-duplication step; so we play it safe and say "no" if there are any 
     * SRFs.  (We could be certain that it's okay if SRFs appear only in the 
     * specified columns, since those must be evaluated before de-duplication; 
     * but it doesn't presently seem worth the complication to check that.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN773"><span class='Ref_to_Parameter'>query</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN124"><span class='Ref_to_Member'>hasTargetSRFs</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * DISTINCT (including DISTINCT ON) guarantees uniqueness if all the 
     * columns in the DISTINCT clause appear in colnos and operator semantics 
     * match. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN773"><span class='Ref_to_Parameter'>query</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN153"><span class='Ref_to_Member'>distinctClause</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN775"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN773"><span class='Ref_to_Parameter'>query</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN153"><span class='Ref_to_Member'>distinctClause</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN800"></a>            <a href="../../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sgc</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN775"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN801"></a>            <a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle</span> <span class='Operator'>= </span><a href="../../../include/optimizer/tlist.h.html#LN37"><span class='Ref_to_Proto'>get_sortgroupclause_tle</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN800"><span class='Ref_To_Local'>sgc</span></a><span class='Delimiter'>, 
</span>                                                       <a href="analyzejoins.c.html#LN773"><span class='Ref_to_Parameter'>query</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="analyzejoins.c.html#LN776"><span class='Ref_To_Local'>opid</span></a> <span class='Operator'>= </span><a href="analyzejoins.c.html#LN42"><span class='Ref_to_Proto'>distinct_col_search</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN801"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1367"><span class='Ref_to_Member'>resno</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN773"><span class='Ref_to_Parameter'>colnos</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN773"><span class='Ref_to_Parameter'>opids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN776"><span class='Ref_To_Local'>opid</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>                <span class='Operator'>!</span><a href="../../../include/utils/lsyscache.h.html#LN82"><span class='Ref_to_Proto'>equality_ops_are_compatible</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN776"><span class='Ref_To_Local'>opid</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN800"><span class='Ref_To_Local'>sgc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1165"><span class='Ref_to_Member'>eqop</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>break</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* exit early if no match */ 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN775"><span class='Ref_To_Local'>l</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span>          <span class='Comment_Single_Line'>/* had matches for all? */ 
</span>            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Similarly, GROUP BY without GROUPING SETS guarantees uniqueness if all 
     * the grouped columns appear in colnos and operator semantics match. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN773"><span class='Ref_to_Parameter'>query</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a> <span class='Operator'>&& !</span><a href="analyzejoins.c.html#LN773"><span class='Ref_to_Parameter'>query</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN147"><span class='Ref_to_Member'>groupingSets</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN775"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN773"><span class='Ref_to_Parameter'>query</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN821"></a>            <a href="../../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sgc</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN775"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN822"></a>            <a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle</span> <span class='Operator'>= </span><a href="../../../include/optimizer/tlist.h.html#LN37"><span class='Ref_to_Proto'>get_sortgroupclause_tle</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN821"><span class='Ref_To_Local'>sgc</span></a><span class='Delimiter'>, 
</span>                                                       <a href="analyzejoins.c.html#LN773"><span class='Ref_to_Parameter'>query</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="analyzejoins.c.html#LN776"><span class='Ref_To_Local'>opid</span></a> <span class='Operator'>= </span><a href="analyzejoins.c.html#LN42"><span class='Ref_to_Proto'>distinct_col_search</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN822"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1367"><span class='Ref_to_Member'>resno</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN773"><span class='Ref_to_Parameter'>colnos</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN773"><span class='Ref_to_Parameter'>opids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN776"><span class='Ref_To_Local'>opid</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>                <span class='Operator'>!</span><a href="../../../include/utils/lsyscache.h.html#LN82"><span class='Ref_to_Proto'>equality_ops_are_compatible</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN776"><span class='Ref_To_Local'>opid</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN821"><span class='Ref_To_Local'>sgc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1165"><span class='Ref_to_Member'>eqop</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>break</span><span class='Delimiter'>;</span>          <span class='Comment_Single_Line'>/* exit early if no match */ 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN775"><span class='Ref_To_Local'>l</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span>          <span class='Comment_Single_Line'>/* had matches for all? */ 
</span>            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN773"><span class='Ref_to_Parameter'>query</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN147"><span class='Ref_to_Member'>groupingSets</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * If we have grouping sets with expressions, we probably don't have 
         * uniqueness and analysis would be hard. Punt. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN773"><span class='Ref_to_Parameter'>query</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * If we have no groupClause (therefore no grouping expressions), we 
         * might have one or many empty grouping sets. If there's just one, 
         * then we're returning only one row and are certainly unique. But 
         * otherwise, we know we're certainly not unique. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN773"><span class='Ref_to_Parameter'>query</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN147"><span class='Ref_to_Member'>groupingSets</span></a><span class='Parentheses'>)</span> <span class='Operator'>== </span><span class='Number'>1</span> <span class='Operator'>&& 
</span>            <span class='Parentheses'>((</span><a href="../../../include/nodes/parsenodes.h.html#LN1230"><span class='Ref_to_Struct'>GroupingSet</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN773"><span class='Ref_to_Parameter'>query</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN147"><span class='Ref_to_Member'>groupingSets</span></a><span class='Parentheses'>))</span><span class='Operator'>-&GT;</span>kind <span class='Operator'>== </span><a href="../../../include/nodes/parsenodes.h.html#LN1223"><span class='Ref_to_EnumConst'>GROUPING_SET_EMPTY</span></a><span class='Parentheses'>)</span> 
            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Control'>else</span> 
            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if query-&GT;groupingSets &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * If we have no GROUP BY, but do have aggregates or HAVING, then the 
         * result is at most one row so it's surely unique, for any operators. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN773"><span class='Ref_to_Parameter'>query</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN122"><span class='Ref_to_Member'>hasAggs</span></a> <span class='Operator'>|| </span><a href="analyzejoins.c.html#LN773"><span class='Ref_to_Parameter'>query</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN149"><span class='Ref_to_Member'>havingQual</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * UNION, INTERSECT, EXCEPT guarantee uniqueness of the whole output row, 
     * except with ALL. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN773"><span class='Ref_to_Parameter'>query</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN162"><span class='Ref_to_Member'>setOperations</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN870"></a>        <a href="../../../include/nodes/parsenodes.h.html#LN1545"><span class='Ref_to_Struct'>SetOperationStmt</span></a> <span class='Operator'>*</span><span class='Declare_Local'>topop</span> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN575"><span class='Ref_to_Macro'>castNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN1545"><span class='Ref_to_Struct'>SetOperationStmt</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN773"><span class='Ref_to_Parameter'>query</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN162"><span class='Ref_to_Member'>setOperations</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN870"><span class='Ref_To_Local'>topop</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1548"><span class='Ref_to_Member'>op</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/parsenodes.h.html#LN1472"><span class='Ref_to_EnumConst'>SETOP_NONE</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="analyzejoins.c.html#LN870"><span class='Ref_To_Local'>topop</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1549"><span class='Ref_to_Member'>all</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN876"></a>            <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lg</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* We're good if all the nonjunk output columns are in colnos */ 
</span>            <a href="analyzejoins.c.html#LN876"><span class='Ref_To_Local'>lg</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN75"><span class='Ref_to_Func'>list_head</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN870"><span class='Ref_To_Local'>topop</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1558"><span class='Ref_to_Member'>groupClauses</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN775"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN773"><span class='Ref_to_Parameter'>query</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN882"></a>                <a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN775"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN883"></a>                <a href="../../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sgc</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN882"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1373"><span class='Ref_to_Member'>resjunk</span></a><span class='Parentheses'>) 
</span>                    <span class='Control'>continue</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* ignore resjunk columns */ 
</span> 
                <span class='Comment_Multi_Line'>/* non-resjunk columns should have grouping clauses */ 
</span>                <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN876"><span class='Ref_To_Local'>lg</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="analyzejoins.c.html#LN883"><span class='Ref_To_Local'>sgc</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN876"><span class='Ref_To_Local'>lg</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="analyzejoins.c.html#LN876"><span class='Ref_To_Local'>lg</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN104"><span class='Ref_to_Macro'>lnext</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN876"><span class='Ref_To_Local'>lg</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="analyzejoins.c.html#LN776"><span class='Ref_To_Local'>opid</span></a> <span class='Operator'>= </span><a href="analyzejoins.c.html#LN42"><span class='Ref_to_Proto'>distinct_col_search</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN882"><span class='Ref_To_Local'>tle</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1367"><span class='Ref_to_Member'>resno</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN773"><span class='Ref_to_Parameter'>colnos</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN773"><span class='Ref_to_Parameter'>opids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN776"><span class='Ref_To_Local'>opid</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>                    <span class='Operator'>!</span><a href="../../../include/utils/lsyscache.h.html#LN82"><span class='Ref_to_Proto'>equality_ops_are_compatible</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN776"><span class='Ref_To_Local'>opid</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN883"><span class='Ref_To_Local'>sgc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1165"><span class='Ref_to_Member'>eqop</span></a><span class='Parentheses'>))</span> 
                    <span class='Control'>break</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* exit early if no match */ 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN775"><span class='Ref_To_Local'>l</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span>      <span class='Comment_Single_Line'>/* had matches for all? */ 
</span>                <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !topop-&GT;all &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if query-&GT;setOperations &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * XXX Are there any other cases in which we can easily see the result 
     * must be distinct? 
     * 
     * If you do add more smarts to this function, be sure to update 
     * query_supports_distinctness() to match. 
     */ 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end query_is_distinct_for &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * distinct_col_search - subroutine for query_is_distinct_for 
 * 
 * If colno is in colnos, return the corresponding element of opids, 
 * else return InvalidOid.  (Ordinarily colnos would not contain duplicates, 
 * but if it does, we arbitrarily select the first match.) 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> 
<a name="LN922"></a><span class='Declare_Function'>distinct_col_search</span><span class='Parentheses'>(</span><span class='Keyword'>int </span><span class='Declare_Parameter'>colno</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>colnos</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>opids</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN924"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc1</span><span class='Delimiter'>, 
</span><a name="LN925"></a>               <span class='Operator'>*</span><span class='Declare_Local'>lc2</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN179"><span class='Ref_to_Macro'>forboth</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN924"><span class='Ref_To_Local'>lc1</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN922"><span class='Ref_to_Parameter'>colnos</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN925"><span class='Ref_To_Local'>lc2</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN922"><span class='Ref_to_Parameter'>opids</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN922"><span class='Ref_to_Parameter'>colno</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN106"><span class='Ref_to_Macro'>lfirst_int</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN924"><span class='Ref_To_Local'>lc1</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <a href="../../../include/nodes/pg_list.h.html#LN107"><span class='Ref_to_Macro'>lfirst_oid</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN925"><span class='Ref_To_Local'>lc2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
} 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * innerrel_is_unique 
 *    Check if the innerrel provably contains at most one tuple matching any 
 *    tuple from the outerrel, based on join clauses in the 'restrictlist'. 
 * 
 * We need an actual RelOptInfo for the innerrel, but it's sufficient to 
 * identify the outerrel by its Relids.  This asymmetry supports use of this 
 * function before joinrels have been built. 
 * 
 * The proof must be made based only on clauses that will be "joinquals" 
 * rather than "otherquals" at execution.  For an inner join there's no 
 * difference; but if the join is outer, we must ignore pushed-down quals, 
 * as those will become "otherquals".  Note that this means the answer might 
 * vary depending on whether IS_OUTER_JOIN(jointype); since we cache the 
 * answer without regard to that, callers must take care not to call this 
 * with jointypes that would be classified differently by IS_OUTER_JOIN(). 
 * 
 * The actual proof is undertaken by is_innerrel_unique_for(); this function 
 * is a frontend that is mainly concerned with caching the answers. 
 * In particular, the force_cache argument allows overriding the internal 
 * heuristic about whether to cache negative answers; it should be "true" 
 * if making an inquiry that is not part of the normal bottom-up join search 
 * sequence. 
 */ 
</span><span class='Keyword'>bool 
</span><a name="LN961"></a><span class='Declare_Function'>innerrel_is_unique</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN962"></a>                   <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Declare_Parameter'>outerrelids</span><span class='Delimiter'>, 
</span><a name="LN963"></a>                   <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>innerrel</span><span class='Delimiter'>, 
</span><a name="LN964"></a>                   <a href="../../../include/nodes/nodes.h.html#LN671"><span class='Ref_to_Enum'>JoinType</span></a> <span class='Declare_Parameter'>jointype</span><span class='Delimiter'>, 
</span><a name="LN965"></a>                   <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>restrictlist</span><span class='Delimiter'>, 
</span><a name="LN966"></a>                   <span class='Keyword'>bool </span><span class='Declare_Parameter'>force_cache</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN968"></a>    <a href="../../../include/utils/palloc.h.html#LN35"><span class='Ref_to_Typedef'>MemoryContext</span></a> <span class='Declare_Local'>old_context</span><span class='Delimiter'>; 
</span><a name="LN969"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Certainly can't prove uniqueness when there are no joinclauses */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN965"><span class='Ref_to_Parameter'>restrictlist</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Make a quick check to eliminate cases in which we will surely be unable 
     * to prove uniqueness of the innerrel. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="analyzejoins.c.html#LN39"><span class='Ref_to_Proto'>rel_supports_distinctness</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN961"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN963"><span class='Ref_to_Parameter'>innerrel</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Query the cache to see if we've managed to prove that innerrel is 
     * unique for any subset of this outerrel.  We don't need an exact match, 
     * as extra outerrels can't make the innerrel any less unique (or more 
     * formally, the restrictlist for a join to a superset outerrel must be a 
     * superset of the conditions we successfully used before). 
     */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN969"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN963"><span class='Ref_to_Parameter'>innerrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN579"><span class='Ref_to_Member'>unique_for_rels</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN991"></a>        <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>unique_for_rels</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN969"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN991"><span class='Ref_To_Local'>unique_for_rels</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN962"><span class='Ref_to_Parameter'>outerrelids</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* Success! */ 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Conversely, we may have already determined that this outerrel, or some 
     * superset thereof, cannot prove this innerrel to be unique. 
     */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN969"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN963"><span class='Ref_to_Parameter'>innerrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN580"><span class='Ref_to_Member'>non_unique_for_rels</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1003"></a>        <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>unique_for_rels</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN969"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN962"><span class='Ref_to_Parameter'>outerrelids</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN1003"><span class='Ref_To_Local'>unique_for_rels</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* No cached information, so try to make the proof. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN43"><span class='Ref_to_Proto'>is_innerrel_unique_for</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN961"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN962"><span class='Ref_to_Parameter'>outerrelids</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN963"><span class='Ref_to_Parameter'>innerrel</span></a><span class='Delimiter'>, 
</span>                               <a href="analyzejoins.c.html#LN964"><span class='Ref_to_Parameter'>jointype</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN965"><span class='Ref_to_Parameter'>restrictlist</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Cache the positive result for future probes, being sure to keep it 
         * in the planner_cxt even if we are working in GEQO. 
         * 
         * Note: one might consider trying to isolate the minimal subset of 
         * the outerrels that proved the innerrel unique.  But it's not worth 
         * the trouble, because the planner builds up joinrels incrementally 
         * and so we'll see the minimally sufficient outerrels before any 
         * supersets of them anyway. 
         */ 
</span>        <a href="analyzejoins.c.html#LN968"><span class='Ref_To_Local'>old_context</span></a> <span class='Operator'>= </span><a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN961"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN286"><span class='Ref_to_Member'>planner_cxt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="analyzejoins.c.html#LN963"><span class='Ref_to_Parameter'>innerrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN579"><span class='Ref_to_Member'>unique_for_rels</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN963"><span class='Ref_to_Parameter'>innerrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN579"><span class='Ref_to_Member'>unique_for_rels</span></a><span class='Delimiter'>, 
</span>                                            <a href="../../../include/nodes/bitmapset.h.html#LN65"><span class='Ref_to_Proto'>bms_copy</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN962"><span class='Ref_to_Parameter'>outerrelids</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN968"><span class='Ref_To_Local'>old_context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>;</span>            <span class='Comment_Single_Line'>/* Success! */ 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if is_innerrel_unique_fo... &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * None of the join conditions for outerrel proved innerrel unique, so 
         * we can safely reject this outerrel or any subset of it in future 
         * checks. 
         * 
         * However, in normal planning mode, caching this knowledge is totally 
         * pointless; it won't be queried again, because we build up joinrels 
         * from smaller to larger.  It is useful in GEQO mode, where the 
         * knowledge can be carried across successive planning attempts; and 
         * it's likely to be useful when using join-search plugins, too. Hence 
         * cache when join_search_private is non-NULL.  (Yeah, that's a hack, 
         * but it seems reasonable.) 
         * 
         * Also, allow callers to override that heuristic and force caching; 
         * that's useful for reduce_unique_semijoins, which calls here before 
         * the normal join search starts. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN966"><span class='Ref_to_Parameter'>force_cache</span></a> <span class='Operator'>|| </span><a href="analyzejoins.c.html#LN961"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN315"><span class='Ref_to_Member'>join_search_private</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="analyzejoins.c.html#LN968"><span class='Ref_To_Local'>old_context</span></a> <span class='Operator'>= </span><a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN961"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN286"><span class='Ref_to_Member'>planner_cxt</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="analyzejoins.c.html#LN963"><span class='Ref_to_Parameter'>innerrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN580"><span class='Ref_to_Member'>non_unique_for_rels</span></a> <span class='Operator'>= 
</span>                <a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN963"><span class='Ref_to_Parameter'>innerrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN580"><span class='Ref_to_Member'>non_unique_for_rels</span></a><span class='Delimiter'>, 
</span>                        <a href="../../../include/nodes/bitmapset.h.html#LN65"><span class='Ref_to_Proto'>bms_copy</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN962"><span class='Ref_to_Parameter'>outerrelids</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <a href="../../../include/utils/palloc.h.html#LN107"><span class='Ref_to_Func'>MemoryContextSwitchTo</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN968"><span class='Ref_To_Local'>old_context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end innerrel_is_unique &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * is_innerrel_unique_for 
 *    Check if the innerrel provably contains at most one tuple matching any 
 *    tuple from the outerrel, based on join clauses in the 'restrictlist'. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN1068"></a><span class='Declare_Function'>is_innerrel_unique_for</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN1069"></a>                       <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Declare_Parameter'>outerrelids</span><span class='Delimiter'>, 
</span><a name="LN1070"></a>                       <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>innerrel</span><span class='Delimiter'>, 
</span><a name="LN1071"></a>                       <a href="../../../include/nodes/nodes.h.html#LN671"><span class='Ref_to_Enum'>JoinType</span></a> <span class='Declare_Parameter'>jointype</span><span class='Delimiter'>, 
</span><a name="LN1072"></a>                       <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>restrictlist</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1074"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>clause_list</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN1075"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Search for mergejoinable clauses that constrain the inner rel against 
     * the outer rel.  If an operator is mergejoinable then it behaves like 
     * equality for some btree opclass, so it's what we want.  The 
     * mergejoinability test also eliminates clauses containing volatile 
     * functions, which we couldn't depend on. 
     */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN1075"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN1072"><span class='Ref_to_Parameter'>restrictlist</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1086"></a>        <a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>restrictinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN1075"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * As noted above, if it's a pushed-down clause and we're at an outer 
         * join, we can't use it. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN1086"><span class='Ref_To_Local'>restrictinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1748"><span class='Ref_to_Member'>is_pushed_down</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN720"><span class='Ref_to_Macro'>IS_OUTER_JOIN</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN1071"><span class='Ref_to_Parameter'>jointype</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Ignore if it's not a mergejoinable clause */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="analyzejoins.c.html#LN1086"><span class='Ref_To_Local'>restrictinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1752"><span class='Ref_to_Member'>can_join</span></a> <span class='Operator'>|| 
</span>            <a href="analyzejoins.c.html#LN1086"><span class='Ref_To_Local'>restrictinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1791"><span class='Ref_to_Member'>mergeopfamilies</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* not mergejoinable */ 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Check if clause has the form "outer op inner" or "inner op outer", 
         * and if so mark which side is inner. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="analyzejoins.c.html#LN125"><span class='Ref_to_Func'>clause_sides_match_join</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN1086"><span class='Ref_To_Local'>restrictinfo</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN1069"><span class='Ref_to_Parameter'>outerrelids</span></a><span class='Delimiter'>, 
</span>                                     <a href="analyzejoins.c.html#LN1070"><span class='Ref_to_Parameter'>innerrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* no good for these input relations */ 
</span> 
        <span class='Comment_Multi_Line'>/* OK, add to list */ 
</span>        <a href="analyzejoins.c.html#LN1074"><span class='Ref_To_Local'>clause_list</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN1074"><span class='Ref_To_Local'>clause_list</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN1086"><span class='Ref_To_Local'>restrictinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Let rel_is_distinct_for() do the hard work */ 
</span>    <span class='Control'>return</span> <a href="analyzejoins.c.html#LN40"><span class='Ref_to_Proto'>rel_is_distinct_for</span></a><span class='Parentheses'>(</span><a href="analyzejoins.c.html#LN1068"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN1070"><span class='Ref_to_Parameter'>innerrel</span></a><span class='Delimiter'>, </span><a href="analyzejoins.c.html#LN1074"><span class='Ref_To_Local'>clause_list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end is_innerrel_unique_for &raquo; </span> 
</pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>