<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\optimizer\plan\initsplan.c</title>
<LINK REL=StyleSheet HREF="../../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\optimizer\plan\initsplan.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:42 2017
</td></tr>
<tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * initsplan.c 
 *    Target list, qualification, joininfo initialization routines 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * 
 * IDENTIFICATION 
 *    src/backend/optimizer/plan/initsplan.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_type.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/nodeFuncs.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/clauses.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/cost.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/joininfo.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/pathnode.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/paths.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/placeholder.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/planmain.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/planner.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/prep.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/restrictinfo.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/var.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/analyze.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"rewrite/rewriteManip.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/lsyscache.h"</span> 
 
 
<span class='Comment_Multi_Line'>/* These parameters are set by GUC */ 
</span><a name="LN35"></a><span class='Keyword'>int</span>         <span class='Declare_Var'>from_collapse_limit</span><span class='Delimiter'>; 
</span><a name="LN36"></a><span class='Keyword'>int</span>         <span class='Declare_Var'>join_collapse_limit</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* Elements of the postponed_qual_list used during deconstruct_recurse */ 
</span><a name="LN40"></a><span class='Control'>typedef</span> <span class='Control'>struct</span> <span class='Declare_Struct'>PostponedQual</span> 
<span class='Delimiter'>{ 
</span><a name="LN42"></a>    <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Member'>qual</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* a qual clause waiting to be processed */ 
</span><a name="LN43"></a>    <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Member'>relids</span><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* the set of baserels it references */ 
</span><a name="LN44"></a><span class='Delimiter'>} </span><span class='Declare_Typedef'>PostponedQual</span><span class='Delimiter'>; 
</span> 
 
<a name="LN47"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>extract_lateral_references</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>brel</span><span class='Delimiter'>, 
</span><a name="LN48"></a>                           <a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a> <span class='Declare_Parameter'>rtindex</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN49"></a><span class='Keyword'>static </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>deconstruct_recurse</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>jtnode</span><span class='Delimiter'>, 
</span><a name="LN50"></a>                    <span class='Keyword'>bool </span><span class='Declare_Parameter'>below_outer_join</span><span class='Delimiter'>, 
</span><a name="LN51"></a>                    <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>qualscope</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>inner_join_rels</span><span class='Delimiter'>, 
</span><a name="LN52"></a>                    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>postponed_qual_list</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN53"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>process_security_barrier_quals</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN54"></a>                               <span class='Keyword'>int </span><span class='Declare_Parameter'>rti</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Declare_Parameter'>qualscope</span><span class='Delimiter'>, 
</span><a name="LN55"></a>                               <span class='Keyword'>bool </span><span class='Declare_Parameter'>below_outer_join</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN56"></a><span class='Keyword'>static </span><a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Declare_Prototype'>make_outerjoininfo</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN57"></a>                   <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Declare_Parameter'>left_rels</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Declare_Parameter'>right_rels</span><span class='Delimiter'>, 
</span><a name="LN58"></a>                   <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Declare_Parameter'>inner_join_rels</span><span class='Delimiter'>, 
</span><a name="LN59"></a>                   <a href="../../../include/nodes/nodes.h.html#LN671"><span class='Ref_to_Enum'>JoinType</span></a> <span class='Declare_Parameter'>jointype</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN60"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>compute_semijoin_info</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sjinfo</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN61"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>distribute_qual_to_rels</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Delimiter'>, 
</span><a name="LN62"></a>                        <span class='Keyword'>bool </span><span class='Declare_Parameter'>is_deduced</span><span class='Delimiter'>, 
</span><a name="LN63"></a>                        <span class='Keyword'>bool </span><span class='Declare_Parameter'>below_outer_join</span><span class='Delimiter'>, 
</span><a name="LN64"></a>                        <a href="../../../include/nodes/nodes.h.html#LN671"><span class='Ref_to_Enum'>JoinType</span></a> <span class='Declare_Parameter'>jointype</span><span class='Delimiter'>, 
</span><a name="LN65"></a>                        <a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a> <span class='Declare_Parameter'>security_level</span><span class='Delimiter'>, 
</span><a name="LN66"></a>                        <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Declare_Parameter'>qualscope</span><span class='Delimiter'>, 
</span><a name="LN67"></a>                        <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Declare_Parameter'>ojscope</span><span class='Delimiter'>, 
</span><a name="LN68"></a>                        <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Declare_Parameter'>outerjoin_nonnullable</span><span class='Delimiter'>, 
</span><a name="LN69"></a>                        <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Declare_Parameter'>deduced_nullable_relids</span><span class='Delimiter'>, 
</span><a name="LN70"></a>                        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>postponed_qual_list</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN71"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>check_outerjoin_delay</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>relids_p</span><span class='Delimiter'>, 
</span><a name="LN72"></a>                      <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>nullable_relids_p</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>is_pushed_down</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN73"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>check_equivalence_delay</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN74"></a>                        <a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>restrictinfo</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN75"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>check_redundant_nullability_qual</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN76"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>check_mergejoinable</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>restrictinfo</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN77"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>check_hashjoinable</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>restrictinfo</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/***************************************************************************** 
 * 
 *   JOIN TREES 
 * 
 *****************************************************************************/ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * add_base_rels_to_query 
 * 
 *    Scan the query's jointree and create baserel RelOptInfos for all 
 *    the base relations (ie, table, subquery, and function RTEs) 
 *    appearing in the jointree. 
 * 
 * The initial invocation must pass root-&GT;parse-&GT;jointree as the value of 
 * jtnode.  Internally, the function recurses through the jointree. 
 * 
 * At the end of this process, there should be one baserel RelOptInfo for 
 * every non-join RTE that is used in the query.  Therefore, this routine 
 * is the only place that should call build_simple_rel with reloptkind 
 * RELOPT_BASEREL.  (Note: build_simple_rel recurses internally to build 
 * "other rel" RelOptInfos for the members of any appendrels we find here.) 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN103"></a><span class='Declare_Function'>add_base_rels_to_query</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>jtnode</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN103"><span class='Ref_to_Parameter'>jtnode</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN103"><span class='Ref_to_Parameter'>jtnode</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN1415"><span class='Ref_to_Struct'>RangeTblRef</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN109"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>varno</span> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN1415"><span class='Ref_to_Struct'>RangeTblRef</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN103"><span class='Ref_to_Parameter'>jtnode</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>rtindex<span class='Delimiter'>; 
</span> 
        <span class='Parentheses'>(</span><span class='Keyword'>void</span><span class='Parentheses'>) </span><a href="../util/relnode.c.html#LN89"><span class='Ref_to_Func'>build_simple_rel</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN103"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN109"><span class='Ref_To_Local'>varno</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN103"><span class='Ref_to_Parameter'>jtnode</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN1466"><span class='Ref_to_Struct'>FromExpr</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN115"></a>        <a href="../../../include/nodes/primnodes.h.html#LN1466"><span class='Ref_to_Struct'>FromExpr</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>f</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1466"><span class='Ref_to_Struct'>FromExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN103"><span class='Ref_to_Parameter'>jtnode</span></a><span class='Delimiter'>; 
</span><a name="LN116"></a>        <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN116"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN115"><span class='Ref_To_Local'>f</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1469"><span class='Ref_to_Member'>fromlist</span></a><span class='Parentheses'>) 
</span><a name="LN119"></a>            <span class='Declare_Local'>add_base_rels_to_query</span><span class='Parentheses'>(</span><a href="initsplan.c.html#LN103"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN116"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN103"><span class='Ref_to_Parameter'>jtnode</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN1444"><span class='Ref_to_Struct'>JoinExpr</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN123"></a>        <a href="../../../include/nodes/primnodes.h.html#LN1444"><span class='Ref_to_Struct'>JoinExpr</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>j</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1444"><span class='Ref_to_Struct'>JoinExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN103"><span class='Ref_to_Parameter'>jtnode</span></a><span class='Delimiter'>; 
</span> 
        <a href="../../../include/optimizer/planmain.h.html#LN73"><span class='Ref_to_Proto'>add_base_rels_to_query</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN103"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN123"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1449"><span class='Ref_to_Member'>larg</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/optimizer/planmain.h.html#LN73"><span class='Ref_to_Proto'>add_base_rels_to_query</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN103"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN123"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1450"><span class='Ref_to_Member'>rarg</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized node type: %d"</span><span class='Delimiter'>, 
</span>             <span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="../../../include/nodes/nodes.h.html#LN513"><span class='Ref_to_Macro'>nodeTag</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN103"><span class='Ref_to_Parameter'>jtnode</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end add_base_rels_to_query &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/***************************************************************************** 
 * 
 *   TARGET LISTS 
 * 
 *****************************************************************************/ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * build_base_rel_tlists 
 *    Add targetlist entries for each var needed in the query's final tlist 
 *    (and HAVING clause, if any) to the appropriate base relations. 
 * 
 * We mark such vars as needed by "relation 0" to ensure that they will 
 * propagate up through all join plan steps. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN149"></a><span class='Declare_Function'>build_base_rel_tlists</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>final_tlist</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN151"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>tlist_vars</span> <span class='Operator'>= </span><a href="../../../include/optimizer/var.h.html#LN36"><span class='Ref_to_Proto'>pull_var_clause</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN149"><span class='Ref_to_Parameter'>final_tlist</span></a><span class='Delimiter'>, 
</span>                                             <a href="../../../include/optimizer/var.h.html#LN20"><span class='Ref_to_Const'>PVC_RECURSE_AGGREGATES</span></a> <span class='Operator'>| 
</span>                                             <a href="../../../include/optimizer/var.h.html#LN22"><span class='Ref_to_Const'>PVC_RECURSE_WINDOWFUNCS</span></a> <span class='Operator'>| 
</span>                                             <a href="../../../include/optimizer/var.h.html#LN23"><span class='Ref_to_Const'>PVC_INCLUDE_PLACEHOLDERS</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN151"><span class='Ref_To_Local'>tlist_vars</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="../../../include/optimizer/planmain.h.html#LN75"><span class='Ref_to_Proto'>add_vars_to_targetlist</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN149"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN151"><span class='Ref_To_Local'>tlist_vars</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/bitmapset.h.html#LN67"><span class='Ref_to_Proto'>bms_make_singleton</span></a><span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN265"><span class='Ref_to_Proto'>list_free</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN151"><span class='Ref_To_Local'>tlist_vars</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If there's a HAVING clause, we'll need the Vars it uses, too.  Note 
     * that HAVING can contain Aggrefs but not WindowFuncs. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN149"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN149"><span class='Ref_to_Member'>havingQual</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN168"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>having_vars</span> <span class='Operator'>= </span><a href="../../../include/optimizer/var.h.html#LN36"><span class='Ref_to_Proto'>pull_var_clause</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN149"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN149"><span class='Ref_to_Member'>havingQual</span></a><span class='Delimiter'>, 
</span>                                                  <a href="../../../include/optimizer/var.h.html#LN20"><span class='Ref_to_Const'>PVC_RECURSE_AGGREGATES</span></a> <span class='Operator'>| 
</span>                                                  <a href="../../../include/optimizer/var.h.html#LN23"><span class='Ref_to_Const'>PVC_INCLUDE_PLACEHOLDERS</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN168"><span class='Ref_To_Local'>having_vars</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../../include/optimizer/planmain.h.html#LN75"><span class='Ref_to_Proto'>add_vars_to_targetlist</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN149"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN168"><span class='Ref_To_Local'>having_vars</span></a><span class='Delimiter'>, 
</span>                                   <a href="../../../include/nodes/bitmapset.h.html#LN67"><span class='Ref_to_Proto'>bms_make_singleton</span></a><span class='Parentheses'>(</span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="../../../include/nodes/pg_list.h.html#LN265"><span class='Ref_to_Proto'>list_free</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN168"><span class='Ref_To_Local'>having_vars</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end build_base_rel_tlists &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * add_vars_to_targetlist 
 *    For each variable appearing in the list, add it to the owning 
 *    relation's targetlist if not already present, and mark the variable 
 *    as being needed for the indicated join (or for final output if 
 *    where_needed includes "relation 0"). 
 * 
 *    The list may also contain PlaceHolderVars.  These don't necessarily 
 *    have a single owning relation; we keep their attr_needed info in 
 *    root-&GT;placeholder_list instead.  If create_new_ph is true, it's OK 
 *    to create new PlaceHolderInfos; otherwise, the PlaceHolderInfos must 
 *    already exist, and we should only update their ph_needed.  (This should 
 *    be true before deconstruct_jointree begins, and false after that.) 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN196"></a><span class='Declare_Function'>add_vars_to_targetlist</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>vars</span><span class='Delimiter'>, 
</span><a name="LN197"></a>                       <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Declare_Parameter'>where_needed</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>create_new_ph</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN199"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>temp</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN85"><span class='Ref_to_Proto'>bms_is_empty</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN197"><span class='Ref_to_Parameter'>where_needed</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN199"><span class='Ref_To_Local'>temp</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN196"><span class='Ref_to_Parameter'>vars</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN205"></a>        <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>node</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN199"><span class='Ref_To_Local'>temp</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN205"><span class='Ref_To_Local'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN209"></a>            <a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>var</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN205"><span class='Ref_To_Local'>node</span></a><span class='Delimiter'>; 
</span><a name="LN210"></a>            <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rel</span> <span class='Operator'>= </span><a href="../util/relnode.c.html#LN241"><span class='Ref_to_Func'>find_base_rel</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN196"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN209"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN165"><span class='Ref_to_Member'>varno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN211"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>attno</span> <span class='Operator'>= </span><a href="initsplan.c.html#LN209"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN167"><span class='Ref_to_Member'>varattno</span></a><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN197"><span class='Ref_to_Parameter'>where_needed</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN210"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN524"><span class='Ref_to_Member'>relids</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>continue</span><span class='Delimiter'>; 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="initsplan.c.html#LN211"><span class='Ref_To_Local'>attno</span></a> <span class='Operator'>&GT;= </span><a href="initsplan.c.html#LN210"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN555"><span class='Ref_to_Member'>min_attr</span></a> <span class='Operator'>&& </span><a href="initsplan.c.html#LN211"><span class='Ref_To_Local'>attno</span></a> <span class='Operator'>&LT;= </span><a href="initsplan.c.html#LN210"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN556"><span class='Ref_to_Member'>max_attr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="initsplan.c.html#LN211"><span class='Ref_To_Local'>attno</span></a> <span class='Operator'>-= </span><a href="initsplan.c.html#LN210"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN555"><span class='Ref_to_Member'>min_attr</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN210"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN557"><span class='Ref_to_Member'>attr_needed</span></a><span class='Delimiter'>[</span><a href="initsplan.c.html#LN211"><span class='Ref_To_Local'>attno</span></a><span class='Delimiter'>] </span><span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* Variable not yet requested, so add to rel's targetlist */ 
</span>                <span class='Comment_Multi_Line'>/* XXX is copyObject necessary here? */ 
</span>                <a href="initsplan.c.html#LN210"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN535"><span class='Ref_to_Member'>reltarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN882"><span class='Ref_to_Member'>exprs</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN210"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN535"><span class='Ref_to_Member'>reltarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN882"><span class='Ref_to_Member'>exprs</span></a><span class='Delimiter'>, 
</span>                                                <a href="../../../include/nodes/nodes.h.html#LN618"><span class='Ref_to_Macro'>copyObject</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN209"><span class='Ref_To_Local'>var</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>                <span class='Comment_Multi_Line'>/* reltarget cost and width will be computed later */ 
</span>            <span class='Delimiter'>} 
</span>            <a href="initsplan.c.html#LN210"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN557"><span class='Ref_to_Member'>attr_needed</span></a><span class='Delimiter'>[</span><a href="initsplan.c.html#LN211"><span class='Ref_To_Local'>attno</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN91"><span class='Ref_to_Proto'>bms_add_members</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN210"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN557"><span class='Ref_to_Member'>attr_needed</span></a><span class='Delimiter'>[</span><a href="initsplan.c.html#LN211"><span class='Ref_To_Local'>attno</span></a><span class='Delimiter'>], 
</span>                                                      <a href="initsplan.c.html#LN197"><span class='Ref_to_Parameter'>where_needed</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if IsA(node,Var) &raquo; </span> 
        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN205"><span class='Ref_To_Local'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1846"><span class='Ref_to_Struct'>PlaceHolderVar</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN230"></a>            <a href="../../../include/nodes/relation.h.html#LN1846"><span class='Ref_to_Struct'>PlaceHolderVar</span></a> <span class='Operator'>*</span><span class='Declare_Local'>phv</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1846"><span class='Ref_to_Struct'>PlaceHolderVar</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN205"><span class='Ref_To_Local'>node</span></a><span class='Delimiter'>; 
</span><a name="LN231"></a>            <a href="../../../include/nodes/relation.h.html#LN2057"><span class='Ref_to_Struct'>PlaceHolderInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>phinfo</span> <span class='Operator'>= </span><a href="../../../include/optimizer/placeholder.h.html#LN21"><span class='Ref_to_Proto'>find_placeholder_info</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN196"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN230"><span class='Ref_To_Local'>phv</span></a><span class='Delimiter'>, 
</span>                                                            <a href="initsplan.c.html#LN197"><span class='Ref_to_Parameter'>create_new_ph</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="initsplan.c.html#LN231"><span class='Ref_To_Local'>phinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2065"><span class='Ref_to_Member'>ph_needed</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN91"><span class='Ref_to_Proto'>bms_add_members</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN231"><span class='Ref_To_Local'>phinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2065"><span class='Ref_to_Member'>ph_needed</span></a><span class='Delimiter'>, 
</span>                                                <a href="initsplan.c.html#LN197"><span class='Ref_to_Parameter'>where_needed</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized node type: %d"</span><span class='Delimiter'>, </span><span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="../../../include/nodes/nodes.h.html#LN513"><span class='Ref_to_Macro'>nodeTag</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN205"><span class='Ref_To_Local'>node</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
}</span><span class='Auto_Annotations'> &laquo; end add_vars_to_targetlist &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/***************************************************************************** 
 * 
 *    LATERAL REFERENCES 
 * 
 *****************************************************************************/ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * find_lateral_references 
 *    For each LATERAL subquery, extract all its references to Vars and 
 *    PlaceHolderVars of the current query level, and make sure those values 
 *    will be available for evaluation of the subquery. 
 * 
 * While later planning steps ensure that the Var/PHV source rels are on the 
 * outside of nestloops relative to the LATERAL subquery, we also need to 
 * ensure that the Vars/PHVs propagate up to the nestloop join level; this 
 * means setting suitable where_needed values for them. 
 * 
 * Note that this only deals with lateral references in unflattened LATERAL 
 * subqueries.  When we flatten a LATERAL subquery, its lateral references 
 * become plain Vars in the parent query, but they may have to be wrapped in 
 * PlaceHolderVars if they need to be forced NULL by outer joins that don't 
 * also null the LATERAL subquery.  That's all handled elsewhere. 
 * 
 * This has to run before deconstruct_jointree, since it might result in 
 * creation of PlaceHolderInfos. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN270"></a><span class='Declare_Function'>find_lateral_references</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN272"></a>    <a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Local'>rti</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* We need do nothing if the query contains no LATERAL RTEs */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="initsplan.c.html#LN270"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN299"><span class='Ref_to_Member'>hasLateralRTEs</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Examine all baserels (the rel array has been set up by now). 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN272"><span class='Ref_To_Local'>rti</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="initsplan.c.html#LN272"><span class='Ref_To_Local'>rti</span></a> <span class='Operator'>&LT; </span><a href="initsplan.c.html#LN270"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN179"><span class='Ref_to_Member'>simple_rel_array_size</span></a><span class='Delimiter'>; </span><a href="initsplan.c.html#LN272"><span class='Ref_To_Local'>rti</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN283"></a>        <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>brel</span> <span class='Operator'>= </span><a href="initsplan.c.html#LN270"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN178"><span class='Ref_to_Member'>simple_rel_array</span></a><span class='Delimiter'>[</span><a href="initsplan.c.html#LN272"><span class='Ref_To_Local'>rti</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Comment_Multi_Line'>/* there may be empty slots corresponding to non-baserel RTEs */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN283"><span class='Ref_To_Local'>brel</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="initsplan.c.html#LN283"><span class='Ref_To_Local'>brel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a> <span class='Operator'>== </span><a href="initsplan.c.html#LN272"><span class='Ref_To_Local'>rti</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* sanity check on array */ 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * This bit is less obvious than it might look.  We ignore appendrel 
         * otherrels and consider only their parent baserels.  In a case where 
         * a LATERAL-containing UNION ALL subquery was pulled up, it is the 
         * otherrel that is actually going to be in the plan.  However, we 
         * want to mark all its lateral references as needed by the parent, 
         * because it is the parent's relid that will be used for join 
         * planning purposes.  And the parent's RTE will contain all the 
         * lateral references we need to know, since the pulled-up member is 
         * nothing but a copy of parts of the original RTE's subquery.  We 
         * could visit the parent's children instead and transform their 
         * references back to the parent's relid, but it would be much more 
         * complicated for no real gain.  (Important here is that the child 
         * members have not yet received any processing beyond being pulled 
         * up.)  Similarly, in appendrels created by inheritance expansion, 
         * it's sufficient to look at the parent relation. 
         */ 
</span> 
        <span class='Comment_Multi_Line'>/* ignore RTEs that are "other rels" */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN283"><span class='Ref_To_Local'>brel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN521"><span class='Ref_to_Member'>reloptkind</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/relation.h.html#LN493"><span class='Ref_to_EnumConst'>RELOPT_BASEREL</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <a href="initsplan.c.html#LN47"><span class='Ref_to_Proto'>extract_lateral_references</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN270"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN283"><span class='Ref_To_Local'>brel</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN272"><span class='Ref_To_Local'>rti</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for rti=1;rti&LT;root-&GT;simpl... &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end find_lateral_references &raquo; </span> 
 
<span class='Keyword'>static void 
</span><a name="LN318"></a><span class='Declare_Function'>extract_lateral_references</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>brel</span><span class='Delimiter'>, </span><a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a> <span class='Declare_Parameter'>rtindex</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN320"></a>    <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span> <span class='Operator'>= </span><a href="initsplan.c.html#LN318"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN187"><span class='Ref_to_Member'>simple_rte_array</span></a><span class='Delimiter'>[</span><a href="initsplan.c.html#LN318"><span class='Ref_to_Parameter'>rtindex</span></a><span class='Delimiter'>]; 
</span><a name="LN321"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>vars</span><span class='Delimiter'>; 
</span><a name="LN322"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>newvars</span><span class='Delimiter'>; 
</span><a name="LN323"></a>    <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>where_needed</span><span class='Delimiter'>; 
</span><a name="LN324"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* No cross-references are possible if it's not LATERAL */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="initsplan.c.html#LN320"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1024"><span class='Ref_to_Member'>lateral</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Fetch the appropriate variables */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN320"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN936"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/parsenodes.h.html#LN922"><span class='Ref_to_EnumConst'>RTE_RELATION</span></a><span class='Parentheses'>) 
</span>        <a href="initsplan.c.html#LN321"><span class='Ref_To_Local'>vars</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/var.h.html#LN32"><span class='Ref_to_Proto'>pull_vars_of_level</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN320"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN949"><span class='Ref_to_Member'>tablesample</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN320"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN936"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/parsenodes.h.html#LN923"><span class='Ref_to_EnumConst'>RTE_SUBQUERY</span></a><span class='Parentheses'>) 
</span>        <a href="initsplan.c.html#LN321"><span class='Ref_To_Local'>vars</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/var.h.html#LN32"><span class='Ref_to_Proto'>pull_vars_of_level</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN320"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN954"><span class='Ref_to_Member'>subquery</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN320"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN936"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/parsenodes.h.html#LN925"><span class='Ref_to_EnumConst'>RTE_FUNCTION</span></a><span class='Parentheses'>) 
</span>        <a href="initsplan.c.html#LN321"><span class='Ref_To_Local'>vars</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/var.h.html#LN32"><span class='Ref_to_Proto'>pull_vars_of_level</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN320"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN985"><span class='Ref_to_Member'>functions</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN320"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN936"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/parsenodes.h.html#LN926"><span class='Ref_to_EnumConst'>RTE_TABLEFUNC</span></a><span class='Parentheses'>) 
</span>        <a href="initsplan.c.html#LN321"><span class='Ref_To_Local'>vars</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/var.h.html#LN32"><span class='Ref_to_Proto'>pull_vars_of_level</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN320"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN991"><span class='Ref_to_Member'>tablefunc</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN320"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN936"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/parsenodes.h.html#LN927"><span class='Ref_to_EnumConst'>RTE_VALUES</span></a><span class='Parentheses'>) 
</span>        <a href="initsplan.c.html#LN321"><span class='Ref_To_Local'>vars</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/var.h.html#LN32"><span class='Ref_to_Proto'>pull_vars_of_level</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN320"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN996"><span class='Ref_to_Member'>values_lists</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>;</span>                 <span class='Comment_Single_Line'>/* keep compiler quiet */ 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN321"><span class='Ref_To_Local'>vars</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>;</span>                 <span class='Comment_Single_Line'>/* nothing to do */ 
</span> 
    <span class='Comment_Multi_Line'>/* Copy each Var (or PlaceHolderVar) and adjust it to match our level */ 
</span>    <a href="initsplan.c.html#LN322"><span class='Ref_To_Local'>newvars</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN324"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN321"><span class='Ref_To_Local'>vars</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN354"></a>        <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>node</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN324"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="initsplan.c.html#LN354"><span class='Ref_To_Local'>node</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN618"><span class='Ref_to_Macro'>copyObject</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN354"><span class='Ref_To_Local'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN354"><span class='Ref_To_Local'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN359"></a>            <a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>var</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN354"><span class='Ref_To_Local'>node</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Adjustment is easy since it's just one node */ 
</span>            <a href="initsplan.c.html#LN359"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN172"><span class='Ref_to_Member'>varlevelsup</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN354"><span class='Ref_To_Local'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1846"><span class='Ref_to_Struct'>PlaceHolderVar</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN366"></a>            <a href="../../../include/nodes/relation.h.html#LN1846"><span class='Ref_to_Struct'>PlaceHolderVar</span></a> <span class='Operator'>*</span><span class='Declare_Local'>phv</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1846"><span class='Ref_to_Struct'>PlaceHolderVar</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN354"><span class='Ref_To_Local'>node</span></a><span class='Delimiter'>; 
</span><a name="LN367"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>levelsup</span> <span class='Operator'>= </span><a href="initsplan.c.html#LN366"><span class='Ref_To_Local'>phv</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1852"><span class='Ref_to_Member'>phlevelsup</span></a><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Have to work harder to adjust the contained expression too */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN367"><span class='Ref_To_Local'>levelsup</span></a> <span class='Operator'>!= </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <a href="../../../include/rewrite/rewriteManip.h.html#LN44"><span class='Ref_to_Proto'>IncrementVarSublevelsUp</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN354"><span class='Ref_To_Local'>node</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><a href="initsplan.c.html#LN367"><span class='Ref_To_Local'>levelsup</span></a><span class='Delimiter'>, </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * If we pulled the PHV out of a subquery RTE, its expression 
             * needs to be preprocessed.  subquery_planner() already did this 
             * for level-zero PHVs in function and values RTEs, though. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN367"><span class='Ref_To_Local'>levelsup</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>                <a href="initsplan.c.html#LN366"><span class='Ref_To_Local'>phv</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1849"><span class='Ref_to_Member'>phexpr</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/planner.h.html#LN55"><span class='Ref_to_Proto'>preprocess_phv_expression</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN318"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN366"><span class='Ref_To_Local'>phv</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1849"><span class='Ref_to_Member'>phexpr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="initsplan.c.html#LN322"><span class='Ref_To_Local'>newvars</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN322"><span class='Ref_To_Local'>newvars</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN354"><span class='Ref_To_Local'>node</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN265"><span class='Ref_to_Proto'>list_free</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN321"><span class='Ref_To_Local'>vars</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We mark the Vars as being "needed" at the LATERAL RTE.  This is a bit 
     * of a cheat: a more formal approach would be to mark each one as needed 
     * at the join of the LATERAL RTE with its source RTE.  But it will work, 
     * and it's much less tedious than computing a separate where_needed for 
     * each Var. 
     */ 
</span>    <a href="initsplan.c.html#LN323"><span class='Ref_To_Local'>where_needed</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN67"><span class='Ref_to_Proto'>bms_make_singleton</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN318"><span class='Ref_to_Parameter'>rtindex</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Push Vars into their source relations' targetlists, and PHVs into 
     * root-&GT;placeholder_list. 
     */ 
</span>    <a href="../../../include/optimizer/planmain.h.html#LN75"><span class='Ref_to_Proto'>add_vars_to_targetlist</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN318"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN322"><span class='Ref_To_Local'>newvars</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN323"><span class='Ref_To_Local'>where_needed</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Remember the lateral references for create_lateral_join_info */ 
</span>    <a href="initsplan.c.html#LN318"><span class='Ref_to_Parameter'>brel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN559"><span class='Ref_to_Member'>lateral_vars</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN322"><span class='Ref_To_Local'>newvars</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end extract_lateral_references &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * create_lateral_join_info 
 *    Fill in the per-base-relation direct_lateral_relids, lateral_relids 
 *    and lateral_referencers sets. 
 * 
 * This has to run after deconstruct_jointree, because we need to know the 
 * final ph_eval_at values for PlaceHolderVars. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN416"></a><span class='Declare_Function'>create_lateral_join_info</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN418"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>found_laterals</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN419"></a>    <a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Local'>rti</span><span class='Delimiter'>; 
</span><a name="LN420"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* We need do nothing if the query contains no LATERAL RTEs */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="initsplan.c.html#LN416"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN299"><span class='Ref_to_Member'>hasLateralRTEs</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Examine all baserels (the rel array has been set up by now). 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN419"><span class='Ref_To_Local'>rti</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="initsplan.c.html#LN419"><span class='Ref_To_Local'>rti</span></a> <span class='Operator'>&LT; </span><a href="initsplan.c.html#LN416"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN179"><span class='Ref_to_Member'>simple_rel_array_size</span></a><span class='Delimiter'>; </span><a href="initsplan.c.html#LN419"><span class='Ref_To_Local'>rti</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN431"></a>        <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>brel</span> <span class='Operator'>= </span><a href="initsplan.c.html#LN416"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN178"><span class='Ref_to_Member'>simple_rel_array</span></a><span class='Delimiter'>[</span><a href="initsplan.c.html#LN419"><span class='Ref_To_Local'>rti</span></a><span class='Delimiter'>]; 
</span><a name="LN432"></a>        <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>lateral_relids</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* there may be empty slots corresponding to non-baserel RTEs */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN431"><span class='Ref_To_Local'>brel</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="initsplan.c.html#LN431"><span class='Ref_To_Local'>brel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN552"><span class='Ref_to_Member'>relid</span></a> <span class='Operator'>== </span><a href="initsplan.c.html#LN419"><span class='Ref_To_Local'>rti</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* sanity check on array */ 
</span> 
        <span class='Comment_Multi_Line'>/* ignore RTEs that are "other rels" */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN431"><span class='Ref_To_Local'>brel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN521"><span class='Ref_to_Member'>reloptkind</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/relation.h.html#LN493"><span class='Ref_to_EnumConst'>RELOPT_BASEREL</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <a href="initsplan.c.html#LN432"><span class='Ref_To_Local'>lateral_relids</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* consider each laterally-referenced Var or PHV */ 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN420"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN431"><span class='Ref_To_Local'>brel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN559"><span class='Ref_to_Member'>lateral_vars</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN449"></a>            <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>node</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN420"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN449"><span class='Ref_To_Local'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span><a name="LN453"></a>                <a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>var</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN449"><span class='Ref_To_Local'>node</span></a><span class='Delimiter'>; 
</span> 
                <a href="initsplan.c.html#LN418"><span class='Ref_To_Local'>found_laterals</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <a href="initsplan.c.html#LN432"><span class='Ref_To_Local'>lateral_relids</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN89"><span class='Ref_to_Proto'>bms_add_member</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN432"><span class='Ref_To_Local'>lateral_relids</span></a><span class='Delimiter'>, 
</span>                                                <a href="initsplan.c.html#LN453"><span class='Ref_To_Local'>var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN165"><span class='Ref_to_Member'>varno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN449"><span class='Ref_To_Local'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN1846"><span class='Ref_to_Struct'>PlaceHolderVar</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span><a name="LN461"></a>                <a href="../../../include/nodes/relation.h.html#LN1846"><span class='Ref_to_Struct'>PlaceHolderVar</span></a> <span class='Operator'>*</span><span class='Declare_Local'>phv</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1846"><span class='Ref_to_Struct'>PlaceHolderVar</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN449"><span class='Ref_To_Local'>node</span></a><span class='Delimiter'>; 
</span><a name="LN462"></a>                <a href="../../../include/nodes/relation.h.html#LN2057"><span class='Ref_to_Struct'>PlaceHolderInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>phinfo</span> <span class='Operator'>= </span><a href="../../../include/optimizer/placeholder.h.html#LN21"><span class='Ref_to_Proto'>find_placeholder_info</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN416"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN461"><span class='Ref_To_Local'>phv</span></a><span class='Delimiter'>, 
</span>                                                                <span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="initsplan.c.html#LN418"><span class='Ref_To_Local'>found_laterals</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <a href="initsplan.c.html#LN432"><span class='Ref_To_Local'>lateral_relids</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN91"><span class='Ref_to_Proto'>bms_add_members</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN432"><span class='Ref_To_Local'>lateral_relids</span></a><span class='Delimiter'>, 
</span>                                                 <a href="initsplan.c.html#LN462"><span class='Ref_To_Local'>phinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2063"><span class='Ref_to_Member'>ph_eval_at</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>else</span> 
                <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* We now have all the simple lateral refs from this rel */ 
</span>        <a href="initsplan.c.html#LN431"><span class='Ref_To_Local'>brel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN548"><span class='Ref_to_Member'>direct_lateral_relids</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN432"><span class='Ref_To_Local'>lateral_relids</span></a><span class='Delimiter'>; 
</span>        <a href="initsplan.c.html#LN431"><span class='Ref_To_Local'>brel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN549"><span class='Ref_to_Member'>lateral_relids</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN65"><span class='Ref_to_Proto'>bms_copy</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN432"><span class='Ref_To_Local'>lateral_relids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for rti=1;rti&LT;root-&GT;simpl... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Now check for lateral references within PlaceHolderVars, and mark their 
     * eval_at rels as having lateral references to the source rels. 
     * 
     * For a PHV that is due to be evaluated at a baserel, mark its source(s) 
     * as direct lateral dependencies of the baserel (adding onto the ones 
     * recorded above).  If it's due to be evaluated at a join, mark its 
     * source(s) as indirect lateral dependencies of each baserel in the join, 
     * ie put them into lateral_relids but not direct_lateral_relids.  This is 
     * appropriate because we can't put any such baserel on the outside of a 
     * join to one of the PHV's lateral dependencies, but on the other hand we 
     * also can't yet join it directly to the dependency. 
     */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN420"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN416"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN257"><span class='Ref_to_Member'>placeholder_list</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN493"></a>        <a href="../../../include/nodes/relation.h.html#LN2057"><span class='Ref_to_Struct'>PlaceHolderInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>phinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN2057"><span class='Ref_to_Struct'>PlaceHolderInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN420"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN494"></a>        <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>eval_at</span> <span class='Operator'>= </span><a href="initsplan.c.html#LN493"><span class='Ref_To_Local'>phinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2063"><span class='Ref_to_Member'>ph_eval_at</span></a><span class='Delimiter'>; 
</span><a name="LN495"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>varno</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN493"><span class='Ref_To_Local'>phinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2064"><span class='Ref_to_Member'>ph_lateral</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* PHV is uninteresting if no lateral refs */ 
</span> 
        <a href="initsplan.c.html#LN418"><span class='Ref_To_Local'>found_laterals</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN80"><span class='Ref_to_Proto'>bms_get_singleton_member</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN494"><span class='Ref_To_Local'>eval_at</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="initsplan.c.html#LN495"><span class='Ref_To_Local'>varno</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Evaluation site is a baserel */ 
</span><a name="LN505"></a>            <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>brel</span> <span class='Operator'>= </span><a href="../util/relnode.c.html#LN241"><span class='Ref_to_Func'>find_base_rel</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN416"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN495"><span class='Ref_To_Local'>varno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="initsplan.c.html#LN505"><span class='Ref_To_Local'>brel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN548"><span class='Ref_to_Member'>direct_lateral_relids</span></a> <span class='Operator'>= 
</span>                <a href="../../../include/nodes/bitmapset.h.html#LN91"><span class='Ref_to_Proto'>bms_add_members</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN505"><span class='Ref_To_Local'>brel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN548"><span class='Ref_to_Member'>direct_lateral_relids</span></a><span class='Delimiter'>, 
</span>                                <a href="initsplan.c.html#LN493"><span class='Ref_To_Local'>phinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2064"><span class='Ref_to_Member'>ph_lateral</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="initsplan.c.html#LN505"><span class='Ref_To_Local'>brel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN549"><span class='Ref_to_Member'>lateral_relids</span></a> <span class='Operator'>= 
</span>                <a href="../../../include/nodes/bitmapset.h.html#LN91"><span class='Ref_to_Proto'>bms_add_members</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN505"><span class='Ref_To_Local'>brel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN549"><span class='Ref_to_Member'>lateral_relids</span></a><span class='Delimiter'>, 
</span>                                <a href="initsplan.c.html#LN493"><span class='Ref_To_Local'>phinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2064"><span class='Ref_to_Member'>ph_lateral</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Evaluation site is a join */ 
</span>            <a href="initsplan.c.html#LN495"><span class='Ref_To_Local'>varno</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>            <span class='Control'>while</span> <span class='Parentheses'>((</span><a href="initsplan.c.html#LN495"><span class='Ref_To_Local'>varno</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN98"><span class='Ref_to_Proto'>bms_next_member</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN494"><span class='Ref_To_Local'>eval_at</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN495"><span class='Ref_To_Local'>varno</span></a><span class='Parentheses'>))</span> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
            <span class='Delimiter'>{ 
</span><a name="LN520"></a>                <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>brel</span> <span class='Operator'>= </span><a href="../util/relnode.c.html#LN241"><span class='Ref_to_Func'>find_base_rel</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN416"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN495"><span class='Ref_To_Local'>varno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <a href="initsplan.c.html#LN520"><span class='Ref_To_Local'>brel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN549"><span class='Ref_to_Member'>lateral_relids</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN91"><span class='Ref_to_Proto'>bms_add_members</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN520"><span class='Ref_To_Local'>brel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN549"><span class='Ref_to_Member'>lateral_relids</span></a><span class='Delimiter'>, 
</span>                                                       <a href="initsplan.c.html#LN493"><span class='Ref_To_Local'>phinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2064"><span class='Ref_to_Member'>ph_lateral</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we found no actual lateral references, we're done; but reset the 
     * hasLateralRTEs flag to avoid useless work later. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="initsplan.c.html#LN418"><span class='Ref_To_Local'>found_laterals</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="initsplan.c.html#LN416"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN299"><span class='Ref_to_Member'>hasLateralRTEs</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Calculate the transitive closure of the lateral_relids sets, so that 
     * they describe both direct and indirect lateral references.  If relation 
     * X references Y laterally, and Y references Z laterally, then we will 
     * have to scan X on the inside of a nestloop with Z, so for all intents 
     * and purposes X is laterally dependent on Z too. 
     * 
     * This code is essentially Warshall's algorithm for transitive closure. 
     * The outer loop considers each baserel, and propagates its lateral 
     * dependencies to those baserels that have a lateral dependency on it. 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN419"><span class='Ref_To_Local'>rti</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="initsplan.c.html#LN419"><span class='Ref_To_Local'>rti</span></a> <span class='Operator'>&LT; </span><a href="initsplan.c.html#LN416"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN179"><span class='Ref_to_Member'>simple_rel_array_size</span></a><span class='Delimiter'>; </span><a href="initsplan.c.html#LN419"><span class='Ref_To_Local'>rti</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN551"></a>        <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>brel</span> <span class='Operator'>= </span><a href="initsplan.c.html#LN416"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN178"><span class='Ref_to_Member'>simple_rel_array</span></a><span class='Delimiter'>[</span><a href="initsplan.c.html#LN419"><span class='Ref_To_Local'>rti</span></a><span class='Delimiter'>]; 
</span><a name="LN552"></a>        <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>outer_lateral_relids</span><span class='Delimiter'>; 
</span><a name="LN553"></a>        <a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Local'>rti2</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN551"><span class='Ref_To_Local'>brel</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>|| </span><a href="initsplan.c.html#LN551"><span class='Ref_To_Local'>brel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN521"><span class='Ref_to_Member'>reloptkind</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/relation.h.html#LN493"><span class='Ref_to_EnumConst'>RELOPT_BASEREL</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* need not consider baserel further if it has no lateral refs */ 
</span>        <a href="initsplan.c.html#LN552"><span class='Ref_To_Local'>outer_lateral_relids</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN551"><span class='Ref_To_Local'>brel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN549"><span class='Ref_to_Member'>lateral_relids</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN552"><span class='Ref_To_Local'>outer_lateral_relids</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* else scan all baserels */ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN553"><span class='Ref_To_Local'>rti2</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="initsplan.c.html#LN553"><span class='Ref_To_Local'>rti2</span></a> <span class='Operator'>&LT; </span><a href="initsplan.c.html#LN416"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN179"><span class='Ref_to_Member'>simple_rel_array_size</span></a><span class='Delimiter'>; </span><a href="initsplan.c.html#LN553"><span class='Ref_To_Local'>rti2</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN566"></a>            <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>brel2</span> <span class='Operator'>= </span><a href="initsplan.c.html#LN416"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN178"><span class='Ref_to_Member'>simple_rel_array</span></a><span class='Delimiter'>[</span><a href="initsplan.c.html#LN553"><span class='Ref_To_Local'>rti2</span></a><span class='Delimiter'>]; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN566"><span class='Ref_To_Local'>brel2</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>|| </span><a href="initsplan.c.html#LN566"><span class='Ref_To_Local'>brel2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN521"><span class='Ref_to_Member'>reloptkind</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/relation.h.html#LN493"><span class='Ref_to_EnumConst'>RELOPT_BASEREL</span></a><span class='Parentheses'>) 
</span>                <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* if brel2 has lateral ref to brel, propagate brel's refs */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN75"><span class='Ref_to_Proto'>bms_is_member</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN419"><span class='Ref_To_Local'>rti</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN566"><span class='Ref_To_Local'>brel2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN549"><span class='Ref_to_Member'>lateral_relids</span></a><span class='Parentheses'>))</span> 
                <a href="initsplan.c.html#LN566"><span class='Ref_To_Local'>brel2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN549"><span class='Ref_to_Member'>lateral_relids</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN91"><span class='Ref_to_Proto'>bms_add_members</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN566"><span class='Ref_To_Local'>brel2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN549"><span class='Ref_to_Member'>lateral_relids</span></a><span class='Delimiter'>, 
</span>                                                        <a href="initsplan.c.html#LN552"><span class='Ref_To_Local'>outer_lateral_relids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for rti=1;rti&LT;root-&GT;simpl... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Now that we've identified all lateral references, mark each baserel 
     * with the set of relids of rels that reference it laterally (possibly 
     * indirectly) --- that is, the inverse mapping of lateral_relids. 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN419"><span class='Ref_To_Local'>rti</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="initsplan.c.html#LN419"><span class='Ref_To_Local'>rti</span></a> <span class='Operator'>&LT; </span><a href="initsplan.c.html#LN416"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN179"><span class='Ref_to_Member'>simple_rel_array_size</span></a><span class='Delimiter'>; </span><a href="initsplan.c.html#LN419"><span class='Ref_To_Local'>rti</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN585"></a>        <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>brel</span> <span class='Operator'>= </span><a href="initsplan.c.html#LN416"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN178"><span class='Ref_to_Member'>simple_rel_array</span></a><span class='Delimiter'>[</span><a href="initsplan.c.html#LN419"><span class='Ref_To_Local'>rti</span></a><span class='Delimiter'>]; 
</span><a name="LN586"></a>        <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>lateral_relids</span><span class='Delimiter'>; 
</span><a name="LN587"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>rti2</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN585"><span class='Ref_To_Local'>brel</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>|| </span><a href="initsplan.c.html#LN585"><span class='Ref_To_Local'>brel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN521"><span class='Ref_to_Member'>reloptkind</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/relation.h.html#LN493"><span class='Ref_to_EnumConst'>RELOPT_BASEREL</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Nothing to do at rels with no lateral refs */ 
</span>        <a href="initsplan.c.html#LN586"><span class='Ref_To_Local'>lateral_relids</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN585"><span class='Ref_To_Local'>brel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN549"><span class='Ref_to_Member'>lateral_relids</span></a><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN586"><span class='Ref_To_Local'>lateral_relids</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We should not have broken the invariant that lateral_relids is 
         * exactly NULL if empty. 
         */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN85"><span class='Ref_to_Proto'>bms_is_empty</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN586"><span class='Ref_To_Local'>lateral_relids</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Also, no rel should have a lateral dependency on itself */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN75"><span class='Ref_to_Proto'>bms_is_member</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN419"><span class='Ref_To_Local'>rti</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN586"><span class='Ref_To_Local'>lateral_relids</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Mark this rel's referencees */ 
</span>        <a href="initsplan.c.html#LN587"><span class='Ref_To_Local'>rti2</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span>        <span class='Control'>while</span> <span class='Parentheses'>((</span><a href="initsplan.c.html#LN587"><span class='Ref_To_Local'>rti2</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN98"><span class='Ref_to_Proto'>bms_next_member</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN586"><span class='Ref_To_Local'>lateral_relids</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN587"><span class='Ref_To_Local'>rti2</span></a><span class='Parentheses'>))</span> <span class='Operator'>&GT;= </span><span class='Number'>0</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span><a name="LN610"></a>            <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>brel2</span> <span class='Operator'>= </span><a href="initsplan.c.html#LN416"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN178"><span class='Ref_to_Member'>simple_rel_array</span></a><span class='Delimiter'>[</span><a href="initsplan.c.html#LN587"><span class='Ref_To_Local'>rti2</span></a><span class='Delimiter'>]; 
</span> 
            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="initsplan.c.html#LN610"><span class='Ref_To_Local'>brel2</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL </span><span class='Operator'>&& </span><a href="initsplan.c.html#LN610"><span class='Ref_To_Local'>brel2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN521"><span class='Ref_to_Member'>reloptkind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/relation.h.html#LN493"><span class='Ref_to_EnumConst'>RELOPT_BASEREL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="initsplan.c.html#LN610"><span class='Ref_To_Local'>brel2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN560"><span class='Ref_to_Member'>lateral_referencers</span></a> <span class='Operator'>= 
</span>                <a href="../../../include/nodes/bitmapset.h.html#LN89"><span class='Ref_to_Proto'>bms_add_member</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN610"><span class='Ref_To_Local'>brel2</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN560"><span class='Ref_to_Member'>lateral_referencers</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN419"><span class='Ref_To_Local'>rti</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for rti=1;rti&LT;root-&GT;simpl... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Lastly, propagate lateral_relids and lateral_referencers from appendrel 
     * parent rels to their child rels.  We intentionally give each child rel 
     * the same minimum parameterization, even though it's quite possible that 
     * some don't reference all the lateral rels.  This is because any append 
     * path for the parent will have to have the same parameterization for 
     * every child anyway, and there's no value in forcing extra 
     * reparameterize_path() calls.  Similarly, a lateral reference to the 
     * parent prevents use of otherwise-movable join rels for each child. 
     */ 
</span>    <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN419"><span class='Ref_To_Local'>rti</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Delimiter'>; </span><a href="initsplan.c.html#LN419"><span class='Ref_To_Local'>rti</span></a> <span class='Operator'>&LT; </span><a href="initsplan.c.html#LN416"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN179"><span class='Ref_to_Member'>simple_rel_array_size</span></a><span class='Delimiter'>; </span><a href="initsplan.c.html#LN419"><span class='Ref_To_Local'>rti</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN630"></a>        <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>brel</span> <span class='Operator'>= </span><a href="initsplan.c.html#LN416"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN178"><span class='Ref_to_Member'>simple_rel_array</span></a><span class='Delimiter'>[</span><a href="initsplan.c.html#LN419"><span class='Ref_To_Local'>rti</span></a><span class='Delimiter'>]; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN630"><span class='Ref_To_Local'>brel</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>|| </span><a href="initsplan.c.html#LN630"><span class='Ref_To_Local'>brel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN521"><span class='Ref_to_Member'>reloptkind</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/relation.h.html#LN493"><span class='Ref_to_EnumConst'>RELOPT_BASEREL</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN416"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN187"><span class='Ref_to_Member'>simple_rte_array</span></a><span class='Delimiter'>[</span><a href="initsplan.c.html#LN419"><span class='Ref_To_Local'>rti</span></a><span class='Delimiter'>]</span><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1025"><span class='Ref_to_Member'>inh</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN420"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN416"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN251"><span class='Ref_to_Member'>append_rel_list</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN639"></a>                <a href="../../../include/nodes/relation.h.html#LN1964"><span class='Ref_to_Struct'>AppendRelInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>appinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1964"><span class='Ref_to_Struct'>AppendRelInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN420"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN640"></a>                <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>childrel</span><span class='Delimiter'>; 
</span> 
                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN639"><span class='Ref_To_Local'>appinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1974"><span class='Ref_to_Member'>parent_relid</span></a> <span class='Operator'>!= </span><a href="initsplan.c.html#LN419"><span class='Ref_To_Local'>rti</span></a><span class='Parentheses'>) 
</span>                    <span class='Control'>continue</span><span class='Delimiter'>; 
</span>                <a href="initsplan.c.html#LN640"><span class='Ref_To_Local'>childrel</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN416"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN178"><span class='Ref_to_Member'>simple_rel_array</span></a><span class='Delimiter'>[</span><a href="initsplan.c.html#LN639"><span class='Ref_To_Local'>appinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1975"><span class='Ref_to_Member'>child_relid</span></a><span class='Delimiter'>]; 
</span>                <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="initsplan.c.html#LN640"><span class='Ref_To_Local'>childrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN521"><span class='Ref_to_Member'>reloptkind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/relation.h.html#LN495"><span class='Ref_to_EnumConst'>RELOPT_OTHER_MEMBER_REL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="initsplan.c.html#LN640"><span class='Ref_To_Local'>childrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN548"><span class='Ref_to_Member'>direct_lateral_relids</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="initsplan.c.html#LN640"><span class='Ref_To_Local'>childrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN548"><span class='Ref_to_Member'>direct_lateral_relids</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN630"><span class='Ref_To_Local'>brel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN548"><span class='Ref_to_Member'>direct_lateral_relids</span></a><span class='Delimiter'>; 
</span>                <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="initsplan.c.html#LN640"><span class='Ref_To_Local'>childrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN549"><span class='Ref_to_Member'>lateral_relids</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="initsplan.c.html#LN640"><span class='Ref_To_Local'>childrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN549"><span class='Ref_to_Member'>lateral_relids</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN630"><span class='Ref_To_Local'>brel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN549"><span class='Ref_to_Member'>lateral_relids</span></a><span class='Delimiter'>; 
</span>                <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="initsplan.c.html#LN640"><span class='Ref_To_Local'>childrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN560"><span class='Ref_to_Member'>lateral_referencers</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="initsplan.c.html#LN640"><span class='Ref_To_Local'>childrel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN560"><span class='Ref_to_Member'>lateral_referencers</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN630"><span class='Ref_To_Local'>brel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN560"><span class='Ref_to_Member'>lateral_referencers</span></a><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for rti=1;rti&LT;root-&GT;simpl... &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end create_lateral_join_info &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/***************************************************************************** 
 * 
 *    JOIN TREE PROCESSING 
 * 
 *****************************************************************************/ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * deconstruct_jointree 
 *    Recursively scan the query's join tree for WHERE and JOIN/ON qual 
 *    clauses, and add these to the appropriate restrictinfo and joininfo 
 *    lists belonging to base RelOptInfos.  Also, add SpecialJoinInfo nodes 
 *    to root-&GT;join_info_list for any outer joins appearing in the query tree. 
 *    Return a "joinlist" data structure showing the join order decisions 
 *    that need to be made by make_one_rel(). 
 * 
 * The "joinlist" result is a list of items that are either RangeTblRef 
 * jointree nodes or sub-joinlists.  All the items at the same level of 
 * joinlist must be joined in an order to be determined by make_one_rel() 
 * (note that legal orders may be constrained by SpecialJoinInfo nodes). 
 * A sub-joinlist represents a subproblem to be planned separately. Currently 
 * sub-joinlists arise only from FULL OUTER JOIN or when collapsing of 
 * subproblems is stopped by join_collapse_limit or from_collapse_limit. 
 * 
 * NOTE: when dealing with inner joins, it is appropriate to let a qual clause 
 * be evaluated at the lowest level where all the variables it mentions are 
 * available.  However, we cannot push a qual down into the nullable side(s) 
 * of an outer join since the qual might eliminate matching rows and cause a 
 * NULL row to be incorrectly emitted by the join.  Therefore, we artificially 
 * OR the minimum-relids of such an outer join into the required_relids of 
 * clauses appearing above it.  This forces those clauses to be delayed until 
 * application of the outer join (or maybe even higher in the join tree). 
 */ 
</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN691"></a><span class='Declare_Function'>deconstruct_jointree</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN693"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>result</span><span class='Delimiter'>; 
</span><a name="LN694"></a>    <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>qualscope</span><span class='Delimiter'>; 
</span><a name="LN695"></a>    <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>inner_join_rels</span><span class='Delimiter'>; 
</span><a name="LN696"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>postponed_qual_list</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Start recursion at top of jointree */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="initsplan.c.html#LN691"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN135"><span class='Ref_to_Member'>jointree</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL </span><span class='Operator'>&& 
</span>           <a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN691"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN135"><span class='Ref_to_Member'>jointree</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN1466"><span class='Ref_to_Struct'>FromExpr</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* this is filled as we scan the jointree */ 
</span>    <a href="initsplan.c.html#LN691"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN203"><span class='Ref_to_Member'>nullable_baserels</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
    <a href="initsplan.c.html#LN693"><span class='Ref_To_Local'>result</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN49"><span class='Ref_to_Proto'>deconstruct_recurse</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN691"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN691"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN135"><span class='Ref_to_Member'>jointree</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                                 <span class='Operator'>&</span><a href="initsplan.c.html#LN694"><span class='Ref_To_Local'>qualscope</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="initsplan.c.html#LN695"><span class='Ref_To_Local'>inner_join_rels</span></a><span class='Delimiter'>, 
</span>                                 <span class='Operator'>&</span><a href="initsplan.c.html#LN696"><span class='Ref_To_Local'>postponed_qual_list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Shouldn't be any leftover quals */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="initsplan.c.html#LN696"><span class='Ref_To_Local'>postponed_qual_list</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="initsplan.c.html#LN693"><span class='Ref_To_Local'>result</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end deconstruct_jointree &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * deconstruct_recurse 
 *    One recursion level of deconstruct_jointree processing. 
 * 
 * Inputs: 
 *  jtnode is the jointree node to examine 
 *  below_outer_join is TRUE if this node is within the nullable side of a 
 *      higher-level outer join 
 * Outputs: 
 *  *qualscope gets the set of base Relids syntactically included in this 
 *      jointree node (do not modify or free this, as it may also be pointed 
 *      to by RestrictInfo and SpecialJoinInfo nodes) 
 *  *inner_join_rels gets the set of base Relids syntactically included in 
 *      inner joins appearing at or below this jointree node (do not modify 
 *      or free this, either) 
 *  *postponed_qual_list is a list of PostponedQual structs, which we can 
 *      add quals to if they turn out to belong to a higher join level 
 *  Return value is the appropriate joinlist for this jointree node 
 * 
 * In addition, entries will be added to root-&GT;join_info_list for outer joins. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>* 
</span><a name="LN737"></a><span class='Declare_Function'>deconstruct_recurse</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>jtnode</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>below_outer_join</span><span class='Delimiter'>, 
</span><a name="LN738"></a>                    <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>qualscope</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>inner_join_rels</span><span class='Delimiter'>, 
</span><a name="LN739"></a>                    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>postponed_qual_list</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN741"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>joinlist</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN737"><span class='Ref_to_Parameter'>jtnode</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Operator'>*</span><a href="initsplan.c.html#LN738"><span class='Ref_to_Parameter'>qualscope</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="initsplan.c.html#LN738"><span class='Ref_to_Parameter'>inner_join_rels</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN737"><span class='Ref_to_Parameter'>jtnode</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN1415"><span class='Ref_to_Struct'>RangeTblRef</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN751"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>varno</span> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN1415"><span class='Ref_to_Struct'>RangeTblRef</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN737"><span class='Ref_to_Parameter'>jtnode</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>rtindex<span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* qualscope is just the one RTE */ 
</span>        <span class='Operator'>*</span><a href="initsplan.c.html#LN738"><span class='Ref_to_Parameter'>qualscope</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN67"><span class='Ref_to_Proto'>bms_make_singleton</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN751"><span class='Ref_To_Local'>varno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* Deal with any securityQuals attached to the RTE */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN737"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN293"><span class='Ref_to_Member'>qual_security_level</span></a> <span class='Operator'>&GT; </span><span class='Number'>0</span><span class='Parentheses'>) 
</span>            <a href="initsplan.c.html#LN53"><span class='Ref_to_Proto'>process_security_barrier_quals</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN737"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                           <a href="initsplan.c.html#LN751"><span class='Ref_To_Local'>varno</span></a><span class='Delimiter'>, 
</span>                                           <span class='Operator'>*</span><a href="initsplan.c.html#LN738"><span class='Ref_to_Parameter'>qualscope</span></a><span class='Delimiter'>, 
</span>                                           <a href="initsplan.c.html#LN737"><span class='Ref_to_Parameter'>below_outer_join</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* A single baserel does not create an inner join */ 
</span>        <span class='Operator'>*</span><a href="initsplan.c.html#LN738"><span class='Ref_to_Parameter'>inner_join_rels</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <a href="initsplan.c.html#LN741"><span class='Ref_To_Local'>joinlist</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN138"><span class='Ref_to_Macro'>list_make1</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN737"><span class='Ref_to_Parameter'>jtnode</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN737"><span class='Ref_to_Parameter'>jtnode</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN1466"><span class='Ref_to_Struct'>FromExpr</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN767"></a>        <a href="../../../include/nodes/primnodes.h.html#LN1466"><span class='Ref_to_Struct'>FromExpr</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>f</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1466"><span class='Ref_to_Struct'>FromExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN737"><span class='Ref_to_Parameter'>jtnode</span></a><span class='Delimiter'>; 
</span><a name="LN768"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>child_postponed_quals</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN769"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>remaining</span><span class='Delimiter'>; 
</span><a name="LN770"></a>        <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * First, recurse to handle child joins.  We collapse subproblems into 
         * a single joinlist whenever the resulting joinlist wouldn't exceed 
         * from_collapse_limit members.  Also, always collapse one-element 
         * subproblems, since that won't lengthen the joinlist anyway. 
         */ 
</span>        <span class='Operator'>*</span><a href="initsplan.c.html#LN738"><span class='Ref_to_Parameter'>qualscope</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="initsplan.c.html#LN738"><span class='Ref_to_Parameter'>inner_join_rels</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <a href="initsplan.c.html#LN741"><span class='Ref_To_Local'>joinlist</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>        <a href="initsplan.c.html#LN769"><span class='Ref_To_Local'>remaining</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN767"><span class='Ref_To_Local'>f</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1469"><span class='Ref_to_Member'>fromlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN770"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN767"><span class='Ref_To_Local'>f</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1469"><span class='Ref_to_Member'>fromlist</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN784"></a>            <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>sub_qualscope</span><span class='Delimiter'>; 
</span><a name="LN785"></a>            <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>sub_joinlist</span><span class='Delimiter'>; 
</span><a name="LN786"></a>            <span class='Keyword'>int</span>         <span class='Declare_Local'>sub_members</span><span class='Delimiter'>; 
</span> 
            <a href="initsplan.c.html#LN785"><span class='Ref_To_Local'>sub_joinlist</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN49"><span class='Ref_to_Proto'>deconstruct_recurse</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN737"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN770"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                               <a href="initsplan.c.html#LN737"><span class='Ref_to_Parameter'>below_outer_join</span></a><span class='Delimiter'>, 
</span>                                               <span class='Operator'>&</span><a href="initsplan.c.html#LN784"><span class='Ref_To_Local'>sub_qualscope</span></a><span class='Delimiter'>, 
</span>                                               <a href="initsplan.c.html#LN738"><span class='Ref_to_Parameter'>inner_join_rels</span></a><span class='Delimiter'>, 
</span>                                               <span class='Operator'>&</span><a href="initsplan.c.html#LN768"><span class='Ref_To_Local'>child_postponed_quals</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Operator'>*</span><a href="initsplan.c.html#LN738"><span class='Ref_to_Parameter'>qualscope</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN91"><span class='Ref_to_Proto'>bms_add_members</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="initsplan.c.html#LN738"><span class='Ref_to_Parameter'>qualscope</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN784"><span class='Ref_To_Local'>sub_qualscope</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="initsplan.c.html#LN786"><span class='Ref_To_Local'>sub_members</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN785"><span class='Ref_To_Local'>sub_joinlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <a href="initsplan.c.html#LN769"><span class='Ref_To_Local'>remaining</span></a><span class='Operator'>--</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN786"><span class='Ref_To_Local'>sub_members</span></a> <span class='Operator'>&LT;= </span><span class='Number'>1</span> <span class='Operator'>|| 
</span>                <a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN741"><span class='Ref_To_Local'>joinlist</span></a><span class='Parentheses'>) </span><span class='Operator'>+ </span><a href="initsplan.c.html#LN786"><span class='Ref_To_Local'>sub_members</span></a> <span class='Operator'>+ </span><a href="initsplan.c.html#LN769"><span class='Ref_To_Local'>remaining</span></a> <span class='Operator'>&LT;= </span><a href="initsplan.c.html#LN35"><span class='Ref_to_Global_Var'>from_collapse_limit</span></a><span class='Parentheses'>)</span> 
                <a href="initsplan.c.html#LN741"><span class='Ref_To_Local'>joinlist</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN219"><span class='Ref_to_Proto'>list_concat</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN741"><span class='Ref_To_Local'>joinlist</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN785"><span class='Ref_To_Local'>sub_joinlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="initsplan.c.html#LN741"><span class='Ref_To_Local'>joinlist</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN741"><span class='Ref_To_Local'>joinlist</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN785"><span class='Ref_To_Local'>sub_joinlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * A FROM with more than one list element is an inner join subsuming 
         * all below it, so we should report inner_join_rels = qualscope. If 
         * there was exactly one element, we should (and already did) report 
         * whatever its inner_join_rels were.  If there were no elements (is 
         * that possible?) the initialization before the loop fixed it. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN767"><span class='Ref_To_Local'>f</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1469"><span class='Ref_to_Member'>fromlist</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
            <span class='Operator'>*</span><a href="initsplan.c.html#LN738"><span class='Ref_to_Parameter'>inner_join_rels</span></a> <span class='Operator'>= *</span><a href="initsplan.c.html#LN738"><span class='Ref_to_Parameter'>qualscope</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Try to process any quals postponed by children.  If they need 
         * further postponement, add them to my output postponed_qual_list. 
         */ 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN770"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN768"><span class='Ref_To_Local'>child_postponed_quals</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN819"></a>            <a href="initsplan.c.html#LN40"><span class='Ref_to_Struct'>PostponedQual</span></a> <span class='Operator'>*</span><span class='Declare_Local'>pq</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="initsplan.c.html#LN40"><span class='Ref_to_Struct'>PostponedQual</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN770"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN819"><span class='Ref_To_Local'>pq</span></a><span class='Operator'>-&GT;</span><a href="initsplan.c.html#LN43"><span class='Ref_to_Member'>relids</span></a><span class='Delimiter'>, </span><span class='Operator'>*</span><a href="initsplan.c.html#LN738"><span class='Ref_to_Parameter'>qualscope</span></a><span class='Parentheses'>))</span> 
                <a href="initsplan.c.html#LN61"><span class='Ref_to_Proto'>distribute_qual_to_rels</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN737"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN819"><span class='Ref_To_Local'>pq</span></a><span class='Operator'>-&GT;</span><a href="initsplan.c.html#LN42"><span class='Ref_to_Member'>qual</span></a><span class='Delimiter'>, 
</span>                                        <span class='Boolean'>false</span><span class='Delimiter'>, </span><a href="initsplan.c.html#LN737"><span class='Ref_to_Parameter'>below_outer_join</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN677"><span class='Ref_to_EnumConst'>JOIN_INNER</span></a><span class='Delimiter'>, 
</span>                                        <a href="initsplan.c.html#LN737"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN293"><span class='Ref_to_Member'>qual_security_level</span></a><span class='Delimiter'>, 
</span>                                        <span class='Operator'>*</span><a href="initsplan.c.html#LN738"><span class='Ref_to_Parameter'>qualscope</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                                        <span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <span class='Operator'>*</span><a href="initsplan.c.html#LN739"><span class='Ref_to_Parameter'>postponed_qual_list</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="initsplan.c.html#LN739"><span class='Ref_to_Parameter'>postponed_qual_list</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN819"><span class='Ref_To_Local'>pq</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Now process the top-level quals. 
         */ 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN770"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN767"><span class='Ref_To_Local'>f</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1470"><span class='Ref_to_Member'>quals</span></a><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span><a name="LN836"></a>            <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>qual</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN770"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="initsplan.c.html#LN61"><span class='Ref_to_Proto'>distribute_qual_to_rels</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN737"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN836"><span class='Ref_To_Local'>qual</span></a><span class='Delimiter'>, 
</span>                                    <span class='Boolean'>false</span><span class='Delimiter'>, </span><a href="initsplan.c.html#LN737"><span class='Ref_to_Parameter'>below_outer_join</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN677"><span class='Ref_to_EnumConst'>JOIN_INNER</span></a><span class='Delimiter'>, 
</span>                                    <a href="initsplan.c.html#LN737"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN293"><span class='Ref_to_Member'>qual_security_level</span></a><span class='Delimiter'>, 
</span>                                    <span class='Operator'>*</span><a href="initsplan.c.html#LN738"><span class='Ref_to_Parameter'>qualscope</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                                    <a href="initsplan.c.html#LN739"><span class='Ref_to_Parameter'>postponed_qual_list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if IsA(jtnode,FromExpr) &raquo; </span> 
    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN737"><span class='Ref_to_Parameter'>jtnode</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN1444"><span class='Ref_to_Struct'>JoinExpr</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN847"></a>        <a href="../../../include/nodes/primnodes.h.html#LN1444"><span class='Ref_to_Struct'>JoinExpr</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>j</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1444"><span class='Ref_to_Struct'>JoinExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN737"><span class='Ref_to_Parameter'>jtnode</span></a><span class='Delimiter'>; 
</span><a name="LN848"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>child_postponed_quals</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN849"></a>        <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>leftids</span><span class='Delimiter'>, 
</span><a name="LN850"></a>                    <span class='Declare_Local'>rightids</span><span class='Delimiter'>, 
</span><a name="LN851"></a>                    <span class='Declare_Local'>left_inners</span><span class='Delimiter'>, 
</span><a name="LN852"></a>                    <span class='Declare_Local'>right_inners</span><span class='Delimiter'>, 
</span><a name="LN853"></a>                    <span class='Declare_Local'>nonnullable_rels</span><span class='Delimiter'>, 
</span><a name="LN854"></a>                    <span class='Declare_Local'>nullable_rels</span><span class='Delimiter'>, 
</span><a name="LN855"></a>                    <span class='Declare_Local'>ojscope</span><span class='Delimiter'>; 
</span><a name="LN856"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>leftjoinlist</span><span class='Delimiter'>, 
</span><a name="LN857"></a>                   <span class='Operator'>*</span><span class='Declare_Local'>rightjoinlist</span><span class='Delimiter'>; 
</span><a name="LN858"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>my_quals</span><span class='Delimiter'>; 
</span><a name="LN859"></a>        <a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sjinfo</span><span class='Delimiter'>; 
</span><a name="LN860"></a>        <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Order of operations here is subtle and critical.  First we recurse 
         * to handle sub-JOINs.  Their join quals will be placed without 
         * regard for whether this level is an outer join, which is correct. 
         * Then we place our own join quals, which are restricted by lower 
         * outer joins in any case, and are forced to this level if this is an 
         * outer join and they mention the outer side.  Finally, if this is an 
         * outer join, we create a join_info_list entry for the join.  This 
         * will prevent quals above us in the join tree that use those rels 
         * from being pushed down below this level.  (It's okay for upper 
         * quals to be pushed down to the outer side, however.) 
         */ 
</span>        <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN847"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1447"><span class='Ref_to_Member'>jointype</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN677"><span class='Ref_to_EnumConst'>JOIN_INNER</span></a><span class='Operator'>: 
</span>                <a href="initsplan.c.html#LN856"><span class='Ref_To_Local'>leftjoinlist</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN49"><span class='Ref_to_Proto'>deconstruct_recurse</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN737"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN847"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1449"><span class='Ref_to_Member'>larg</span></a><span class='Delimiter'>, 
</span>                                                   <a href="initsplan.c.html#LN737"><span class='Ref_to_Parameter'>below_outer_join</span></a><span class='Delimiter'>, 
</span>                                                   <span class='Operator'>&</span><a href="initsplan.c.html#LN849"><span class='Ref_To_Local'>leftids</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="initsplan.c.html#LN851"><span class='Ref_To_Local'>left_inners</span></a><span class='Delimiter'>, 
</span>                                                   <span class='Operator'>&</span><a href="initsplan.c.html#LN848"><span class='Ref_To_Local'>child_postponed_quals</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="initsplan.c.html#LN857"><span class='Ref_To_Local'>rightjoinlist</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN49"><span class='Ref_to_Proto'>deconstruct_recurse</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN737"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN847"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1450"><span class='Ref_to_Member'>rarg</span></a><span class='Delimiter'>, 
</span>                                                    <a href="initsplan.c.html#LN737"><span class='Ref_to_Parameter'>below_outer_join</span></a><span class='Delimiter'>, 
</span>                                                    <span class='Operator'>&</span><a href="initsplan.c.html#LN850"><span class='Ref_To_Local'>rightids</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="initsplan.c.html#LN852"><span class='Ref_To_Local'>right_inners</span></a><span class='Delimiter'>, 
</span>                                                    <span class='Operator'>&</span><a href="initsplan.c.html#LN848"><span class='Ref_To_Local'>child_postponed_quals</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Operator'>*</span><a href="initsplan.c.html#LN738"><span class='Ref_to_Parameter'>qualscope</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN70"><span class='Ref_to_Proto'>bms_union</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN849"><span class='Ref_To_Local'>leftids</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN850"><span class='Ref_To_Local'>rightids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Operator'>*</span><a href="initsplan.c.html#LN738"><span class='Ref_to_Parameter'>inner_join_rels</span></a> <span class='Operator'>= *</span><a href="initsplan.c.html#LN738"><span class='Ref_to_Parameter'>qualscope</span></a><span class='Delimiter'>; 
</span>                <span class='Comment_Multi_Line'>/* Inner join adds no restrictions for quals */ 
</span>                <a href="initsplan.c.html#LN853"><span class='Ref_To_Local'>nonnullable_rels</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>                <span class='Comment_Multi_Line'>/* and it doesn't force anything to null, either */ 
</span>                <a href="initsplan.c.html#LN854"><span class='Ref_To_Local'>nullable_rels</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN678"><span class='Ref_to_EnumConst'>JOIN_LEFT</span></a><span class='Operator'>: 
</span>            <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN692"><span class='Ref_to_EnumConst'>JOIN_ANTI</span></a><span class='Operator'>: 
</span>                <a href="initsplan.c.html#LN856"><span class='Ref_To_Local'>leftjoinlist</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN49"><span class='Ref_to_Proto'>deconstruct_recurse</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN737"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN847"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1449"><span class='Ref_to_Member'>larg</span></a><span class='Delimiter'>, 
</span>                                                   <a href="initsplan.c.html#LN737"><span class='Ref_to_Parameter'>below_outer_join</span></a><span class='Delimiter'>, 
</span>                                                   <span class='Operator'>&</span><a href="initsplan.c.html#LN849"><span class='Ref_To_Local'>leftids</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="initsplan.c.html#LN851"><span class='Ref_To_Local'>left_inners</span></a><span class='Delimiter'>, 
</span>                                                   <span class='Operator'>&</span><a href="initsplan.c.html#LN848"><span class='Ref_To_Local'>child_postponed_quals</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="initsplan.c.html#LN857"><span class='Ref_To_Local'>rightjoinlist</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN49"><span class='Ref_to_Proto'>deconstruct_recurse</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN737"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN847"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1450"><span class='Ref_to_Member'>rarg</span></a><span class='Delimiter'>, 
</span>                                                    <span class='Boolean'>true</span><span class='Delimiter'>, 
</span>                                                    <span class='Operator'>&</span><a href="initsplan.c.html#LN850"><span class='Ref_To_Local'>rightids</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="initsplan.c.html#LN852"><span class='Ref_To_Local'>right_inners</span></a><span class='Delimiter'>, 
</span>                                                    <span class='Operator'>&</span><a href="initsplan.c.html#LN848"><span class='Ref_To_Local'>child_postponed_quals</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Operator'>*</span><a href="initsplan.c.html#LN738"><span class='Ref_to_Parameter'>qualscope</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN70"><span class='Ref_to_Proto'>bms_union</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN849"><span class='Ref_To_Local'>leftids</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN850"><span class='Ref_To_Local'>rightids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Operator'>*</span><a href="initsplan.c.html#LN738"><span class='Ref_to_Parameter'>inner_join_rels</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN70"><span class='Ref_to_Proto'>bms_union</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN851"><span class='Ref_To_Local'>left_inners</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN852"><span class='Ref_To_Local'>right_inners</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="initsplan.c.html#LN853"><span class='Ref_To_Local'>nonnullable_rels</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN849"><span class='Ref_To_Local'>leftids</span></a><span class='Delimiter'>; 
</span>                <a href="initsplan.c.html#LN854"><span class='Ref_To_Local'>nullable_rels</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN850"><span class='Ref_To_Local'>rightids</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN691"><span class='Ref_to_EnumConst'>JOIN_SEMI</span></a><span class='Operator'>: 
</span>                <a href="initsplan.c.html#LN856"><span class='Ref_To_Local'>leftjoinlist</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN49"><span class='Ref_to_Proto'>deconstruct_recurse</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN737"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN847"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1449"><span class='Ref_to_Member'>larg</span></a><span class='Delimiter'>, 
</span>                                                   <a href="initsplan.c.html#LN737"><span class='Ref_to_Parameter'>below_outer_join</span></a><span class='Delimiter'>, 
</span>                                                   <span class='Operator'>&</span><a href="initsplan.c.html#LN849"><span class='Ref_To_Local'>leftids</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="initsplan.c.html#LN851"><span class='Ref_To_Local'>left_inners</span></a><span class='Delimiter'>, 
</span>                                                   <span class='Operator'>&</span><a href="initsplan.c.html#LN848"><span class='Ref_To_Local'>child_postponed_quals</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="initsplan.c.html#LN857"><span class='Ref_To_Local'>rightjoinlist</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN49"><span class='Ref_to_Proto'>deconstruct_recurse</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN737"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN847"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1450"><span class='Ref_to_Member'>rarg</span></a><span class='Delimiter'>, 
</span>                                                    <a href="initsplan.c.html#LN737"><span class='Ref_to_Parameter'>below_outer_join</span></a><span class='Delimiter'>, 
</span>                                                    <span class='Operator'>&</span><a href="initsplan.c.html#LN850"><span class='Ref_To_Local'>rightids</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="initsplan.c.html#LN852"><span class='Ref_To_Local'>right_inners</span></a><span class='Delimiter'>, 
</span>                                                    <span class='Operator'>&</span><a href="initsplan.c.html#LN848"><span class='Ref_To_Local'>child_postponed_quals</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Operator'>*</span><a href="initsplan.c.html#LN738"><span class='Ref_to_Parameter'>qualscope</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN70"><span class='Ref_to_Proto'>bms_union</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN849"><span class='Ref_To_Local'>leftids</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN850"><span class='Ref_To_Local'>rightids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Operator'>*</span><a href="initsplan.c.html#LN738"><span class='Ref_to_Parameter'>inner_join_rels</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN70"><span class='Ref_to_Proto'>bms_union</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN851"><span class='Ref_To_Local'>left_inners</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN852"><span class='Ref_To_Local'>right_inners</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Comment_Multi_Line'>/* Semi join adds no restrictions for quals */ 
</span>                <a href="initsplan.c.html#LN853"><span class='Ref_To_Local'>nonnullable_rels</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* 
                 * Theoretically, a semijoin would null the RHS; but since the 
                 * RHS can't be accessed above the join, this is immaterial 
                 * and we needn't account for it. 
                 */ 
</span>                <a href="initsplan.c.html#LN854"><span class='Ref_To_Local'>nullable_rels</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>case</span> <a href="../../../include/nodes/nodes.h.html#LN679"><span class='Ref_to_EnumConst'>JOIN_FULL</span></a><span class='Operator'>: 
</span>                <a href="initsplan.c.html#LN856"><span class='Ref_To_Local'>leftjoinlist</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN49"><span class='Ref_to_Proto'>deconstruct_recurse</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN737"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN847"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1449"><span class='Ref_to_Member'>larg</span></a><span class='Delimiter'>, 
</span>                                                   <span class='Boolean'>true</span><span class='Delimiter'>, 
</span>                                                   <span class='Operator'>&</span><a href="initsplan.c.html#LN849"><span class='Ref_To_Local'>leftids</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="initsplan.c.html#LN851"><span class='Ref_To_Local'>left_inners</span></a><span class='Delimiter'>, 
</span>                                                   <span class='Operator'>&</span><a href="initsplan.c.html#LN848"><span class='Ref_To_Local'>child_postponed_quals</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="initsplan.c.html#LN857"><span class='Ref_To_Local'>rightjoinlist</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN49"><span class='Ref_to_Proto'>deconstruct_recurse</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN737"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN847"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1450"><span class='Ref_to_Member'>rarg</span></a><span class='Delimiter'>, 
</span>                                                    <span class='Boolean'>true</span><span class='Delimiter'>, 
</span>                                                    <span class='Operator'>&</span><a href="initsplan.c.html#LN850"><span class='Ref_To_Local'>rightids</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="initsplan.c.html#LN852"><span class='Ref_To_Local'>right_inners</span></a><span class='Delimiter'>, 
</span>                                                    <span class='Operator'>&</span><a href="initsplan.c.html#LN848"><span class='Ref_To_Local'>child_postponed_quals</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Operator'>*</span><a href="initsplan.c.html#LN738"><span class='Ref_to_Parameter'>qualscope</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN70"><span class='Ref_to_Proto'>bms_union</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN849"><span class='Ref_To_Local'>leftids</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN850"><span class='Ref_To_Local'>rightids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Operator'>*</span><a href="initsplan.c.html#LN738"><span class='Ref_to_Parameter'>inner_join_rels</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN70"><span class='Ref_to_Proto'>bms_union</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN851"><span class='Ref_To_Local'>left_inners</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN852"><span class='Ref_To_Local'>right_inners</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Comment_Multi_Line'>/* each side is both outer and inner */ 
</span>                <a href="initsplan.c.html#LN853"><span class='Ref_To_Local'>nonnullable_rels</span></a> <span class='Operator'>= *</span><a href="initsplan.c.html#LN738"><span class='Ref_to_Parameter'>qualscope</span></a><span class='Delimiter'>; 
</span>                <a href="initsplan.c.html#LN854"><span class='Ref_To_Local'>nullable_rels</span></a> <span class='Operator'>= *</span><a href="initsplan.c.html#LN738"><span class='Ref_to_Parameter'>qualscope</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>            <span class='Control'>default</span><span class='Operator'>: 
</span>                <span class='Comment_Multi_Line'>/* JOIN_RIGHT was eliminated during reduce_outer_joins() */ 
</span>                <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized join type: %d"</span><span class='Delimiter'>, 
</span>                     <span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN847"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1447"><span class='Ref_to_Member'>jointype</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="initsplan.c.html#LN853"><span class='Ref_To_Local'>nonnullable_rels</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* keep compiler quiet */ 
</span>                <a href="initsplan.c.html#LN854"><span class='Ref_To_Local'>nullable_rels</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>                <a href="initsplan.c.html#LN856"><span class='Ref_To_Local'>leftjoinlist</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN857"><span class='Ref_To_Local'>rightjoinlist</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>                <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch j-&GT;jointype &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* Report all rels that will be nulled anywhere in the jointree */ 
</span>        <a href="initsplan.c.html#LN737"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN203"><span class='Ref_to_Member'>nullable_baserels</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN91"><span class='Ref_to_Proto'>bms_add_members</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN737"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN203"><span class='Ref_to_Member'>nullable_baserels</span></a><span class='Delimiter'>, 
</span>                                                  <a href="initsplan.c.html#LN854"><span class='Ref_To_Local'>nullable_rels</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Try to process any quals postponed by children.  If they need 
         * further postponement, add them to my output postponed_qual_list. 
         * Quals that can be processed now must be included in my_quals, so 
         * that they'll be handled properly in make_outerjoininfo. 
         */ 
</span>        <a href="initsplan.c.html#LN858"><span class='Ref_To_Local'>my_quals</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN860"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN848"><span class='Ref_To_Local'>child_postponed_quals</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN966"></a>            <a href="initsplan.c.html#LN40"><span class='Ref_to_Struct'>PostponedQual</span></a> <span class='Operator'>*</span><span class='Declare_Local'>pq</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="initsplan.c.html#LN40"><span class='Ref_to_Struct'>PostponedQual</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN860"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN966"><span class='Ref_To_Local'>pq</span></a><span class='Operator'>-&GT;</span><a href="initsplan.c.html#LN43"><span class='Ref_to_Member'>relids</span></a><span class='Delimiter'>, </span><span class='Operator'>*</span><a href="initsplan.c.html#LN738"><span class='Ref_to_Parameter'>qualscope</span></a><span class='Parentheses'>))</span> 
                <a href="initsplan.c.html#LN858"><span class='Ref_To_Local'>my_quals</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN858"><span class='Ref_To_Local'>my_quals</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN966"><span class='Ref_To_Local'>pq</span></a><span class='Operator'>-&GT;</span><a href="initsplan.c.html#LN42"><span class='Ref_to_Member'>qual</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * We should not be postponing any quals past an outer join. 
                 * If this Assert fires, pull_up_subqueries() messed up. 
                 */ 
</span>                <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="initsplan.c.html#LN847"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1447"><span class='Ref_to_Member'>jointype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN677"><span class='Ref_to_EnumConst'>JOIN_INNER</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Operator'>*</span><a href="initsplan.c.html#LN739"><span class='Ref_to_Parameter'>postponed_qual_list</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="initsplan.c.html#LN739"><span class='Ref_to_Parameter'>postponed_qual_list</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN966"><span class='Ref_To_Local'>pq</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>        <span class='Comment_Multi_Line'>/* list_concat is nondestructive of its second argument */ 
</span>        <a href="initsplan.c.html#LN858"><span class='Ref_To_Local'>my_quals</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN219"><span class='Ref_to_Proto'>list_concat</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN858"><span class='Ref_To_Local'>my_quals</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN847"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1452"><span class='Ref_to_Member'>quals</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * For an OJ, form the SpecialJoinInfo now, because we need the OJ's 
         * semantic scope (ojscope) to pass to distribute_qual_to_rels.  But 
         * we mustn't add it to join_info_list just yet, because we don't want 
         * distribute_qual_to_rels to think it is an outer join below us. 
         * 
         * Semijoins are a bit of a hybrid: we build a SpecialJoinInfo, but we 
         * want ojscope = NULL for distribute_qual_to_rels. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN847"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1447"><span class='Ref_to_Member'>jointype</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/nodes.h.html#LN677"><span class='Ref_to_EnumConst'>JOIN_INNER</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="initsplan.c.html#LN859"><span class='Ref_To_Local'>sjinfo</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN56"><span class='Ref_to_Proto'>make_outerjoininfo</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN737"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                        <a href="initsplan.c.html#LN849"><span class='Ref_To_Local'>leftids</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN850"><span class='Ref_To_Local'>rightids</span></a><span class='Delimiter'>, 
</span>                                        <span class='Operator'>*</span><a href="initsplan.c.html#LN738"><span class='Ref_to_Parameter'>inner_join_rels</span></a><span class='Delimiter'>, 
</span>                                        <a href="initsplan.c.html#LN847"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1447"><span class='Ref_to_Member'>jointype</span></a><span class='Delimiter'>, 
</span>                                        <a href="initsplan.c.html#LN858"><span class='Ref_To_Local'>my_quals</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN847"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1447"><span class='Ref_to_Member'>jointype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN691"><span class='Ref_to_EnumConst'>JOIN_SEMI</span></a><span class='Parentheses'>) 
</span>                <a href="initsplan.c.html#LN855"><span class='Ref_To_Local'>ojscope</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="initsplan.c.html#LN855"><span class='Ref_To_Local'>ojscope</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN70"><span class='Ref_to_Proto'>bms_union</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN859"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1916"><span class='Ref_to_Member'>min_lefthand</span></a><span class='Delimiter'>, 
</span>                                    <a href="initsplan.c.html#LN859"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1917"><span class='Ref_to_Member'>min_righthand</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <a href="initsplan.c.html#LN859"><span class='Ref_To_Local'>sjinfo</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>            <a href="initsplan.c.html#LN855"><span class='Ref_To_Local'>ojscope</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* Process the JOIN's qual clauses */ 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN860"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN858"><span class='Ref_To_Local'>my_quals</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1014"></a>            <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>qual</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN860"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <a href="initsplan.c.html#LN61"><span class='Ref_to_Proto'>distribute_qual_to_rels</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN737"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1014"><span class='Ref_To_Local'>qual</span></a><span class='Delimiter'>, 
</span>                                    <span class='Boolean'>false</span><span class='Delimiter'>, </span><a href="initsplan.c.html#LN737"><span class='Ref_to_Parameter'>below_outer_join</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN847"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1447"><span class='Ref_to_Member'>jointype</span></a><span class='Delimiter'>, 
</span>                                    <a href="initsplan.c.html#LN737"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN293"><span class='Ref_to_Member'>qual_security_level</span></a><span class='Delimiter'>, 
</span>                                    <span class='Operator'>*</span><a href="initsplan.c.html#LN738"><span class='Ref_to_Parameter'>qualscope</span></a><span class='Delimiter'>, 
</span>                                    <a href="initsplan.c.html#LN855"><span class='Ref_To_Local'>ojscope</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN853"><span class='Ref_To_Local'>nonnullable_rels</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                                    <a href="initsplan.c.html#LN739"><span class='Ref_to_Parameter'>postponed_qual_list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* Now we can add the SpecialJoinInfo to join_info_list */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN859"><span class='Ref_To_Local'>sjinfo</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="initsplan.c.html#LN737"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN249"><span class='Ref_to_Member'>join_info_list</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN737"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN249"><span class='Ref_to_Member'>join_info_list</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN859"><span class='Ref_To_Local'>sjinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* Each time we do that, recheck placeholder eval levels */ 
</span>            <a href="../../../include/optimizer/placeholder.h.html#LN24"><span class='Ref_to_Proto'>update_placeholder_eval_levels</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN737"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN859"><span class='Ref_To_Local'>sjinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Finally, compute the output joinlist.  We fold subproblems together 
         * except at a FULL JOIN or where join_collapse_limit would be 
         * exceeded. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN847"><span class='Ref_To_Local'>j</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1447"><span class='Ref_to_Member'>jointype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN679"><span class='Ref_to_EnumConst'>JOIN_FULL</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* force the join order exactly at this node */ 
</span>            <a href="initsplan.c.html#LN741"><span class='Ref_To_Local'>joinlist</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN138"><span class='Ref_to_Macro'>list_make1</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN139"><span class='Ref_to_Macro'>list_make2</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN856"><span class='Ref_To_Local'>leftjoinlist</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN857"><span class='Ref_To_Local'>rightjoinlist</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN856"><span class='Ref_To_Local'>leftjoinlist</span></a><span class='Parentheses'>) </span><span class='Operator'>+ </span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN857"><span class='Ref_To_Local'>rightjoinlist</span></a><span class='Parentheses'>) </span><span class='Operator'>&LT;= 
</span>                 <a href="initsplan.c.html#LN36"><span class='Ref_to_Global_Var'>join_collapse_limit</span></a><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* OK to combine subproblems */ 
</span>            <a href="initsplan.c.html#LN741"><span class='Ref_To_Local'>joinlist</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN219"><span class='Ref_to_Proto'>list_concat</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN856"><span class='Ref_To_Local'>leftjoinlist</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN857"><span class='Ref_To_Local'>rightjoinlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* can't combine, but needn't force join order above here */ 
</span><a name="LN1051"></a>            <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>leftpart</span><span class='Delimiter'>, 
</span><a name="LN1052"></a>                       <span class='Operator'>*</span><span class='Declare_Local'>rightpart</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* avoid creating useless 1-element sublists */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN856"><span class='Ref_To_Local'>leftjoinlist</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
                <a href="initsplan.c.html#LN1051"><span class='Ref_To_Local'>leftpart</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN856"><span class='Ref_To_Local'>leftjoinlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="initsplan.c.html#LN1051"><span class='Ref_To_Local'>leftpart</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN856"><span class='Ref_To_Local'>leftjoinlist</span></a><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN857"><span class='Ref_To_Local'>rightjoinlist</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
                <a href="initsplan.c.html#LN1052"><span class='Ref_To_Local'>rightpart</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN857"><span class='Ref_To_Local'>rightjoinlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>else</span> 
                <a href="initsplan.c.html#LN1052"><span class='Ref_To_Local'>rightpart</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN857"><span class='Ref_To_Local'>rightjoinlist</span></a><span class='Delimiter'>; 
</span>            <a href="initsplan.c.html#LN741"><span class='Ref_To_Local'>joinlist</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN139"><span class='Ref_to_Macro'>list_make2</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1051"><span class='Ref_To_Local'>leftpart</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1052"><span class='Ref_To_Local'>rightpart</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if IsA(jtnode,JoinExpr) &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"unrecognized node type: %d"</span><span class='Delimiter'>, 
</span>             <span class='Parentheses'>(</span><span class='Keyword'>int</span><span class='Parentheses'>) </span><a href="../../../include/nodes/nodes.h.html#LN513"><span class='Ref_to_Macro'>nodeTag</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN737"><span class='Ref_to_Parameter'>jtnode</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>        <a href="initsplan.c.html#LN741"><span class='Ref_To_Local'>joinlist</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>;</span>         <span class='Comment_Single_Line'>/* keep compiler quiet */ 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>return</span> <a href="initsplan.c.html#LN741"><span class='Ref_To_Local'>joinlist</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end deconstruct_recurse &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * process_security_barrier_quals 
 *    Transfer security-barrier quals into relation's baserestrictinfo list. 
 * 
 * The rewriter put any relevant security-barrier conditions into the RTE's 
 * securityQuals field, but it's now time to copy them into the rel's 
 * baserestrictinfo. 
 * 
 * In inheritance cases, we only consider quals attached to the parent rel 
 * here; they will be valid for all children too, so it's okay to consider 
 * them for purposes like equivalence class creation.  Quals attached to 
 * individual child rels will be dealt with during path creation. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1089"></a><span class='Declare_Function'>process_security_barrier_quals</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN1090"></a>                               <span class='Keyword'>int </span><span class='Declare_Parameter'>rti</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Declare_Parameter'>qualscope</span><span class='Delimiter'>, 
</span><a name="LN1091"></a>                               <span class='Keyword'>bool </span><span class='Declare_Parameter'>below_outer_join</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1093"></a>    <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span> <span class='Operator'>= </span><a href="initsplan.c.html#LN1089"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN187"><span class='Ref_to_Member'>simple_rte_array</span></a><span class='Delimiter'>[</span><a href="initsplan.c.html#LN1090"><span class='Ref_to_Parameter'>rti</span></a><span class='Delimiter'>]; 
</span><a name="LN1094"></a>    <a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Local'>security_level</span> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span><a name="LN1095"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Each element of the securityQuals list has been preprocessed into an 
     * implicitly-ANDed list of clauses.  All the clauses in a given sublist 
     * should get the same security level, but successive sublists get higher 
     * levels. 
     */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1095"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1093"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1032"><span class='Ref_to_Member'>securityQuals</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1105"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>qualset</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1095"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1106"></a>        <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc2</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1106"><span class='Ref_To_Local'>lc2</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1105"><span class='Ref_To_Local'>qualset</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN1110"></a>            <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>qual</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1106"><span class='Ref_To_Local'>lc2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * We cheat to the extent of passing ojscope = qualscope rather 
             * than its more logical value of NULL.  The only effect this has 
             * is to force a Var-free qual to be evaluated at the rel rather 
             * than being pushed up to top of tree, which we don't want. 
             */ 
</span>            <a href="initsplan.c.html#LN61"><span class='Ref_to_Proto'>distribute_qual_to_rels</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1089"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1110"><span class='Ref_To_Local'>qual</span></a><span class='Delimiter'>, 
</span>                                    <span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                                    <a href="initsplan.c.html#LN1091"><span class='Ref_to_Parameter'>below_outer_join</span></a><span class='Delimiter'>, 
</span>                                    <a href="../../../include/nodes/nodes.h.html#LN677"><span class='Ref_to_EnumConst'>JOIN_INNER</span></a><span class='Delimiter'>, 
</span>                                    <a href="initsplan.c.html#LN1094"><span class='Ref_To_Local'>security_level</span></a><span class='Delimiter'>, 
</span>                                    <a href="initsplan.c.html#LN1090"><span class='Ref_to_Parameter'>qualscope</span></a><span class='Delimiter'>, 
</span>                                    <a href="initsplan.c.html#LN1090"><span class='Ref_to_Parameter'>qualscope</span></a><span class='Delimiter'>, 
</span>                                    <span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                                    <span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                                    <span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <a href="initsplan.c.html#LN1094"><span class='Ref_To_Local'>security_level</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Assert that qual_security_level is higher than anything we just used */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1094"><span class='Ref_To_Local'>security_level</span></a> <span class='Operator'>&LT;= </span><a href="initsplan.c.html#LN1089"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN293"><span class='Ref_to_Member'>qual_security_level</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end process_security_barrier_quals &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * make_outerjoininfo 
 *    Build a SpecialJoinInfo for the current outer join 
 * 
 * Inputs: 
 *  left_rels: the base Relids syntactically on outer side of join 
 *  right_rels: the base Relids syntactically on inner side of join 
 *  inner_join_rels: base Relids participating in inner joins below this one 
 *  jointype: what it says (must always be LEFT, FULL, SEMI, or ANTI) 
 *  clause: the outer join's join condition (in implicit-AND format) 
 * 
 * The node should eventually be appended to root-&GT;join_info_list, but we 
 * do not do that here. 
 * 
 * Note: we assume that this function is invoked bottom-up, so that 
 * root-&GT;join_info_list already contains entries for all outer joins that are 
 * syntactically below this one. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>* 
</span><a name="LN1155"></a><span class='Declare_Function'>make_outerjoininfo</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN1156"></a>                   <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Declare_Parameter'>left_rels</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Declare_Parameter'>right_rels</span><span class='Delimiter'>, 
</span><a name="LN1157"></a>                   <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Declare_Parameter'>inner_join_rels</span><span class='Delimiter'>, 
</span><a name="LN1158"></a>                   <a href="../../../include/nodes/nodes.h.html#LN671"><span class='Ref_to_Enum'>JoinType</span></a> <span class='Declare_Parameter'>jointype</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1160"></a>    <a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sjinfo</span> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1161"></a>    <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>clause_relids</span><span class='Delimiter'>; 
</span><a name="LN1162"></a>    <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>strict_relids</span><span class='Delimiter'>; 
</span><a name="LN1163"></a>    <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>min_lefthand</span><span class='Delimiter'>; 
</span><a name="LN1164"></a>    <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>min_righthand</span><span class='Delimiter'>; 
</span><a name="LN1165"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We should not see RIGHT JOIN here because left/right were switched 
     * earlier 
     */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1158"><span class='Ref_to_Parameter'>jointype</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/nodes.h.html#LN677"><span class='Ref_to_EnumConst'>JOIN_INNER</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1158"><span class='Ref_to_Parameter'>jointype</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/nodes.h.html#LN680"><span class='Ref_to_EnumConst'>JOIN_RIGHT</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Presently the executor cannot support FOR [KEY] UPDATE/SHARE marking of 
     * rels appearing on the nullable side of an outer join. (It's somewhat 
     * unclear what that would mean, anyway: what should we mark when a result 
     * row is generated from no element of the nullable relation?)  So, 
     * complain if any nullable rel is FOR [KEY] UPDATE/SHARE. 
     * 
     * You might be wondering why this test isn't made far upstream in the 
     * parser.  It's because the parser hasn't got enough info --- consider 
     * FOR UPDATE applied to a view.  Only after rewriting and flattening do 
     * we know whether the view contains an outer join. 
     * 
     * We use the original RowMarkClause list here; the PlanRowMark list would 
     * list everything. 
     */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1165"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1155"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN160"><span class='Ref_to_Member'>rowMarks</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1191"></a>        <a href="../../../include/nodes/parsenodes.h.html#LN1278"><span class='Ref_to_Struct'>RowMarkClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rc</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN1278"><span class='Ref_to_Struct'>RowMarkClause</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1165"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN75"><span class='Ref_to_Proto'>bms_is_member</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1191"><span class='Ref_To_Local'>rc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1281"><span class='Ref_to_Member'>rti</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1156"><span class='Ref_to_Parameter'>right_rels</span></a><span class='Parentheses'>)</span> <span class='Operator'>|| 
</span>            <span class='Parentheses'>(</span><a href="initsplan.c.html#LN1158"><span class='Ref_to_Parameter'>jointype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN679"><span class='Ref_to_EnumConst'>JOIN_FULL</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/bitmapset.h.html#LN75"><span class='Ref_to_Proto'>bms_is_member</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1191"><span class='Ref_To_Local'>rc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1281"><span class='Ref_to_Member'>rti</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1156"><span class='Ref_to_Parameter'>left_rels</span></a><span class='Parentheses'>)))</span> 
            <a href="../../../include/utils/elog.h.html#LN121"><span class='Ref_to_Macro'>ereport</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, 
</span>                    <span class='Parentheses'>(</span><a href="../../../include/utils/elog.h.html#LN130"><span class='Ref_to_Proto'>errcode</span></a><span class='Parentheses'>(</span>ERRCODE_FEATURE_NOT_SUPPORTED<span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>            <span class='Comment_Multi_Line'>/*------ 
             translator: %s is a SQL row locking clause such as FOR UPDATE */ 
</span>                     <a href="../../utils/error/elog.c.html#LN795"><span class='Ref_to_Func'>errmsg</span></a><span class='Parentheses'>(</span><span class='String'>"%s cannot be applied to the nullable side of an outer join"</span><span class='Delimiter'>, 
</span>                            <a href="../../../include/parser/analyze.h.html#LN39"><span class='Ref_to_Proto'>LCS_asString</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1191"><span class='Ref_To_Local'>rc</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1282"><span class='Ref_to_Member'>strength</span></a><span class='Parentheses'>))))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <a href="initsplan.c.html#LN1160"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1918"><span class='Ref_to_Member'>syn_lefthand</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN1156"><span class='Ref_to_Parameter'>left_rels</span></a><span class='Delimiter'>; 
</span>    <a href="initsplan.c.html#LN1160"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1919"><span class='Ref_to_Member'>syn_righthand</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN1156"><span class='Ref_to_Parameter'>right_rels</span></a><span class='Delimiter'>; 
</span>    <a href="initsplan.c.html#LN1160"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1920"><span class='Ref_to_Member'>jointype</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN1158"><span class='Ref_to_Parameter'>jointype</span></a><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* this always starts out false */ 
</span>    <a href="initsplan.c.html#LN1160"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1922"><span class='Ref_to_Member'>delay_upper_joins</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <a href="initsplan.c.html#LN60"><span class='Ref_to_Proto'>compute_semijoin_info</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1160"><span class='Ref_To_Local'>sjinfo</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1158"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* If it's a full join, no need to be very smart */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN1158"><span class='Ref_to_Parameter'>jointype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN679"><span class='Ref_to_EnumConst'>JOIN_FULL</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="initsplan.c.html#LN1160"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1916"><span class='Ref_to_Member'>min_lefthand</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN65"><span class='Ref_to_Proto'>bms_copy</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1156"><span class='Ref_to_Parameter'>left_rels</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="initsplan.c.html#LN1160"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1917"><span class='Ref_to_Member'>min_righthand</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN65"><span class='Ref_to_Proto'>bms_copy</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1156"><span class='Ref_to_Parameter'>right_rels</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="initsplan.c.html#LN1160"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1921"><span class='Ref_to_Member'>lhs_strict</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* don't care about this */ 
</span>        <span class='Control'>return</span> <a href="initsplan.c.html#LN1160"><span class='Ref_To_Local'>sjinfo</span></a><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Retrieve all relids mentioned within the join clause. 
     */ 
</span>    <a href="initsplan.c.html#LN1161"><span class='Ref_To_Local'>clause_relids</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/var.h.html#LN29"><span class='Ref_to_Proto'>pull_varnos</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN1158"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * For which relids is the clause strict, ie, it cannot succeed if the 
     * rel's columns are all NULL? 
     */ 
</span>    <a href="initsplan.c.html#LN1162"><span class='Ref_To_Local'>strict_relids</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/clauses.h.html#LN67"><span class='Ref_to_Proto'>find_nonnullable_rels</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN1158"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Remember whether the clause is strict for any LHS relations */ 
</span>    <a href="initsplan.c.html#LN1160"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1921"><span class='Ref_to_Member'>lhs_strict</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1162"><span class='Ref_To_Local'>strict_relids</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1156"><span class='Ref_to_Parameter'>left_rels</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Required LHS always includes the LHS rels mentioned in the clause. We 
     * may have to add more rels based on lower outer joins; see below. 
     */ 
</span>    <a href="initsplan.c.html#LN1163"><span class='Ref_To_Local'>min_lefthand</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN71"><span class='Ref_to_Proto'>bms_intersect</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1161"><span class='Ref_To_Local'>clause_relids</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1156"><span class='Ref_to_Parameter'>left_rels</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Similarly for required RHS.  But here, we must also include any lower 
     * inner joins, to ensure we don't try to commute with any of them. 
     */ 
</span>    <a href="initsplan.c.html#LN1164"><span class='Ref_To_Local'>min_righthand</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN92"><span class='Ref_to_Proto'>bms_int_members</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN70"><span class='Ref_to_Proto'>bms_union</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1161"><span class='Ref_To_Local'>clause_relids</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1157"><span class='Ref_to_Parameter'>inner_join_rels</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                    <a href="initsplan.c.html#LN1156"><span class='Ref_to_Parameter'>right_rels</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Now check previous outer joins for ordering restrictions. 
     */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1165"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1155"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN249"><span class='Ref_to_Member'>join_info_list</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1252"></a>        <a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>otherinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1165"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * A full join is an optimization barrier: we can't associate into or 
         * out of it.  Hence, if it overlaps either LHS or RHS of the current 
         * rel, expand that side's min relset to cover the whole full join. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN1252"><span class='Ref_To_Local'>otherinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1920"><span class='Ref_to_Member'>jointype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN679"><span class='Ref_to_EnumConst'>JOIN_FULL</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1156"><span class='Ref_to_Parameter'>left_rels</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1252"><span class='Ref_To_Local'>otherinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1918"><span class='Ref_to_Member'>syn_lefthand</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>                <a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1156"><span class='Ref_to_Parameter'>left_rels</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1252"><span class='Ref_To_Local'>otherinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1919"><span class='Ref_to_Member'>syn_righthand</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <a href="initsplan.c.html#LN1163"><span class='Ref_To_Local'>min_lefthand</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN91"><span class='Ref_to_Proto'>bms_add_members</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1163"><span class='Ref_To_Local'>min_lefthand</span></a><span class='Delimiter'>, 
</span>                                               <a href="initsplan.c.html#LN1252"><span class='Ref_To_Local'>otherinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1918"><span class='Ref_to_Member'>syn_lefthand</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="initsplan.c.html#LN1163"><span class='Ref_To_Local'>min_lefthand</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN91"><span class='Ref_to_Proto'>bms_add_members</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1163"><span class='Ref_To_Local'>min_lefthand</span></a><span class='Delimiter'>, 
</span>                                               <a href="initsplan.c.html#LN1252"><span class='Ref_To_Local'>otherinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1919"><span class='Ref_to_Member'>syn_righthand</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1156"><span class='Ref_to_Parameter'>right_rels</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1252"><span class='Ref_To_Local'>otherinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1918"><span class='Ref_to_Member'>syn_lefthand</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>                <a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1156"><span class='Ref_to_Parameter'>right_rels</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1252"><span class='Ref_To_Local'>otherinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1919"><span class='Ref_to_Member'>syn_righthand</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <a href="initsplan.c.html#LN1164"><span class='Ref_To_Local'>min_righthand</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN91"><span class='Ref_to_Proto'>bms_add_members</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1164"><span class='Ref_To_Local'>min_righthand</span></a><span class='Delimiter'>, 
</span>                                                <a href="initsplan.c.html#LN1252"><span class='Ref_To_Local'>otherinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1918"><span class='Ref_to_Member'>syn_lefthand</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="initsplan.c.html#LN1164"><span class='Ref_To_Local'>min_righthand</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN91"><span class='Ref_to_Proto'>bms_add_members</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1164"><span class='Ref_To_Local'>min_righthand</span></a><span class='Delimiter'>, 
</span>                                                <a href="initsplan.c.html#LN1252"><span class='Ref_To_Local'>otherinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1919"><span class='Ref_to_Member'>syn_righthand</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Comment_Multi_Line'>/* Needn't do anything else with the full join */ 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if otherinfo-&GT;jointype==... &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* 
         * For a lower OJ in our LHS, if our join condition uses the lower 
         * join's RHS and is not strict for that rel, we must preserve the 
         * ordering of the two OJs, so add lower OJ's full syntactic relset to 
         * min_lefthand.  (We must use its full syntactic relset, not just its 
         * min_lefthand + min_righthand.  This is because there might be other 
         * OJs below this one that this one can commute with, but we cannot 
         * commute with them if we don't with this one.)  Also, if the current 
         * join is a semijoin or antijoin, we must preserve ordering 
         * regardless of strictness. 
         * 
         * Note: I believe we have to insist on being strict for at least one 
         * rel in the lower OJ's min_righthand, not its whole syn_righthand. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1156"><span class='Ref_to_Parameter'>left_rels</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1252"><span class='Ref_To_Local'>otherinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1919"><span class='Ref_to_Member'>syn_righthand</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1161"><span class='Ref_To_Local'>clause_relids</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1252"><span class='Ref_To_Local'>otherinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1919"><span class='Ref_to_Member'>syn_righthand</span></a><span class='Parentheses'>)</span> <span class='Operator'>&& 
</span>                <span class='Parentheses'>(</span><a href="initsplan.c.html#LN1158"><span class='Ref_to_Parameter'>jointype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN691"><span class='Ref_to_EnumConst'>JOIN_SEMI</span></a> <span class='Operator'>|| </span><a href="initsplan.c.html#LN1158"><span class='Ref_to_Parameter'>jointype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN692"><span class='Ref_to_EnumConst'>JOIN_ANTI</span></a> <span class='Operator'>|| 
</span>                 <span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1162"><span class='Ref_To_Local'>strict_relids</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1252"><span class='Ref_To_Local'>otherinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1917"><span class='Ref_to_Member'>min_righthand</span></a><span class='Parentheses'>)))</span> 
            <span class='Delimiter'>{ 
</span>                <a href="initsplan.c.html#LN1163"><span class='Ref_To_Local'>min_lefthand</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN91"><span class='Ref_to_Proto'>bms_add_members</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1163"><span class='Ref_To_Local'>min_lefthand</span></a><span class='Delimiter'>, 
</span>                                               <a href="initsplan.c.html#LN1252"><span class='Ref_To_Local'>otherinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1918"><span class='Ref_to_Member'>syn_lefthand</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="initsplan.c.html#LN1163"><span class='Ref_To_Local'>min_lefthand</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN91"><span class='Ref_to_Proto'>bms_add_members</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1163"><span class='Ref_To_Local'>min_lefthand</span></a><span class='Delimiter'>, 
</span>                                               <a href="initsplan.c.html#LN1252"><span class='Ref_To_Local'>otherinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1919"><span class='Ref_to_Member'>syn_righthand</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * For a lower OJ in our RHS, if our join condition does not use the 
         * lower join's RHS and the lower OJ's join condition is strict, we 
         * can interchange the ordering of the two OJs; otherwise we must add 
         * the lower OJ's full syntactic relset to min_righthand. 
         * 
         * Also, if our join condition does not use the lower join's LHS 
         * either, force the ordering to be preserved.  Otherwise we can end 
         * up with SpecialJoinInfos with identical min_righthands, which can 
         * confuse join_is_legal (see discussion in backend/optimizer/README). 
         * 
         * Also, we must preserve ordering anyway if either the current join 
         * or the lower OJ is either a semijoin or an antijoin. 
         * 
         * Here, we have to consider that "our join condition" includes any 
         * clauses that syntactically appeared above the lower OJ and below 
         * ours; those are equivalent to degenerate clauses in our OJ and must 
         * be treated as such.  Such clauses obviously can't reference our 
         * LHS, and they must be non-strict for the lower OJ's RHS (else 
         * reduce_outer_joins would have reduced the lower OJ to a plain 
         * join).  Hence the other ways in which we handle clauses within our 
         * join condition are not affected by them.  The net effect is 
         * therefore sufficiently represented by the delay_upper_joins flag 
         * saved for us by check_outerjoin_delay. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1156"><span class='Ref_to_Parameter'>right_rels</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1252"><span class='Ref_To_Local'>otherinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1919"><span class='Ref_to_Member'>syn_righthand</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1161"><span class='Ref_To_Local'>clause_relids</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1252"><span class='Ref_To_Local'>otherinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1919"><span class='Ref_to_Member'>syn_righthand</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>                <span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1161"><span class='Ref_To_Local'>clause_relids</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1252"><span class='Ref_To_Local'>otherinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1916"><span class='Ref_to_Member'>min_lefthand</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>                <a href="initsplan.c.html#LN1158"><span class='Ref_to_Parameter'>jointype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN691"><span class='Ref_to_EnumConst'>JOIN_SEMI</span></a> <span class='Operator'>|| 
</span>                <a href="initsplan.c.html#LN1158"><span class='Ref_to_Parameter'>jointype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN692"><span class='Ref_to_EnumConst'>JOIN_ANTI</span></a> <span class='Operator'>|| 
</span>                <a href="initsplan.c.html#LN1252"><span class='Ref_To_Local'>otherinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1920"><span class='Ref_to_Member'>jointype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN691"><span class='Ref_to_EnumConst'>JOIN_SEMI</span></a> <span class='Operator'>|| 
</span>                <a href="initsplan.c.html#LN1252"><span class='Ref_To_Local'>otherinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1920"><span class='Ref_to_Member'>jointype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN692"><span class='Ref_to_EnumConst'>JOIN_ANTI</span></a> <span class='Operator'>|| 
</span>                <span class='Operator'>!</span><a href="initsplan.c.html#LN1252"><span class='Ref_To_Local'>otherinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1921"><span class='Ref_to_Member'>lhs_strict</span></a> <span class='Operator'>|| </span><a href="initsplan.c.html#LN1252"><span class='Ref_To_Local'>otherinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1922"><span class='Ref_to_Member'>delay_upper_joins</span></a><span class='Parentheses'>)</span> 
            <span class='Delimiter'>{ 
</span>                <a href="initsplan.c.html#LN1164"><span class='Ref_To_Local'>min_righthand</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN91"><span class='Ref_to_Proto'>bms_add_members</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1164"><span class='Ref_To_Local'>min_righthand</span></a><span class='Delimiter'>, 
</span>                                                <a href="initsplan.c.html#LN1252"><span class='Ref_To_Local'>otherinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1918"><span class='Ref_to_Member'>syn_lefthand</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="initsplan.c.html#LN1164"><span class='Ref_To_Local'>min_righthand</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN91"><span class='Ref_to_Proto'>bms_add_members</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1164"><span class='Ref_To_Local'>min_righthand</span></a><span class='Delimiter'>, 
</span>                                                <a href="initsplan.c.html#LN1252"><span class='Ref_To_Local'>otherinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1919"><span class='Ref_to_Member'>syn_righthand</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Examine PlaceHolderVars.  If a PHV is supposed to be evaluated within 
     * this join's nullable side, then ensure that min_righthand contains the 
     * full eval_at set of the PHV.  This ensures that the PHV actually can be 
     * evaluated within the RHS.  Note that this works only because we should 
     * already have determined the final eval_at level for any PHV 
     * syntactically within this join. 
     */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1165"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1155"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN257"><span class='Ref_to_Member'>placeholder_list</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1361"></a>        <a href="../../../include/nodes/relation.h.html#LN2057"><span class='Ref_to_Struct'>PlaceHolderInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>phinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN2057"><span class='Ref_to_Struct'>PlaceHolderInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1165"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1362"></a>        <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>ph_syn_level</span> <span class='Operator'>= </span><a href="initsplan.c.html#LN1361"><span class='Ref_To_Local'>phinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2062"><span class='Ref_to_Member'>ph_var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1850"><span class='Ref_to_Member'>phrels</span></a><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Ignore placeholder if it didn't syntactically come from RHS */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1362"><span class='Ref_To_Local'>ph_syn_level</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1156"><span class='Ref_to_Parameter'>right_rels</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Else, prevent join from being formed before we eval the PHV */ 
</span>        <a href="initsplan.c.html#LN1164"><span class='Ref_To_Local'>min_righthand</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN91"><span class='Ref_to_Proto'>bms_add_members</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1164"><span class='Ref_To_Local'>min_righthand</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1361"><span class='Ref_To_Local'>phinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2063"><span class='Ref_to_Member'>ph_eval_at</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we found nothing to put in min_lefthand, punt and make it the full 
     * LHS, to avoid having an empty min_lefthand which will confuse later 
     * processing. (We don't try to be smart about such cases, just correct.) 
     * Likewise for min_righthand. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN85"><span class='Ref_to_Proto'>bms_is_empty</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1163"><span class='Ref_To_Local'>min_lefthand</span></a><span class='Parentheses'>))</span> 
        <a href="initsplan.c.html#LN1163"><span class='Ref_To_Local'>min_lefthand</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN65"><span class='Ref_to_Proto'>bms_copy</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1156"><span class='Ref_to_Parameter'>left_rels</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN85"><span class='Ref_to_Proto'>bms_is_empty</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1164"><span class='Ref_To_Local'>min_righthand</span></a><span class='Parentheses'>))</span> 
        <a href="initsplan.c.html#LN1164"><span class='Ref_To_Local'>min_righthand</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN65"><span class='Ref_to_Proto'>bms_copy</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1156"><span class='Ref_to_Parameter'>right_rels</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Now they'd better be nonempty */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN85"><span class='Ref_to_Proto'>bms_is_empty</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1163"><span class='Ref_To_Local'>min_lefthand</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN85"><span class='Ref_to_Proto'>bms_is_empty</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1164"><span class='Ref_To_Local'>min_righthand</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* Shouldn't overlap either */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1163"><span class='Ref_To_Local'>min_lefthand</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1164"><span class='Ref_To_Local'>min_righthand</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <a href="initsplan.c.html#LN1160"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1916"><span class='Ref_to_Member'>min_lefthand</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN1163"><span class='Ref_To_Local'>min_lefthand</span></a><span class='Delimiter'>; 
</span>    <a href="initsplan.c.html#LN1160"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1917"><span class='Ref_to_Member'>min_righthand</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN1164"><span class='Ref_To_Local'>min_righthand</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="initsplan.c.html#LN1160"><span class='Ref_To_Local'>sjinfo</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end make_outerjoininfo &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * compute_semijoin_info 
 *    Fill semijoin-related fields of a new SpecialJoinInfo 
 * 
 * Note: this relies on only the jointype and syn_righthand fields of the 
 * SpecialJoinInfo; the rest may not be set yet. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1403"></a><span class='Declare_Function'>compute_semijoin_info</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>sjinfo</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1405"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>semi_operators</span><span class='Delimiter'>; 
</span><a name="LN1406"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>semi_rhs_exprs</span><span class='Delimiter'>; 
</span><a name="LN1407"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>all_btree</span><span class='Delimiter'>; 
</span><a name="LN1408"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>all_hash</span><span class='Delimiter'>; 
</span><a name="LN1409"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Initialize semijoin-related fields in case we can't unique-ify */ 
</span>    <a href="initsplan.c.html#LN1403"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1924"><span class='Ref_to_Member'>semi_can_btree</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="initsplan.c.html#LN1403"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1925"><span class='Ref_to_Member'>semi_can_hash</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="initsplan.c.html#LN1403"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1926"><span class='Ref_to_Member'>semi_operators</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="initsplan.c.html#LN1403"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1927"><span class='Ref_to_Member'>semi_rhs_exprs</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Nothing more to do if it's not a semijoin */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN1403"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1920"><span class='Ref_to_Member'>jointype</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/nodes.h.html#LN691"><span class='Ref_to_EnumConst'>JOIN_SEMI</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Look to see whether the semijoin's join quals consist of AND'ed 
     * equality operators, with (only) RHS variables on only one side of each 
     * one.  If so, we can figure out how to enforce uniqueness for the RHS. 
     * 
     * Note that the input clause list is the list of quals that are 
     * *syntactically* associated with the semijoin, which in practice means 
     * the synthesized comparison list for an IN or the WHERE of an EXISTS. 
     * Particularly in the latter case, it might contain clauses that aren't 
     * *semantically* associated with the join, but refer to just one side or 
     * the other.  We can ignore such clauses here, as they will just drop 
     * down to be processed within one side or the other.  (It is okay to 
     * consider only the syntactically-associated clauses here because for a 
     * semijoin, no higher-level quals could refer to the RHS, and so there 
     * can be no other quals that are semantically associated with this join. 
     * We do things this way because it is useful to have the set of potential 
     * unique-ification expressions before we can extract the list of quals 
     * that are actually semantically associated with the particular join.) 
     * 
     * Note that the semi_operators list consists of the joinqual operators 
     * themselves (but commuted if needed to put the RHS value on the right). 
     * These could be cross-type operators, in which case the operator 
     * actually needed for uniqueness is a related single-type operator. We 
     * assume here that that operator will be available from the btree or hash 
     * opclass when the time comes ... if not, create_unique_plan() will fail. 
     */ 
</span>    <a href="initsplan.c.html#LN1405"><span class='Ref_To_Local'>semi_operators</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="initsplan.c.html#LN1406"><span class='Ref_To_Local'>semi_rhs_exprs</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="initsplan.c.html#LN1407"><span class='Ref_To_Local'>all_btree</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <a href="initsplan.c.html#LN1408"><span class='Ref_To_Local'>all_hash</span></a> <span class='Operator'>= </span><a href="../path/costsize.c.html#LN123"><span class='Ref_to_Global_Var'>enable_hashagg</span></a><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* don't consider hash if not enabled */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1409"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1403"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN1453"></a>        <a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>op</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1409"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN1454"></a>        <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>opno</span><span class='Delimiter'>; 
</span><a name="LN1455"></a>        <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>left_expr</span><span class='Delimiter'>; 
</span><a name="LN1456"></a>        <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>right_expr</span><span class='Delimiter'>; 
</span><a name="LN1457"></a>        <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>left_varnos</span><span class='Delimiter'>; 
</span><a name="LN1458"></a>        <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>right_varnos</span><span class='Delimiter'>; 
</span><a name="LN1459"></a>        <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>all_varnos</span><span class='Delimiter'>; 
</span><a name="LN1460"></a>        <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>opinputtype</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Is it a binary opclause? */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1453"><span class='Ref_To_Local'>op</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>            <a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1453"><span class='Ref_To_Local'>op</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN500"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>2</span><span class='Parentheses'>)</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* No, but does it reference both sides? */ 
</span>            <a href="initsplan.c.html#LN1459"><span class='Ref_To_Local'>all_varnos</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/var.h.html#LN29"><span class='Ref_to_Proto'>pull_varnos</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN1453"><span class='Ref_To_Local'>op</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1459"><span class='Ref_To_Local'>all_varnos</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1403"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1919"><span class='Ref_to_Member'>syn_righthand</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>                <a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1459"><span class='Ref_To_Local'>all_varnos</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1403"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1919"><span class='Ref_to_Member'>syn_righthand</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* 
                 * Clause refers to only one rel, so ignore it --- unless it 
                 * contains volatile functions, in which case we'd better 
                 * punt. 
                 */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/optimizer/clauses.h.html#LN60"><span class='Ref_to_Proto'>contain_volatile_functions</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN1453"><span class='Ref_To_Local'>op</span></a><span class='Parentheses'>))</span> 
                    <span class='Control'>return</span><span class='Delimiter'>; 
</span>                <span class='Control'>continue</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Comment_Multi_Line'>/* Non-operator clause referencing both sides, must punt */ 
</span>            <span class='Control'>return</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if !IsA(op,OpExpr)||list... &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* Extract data from binary opclause */ 
</span>        <a href="initsplan.c.html#LN1454"><span class='Ref_To_Local'>opno</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN1453"><span class='Ref_To_Local'>op</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN494"><span class='Ref_to_Member'>opno</span></a><span class='Delimiter'>; 
</span>        <a href="initsplan.c.html#LN1455"><span class='Ref_To_Local'>left_expr</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1453"><span class='Ref_To_Local'>op</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN500"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="initsplan.c.html#LN1456"><span class='Ref_To_Local'>right_expr</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN115"><span class='Ref_to_Macro'>lsecond</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1453"><span class='Ref_To_Local'>op</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN500"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="initsplan.c.html#LN1457"><span class='Ref_To_Local'>left_varnos</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/var.h.html#LN29"><span class='Ref_to_Proto'>pull_varnos</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1455"><span class='Ref_To_Local'>left_expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="initsplan.c.html#LN1458"><span class='Ref_To_Local'>right_varnos</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/var.h.html#LN29"><span class='Ref_to_Proto'>pull_varnos</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1456"><span class='Ref_To_Local'>right_expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="initsplan.c.html#LN1459"><span class='Ref_To_Local'>all_varnos</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN70"><span class='Ref_to_Proto'>bms_union</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1457"><span class='Ref_To_Local'>left_varnos</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1458"><span class='Ref_To_Local'>right_varnos</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="initsplan.c.html#LN1460"><span class='Ref_To_Local'>opinputtype</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1455"><span class='Ref_To_Local'>left_expr</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Does it reference both sides? */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1459"><span class='Ref_To_Local'>all_varnos</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1403"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1919"><span class='Ref_to_Member'>syn_righthand</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>            <a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1459"><span class='Ref_To_Local'>all_varnos</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1403"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1919"><span class='Ref_to_Member'>syn_righthand</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Clause refers to only one rel, so ignore it --- unless it 
             * contains volatile functions, in which case we'd better punt. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/optimizer/clauses.h.html#LN60"><span class='Ref_to_Proto'>contain_volatile_functions</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN1453"><span class='Ref_To_Local'>op</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>return</span><span class='Delimiter'>; 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* check rel membership of arguments */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN85"><span class='Ref_to_Proto'>bms_is_empty</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1458"><span class='Ref_To_Local'>right_varnos</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>            <a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1458"><span class='Ref_To_Local'>right_varnos</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1403"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1919"><span class='Ref_to_Member'>syn_righthand</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>            <span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1457"><span class='Ref_To_Local'>left_varnos</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1403"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1919"><span class='Ref_to_Member'>syn_righthand</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* typical case, right_expr is RHS variable */ 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN85"><span class='Ref_to_Proto'>bms_is_empty</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1457"><span class='Ref_To_Local'>left_varnos</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                 <a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1457"><span class='Ref_To_Local'>left_varnos</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1403"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1919"><span class='Ref_to_Member'>syn_righthand</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                 <span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1458"><span class='Ref_To_Local'>right_varnos</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1403"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1919"><span class='Ref_to_Member'>syn_righthand</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* flipped case, left_expr is RHS variable */ 
</span>            <a href="initsplan.c.html#LN1454"><span class='Ref_To_Local'>opno</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN106"><span class='Ref_to_Proto'>get_commutator</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1454"><span class='Ref_To_Local'>opno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1454"><span class='Ref_To_Local'>opno</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>return</span><span class='Delimiter'>; 
</span>            <a href="initsplan.c.html#LN1456"><span class='Ref_To_Local'>right_expr</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN1455"><span class='Ref_To_Local'>left_expr</span></a><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* mixed membership of args, punt */ 
</span>            <span class='Control'>return</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* all operators must be btree equality or hash equality */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN1407"><span class='Ref_To_Local'>all_btree</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* oprcanmerge is considered a hint... */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/utils/lsyscache.h.html#LN102"><span class='Ref_to_Proto'>op_mergejoinable</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1454"><span class='Ref_To_Local'>opno</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1460"><span class='Ref_To_Local'>opinputtype</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>                <a href="../../../include/utils/lsyscache.h.html#LN76"><span class='Ref_to_Proto'>get_mergejoin_opfamilies</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1454"><span class='Ref_To_Local'>opno</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span> 
                <a href="initsplan.c.html#LN1407"><span class='Ref_To_Local'>all_btree</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN1408"><span class='Ref_To_Local'>all_hash</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* ... but oprcanhash had better be correct */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/utils/lsyscache.h.html#LN103"><span class='Ref_to_Proto'>op_hashjoinable</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1454"><span class='Ref_To_Local'>opno</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1460"><span class='Ref_To_Local'>opinputtype</span></a><span class='Parentheses'>))</span> 
                <a href="initsplan.c.html#LN1408"><span class='Ref_To_Local'>all_hash</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1407"><span class='Ref_To_Local'>all_btree</span></a> <span class='Operator'>|| </span><a href="initsplan.c.html#LN1408"><span class='Ref_To_Local'>all_hash</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* so far so good, keep building lists */ 
</span>        <a href="initsplan.c.html#LN1405"><span class='Ref_To_Local'>semi_operators</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN162"><span class='Ref_to_Func'>lappend_oid</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1405"><span class='Ref_To_Local'>semi_operators</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1454"><span class='Ref_To_Local'>opno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="initsplan.c.html#LN1406"><span class='Ref_To_Local'>semi_rhs_exprs</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1406"><span class='Ref_To_Local'>semi_rhs_exprs</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN618"><span class='Ref_to_Macro'>copyObject</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1456"><span class='Ref_To_Local'>right_expr</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* Punt if we didn't find at least one column to unique-ify */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN1406"><span class='Ref_To_Local'>semi_rhs_exprs</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * The expressions we'd need to unique-ify mustn't be volatile. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/optimizer/clauses.h.html#LN60"><span class='Ref_to_Proto'>contain_volatile_functions</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN1406"><span class='Ref_To_Local'>semi_rhs_exprs</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If we get here, we can unique-ify the semijoin's RHS using at least one 
     * of sorting and hashing.  Save the information about how to do that. 
     */ 
</span>    <a href="initsplan.c.html#LN1403"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1924"><span class='Ref_to_Member'>semi_can_btree</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN1407"><span class='Ref_To_Local'>all_btree</span></a><span class='Delimiter'>; 
</span>    <a href="initsplan.c.html#LN1403"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1925"><span class='Ref_to_Member'>semi_can_hash</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN1408"><span class='Ref_To_Local'>all_hash</span></a><span class='Delimiter'>; 
</span>    <a href="initsplan.c.html#LN1403"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1926"><span class='Ref_to_Member'>semi_operators</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN1405"><span class='Ref_To_Local'>semi_operators</span></a><span class='Delimiter'>; 
</span>    <a href="initsplan.c.html#LN1403"><span class='Ref_to_Parameter'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1927"><span class='Ref_to_Member'>semi_rhs_exprs</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN1406"><span class='Ref_To_Local'>semi_rhs_exprs</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end compute_semijoin_info &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/***************************************************************************** 
 * 
 *    QUALIFICATIONS 
 * 
 *****************************************************************************/ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * distribute_qual_to_rels 
 *    Add clause information to either the baserestrictinfo or joininfo list 
 *    (depending on whether the clause is a join) of each base relation 
 *    mentioned in the clause.  A RestrictInfo node is created and added to 
 *    the appropriate list for each rel.  Alternatively, if the clause uses a 
 *    mergejoinable operator and is not delayed by outer-join rules, enter 
 *    the left- and right-side expressions into the query's list of 
 *    EquivalenceClasses.  Alternatively, if the clause needs to be treated 
 *    as belonging to a higher join level, just add it to postponed_qual_list. 
 * 
 * 'clause': the qual clause to be distributed 
 * 'is_deduced': TRUE if the qual came from implied-equality deduction 
 * 'below_outer_join': TRUE if the qual is from a JOIN/ON that is below the 
 *      nullable side of a higher-level outer join 
 * 'jointype': type of join the qual is from (JOIN_INNER for a WHERE clause) 
 * 'security_level': security_level to assign to the qual 
 * 'qualscope': set of baserels the qual's syntactic scope covers 
 * 'ojscope': NULL if not an outer-join qual, else the minimum set of baserels 
 *      needed to form this join 
 * 'outerjoin_nonnullable': NULL if not an outer-join qual, else the set of 
 *      baserels appearing on the outer (nonnullable) side of the join 
 *      (for FULL JOIN this includes both sides of the join, and must in fact 
 *      equal qualscope) 
 * 'deduced_nullable_relids': if is_deduced is TRUE, the nullable relids to 
 *      impute to the clause; otherwise NULL 
 * 'postponed_qual_list': list of PostponedQual structs, which we can add 
 *      this qual to if it turns out to belong to a higher join level. 
 *      Can be NULL if caller knows postponement is impossible. 
 * 
 * 'qualscope' identifies what level of JOIN the qual came from syntactically. 
 * 'ojscope' is needed if we decide to force the qual up to the outer-join 
 * level, which will be ojscope not necessarily qualscope. 
 * 
 * In normal use (when is_deduced is FALSE), at the time this is called, 
 * root-&GT;join_info_list must contain entries for all and only those special 
 * joins that are syntactically below this qual.  But when is_deduced is TRUE, 
 * we are adding new deduced clauses after completion of deconstruct_jointree, 
 * so it cannot be assumed that root-&GT;join_info_list has anything to do with 
 * qual placement. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN1620"></a><span class='Declare_Function'>distribute_qual_to_rels</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Delimiter'>, 
</span><a name="LN1621"></a>                        <span class='Keyword'>bool </span><span class='Declare_Parameter'>is_deduced</span><span class='Delimiter'>, 
</span><a name="LN1622"></a>                        <span class='Keyword'>bool </span><span class='Declare_Parameter'>below_outer_join</span><span class='Delimiter'>, 
</span><a name="LN1623"></a>                        <a href="../../../include/nodes/nodes.h.html#LN671"><span class='Ref_to_Enum'>JoinType</span></a> <span class='Declare_Parameter'>jointype</span><span class='Delimiter'>, 
</span><a name="LN1624"></a>                        <a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a> <span class='Declare_Parameter'>security_level</span><span class='Delimiter'>, 
</span><a name="LN1625"></a>                        <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Declare_Parameter'>qualscope</span><span class='Delimiter'>, 
</span><a name="LN1626"></a>                        <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Declare_Parameter'>ojscope</span><span class='Delimiter'>, 
</span><a name="LN1627"></a>                        <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Declare_Parameter'>outerjoin_nonnullable</span><span class='Delimiter'>, 
</span><a name="LN1628"></a>                        <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Declare_Parameter'>deduced_nullable_relids</span><span class='Delimiter'>, 
</span><a name="LN1629"></a>                        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>postponed_qual_list</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN1631"></a>    <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>relids</span><span class='Delimiter'>; 
</span><a name="LN1632"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>is_pushed_down</span><span class='Delimiter'>; 
</span><a name="LN1633"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>outerjoin_delayed</span><span class='Delimiter'>; 
</span><a name="LN1634"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>pseudoconstant</span> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span><a name="LN1635"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>maybe_equivalence</span><span class='Delimiter'>; 
</span><a name="LN1636"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>maybe_outer_join</span><span class='Delimiter'>; 
</span><a name="LN1637"></a>    <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>nullable_relids</span><span class='Delimiter'>; 
</span><a name="LN1638"></a>    <a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>restrictinfo</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Retrieve all relids mentioned within the clause. 
     */ 
</span>    <a href="initsplan.c.html#LN1631"><span class='Ref_To_Local'>relids</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/var.h.html#LN29"><span class='Ref_to_Proto'>pull_varnos</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1620"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * In ordinary SQL, a WHERE or JOIN/ON clause can't reference any rels 
     * that aren't within its syntactic scope; however, if we pulled up a 
     * LATERAL subquery then we might find such references in quals that have 
     * been pulled up.  We need to treat such quals as belonging to the join 
     * level that includes every rel they reference.  Although we could make 
     * pull_up_subqueries() place such quals correctly to begin with, it's 
     * easier to handle it here.  When we find a clause that contains Vars 
     * outside its syntactic scope, we add it to the postponed-quals list, and 
     * process it once we've recursed back up to the appropriate join level. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1631"><span class='Ref_To_Local'>relids</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1625"><span class='Ref_to_Parameter'>qualscope</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1658"></a>        <a href="initsplan.c.html#LN40"><span class='Ref_to_Struct'>PostponedQual</span></a> <span class='Operator'>*</span><span class='Declare_Local'>pq</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="initsplan.c.html#LN40"><span class='Ref_to_Struct'>PostponedQual</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="initsplan.c.html#LN40"><span class='Ref_to_Struct'>PostponedQual</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1620"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN299"><span class='Ref_to_Member'>hasLateralRTEs</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* shouldn't happen otherwise */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1623"><span class='Ref_to_Parameter'>jointype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN677"><span class='Ref_to_EnumConst'>JOIN_INNER</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* mustn't postpone past outer join */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="initsplan.c.html#LN1621"><span class='Ref_to_Parameter'>is_deduced</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* shouldn't be deduced, either */ 
</span>        <a href="initsplan.c.html#LN1658"><span class='Ref_To_Local'>pq</span></a><span class='Operator'>-&GT;</span><a href="initsplan.c.html#LN42"><span class='Ref_to_Member'>qual</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN1620"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>; 
</span>        <a href="initsplan.c.html#LN1658"><span class='Ref_To_Local'>pq</span></a><span class='Operator'>-&GT;</span><a href="initsplan.c.html#LN43"><span class='Ref_to_Member'>relids</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN1631"><span class='Ref_To_Local'>relids</span></a><span class='Delimiter'>; 
</span>        <span class='Operator'>*</span><a href="initsplan.c.html#LN1629"><span class='Ref_to_Parameter'>postponed_qual_list</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="initsplan.c.html#LN1629"><span class='Ref_to_Parameter'>postponed_qual_list</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1658"><span class='Ref_To_Local'>pq</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If it's an outer-join clause, also check that relids is a subset of 
     * ojscope.  (This should not fail if the syntactic scope check passed.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN1626"><span class='Ref_to_Parameter'>ojscope</span></a> <span class='Operator'>&& !</span><a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1631"><span class='Ref_To_Local'>relids</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1626"><span class='Ref_to_Parameter'>ojscope</span></a><span class='Parentheses'>))</span> 
        <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"JOIN qualification cannot refer to other relations"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the clause is variable-free, our normal heuristic for pushing it 
     * down to just the mentioned rels doesn't work, because there are none. 
     * 
     * If the clause is an outer-join clause, we must force it to the OJ's 
     * semantic level to preserve semantics. 
     * 
     * Otherwise, when the clause contains volatile functions, we force it to 
     * be evaluated at its original syntactic level.  This preserves the 
     * expected semantics. 
     * 
     * When the clause contains no volatile functions either, it is actually a 
     * pseudoconstant clause that will not change value during any one 
     * execution of the plan, and hence can be used as a one-time qual in a 
     * gating Result plan node.  We put such a clause into the regular 
     * RestrictInfo lists for the moment, but eventually createplan.c will 
     * pull it out and make a gating Result node immediately above whatever 
     * plan node the pseudoconstant clause is assigned to.  It's usually best 
     * to put a gating node as high in the plan tree as possible. If we are 
     * not below an outer join, we can actually push the pseudoconstant qual 
     * all the way to the top of the tree.  If we are below an outer join, we 
     * leave the qual at its original syntactic level (we could push it up to 
     * just below the outer join, but that seems more complex than it's 
     * worth). 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN85"><span class='Ref_to_Proto'>bms_is_empty</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1631"><span class='Ref_To_Local'>relids</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN1626"><span class='Ref_to_Parameter'>ojscope</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* clause is attached to outer join, eval it there */ 
</span>            <a href="initsplan.c.html#LN1631"><span class='Ref_To_Local'>relids</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN65"><span class='Ref_to_Proto'>bms_copy</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1626"><span class='Ref_to_Parameter'>ojscope</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* mustn't use as gating qual, so don't mark pseudoconstant */ 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* eval at original syntactic level */ 
</span>            <a href="initsplan.c.html#LN1631"><span class='Ref_To_Local'>relids</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN65"><span class='Ref_to_Proto'>bms_copy</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1625"><span class='Ref_to_Parameter'>qualscope</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/optimizer/clauses.h.html#LN60"><span class='Ref_to_Proto'>contain_volatile_functions</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1620"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* mark as gating qual */ 
</span>                <a href="initsplan.c.html#LN1634"><span class='Ref_To_Local'>pseudoconstant</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Comment_Multi_Line'>/* tell createplan.c to check for gating quals */ 
</span>                <a href="initsplan.c.html#LN1620"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN302"><span class='Ref_to_Member'>hasPseudoConstantQuals</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Comment_Multi_Line'>/* if not below outer join, push it to top of tree */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="initsplan.c.html#LN1622"><span class='Ref_to_Parameter'>below_outer_join</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <a href="initsplan.c.html#LN1631"><span class='Ref_To_Local'>relids</span></a> <span class='Operator'>= 
</span>                        <a href="../../../include/optimizer/prep.h.html#LN28"><span class='Ref_to_Proto'>get_relids_in_jointree</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN1620"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN135"><span class='Ref_to_Member'>jointree</span></a><span class='Delimiter'>, 
</span>                                               <span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="initsplan.c.html#LN1625"><span class='Ref_to_Parameter'>qualscope</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN65"><span class='Ref_to_Proto'>bms_copy</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1631"><span class='Ref_To_Local'>relids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>            <span class='Delimiter'>} 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if bms_is_empty(relids) &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/*---------- 
     * Check to see if clause application must be delayed by outer-join 
     * considerations. 
     * 
     * A word about is_pushed_down: we mark the qual as "pushed down" if 
     * it is (potentially) applicable at a level different from its original 
     * syntactic level.  This flag is used to distinguish OUTER JOIN ON quals 
     * from other quals pushed down to the same joinrel.  The rules are: 
     *      WHERE quals and INNER JOIN quals: is_pushed_down = true. 
     *      Non-degenerate OUTER JOIN quals: is_pushed_down = false. 
     *      Degenerate OUTER JOIN quals: is_pushed_down = true. 
     * A "degenerate" OUTER JOIN qual is one that doesn't mention the 
     * non-nullable side, and hence can be pushed down into the nullable side 
     * without changing the join result.  It is correct to treat it as a 
     * regular filter condition at the level where it is evaluated. 
     * 
     * Note: it is not immediately obvious that a simple boolean is enough 
     * for this: if for some reason we were to attach a degenerate qual to 
     * its original join level, it would need to be treated as an outer join 
     * qual there.  However, this cannot happen, because all the rels the 
     * clause mentions must be in the outer join's min_righthand, therefore 
     * the join it needs must be formed before the outer join; and we always 
     * attach quals to the lowest level where they can be evaluated.  But 
     * if we were ever to re-introduce a mechanism for delaying evaluation 
     * of "expensive" quals, this area would need work. 
     *---------- 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN1621"><span class='Ref_to_Parameter'>is_deduced</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * If the qual came from implied-equality deduction, it should not be 
         * outerjoin-delayed, else deducer blew it.  But we can't check this 
         * because the join_info_list may now contain OJs above where the qual 
         * belongs.  For the same reason, we must rely on caller to supply the 
         * correct nullable_relids set. 
         */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="initsplan.c.html#LN1626"><span class='Ref_to_Parameter'>ojscope</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="initsplan.c.html#LN1632"><span class='Ref_To_Local'>is_pushed_down</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <a href="initsplan.c.html#LN1633"><span class='Ref_To_Local'>outerjoin_delayed</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <a href="initsplan.c.html#LN1637"><span class='Ref_To_Local'>nullable_relids</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN1628"><span class='Ref_to_Parameter'>deduced_nullable_relids</span></a><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* Don't feed it back for more deductions */ 
</span>        <a href="initsplan.c.html#LN1635"><span class='Ref_To_Local'>maybe_equivalence</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <a href="initsplan.c.html#LN1636"><span class='Ref_To_Local'>maybe_outer_join</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1631"><span class='Ref_To_Local'>relids</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1627"><span class='Ref_to_Parameter'>outerjoin_nonnullable</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * The qual is attached to an outer join and mentions (some of the) 
         * rels on the nonnullable side, so it's not degenerate. 
         * 
         * We can't use such a clause to deduce equivalence (the left and 
         * right sides might be unequal above the join because one of them has 
         * gone to NULL) ... but we might be able to use it for more limited 
         * deductions, if it is mergejoinable.  So consider adding it to the 
         * lists of set-aside outer-join clauses. 
         */ 
</span>        <a href="initsplan.c.html#LN1632"><span class='Ref_To_Local'>is_pushed_down</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <a href="initsplan.c.html#LN1635"><span class='Ref_To_Local'>maybe_equivalence</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <a href="initsplan.c.html#LN1636"><span class='Ref_To_Local'>maybe_outer_join</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Check to see if must be delayed by lower outer join */ 
</span>        <a href="initsplan.c.html#LN1633"><span class='Ref_To_Local'>outerjoin_delayed</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN71"><span class='Ref_to_Proto'>check_outerjoin_delay</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1620"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                                  <span class='Operator'>&</span><a href="initsplan.c.html#LN1631"><span class='Ref_To_Local'>relids</span></a><span class='Delimiter'>, 
</span>                                                  <span class='Operator'>&</span><a href="initsplan.c.html#LN1637"><span class='Ref_To_Local'>nullable_relids</span></a><span class='Delimiter'>, 
</span>                                                  <span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Now force the qual to be evaluated exactly at the level of joining 
         * corresponding to the outer join.  We cannot let it get pushed down 
         * into the nonnullable side, since then we'd produce no output rows, 
         * rather than the intended single null-extended row, for any 
         * nonnullable-side rows failing the qual. 
         * 
         * (Do this step after calling check_outerjoin_delay, because that 
         * trashes relids.) 
         */ 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1626"><span class='Ref_to_Parameter'>ojscope</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="initsplan.c.html#LN1631"><span class='Ref_To_Local'>relids</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN1626"><span class='Ref_to_Parameter'>ojscope</span></a><span class='Delimiter'>; 
</span>        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="initsplan.c.html#LN1634"><span class='Ref_To_Local'>pseudoconstant</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if bms_overlap(relids,ou... &raquo; </span> 
    <span class='Control'>else</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Comment_Multi_Line'>/* 
         * Normal qual clause or degenerate outer-join clause.  Either way, we 
         * can mark it as pushed-down. 
         */ 
</span>        <a href="initsplan.c.html#LN1632"><span class='Ref_To_Local'>is_pushed_down</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* Check to see if must be delayed by lower outer join */ 
</span>        <a href="initsplan.c.html#LN1633"><span class='Ref_To_Local'>outerjoin_delayed</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN71"><span class='Ref_to_Proto'>check_outerjoin_delay</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1620"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                                  <span class='Operator'>&</span><a href="initsplan.c.html#LN1631"><span class='Ref_To_Local'>relids</span></a><span class='Delimiter'>, 
</span>                                                  <span class='Operator'>&</span><a href="initsplan.c.html#LN1637"><span class='Ref_To_Local'>nullable_relids</span></a><span class='Delimiter'>, 
</span>                                                  <span class='Boolean'>true</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN1633"><span class='Ref_To_Local'>outerjoin_delayed</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* Should still be a subset of current scope ... */ 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1620"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN299"><span class='Ref_to_Member'>hasLateralRTEs</span></a> <span class='Operator'>|| </span><a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1631"><span class='Ref_To_Local'>relids</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1625"><span class='Ref_to_Parameter'>qualscope</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1626"><span class='Ref_to_Parameter'>ojscope</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL </span><span class='Operator'>|| </span><a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1631"><span class='Ref_To_Local'>relids</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1626"><span class='Ref_to_Parameter'>ojscope</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Because application of the qual will be delayed by outer join, 
             * we mustn't assume its vars are equal everywhere. 
             */ 
</span>            <a href="initsplan.c.html#LN1635"><span class='Ref_To_Local'>maybe_equivalence</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * It's possible that this is an IS NULL clause that's redundant 
             * with a lower antijoin; if so we can just discard it.  We need 
             * not test in any of the other cases, because this will only be 
             * possible for pushed-down, delayed clauses. 
             */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN75"><span class='Ref_to_Proto'>check_redundant_nullability_qual</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1620"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1620"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>return</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if outerjoin_delayed &raquo; </span> 
        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* 
             * Qual is not delayed by any lower outer-join restriction, so we 
             * can consider feeding it to the equivalence machinery. However, 
             * if it's itself within an outer-join clause, treat it as though 
             * it appeared below that outer join (note that we can only get 
             * here when the clause references only nullable-side rels). 
             */ 
</span>            <a href="initsplan.c.html#LN1635"><span class='Ref_To_Local'>maybe_equivalence</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN1627"><span class='Ref_to_Parameter'>outerjoin_nonnullable</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>                <a href="initsplan.c.html#LN1622"><span class='Ref_to_Parameter'>below_outer_join</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Since it doesn't mention the LHS, it's certainly not useful as a 
         * set-aside OJ clause, even if it's in an OJ. 
         */ 
</span>        <a href="initsplan.c.html#LN1636"><span class='Ref_To_Local'>maybe_outer_join</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end else &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* 
     * Build the RestrictInfo node itself. 
     */ 
</span>    <a href="initsplan.c.html#LN1638"><span class='Ref_To_Local'>restrictinfo</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/restrictinfo.h.html#LN23"><span class='Ref_to_Proto'>make_restrictinfo</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN1620"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, 
</span>                                     <a href="initsplan.c.html#LN1632"><span class='Ref_To_Local'>is_pushed_down</span></a><span class='Delimiter'>, 
</span>                                     <a href="initsplan.c.html#LN1633"><span class='Ref_To_Local'>outerjoin_delayed</span></a><span class='Delimiter'>, 
</span>                                     <a href="initsplan.c.html#LN1634"><span class='Ref_To_Local'>pseudoconstant</span></a><span class='Delimiter'>, 
</span>                                     <a href="initsplan.c.html#LN1624"><span class='Ref_to_Parameter'>security_level</span></a><span class='Delimiter'>, 
</span>                                     <a href="initsplan.c.html#LN1631"><span class='Ref_To_Local'>relids</span></a><span class='Delimiter'>, 
</span>                                     <a href="initsplan.c.html#LN1627"><span class='Ref_to_Parameter'>outerjoin_nonnullable</span></a><span class='Delimiter'>, 
</span>                                     <a href="initsplan.c.html#LN1637"><span class='Ref_To_Local'>nullable_relids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If it's a join clause (either naturally, or because delayed by 
     * outer-join rules), add vars used in the clause to targetlists of their 
     * relations, so that they will be emitted by the plan nodes that scan 
     * those relations (else they won't be available at the join node!). 
     * 
     * Note: if the clause gets absorbed into an EquivalenceClass then this 
     * may be unnecessary, but for now we have to do it to cover the case 
     * where the EC becomes ec_broken and we end up reinserting the original 
     * clauses into the plan. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN84"><span class='Ref_to_Proto'>bms_membership</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1631"><span class='Ref_To_Local'>relids</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="../../../include/nodes/bitmapset.h.html#LN57"><span class='Ref_to_EnumConst'>BMS_MULTIPLE</span></a><span class='Parentheses'>)</span> 
    <span class='Delimiter'>{ 
</span><a name="LN1892"></a>        <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>vars</span> <span class='Operator'>= </span><a href="../../../include/optimizer/var.h.html#LN36"><span class='Ref_to_Proto'>pull_var_clause</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1620"><span class='Ref_to_Parameter'>clause</span></a><span class='Delimiter'>, 
</span>                                           <a href="../../../include/optimizer/var.h.html#LN20"><span class='Ref_to_Const'>PVC_RECURSE_AGGREGATES</span></a> <span class='Operator'>| 
</span>                                           <a href="../../../include/optimizer/var.h.html#LN22"><span class='Ref_to_Const'>PVC_RECURSE_WINDOWFUNCS</span></a> <span class='Operator'>| 
</span>                                           <a href="../../../include/optimizer/var.h.html#LN23"><span class='Ref_to_Const'>PVC_INCLUDE_PLACEHOLDERS</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="../../../include/optimizer/planmain.h.html#LN75"><span class='Ref_to_Proto'>add_vars_to_targetlist</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1620"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1892"><span class='Ref_To_Local'>vars</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1631"><span class='Ref_To_Local'>relids</span></a><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN265"><span class='Ref_to_Proto'>list_free</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1892"><span class='Ref_To_Local'>vars</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We check "mergejoinability" of every clause, not only join clauses, 
     * because we want to know about equivalences between vars of the same 
     * relation, or between vars and consts. 
     */ 
</span>    <a href="initsplan.c.html#LN76"><span class='Ref_to_Proto'>check_mergejoinable</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1638"><span class='Ref_To_Local'>restrictinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If it is a true equivalence clause, send it to the EquivalenceClass 
     * machinery.  We do *not* attach it directly to any restriction or join 
     * lists.  The EC code will propagate it to the appropriate places later. 
     * 
     * If the clause has a mergejoinable operator and is not 
     * outerjoin-delayed, yet isn't an equivalence because it is an outer-join 
     * clause, the EC code may yet be able to do something with it.  We add it 
     * to appropriate lists for further consideration later.  Specifically: 
     * 
     * If it is a left or right outer-join qualification that relates the two 
     * sides of the outer join (no funny business like leftvar1 = leftvar2 + 
     * rightvar), we add it to root-&GT;left_join_clauses or 
     * root-&GT;right_join_clauses according to which side the nonnullable 
     * variable appears on. 
     * 
     * If it is a full outer-join qualification, we add it to 
     * root-&GT;full_join_clauses.  (Ideally we'd discard cases that aren't 
     * leftvar = rightvar, as we do for left/right joins, but this routine 
     * doesn't have the info needed to do that; and the current usage of the 
     * full_join_clauses list doesn't require that, so it's not currently 
     * worth complicating this routine's API to make it possible.) 
     * 
     * If none of the above hold, pass it off to 
     * distribute_restrictinfo_to_rels(). 
     * 
     * In all cases, it's important to initialize the left_ec and right_ec 
     * fields of a mergejoinable clause, so that all possibly mergejoinable 
     * expressions have representations in EquivalenceClasses.  If 
     * process_equivalence is successful, it will take care of that; 
     * otherwise, we have to call initialize_mergeclause_eclasses to do it. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN1638"><span class='Ref_To_Local'>restrictinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1791"><span class='Ref_to_Member'>mergeopfamilies</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN1635"><span class='Ref_To_Local'>maybe_equivalence</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN73"><span class='Ref_to_Proto'>check_equivalence_delay</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1620"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1638"><span class='Ref_To_Local'>restrictinfo</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                <a href="../path/equivclass.c.html#LN105"><span class='Ref_to_Func'>process_equivalence</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1620"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1638"><span class='Ref_To_Local'>restrictinfo</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1622"><span class='Ref_to_Parameter'>below_outer_join</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>return</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* EC rejected it, so set left_ec/right_ec the hard way ... */ 
</span>            <a href="../../../include/optimizer/paths.h.html#LN208"><span class='Ref_to_Proto'>initialize_mergeclause_eclasses</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1620"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1638"><span class='Ref_To_Local'>restrictinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* ... and fall through to distribute_restrictinfo_to_rels */ 
</span>        <span class='Delimiter'>} 
</span>        <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN1636"><span class='Ref_To_Local'>maybe_outer_join</span></a> <span class='Operator'>&& </span><a href="initsplan.c.html#LN1638"><span class='Ref_To_Local'>restrictinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1752"><span class='Ref_to_Member'>can_join</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* we need to set up left_ec/right_ec the hard way */ 
</span>            <a href="../../../include/optimizer/paths.h.html#LN208"><span class='Ref_to_Proto'>initialize_mergeclause_eclasses</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1620"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1638"><span class='Ref_To_Local'>restrictinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* now see if it should go to any outer-join lists */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1638"><span class='Ref_To_Local'>restrictinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1773"><span class='Ref_to_Member'>left_relids</span></a><span class='Delimiter'>, 
</span>                              <a href="initsplan.c.html#LN1627"><span class='Ref_to_Parameter'>outerjoin_nonnullable</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                <span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1638"><span class='Ref_To_Local'>restrictinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1774"><span class='Ref_to_Member'>right_relids</span></a><span class='Delimiter'>, 
</span>                             <a href="initsplan.c.html#LN1627"><span class='Ref_to_Parameter'>outerjoin_nonnullable</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* we have outervar = innervar */ 
</span>                <a href="initsplan.c.html#LN1620"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN238"><span class='Ref_to_Member'>left_join_clauses</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1620"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN238"><span class='Ref_to_Member'>left_join_clauses</span></a><span class='Delimiter'>, 
</span>                                                  <a href="initsplan.c.html#LN1638"><span class='Ref_To_Local'>restrictinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>return</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1638"><span class='Ref_To_Local'>restrictinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1774"><span class='Ref_to_Member'>right_relids</span></a><span class='Delimiter'>, 
</span>                              <a href="initsplan.c.html#LN1627"><span class='Ref_to_Parameter'>outerjoin_nonnullable</span></a><span class='Parentheses'>) </span><span class='Operator'>&& 
</span>                <span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1638"><span class='Ref_To_Local'>restrictinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1773"><span class='Ref_to_Member'>left_relids</span></a><span class='Delimiter'>, 
</span>                             <a href="initsplan.c.html#LN1627"><span class='Ref_to_Parameter'>outerjoin_nonnullable</span></a><span class='Parentheses'>))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* we have innervar = outervar */ 
</span>                <a href="initsplan.c.html#LN1620"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN242"><span class='Ref_to_Member'>right_join_clauses</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1620"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN242"><span class='Ref_to_Member'>right_join_clauses</span></a><span class='Delimiter'>, 
</span>                                                   <a href="initsplan.c.html#LN1638"><span class='Ref_To_Local'>restrictinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>return</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN1623"><span class='Ref_to_Parameter'>jointype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN679"><span class='Ref_to_EnumConst'>JOIN_FULL</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* FULL JOIN (above tests cannot match in this case) */ 
</span>                <a href="initsplan.c.html#LN1620"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN246"><span class='Ref_to_Member'>full_join_clauses</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1620"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN246"><span class='Ref_to_Member'>full_join_clauses</span></a><span class='Delimiter'>, 
</span>                                                  <a href="initsplan.c.html#LN1638"><span class='Ref_To_Local'>restrictinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>return</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span>            <span class='Comment_Multi_Line'>/* nope, so fall through to distribute_restrictinfo_to_rels */ 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if maybe_outer_join&&res... &raquo; </span> 
        <span class='Control'>else</span> 
        <span class='Delimiter'>{ 
</span>            <span class='Comment_Multi_Line'>/* we still need to set up left_ec/right_ec */ 
</span>            <a href="../../../include/optimizer/paths.h.html#LN208"><span class='Ref_to_Proto'>initialize_mergeclause_eclasses</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1620"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1638"><span class='Ref_To_Local'>restrictinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if restrictinfo-&GT;mergeop... &raquo; </span> 
 
    <span class='Comment_Multi_Line'>/* No EC special case applies, so push it into the clause lists */ 
</span>    <a href="../../../include/optimizer/planmain.h.html#LN80"><span class='Ref_to_Proto'>distribute_restrictinfo_to_rels</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN1620"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN1638"><span class='Ref_To_Local'>restrictinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end distribute_qual_to_rels &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * check_outerjoin_delay 
 *      Detect whether a qual referencing the given relids must be delayed 
 *      in application due to the presence of a lower outer join, and/or 
 *      may force extra delay of higher-level outer joins. 
 * 
 * If the qual must be delayed, add relids to *relids_p to reflect the lowest 
 * safe level for evaluating the qual, and return TRUE.  Any extra delay for 
 * higher-level joins is reflected by setting delay_upper_joins to TRUE in 
 * SpecialJoinInfo structs.  We also compute nullable_relids, the set of 
 * referenced relids that are nullable by lower outer joins (note that this 
 * can be nonempty even for a non-delayed qual). 
 * 
 * For an is_pushed_down qual, we can evaluate the qual as soon as (1) we have 
 * all the rels it mentions, and (2) we are at or above any outer joins that 
 * can null any of these rels and are below the syntactic location of the 
 * given qual.  We must enforce (2) because pushing down such a clause below 
 * the OJ might cause the OJ to emit null-extended rows that should not have 
 * been formed, or that should have been rejected by the clause.  (This is 
 * only an issue for non-strict quals, since if we can prove a qual mentioning 
 * only nullable rels is strict, we'd have reduced the outer join to an inner 
 * join in reduce_outer_joins().) 
 * 
 * To enforce (2), scan the join_info_list and merge the required-relid sets of 
 * any such OJs into the clause's own reference list.  At the time we are 
 * called, the join_info_list contains only outer joins below this qual.  We 
 * have to repeat the scan until no new relids get added; this ensures that 
 * the qual is suitably delayed regardless of the order in which OJs get 
 * executed.  As an example, if we have one OJ with LHS=A, RHS=B, and one with 
 * LHS=B, RHS=C, it is implied that these can be done in either order; if the 
 * B/C join is done first then the join to A can null C, so a qual actually 
 * mentioning only C cannot be applied below the join to A. 
 * 
 * For a non-pushed-down qual, this isn't going to determine where we place the 
 * qual, but we need to determine outerjoin_delayed and nullable_relids anyway 
 * for use later in the planning process. 
 * 
 * Lastly, a pushed-down qual that references the nullable side of any current 
 * join_info_list member and has to be evaluated above that OJ (because its 
 * required relids overlap the LHS too) causes that OJ's delay_upper_joins 
 * flag to be set TRUE.  This will prevent any higher-level OJs from 
 * being interchanged with that OJ, which would result in not having any 
 * correct place to evaluate the qual.  (The case we care about here is a 
 * sub-select WHERE clause within the RHS of some outer join.  The WHERE 
 * clause must effectively be treated as a degenerate clause of that outer 
 * join's condition.  Rather than trying to match such clauses with joins 
 * directly, we set delay_upper_joins here, and when the upper outer join 
 * is processed by make_outerjoininfo, it will refrain from allowing the 
 * two OJs to commute.) 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN2047"></a><span class='Declare_Function'>check_outerjoin_delay</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN2048"></a>                      <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>relids_p</span><span class='Delimiter'>, </span><span class='Comment_Single_Line'>/* in/out parameter */ 
</span><a name="LN2049"></a>                      <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>nullable_relids_p</span><span class='Delimiter'>,</span>        <span class='Comment_Single_Line'>/* output parameter */ 
</span><a name="LN2050"></a>                      <span class='Keyword'>bool </span><span class='Declare_Parameter'>is_pushed_down</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2052"></a>    <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>relids</span><span class='Delimiter'>; 
</span><a name="LN2053"></a>    <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>nullable_relids</span><span class='Delimiter'>; 
</span><a name="LN2054"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>outerjoin_delayed</span><span class='Delimiter'>; 
</span><a name="LN2055"></a>    <span class='Keyword'>bool</span>        <span class='Declare_Local'>found_some</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* fast path if no special joins */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN2047"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN249"><span class='Ref_to_Member'>join_info_list</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <span class='Operator'>*</span><a href="initsplan.c.html#LN2049"><span class='Ref_to_Parameter'>nullable_relids_p</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* must copy relids because we need the original value at the end */ 
</span>    <a href="initsplan.c.html#LN2052"><span class='Ref_To_Local'>relids</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN65"><span class='Ref_to_Proto'>bms_copy</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="initsplan.c.html#LN2048"><span class='Ref_to_Parameter'>relids_p</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="initsplan.c.html#LN2053"><span class='Ref_To_Local'>nullable_relids</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="initsplan.c.html#LN2054"><span class='Ref_To_Local'>outerjoin_delayed</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Control'>do</span> 
    <span class='Delimiter'>{ 
</span><a name="LN2070"></a>        <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
        <a href="initsplan.c.html#LN2055"><span class='Ref_To_Local'>found_some</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2070"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN2047"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN249"><span class='Ref_to_Member'>join_info_list</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN2075"></a>            <a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sjinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2070"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* do we reference any nullable rels of this OJ? */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2052"><span class='Ref_To_Local'>relids</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN2075"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1917"><span class='Ref_to_Member'>min_righthand</span></a><span class='Parentheses'>)</span> <span class='Operator'>|| 
</span>                <span class='Parentheses'>(</span><a href="initsplan.c.html#LN2075"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1920"><span class='Ref_to_Member'>jointype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN679"><span class='Ref_to_EnumConst'>JOIN_FULL</span></a> <span class='Operator'>&& 
</span>                 <a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2052"><span class='Ref_To_Local'>relids</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN2075"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1916"><span class='Ref_to_Member'>min_lefthand</span></a><span class='Parentheses'>)))</span> 
            <span class='Delimiter'>{ 
</span>                <span class='Comment_Multi_Line'>/* yes; have we included all its rels in relids? */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2075"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1916"><span class='Ref_to_Member'>min_lefthand</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN2052"><span class='Ref_To_Local'>relids</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>                    <span class='Operator'>!</span><a href="../../../include/nodes/bitmapset.h.html#LN73"><span class='Ref_to_Proto'>bms_is_subset</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2075"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1917"><span class='Ref_to_Member'>min_righthand</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN2052"><span class='Ref_To_Local'>relids</span></a><span class='Parentheses'>))</span> 
                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* no, so add them in */ 
</span>                    <a href="initsplan.c.html#LN2052"><span class='Ref_To_Local'>relids</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN91"><span class='Ref_to_Proto'>bms_add_members</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2052"><span class='Ref_To_Local'>relids</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN2075"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1916"><span class='Ref_to_Member'>min_lefthand</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="initsplan.c.html#LN2052"><span class='Ref_To_Local'>relids</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN91"><span class='Ref_to_Proto'>bms_add_members</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2052"><span class='Ref_To_Local'>relids</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN2075"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1917"><span class='Ref_to_Member'>min_righthand</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <a href="initsplan.c.html#LN2054"><span class='Ref_To_Local'>outerjoin_delayed</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                    <span class='Comment_Multi_Line'>/* we'll need another iteration */ 
</span>                    <a href="initsplan.c.html#LN2055"><span class='Ref_To_Local'>found_some</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>                <span class='Delimiter'>} 
</span>                <span class='Comment_Multi_Line'>/* track all the nullable rels of relevant OJs */ 
</span>                <a href="initsplan.c.html#LN2053"><span class='Ref_To_Local'>nullable_relids</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN91"><span class='Ref_to_Proto'>bms_add_members</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2053"><span class='Ref_To_Local'>nullable_relids</span></a><span class='Delimiter'>, 
</span>                                                  <a href="initsplan.c.html#LN2075"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1917"><span class='Ref_to_Member'>min_righthand</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN2075"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1920"><span class='Ref_to_Member'>jointype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN679"><span class='Ref_to_EnumConst'>JOIN_FULL</span></a><span class='Parentheses'>) 
</span>                    <a href="initsplan.c.html#LN2053"><span class='Ref_To_Local'>nullable_relids</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN91"><span class='Ref_to_Proto'>bms_add_members</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2053"><span class='Ref_To_Local'>nullable_relids</span></a><span class='Delimiter'>, 
</span>                                                      <a href="initsplan.c.html#LN2075"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1916"><span class='Ref_to_Member'>min_lefthand</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <span class='Comment_Multi_Line'>/* set delay_upper_joins if needed */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN2050"><span class='Ref_to_Parameter'>is_pushed_down</span></a> <span class='Operator'>&& </span><a href="initsplan.c.html#LN2075"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1920"><span class='Ref_to_Member'>jointype</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/nodes.h.html#LN679"><span class='Ref_to_EnumConst'>JOIN_FULL</span></a> <span class='Operator'>&& 
</span>                    <a href="../../../include/nodes/bitmapset.h.html#LN76"><span class='Ref_to_Proto'>bms_overlap</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2052"><span class='Ref_To_Local'>relids</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN2075"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1916"><span class='Ref_to_Member'>min_lefthand</span></a><span class='Parentheses'>))</span> 
                    <a href="initsplan.c.html#LN2075"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1922"><span class='Ref_to_Member'>delay_upper_joins</span></a> <span class='Operator'>= </span><span class='Boolean'>true</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if bms_overlap(relids,sj... &raquo; </span> 
        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end do &raquo; </span> <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN2055"><span class='Ref_To_Local'>found_some</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* identify just the actually-referenced nullable rels */ 
</span>    <a href="initsplan.c.html#LN2053"><span class='Ref_To_Local'>nullable_relids</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN92"><span class='Ref_to_Proto'>bms_int_members</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2053"><span class='Ref_To_Local'>nullable_relids</span></a><span class='Delimiter'>, </span><span class='Operator'>*</span><a href="initsplan.c.html#LN2048"><span class='Ref_to_Parameter'>relids_p</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* replace *relids_p, and return nullable_relids */ 
</span>    <a href="../../../include/nodes/bitmapset.h.html#LN68"><span class='Ref_to_Proto'>bms_free</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="initsplan.c.html#LN2048"><span class='Ref_to_Parameter'>relids_p</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="initsplan.c.html#LN2048"><span class='Ref_to_Parameter'>relids_p</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN2052"><span class='Ref_To_Local'>relids</span></a><span class='Delimiter'>; 
</span>    <span class='Operator'>*</span><a href="initsplan.c.html#LN2049"><span class='Ref_to_Parameter'>nullable_relids_p</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN2053"><span class='Ref_To_Local'>nullable_relids</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="initsplan.c.html#LN2054"><span class='Ref_To_Local'>outerjoin_delayed</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end check_outerjoin_delay &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * check_equivalence_delay 
 *      Detect whether a potential equivalence clause is rendered unsafe 
 *      by outer-join-delay considerations.  Return TRUE if it's safe. 
 * 
 * The initial tests in distribute_qual_to_rels will consider a mergejoinable 
 * clause to be a potential equivalence clause if it is not outerjoin_delayed. 
 * But since the point of equivalence processing is that we will recombine the 
 * two sides of the clause with others, we have to check that each side 
 * satisfies the not-outerjoin_delayed condition on its own; otherwise it might 
 * not be safe to evaluate everywhere we could place a derived equivalence 
 * condition. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN2131"></a><span class='Declare_Function'>check_equivalence_delay</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN2132"></a>                        <a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>restrictinfo</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2134"></a>    <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>relids</span><span class='Delimiter'>; 
</span><a name="LN2135"></a>    <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>nullable_relids</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* fast path if no special joins */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN2131"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN249"><span class='Ref_to_Member'>join_info_list</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* must copy restrictinfo's relids to avoid changing it */ 
</span>    <a href="initsplan.c.html#LN2134"><span class='Ref_To_Local'>relids</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN65"><span class='Ref_to_Proto'>bms_copy</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2132"><span class='Ref_to_Parameter'>restrictinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1773"><span class='Ref_to_Member'>left_relids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* check left side does not need delay */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN71"><span class='Ref_to_Proto'>check_outerjoin_delay</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2131"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="initsplan.c.html#LN2134"><span class='Ref_To_Local'>relids</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="initsplan.c.html#LN2135"><span class='Ref_To_Local'>nullable_relids</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* and similarly for the right side */ 
</span>    <a href="initsplan.c.html#LN2134"><span class='Ref_To_Local'>relids</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/bitmapset.h.html#LN65"><span class='Ref_to_Proto'>bms_copy</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2132"><span class='Ref_to_Parameter'>restrictinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1774"><span class='Ref_to_Member'>right_relids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN71"><span class='Ref_to_Proto'>check_outerjoin_delay</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2131"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="initsplan.c.html#LN2134"><span class='Ref_To_Local'>relids</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="initsplan.c.html#LN2135"><span class='Ref_To_Local'>nullable_relids</span></a><span class='Delimiter'>, </span><span class='Boolean'>true</span><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end check_equivalence_delay &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * check_redundant_nullability_qual 
 *    Check to see if the qual is an IS NULL qual that is redundant with 
 *    a lower JOIN_ANTI join. 
 * 
 * We want to suppress redundant IS NULL quals, not so much to save cycles 
 * as to avoid generating bogus selectivity estimates for them.  So if 
 * redundancy is detected here, distribute_qual_to_rels() just throws away 
 * the qual. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN2166"></a><span class='Declare_Function'>check_redundant_nullability_qual</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>clause</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2168"></a>    <a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>forced_null_var</span><span class='Delimiter'>; 
</span><a name="LN2169"></a>    <a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a>       <span class='Declare_Local'>forced_null_rel</span><span class='Delimiter'>; 
</span><a name="LN2170"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Check for IS NULL, and identify the Var forced to NULL */ 
</span>    <a href="initsplan.c.html#LN2168"><span class='Ref_To_Local'>forced_null_var</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/clauses.h.html#LN70"><span class='Ref_to_Proto'>find_forced_null_var</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2166"><span class='Ref_to_Parameter'>clause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN2168"><span class='Ref_To_Local'>forced_null_var</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="initsplan.c.html#LN2169"><span class='Ref_To_Local'>forced_null_rel</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN2168"><span class='Ref_To_Local'>forced_null_var</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN165"><span class='Ref_to_Member'>varno</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * If the Var comes from the nullable side of a lower antijoin, the IS 
     * NULL condition is necessarily true. 
     */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2170"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN2166"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN249"><span class='Ref_to_Member'>join_info_list</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2184"></a>        <a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sjinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1913"><span class='Ref_to_Struct'>SpecialJoinInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2170"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN2184"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1920"><span class='Ref_to_Member'>jointype</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/nodes.h.html#LN692"><span class='Ref_to_EnumConst'>JOIN_ANTI</span></a> <span class='Operator'>&& 
</span>            <a href="../../../include/nodes/bitmapset.h.html#LN75"><span class='Ref_to_Proto'>bms_is_member</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2169"><span class='Ref_To_Local'>forced_null_rel</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN2184"><span class='Ref_To_Local'>sjinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1919"><span class='Ref_to_Member'>syn_righthand</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end check_redundant_nullability_qual &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * distribute_restrictinfo_to_rels 
 *    Push a completed RestrictInfo into the proper restriction or join 
 *    clause list(s). 
 * 
 * This is the last step of distribute_qual_to_rels() for ordinary qual 
 * clauses.  Clauses that are interesting for equivalence-class processing 
 * are diverted to the EC machinery, but may ultimately get fed back here. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN2204"></a><span class='Declare_Function'>distribute_restrictinfo_to_rels</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN2205"></a>                                <a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>restrictinfo</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2207"></a>    <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a>      <span class='Declare_Local'>relids</span> <span class='Operator'>= </span><a href="initsplan.c.html#LN2205"><span class='Ref_to_Parameter'>restrictinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1764"><span class='Ref_to_Member'>required_relids</span></a><span class='Delimiter'>; 
</span><a name="LN2208"></a>    <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rel</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>switch</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/bitmapset.h.html#LN84"><span class='Ref_to_Proto'>bms_membership</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2207"><span class='Ref_To_Local'>relids</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/bitmapset.h.html#LN56"><span class='Ref_to_EnumConst'>BMS_SINGLETON</span></a><span class='Operator'>: 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * There is only one relation participating in the clause, so it 
             * is a restriction clause for that relation. 
             */ 
</span>            <a href="initsplan.c.html#LN2208"><span class='Ref_To_Local'>rel</span></a> <span class='Operator'>= </span><a href="../util/relnode.c.html#LN241"><span class='Ref_to_Func'>find_base_rel</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2204"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/bitmapset.h.html#LN79"><span class='Ref_to_Proto'>bms_singleton_member</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2207"><span class='Ref_To_Local'>relids</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* Add clause to rel's restriction list */ 
</span>            <a href="initsplan.c.html#LN2208"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN583"><span class='Ref_to_Member'>baserestrictinfo</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2208"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN583"><span class='Ref_to_Member'>baserestrictinfo</span></a><span class='Delimiter'>, 
</span>                                            <a href="initsplan.c.html#LN2205"><span class='Ref_to_Parameter'>restrictinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* Update security level info */ 
</span>            <a href="initsplan.c.html#LN2208"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN586"><span class='Ref_to_Member'>baserestrict_min_security</span></a> <span class='Operator'>= </span><a href="../../../interfaces/ecpg/pgtypeslib/numeric.c.html#LN11"><span class='Ref_to_Macro'>Min</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2208"><span class='Ref_To_Local'>rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN586"><span class='Ref_to_Member'>baserestrict_min_security</span></a><span class='Delimiter'>, 
</span>                                               <a href="initsplan.c.html#LN2205"><span class='Ref_to_Parameter'>restrictinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1758"><span class='Ref_to_Member'>security_level</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>case</span> <a href="../../../include/nodes/bitmapset.h.html#LN57"><span class='Ref_to_EnumConst'>BMS_MULTIPLE</span></a><span class='Operator'>: 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * The clause is a join clause, since there is more than one rel 
             * in its relid set. 
             */ 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Check for hashjoinable operators.  (We don't bother setting the 
             * hashjoin info except in true join clauses.) 
             */ 
</span>            <a href="initsplan.c.html#LN77"><span class='Ref_to_Proto'>check_hashjoinable</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2205"><span class='Ref_to_Parameter'>restrictinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Add clause to the join lists of all the relevant relations. 
             */ 
</span>            <a href="../../../include/optimizer/joininfo.h.html#LN22"><span class='Ref_to_Proto'>add_join_clause_to_rels</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2204"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN2205"><span class='Ref_to_Parameter'>restrictinfo</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN2207"><span class='Ref_To_Local'>relids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>        <span class='Control'>default</span><span class='Operator'>: 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * clause references no rels, and therefore we have no place to 
             * attach it.  Shouldn't get here if callers are working properly. 
             */ 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"cannot cope with variable-free clause"</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>break</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end switch bms_membership(relids... &raquo; </span> 
<span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end distribute_restrictinfo_to_rels &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * process_implied_equality 
 *    Create a restrictinfo item that says "item1 op item2", and push it 
 *    into the appropriate lists.  (In practice opno is always a btree 
 *    equality operator.) 
 * 
 * "qualscope" is the nominal syntactic level to impute to the restrictinfo. 
 * This must contain at least all the rels used in the expressions, but it 
 * is used only to set the qual application level when both exprs are 
 * variable-free.  Otherwise the qual is applied at the lowest join level 
 * that provides all its variables. 
 * 
 * "nullable_relids" is the set of relids used in the expressions that are 
 * potentially nullable below the expressions.  (This has to be supplied by 
 * caller because this function is used after deconstruct_jointree, so we 
 * don't have knowledge of where the clause items came from.) 
 * 
 * "security_level" is the security level to assign to the new restrictinfo. 
 * 
 * "both_const" indicates whether both items are known pseudo-constant; 
 * in this case it is worth applying eval_const_expressions() in case we 
 * can produce constant TRUE or constant FALSE.  (Otherwise it's not, 
 * because the expressions went through eval_const_expressions already.) 
 * 
 * Note: this function will copy item1 and item2, but it is caller's 
 * responsibility to make sure that the Relids parameters are fresh copies 
 * not shared with other uses. 
 * 
 * This is currently used only when an EquivalenceClass is found to 
 * contain pseudoconstants.  See path/pathkeys.c for more details. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN2288"></a><span class='Declare_Function'>process_implied_equality</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, 
</span><a name="LN2289"></a>                         <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>opno</span><span class='Delimiter'>, 
</span><a name="LN2290"></a>                         <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>collation</span><span class='Delimiter'>, 
</span><a name="LN2291"></a>                         <a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>item1</span><span class='Delimiter'>, 
</span><a name="LN2292"></a>                         <a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>item2</span><span class='Delimiter'>, 
</span><a name="LN2293"></a>                         <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Declare_Parameter'>qualscope</span><span class='Delimiter'>, 
</span><a name="LN2294"></a>                         <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Declare_Parameter'>nullable_relids</span><span class='Delimiter'>, 
</span><a name="LN2295"></a>                         <a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a> <span class='Declare_Parameter'>security_level</span><span class='Delimiter'>, 
</span><a name="LN2296"></a>                         <span class='Keyword'>bool </span><span class='Declare_Parameter'>below_outer_join</span><span class='Delimiter'>, 
</span><a name="LN2297"></a>                         <span class='Keyword'>bool </span><span class='Declare_Parameter'>both_const</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2299"></a>    <a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>clause</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Build the new clause.  Copy to ensure it shares no substructure with 
     * original (this is necessary in case there are subselects in there...) 
     */ 
</span>    <a href="initsplan.c.html#LN2299"><span class='Ref_To_Local'>clause</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/clauses.h.html#LN29"><span class='Ref_to_Proto'>make_opclause</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2289"><span class='Ref_to_Parameter'>opno</span></a><span class='Delimiter'>, 
</span>                           <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN17"><span class='Ref_to_Const'>BOOLOID</span></a><span class='Delimiter'>,</span>     <span class='Comment_Single_Line'>/* opresulttype */ 
</span>                           <span class='Boolean'>false</span><span class='Delimiter'>,</span>       <span class='Comment_Single_Line'>/* opretset */ 
</span>                           <a href="../../../include/nodes/nodes.h.html#LN618"><span class='Ref_to_Macro'>copyObject</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2291"><span class='Ref_to_Parameter'>item1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                           <a href="../../../include/nodes/nodes.h.html#LN618"><span class='Ref_to_Macro'>copyObject</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2292"><span class='Ref_to_Parameter'>item2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                           <a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, 
</span>                           <a href="initsplan.c.html#LN2290"><span class='Ref_to_Parameter'>collation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* If both constant, try to reduce to a boolean constant. */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN2297"><span class='Ref_to_Parameter'>both_const</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span>        <a href="initsplan.c.html#LN2299"><span class='Ref_To_Local'>clause</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/optimizer/clauses.h.html#LN80"><span class='Ref_to_Proto'>eval_const_expressions</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2288"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN2299"><span class='Ref_To_Local'>clause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* If we produced const TRUE, just drop the clause */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN2299"><span class='Ref_To_Local'>clause</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2299"><span class='Ref_To_Local'>clause</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a><span class='Parentheses'>))</span> 
        <span class='Delimiter'>{ 
</span><a name="LN2321"></a>            <a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>cclause</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN188"><span class='Ref_to_Struct'>Const</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN2299"><span class='Ref_To_Local'>clause</span></a><span class='Delimiter'>; 
</span> 
            <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2321"><span class='Ref_To_Local'>cclause</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN191"><span class='Ref_to_Member'>consttype</span></a> <span class='Operator'>== </span><a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN17"><span class='Ref_to_Const'>BOOLOID</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="initsplan.c.html#LN2321"><span class='Ref_To_Local'>cclause</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN196"><span class='Ref_to_Member'>constisnull</span></a> <span class='Operator'>&& </span><a href="../../../include/postgres.h.html#LN398"><span class='Ref_to_Macro'>DatumGetBool</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2321"><span class='Ref_To_Local'>cclause</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN195"><span class='Ref_to_Member'>constvalue</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>return</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Push the new clause into all the appropriate restrictinfo lists. 
     */ 
</span>    <a href="initsplan.c.html#LN61"><span class='Ref_to_Proto'>distribute_qual_to_rels</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2288"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN2299"><span class='Ref_To_Local'>clause</span></a><span class='Delimiter'>, 
</span>                            <span class='Boolean'>true</span><span class='Delimiter'>, </span><a href="initsplan.c.html#LN2296"><span class='Ref_to_Parameter'>below_outer_join</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/nodes.h.html#LN677"><span class='Ref_to_EnumConst'>JOIN_INNER</span></a><span class='Delimiter'>, 
</span>                            <a href="initsplan.c.html#LN2295"><span class='Ref_to_Parameter'>security_level</span></a><span class='Delimiter'>, 
</span>                            <a href="initsplan.c.html#LN2293"><span class='Ref_to_Parameter'>qualscope</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Delimiter'>, </span><a href="initsplan.c.html#LN2294"><span class='Ref_to_Parameter'>nullable_relids</span></a><span class='Delimiter'>, 
</span>                            <span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end process_implied_equality &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * build_implied_join_equality --- build a RestrictInfo for a derived equality 
 * 
 * This overlaps the functionality of process_implied_equality(), but we 
 * must return the RestrictInfo, not push it into the joininfo tree. 
 * 
 * Note: this function will copy item1 and item2, but it is caller's 
 * responsibility to make sure that the Relids parameters are fresh copies 
 * not shared with other uses. 
 * 
 * Note: we do not do initialize_mergeclause_eclasses() here.  It is 
 * caller's responsibility that left_ec/right_ec be set as necessary. 
 */ 
</span><a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>* 
</span><a name="LN2353"></a><span class='Declare_Function'>build_implied_join_equality</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>opno</span><span class='Delimiter'>, 
</span><a name="LN2354"></a>                            <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>collation</span><span class='Delimiter'>, 
</span><a name="LN2355"></a>                            <a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>item1</span><span class='Delimiter'>, 
</span><a name="LN2356"></a>                            <a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>item2</span><span class='Delimiter'>, 
</span><a name="LN2357"></a>                            <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Declare_Parameter'>qualscope</span><span class='Delimiter'>, 
</span><a name="LN2358"></a>                            <a href="../../../include/nodes/relation.h.html#LN27"><span class='Ref_to_Typedef'>Relids</span></a> <span class='Declare_Parameter'>nullable_relids</span><span class='Delimiter'>, 
</span><a name="LN2359"></a>                            <a href="../../../include/c.h.html#LN364"><span class='Ref_to_Typedef'>Index</span></a> <span class='Declare_Parameter'>security_level</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2361"></a>    <a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>restrictinfo</span><span class='Delimiter'>; 
</span><a name="LN2362"></a>    <a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>clause</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Build the new clause.  Copy to ensure it shares no substructure with 
     * original (this is necessary in case there are subselects in there...) 
     */ 
</span>    <a href="initsplan.c.html#LN2362"><span class='Ref_To_Local'>clause</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/clauses.h.html#LN29"><span class='Ref_to_Proto'>make_opclause</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2353"><span class='Ref_to_Parameter'>opno</span></a><span class='Delimiter'>, 
</span>                           <a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN17"><span class='Ref_to_Const'>BOOLOID</span></a><span class='Delimiter'>,</span>     <span class='Comment_Single_Line'>/* opresulttype */ 
</span>                           <span class='Boolean'>false</span><span class='Delimiter'>,</span>       <span class='Comment_Single_Line'>/* opretset */ 
</span>                           <a href="../../../include/nodes/nodes.h.html#LN618"><span class='Ref_to_Macro'>copyObject</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2355"><span class='Ref_to_Parameter'>item1</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                           <a href="../../../include/nodes/nodes.h.html#LN618"><span class='Ref_to_Macro'>copyObject</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2356"><span class='Ref_to_Parameter'>item2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                           <a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, 
</span>                           <a href="initsplan.c.html#LN2354"><span class='Ref_to_Parameter'>collation</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Build the RestrictInfo node itself. 
     */ 
</span>    <a href="initsplan.c.html#LN2361"><span class='Ref_To_Local'>restrictinfo</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/restrictinfo.h.html#LN23"><span class='Ref_to_Proto'>make_restrictinfo</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2362"><span class='Ref_To_Local'>clause</span></a><span class='Delimiter'>, 
</span>                                     <span class='Boolean'>true</span><span class='Delimiter'>,</span>      <span class='Comment_Single_Line'>/* is_pushed_down */ 
</span>                                     <span class='Boolean'>false</span><span class='Delimiter'>,</span>     <span class='Comment_Single_Line'>/* outerjoin_delayed */ 
</span>                                     <span class='Boolean'>false</span><span class='Delimiter'>,</span>     <span class='Comment_Single_Line'>/* pseudoconstant */ 
</span>                                     <a href="initsplan.c.html#LN2359"><span class='Ref_to_Parameter'>security_level</span></a><span class='Delimiter'>,</span>    <span class='Comment_Single_Line'>/* security_level */ 
</span>                                     <a href="initsplan.c.html#LN2357"><span class='Ref_to_Parameter'>qualscope</span></a><span class='Delimiter'>, </span><span class='Comment_Single_Line'>/* required_relids */ 
</span>                                     <span class='Null_Value'>NULL</span><span class='Delimiter'>,</span>      <span class='Comment_Single_Line'>/* outer_relids */ 
</span>                                     <a href="initsplan.c.html#LN2358"><span class='Ref_to_Parameter'>nullable_relids</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>  <span class='Comment_Single_Line'>/* nullable_relids */ 
</span> 
    <span class='Comment_Multi_Line'>/* Set mergejoinability/hashjoinability flags */ 
</span>    <a href="initsplan.c.html#LN76"><span class='Ref_to_Proto'>check_mergejoinable</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2361"><span class='Ref_To_Local'>restrictinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="initsplan.c.html#LN77"><span class='Ref_to_Proto'>check_hashjoinable</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2361"><span class='Ref_To_Local'>restrictinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="initsplan.c.html#LN2361"><span class='Ref_To_Local'>restrictinfo</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end build_implied_join_equality &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/* 
 * match_foreign_keys_to_quals 
 *      Match foreign-key constraints to equivalence classes and join quals 
 * 
 * The idea here is to see which query join conditions match equality 
 * constraints of a foreign-key relationship.  For such join conditions, 
 * we can use the FK semantics to make selectivity estimates that are more 
 * reliable than estimating from statistics, especially for multiple-column 
 * FKs, where the normal assumption of independent conditions tends to fail. 
 * 
 * In this function we annotate the ForeignKeyOptInfos in root-&GT;fkey_list 
 * with info about which eclasses and join qual clauses they match, and 
 * discard any ForeignKeyOptInfos that are irrelevant for the query. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN2411"></a><span class='Declare_Function'>match_foreign_keys_to_quals</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2413"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>newlist</span> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span><a name="LN2414"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2414"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN2411"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN259"><span class='Ref_to_Member'>fkey_list</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN2418"></a>        <a href="../../../include/nodes/relation.h.html#LN687"><span class='Ref_to_Struct'>ForeignKeyOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>fkinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN687"><span class='Ref_to_Struct'>ForeignKeyOptInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2414"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2419"></a>        <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>con_rel</span><span class='Delimiter'>; 
</span><a name="LN2420"></a>        <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>ref_rel</span><span class='Delimiter'>; 
</span><a name="LN2421"></a>        <span class='Keyword'>int</span>         <span class='Declare_Local'>colno</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Either relid might identify a rel that is in the query's rtable but 
         * isn't referenced by the jointree so won't have a RelOptInfo.  Hence 
         * don't use find_base_rel() here.  We can ignore such FKs. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN2418"><span class='Ref_To_Local'>fkinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN692"><span class='Ref_to_Member'>con_relid</span></a> <span class='Operator'>&GT;= </span><a href="initsplan.c.html#LN2411"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN179"><span class='Ref_to_Member'>simple_rel_array_size</span></a> <span class='Operator'>|| 
</span>            <a href="initsplan.c.html#LN2418"><span class='Ref_To_Local'>fkinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN693"><span class='Ref_to_Member'>ref_relid</span></a> <span class='Operator'>&GT;= </span><a href="initsplan.c.html#LN2411"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN179"><span class='Ref_to_Member'>simple_rel_array_size</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>;</span>           <span class='Comment_Single_Line'>/* just paranoia */ 
</span>        <a href="initsplan.c.html#LN2419"><span class='Ref_To_Local'>con_rel</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN2411"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN178"><span class='Ref_to_Member'>simple_rel_array</span></a><span class='Delimiter'>[</span><a href="initsplan.c.html#LN2418"><span class='Ref_To_Local'>fkinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN692"><span class='Ref_to_Member'>con_relid</span></a><span class='Delimiter'>]; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN2419"><span class='Ref_To_Local'>con_rel</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <a href="initsplan.c.html#LN2420"><span class='Ref_To_Local'>ref_rel</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN2411"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN178"><span class='Ref_to_Member'>simple_rel_array</span></a><span class='Delimiter'>[</span><a href="initsplan.c.html#LN2418"><span class='Ref_To_Local'>fkinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN693"><span class='Ref_to_Member'>ref_relid</span></a><span class='Delimiter'>]; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN2420"><span class='Ref_To_Local'>ref_rel</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Ignore FK unless both rels are baserels.  This gets rid of FKs that 
         * link to inheritance child rels (otherrels) and those that link to 
         * rels removed by join removal (dead rels). 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN2419"><span class='Ref_To_Local'>con_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN521"><span class='Ref_to_Member'>reloptkind</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/relation.h.html#LN493"><span class='Ref_to_EnumConst'>RELOPT_BASEREL</span></a> <span class='Operator'>|| 
</span>            <a href="initsplan.c.html#LN2420"><span class='Ref_To_Local'>ref_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN521"><span class='Ref_to_Member'>reloptkind</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/relation.h.html#LN493"><span class='Ref_to_EnumConst'>RELOPT_BASEREL</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Scan the columns and try to match them to eclasses and quals. 
         * 
         * Note: for simple inner joins, any match should be in an eclass. 
         * "Loose" quals that syntactically match an FK equality must have 
         * been rejected for EC status because they are outer-join quals or 
         * similar.  We can still consider them to match the FK if they are 
         * not outerjoin_delayed. 
         */ 
</span>        <span class='Control'>for</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN2421"><span class='Ref_To_Local'>colno</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; </span><a href="initsplan.c.html#LN2421"><span class='Ref_To_Local'>colno</span></a> <span class='Operator'>&LT; </span><a href="initsplan.c.html#LN2418"><span class='Ref_To_Local'>fkinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN694"><span class='Ref_to_Member'>nkeys</span></a><span class='Delimiter'>; </span><a href="initsplan.c.html#LN2421"><span class='Ref_To_Local'>colno</span></a><span class='Operator'>++</span><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span><a name="LN2458"></a>            <a href="../../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a>  <span class='Declare_Local'>con_attno</span><span class='Delimiter'>, 
</span><a name="LN2459"></a>                        <span class='Declare_Local'>ref_attno</span><span class='Delimiter'>; 
</span><a name="LN2460"></a>            <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>fpeqop</span><span class='Delimiter'>; 
</span><a name="LN2461"></a>            <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc2</span><span class='Delimiter'>; 
</span> 
            <a href="initsplan.c.html#LN2418"><span class='Ref_To_Local'>fkinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN704"><span class='Ref_to_Member'>eclass</span></a><span class='Delimiter'>[</span><a href="initsplan.c.html#LN2421"><span class='Ref_To_Local'>colno</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../../include/optimizer/paths.h.html#LN149"><span class='Ref_to_Proto'>match_eclasses_to_foreign_key_col</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2411"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                                                      <a href="initsplan.c.html#LN2418"><span class='Ref_To_Local'>fkinfo</span></a><span class='Delimiter'>, 
</span>                                                                      <a href="initsplan.c.html#LN2421"><span class='Ref_To_Local'>colno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Comment_Multi_Line'>/* Don't bother looking for loose quals if we got an EC match */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN2418"><span class='Ref_To_Local'>fkinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN704"><span class='Ref_to_Member'>eclass</span></a><span class='Delimiter'>[</span><a href="initsplan.c.html#LN2421"><span class='Ref_To_Local'>colno</span></a><span class='Delimiter'>] </span><span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span>                <a href="initsplan.c.html#LN2418"><span class='Ref_To_Local'>fkinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN700"><span class='Ref_to_Member'>nmatched_ec</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>                <span class='Control'>continue</span><span class='Delimiter'>; 
</span>            <span class='Delimiter'>} 
</span> 
            <span class='Comment_Multi_Line'>/* 
             * Scan joininfo list for relevant clauses.  Either rel's joininfo 
             * list would do equally well; we use con_rel's. 
             */ 
</span>            <a href="initsplan.c.html#LN2458"><span class='Ref_To_Local'>con_attno</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN2418"><span class='Ref_To_Local'>fkinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN695"><span class='Ref_to_Member'>conkey</span></a><span class='Delimiter'>[</span><a href="initsplan.c.html#LN2421"><span class='Ref_To_Local'>colno</span></a><span class='Delimiter'>]; 
</span>            <a href="initsplan.c.html#LN2459"><span class='Ref_To_Local'>ref_attno</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN2418"><span class='Ref_To_Local'>fkinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN696"><span class='Ref_to_Member'>confkey</span></a><span class='Delimiter'>[</span><a href="initsplan.c.html#LN2421"><span class='Ref_To_Local'>colno</span></a><span class='Delimiter'>]; 
</span>            <a href="initsplan.c.html#LN2460"><span class='Ref_To_Local'>fpeqop</span></a> <span class='Operator'>= </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>;</span>    <span class='Comment_Single_Line'>/* we'll look this up only if needed */ 
</span> 
            <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2461"><span class='Ref_To_Local'>lc2</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN2419"><span class='Ref_To_Local'>con_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN588"><span class='Ref_to_Member'>joininfo</span></a><span class='Parentheses'>) 
</span>            <span class='Delimiter'>{ 
</span><a name="LN2483"></a>                <a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rinfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2461"><span class='Ref_To_Local'>lc2</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN2484"></a>                <a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>clause</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN2483"><span class='Ref_To_Local'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1746"><span class='Ref_to_Member'>clause</span></a><span class='Delimiter'>; 
</span><a name="LN2485"></a>                <a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>leftvar</span><span class='Delimiter'>; 
</span><a name="LN2486"></a>                <a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a>        <span class='Operator'>*</span><span class='Declare_Local'>rightvar</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* Ignore outerjoin-delayed clauses */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN2483"><span class='Ref_To_Local'>rinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1750"><span class='Ref_to_Member'>outerjoin_delayed</span></a><span class='Parentheses'>) 
</span>                    <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* Only binary OpExprs are useful for consideration */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2484"><span class='Ref_To_Local'>clause</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a><span class='Parentheses'>) </span><span class='Operator'>|| 
</span>                    <a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2484"><span class='Ref_To_Local'>clause</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN500"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>2</span><span class='Parentheses'>)</span> 
                    <span class='Control'>continue</span><span class='Delimiter'>; 
</span>                <a href="initsplan.c.html#LN2485"><span class='Ref_To_Local'>leftvar</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/optimizer/clauses.h.html#LN32"><span class='Ref_to_Proto'>get_leftop</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN2484"><span class='Ref_To_Local'>clause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                <a href="initsplan.c.html#LN2486"><span class='Ref_To_Local'>rightvar</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/optimizer/clauses.h.html#LN33"><span class='Ref_to_Proto'>get_rightop</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN2484"><span class='Ref_To_Local'>clause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* Operands must be Vars, possibly with RelabelType */ 
</span>                <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN2485"><span class='Ref_To_Local'>leftvar</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2485"><span class='Ref_To_Local'>leftvar</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a><span class='Parentheses'>))</span> 
                    <a href="initsplan.c.html#LN2485"><span class='Ref_To_Local'>leftvar</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) ((</span><a href="../../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN2485"><span class='Ref_To_Local'>leftvar</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>arg<span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2485"><span class='Ref_To_Local'>leftvar</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2485"><span class='Ref_To_Local'>leftvar</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a><span class='Parentheses'>)))</span> 
                    <span class='Control'>continue</span><span class='Delimiter'>; 
</span>                <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN2486"><span class='Ref_To_Local'>rightvar</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2486"><span class='Ref_To_Local'>rightvar</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a><span class='Parentheses'>))</span> 
                    <a href="initsplan.c.html#LN2486"><span class='Ref_To_Local'>rightvar</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a> <span class='Operator'>*</span><span class='Parentheses'>) ((</span><a href="../../../include/nodes/primnodes.h.html#LN786"><span class='Ref_to_Struct'>RelabelType</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN2486"><span class='Ref_To_Local'>rightvar</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>arg<span class='Delimiter'>; 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2486"><span class='Ref_To_Local'>rightvar</span></a> <span class='Operator'>&& </span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2486"><span class='Ref_To_Local'>rightvar</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN162"><span class='Ref_to_Struct'>Var</span></a><span class='Parentheses'>)))</span> 
                    <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
                <span class='Comment_Multi_Line'>/* Now try to match the vars to the current foreign key cols */ 
</span>                <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN2418"><span class='Ref_To_Local'>fkinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN693"><span class='Ref_to_Member'>ref_relid</span></a> <span class='Operator'>== </span><a href="initsplan.c.html#LN2485"><span class='Ref_To_Local'>leftvar</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN165"><span class='Ref_to_Member'>varno</span></a> <span class='Operator'>&& 
</span>                    <a href="initsplan.c.html#LN2459"><span class='Ref_To_Local'>ref_attno</span></a> <span class='Operator'>== </span><a href="initsplan.c.html#LN2485"><span class='Ref_To_Local'>leftvar</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN167"><span class='Ref_to_Member'>varattno</span></a> <span class='Operator'>&& 
</span>                    <a href="initsplan.c.html#LN2418"><span class='Ref_To_Local'>fkinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN692"><span class='Ref_to_Member'>con_relid</span></a> <span class='Operator'>== </span><a href="initsplan.c.html#LN2486"><span class='Ref_To_Local'>rightvar</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN165"><span class='Ref_to_Member'>varno</span></a> <span class='Operator'>&& 
</span>                    <a href="initsplan.c.html#LN2458"><span class='Ref_To_Local'>con_attno</span></a> <span class='Operator'>== </span><a href="initsplan.c.html#LN2486"><span class='Ref_To_Local'>rightvar</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN167"><span class='Ref_to_Member'>varattno</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* Vars match, but is it the right operator? */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN2484"><span class='Ref_To_Local'>clause</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN494"><span class='Ref_to_Member'>opno</span></a> <span class='Operator'>== </span><a href="initsplan.c.html#LN2418"><span class='Ref_To_Local'>fkinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN697"><span class='Ref_to_Member'>conpfeqop</span></a><span class='Delimiter'>[</span><a href="initsplan.c.html#LN2421"><span class='Ref_To_Local'>colno</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <a href="initsplan.c.html#LN2418"><span class='Ref_To_Local'>fkinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN706"><span class='Ref_to_Member'>rinfos</span></a><span class='Delimiter'>[</span><a href="initsplan.c.html#LN2421"><span class='Ref_To_Local'>colno</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2418"><span class='Ref_To_Local'>fkinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN706"><span class='Ref_to_Member'>rinfos</span></a><span class='Delimiter'>[</span><a href="initsplan.c.html#LN2421"><span class='Ref_To_Local'>colno</span></a><span class='Delimiter'>], 
</span>                                                        <a href="initsplan.c.html#LN2483"><span class='Ref_To_Local'>rinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                        <a href="initsplan.c.html#LN2418"><span class='Ref_To_Local'>fkinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN702"><span class='Ref_to_Member'>nmatched_ri</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                <span class='Delimiter'>} 
</span>                <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN2418"><span class='Ref_To_Local'>fkinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN693"><span class='Ref_to_Member'>ref_relid</span></a> <span class='Operator'>== </span><a href="initsplan.c.html#LN2486"><span class='Ref_To_Local'>rightvar</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN165"><span class='Ref_to_Member'>varno</span></a> <span class='Operator'>&& 
</span>                         <a href="initsplan.c.html#LN2459"><span class='Ref_To_Local'>ref_attno</span></a> <span class='Operator'>== </span><a href="initsplan.c.html#LN2486"><span class='Ref_To_Local'>rightvar</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN167"><span class='Ref_to_Member'>varattno</span></a> <span class='Operator'>&& 
</span>                         <a href="initsplan.c.html#LN2418"><span class='Ref_To_Local'>fkinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN692"><span class='Ref_to_Member'>con_relid</span></a> <span class='Operator'>== </span><a href="initsplan.c.html#LN2485"><span class='Ref_To_Local'>leftvar</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN165"><span class='Ref_to_Member'>varno</span></a> <span class='Operator'>&& 
</span>                         <a href="initsplan.c.html#LN2458"><span class='Ref_To_Local'>con_attno</span></a> <span class='Operator'>== </span><a href="initsplan.c.html#LN2485"><span class='Ref_To_Local'>leftvar</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN167"><span class='Ref_to_Member'>varattno</span></a><span class='Parentheses'>) 
</span>                <span class='Delimiter'>{ 
</span>                    <span class='Comment_Multi_Line'>/* 
                     * Reverse match, must check commutator operator.  Look it 
                     * up if we didn't already.  (In the worst case we might 
                     * do multiple lookups here, but that would require an FK 
                     * equality operator without commutator, which is 
                     * unlikely.) 
                     */ 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2460"><span class='Ref_To_Local'>fpeqop</span></a><span class='Parentheses'>))</span> 
                        <a href="initsplan.c.html#LN2460"><span class='Ref_To_Local'>fpeqop</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN106"><span class='Ref_to_Proto'>get_commutator</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2418"><span class='Ref_To_Local'>fkinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN697"><span class='Ref_to_Member'>conpfeqop</span></a><span class='Delimiter'>[</span><a href="initsplan.c.html#LN2421"><span class='Ref_To_Local'>colno</span></a><span class='Delimiter'>]</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN2484"><span class='Ref_To_Local'>clause</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN494"><span class='Ref_to_Member'>opno</span></a> <span class='Operator'>== </span><a href="initsplan.c.html#LN2460"><span class='Ref_To_Local'>fpeqop</span></a><span class='Parentheses'>) 
</span>                    <span class='Delimiter'>{ 
</span>                        <a href="initsplan.c.html#LN2418"><span class='Ref_To_Local'>fkinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN706"><span class='Ref_to_Member'>rinfos</span></a><span class='Delimiter'>[</span><a href="initsplan.c.html#LN2421"><span class='Ref_To_Local'>colno</span></a><span class='Delimiter'>] </span><span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2418"><span class='Ref_To_Local'>fkinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN706"><span class='Ref_to_Member'>rinfos</span></a><span class='Delimiter'>[</span><a href="initsplan.c.html#LN2421"><span class='Ref_To_Local'>colno</span></a><span class='Delimiter'>], 
</span>                                                        <a href="initsplan.c.html#LN2483"><span class='Ref_To_Local'>rinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>                        <a href="initsplan.c.html#LN2418"><span class='Ref_To_Local'>fkinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN702"><span class='Ref_to_Member'>nmatched_ri</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>                    <span class='Delimiter'>} 
</span>                <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if fkinfo-&GT;ref_relid==ri... &raquo; </span> 
            <span class='Delimiter'>} 
</span>            <span class='Comment_Multi_Line'>/* If we found any matching loose quals, count col as matched */ 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN2418"><span class='Ref_To_Local'>fkinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN706"><span class='Ref_to_Member'>rinfos</span></a><span class='Delimiter'>[</span><a href="initsplan.c.html#LN2421"><span class='Ref_To_Local'>colno</span></a><span class='Delimiter'>]</span><span class='Parentheses'>) 
</span>                <a href="initsplan.c.html#LN2418"><span class='Ref_To_Local'>fkinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN701"><span class='Ref_to_Member'>nmatched_rcols</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end for colno=0;colno&LT;fkinfo-... &raquo; </span> 
 
        <span class='Comment_Multi_Line'>/* 
         * Currently, we drop multicolumn FKs that aren't fully matched to the 
         * query.  Later we might figure out how to derive some sort of 
         * estimate from them, in which case this test should be weakened to 
         * "if ((fkinfo-&GT;nmatched_ec + fkinfo-&GT;nmatched_rcols) &GT; 0)". 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>((</span><a href="initsplan.c.html#LN2418"><span class='Ref_To_Local'>fkinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN700"><span class='Ref_to_Member'>nmatched_ec</span></a> <span class='Operator'>+ </span><a href="initsplan.c.html#LN2418"><span class='Ref_To_Local'>fkinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN701"><span class='Ref_to_Member'>nmatched_rcols</span></a><span class='Parentheses'>) </span><span class='Operator'>== </span><a href="initsplan.c.html#LN2418"><span class='Ref_To_Local'>fkinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN694"><span class='Ref_to_Member'>nkeys</span></a><span class='Parentheses'>)</span> 
            <a href="initsplan.c.html#LN2413"><span class='Ref_To_Local'>newlist</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2413"><span class='Ref_To_Local'>newlist</span></a><span class='Delimiter'>, </span><a href="initsplan.c.html#LN2418"><span class='Ref_To_Local'>fkinfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Comment_Multi_Line'>/* Replace fkey_list, thereby discarding any useless entries */ 
</span>    <a href="initsplan.c.html#LN2411"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN259"><span class='Ref_to_Member'>fkey_list</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN2413"><span class='Ref_To_Local'>newlist</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end match_foreign_keys_to_quals &raquo; </span> 
 
 
<span class='Comment_Multi_Line'>/***************************************************************************** 
 * 
 *   CHECKS FOR MERGEJOINABLE AND HASHJOINABLE CLAUSES 
 * 
 *****************************************************************************/ 
</span> 
<span class='Comment_Multi_Line'>/* 
 * check_mergejoinable 
 *    If the restrictinfo's clause is mergejoinable, set the mergejoin 
 *    info fields in the restrictinfo. 
 * 
 *    Currently, we support mergejoin for binary opclauses where 
 *    the operator is a mergejoinable operator.  The arguments can be 
 *    anything --- as long as there are no volatile functions in them. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2580"></a><span class='Declare_Function'>check_mergejoinable</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>restrictinfo</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2582"></a>    <a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>clause</span> <span class='Operator'>= </span><a href="initsplan.c.html#LN2580"><span class='Ref_to_Parameter'>restrictinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1746"><span class='Ref_to_Member'>clause</span></a><span class='Delimiter'>; 
</span><a name="LN2583"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>opno</span><span class='Delimiter'>; 
</span><a name="LN2584"></a>    <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>leftarg</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN2580"><span class='Ref_to_Parameter'>restrictinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1754"><span class='Ref_to_Member'>pseudoconstant</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/optimizer/clauses.h.html#LN19"><span class='Ref_to_Macro'>is_opclause</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2582"><span class='Ref_To_Local'>clause</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN2582"><span class='Ref_To_Local'>clause</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>args<span class='Parentheses'>)</span> <span class='Operator'>!= </span><span class='Number'>2</span><span class='Parentheses'>)</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <a href="initsplan.c.html#LN2583"><span class='Ref_To_Local'>opno</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN2582"><span class='Ref_To_Local'>clause</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>opno<span class='Delimiter'>; 
</span>    <a href="initsplan.c.html#LN2584"><span class='Ref_To_Local'>leftarg</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN2582"><span class='Ref_To_Local'>clause</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>args<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/lsyscache.h.html#LN102"><span class='Ref_to_Proto'>op_mergejoinable</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2583"><span class='Ref_To_Local'>opno</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2584"><span class='Ref_To_Local'>leftarg</span></a><span class='Parentheses'>))</span> <span class='Operator'>&& 
</span>        <span class='Operator'>!</span><a href="../../../include/optimizer/clauses.h.html#LN60"><span class='Ref_to_Proto'>contain_volatile_functions</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN2582"><span class='Ref_To_Local'>clause</span></a><span class='Parentheses'>))</span> 
        <a href="initsplan.c.html#LN2580"><span class='Ref_to_Parameter'>restrictinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1791"><span class='Ref_to_Member'>mergeopfamilies</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN76"><span class='Ref_to_Proto'>get_mergejoin_opfamilies</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2583"><span class='Ref_To_Local'>opno</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Note: op_mergejoinable is just a hint; if we fail to find the operator 
     * in any btree opfamilies, mergeopfamilies remains NIL and so the clause 
     * is not treated as mergejoinable. 
     */ 
</span><span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end check_mergejoinable &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * check_hashjoinable 
 *    If the restrictinfo's clause is hashjoinable, set the hashjoin 
 *    info fields in the restrictinfo. 
 * 
 *    Currently, we support hashjoin for binary opclauses where 
 *    the operator is a hashjoinable operator.  The arguments can be 
 *    anything --- as long as there are no volatile functions in them. 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN2617"></a><span class='Declare_Function'>check_hashjoinable</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN1742"><span class='Ref_to_Struct'>RestrictInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>restrictinfo</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN2619"></a>    <a href="../../../include/nodes/primnodes.h.html#LN131"><span class='Ref_to_Struct'>Expr</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>clause</span> <span class='Operator'>= </span><a href="initsplan.c.html#LN2617"><span class='Ref_to_Parameter'>restrictinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1746"><span class='Ref_to_Member'>clause</span></a><span class='Delimiter'>; 
</span><a name="LN2620"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>opno</span><span class='Delimiter'>; 
</span><a name="LN2621"></a>    <a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>leftarg</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="initsplan.c.html#LN2617"><span class='Ref_to_Parameter'>restrictinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1754"><span class='Ref_to_Member'>pseudoconstant</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/optimizer/clauses.h.html#LN19"><span class='Ref_to_Macro'>is_opclause</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2619"><span class='Ref_To_Local'>clause</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN2619"><span class='Ref_To_Local'>clause</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>args<span class='Parentheses'>)</span> <span class='Operator'>!= </span><span class='Number'>2</span><span class='Parentheses'>)</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <a href="initsplan.c.html#LN2620"><span class='Ref_To_Local'>opno</span></a> <span class='Operator'>= </span><span class='Parentheses'>((</span><a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN2619"><span class='Ref_To_Local'>clause</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>opno<span class='Delimiter'>; 
</span>    <a href="initsplan.c.html#LN2621"><span class='Ref_To_Local'>leftarg</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(((</span><a href="../../../include/nodes/primnodes.h.html#LN491"><span class='Ref_to_Struct'>OpExpr</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN2619"><span class='Ref_To_Local'>clause</span></a><span class='Parentheses'>)</span><span class='Operator'>-&GT;</span>args<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/lsyscache.h.html#LN103"><span class='Ref_to_Proto'>op_hashjoinable</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2620"><span class='Ref_To_Local'>opno</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>(</span><a href="initsplan.c.html#LN2621"><span class='Ref_To_Local'>leftarg</span></a><span class='Parentheses'>))</span> <span class='Operator'>&& 
</span>        <span class='Operator'>!</span><a href="../../../include/optimizer/clauses.h.html#LN60"><span class='Ref_to_Proto'>contain_volatile_functions</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="initsplan.c.html#LN2619"><span class='Ref_To_Local'>clause</span></a><span class='Parentheses'>))</span> 
        <a href="initsplan.c.html#LN2617"><span class='Ref_to_Parameter'>restrictinfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN1804"><span class='Ref_to_Member'>hashjoinoperator</span></a> <span class='Operator'>= </span><a href="initsplan.c.html#LN2620"><span class='Ref_To_Local'>opno</span></a><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end check_hashjoinable &raquo; </span> 
</pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>