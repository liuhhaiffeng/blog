<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="Source Insight Version 4.00.0084 Built on 2017-02-26">
<meta charset='UTF-8' />
<style type='text/css'><!--
TD {background-color: #C0C0C0; font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.blurb {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 70%; }
.filename {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 120%; font-weight: bold; }
.dirname {font-family: 'Verdana', 'Arial', 'Helvetica', Sans-Serif; font-size: 100%; font-weight: bold; margin-top: 2.5em;}
--></style>
<title>src\backend\optimizer\plan\planagg.c</title>
<LINK REL=StyleSheet HREF="../../../../C_Cpp_Source_File.css" TYPE='text/css' MEDIA=screen>
</head>
<body bgcolor=#ffffff>
<table bgcolor='#c0c0c0' width='100%'>
<tr><td><p class='filename'><b>src\backend\optimizer\plan\planagg.c</b></p></td>
<td align='right'>
Wed Jun 14 08:25:42 2017
</td></tr>
<tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table>
<pre>
<span class='Comment_Multi_Line'>/*------------------------------------------------------------------------- 
 * 
 * planagg.c 
 *    Special planning for aggregate queries. 
 * 
 * This module tries to replace MIN/MAX aggregate functions by subqueries 
 * of the form 
 *      (SELECT col FROM tab 
 *       WHERE col IS NOT NULL AND existing-quals 
 *       ORDER BY col ASC/DESC 
 *       LIMIT 1) 
 * Given a suitable index on tab.col, this can be much faster than the 
 * generic scan-all-the-rows aggregation plan.  We can handle multiple 
 * MIN/MAX aggregates by generating multiple subqueries, and their 
 * orderings can be different.  However, if the query contains any 
 * non-optimizable aggregates, there's no point since we'll have to 
 * scan all the rows anyway. 
 * 
 * 
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group 
 * Portions Copyright (c) 1994, Regents of the University of California 
 * 
 * 
 * IDENTIFICATION 
 *    src/backend/optimizer/plan/planagg.c 
 * 
 *------------------------------------------------------------------------- 
 */ 
</span><span class='Keyword'>#include </span><span class='String'>"postgres.h"</span> 
 
<span class='Keyword'>#include </span><span class='String'>"access/htup_details.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_aggregate.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"catalog/pg_type.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/makefuncs.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"nodes/nodeFuncs.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/clauses.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/cost.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/pathnode.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/paths.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/planmain.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/subselect.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"optimizer/tlist.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parsetree.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"parser/parse_clause.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"rewrite/rewriteManip.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/lsyscache.h"</span> 
<span class='Keyword'>#include </span><span class='String'>"utils/syscache.h"</span> 
 
 
<a name="LN49"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>find_minmax_aggs_walker</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN50"></a><span class='Keyword'>static bool </span><span class='Declare_Prototype'>build_minmax_path</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN2074"><span class='Ref_to_Struct'>MinMaxAggInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>mminfo</span><span class='Delimiter'>, 
</span><a name="LN51"></a>                  <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>eqop</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>sortop</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>nulls_first</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN52"></a><span class='Keyword'>static void </span><span class='Declare_Prototype'>minmax_qp_callback</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>extra</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN53"></a><span class='Keyword'>static </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>  <span class='Declare_Prototype'>fetch_agg_sort_op</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>aggfnoid</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
 
<span class='Comment_Multi_Line'>/* 
 * preprocess_minmax_aggregates - preprocess MIN/MAX aggregates 
 * 
 * Check to see whether the query contains MIN/MAX aggregate functions that 
 * might be optimizable via indexscans.  If it does, and all the aggregates 
 * are potentially optimizable, then create a MinMaxAggPath and add it to 
 * the (UPPERREL_GROUP_AGG, NULL) upperrel. 
 * 
 * This should be called by grouping_planner() just before it's ready to call 
 * query_planner(), because we generate indexscan paths by cloning the 
 * planner's state and invoking query_planner() on a modified version of 
 * the query parsetree.  Thus, all preprocessing needed before query_planner() 
 * must already be done. 
 * 
 * Note: we are passed the preprocessed targetlist separately, because it's 
 * not necessarily equal to root-&GT;parse-&GT;targetList. 
 */ 
</span><span class='Keyword'>void 
</span><a name="LN74"></a><span class='Declare_Function'>preprocess_minmax_aggregates</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>tlist</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN76"></a>    <a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>parse</span> <span class='Operator'>= </span><a href="planagg.c.html#LN74"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Delimiter'>; 
</span><a name="LN77"></a>    <a href="../../../include/nodes/primnodes.h.html#LN1466"><span class='Ref_to_Struct'>FromExpr</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>jtnode</span><span class='Delimiter'>; 
</span><a name="LN78"></a>    <a href="../../../include/nodes/primnodes.h.html#LN1415"><span class='Ref_to_Struct'>RangeTblRef</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rtr</span><span class='Delimiter'>; 
</span><a name="LN79"></a>    <a href="../../../include/nodes/parsenodes.h.html#LN932"><span class='Ref_to_Struct'>RangeTblEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>rte</span><span class='Delimiter'>; 
</span><a name="LN80"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>aggs_list</span><span class='Delimiter'>; 
</span><a name="LN81"></a>    <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>grouped_rel</span><span class='Delimiter'>; 
</span><a name="LN82"></a>    <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>lc</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* minmax_aggs list should be empty at this point */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="planagg.c.html#LN74"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN284"><span class='Ref_to_Member'>minmax_aggs</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Nothing to do if query has no aggregates */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="planagg.c.html#LN76"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN122"><span class='Ref_to_Member'>hasAggs</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="planagg.c.html#LN76"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN162"><span class='Ref_to_Member'>setOperations</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>      <span class='Comment_Single_Line'>/* shouldn't get here if a setop */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="planagg.c.html#LN76"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN160"><span class='Ref_to_Member'>rowMarks</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>;</span>     <span class='Comment_Single_Line'>/* nor if FOR UPDATE */ 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Reject unoptimizable cases. 
     * 
     * We don't handle GROUP BY or windowing, because our current 
     * implementations of grouping require looking at all the rows anyway, and 
     * so there's not much point in optimizing MIN/MAX. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planagg.c.html#LN76"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN145"><span class='Ref_to_Member'>groupClause</span></a> <span class='Operator'>|| </span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN76"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN147"><span class='Ref_to_Member'>groupingSets</span></a><span class='Parentheses'>) </span><span class='Operator'>&GT; </span><span class='Number'>1</span> <span class='Operator'>|| 
</span>        <a href="planagg.c.html#LN76"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN123"><span class='Ref_to_Member'>hasWindowFuncs</span></a><span class='Parentheses'>)</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Reject if query contains any CTEs; there's no way to build an indexscan 
     * on one so we couldn't succeed here.  (If the CTEs are unreferenced, 
     * that's not true, but it doesn't seem worth expending cycles to check.) 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planagg.c.html#LN76"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN132"><span class='Ref_to_Member'>cteList</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We also restrict the query to reference exactly one table, since join 
     * conditions can't be handled reasonably.  (We could perhaps handle a 
     * query containing cartesian-product joins, but it hardly seems worth the 
     * trouble.)  However, the single table could be buried in several levels 
     * of FromExpr due to subqueries.  Note the "single" table could be an 
     * inheritance parent, too, including the case of a UNION ALL subquery 
     * that's been flattened to an appendrel. 
     */ 
</span>    <a href="planagg.c.html#LN77"><span class='Ref_To_Local'>jtnode</span></a> <span class='Operator'>= </span><a href="planagg.c.html#LN76"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN135"><span class='Ref_to_Member'>jointree</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>while</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN77"><span class='Ref_To_Local'>jtnode</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN1466"><span class='Ref_to_Struct'>FromExpr</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN77"><span class='Ref_To_Local'>jtnode</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1469"><span class='Ref_to_Member'>fromlist</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
            <span class='Control'>return</span><span class='Delimiter'>; 
</span>        <a href="planagg.c.html#LN77"><span class='Ref_To_Local'>jtnode</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN77"><span class='Ref_To_Local'>jtnode</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1469"><span class='Ref_to_Member'>fromlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN77"><span class='Ref_To_Local'>jtnode</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN1415"><span class='Ref_to_Struct'>RangeTblRef</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <a href="planagg.c.html#LN78"><span class='Ref_To_Local'>rtr</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1415"><span class='Ref_to_Struct'>RangeTblRef</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planagg.c.html#LN77"><span class='Ref_To_Local'>jtnode</span></a><span class='Delimiter'>; 
</span>    <a href="planagg.c.html#LN79"><span class='Ref_To_Local'>rte</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/relation.h.html#LN324"><span class='Ref_to_Macro'>planner_rt_fetch</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN78"><span class='Ref_To_Local'>rtr</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1418"><span class='Ref_to_Member'>rtindex</span></a><span class='Delimiter'>, </span><a href="planagg.c.html#LN74"><span class='Ref_to_Parameter'>root</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planagg.c.html#LN79"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN936"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/parsenodes.h.html#LN922"><span class='Ref_to_EnumConst'>RTE_RELATION</span></a><span class='Parentheses'>) 
</span>         <span class='Comment_Multi_Line'>/* ordinary relation, ok */ </span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planagg.c.html#LN79"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN936"><span class='Ref_to_Member'>rtekind</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/parsenodes.h.html#LN923"><span class='Ref_to_EnumConst'>RTE_SUBQUERY</span></a> <span class='Operator'>&& </span><a href="planagg.c.html#LN79"><span class='Ref_To_Local'>rte</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1025"><span class='Ref_to_Member'>inh</span></a><span class='Parentheses'>) 
</span>         <span class='Comment_Multi_Line'>/* flattened UNION ALL subquery, ok */ </span><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Scan the tlist and HAVING qual to find all the aggregates and verify 
     * all are MIN/MAX aggregates.  Stop as soon as we find one that isn't. 
     */ 
</span>    <a href="planagg.c.html#LN80"><span class='Ref_To_Local'>aggs_list</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planagg.c.html#LN49"><span class='Ref_to_Proto'>find_minmax_aggs_walker</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planagg.c.html#LN74"><span class='Ref_to_Parameter'>tlist</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="planagg.c.html#LN80"><span class='Ref_To_Local'>aggs_list</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planagg.c.html#LN49"><span class='Ref_to_Proto'>find_minmax_aggs_walker</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN76"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN149"><span class='Ref_to_Member'>havingQual</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="planagg.c.html#LN80"><span class='Ref_To_Local'>aggs_list</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * OK, there is at least the possibility of performing the optimization. 
     * Build an access path for each aggregate.  If any of the aggregates 
     * prove to be non-indexable, give up; there is no point in optimizing 
     * just some of them. 
     */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN82"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="planagg.c.html#LN80"><span class='Ref_To_Local'>aggs_list</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN158"></a>        <a href="../../../include/nodes/relation.h.html#LN2074"><span class='Ref_to_Struct'>MinMaxAggInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>mminfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN2074"><span class='Ref_to_Struct'>MinMaxAggInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN82"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span><a name="LN159"></a>        <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>eqop</span><span class='Delimiter'>; 
</span><a name="LN160"></a>        <span class='Keyword'>bool</span>        <span class='Declare_Local'>reverse</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We'll need the equality operator that goes with the aggregate's 
         * ordering operator. 
         */ 
</span>        <a href="planagg.c.html#LN159"><span class='Ref_To_Local'>eqop</span></a> <span class='Operator'>= </span><a href="../../../include/utils/lsyscache.h.html#LN74"><span class='Ref_to_Proto'>get_equality_op_for_ordering_op</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN158"><span class='Ref_To_Local'>mminfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2079"><span class='Ref_to_Member'>aggsortop</span></a><span class='Delimiter'>, </span><span class='Operator'>&</span><a href="planagg.c.html#LN160"><span class='Ref_To_Local'>reverse</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN159"><span class='Ref_To_Local'>eqop</span></a><span class='Parentheses'>))</span>  <span class='Comment_Single_Line'>/* shouldn't happen */ 
</span>            <a href="../../bootstrap/bootscanner.l.html#LN129"><span class='Ref_to_Proto'>elog</span></a><span class='Parentheses'>(</span><a href="../../../include/port/win32/sys/socket.h.html#LN22"><span class='Ref_to_Const'>ERROR</span></a><span class='Delimiter'>, </span><span class='String'>"could not find equality operator for ordering operator %u"</span><span class='Delimiter'>, 
</span>                 <a href="planagg.c.html#LN158"><span class='Ref_To_Local'>mminfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2079"><span class='Ref_to_Member'>aggsortop</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We can use either an ordering that gives NULLS FIRST or one that 
         * gives NULLS LAST; furthermore there's unlikely to be much 
         * performance difference between them, so it doesn't seem worth 
         * costing out both ways if we get a hit on the first one.  NULLS 
         * FIRST is more likely to be available if the operator is a 
         * reverse-sort operator, so try that first if reverse. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planagg.c.html#LN50"><span class='Ref_to_Proto'>build_minmax_path</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN74"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planagg.c.html#LN158"><span class='Ref_To_Local'>mminfo</span></a><span class='Delimiter'>, </span><a href="planagg.c.html#LN159"><span class='Ref_To_Local'>eqop</span></a><span class='Delimiter'>, </span><a href="planagg.c.html#LN158"><span class='Ref_To_Local'>mminfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2079"><span class='Ref_to_Member'>aggsortop</span></a><span class='Delimiter'>, </span><a href="planagg.c.html#LN160"><span class='Ref_To_Local'>reverse</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planagg.c.html#LN50"><span class='Ref_to_Proto'>build_minmax_path</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN74"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planagg.c.html#LN158"><span class='Ref_To_Local'>mminfo</span></a><span class='Delimiter'>, </span><a href="planagg.c.html#LN159"><span class='Ref_To_Local'>eqop</span></a><span class='Delimiter'>, </span><a href="planagg.c.html#LN158"><span class='Ref_To_Local'>mminfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2079"><span class='Ref_to_Member'>aggsortop</span></a><span class='Delimiter'>, </span><span class='Operator'>!</span><a href="planagg.c.html#LN160"><span class='Ref_To_Local'>reverse</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>continue</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* No indexable path for this aggregate, so fail */ 
</span>        <span class='Control'>return</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * OK, we can do the query this way.  Prepare to create a MinMaxAggPath 
     * node. 
     * 
     * First, create an output Param node for each agg.  (If we end up not 
     * using the MinMaxAggPath, we'll waste a PARAM_EXEC slot for each agg, 
     * which is not worth worrying about.  We can't wait till create_plan time 
     * to decide whether to make the Param, unfortunately.) 
     */ 
</span>    <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN82"><span class='Ref_To_Local'>lc</span></a><span class='Delimiter'>, </span><a href="planagg.c.html#LN80"><span class='Ref_To_Local'>aggs_list</span></a><span class='Parentheses'>) 
</span>    <span class='Delimiter'>{ 
</span><a name="LN199"></a>        <a href="../../../include/nodes/relation.h.html#LN2074"><span class='Ref_to_Struct'>MinMaxAggInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>mminfo</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN2074"><span class='Ref_to_Struct'>MinMaxAggInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN82"><span class='Ref_To_Local'>lc</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <a href="planagg.c.html#LN199"><span class='Ref_To_Local'>mminfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2084"><span class='Ref_to_Member'>param</span></a> <span class='Operator'>= 
</span>            <a href="../../../include/optimizer/subselect.h.html#LN31"><span class='Ref_to_Proto'>SS_make_initplan_output_param</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN74"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                          <a href="../../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planagg.c.html#LN199"><span class='Ref_To_Local'>mminfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2080"><span class='Ref_to_Member'>target</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                          <span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, 
</span>                                     <a href="../../../include/nodes/nodeFuncs.h.html#LN38"><span class='Ref_to_Proto'>exprCollation</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planagg.c.html#LN199"><span class='Ref_To_Local'>mminfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2080"><span class='Ref_to_Member'>target</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>} 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Create a MinMaxAggPath node with the appropriate estimated costs and 
     * other needed data, and add it to the UPPERREL_GROUP_AGG upperrel, where 
     * it will compete against the standard aggregate implementation.  (It 
     * will likely always win, but we need not assume that here.) 
     * 
     * Note: grouping_planner won't have created this upperrel yet, but it's 
     * fine for us to create it first.  We will not have inserted the correct 
     * consider_parallel value in it, but MinMaxAggPath paths are currently 
     * never parallel-safe anyway, so that doesn't matter.  Likewise, it 
     * doesn't matter that we haven't filled FDW-related fields in the rel. 
     */ 
</span>    <a href="planagg.c.html#LN81"><span class='Ref_To_Local'>grouped_rel</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/pathnode.h.html#LN270"><span class='Ref_to_Proto'>fetch_upper_rel</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN74"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN73"><span class='Ref_to_EnumConst'>UPPERREL_GROUP_AGG</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/optimizer/pathnode.h.html#LN27"><span class='Ref_to_Proto'>add_path</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN81"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a> <span class='Operator'>*</span><span class='Parentheses'>)</span> 
             <a href="../../../include/optimizer/pathnode.h.html#LN201"><span class='Ref_to_Proto'>create_minmaxagg_path</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN74"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planagg.c.html#LN81"><span class='Ref_To_Local'>grouped_rel</span></a><span class='Delimiter'>, 
</span>                                   <a href="../../../include/optimizer/tlist.h.html#LN68"><span class='Ref_to_Macro'>create_pathtarget</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN74"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><a href="planagg.c.html#LN74"><span class='Ref_to_Parameter'>tlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                   <a href="planagg.c.html#LN80"><span class='Ref_To_Local'>aggs_list</span></a><span class='Delimiter'>, 
</span>                                   <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planagg.c.html#LN76"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN149"><span class='Ref_to_Member'>havingQual</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end preprocess_minmax_aggregates &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * find_minmax_aggs_walker 
 *      Recursively scan the Aggref nodes in an expression tree, and check 
 *      that each one is a MIN/MAX aggregate.  If so, build a list of the 
 *      distinct aggregate calls in the tree. 
 * 
 * Returns TRUE if a non-MIN/MAX aggregate is found, FALSE otherwise. 
 * (This seemingly-backward definition is used because expression_tree_walker 
 * aborts the scan on TRUE return, which is what we want.) 
 * 
 * Found aggregates are added to the list at *context; it's up to the caller 
 * to initialize the list to NIL. 
 * 
 * This does not descend into subqueries, and so should be used only after 
 * reduction of sublinks to subplans.  There mustn't be outer-aggregate 
 * references either. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN246"></a><span class='Declare_Function'>find_minmax_aggs_walker</span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>node</span><span class='Delimiter'>, </span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>**</span><span class='Declare_Parameter'>context</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planagg.c.html#LN246"><span class='Ref_to_Parameter'>node</span></a> <span class='Operator'>== </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN246"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a><span class='Parentheses'>))</span> 
    <span class='Delimiter'>{ 
</span><a name="LN252"></a>        <a href="../../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a>     <span class='Operator'>*</span><span class='Declare_Local'>aggref</span> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN290"><span class='Ref_to_Struct'>Aggref</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planagg.c.html#LN246"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>; 
</span><a name="LN253"></a>        <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>aggsortop</span><span class='Delimiter'>; 
</span><a name="LN254"></a>        <a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>curTarget</span><span class='Delimiter'>; 
</span><a name="LN255"></a>        <a href="../../../include/nodes/relation.h.html#LN2074"><span class='Ref_to_Struct'>MinMaxAggInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>mminfo</span><span class='Delimiter'>; 
</span><a name="LN256"></a>        <a href="../../../include/nodes/pg_list.h.html#LN52"><span class='Ref_to_Struct'>ListCell</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>l</span><span class='Delimiter'>; 
</span> 
        <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="planagg.c.html#LN252"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN308"><span class='Ref_to_Member'>agglevelsup</span></a> <span class='Operator'>== </span><span class='Number'>0</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN87"><span class='Ref_to_Func'>list_length</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN252"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN300"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>) </span><span class='Operator'>!= </span><span class='Number'>1</span><span class='Parentheses'>)</span> 
            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* it couldn't be MIN/MAX */ 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * ORDER BY is usually irrelevant for MIN/MAX, but it can change the 
         * outcome if the aggsortop's operator class recognizes non-identical 
         * values as equal.  For example, 4.0 and 4.00 are equal according to 
         * numeric_ops, yet distinguishable.  If MIN() receives more than one 
         * value equal to 4.0 and no value less than 4.0, it is unspecified 
         * which of those equal values MIN() returns.  An ORDER BY expression 
         * that differs for each of those equal values of the argument 
         * expression makes the result predictable once again.  This is a 
         * niche requirement, and we do not implement it with subquery paths. 
         * In any case, this test lets us reject ordered-set aggregates 
         * quickly. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planagg.c.html#LN252"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN301"><span class='Ref_to_Member'>aggorder</span></a> <span class='Operator'>!= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span>        <span class='Comment_Multi_Line'>/* note: we do not care if DISTINCT is mentioned ... */ 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We might implement the optimization when a FILTER clause is present 
         * by adding the filter to the quals of the generated subquery.  For 
         * now, just punt. 
         */ 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planagg.c.html#LN252"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN303"><span class='Ref_to_Member'>aggfilter</span></a> <span class='Operator'>!= </span><span class='Null_Value'>NULL</span><span class='Parentheses'>) 
</span>            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
</span> 
        <a href="planagg.c.html#LN253"><span class='Ref_To_Local'>aggsortop</span></a> <span class='Operator'>= </span><a href="planagg.c.html#LN53"><span class='Ref_to_Proto'>fetch_agg_sort_op</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN252"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN293"><span class='Ref_to_Member'>aggfnoid</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/c.h.html#LN537"><span class='Ref_to_Macro'>OidIsValid</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN253"><span class='Ref_To_Local'>aggsortop</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* not a MIN/MAX aggregate */ 
</span> 
        <a href="planagg.c.html#LN254"><span class='Ref_To_Local'>curTarget</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN110"><span class='Ref_to_Macro'>linitial</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN252"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN300"><span class='Ref_to_Member'>args</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/optimizer/clauses.h.html#LN59"><span class='Ref_to_Proto'>contain_mutable_functions</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planagg.c.html#LN254"><span class='Ref_To_Local'>curTarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Parentheses'>))</span> 
            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* not potentially indexable */ 
</span> 
        <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="../../../include/utils/lsyscache.h.html#LN150"><span class='Ref_to_Proto'>type_is_rowtype</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/nodeFuncs.h.html#LN31"><span class='Ref_to_Proto'>exprType</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planagg.c.html#LN254"><span class='Ref_To_Local'>curTarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Parentheses'>)))</span> 
            <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>;</span>        <span class='Comment_Single_Line'>/* IS NOT NULL would have weird semantics */ 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * Check whether it's already in the list, and add it if not. 
         */ 
</span>        <a href="../../../include/nodes/pg_list.h.html#LN160"><span class='Ref_to_Macro'>foreach</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN256"><span class='Ref_To_Local'>l</span></a><span class='Delimiter'>, </span><span class='Operator'>*</span><a href="planagg.c.html#LN246"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>) 
</span>        <span class='Delimiter'>{ 
</span>            <a href="planagg.c.html#LN255"><span class='Ref_To_Local'>mminfo</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN2074"><span class='Ref_to_Struct'>MinMaxAggInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/pg_list.h.html#LN105"><span class='Ref_to_Macro'>lfirst</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN256"><span class='Ref_To_Local'>l</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>            <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planagg.c.html#LN255"><span class='Ref_To_Local'>mminfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2078"><span class='Ref_to_Member'>aggfnoid</span></a> <span class='Operator'>== </span><a href="planagg.c.html#LN252"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN293"><span class='Ref_to_Member'>aggfnoid</span></a> <span class='Operator'>&& 
</span>                <a href="../../../include/nodes/nodes.h.html#LN626"><span class='Ref_to_Proto'>equal</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN255"><span class='Ref_To_Local'>mminfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2080"><span class='Ref_to_Member'>target</span></a><span class='Delimiter'>, </span><a href="planagg.c.html#LN254"><span class='Ref_To_Local'>curTarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Parentheses'>))</span> 
                <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>        <span class='Delimiter'>} 
</span> 
        <a href="planagg.c.html#LN255"><span class='Ref_To_Local'>mminfo</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN2074"><span class='Ref_to_Struct'>MinMaxAggInfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>        <a href="planagg.c.html#LN255"><span class='Ref_To_Local'>mminfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2078"><span class='Ref_to_Member'>aggfnoid</span></a> <span class='Operator'>= </span><a href="planagg.c.html#LN252"><span class='Ref_To_Local'>aggref</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN293"><span class='Ref_to_Member'>aggfnoid</span></a><span class='Delimiter'>; 
</span>        <a href="planagg.c.html#LN255"><span class='Ref_To_Local'>mminfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2079"><span class='Ref_to_Member'>aggsortop</span></a> <span class='Operator'>= </span><a href="planagg.c.html#LN253"><span class='Ref_To_Local'>aggsortop</span></a><span class='Delimiter'>; 
</span>        <a href="planagg.c.html#LN255"><span class='Ref_To_Local'>mminfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2080"><span class='Ref_to_Member'>target</span></a> <span class='Operator'>= </span><a href="planagg.c.html#LN254"><span class='Ref_To_Local'>curTarget</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1366"><span class='Ref_to_Member'>expr</span></a><span class='Delimiter'>; 
</span>        <a href="planagg.c.html#LN255"><span class='Ref_To_Local'>mminfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2081"><span class='Ref_to_Member'>subroot</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; </span><span class='Comment_Single_Line'>/* don't compute path yet */ 
</span>        <a href="planagg.c.html#LN255"><span class='Ref_To_Local'>mminfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2082"><span class='Ref_to_Member'>path</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>        <a href="planagg.c.html#LN255"><span class='Ref_To_Local'>mminfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2083"><span class='Ref_to_Member'>pathcost</span></a> <span class='Operator'>= </span><span class='Number'>0</span><span class='Delimiter'>; 
</span>        <a href="planagg.c.html#LN255"><span class='Ref_To_Local'>mminfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2084"><span class='Ref_to_Member'>param</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span> 
        <span class='Operator'>*</span><a href="planagg.c.html#LN246"><span class='Ref_to_Parameter'>context</span></a> <span class='Operator'>= </span><a href="../../nodes/list.c.html#LN126"><span class='Ref_to_Func'>lappend</span></a><span class='Parentheses'>(</span><span class='Operator'>*</span><a href="planagg.c.html#LN246"><span class='Ref_to_Parameter'>context</span></a><span class='Delimiter'>, </span><a href="planagg.c.html#LN255"><span class='Ref_To_Local'>mminfo</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
        <span class='Comment_Multi_Line'>/* 
         * We need not recurse into the argument, since it can't contain any 
         * aggregates. 
         */ 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <span class='Delimiter'>}</span><span class='Auto_Annotations'> &laquo; end if IsA(node,Aggref) &raquo; </span> 
    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/nodes.h.html#LN559"><span class='Ref_to_Macro'>IsA</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN246"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="../../../include/nodes/primnodes.h.html#LN629"><span class='Ref_to_Struct'>SubLink</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>return</span> <a href="../../../include/nodes/nodeFuncs.h.html#LN52"><span class='Ref_to_Proto'>expression_tree_walker</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN246"><span class='Ref_to_Parameter'>node</span></a><span class='Delimiter'>, </span><a href="planagg.c.html#LN49"><span class='Ref_to_Proto'>find_minmax_aggs_walker</span></a><span class='Delimiter'>, 
</span>                                  <span class='Parentheses'>(</span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planagg.c.html#LN246"><span class='Ref_to_Parameter'>context</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end find_minmax_aggs_walker &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * build_minmax_path 
 *      Given a MIN/MAX aggregate, try to build an indexscan Path it can be 
 *      optimized with. 
 * 
 * If successful, stash the best path in *mminfo and return TRUE. 
 * Otherwise, return FALSE. 
 */ 
</span><span class='Keyword'>static bool 
</span><a name="LN341"></a><span class='Declare_Function'>build_minmax_path</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><a href="../../../include/nodes/relation.h.html#LN2074"><span class='Ref_to_Struct'>MinMaxAggInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>mminfo</span><span class='Delimiter'>, 
</span><a name="LN342"></a>                  <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>eqop</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>sortop</span><span class='Delimiter'>, </span><span class='Keyword'>bool </span><span class='Declare_Parameter'>nulls_first</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN344"></a>    <a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>subroot</span><span class='Delimiter'>; 
</span><a name="LN345"></a>    <a href="../../../include/nodes/parsenodes.h.html#LN105"><span class='Ref_to_Struct'>Query</span></a>      <span class='Operator'>*</span><span class='Declare_Local'>parse</span><span class='Delimiter'>; 
</span><a name="LN346"></a>    <a href="../../../include/nodes/primnodes.h.html#LN1363"><span class='Ref_to_Struct'>TargetEntry</span></a> <span class='Operator'>*</span><span class='Declare_Local'>tle</span><span class='Delimiter'>; 
</span><a name="LN347"></a>    <a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>tlist</span><span class='Delimiter'>; 
</span><a name="LN348"></a>    <a href="../../../include/nodes/primnodes.h.html#LN1175"><span class='Ref_to_Struct'>NullTest</span></a>   <span class='Operator'>*</span><span class='Declare_Local'>ntest</span><span class='Delimiter'>; 
</span><a name="LN349"></a>    <a href="../../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a> <span class='Operator'>*</span><span class='Declare_Local'>sortcl</span><span class='Delimiter'>; 
</span><a name="LN350"></a>    <a href="../../../include/nodes/relation.h.html#LN517"><span class='Ref_to_Struct'>RelOptInfo</span></a> <span class='Operator'>*</span><span class='Declare_Local'>final_rel</span><span class='Delimiter'>; 
</span><a name="LN351"></a>    <a href="../../../include/nodes/relation.h.html#LN946"><span class='Ref_to_Struct'>Path</span></a>       <span class='Operator'>*</span><span class='Declare_Local'>sorted_path</span><span class='Delimiter'>; 
</span><a name="LN352"></a>    <a href="../../../include/nodes/nodes.h.html#LN638"><span class='Ref_to_Typedef'>Cost</span></a>        <span class='Declare_Local'>path_cost</span><span class='Delimiter'>; 
</span><a name="LN353"></a>    <span class='Keyword'>double</span>      <span class='Declare_Local'>path_fraction</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * We are going to construct what is effectively a sub-SELECT query, so 
     * clone the current query level's state and adjust it to make it look 
     * like a subquery.  Any outer references will now be one level higher 
     * than before.  (This means that when we are done, there will be no Vars 
     * of level 1, which is why the subquery can become an initplan.) 
     */ 
</span>    <a href="planagg.c.html#LN344"><span class='Ref_To_Local'>subroot</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/common/fe_memutils.h.html#LN33"><span class='Ref_to_Proto'>palloc</span></a><span class='Parentheses'>(</span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    memcpy<span class='Parentheses'>(</span><a href="planagg.c.html#LN344"><span class='Ref_To_Local'>subroot</span></a><span class='Delimiter'>, </span><a href="planagg.c.html#LN341"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, </span><span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <a href="planagg.c.html#LN344"><span class='Ref_To_Local'>subroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN158"><span class='Ref_to_Member'>query_level</span></a><span class='Operator'>++</span><span class='Delimiter'>; 
</span>    <a href="planagg.c.html#LN344"><span class='Ref_To_Local'>subroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN160"><span class='Ref_to_Member'>parent_root</span></a> <span class='Operator'>= </span><a href="planagg.c.html#LN341"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* reset subplan-related stuff */ 
</span>    <a href="planagg.c.html#LN344"><span class='Ref_To_Local'>subroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN168"><span class='Ref_to_Member'>plan_params</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="planagg.c.html#LN344"><span class='Ref_To_Local'>subroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN169"><span class='Ref_to_Member'>outer_params</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="planagg.c.html#LN344"><span class='Ref_To_Local'>subroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN227"><span class='Ref_to_Member'>init_plans</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
    <a href="planagg.c.html#LN344"><span class='Ref_To_Local'>subroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a> <span class='Operator'>= </span><a href="planagg.c.html#LN345"><span class='Ref_To_Local'>parse</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN618"><span class='Ref_to_Macro'>copyObject</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN341"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/rewrite/rewriteManip.h.html#LN44"><span class='Ref_to_Proto'>IncrementVarSublevelsUp</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planagg.c.html#LN345"><span class='Ref_To_Local'>parse</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* append_rel_list might contain outer Vars? */ 
</span>    <a href="planagg.c.html#LN344"><span class='Ref_To_Local'>subroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN251"><span class='Ref_to_Member'>append_rel_list</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN618"><span class='Ref_to_Macro'>copyObject</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN341"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN251"><span class='Ref_to_Member'>append_rel_list</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/rewrite/rewriteManip.h.html#LN44"><span class='Ref_to_Proto'>IncrementVarSublevelsUp</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planagg.c.html#LN344"><span class='Ref_To_Local'>subroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN251"><span class='Ref_to_Member'>append_rel_list</span></a><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Delimiter'>, </span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* There shouldn't be any OJ info to translate, as yet */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="planagg.c.html#LN344"><span class='Ref_To_Local'>subroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN249"><span class='Ref_to_Member'>join_info_list</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* and we haven't made equivalence classes, either */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="planagg.c.html#LN344"><span class='Ref_To_Local'>subroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN234"><span class='Ref_to_Member'>eq_classes</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* and we haven't created PlaceHolderInfos, either */ 
</span>    <span class='Debug'>Assert</span><span class='Parentheses'>(</span><a href="planagg.c.html#LN344"><span class='Ref_To_Local'>subroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN257"><span class='Ref_to_Member'>placeholder_list</span></a> <span class='Operator'>== </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/*---------- 
     * Generate modified query of the form 
     *      (SELECT col FROM tab 
     *       WHERE col IS NOT NULL AND existing-quals 
     *       ORDER BY col ASC/DESC 
     *       LIMIT 1) 
     *---------- 
     */ 
</span>    <span class='Comment_Multi_Line'>/* single tlist entry that is the aggregate target */ 
</span>    <a href="planagg.c.html#LN346"><span class='Ref_To_Local'>tle</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/makefuncs.h.html#LN40"><span class='Ref_to_Proto'>makeTargetEntry</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN618"><span class='Ref_to_Macro'>copyObject</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN341"><span class='Ref_to_Parameter'>mminfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2080"><span class='Ref_to_Member'>target</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                          <span class='Parentheses'>(</span><a href="../../../include/access/attnum.h.html#LN20"><span class='Ref_to_Typedef'>AttrNumber</span></a><span class='Parentheses'>) </span><span class='Number'>1</span><span class='Delimiter'>, 
</span>                          <a href="../../../include/common/fe_memutils.h.html#LN32"><span class='Ref_to_Proto'>pstrdup</span></a><span class='Parentheses'>(</span><span class='String'>"agg_target"</span><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                          <span class='Boolean'>false</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="planagg.c.html#LN347"><span class='Ref_To_Local'>tlist</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN138"><span class='Ref_to_Macro'>list_make1</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN346"><span class='Ref_To_Local'>tle</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="planagg.c.html#LN344"><span class='Ref_To_Local'>subroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN280"><span class='Ref_to_Member'>processed_tlist</span></a> <span class='Operator'>= </span><a href="planagg.c.html#LN345"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a> <span class='Operator'>= </span><a href="planagg.c.html#LN347"><span class='Ref_To_Local'>tlist</span></a><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* No HAVING, no DISTINCT, no aggregates anymore */ 
</span>    <a href="planagg.c.html#LN345"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN149"><span class='Ref_to_Member'>havingQual</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="planagg.c.html#LN344"><span class='Ref_To_Local'>subroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN301"><span class='Ref_to_Member'>hasHavingQual</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="planagg.c.html#LN345"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN153"><span class='Ref_to_Member'>distinctClause</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="planagg.c.html#LN345"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN126"><span class='Ref_to_Member'>hasDistinctOn</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="planagg.c.html#LN345"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN122"><span class='Ref_to_Member'>hasAggs</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Build "target IS NOT NULL" expression */ 
</span>    <a href="planagg.c.html#LN348"><span class='Ref_To_Local'>ntest</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/primnodes.h.html#LN1175"><span class='Ref_to_Struct'>NullTest</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="planagg.c.html#LN348"><span class='Ref_To_Local'>ntest</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1179"><span class='Ref_to_Member'>nulltesttype</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/primnodes.h.html#LN1172"><span class='Ref_to_EnumConst'>IS_NOT_NULL</span></a><span class='Delimiter'>; 
</span>    <a href="planagg.c.html#LN348"><span class='Ref_To_Local'>ntest</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1178"><span class='Ref_to_Member'>arg</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN618"><span class='Ref_to_Macro'>copyObject</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN341"><span class='Ref_to_Parameter'>mminfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2080"><span class='Ref_to_Member'>target</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Comment_Multi_Line'>/* we checked it wasn't a rowtype in find_minmax_aggs_walker */ 
</span>    <a href="planagg.c.html#LN348"><span class='Ref_To_Local'>ntest</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1180"><span class='Ref_to_Member'>argisrow</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>; 
</span>    <a href="planagg.c.html#LN348"><span class='Ref_To_Local'>ntest</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1181"><span class='Ref_to_Member'>location</span></a> <span class='Operator'>= -</span><span class='Number'>1</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* User might have had that in WHERE already */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/nodes/pg_list.h.html#LN228"><span class='Ref_to_Proto'>list_member</span></a><span class='Parentheses'>((</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planagg.c.html#LN345"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN135"><span class='Ref_to_Member'>jointree</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1470"><span class='Ref_to_Member'>quals</span></a><span class='Delimiter'>, </span><a href="planagg.c.html#LN348"><span class='Ref_To_Local'>ntest</span></a><span class='Parentheses'>))</span> 
        <a href="planagg.c.html#LN345"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN135"><span class='Ref_to_Member'>jointree</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1470"><span class='Ref_to_Member'>quals</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) 
</span>            <a href="../../../include/nodes/pg_list.h.html#LN215"><span class='Ref_to_Proto'>lcons</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN348"><span class='Ref_To_Local'>ntest</span></a><span class='Delimiter'>, </span><span class='Parentheses'>(</span><a href="../../../include/nodes/pg_list.h.html#LN44"><span class='Ref_to_Struct'>List</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="planagg.c.html#LN345"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN135"><span class='Ref_to_Member'>jointree</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/primnodes.h.html#LN1470"><span class='Ref_to_Member'>quals</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Build suitable ORDER BY clause */ 
</span>    <a href="planagg.c.html#LN349"><span class='Ref_To_Local'>sortcl</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/nodes.h.html#LN556"><span class='Ref_to_Macro'>makeNode</span></a><span class='Parentheses'>(</span><a href="../../../include/nodes/parsenodes.h.html#LN1161"><span class='Ref_to_Struct'>SortGroupClause</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="planagg.c.html#LN349"><span class='Ref_To_Local'>sortcl</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1164"><span class='Ref_to_Member'>tleSortGroupRef</span></a> <span class='Operator'>= </span><a href="../../../include/parser/parse_clause.h.html#LN50"><span class='Ref_to_Proto'>assignSortGroupRef</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN346"><span class='Ref_To_Local'>tle</span></a><span class='Delimiter'>, </span><a href="planagg.c.html#LN347"><span class='Ref_To_Local'>tlist</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="planagg.c.html#LN349"><span class='Ref_To_Local'>sortcl</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1165"><span class='Ref_to_Member'>eqop</span></a> <span class='Operator'>= </span><a href="planagg.c.html#LN342"><span class='Ref_to_Parameter'>eqop</span></a><span class='Delimiter'>; 
</span>    <a href="planagg.c.html#LN349"><span class='Ref_To_Local'>sortcl</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1166"><span class='Ref_to_Member'>sortop</span></a> <span class='Operator'>= </span><a href="planagg.c.html#LN342"><span class='Ref_to_Parameter'>sortop</span></a><span class='Delimiter'>; 
</span>    <a href="planagg.c.html#LN349"><span class='Ref_To_Local'>sortcl</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1167"><span class='Ref_to_Member'>nulls_first</span></a> <span class='Operator'>= </span><a href="planagg.c.html#LN342"><span class='Ref_to_Parameter'>nulls_first</span></a><span class='Delimiter'>; 
</span>    <a href="planagg.c.html#LN349"><span class='Ref_To_Local'>sortcl</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN1168"><span class='Ref_to_Member'>hashable</span></a> <span class='Operator'>= </span><span class='Boolean'>false</span><span class='Delimiter'>;</span>   <span class='Comment_Single_Line'>/* no need to make this accurate */ 
</span>    <a href="planagg.c.html#LN345"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN155"><span class='Ref_to_Member'>sortClause</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN138"><span class='Ref_to_Macro'>list_make1</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN349"><span class='Ref_To_Local'>sortcl</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* set up expressions for LIMIT 1 */ 
</span>    <a href="planagg.c.html#LN345"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN157"><span class='Ref_to_Member'>limitOffset</span></a> <span class='Operator'>= </span><span class='Null_Value'>NULL</span><span class='Delimiter'>; 
</span>    <a href="planagg.c.html#LN345"><span class='Ref_To_Local'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN158"><span class='Ref_to_Member'>limitCount</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/nodes/nodes.h.html#LN508"><span class='Ref_to_Struct'>Node</span></a> <span class='Operator'>*</span><span class='Parentheses'>) </span><a href="../../../include/nodes/makefuncs.h.html#LN49"><span class='Ref_to_Proto'>makeConst</span></a><span class='Parentheses'>(</span><a href="../../../interfaces/ecpg/ecpglib/pg_type.h.html#LN21"><span class='Ref_to_Const'>INT8OID</span></a><span class='Delimiter'>, </span><span class='Operator'>-</span><span class='Number'>1</span><span class='Delimiter'>, </span><a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>, 
</span>                                           <span class='Keyword'>sizeof</span><span class='Parentheses'>(</span><a href="../../../include/c.h.html#LN294"><span class='Ref_to_Typedef'>int64</span></a><span class='Parentheses'>)</span><span class='Delimiter'>, 
</span>                                           <a href="../../../include/postgres.h.html#LN624"><span class='Ref_to_Macro'>Int64GetDatum</span></a><span class='Parentheses'>(</span><span class='Number'>1</span><span class='Parentheses'>)</span><span class='Delimiter'>, </span><span class='Boolean'>false</span><span class='Delimiter'>, 
</span>                                           FLOAT8PASSBYVAL<span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Generate the best paths for this query, telling query_planner that we 
     * have LIMIT 1. 
     */ 
</span>    <a href="planagg.c.html#LN344"><span class='Ref_To_Local'>subroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN290"><span class='Ref_to_Member'>tuple_fraction</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span>    <a href="planagg.c.html#LN344"><span class='Ref_To_Local'>subroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN291"><span class='Ref_to_Member'>limit_tuples</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <a href="planagg.c.html#LN350"><span class='Ref_To_Local'>final_rel</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/planmain.h.html#LN38"><span class='Ref_to_Proto'>query_planner</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN344"><span class='Ref_To_Local'>subroot</span></a><span class='Delimiter'>, </span><a href="planagg.c.html#LN347"><span class='Ref_To_Local'>tlist</span></a><span class='Delimiter'>, </span><a href="planagg.c.html#LN52"><span class='Ref_to_Proto'>minmax_qp_callback</span></a><span class='Delimiter'>, </span><span class='Null_Value'>NULL</span><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Since we didn't go through subquery_planner() to handle the subquery, 
     * we have to do some of the same cleanup it would do, in particular cope 
     * with params and initplans used within this subquery.  (This won't 
     * matter if we end up not using the subplan.) 
     */ 
</span>    <a href="../../../include/optimizer/subselect.h.html#LN27"><span class='Ref_to_Proto'>SS_identify_outer_params</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN344"><span class='Ref_To_Local'>subroot</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="../../../include/optimizer/subselect.h.html#LN28"><span class='Ref_to_Proto'>SS_charge_for_initplans</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN344"><span class='Ref_To_Local'>subroot</span></a><span class='Delimiter'>, </span><a href="planagg.c.html#LN350"><span class='Ref_To_Local'>final_rel</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Get the best presorted path, that being the one that's cheapest for 
     * fetching just one row.  If there's no such path, fail. 
     */ 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><a href="planagg.c.html#LN350"><span class='Ref_To_Local'>final_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a> <span class='Operator'>&GT; </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Parentheses'>) 
</span>        <a href="planagg.c.html#LN353"><span class='Ref_To_Local'>path_fraction</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span> <span class='Operator'>/ </span><a href="planagg.c.html#LN350"><span class='Ref_To_Local'>final_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN527"><span class='Ref_to_Member'>rows</span></a><span class='Delimiter'>; 
</span>    <span class='Control'>else</span> 
        <a href="planagg.c.html#LN353"><span class='Ref_To_Local'>path_fraction</span></a> <span class='Operator'>= </span><span class='Number'>1</span><span class='Operator'>.</span><span class='Number'>0</span><span class='Delimiter'>; 
</span> 
    <a href="planagg.c.html#LN351"><span class='Ref_To_Local'>sorted_path</span></a> <span class='Operator'>= 
</span>        <a href="../../../include/optimizer/paths.h.html#LN188"><span class='Ref_to_Proto'>get_cheapest_fractional_path_for_pathkeys</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN350"><span class='Ref_To_Local'>final_rel</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN538"><span class='Ref_to_Member'>pathlist</span></a><span class='Delimiter'>, 
</span>                                                  <a href="planagg.c.html#LN344"><span class='Ref_To_Local'>subroot</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN261"><span class='Ref_to_Member'>query_pathkeys</span></a><span class='Delimiter'>, 
</span>                                                  <span class='Null_Value'>NULL</span><span class='Delimiter'>, 
</span>                                                  <a href="planagg.c.html#LN353"><span class='Ref_To_Local'>path_fraction</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="planagg.c.html#LN351"><span class='Ref_To_Local'>sorted_path</span></a><span class='Parentheses'>) 
</span>        <span class='Control'>return</span> <span class='Boolean'>false</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * The path might not return exactly what we want, so fix that.  (We 
     * assume that this won't change any conclusions about which was the 
     * cheapest path.) 
     */ 
</span>    <a href="planagg.c.html#LN351"><span class='Ref_To_Local'>sorted_path</span></a> <span class='Operator'>= </span><a href="../../../include/optimizer/pathnode.h.html#LN157"><span class='Ref_to_Proto'>apply_projection_to_path</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN344"><span class='Ref_To_Local'>subroot</span></a><span class='Delimiter'>, </span><a href="planagg.c.html#LN350"><span class='Ref_To_Local'>final_rel</span></a><span class='Delimiter'>, </span><a href="planagg.c.html#LN351"><span class='Ref_To_Local'>sorted_path</span></a><span class='Delimiter'>, 
</span>                                           <a href="../../../include/optimizer/tlist.h.html#LN68"><span class='Ref_to_Macro'>create_pathtarget</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN344"><span class='Ref_To_Local'>subroot</span></a><span class='Delimiter'>, </span><a href="planagg.c.html#LN347"><span class='Ref_To_Local'>tlist</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* 
     * Determine cost to get just the first row of the presorted path. 
     * 
     * Note: cost calculation here should match 
     * compare_fractional_path_costs(). 
     */ 
</span>    <a href="planagg.c.html#LN352"><span class='Ref_To_Local'>path_cost</span></a> <span class='Operator'>= </span><a href="planagg.c.html#LN351"><span class='Ref_To_Local'>sorted_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a> <span class='Operator'>+ 
</span>        <a href="planagg.c.html#LN353"><span class='Ref_To_Local'>path_fraction</span></a> <span class='Operator'>* </span><span class='Parentheses'>(</span><a href="planagg.c.html#LN351"><span class='Ref_To_Local'>sorted_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN965"><span class='Ref_to_Member'>total_cost</span></a> <span class='Operator'>- </span><a href="planagg.c.html#LN351"><span class='Ref_To_Local'>sorted_path</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN964"><span class='Ref_to_Member'>startup_cost</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* Save state for further processing */ 
</span>    <a href="planagg.c.html#LN341"><span class='Ref_to_Parameter'>mminfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2081"><span class='Ref_to_Member'>subroot</span></a> <span class='Operator'>= </span><a href="planagg.c.html#LN344"><span class='Ref_To_Local'>subroot</span></a><span class='Delimiter'>; 
</span>    <a href="planagg.c.html#LN341"><span class='Ref_to_Parameter'>mminfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2082"><span class='Ref_to_Member'>path</span></a> <span class='Operator'>= </span><a href="planagg.c.html#LN351"><span class='Ref_To_Local'>sorted_path</span></a><span class='Delimiter'>; 
</span>    <a href="planagg.c.html#LN341"><span class='Ref_to_Parameter'>mminfo</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN2083"><span class='Ref_to_Member'>pathcost</span></a> <span class='Operator'>= </span><a href="planagg.c.html#LN352"><span class='Ref_To_Local'>path_cost</span></a><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <span class='Boolean'>true</span><span class='Delimiter'>; 
}</span><span class='Auto_Annotations'> &laquo; end build_minmax_path &raquo; </span> 
 
<span class='Comment_Multi_Line'>/* 
 * Compute query_pathkeys and other pathkeys during query_planner() 
 */ 
</span><span class='Keyword'>static void 
</span><a name="LN500"></a><span class='Declare_Function'>minmax_qp_callback</span><span class='Parentheses'>(</span><a href="../../../include/nodes/relation.h.html#LN150"><span class='Ref_to_Struct'>PlannerInfo</span></a> <span class='Operator'>*</span><span class='Declare_Parameter'>root</span><span class='Delimiter'>, </span><span class='Keyword'>void </span><span class='Operator'>*</span><span class='Declare_Parameter'>extra</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span>    <a href="planagg.c.html#LN500"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN263"><span class='Ref_to_Member'>group_pathkeys</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="planagg.c.html#LN500"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN264"><span class='Ref_to_Member'>window_pathkeys</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span>    <a href="planagg.c.html#LN500"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN265"><span class='Ref_to_Member'>distinct_pathkeys</span></a> <span class='Operator'>= </span><a href="../../../include/nodes/pg_list.h.html#LN68"><span class='Ref_to_Const'>NIL</span></a><span class='Delimiter'>; 
</span> 
    <a href="planagg.c.html#LN500"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN266"><span class='Ref_to_Member'>sort_pathkeys</span></a> <span class='Operator'>= 
</span>        <a href="../../../include/optimizer/paths.h.html#LN205"><span class='Ref_to_Proto'>make_pathkeys_for_sortclauses</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN500"><span class='Ref_to_Parameter'>root</span></a><span class='Delimiter'>, 
</span>                                      <a href="planagg.c.html#LN500"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN155"><span class='Ref_to_Member'>sortClause</span></a><span class='Delimiter'>, 
</span>                                      <a href="planagg.c.html#LN500"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN154"><span class='Ref_to_Member'>parse</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/parsenodes.h.html#LN137"><span class='Ref_to_Member'>targetList</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <a href="planagg.c.html#LN500"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN261"><span class='Ref_to_Member'>query_pathkeys</span></a> <span class='Operator'>= </span><a href="planagg.c.html#LN500"><span class='Ref_to_Parameter'>root</span></a><span class='Operator'>-&GT;</span><a href="../../../include/nodes/relation.h.html#LN266"><span class='Ref_to_Member'>sort_pathkeys</span></a><span class='Delimiter'>; 
} 
</span> 
<span class='Comment_Multi_Line'>/* 
 * Get the OID of the sort operator, if any, associated with an aggregate. 
 * Returns InvalidOid if there is no such operator. 
 */ 
</span><span class='Keyword'>static </span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> 
<a name="LN519"></a><span class='Declare_Function'>fetch_agg_sort_op</span><span class='Parentheses'>(</span><a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a> <span class='Declare_Parameter'>aggfnoid</span><span class='Parentheses'>) 
</span><span class='Delimiter'>{ 
</span><a name="LN521"></a>    <a href="../../../include/access/htup.h.html#LN69"><span class='Ref_to_Typedef'>HeapTuple</span></a>   <span class='Declare_Local'>aggTuple</span><span class='Delimiter'>; 
</span><a name="LN522"></a>    <a href="../../../include/catalog/pg_aggregate.h.html#LN86"><span class='Ref_to_Typedef'>Form_pg_aggregate</span></a> <span class='Declare_Local'>aggform</span><span class='Delimiter'>; 
</span><a name="LN523"></a>    <a href="../../../include/postgres_ext.h.html#LN30"><span class='Ref_to_Typedef'>Oid</span></a>         <span class='Declare_Local'>aggsortop</span><span class='Delimiter'>; 
</span> 
    <span class='Comment_Multi_Line'>/* fetch aggregate entry from pg_aggregate */ 
</span>    <a href="planagg.c.html#LN521"><span class='Ref_To_Local'>aggTuple</span></a> <span class='Operator'>= </span><a href="../../../include/utils/syscache.h.html#LN155"><span class='Ref_to_Macro'>SearchSysCache1</span></a><span class='Parentheses'>(</span><a href="../../../include/utils/syscache.h.html#LN33"><span class='Ref_to_EnumConst'>AGGFNOID</span></a><span class='Delimiter'>, </span><a href="../../../include/postgres.h.html#LN512"><span class='Ref_to_Macro'>ObjectIdGetDatum</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN519"><span class='Ref_to_Parameter'>aggfnoid</span></a><span class='Parentheses'>))</span><span class='Delimiter'>; 
</span>    <span class='Control'>if</span> <span class='Parentheses'>(</span><span class='Operator'>!</span><a href="../../../include/access/htup.h.html#LN76"><span class='Ref_to_Macro'>HeapTupleIsValid</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN521"><span class='Ref_To_Local'>aggTuple</span></a><span class='Parentheses'>))</span> 
        <span class='Control'>return</span> <a href="../../../include/postgres_ext.h.html#LN33"><span class='Ref_to_Const'>InvalidOid</span></a><span class='Delimiter'>; 
</span>    <a href="planagg.c.html#LN522"><span class='Ref_To_Local'>aggform</span></a> <span class='Operator'>= </span><span class='Parentheses'>(</span><a href="../../../include/catalog/pg_aggregate.h.html#LN86"><span class='Ref_to_Typedef'>Form_pg_aggregate</span></a><span class='Parentheses'>) </span><a href="../../../include/access/htup_details.h.html#LN655"><span class='Ref_to_Macro'>GETSTRUCT</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN521"><span class='Ref_To_Local'>aggTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span>    <a href="planagg.c.html#LN523"><span class='Ref_To_Local'>aggsortop</span></a> <span class='Operator'>= </span><a href="planagg.c.html#LN522"><span class='Ref_To_Local'>aggform</span></a><span class='Operator'>-&GT;</span>aggsortop<span class='Delimiter'>; 
</span>    <a href="../../../include/utils/syscache.h.html#LN119"><span class='Ref_to_Proto'>ReleaseSysCache</span></a><span class='Parentheses'>(</span><a href="planagg.c.html#LN521"><span class='Ref_To_Local'>aggTuple</span></a><span class='Parentheses'>)</span><span class='Delimiter'>; 
</span> 
    <span class='Control'>return</span> <a href="planagg.c.html#LN523"><span class='Ref_To_Local'>aggsortop</span></a><span class='Delimiter'>; 
} 
</span></pre>
<table bgcolor='#c0c0c0' width='100%'><tr><td><a href='../../../../Contents.html'>Contents</a></td></tr>
</table><hr><p class='blurb' align='center'><a href='http://www.sourceinsight.com'>HTML Created by Source Insight Version 4.00.0084 Built on 2017-02-26</a></p>
</body></html>